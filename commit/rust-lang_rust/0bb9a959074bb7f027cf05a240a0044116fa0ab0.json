{"sha": "0bb9a959074bb7f027cf05a240a0044116fa0ab0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYjlhOTU5MDc0YmI3ZjAyN2NmMDVhMjQwYTAwNDQxMTZmYTBhYjA=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-11T03:37:34Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-11T03:37:34Z"}, "message": "Merge branch 'master' into redox", "tree": {"sha": "69fca65cd12f30f97f8bcfd403b39577f2ce3c57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69fca65cd12f30f97f8bcfd403b39577f2ce3c57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bb9a959074bb7f027cf05a240a0044116fa0ab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb9a959074bb7f027cf05a240a0044116fa0ab0", "html_url": "https://github.com/rust-lang/rust/commit/0bb9a959074bb7f027cf05a240a0044116fa0ab0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bb9a959074bb7f027cf05a240a0044116fa0ab0/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25e1a4a0084a56807d7a1e4ca676e078c085b3aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/25e1a4a0084a56807d7a1e4ca676e078c085b3aa", "html_url": "https://github.com/rust-lang/rust/commit/25e1a4a0084a56807d7a1e4ca676e078c085b3aa"}, {"sha": "1473007618e6ab85a994f86348acdaf125b7914f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1473007618e6ab85a994f86348acdaf125b7914f", "html_url": "https://github.com/rust-lang/rust/commit/1473007618e6ab85a994f86348acdaf125b7914f"}], "stats": {"total": 61565, "additions": 52992, "deletions": 8573}, "files": [{"sha": "1d4c6252f2c7503ddf6b6861250e31530d53f119", "filename": ".gitattributes", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -7,3 +7,4 @@\n src/etc/pkg/rust-logo.ico binary\n src/etc/pkg/rust-logo.png binary\n *.woff binary\n+src/vendor/* binary"}, {"sha": "bf66eabc1c800bd44ca12ed1932995bf8ca3955f", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -98,3 +98,4 @@ tmp.*.rs\n version.md\n version.ml\n version.texi\n+.cargo"}, {"sha": "144329caa71aa8c1afb018e24bf7bda37a7edde6", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -15,7 +15,7 @@ before_install:\n script:\n   - docker run -v `pwd`:/build rust\n     sh -c \"\n-      ./configure --enable-rustbuild --llvm-root=/usr/lib/llvm-3.7 --enable-quiet-tests &&\n+      ./configure --enable-vendor --enable-rustbuild --llvm-root=/usr/lib/llvm-3.7 --enable-quiet-tests &&\n       make tidy &&\n       make check -j4\n     \""}, {"sha": "7360651095bb581d01a575b071c7a91ba8db7585", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -127,7 +127,7 @@ ones from MSYS if you have it installed). You'll also need Visual Studio 2013 or\n newer with the C++ tools. Then all you need to do is to kick off rustbuild.\n \n ```\n-python .\\src\\bootstrap\\bootstrap.py\n+python x.py build\n ```\n \n Currently rustbuild only works with some known versions of Visual Studio. If you\n@@ -137,7 +137,7 @@ by manually calling the appropriate vcvars file before running the bootstrap.\n \n ```\n CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.bat\"\n-python .\\src\\bootstrap\\bootstrap.py\n+python x.py build\n ```\n \n ## Building Documentation"}, {"sha": "222ad3aa112af8e93b0ffd713f0aa5fd605adee6", "filename": "RELEASES.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -1,3 +1,30 @@\n+Version 1.12.1 (2016-10-20)\n+===========================\n+\n+Regression Fixes\n+----------------\n+\n+* [ICE: 'rustc' panicked at 'assertion failed: concrete_substs.is_normalized_for_trans()' #36381][36381]\n+* [Confusion with double negation and booleans][36856]\n+* [rustc 1.12.0 fails with SIGSEGV in release mode (syn crate 0.8.0)][36875]\n+* [Rustc 1.12.0 Windows build of `ethcore` crate fails with LLVM error][36924]\n+* [1.12.0: High memory usage when linking in release mode with debug info][36926]\n+* [Corrupted memory after updated to 1.12][36936]\n+* [\"Let NullaryConstructor = something;\" causes internal compiler error: \"tried to overwrite interned AdtDef\"][37026]\n+* [Fix ICE: inject bitcast if types mismatch for invokes/calls/stores][37112]\n+* [debuginfo: Handle spread_arg case in MIR-trans in a more stable way.][37153]\n+\n+[36381]: https://github.com/rust-lang/rust/issues/36381\n+[36856]: https://github.com/rust-lang/rust/issues/36856\n+[36875]: https://github.com/rust-lang/rust/issues/36875\n+[36924]: https://github.com/rust-lang/rust/issues/36924\n+[36926]: https://github.com/rust-lang/rust/issues/36926\n+[36936]: https://github.com/rust-lang/rust/issues/36936\n+[37026]: https://github.com/rust-lang/rust/issues/37026\n+[37112]: https://github.com/rust-lang/rust/issues/37112\n+[37153]: https://github.com/rust-lang/rust/issues/37153\n+\n+\n Version 1.12.0 (2016-09-29)\n ===========================\n "}, {"sha": "9c055e7217aa329d63a6697780a4df5de645116a", "filename": "configure", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/configure", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -634,6 +634,7 @@ opt rustbuild 0 \"use the rust and cargo based build system\"\n opt codegen-tests 1 \"run the src/test/codegen tests\"\n opt option-checking 1 \"complain about unrecognized options in this configure script\"\n opt ninja 0 \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\"\n+opt vendor 0 \"enable usage of vendored Rust crates\"\n \n # Optimization and debugging options. These may be overridden by the release channel, etc.\n opt_nosave optimize 1 \"build optimized rust code\"\n@@ -868,13 +869,6 @@ then\n     fi\n fi\n \n-if [ -n \"$CFG_GDB\" ]\n-then\n-    # Store GDB's version\n-    CFG_GDB_VERSION=$($CFG_GDB --version 2>/dev/null | head -1)\n-    putvar CFG_GDB_VERSION\n-fi\n-\n if [ -n \"$CFG_LLDB\" ]\n then\n     # Store LLDB's version"}, {"sha": "238ba8acee42f894fb7aaae3648de1a5d0d91e65", "filename": "mk/dist.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -65,7 +65,8 @@ PKG_FILES := \\\n       stage0.txt                               \\\n       rust-installer                           \\\n       tools                                    \\\n-      test)                                    \\\n+      test                                     \\\n+      vendor)                                  \\\n     $(PKG_GITMODULES)                          \\\n     $(filter-out config.stamp, \\\n                  $(MKFILES_FOR_TARBALL))"}, {"sha": "2fa8ccf3621e0c1f59ec2d9cc549af603b82158a", "filename": "mk/main.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -372,7 +372,7 @@ CFG_INFO := $(info cfg: disabling unstable features (CFG_DISABLE_UNSTABLE_FEATUR\n # Turn on feature-staging\n export CFG_DISABLE_UNSTABLE_FEATURES\n # Subvert unstable feature lints to do the self-build\n-export RUSTC_BOOTSTRAP\n+export RUSTC_BOOTSTRAP=1\n endif\n ifdef CFG_MUSL_ROOT\n export CFG_MUSL_ROOT"}, {"sha": "f3d8f0387bbd6367bcacdd7576ede0b576b564bb", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -648,7 +648,7 @@ CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3) = \\\n         --host $(3) \\\n \t--docck-python $$(CFG_PYTHON) \\\n \t--lldb-python $$(CFG_LLDB_PYTHON) \\\n-        --gdb-version=\"$(CFG_GDB_VERSION)\" \\\n+        --gdb=\"$(CFG_GDB)\" \\\n         --lldb-version=\"$(CFG_LLDB_VERSION)\" \\\n         --llvm-version=\"$$(LLVM_VERSION_$(3))\" \\\n         --android-cross-path=$(CFG_ARM_LINUX_ANDROIDEABI_NDK) \\"}, {"sha": "d3517175d4cedb9309e14c64a5cf9171685c54a0", "filename": "src/Cargo.lock", "status": "modified", "additions": 4, "deletions": 79, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -40,17 +40,15 @@ name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.38 (git+https://github.com/alexcrichton/gcc-rs)\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -63,7 +61,7 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cmake\"\n-version = \"0.1.17\"\n+version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -131,11 +129,6 @@ dependencies = [\n name = \"fmt_macros\"\n version = \"0.0.0\"\n \n-[[package]]\n-name = \"gcc\"\n-version = \"0.3.38\"\n-source = \"git+https://github.com/alexcrichton/gcc-rs#be620ac6d3ddb498cd0c700d5312c6a4c3c19597\"\n-\n [[package]]\n name = \"gcc\"\n version = \"0.3.38\"\n@@ -154,25 +147,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"graphviz\"\n version = \"0.0.0\"\n \n-[[package]]\n-name = \"idna\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-bidi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-normalization 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"kernel32-sys\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"libc\"\n version = \"0.0.0\"\n@@ -188,9 +162,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"linkchecker\"\n version = \"0.1.0\"\n-dependencies = [\n- \"url 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n name = \"log\"\n@@ -201,11 +172,6 @@ name = \"log\"\n version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"matches\"\n-version = \"0.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"md5\"\n version = \"0.1.1\"\n@@ -710,56 +676,15 @@ dependencies = [\n  \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"unicode-bidi\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"unicode-normalization\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"url\"\n-version = \"1.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"winapi\"\n-version = \"0.2.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi-build\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [metadata]\n-\"checksum cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dfcf5bcece56ef953b8ea042509e9dcbdfe97820b7e20d86beb53df30ed94978\"\n+\"checksum cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e5bcf27e097a184c1df4437654ed98df3d7a516e8508a6ba45d8b092bbdf283\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.38 (git+https://github.com/alexcrichton/gcc-rs)\" = \"<none>\"\n \"checksum gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\" = \"553f11439bdefe755bf366b264820f1da70f3aaf3924e594b886beb9c831bcf5\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n-\"checksum idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1053236e00ce4f668aeca4a769a09b3bf5a682d802abd6f3cb39374f6b162c11\"\n-\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"044d1360593a78f5c8e5e710beccdc24ab71d1f01bc19a29bcacdba22e8475d8\"\n \"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\"\n-\"checksum matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcc3ad8109fa4b522f9b0cd81440422781f564aaf8c195de6b9d6642177ad0dd\"\n \"checksum md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a5539a8dee9b4ae308c9c406a379838b435a8f2c84cf9fedc6d5a576be9888db\"\n \"checksum num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cee7e88156f3f9e19bdd598f8d6c9db7bf4078f99f8381f43a55b09648d1a6e3\"\n \"checksum rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6159e4e6e559c81bd706afe9c8fd68f547d3e851ce12e76b1de7914bab61691b\"\n \"checksum toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0590d72182e50e879c4da3b11c6488dae18fccb1ae0c7a3eda18e16795844796\"\n-\"checksum unicode-bidi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c1f7ceb96afdfeedee42bade65a0d585a6a0106f681b6749c8ff4daa8df30b3f\"\n-\"checksum unicode-normalization 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"26643a2f83bac55f1976fb716c10234485f9202dcd65cfbdf9da49867b271172\"\n-\"checksum url 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ba5a45db1d2e0effb7a1c00cc73ffc63a973da8c7d1fcd5b46f24285ade6c54\"\n-\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n-\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "4c9b578c1349d9de291516207d8f0c7e75deae0c", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -27,10 +27,6 @@ num_cpus = \"0.2\"\n toml = \"0.1\"\n getopts = \"0.2\"\n rustc-serialize = \"0.3\"\n-gcc = { git = \"https://github.com/alexcrichton/gcc-rs\" }\n+gcc = \"0.3.38\"\n libc = \"0.2\"\n md5 = \"0.1\"\n-\n-[target.'cfg(windows)'.dependencies]\n-winapi = \"0.2\"\n-kernel32-sys = \"0.2\""}, {"sha": "f73f41ffae29df50716f05e79b207ff759a88465", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 59, "deletions": 11, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -10,24 +10,72 @@ system.\n \n ## Using rustbuild\n \n-When configuring Rust via `./configure`, pass the following to enable building\n-via this build system:\n+The rustbuild build system has a primary entry point, a top level `x.py` script:\n \n ```\n-./configure --enable-rustbuild\n-make\n+python ./x.py build\n ```\n \n-Afterwards the `Makefile` which is generated will have a few commands like\n-`make check`, `make tidy`, etc. For finer-grained control, the\n-`bootstrap.py` entry point can be used:\n+Note that if you're on Unix you should be able to execute the script directly:\n \n ```\n-python src/bootstrap/bootstrap.py\n+./x.py build\n ```\n \n-This accepts a number of options like `--stage` and `--step` which can configure\n-what's actually being done.\n+The script accepts commands, flags, and filters to determine what to do:\n+\n+* `build` - a general purpose command for compiling code. Alone `build` will\n+  bootstrap the entire compiler, and otherwise arguments passed indicate what to\n+  build. For example:\n+\n+  ```\n+  # build the whole compiler\n+  ./x.py build\n+\n+  # build the stage1 compier\n+  ./x.py build --stage 1\n+\n+  # build stage0 libstd\n+  ./x.py build --stage 0 src/libstd\n+\n+  # build a particular crate in stage0\n+  ./x.py build --stage 0 src/libtest\n+  ```\n+\n+* `test` - a command for executing unit tests. Like the `build` command this\n+  will execute the entire test suite by default, and otherwise it can be used to\n+  select which test suite is run:\n+\n+  ```\n+  # run all unit tests\n+  ./x.py test\n+\n+  # execute the run-pass test suite\n+  ./x.py test src/test/run-pass\n+\n+  # execute only some tests in the run-pass test suite\n+  ./x.py test src/test/run-pass --filter my-filter\n+\n+  # execute tests in the standard library in stage0\n+  ./x.py test --stage 0 src/libstd\n+\n+  # execute all doc tests\n+  ./x.py test src/doc\n+  ```\n+\n+* `doc` - a command for building documentation. Like above can take arguments\n+  for what to document.\n+\n+If you're more used to `./configure` and `make`, however, then you can also\n+configure the build system to use rustbuild instead of the old makefiles:\n+\n+```\n+./configure --enable-rustbuild\n+make\n+```\n+\n+Afterwards the `Makefile` which is generated will have a few commands like\n+`make check`, `make tidy`, etc.\n \n ## Configuring rustbuild\n \n@@ -47,7 +95,7 @@ being invoked manually (via the python script).\n The rustbuild build system goes through a few phases to actually build the\n compiler. What actually happens when you invoke rustbuild is:\n \n-1. The entry point script, `src/bootstrap/bootstrap.py` is run. This script is\n+1. The entry point script, `x.py` is run. This script is\n    responsible for downloading the stage0 compiler/Cargo binaries, and it then\n    compiles the build system itself (this folder). Finally, it then invokes the\n    actual `bootstrap` binary build system."}, {"sha": "08a8ca5a631303a2e772420d77ea061a1afceb4d", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -259,9 +259,11 @@ def build_bootstrap(self):\n         env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\")\n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n                       os.pathsep + env[\"PATH\"]\n-        self.run([self.cargo(), \"build\", \"--manifest-path\",\n-                  os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")],\n-                 env)\n+        args = [self.cargo(), \"build\", \"--manifest-path\",\n+                os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")]\n+        if self.use_vendored_sources:\n+            args.append(\"--frozen\")\n+        self.run(args, env)\n \n     def run(self, args, env):\n         proc = subprocess.Popen(args, env=env)\n@@ -344,6 +346,22 @@ def build_triple(self):\n             ostype += 'eabihf'\n         elif cputype == 'aarch64':\n             cputype = 'aarch64'\n+        elif cputype == 'mips':\n+            if sys.byteorder == 'big':\n+                cputype = 'mips'\n+            elif sys.byteorder == 'little':\n+                cputype = 'mipsel'\n+            else:\n+                raise ValueError('unknown byteorder: ' + sys.byteorder)\n+        elif cputype == 'mips64':\n+            if sys.byteorder == 'big':\n+                cputype = 'mips64'\n+            elif sys.byteorder == 'little':\n+                cputype = 'mips64el'\n+            else:\n+                raise ValueError('unknown byteorder: ' + sys.byteorder)\n+            # only the n64 ABI is supported, indicate it\n+            ostype += 'abi64'\n         elif cputype in {'powerpc', 'ppc', 'ppc64'}:\n             cputype = 'powerpc'\n         elif cputype in {'amd64', 'x86_64', 'x86-64', 'x64'}:\n@@ -384,6 +402,25 @@ def main():\n     except:\n         pass\n \n+    rb.use_vendored_sources = '\\nvendor = true' in rb.config_toml or \\\n+                              'CFG_ENABLE_VENDOR' in rb.config_mk\n+\n+    if rb.use_vendored_sources:\n+        if not os.path.exists('.cargo'):\n+            os.makedirs('.cargo')\n+        f = open('.cargo/config','w')\n+        f.write(\"\"\"\n+            [source.crates-io]\n+            replace-with = 'vendored-sources'\n+            registry = 'https://example.com'\n+\n+            [source.vendored-sources]\n+            directory = '{}/src/vendor'\n+        \"\"\".format(rb.rust_root))\n+        f.close()\n+    else:\n+        if os.path.exists('.cargo'):\n+            shutil.rmtree('.cargo')\n     data = stage0_data(rb.rust_root)\n     rb._rustc_channel, rb._rustc_date = data['rustc'].split('-', 1)\n     rb._cargo_channel, rb._cargo_date = data['cargo'].split('-', 1)\n@@ -399,12 +436,10 @@ def main():\n \n     # Run the bootstrap\n     args = [os.path.join(rb.build_dir, \"bootstrap/debug/bootstrap\")]\n-    args.append('--src')\n-    args.append(rb.rust_root)\n-    args.append('--build')\n-    args.append(rb.build)\n     args.extend(sys.argv[1:])\n     env = os.environ.copy()\n+    env[\"BUILD\"] = rb.build\n+    env[\"SRC\"] = rb.rust_root\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     rb.run(args, env)\n "}, {"sha": "f27f9641036c7c4c2cf06d853b67699dd9d7d788", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 30, "deletions": 69, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -13,44 +13,19 @@\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashSet;\n use std::env;\n use std::fs;\n use std::path::{PathBuf, Path};\n use std::process::Command;\n \n use build_helper::output;\n-use rustc_serialize::json;\n \n use {Build, Compiler, Mode};\n use util::{self, dylib_path, dylib_path_var};\n \n const ADB_TEST_DIR: &'static str = \"/data/tmp\";\n \n-#[derive(RustcDecodable)]\n-struct Output {\n-    packages: Vec<Package>,\n-    resolve: Resolve,\n-}\n-\n-#[derive(RustcDecodable)]\n-struct Package {\n-    id: String,\n-    name: String,\n-    source: Option<String>,\n-}\n-\n-#[derive(RustcDecodable)]\n-struct Resolve {\n-    nodes: Vec<ResolveNode>,\n-}\n-\n-#[derive(RustcDecodable)]\n-struct ResolveNode {\n-    id: String,\n-    dependencies: Vec<String>,\n-}\n-\n /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n ///\n /// This tool in `src/tools` will verify the validity of all our links in the\n@@ -168,8 +143,8 @@ pub fn compiletest(build: &Build,\n         cmd.arg(\"--lldb-python\").arg(python_default);\n     }\n \n-    if let Some(ref vers) = build.gdb_version {\n-        cmd.arg(\"--gdb-version\").arg(vers);\n+    if let Some(ref gdb) = build.config.gdb {\n+        cmd.arg(\"--gdb\").arg(gdb);\n     }\n     if let Some(ref vers) = build.lldb_version {\n         cmd.arg(\"--lldb-version\").arg(vers);\n@@ -181,7 +156,7 @@ pub fn compiletest(build: &Build,\n     let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n     cmd.arg(\"--llvm-version\").arg(llvm_version);\n \n-    cmd.args(&build.flags.args);\n+    cmd.args(&build.flags.cmd.test_args());\n \n     if build.config.verbose || build.flags.verbose {\n         cmd.arg(\"--verbose\");\n@@ -267,7 +242,9 @@ pub fn docs(build: &Build, compiler: &Compiler) {\n pub fn error_index(build: &Build, compiler: &Compiler) {\n     println!(\"Testing error-index stage{}\", compiler.stage);\n \n-    let output = testdir(build, compiler.host).join(\"error-index.md\");\n+    let dir = testdir(build, compiler.host);\n+    t!(fs::create_dir_all(&dir));\n+    let output = dir.join(\"error-index.md\");\n     build.run(build.tool_cmd(compiler, \"error_index_generator\")\n                    .arg(\"markdown\")\n                    .arg(&output)\n@@ -282,7 +259,7 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n \n-    let mut test_args = build.flags.args.join(\" \");\n+    let mut test_args = build.flags.cmd.test_args().join(\" \");\n     if build.config.quiet_tests {\n         test_args.push_str(\" --quiet\");\n     }\n@@ -302,7 +279,8 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n pub fn krate(build: &Build,\n              compiler: &Compiler,\n              target: &str,\n-             mode: Mode) {\n+             mode: Mode,\n+             krate: Option<&str>) {\n     let (name, path, features, root) = match mode {\n         Mode::Libstd => {\n             (\"libstd\", \"src/rustc/std_shim\", build.std_features(), \"std_shim\")\n@@ -318,24 +296,6 @@ pub fn krate(build: &Build,\n     println!(\"Testing {} stage{} ({} -> {})\", name, compiler.stage,\n              compiler.host, target);\n \n-    // Run `cargo metadata` to figure out what crates we're testing.\n-    //\n-    // Down below we're going to call `cargo test`, but to test the right set\n-    // of packages we're going to have to know what `-p` arguments to pass it\n-    // to know what crates to test. Here we run `cargo metadata` to learn about\n-    // the dependency graph and what `-p` arguments there are.\n-    let mut cargo = Command::new(&build.cargo);\n-    cargo.arg(\"metadata\")\n-         .arg(\"--manifest-path\").arg(build.src.join(path).join(\"Cargo.toml\"));\n-    let output = output(&mut cargo);\n-    let output: Output = json::decode(&output).unwrap();\n-    let id2pkg = output.packages.iter()\n-                        .map(|pkg| (&pkg.id, pkg))\n-                        .collect::<HashMap<_, _>>();\n-    let id2deps = output.resolve.nodes.iter()\n-                        .map(|node| (&node.id, &node.dependencies))\n-                        .collect::<HashMap<_, _>>();\n-\n     // Build up the base `cargo test` command.\n     //\n     // Pass in some standard flags then iterate over the graph we've discovered\n@@ -346,24 +306,25 @@ pub fn krate(build: &Build,\n          .arg(build.src.join(path).join(\"Cargo.toml\"))\n          .arg(\"--features\").arg(features);\n \n-    let mut visited = HashSet::new();\n-    let root_pkg = output.packages.iter().find(|p| p.name == root).unwrap();\n-    let mut next = vec![&root_pkg.id];\n-    while let Some(id) = next.pop() {\n-        // Skip any packages with sources listed, as these come from crates.io\n-        // and we shouldn't be testing them.\n-        if id2pkg[id].source.is_some() {\n-            continue\n-        }\n-        // Right now jemalloc is our only target-specific crate in the sense\n-        // that it's not present on all platforms. Custom skip it here for now,\n-        // but if we add more this probably wants to get more generalized.\n-        if !id.contains(\"jemalloc\") {\n-            cargo.arg(\"-p\").arg(&id2pkg[id].name);\n+    match krate {\n+        Some(krate) => {\n+            cargo.arg(\"-p\").arg(krate);\n         }\n-        for dep in id2deps[id] {\n-            if visited.insert(dep) {\n-                next.push(dep);\n+        None => {\n+            let mut visited = HashSet::new();\n+            let mut next = vec![root];\n+            while let Some(name) = next.pop() {\n+                // Right now jemalloc is our only target-specific crate in the sense\n+                // that it's not present on all platforms. Custom skip it here for now,\n+                // but if we add more this probably wants to get more generalized.\n+                if !name.contains(\"jemalloc\") {\n+                    cargo.arg(\"-p\").arg(name);\n+                }\n+                for dep in build.crates[name].deps.iter() {\n+                    if visited.insert(dep) {\n+                        next.push(dep);\n+                    }\n+                }\n             }\n         }\n     }\n@@ -389,7 +350,7 @@ pub fn krate(build: &Build,\n         build.run(cargo.arg(\"--no-run\"));\n         krate_emscripten(build, compiler, target, mode);\n     } else {\n-        cargo.args(&build.flags.args);\n+        cargo.args(&build.flags.cmd.test_args());\n         build.run(&mut cargo);\n     }\n }\n@@ -421,7 +382,7 @@ fn krate_android(build: &Build,\n                               target = target,\n                               test = test_file_name,\n                               log = log,\n-                              args = build.flags.args.join(\" \"));\n+                              args = build.flags.cmd.test_args().join(\" \"));\n \n         let output = output(Command::new(\"adb\").arg(\"shell\").arg(&program));\n         println!(\"{}\", output);"}, {"sha": "75bcbfee6ee0b3e119f037baa95f75d0b2e70fd6", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -16,6 +16,7 @@\n //! directory as we want that cached between builds.\n \n use std::fs;\n+use std::io::{self, ErrorKind};\n use std::path::Path;\n \n use Build;\n@@ -25,24 +26,58 @@ pub fn clean(build: &Build) {\n     rm_rf(build, &build.out.join(\"tmp\"));\n \n     for host in build.config.host.iter() {\n+        let entries = match build.out.join(host).read_dir() {\n+            Ok(iter) => iter,\n+            Err(_) => continue,\n+        };\n \n-        let out = build.out.join(host);\n+        for entry in entries {\n+            let entry = t!(entry);\n+            if entry.file_name().to_str() == Some(\"llvm\") {\n+                continue\n+            }\n+            let path = t!(entry.path().canonicalize());\n+            rm_rf(build, &path);\n+        }\n+    }\n+}\n \n-        rm_rf(build, &out.join(\"doc\"));\n+fn rm_rf(build: &Build, path: &Path) {\n+    if !path.exists() {\n+        return\n+    }\n \n-        for stage in 0..4 {\n-            rm_rf(build, &out.join(format!(\"stage{}\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-std\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-rustc\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-tools\", stage)));\n-            rm_rf(build, &out.join(format!(\"stage{}-test\", stage)));\n+    for file in t!(fs::read_dir(path)) {\n+        let file = t!(file).path();\n+\n+        if file.is_dir() {\n+            rm_rf(build, &file);\n+        } else {\n+            // On windows we can't remove a readonly file, and git will\n+            // often clone files as readonly. As a result, we have some\n+            // special logic to remove readonly files on windows.\n+            do_op(&file, \"remove file\", |p| fs::remove_file(p));\n         }\n     }\n+    do_op(path, \"remove dir\", |p| fs::remove_dir(p));\n }\n \n-fn rm_rf(build: &Build, path: &Path) {\n-    if path.exists() {\n-        build.verbose(&format!(\"removing `{}`\", path.display()));\n-        t!(fs::remove_dir_all(path));\n+fn do_op<F>(path: &Path, desc: &str, mut f: F)\n+    where F: FnMut(&Path) -> io::Result<()>\n+{\n+    match f(path) {\n+        Ok(()) => {}\n+        Err(ref e) if cfg!(windows) &&\n+                      e.kind() == ErrorKind::PermissionDenied => {\n+            let mut p = t!(path.metadata()).permissions();\n+            p.set_readonly(false);\n+            t!(fs::set_permissions(path, p));\n+            f(path).unwrap_or_else(|e| {\n+                panic!(\"failed to {} {}: {}\", desc, path.display(), e);\n+            })\n+        }\n+        Err(e) => {\n+            panic!(\"failed to {} {}: {}\", desc, path.display(), e);\n+        }\n     }\n }"}, {"sha": "5fc4f006729d3e6e397c25d0113ddc35af7b4593", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -64,8 +64,8 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     }\n \n     build.run(&mut cargo);\n-    update_mtime(&libstd_stamp(build, compiler, target));\n-    std_link(build, target, compiler, compiler.host);\n+    update_mtime(&libstd_stamp(build, &compiler, target));\n+    std_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all libstd rlibs/dylibs into the sysroot location.\n@@ -74,11 +74,12 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n /// by `compiler` into `host`'s sysroot.\n pub fn std_link(build: &Build,\n                 target: &str,\n-                compiler: &Compiler,\n+                stage: u32,\n                 host: &str) {\n+    let compiler = Compiler::new(stage, &build.config.build);\n     let target_compiler = Compiler::new(compiler.stage, host);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n-    let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n+    let out_dir = build.cargo_out(&compiler, Mode::Libstd, target);\n \n     // If we're linking one compiler host's output into another, then we weren't\n     // called from the `std` method above. In that case we clean out what's\n@@ -146,7 +147,7 @@ pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n          .arg(build.src.join(\"src/rustc/test_shim/Cargo.toml\"));\n     build.run(&mut cargo);\n     update_mtime(&libtest_stamp(build, compiler, target));\n-    test_link(build, target, compiler, compiler.host);\n+    test_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all libtest rlibs/dylibs into the sysroot location.\n@@ -155,11 +156,12 @@ pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n /// by `compiler` into `host`'s sysroot.\n pub fn test_link(build: &Build,\n                  target: &str,\n-                 compiler: &Compiler,\n+                 stage: u32,\n                  host: &str) {\n+    let compiler = Compiler::new(stage, &build.config.build);\n     let target_compiler = Compiler::new(compiler.stage, host);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n-    let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n+    let out_dir = build.cargo_out(&compiler, Mode::Libtest, target);\n     add_to_sysroot(&out_dir, &libdir);\n }\n \n@@ -218,7 +220,7 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     }\n     build.run(&mut cargo);\n \n-    rustc_link(build, target, compiler, compiler.host);\n+    rustc_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all librustc rlibs/dylibs into the sysroot location.\n@@ -227,11 +229,12 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n /// by `compiler` into `host`'s sysroot.\n pub fn rustc_link(build: &Build,\n                   target: &str,\n-                  compiler: &Compiler,\n+                  stage: u32,\n                   host: &str) {\n+    let compiler = Compiler::new(stage, &build.config.build);\n     let target_compiler = Compiler::new(compiler.stage, host);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n-    let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n+    let out_dir = build.cargo_out(&compiler, Mode::Librustc, target);\n     add_to_sysroot(&out_dir, &libdir);\n }\n \n@@ -259,7 +262,10 @@ fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n /// must have been previously produced by the `stage - 1` build.config.build\n /// compiler.\n pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n-    assert!(stage > 0, \"the stage0 compiler isn't assembled, it's downloaded\");\n+    // nothing to do in stage0\n+    if stage == 0 {\n+        return\n+    }\n     // The compiler that we're assembling\n     let target_compiler = Compiler::new(stage, host);\n "}, {"sha": "9a939fee43e8bcf06d2b8789a6b0e421fcce2e8a", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -23,6 +23,7 @@ use std::process;\n use num_cpus;\n use rustc_serialize::Decodable;\n use toml::{Parser, Decoder, Value};\n+use util::push_exe_path;\n \n /// Global configuration for the entire build and/or bootstrap.\n ///\n@@ -43,6 +44,7 @@ pub struct Config {\n     pub submodules: bool,\n     pub compiler_docs: bool,\n     pub docs: bool,\n+    pub vendor: bool,\n     pub target_config: HashMap<String, Target>,\n \n     // llvm codegen options\n@@ -86,6 +88,7 @@ pub struct Config {\n     pub mandir: Option<String>,\n     pub codegen_tests: bool,\n     pub nodejs: Option<PathBuf>,\n+    pub gdb: Option<PathBuf>,\n }\n \n /// Per-target configuration stored in the global configuration structure.\n@@ -123,6 +126,8 @@ struct Build {\n     compiler_docs: Option<bool>,\n     docs: Option<bool>,\n     submodules: Option<bool>,\n+    gdb: Option<String>,\n+    vendor: Option<bool>,\n }\n \n /// TOML representation of how the LLVM build is configured.\n@@ -227,9 +232,11 @@ impl Config {\n         }\n         config.rustc = build.rustc.map(PathBuf::from);\n         config.cargo = build.cargo.map(PathBuf::from);\n+        config.gdb = build.gdb.map(PathBuf::from);\n         set(&mut config.compiler_docs, build.compiler_docs);\n         set(&mut config.docs, build.docs);\n         set(&mut config.submodules, build.submodules);\n+        set(&mut config.vendor, build.vendor);\n \n         if let Some(ref llvm) = toml.llvm {\n             set(&mut config.ccache, llvm.ccache);\n@@ -343,6 +350,7 @@ impl Config {\n                 (\"LOCAL_REBUILD\", self.local_rebuild),\n                 (\"NINJA\", self.ninja),\n                 (\"CODEGEN_TESTS\", self.codegen_tests),\n+                (\"VENDOR\", self.vendor),\n             }\n \n             match key {\n@@ -356,44 +364,47 @@ impl Config {\n                                        .collect();\n                 }\n                 \"CFG_MUSL_ROOT\" if value.len() > 0 => {\n-                    self.musl_root = Some(PathBuf::from(value));\n+                    self.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_X86_64\" if value.len() > 0 => {\n                     let target = \"x86_64-unknown-linux-musl\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.musl_root = Some(PathBuf::from(value));\n+                    target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_I686\" if value.len() > 0 => {\n                     let target = \"i686-unknown-linux-musl\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.musl_root = Some(PathBuf::from(value));\n+                    target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_ARM\" if value.len() > 0 => {\n                     let target = \"arm-unknown-linux-musleabi\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.musl_root = Some(PathBuf::from(value));\n+                    target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_ARMHF\" if value.len() > 0 => {\n                     let target = \"arm-unknown-linux-musleabihf\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.musl_root = Some(PathBuf::from(value));\n+                    target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_ARMV7\" if value.len() > 0 => {\n                     let target = \"armv7-unknown-linux-musleabihf\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.musl_root = Some(PathBuf::from(value));\n+                    target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_DEFAULT_AR\" if value.len() > 0 => {\n                     self.rustc_default_ar = Some(value.to_string());\n                 }\n                 \"CFG_DEFAULT_LINKER\" if value.len() > 0 => {\n                     self.rustc_default_linker = Some(value.to_string());\n                 }\n+                \"CFG_GDB\" if value.len() > 0 => {\n+                    self.gdb = Some(parse_configure_path(value));\n+                }\n                 \"CFG_RELEASE_CHANNEL\" => {\n                     self.channel = value.to_string();\n                 }\n@@ -412,48 +423,73 @@ impl Config {\n                 \"CFG_LLVM_ROOT\" if value.len() > 0 => {\n                     let target = self.target_config.entry(self.build.clone())\n                                      .or_insert(Target::default());\n-                    let root = PathBuf::from(value);\n-                    target.llvm_config = Some(root.join(\"bin/llvm-config\"));\n+                    let root = parse_configure_path(value);\n+                    target.llvm_config = Some(push_exe_path(root, &[\"bin\", \"llvm-config\"]));\n                 }\n                 \"CFG_JEMALLOC_ROOT\" if value.len() > 0 => {\n                     let target = self.target_config.entry(self.build.clone())\n                                      .or_insert(Target::default());\n-                    target.jemalloc = Some(PathBuf::from(value));\n+                    target.jemalloc = Some(parse_configure_path(value));\n                 }\n                 \"CFG_ARM_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n                     let target = \"arm-linux-androideabi\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.ndk = Some(PathBuf::from(value));\n+                    target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_ARMV7_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n                     let target = \"armv7-linux-androideabi\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.ndk = Some(PathBuf::from(value));\n+                    target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_I686_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n                     let target = \"i686-linux-android\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.ndk = Some(PathBuf::from(value));\n+                    target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_AARCH64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n                     let target = \"aarch64-linux-android\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n-                    target.ndk = Some(PathBuf::from(value));\n+                    target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_LOCAL_RUST_ROOT\" if value.len() > 0 => {\n-                    self.rustc = Some(PathBuf::from(value).join(\"bin/rustc\"));\n-                    self.cargo = Some(PathBuf::from(value).join(\"bin/cargo\"));\n+                    let path = parse_configure_path(value);\n+                    self.rustc = Some(push_exe_path(path.clone(), &[\"bin\", \"rustc\"]));\n+                    self.cargo = Some(push_exe_path(path, &[\"bin\", \"cargo\"]));\n                 }\n                 _ => {}\n             }\n         }\n     }\n }\n \n+#[cfg(not(windows))]\n+fn parse_configure_path(path: &str) -> PathBuf {\n+    path.into()\n+}\n+\n+#[cfg(windows)]\n+fn parse_configure_path(path: &str) -> PathBuf {\n+    // on windows, configure produces unix style paths e.g. /c/some/path but we\n+    // only want real windows paths\n+\n+    use std::process::Command;\n+    use build_helper;\n+\n+    // '/' is invalid in windows paths, so we can detect unix paths by the presence of it\n+    if !path.contains('/') {\n+        return path.into();\n+    }\n+\n+    let win_path = build_helper::output(Command::new(\"cygpath\").arg(\"-w\").arg(path));\n+    let win_path = win_path.trim();\n+\n+    win_path.into()\n+}\n+\n fn set<T>(field: &mut T, val: Option<T>) {\n     if let Some(v) = val {\n         *field = v;"}, {"sha": "306708f9e4b68444ad4e9012d2d101c7a14456bc", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -79,6 +79,12 @@\n # Indicate whether submodules are managed and updated automatically.\n #submodules = true\n \n+# The path to (or name of) the GDB executable to use\n+#gdb = \"gdb\"\n+\n+# Indicate whether the vendored sources are used for Rust dependencies or not\n+#vendor = false\n+\n # =============================================================================\n # Options for compiling Rust code itself\n # ============================================================================="}, {"sha": "30c7fefad87453bedfbfd4855aa50346c0e66a67", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -19,7 +19,6 @@\n \n use std::fs::{self, File};\n use std::io::prelude::*;\n-use std::path::Path;\n use std::process::Command;\n \n use {Build, Compiler, Mode};\n@@ -30,8 +29,9 @@ use util::{up_to_date, cp_r};\n ///\n /// This will not actually generate any documentation if the documentation has\n /// already been generated.\n-pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str, out: &Path) {\n-    t!(fs::create_dir_all(out));\n+pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str) {\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n \n     let out = out.join(name);\n     let compiler = Compiler::new(stage, &build.config.build);\n@@ -57,9 +57,10 @@ pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str, out: &Path)\n /// `STAMP` alongw ith providing the various header/footer HTML we've cutomized.\n ///\n /// In the end, this is just a glorified wrapper around rustdoc!\n-pub fn standalone(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn standalone(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} standalone ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n \n     let compiler = Compiler::new(stage, &build.config.build);\n \n@@ -109,7 +110,7 @@ pub fn standalone(build: &Build, stage: u32, target: &str, out: &Path) {\n            .arg(\"--html-in-header\").arg(&favicon)\n            .arg(\"--markdown-playground-url\")\n            .arg(\"https://play.rust-lang.org/\")\n-           .arg(\"-o\").arg(out)\n+           .arg(\"-o\").arg(&out)\n            .arg(&path);\n \n         if filename == \"reference.md\" {\n@@ -131,9 +132,10 @@ pub fn standalone(build: &Build, stage: u32, target: &str, out: &Path) {\n ///\n /// This will generate all documentation for the standard library and its\n /// dependencies. This is largely just a wrapper around `cargo doc`.\n-pub fn std(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn std(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} std ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let out_dir = build.stage_out(&compiler, Mode::Libstd)\n                        .join(target).join(\"doc\");\n@@ -146,16 +148,17 @@ pub fn std(build: &Build, stage: u32, target: &str, out: &Path) {\n          .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"))\n          .arg(\"--features\").arg(build.std_features());\n     build.run(&mut cargo);\n-    cp_r(&out_dir, out)\n+    cp_r(&out_dir, &out)\n }\n \n /// Compile all libtest documentation.\n ///\n /// This will generate all documentation for libtest and its dependencies. This\n /// is largely just a wrapper around `cargo doc`.\n-pub fn test(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn test(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} test ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let out_dir = build.stage_out(&compiler, Mode::Libtest)\n                        .join(target).join(\"doc\");\n@@ -167,16 +170,17 @@ pub fn test(build: &Build, stage: u32, target: &str, out: &Path) {\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/test_shim/Cargo.toml\"));\n     build.run(&mut cargo);\n-    cp_r(&out_dir, out)\n+    cp_r(&out_dir, &out)\n }\n \n /// Generate all compiler documentation.\n ///\n /// This will generate all documentation for the compiler libraries and their\n /// dependencies. This is largely just a wrapper around `cargo doc`.\n-pub fn rustc(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn rustc(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} compiler ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let out_dir = build.stage_out(&compiler, Mode::Librustc)\n                        .join(target).join(\"doc\");\n@@ -189,14 +193,15 @@ pub fn rustc(build: &Build, stage: u32, target: &str, out: &Path) {\n          .arg(build.src.join(\"src/rustc/Cargo.toml\"))\n          .arg(\"--features\").arg(build.rustc_features());\n     build.run(&mut cargo);\n-    cp_r(&out_dir, out)\n+    cp_r(&out_dir, &out)\n }\n \n /// Generates the HTML rendered error-index by running the\n /// `error_index_generator` tool.\n-pub fn error_index(build: &Build, stage: u32, target: &str, out: &Path) {\n+pub fn error_index(build: &Build, stage: u32, target: &str) {\n     println!(\"Documenting stage{} error index ({})\", stage, target);\n-    t!(fs::create_dir_all(out));\n+    let out = build.doc_out(target);\n+    t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let mut index = build.tool_cmd(&compiler, \"error_index_generator\");\n     index.arg(\"html\");"}, {"sha": "d7516954f12d50fe20c0dfb4f1a8e9d2892f7dc1", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 202, "deletions": 37, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -13,60 +13,224 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n+use std::env;\n use std::fs;\n use std::path::PathBuf;\n use std::process;\n-use std::slice;\n \n-use getopts::Options;\n+use getopts::{Matches, Options};\n+\n+use Build;\n+use config::Config;\n+use metadata;\n+use step;\n \n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n     pub verbose: bool,\n     pub stage: Option<u32>,\n     pub build: String,\n-    pub host: Filter,\n-    pub target: Filter,\n-    pub step: Vec<String>,\n+    pub host: Vec<String>,\n+    pub target: Vec<String>,\n     pub config: Option<PathBuf>,\n     pub src: Option<PathBuf>,\n     pub jobs: Option<u32>,\n-    pub args: Vec<String>,\n-    pub clean: bool,\n+    pub cmd: Subcommand,\n }\n \n-pub struct Filter {\n-    values: Vec<String>,\n+pub enum Subcommand {\n+    Build {\n+        paths: Vec<PathBuf>,\n+    },\n+    Doc {\n+        paths: Vec<PathBuf>,\n+    },\n+    Test {\n+        paths: Vec<PathBuf>,\n+        test_args: Vec<String>,\n+    },\n+    Clean,\n+    Dist {\n+        install: bool,\n+    },\n }\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n         let mut opts = Options::new();\n         opts.optflag(\"v\", \"verbose\", \"use verbose output\");\n         opts.optopt(\"\", \"config\", \"TOML configuration file for build\", \"FILE\");\n+        opts.optopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n         opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n-        opts.reqopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n-        opts.optmulti(\"\", \"target\", \"targets to build\", \"TARGET\");\n-        opts.optmulti(\"s\", \"step\", \"build step to execute\", \"STEP\");\n+        opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n-        opts.optopt(\"\", \"src\", \"path to repo root\", \"DIR\");\n+        opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n-        opts.optflag(\"\", \"clean\", \"clean output directory\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n \n-        let usage = |n| -> ! {\n-            let brief = format!(\"Usage: rust.py [options]\");\n-            print!(\"{}\", opts.usage(&brief));\n+        let usage = |n, opts: &Options| -> ! {\n+            let command = args.get(0).map(|s| &**s);\n+            let brief = format!(\"Usage: x.py {} [options] [<args>...]\",\n+                                command.unwrap_or(\"<command>\"));\n+\n+            println!(\"{}\", opts.usage(&brief));\n+            match command {\n+                Some(\"build\") => {\n+                    println!(\"\\\n+Arguments:\n+    This subcommand accepts a number of positional arguments of directories to\n+    the crates and/or artifacts to compile. For example:\n+\n+        ./x.py build src/libcore\n+        ./x.py build src/libproc_macro\n+        ./x.py build src/libstd --stage 1\n+\n+    If no arguments are passed then the complete artifacts for that stage are\n+    also compiled.\n+\n+        ./x.py build\n+        ./x.py build --stage 1\n+\n+    For a quick build with a usable compile, you can pass:\n+\n+        ./x.py build --stage 1 src/libtest\n+\");\n+                }\n+\n+                Some(\"test\") => {\n+                    println!(\"\\\n+Arguments:\n+    This subcommand accepts a number of positional arguments of directories to\n+    tests that should be compiled and run. For example:\n+\n+        ./x.py test src/test/run-pass\n+        ./x.py test src/test/run-pass/assert-*\n+        ./x.py test src/libstd --test-args hash_map\n+        ./x.py test src/libstd --stage 0\n+\n+    If no arguments are passed then the complete artifacts for that stage are\n+    compiled and tested.\n+\n+        ./x.py test\n+        ./x.py test --stage 1\n+\");\n+                }\n+\n+                Some(\"doc\") => {\n+                    println!(\"\\\n+Arguments:\n+    This subcommand accepts a number of positional arguments of directories of\n+    documentation to build. For example:\n+\n+        ./x.py doc src/doc/book\n+        ./x.py doc src/doc/nomicon\n+        ./x.py doc src/libstd\n+\n+    If no arguments are passed then everything is documented:\n+\n+        ./x.py doc\n+        ./x.py doc --stage 1\n+\");\n+                }\n+\n+                _ => {}\n+            }\n+\n+            if let Some(command) = command {\n+                if command == \"build\" ||\n+                   command == \"dist\" ||\n+                   command == \"doc\" ||\n+                   command == \"test\" ||\n+                   command == \"clean\"  {\n+                    println!(\"Available invocations:\");\n+                    if args.iter().any(|a| a == \"-v\") {\n+                        let flags = Flags::parse(&[\"build\".to_string()]);\n+                        let mut config = Config::default();\n+                        config.build = flags.build.clone();\n+                        let mut build = Build::new(flags, config);\n+                        metadata::build(&mut build);\n+                        step::build_rules(&build).print_help(command);\n+                    } else {\n+                        println!(\"    ... elided, run `./x.py {} -h -v` to see\",\n+                                 command);\n+                    }\n+\n+                    println!(\"\");\n+                }\n+            }\n+\n+println!(\"\\\n+Subcommands:\n+    build       Compile either the compiler or libraries\n+    test        Build and run some test suites\n+    doc         Build documentation\n+    clean       Clean out build directories\n+    dist        Build and/or install distribution artifacts\n+\n+To learn more about a subcommand, run `./x.py <command> -h`\n+\");\n+\n             process::exit(n);\n         };\n-\n-        let m = opts.parse(args).unwrap_or_else(|e| {\n-            println!(\"failed to parse options: {}\", e);\n-            usage(1);\n-        });\n-        if m.opt_present(\"h\") {\n-            usage(0);\n+        if args.len() == 0 {\n+            println!(\"a command must be passed\");\n+            usage(1, &opts);\n         }\n+        let parse = |opts: &Options| {\n+            let m = opts.parse(&args[1..]).unwrap_or_else(|e| {\n+                println!(\"failed to parse options: {}\", e);\n+                usage(1, opts);\n+            });\n+            if m.opt_present(\"h\") {\n+                usage(0, opts);\n+            }\n+            return m\n+        };\n+\n+        let cwd = t!(env::current_dir());\n+        let remaining_as_path = |m: &Matches| {\n+            m.free.iter().map(|p| cwd.join(p)).collect::<Vec<_>>()\n+        };\n+\n+        let m: Matches;\n+        let cmd = match &args[0][..] {\n+            \"build\" => {\n+                m = parse(&opts);\n+                Subcommand::Build { paths: remaining_as_path(&m) }\n+            }\n+            \"doc\" => {\n+                m = parse(&opts);\n+                Subcommand::Doc { paths: remaining_as_path(&m) }\n+            }\n+            \"test\" => {\n+                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n+                m = parse(&opts);\n+                Subcommand::Test {\n+                    paths: remaining_as_path(&m),\n+                    test_args: m.opt_strs(\"test-args\"),\n+                }\n+            }\n+            \"clean\" => {\n+                m = parse(&opts);\n+                if m.free.len() > 0 {\n+                    println!(\"clean takes no arguments\");\n+                    usage(1, &opts);\n+                }\n+                Subcommand::Clean\n+            }\n+            \"dist\" => {\n+                opts.optflag(\"\", \"install\", \"run installer as well\");\n+                m = parse(&opts);\n+                Subcommand::Dist {\n+                    install: m.opt_present(\"install\"),\n+                }\n+            }\n+            cmd => {\n+                println!(\"unknown command: {}\", cmd);\n+                usage(1, &opts);\n+            }\n+        };\n+\n \n         let cfg_file = m.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n@@ -78,26 +242,27 @@ impl Flags {\n \n         Flags {\n             verbose: m.opt_present(\"v\"),\n-            clean: m.opt_present(\"clean\"),\n             stage: m.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n-            build: m.opt_str(\"build\").unwrap(),\n-            host: Filter { values: m.opt_strs(\"host\") },\n-            target: Filter { values: m.opt_strs(\"target\") },\n-            step: m.opt_strs(\"step\"),\n+            build: m.opt_str(\"build\").unwrap_or_else(|| {\n+                env::var(\"BUILD\").unwrap()\n+            }),\n+            host: m.opt_strs(\"host\"),\n+            target: m.opt_strs(\"target\"),\n             config: cfg_file,\n             src: m.opt_str(\"src\").map(PathBuf::from),\n             jobs: m.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n-            args: m.free.clone(),\n+            cmd: cmd,\n         }\n     }\n }\n \n-impl Filter {\n-    pub fn contains(&self, name: &str) -> bool {\n-        self.values.len() == 0 || self.values.iter().any(|s| s == name)\n-    }\n-\n-    pub fn iter(&self) -> slice::Iter<String> {\n-        self.values.iter()\n+impl Subcommand {\n+    pub fn test_args(&self) -> Vec<&str> {\n+        match *self {\n+            Subcommand::Test { ref test_args, .. } => {\n+                test_args.iter().flat_map(|s| s.split_whitespace()).collect()\n+            }\n+            _ => Vec::new(),\n+        }\n     }\n }"}, {"sha": "b4d7aff97da6a30a6784865e732994b5ddc44095", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -37,15 +37,82 @@\n //! Note that this module has a #[cfg(windows)] above it as none of this logic\n //! is required on Unix.\n \n-extern crate kernel32;\n-extern crate winapi;\n+#![allow(bad_style, dead_code)]\n \n use std::env;\n use std::io;\n use std::mem;\n \n-use self::winapi::*;\n-use self::kernel32::*;\n+type HANDLE = *mut u8;\n+type BOOL = i32;\n+type DWORD = u32;\n+type LPHANDLE = *mut HANDLE;\n+type LPVOID = *mut u8;\n+type JOBOBJECTINFOCLASS = i32;\n+type SIZE_T = usize;\n+type LARGE_INTEGER = i64;\n+type ULONG_PTR = usize;\n+type ULONGLONG = u64;\n+\n+const FALSE: BOOL = 0;\n+const DUPLICATE_SAME_ACCESS: DWORD = 0x2;\n+const PROCESS_DUP_HANDLE: DWORD = 0x40;\n+const JobObjectExtendedLimitInformation: JOBOBJECTINFOCLASS = 9;\n+const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE: DWORD = 0x2000;\n+\n+extern \"system\" {\n+    fn CreateJobObjectW(lpJobAttributes: *mut u8, lpName: *const u8) -> HANDLE;\n+    fn CloseHandle(hObject: HANDLE) -> BOOL;\n+    fn GetCurrentProcess() -> HANDLE;\n+    fn OpenProcess(dwDesiredAccess: DWORD,\n+                   bInheritHandle: BOOL,\n+                   dwProcessId: DWORD) -> HANDLE;\n+    fn DuplicateHandle(hSourceProcessHandle: HANDLE,\n+                       hSourceHandle: HANDLE,\n+                       hTargetProcessHandle: HANDLE,\n+                       lpTargetHandle: LPHANDLE,\n+                       dwDesiredAccess: DWORD,\n+                       bInheritHandle: BOOL,\n+                       dwOptions: DWORD) -> BOOL;\n+    fn AssignProcessToJobObject(hJob: HANDLE, hProcess: HANDLE) -> BOOL;\n+    fn SetInformationJobObject(hJob: HANDLE,\n+                               JobObjectInformationClass: JOBOBJECTINFOCLASS,\n+                               lpJobObjectInformation: LPVOID,\n+                               cbJobObjectInformationLength: DWORD) -> BOOL;\n+}\n+\n+#[repr(C)]\n+struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION {\n+    BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,\n+    IoInfo: IO_COUNTERS,\n+    ProcessMemoryLimit: SIZE_T,\n+    JobMemoryLimit: SIZE_T,\n+    PeakProcessMemoryUsed: SIZE_T,\n+    PeakJobMemoryUsed: SIZE_T,\n+}\n+\n+#[repr(C)]\n+struct IO_COUNTERS {\n+    ReadOperationCount: ULONGLONG,\n+    WriteOperationCount: ULONGLONG,\n+    OtherOperationCount: ULONGLONG,\n+    ReadTransferCount: ULONGLONG,\n+    WriteTransferCount: ULONGLONG,\n+    OtherTransferCount: ULONGLONG,\n+}\n+\n+#[repr(C)]\n+struct JOBOBJECT_BASIC_LIMIT_INFORMATION {\n+    PerProcessUserTimeLimit: LARGE_INTEGER,\n+    PerJobUserTimeLimit: LARGE_INTEGER,\n+    LimitFlags: DWORD,\n+    MinimumWorkingsetSize: SIZE_T,\n+    MaximumWorkingsetSize: SIZE_T,\n+    ActiveProcessLimit: DWORD,\n+    Affinity: ULONG_PTR,\n+    PriorityClass: DWORD,\n+    SchedulingClass: DWORD,\n+}\n \n pub unsafe fn setup() {\n     // Create a new job object for us to use"}, {"sha": "e6b88ea58c9bc0de545265f2b17a43852fdde5b9", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 30, "deletions": 248, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -57,6 +57,7 @@ mod channel;\n mod check;\n mod clean;\n mod compile;\n+mod metadata;\n mod config;\n mod dist;\n mod doc;\n@@ -76,7 +77,7 @@ mod job {\n }\n \n pub use config::Config;\n-pub use flags::Flags;\n+pub use flags::{Flags, Subcommand};\n \n /// A structure representing a Rust compiler.\n ///\n@@ -123,13 +124,23 @@ pub struct Build {\n     bootstrap_key_stage0: String,\n \n     // Probed tools at runtime\n-    gdb_version: Option<String>,\n     lldb_version: Option<String>,\n     lldb_python_dir: Option<String>,\n \n     // Runtime state filled in later on\n     cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n     cxx: HashMap<String, gcc::Tool>,\n+    crates: HashMap<String, Crate>,\n+}\n+\n+#[derive(Debug)]\n+struct Crate {\n+    name: String,\n+    deps: Vec<String>,\n+    path: PathBuf,\n+    doc_step: String,\n+    build_step: String,\n+    test_step: String,\n }\n \n /// The various \"modes\" of invoking Cargo.\n@@ -162,7 +173,9 @@ impl Build {\n     /// By default all build output will be placed in the current directory.\n     pub fn new(flags: Flags, config: Config) -> Build {\n         let cwd = t!(env::current_dir());\n-        let src = flags.src.clone().unwrap_or(cwd.clone());\n+        let src = flags.src.clone().or_else(|| {\n+            env::var_os(\"SRC\").map(|x| x.into())\n+        }).unwrap_or(cwd.clone());\n         let out = cwd.join(\"build\");\n \n         let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n@@ -196,21 +209,19 @@ impl Build {\n             package_vers: String::new(),\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n-            gdb_version: None,\n+            crates: HashMap::new(),\n             lldb_version: None,\n             lldb_python_dir: None,\n         }\n     }\n \n     /// Executes the entire build, as configured by the flags and configuration.\n     pub fn build(&mut self) {\n-        use step::Source::*;\n-\n         unsafe {\n             job::setup();\n         }\n \n-        if self.flags.clean {\n+        if let Subcommand::Clean = self.flags.cmd {\n             return clean::clean(self);\n         }\n \n@@ -232,247 +243,10 @@ impl Build {\n         }\n         self.verbose(\"updating submodules\");\n         self.update_submodules();\n+        self.verbose(\"learning about cargo\");\n+        metadata::build(self);\n \n-        // The main loop of the build system.\n-        //\n-        // The `step::all` function returns a topographically sorted list of all\n-        // steps that need to be executed as part of this build. Each step has a\n-        // corresponding entry in `step.rs` and indicates some unit of work that\n-        // needs to be done as part of the build.\n-        //\n-        // Almost all of these are simple one-liners that shell out to the\n-        // corresponding functionality in the extra modules, where more\n-        // documentation can be found.\n-        let steps = step::all(self);\n-\n-        self.verbose(\"bootstrap build plan:\");\n-        for step in &steps {\n-            self.verbose(&format!(\"{:?}\", step));\n-        }\n-\n-        for target in steps {\n-            let doc_out = self.out.join(&target.target).join(\"doc\");\n-            match target.src {\n-                Llvm { _dummy } => {\n-                    native::llvm(self, target.target);\n-                }\n-                TestHelpers { _dummy } => {\n-                    native::test_helpers(self, target.target);\n-                }\n-                Libstd { compiler } => {\n-                    compile::std(self, target.target, &compiler);\n-                }\n-                Libtest { compiler } => {\n-                    compile::test(self, target.target, &compiler);\n-                }\n-                Librustc { compiler } => {\n-                    compile::rustc(self, target.target, &compiler);\n-                }\n-                LibstdLink { compiler, host } => {\n-                    compile::std_link(self, target.target, &compiler, host);\n-                }\n-                LibtestLink { compiler, host } => {\n-                    compile::test_link(self, target.target, &compiler, host);\n-                }\n-                LibrustcLink { compiler, host } => {\n-                    compile::rustc_link(self, target.target, &compiler, host);\n-                }\n-                Rustc { stage: 0 } => {\n-                    // nothing to do...\n-                }\n-                Rustc { stage } => {\n-                    compile::assemble_rustc(self, stage, target.target);\n-                }\n-                ToolLinkchecker { stage } => {\n-                    compile::tool(self, stage, target.target, \"linkchecker\");\n-                }\n-                ToolRustbook { stage } => {\n-                    compile::tool(self, stage, target.target, \"rustbook\");\n-                }\n-                ToolErrorIndex { stage } => {\n-                    compile::tool(self, stage, target.target,\n-                                  \"error_index_generator\");\n-                }\n-                ToolCargoTest { stage } => {\n-                    compile::tool(self, stage, target.target, \"cargotest\");\n-                }\n-                ToolTidy { stage } => {\n-                    compile::tool(self, stage, target.target, \"tidy\");\n-                }\n-                ToolCompiletest { stage } => {\n-                    compile::tool(self, stage, target.target, \"compiletest\");\n-                }\n-                DocBook { stage } => {\n-                    doc::rustbook(self, stage, target.target, \"book\", &doc_out);\n-                }\n-                DocNomicon { stage } => {\n-                    doc::rustbook(self, stage, target.target, \"nomicon\",\n-                                  &doc_out);\n-                }\n-                DocStandalone { stage } => {\n-                    doc::standalone(self, stage, target.target, &doc_out);\n-                }\n-                DocStd { stage } => {\n-                    doc::std(self, stage, target.target, &doc_out);\n-                }\n-                DocTest { stage } => {\n-                    doc::test(self, stage, target.target, &doc_out);\n-                }\n-                DocRustc { stage } => {\n-                    doc::rustc(self, stage, target.target, &doc_out);\n-                }\n-                DocErrorIndex { stage } => {\n-                    doc::error_index(self, stage, target.target, &doc_out);\n-                }\n-\n-                CheckLinkcheck { stage } => {\n-                    check::linkcheck(self, stage, target.target);\n-                }\n-                CheckCargoTest { stage } => {\n-                    check::cargotest(self, stage, target.target);\n-                }\n-                CheckTidy { stage } => {\n-                    check::tidy(self, stage, target.target);\n-                }\n-                CheckRPass { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass\", \"run-pass\");\n-                }\n-                CheckRPassFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass\", \"run-pass-fulldeps\");\n-                }\n-                CheckCFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"compile-fail\", \"compile-fail\");\n-                }\n-                CheckCFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"compile-fail\", \"compile-fail-fulldeps\")\n-                }\n-                CheckPFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"parse-fail\", \"parse-fail\");\n-                }\n-                CheckRFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-fail\", \"run-fail\");\n-                }\n-                CheckRFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-fail\", \"run-fail-fulldeps\");\n-                }\n-                CheckPretty { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"pretty\");\n-                }\n-                CheckPrettyRPass { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass\");\n-                }\n-                CheckPrettyRPassFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass-fulldeps\");\n-                }\n-                CheckPrettyRFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-fail\");\n-                }\n-                CheckPrettyRFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-fail-fulldeps\");\n-                }\n-                CheckPrettyRPassValgrind { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass-valgrind\");\n-                }\n-                CheckMirOpt { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"mir-opt\", \"mir-opt\");\n-                }\n-                CheckCodegen { compiler } => {\n-                    if self.config.codegen_tests {\n-                        check::compiletest(self, &compiler, target.target,\n-                                           \"codegen\", \"codegen\");\n-                    }\n-                }\n-                CheckCodegenUnits { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"codegen-units\", \"codegen-units\");\n-                }\n-                CheckIncremental { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"incremental\", \"incremental\");\n-                }\n-                CheckUi { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"ui\", \"ui\");\n-                }\n-                CheckDebuginfo { compiler } => {\n-                    if target.target.contains(\"msvc\") {\n-                        // nothing to do\n-                    } else if target.target.contains(\"apple\") {\n-                        check::compiletest(self, &compiler, target.target,\n-                                           \"debuginfo-lldb\", \"debuginfo\");\n-                    } else {\n-                        check::compiletest(self, &compiler, target.target,\n-                                           \"debuginfo-gdb\", \"debuginfo\");\n-                    }\n-                }\n-                CheckRustdoc { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"rustdoc\", \"rustdoc\");\n-                }\n-                CheckRPassValgrind { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass-valgrind\", \"run-pass-valgrind\");\n-                }\n-                CheckDocs { compiler } => {\n-                    check::docs(self, &compiler);\n-                }\n-                CheckErrorIndex { compiler } => {\n-                    check::error_index(self, &compiler);\n-                }\n-                CheckRMake { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-make\", \"run-make\")\n-                }\n-                CheckCrateStd { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Libstd)\n-                }\n-                CheckCrateTest { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Libtest)\n-                }\n-                CheckCrateRustc { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Librustc)\n-                }\n-\n-                DistDocs { stage } => dist::docs(self, stage, target.target),\n-                DistMingw { _dummy } => dist::mingw(self, target.target),\n-                DistRustc { stage } => dist::rustc(self, stage, target.target),\n-                DistStd { compiler } => dist::std(self, &compiler, target.target),\n-                DistSrc { _dummy } => dist::rust_src(self),\n-\n-                Install { stage } => install::install(self, stage, target.target),\n-\n-                DebuggerScripts { stage } => {\n-                    let compiler = Compiler::new(stage, target.target);\n-                    dist::debugger_scripts(self,\n-                                           &self.sysroot(&compiler),\n-                                           target.target);\n-                }\n-\n-                AndroidCopyLibs { compiler } => {\n-                    check::android_copy_libs(self, &compiler, target.target);\n-                }\n-\n-                // pseudo-steps\n-                Dist { .. } |\n-                Doc { .. } |\n-                CheckTarget { .. } |\n-                Check { .. } => {}\n-            }\n-        }\n+        step::run(self);\n     }\n \n     /// Updates all git submodules that we have.\n@@ -686,6 +460,9 @@ impl Build {\n         if self.config.rust_optimize {\n             cargo.arg(\"--release\");\n         }\n+        if self.config.vendor {\n+            cargo.arg(\"--frozen\");\n+        }\n         return cargo\n     }\n \n@@ -812,6 +589,11 @@ impl Build {\n         self.out.join(target).join(\"llvm\")\n     }\n \n+    /// Output directory for all documentation for a target\n+    fn doc_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"doc\")\n+    }\n+\n     /// Returns true if no custom `llvm-config` is set for the specified target.\n     ///\n     /// If no custom `llvm-config` was specified then Rust's llvm will be used.\n@@ -873,7 +655,7 @@ impl Build {\n \n     /// Adds the compiler's bootstrap key to the environment of `cmd`.\n     fn add_bootstrap_key(&self, cmd: &mut Command) {\n-        cmd.env(\"RUSTC_BOOTSTRAP\", \"\");\n+        cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n         // FIXME: Transitionary measure to bootstrap using the old bootstrap logic.\n         // Remove this once the bootstrap compiler uses the new login in Issue #36548.\n         cmd.env(\"RUSTC_BOOTSTRAP_KEY\", \"62b3e239\");"}, {"sha": "bf5cc6a4ad838a057cc5fa3a04a4a0fe1cadb8f7", "filename": "src/bootstrap/metadata.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+use std::process::Command;\n+use std::path::PathBuf;\n+\n+use build_helper::output;\n+use rustc_serialize::json;\n+\n+use {Build, Crate};\n+\n+#[derive(RustcDecodable)]\n+struct Output {\n+    packages: Vec<Package>,\n+    resolve: Resolve,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct Package {\n+    id: String,\n+    name: String,\n+    source: Option<String>,\n+    manifest_path: String,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct Resolve {\n+    nodes: Vec<ResolveNode>,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct ResolveNode {\n+    id: String,\n+    dependencies: Vec<String>,\n+}\n+\n+pub fn build(build: &mut Build) {\n+    build_krate(build, \"src/rustc/std_shim\");\n+    build_krate(build, \"src/rustc/test_shim\");\n+    build_krate(build, \"src/rustc\");\n+}\n+\n+fn build_krate(build: &mut Build, krate: &str) {\n+    // Run `cargo metadata` to figure out what crates we're testing.\n+    //\n+    // Down below we're going to call `cargo test`, but to test the right set\n+    // of packages we're going to have to know what `-p` arguments to pass it\n+    // to know what crates to test. Here we run `cargo metadata` to learn about\n+    // the dependency graph and what `-p` arguments there are.\n+    let mut cargo = Command::new(&build.cargo);\n+    cargo.arg(\"metadata\")\n+         .arg(\"--manifest-path\").arg(build.src.join(krate).join(\"Cargo.toml\"));\n+    let output = output(&mut cargo);\n+    let output: Output = json::decode(&output).unwrap();\n+    let mut id2name = HashMap::new();\n+    for package in output.packages {\n+        if package.source.is_none() {\n+            id2name.insert(package.id, package.name.clone());\n+            let mut path = PathBuf::from(package.manifest_path);\n+            path.pop();\n+            build.crates.insert(package.name.clone(), Crate {\n+                build_step: format!(\"build-crate-{}\", package.name),\n+                doc_step: format!(\"doc-crate-{}\", package.name),\n+                test_step: format!(\"test-crate-{}\", package.name),\n+                name: package.name,\n+                deps: Vec::new(),\n+                path: path,\n+            });\n+        }\n+    }\n+\n+    for node in output.resolve.nodes {\n+        let name = match id2name.get(&node.id) {\n+            Some(name) => name,\n+            None => continue,\n+        };\n+\n+        let krate = build.crates.get_mut(name).unwrap();\n+        for dep in node.dependencies.iter() {\n+            let dep = match id2name.get(dep) {\n+                Some(dep) => dep,\n+                None => continue,\n+            };\n+            krate.deps.push(dep.clone());\n+        }\n+    }\n+}"}, {"sha": "d4031077639c50d0be477ca4b062594c0e032829", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -17,47 +17,46 @@ else\n BOOTSTRAP_ARGS :=\n endif\n \n-BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py $(BOOTSTRAP_ARGS)\n+BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py\n \n all:\n-\t$(Q)$(BOOTSTRAP)\n+\t$(Q)$(BOOTSTRAP) build $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) doc $(BOOTSTRAP_ARGS)\n \n # Don\u2019t use $(Q) here, always show how to invoke the bootstrap script directly\n help:\n \t$(BOOTSTRAP) --help\n \n clean:\n-\t$(Q)$(BOOTSTRAP) --clean\n+\t$(Q)$(BOOTSTRAP) clean $(BOOTSTRAP_ARGS)\n \n rustc-stage1:\n-\t$(Q)$(BOOTSTRAP) --step libtest --stage 1\n+\t$(Q)$(BOOTSTRAP) build --stage 1 src/libtest $(BOOTSTRAP_ARGS)\n rustc-stage2:\n-\t$(Q)$(BOOTSTRAP) --step libtest --stage 2\n+\t$(Q)$(BOOTSTRAP) build --stage 2 src/libtest $(BOOTSTRAP_ARGS)\n \n docs: doc\n doc:\n-\t$(Q)$(BOOTSTRAP) --step doc\n-style:\n-\t$(Q)$(BOOTSTRAP) --step doc-style\n+\t$(Q)$(BOOTSTRAP) doc $(BOOTSTRAP_ARGS)\n nomicon:\n-\t$(Q)$(BOOTSTRAP) --step doc-nomicon\n+\t$(Q)$(BOOTSTRAP) doc src/doc/nomicon $(BOOTSTRAP_ARGS)\n book:\n-\t$(Q)$(BOOTSTRAP) --step doc-book\n+\t$(Q)$(BOOTSTRAP) doc src/doc/book $(BOOTSTRAP_ARGS)\n standalone-docs:\n-\t$(Q)$(BOOTSTRAP) --step doc-standalone\n+\t$(Q)$(BOOTSTRAP) doc src/doc $(BOOTSTRAP_ARGS)\n check:\n-\t$(Q)$(BOOTSTRAP) --step check\n+\t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-cargotest:\n-\t$(Q)$(BOOTSTRAP) --step check-cargotest\n+\t$(Q)$(BOOTSTRAP) test src/tools/cargotest $(BOOTSTRAP_ARGS)\n dist:\n-\t$(Q)$(BOOTSTRAP) --step dist\n+\t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n install:\n ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))\n \t$(Q)echo \"'sudo make install' is not supported currently.\"\n else\n-\t$(Q)$(BOOTSTRAP) --step install\n+\t$(Q)$(BOOTSTRAP) dist --install $(BOOTSTRAP_ARGS)\n endif\n tidy:\n-\t$(Q)$(BOOTSTRAP) --step check-tidy --stage 0\n+\t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS)\n \n .PHONY: dist"}, {"sha": "cc1b7136d475f99f920ab3780f0d18fc8390c1d2", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -92,6 +92,12 @@ pub fn check(build: &mut Build) {\n         need_cmd(s.as_ref());\n     }\n \n+    if let Some(ref gdb) = build.config.gdb {\n+        need_cmd(gdb.as_ref());\n+    } else {\n+        build.config.gdb = have_cmd(\"gdb\".as_ref());\n+    }\n+\n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n     for target in build.config.target.iter() {\n@@ -198,7 +204,6 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n                    .to_string()\n         })\n     };\n-    build.gdb_version = run(Command::new(\"gdb\").arg(\"--version\")).ok();\n     build.lldb_version = run(Command::new(\"lldb\").arg(\"--version\")).ok();\n     if build.lldb_version.is_some() {\n         build.lldb_python_dir = run(Command::new(\"lldb\").arg(\"-P\")).ok();"}, {"sha": "6f616434b10c345bd93041ccc4ded07da55adf8f", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 639, "deletions": 548, "changes": 1187, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -8,600 +8,691 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Major workhorse of rustbuild, definition and dependencies between stages of\n-//! the copmile.\n-//!\n-//! The primary purpose of this module is to define the various `Step`s of\n-//! execution of the build. Each `Step` has a corresponding `Source` indicating\n-//! what it's actually doing along with a number of dependencies which must be\n-//! executed first.\n-//!\n-//! This module will take the CLI as input and calculate the steps required for\n-//! the build requested, ensuring that all intermediate pieces are in place.\n-//! Essentially this module is a `make`-replacement, but not as good.\n-\n-use std::collections::HashSet;\n-\n-use {Build, Compiler};\n-\n-#[derive(Hash, Eq, PartialEq, Clone, Debug)]\n-pub struct Step<'a> {\n-    pub src: Source<'a>,\n-    pub target: &'a str,\n+use std::collections::{HashMap, HashSet};\n+use std::mem;\n+\n+use check;\n+use compile;\n+use dist;\n+use doc;\n+use flags::Subcommand;\n+use install;\n+use native;\n+use {Compiler, Build, Mode};\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+struct Step<'a> {\n+    name: &'a str,\n+    stage: u32,\n+    host: &'a str,\n+    target: &'a str,\n }\n \n-/// Macro used to iterate over all targets that are recognized by the build\n-/// system.\n-///\n-/// Whenever a new step is added it will involve adding an entry here, updating\n-/// the dependencies section below, and then adding an implementation of the\n-/// step in `build/mod.rs`.\n-///\n-/// This macro takes another macro as an argument and then calls that macro with\n-/// all steps that the build system knows about.\n-macro_rules! targets {\n-    ($m:ident) => {\n-        $m! {\n-            // Step representing building the stageN compiler. This is just the\n-            // compiler executable itself, not any of the support libraries\n-            (rustc, Rustc { stage: u32 }),\n-\n-            // Steps for the two main cargo builds. These are parameterized over\n-            // the compiler which is producing the artifact.\n-            (libstd, Libstd { compiler: Compiler<'a> }),\n-            (libtest, Libtest { compiler: Compiler<'a> }),\n-            (librustc, Librustc { compiler: Compiler<'a> }),\n-\n-            // Links the target produced by the compiler provided into the\n-            // host's directory also provided.\n-            (libstd_link, LibstdLink {\n-                compiler: Compiler<'a>,\n-                host: &'a str\n-            }),\n-            (libtest_link, LibtestLink {\n-                compiler: Compiler<'a>,\n-                host: &'a str\n-            }),\n-            (librustc_link, LibrustcLink {\n-                compiler: Compiler<'a>,\n-                host: &'a str\n-            }),\n-\n-            // Various tools that we can build as part of the build.\n-            (tool_linkchecker, ToolLinkchecker { stage: u32 }),\n-            (tool_rustbook, ToolRustbook { stage: u32 }),\n-            (tool_error_index, ToolErrorIndex { stage: u32 }),\n-            (tool_cargotest, ToolCargoTest { stage: u32 }),\n-            (tool_tidy, ToolTidy { stage: u32 }),\n-            (tool_compiletest, ToolCompiletest { stage: u32 }),\n-\n-            // Steps for long-running native builds. Ideally these wouldn't\n-            // actually exist and would be part of build scripts, but for now\n-            // these are here.\n-            //\n-            // There aren't really any parameters to this, but empty structs\n-            // with braces are unstable so we just pick something that works.\n-            (llvm, Llvm { _dummy: () }),\n-            (test_helpers, TestHelpers { _dummy: () }),\n-            (debugger_scripts, DebuggerScripts { stage: u32 }),\n-\n-            // Steps for various pieces of documentation that we can generate,\n-            // the 'doc' step is just a pseudo target to depend on a bunch of\n-            // others.\n-            (doc, Doc { stage: u32 }),\n-            (doc_book, DocBook { stage: u32 }),\n-            (doc_nomicon, DocNomicon { stage: u32 }),\n-            (doc_standalone, DocStandalone { stage: u32 }),\n-            (doc_std, DocStd { stage: u32 }),\n-            (doc_test, DocTest { stage: u32 }),\n-            (doc_rustc, DocRustc { stage: u32 }),\n-            (doc_error_index, DocErrorIndex { stage: u32 }),\n-\n-            // Steps for running tests. The 'check' target is just a pseudo\n-            // target to depend on a bunch of others.\n-            (check, Check { stage: u32, compiler: Compiler<'a> }),\n-            (check_target, CheckTarget { stage: u32, compiler: Compiler<'a> }),\n-            (check_linkcheck, CheckLinkcheck { stage: u32 }),\n-            (check_cargotest, CheckCargoTest { stage: u32 }),\n-            (check_tidy, CheckTidy { stage: u32 }),\n-            (check_rpass, CheckRPass { compiler: Compiler<'a> }),\n-            (check_rpass_full, CheckRPassFull { compiler: Compiler<'a> }),\n-            (check_rpass_valgrind, CheckRPassValgrind { compiler: Compiler<'a> }),\n-            (check_rfail, CheckRFail { compiler: Compiler<'a> }),\n-            (check_rfail_full, CheckRFailFull { compiler: Compiler<'a> }),\n-            (check_cfail, CheckCFail { compiler: Compiler<'a> }),\n-            (check_cfail_full, CheckCFailFull { compiler: Compiler<'a> }),\n-            (check_pfail, CheckPFail { compiler: Compiler<'a> }),\n-            (check_pretty, CheckPretty { compiler: Compiler<'a> }),\n-            (check_pretty_rpass, CheckPrettyRPass { compiler: Compiler<'a> }),\n-            (check_pretty_rpass_full, CheckPrettyRPassFull { compiler: Compiler<'a> }),\n-            (check_pretty_rfail, CheckPrettyRFail { compiler: Compiler<'a> }),\n-            (check_pretty_rfail_full, CheckPrettyRFailFull { compiler: Compiler<'a> }),\n-            (check_pretty_rpass_valgrind, CheckPrettyRPassValgrind { compiler: Compiler<'a> }),\n-            (check_codegen, CheckCodegen { compiler: Compiler<'a> }),\n-            (check_codegen_units, CheckCodegenUnits { compiler: Compiler<'a> }),\n-            (check_incremental, CheckIncremental { compiler: Compiler<'a> }),\n-            (check_ui, CheckUi { compiler: Compiler<'a> }),\n-            (check_mir_opt, CheckMirOpt { compiler: Compiler<'a> }),\n-            (check_debuginfo, CheckDebuginfo { compiler: Compiler<'a> }),\n-            (check_rustdoc, CheckRustdoc { compiler: Compiler<'a> }),\n-            (check_docs, CheckDocs { compiler: Compiler<'a> }),\n-            (check_error_index, CheckErrorIndex { compiler: Compiler<'a> }),\n-            (check_rmake, CheckRMake { compiler: Compiler<'a> }),\n-            (check_crate_std, CheckCrateStd { compiler: Compiler<'a> }),\n-            (check_crate_test, CheckCrateTest { compiler: Compiler<'a> }),\n-            (check_crate_rustc, CheckCrateRustc { compiler: Compiler<'a> }),\n-\n-            // Distribution targets, creating tarballs\n-            (dist, Dist { stage: u32 }),\n-            (dist_docs, DistDocs { stage: u32 }),\n-            (dist_mingw, DistMingw { _dummy: () }),\n-            (dist_rustc, DistRustc { stage: u32 }),\n-            (dist_std, DistStd { compiler: Compiler<'a> }),\n-            (dist_src, DistSrc { _dummy: () }),\n-\n-            // install target\n-            (install, Install { stage: u32 }),\n-\n-            // Misc targets\n-            (android_copy_libs, AndroidCopyLibs { compiler: Compiler<'a> }),\n-        }\n+impl<'a> Step<'a> {\n+    fn name(&self, name: &'a str) -> Step<'a> {\n+        Step { name: name, ..*self }\n     }\n-}\n \n-// Define the `Source` enum by iterating over all the steps and peeling out just\n-// the types that we want to define.\n+    fn stage(&self, stage: u32) -> Step<'a> {\n+        Step { stage: stage, ..*self }\n+    }\n \n-macro_rules! item { ($a:item) => ($a) }\n+    fn host(&self, host: &'a str) -> Step<'a> {\n+        Step { host: host, ..*self }\n+    }\n \n-macro_rules! define_source {\n-    ($(($short:ident, $name:ident { $($args:tt)* }),)*) => {\n-        item! {\n-            #[derive(Hash, Eq, PartialEq, Clone, Debug)]\n-            pub enum Source<'a> {\n-                $($name { $($args)* }),*\n-            }\n-        }\n+    fn target(&self, target: &'a str) -> Step<'a> {\n+        Step { target: target, ..*self }\n     }\n-}\n \n-targets!(define_source);\n-\n-/// Calculate a list of all steps described by `build`.\n-///\n-/// This will inspect the flags passed in on the command line and use that to\n-/// build up a list of steps to execute. These steps will then be transformed\n-/// into a topologically sorted list which when executed left-to-right will\n-/// correctly sequence the entire build.\n-pub fn all(build: &Build) -> Vec<Step> {\n-    build.verbose(\"inferred build steps:\");\n-\n-    let mut ret = Vec::new();\n-    let mut all = HashSet::new();\n-    for target in top_level(build) {\n-        fill(build, &target, &mut ret, &mut all);\n-    }\n-    return ret;\n-\n-    fn fill<'a>(build: &'a Build,\n-                target: &Step<'a>,\n-                ret: &mut Vec<Step<'a>>,\n-                set: &mut HashSet<Step<'a>>) {\n-        if set.insert(target.clone()) {\n-            for dep in target.deps(build) {\n-                build.verbose(&format!(\"{:?}\\n  -> {:?}\", target, dep));\n-                fill(build, &dep, ret, set);\n-            }\n-            ret.push(target.clone());\n-        }\n+    fn compiler(&self) -> Compiler<'a> {\n+        Compiler::new(self.stage, self.host)\n     }\n }\n \n-/// Determines what top-level targets are requested as part of this build,\n-/// returning them as a list.\n-fn top_level(build: &Build) -> Vec<Step> {\n-    let mut targets = Vec::new();\n-    let stage = build.flags.stage.unwrap_or(2);\n+pub fn run(build: &Build) {\n+    let rules = build_rules(build);\n+    let steps = rules.plan();\n+    rules.run(&steps);\n+}\n \n-    let host = Step {\n-        src: Source::Llvm { _dummy: () },\n-        target: build.flags.host.iter().next()\n-                     .unwrap_or(&build.config.build),\n-    };\n-    let target = Step {\n-        src: Source::Llvm { _dummy: () },\n-        target: build.flags.target.iter().next().map(|x| &x[..])\n-                     .unwrap_or(host.target)\n+pub fn build_rules(build: &Build) -> Rules {\n+    let mut rules: Rules = Rules::new(build);\n+    // dummy rule to do nothing, useful when a dep maps to no deps\n+    rules.build(\"dummy\", \"path/to/nowhere\");\n+    fn dummy<'a>(s: &Step<'a>, build: &'a Build) -> Step<'a> {\n+        s.name(\"dummy\").stage(0)\n+         .target(&build.config.build)\n+         .host(&build.config.build)\n+    }\n+\n+    // Helper for loading an entire DAG of crates, rooted at `name`\n+    let krates = |name: &str| {\n+        let mut ret = Vec::new();\n+        let mut list = vec![name];\n+        let mut visited = HashSet::new();\n+        while let Some(krate) = list.pop() {\n+            let default = krate == name;\n+            let krate = &build.crates[krate];\n+            let path = krate.path.strip_prefix(&build.src).unwrap();\n+            ret.push((krate, path.to_str().unwrap(), default));\n+            for dep in krate.deps.iter() {\n+                if visited.insert(dep) && dep != \"build_helper\" {\n+                    list.push(dep);\n+                }\n+            }\n+        }\n+        return ret\n     };\n \n-    // First, try to find steps on the command line.\n-    add_steps(build, stage, &host, &target, &mut targets);\n+    rules.build(\"rustc\", \"path/to/nowhere\")\n+         .dep(move |s| {\n+             if s.stage == 0 {\n+                 dummy(s, build)\n+             } else {\n+                 s.name(\"librustc\")\n+                  .host(&build.config.build)\n+                  .stage(s.stage - 1)\n+             }\n+         })\n+         .run(move |s| compile::assemble_rustc(build, s.stage, s.target));\n+    rules.build(\"llvm\", \"src/llvm\")\n+         .host(true)\n+         .run(move |s| native::llvm(build, s.target));\n+\n+    // ========================================================================\n+    // Crate compilations\n+    //\n+    // Tools used during the build system but not shipped\n+    rules.build(\"libstd\", \"src/libstd\")\n+         .dep(|s| s.name(\"build-crate-std_shim\"));\n+    rules.build(\"libtest\", \"src/libtest\")\n+         .dep(|s| s.name(\"build-crate-test_shim\"));\n+    rules.build(\"librustc\", \"src/librustc\")\n+         .dep(|s| s.name(\"build-crate-rustc-main\"));\n+    for (krate, path, _default) in krates(\"std_shim\") {\n+        rules.build(&krate.build_step, path)\n+             .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(s.host))\n+             .dep(move |s| {\n+                 if s.host == build.config.build {\n+                    dummy(s, build)\n+                 } else {\n+                    s.host(&build.config.build)\n+                 }\n+             })\n+             .run(move |s| {\n+                 if s.host == build.config.build {\n+                    compile::std(build, s.target, &s.compiler())\n+                 } else {\n+                    compile::std_link(build, s.target, s.stage, s.host)\n+                 }\n+             });\n+    }\n+    for (krate, path, default) in krates(\"test_shim\") {\n+        rules.build(&krate.build_step, path)\n+             .dep(|s| s.name(\"libstd\"))\n+             .dep(move |s| {\n+                 if s.host == build.config.build {\n+                    dummy(s, build)\n+                 } else {\n+                    s.host(&build.config.build)\n+                 }\n+             })\n+             .default(default)\n+             .run(move |s| {\n+                 if s.host == build.config.build {\n+                    compile::test(build, s.target, &s.compiler())\n+                 } else {\n+                    compile::test_link(build, s.target, s.stage, s.host)\n+                 }\n+             });\n+    }\n+    for (krate, path, default) in krates(\"rustc-main\") {\n+        rules.build(&krate.build_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .dep(move |s| s.name(\"llvm\").host(&build.config.build).stage(0))\n+             .dep(move |s| {\n+                 if s.host == build.config.build {\n+                    dummy(s, build)\n+                 } else {\n+                    s.host(&build.config.build)\n+                 }\n+             })\n+             .host(true)\n+             .default(default)\n+             .run(move |s| {\n+                 if s.host == build.config.build {\n+                    compile::rustc(build, s.target, &s.compiler())\n+                 } else {\n+                    compile::rustc_link(build, s.target, s.stage, s.host)\n+                 }\n+             });\n+    }\n \n-    // If none are specified, then build everything.\n-    if targets.len() == 0 {\n-        let t = Step {\n-            src: Source::Llvm { _dummy: () },\n-            target: &build.config.build,\n+    // ========================================================================\n+    // Test targets\n+    //\n+    // Various unit tests and tests suites we can run\n+    {\n+        let mut suite = |name, path, dir, mode| {\n+            rules.test(name, path)\n+                 .dep(|s| s.name(\"libtest\"))\n+                 .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n+                 .dep(|s| s.name(\"test-helpers\"))\n+                 .dep(move |s| {\n+                     if s.target.contains(\"android\") {\n+                         s.name(\"android-copy-libs\")\n+                     } else {\n+                         dummy(s, build)\n+                     }\n+                 })\n+                 .default(true)\n+                 .run(move |s| {\n+                     check::compiletest(build, &s.compiler(), s.target, dir, mode)\n+                 });\n         };\n-        if build.config.docs {\n-          targets.push(t.doc(stage));\n-        }\n-        for host in build.config.host.iter() {\n-            if !build.flags.host.contains(host) {\n-                continue\n-            }\n-            let host = t.target(host);\n-            if host.target == build.config.build {\n-                targets.push(host.librustc(host.compiler(stage)));\n-            } else {\n-                targets.push(host.librustc_link(t.compiler(stage), host.target));\n-            }\n-            for target in build.config.target.iter() {\n-                if !build.flags.target.contains(target) {\n-                    continue\n-                }\n \n-                if host.target == build.config.build {\n-                    targets.push(host.target(target)\n-                                     .libtest(host.compiler(stage)));\n-                } else {\n-                    targets.push(host.target(target)\n-                                     .libtest_link(t.compiler(stage), host.target));\n-                }\n-            }\n+        suite(\"check-rpass\", \"src/test/run-pass\", \"run-pass\", \"run-pass\");\n+        suite(\"check-cfail\", \"src/test/compile-fail\", \"compile-fail\", \"compile-fail\");\n+        suite(\"check-pfail\", \"src/test/parse-fail\", \"parse-fail\", \"parse-fail\");\n+        suite(\"check-rfail\", \"src/test/run-fail\", \"run-fail\", \"run-fail\");\n+        suite(\"check-rpass-valgrind\", \"src/test/run-pass-valgrind\",\n+              \"run-pass-valgrind\", \"run-pass-valgrind\");\n+        suite(\"check-mir-opt\", \"src/test/mir-opt\", \"mir-opt\", \"mir-opt\");\n+        if build.config.codegen_tests {\n+            suite(\"check-codegen\", \"src/test/codegen\", \"codegen\", \"codegen\");\n         }\n+        suite(\"check-codegen-units\", \"src/test/codegen-units\", \"codegen-units\",\n+              \"codegen-units\");\n+        suite(\"check-incremental\", \"src/test/incremental\", \"incremental\",\n+              \"incremental\");\n+        suite(\"check-ui\", \"src/test/ui\", \"ui\", \"ui\");\n+        suite(\"check-pretty\", \"src/test/pretty\", \"pretty\", \"pretty\");\n+        suite(\"check-pretty-rpass\", \"src/test/run-pass/pretty\", \"pretty\",\n+              \"run-pass\");\n+        suite(\"check-pretty-rfail\", \"src/test/run-pass/pretty\", \"pretty\",\n+              \"run-fail\");\n+        suite(\"check-pretty-valgrind\", \"src/test/run-pass-valgrind\", \"pretty\",\n+              \"run-pass-valgrind\");\n     }\n \n-    targets\n-}\n+    if build.config.build.contains(\"msvc\") {\n+        // nothing to do for debuginfo tests\n+    } else if build.config.build.contains(\"apple\") {\n+        rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n+             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"tool-compiletest\").host(s.host))\n+             .dep(|s| s.name(\"test-helpers\"))\n+             .dep(|s| s.name(\"debugger-scripts\"))\n+             .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n+                                         \"debuginfo-lldb\", \"debuginfo\"));\n+    } else {\n+        rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n+             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"tool-compiletest\").host(s.host))\n+             .dep(|s| s.name(\"test-helpers\"))\n+             .dep(|s| s.name(\"debugger-scripts\"))\n+             .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n+                                         \"debuginfo-gdb\", \"debuginfo\"));\n+    }\n \n-fn add_steps<'a>(build: &'a Build,\n-                 stage: u32,\n-                 host: &Step<'a>,\n-                 target: &Step<'a>,\n-                 targets: &mut Vec<Step<'a>>) {\n-    struct Context<'a> {\n-        stage: u32,\n-        compiler: Compiler<'a>,\n-        _dummy: (),\n-        host: &'a str,\n-    }\n-    for step in build.flags.step.iter() {\n-\n-        // The macro below insists on hygienic access to all local variables, so\n-        // we shove them all in a struct and subvert hygiene by accessing struct\n-        // fields instead,\n-        let cx = Context {\n-            stage: stage,\n-            compiler: host.target(&build.config.build).compiler(stage),\n-            _dummy: (),\n-            host: host.target,\n+    rules.test(\"debugger-scripts\", \"src/etc/lldb_batchmode.py\")\n+         .run(move |s| dist::debugger_scripts(build, &build.sysroot(&s.compiler()),\n+                                         s.target));\n+\n+    {\n+        let mut suite = |name, path, dir, mode| {\n+            rules.test(name, path)\n+                 .dep(|s| s.name(\"librustc\"))\n+                 .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n+                 .default(true)\n+                 .host(true)\n+                 .run(move |s| {\n+                     check::compiletest(build, &s.compiler(), s.target, dir, mode)\n+                 });\n         };\n-        macro_rules! add_step {\n-            ($(($short:ident, $name:ident { $($arg:ident: $t:ty),* }),)*) => ({$(\n-                let name = stringify!($short).replace(\"_\", \"-\");\n-                if &step[..] == &name[..] {\n-                    targets.push(target.$short($(cx.$arg),*));\n-                    continue\n-                }\n-                drop(name);\n-            )*})\n+\n+        suite(\"check-rpass-full\", \"src/test/run-pass-fulldeps\",\n+              \"run-pass\", \"run-pass-fulldeps\");\n+        suite(\"check-cfail-full\", \"src/test/compile-fail-fulldeps\",\n+              \"compile-fail\", \"compile-fail-fulldeps\");\n+        suite(\"check-rmake\", \"src/test/run-make\", \"run-make\", \"run-make\");\n+        suite(\"check-rustdoc\", \"src/test/rustdoc\", \"rustdoc\", \"rustdoc\");\n+        suite(\"check-pretty-rpass-full\", \"src/test/run-pass-fulldeps\",\n+              \"pretty\", \"run-pass-fulldeps\");\n+        suite(\"check-pretty-rfail-full\", \"src/test/run-fail-fulldeps\",\n+              \"pretty\", \"run-fail-fulldeps\");\n+    }\n+\n+    for (krate, path, _default) in krates(\"std_shim\") {\n+        rules.test(&krate.test_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                        Mode::Libstd, Some(&krate.name)));\n+    }\n+    rules.test(\"check-std-all\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .default(true)\n+         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Libstd,\n+                               None));\n+    for (krate, path, _default) in krates(\"test_shim\") {\n+        rules.test(&krate.test_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                        Mode::Libtest, Some(&krate.name)));\n+    }\n+    rules.test(\"check-test-all\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .default(true)\n+         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Libtest,\n+                               None));\n+    for (krate, path, _default) in krates(\"rustc-main\") {\n+        rules.test(&krate.test_step, path)\n+             .dep(|s| s.name(\"librustc\"))\n+             .host(true)\n+             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                        Mode::Librustc, Some(&krate.name)));\n+    }\n+    rules.test(\"check-rustc-all\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"librustc\"))\n+         .default(true)\n+         .host(true)\n+         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Librustc,\n+                               None));\n+\n+    rules.test(\"check-linkchecker\", \"src/tools/linkchecker\")\n+         .dep(|s| s.name(\"tool-linkchecker\"))\n+         .dep(|s| s.name(\"default:doc\"))\n+         .default(true)\n+         .host(true)\n+         .run(move |s| check::linkcheck(build, s.stage, s.target));\n+    rules.test(\"check-cargotest\", \"src/tools/cargotest\")\n+         .dep(|s| s.name(\"tool-cargotest\"))\n+         .dep(|s| s.name(\"librustc\"))\n+         .host(true)\n+         .run(move |s| check::cargotest(build, s.stage, s.target));\n+    rules.test(\"check-tidy\", \"src/tools/tidy\")\n+         .dep(|s| s.name(\"tool-tidy\"))\n+         .default(true)\n+         .host(true)\n+         .run(move |s| check::tidy(build, s.stage, s.target));\n+    rules.test(\"check-error-index\", \"src/tools/error_index_generator\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"tool-error-index\").host(s.host))\n+         .default(true)\n+         .host(true)\n+         .run(move |s| check::error_index(build, &s.compiler()));\n+    rules.test(\"check-docs\", \"src/doc\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .default(true)\n+         .host(true)\n+         .run(move |s| check::docs(build, &s.compiler()));\n+\n+    rules.build(\"test-helpers\", \"src/rt/rust_test_helpers.c\")\n+         .run(move |s| native::test_helpers(build, s.target));\n+    rules.test(\"android-copy-libs\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .run(move |s| check::android_copy_libs(build, &s.compiler(), s.target));\n+\n+    // ========================================================================\n+    // Build tools\n+    //\n+    // Tools used during the build system but not shipped\n+    rules.build(\"tool-rustbook\", \"src/tools/rustbook\")\n+         .dep(|s| s.name(\"librustc\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"rustbook\"));\n+    rules.build(\"tool-error-index\", \"src/tools/error_index_generator\")\n+         .dep(|s| s.name(\"librustc\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"error_index_generator\"));\n+    rules.build(\"tool-tidy\", \"src/tools/tidy\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"tidy\"));\n+    rules.build(\"tool-linkchecker\", \"src/tools/linkchecker\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"linkchecker\"));\n+    rules.build(\"tool-cargotest\", \"src/tools/cargotest\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"cargotest\"));\n+    rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n+\n+    // ========================================================================\n+    // Documentation targets\n+    rules.doc(\"doc-book\", \"src/doc/book\")\n+         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build))\n+         .default(build.config.docs)\n+         .run(move |s| doc::rustbook(build, s.stage, s.target, \"book\"));\n+    rules.doc(\"doc-nomicon\", \"src/doc/nomicon\")\n+         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build))\n+         .default(build.config.docs)\n+         .run(move |s| doc::rustbook(build, s.stage, s.target, \"nomicon\"));\n+    rules.doc(\"doc-standalone\", \"src/doc\")\n+         .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(&build.config.build))\n+         .default(build.config.docs)\n+         .run(move |s| doc::standalone(build, s.stage, s.target));\n+    rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n+         .dep(move |s| s.name(\"tool-error-index\").target(&build.config.build))\n+         .dep(move |s| s.name(\"librustc\"))\n+         .default(build.config.docs)\n+         .host(true)\n+         .run(move |s| doc::error_index(build, s.stage, s.target));\n+    for (krate, path, default) in krates(\"std_shim\") {\n+        rules.doc(&krate.doc_step, path)\n+             .dep(|s| s.name(\"libstd\"))\n+             .default(default && build.config.docs)\n+             .run(move |s| doc::std(build, s.stage, s.target));\n+    }\n+    for (krate, path, default) in krates(\"test_shim\") {\n+        rules.doc(&krate.doc_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .default(default && build.config.docs)\n+             .run(move |s| doc::test(build, s.stage, s.target));\n+    }\n+    for (krate, path, default) in krates(\"rustc-main\") {\n+        rules.doc(&krate.doc_step, path)\n+             .dep(|s| s.name(\"librustc\"))\n+             .host(true)\n+             .default(default && build.config.compiler_docs)\n+             .run(move |s| doc::rustc(build, s.stage, s.target));\n+    }\n+\n+    // ========================================================================\n+    // Distribution targets\n+    rules.dist(\"dist-rustc\", \"src/librustc\")\n+         .dep(move |s| s.name(\"rustc\").host(&build.config.build))\n+         .host(true)\n+         .default(true)\n+         .run(move |s| dist::rustc(build, s.stage, s.target));\n+    rules.dist(\"dist-std\", \"src/libstd\")\n+         .dep(move |s| {\n+             // We want to package up as many target libraries as possible\n+             // for the `rust-std` package, so if this is a host target we\n+             // depend on librustc and otherwise we just depend on libtest.\n+             if build.config.host.iter().any(|t| t == s.target) {\n+                 s.name(\"librustc\")\n+             } else {\n+                 s.name(\"libtest\")\n+             }\n+         })\n+         .default(true)\n+         .run(move |s| dist::std(build, &s.compiler(), s.target));\n+    rules.dist(\"dist-mingw\", \"path/to/nowhere\")\n+         .run(move |s| dist::mingw(build, s.target));\n+    rules.dist(\"dist-src\", \"src\")\n+         .default(true)\n+         .host(true)\n+         .run(move |_| dist::rust_src(build));\n+    rules.dist(\"dist-docs\", \"src/doc\")\n+         .dep(|s| s.name(\"default:doc\"))\n+         .run(move |s| dist::docs(build, s.stage, s.target));\n+    rules.dist(\"install\", \"src\")\n+         .dep(|s| s.name(\"default:dist\"))\n+         .run(move |s| install::install(build, s.stage, s.target));\n+\n+    rules.verify();\n+    return rules\n+}\n+\n+struct Rule<'a> {\n+    name: &'a str,\n+    path: &'a str,\n+    kind: Kind,\n+    deps: Vec<Box<Fn(&Step<'a>) -> Step<'a> + 'a>>,\n+    run: Box<Fn(&Step<'a>) + 'a>,\n+    default: bool,\n+    host: bool,\n+}\n+\n+#[derive(PartialEq)]\n+enum Kind {\n+    Build,\n+    Test,\n+    Dist,\n+    Doc,\n+}\n+\n+impl<'a> Rule<'a> {\n+    fn new(name: &'a str, path: &'a str, kind: Kind) -> Rule<'a> {\n+        Rule {\n+            name: name,\n+            deps: Vec::new(),\n+            run: Box::new(|_| ()),\n+            path: path,\n+            kind: kind,\n+            default: false,\n+            host: false,\n         }\n+    }\n+}\n+\n+struct RuleBuilder<'a: 'b, 'b> {\n+    rules: &'b mut Rules<'a>,\n+    rule: Rule<'a>,\n+}\n \n-        targets!(add_step);\n+impl<'a, 'b> RuleBuilder<'a, 'b> {\n+    fn dep<F>(&mut self, f: F) -> &mut Self\n+        where F: Fn(&Step<'a>) -> Step<'a> + 'a,\n+    {\n+        self.rule.deps.push(Box::new(f));\n+        self\n+    }\n+\n+    fn run<F>(&mut self, f: F) -> &mut Self\n+        where F: Fn(&Step<'a>) + 'a,\n+    {\n+        self.rule.run = Box::new(f);\n+        self\n+    }\n+\n+    fn default(&mut self, default: bool) -> &mut Self {\n+        self.rule.default = default;\n+        self\n+    }\n \n-        panic!(\"unknown step: {}\", step);\n+    fn host(&mut self, host: bool) -> &mut Self {\n+        self.rule.host = host;\n+        self\n     }\n }\n \n-macro_rules! constructors {\n-    ($(($short:ident, $name:ident { $($arg:ident: $t:ty),* }),)*) => {$(\n-        fn $short(&self, $($arg: $t),*) -> Step<'a> {\n-            Step {\n-                src: Source::$name { $($arg: $arg),* },\n-                target: self.target,\n-            }\n+impl<'a, 'b> Drop for RuleBuilder<'a, 'b> {\n+    fn drop(&mut self) {\n+        let rule = mem::replace(&mut self.rule, Rule::new(\"\", \"\", Kind::Build));\n+        let prev = self.rules.rules.insert(rule.name, rule);\n+        if let Some(prev) = prev {\n+            panic!(\"duplicate rule named: {}\", prev.name);\n         }\n-    )*}\n+    }\n }\n \n-impl<'a> Step<'a> {\n-    fn compiler(&self, stage: u32) -> Compiler<'a> {\n-        Compiler::new(stage, self.target)\n+pub struct Rules<'a> {\n+    build: &'a Build,\n+    sbuild: Step<'a>,\n+    rules: HashMap<&'a str, Rule<'a>>,\n+}\n+\n+impl<'a> Rules<'a> {\n+    fn new(build: &'a Build) -> Rules<'a> {\n+        Rules {\n+            build: build,\n+            sbuild: Step {\n+                stage: build.flags.stage.unwrap_or(2),\n+                target: &build.config.build,\n+                host: &build.config.build,\n+                name: \"\",\n+            },\n+            rules: HashMap::new(),\n+        }\n     }\n \n-    fn target(&self, target: &'a str) -> Step<'a> {\n-        Step { target: target, src: self.src.clone() }\n+    fn build<'b>(&'b mut self, name: &'a str, path: &'a str)\n+                 -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Build)\n     }\n \n-    // Define ergonomic constructors for each step defined above so they can be\n-    // easily constructed.\n-    targets!(constructors);\n+    fn test<'b>(&'b mut self, name: &'a str, path: &'a str)\n+                -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Test)\n+    }\n \n-    /// Mapping of all dependencies for rustbuild.\n-    ///\n-    /// This function receives a step, the build that we're building for, and\n-    /// then returns a list of all the dependencies of that step.\n-    pub fn deps(&self, build: &'a Build) -> Vec<Step<'a>> {\n-        match self.src {\n-            Source::Rustc { stage: 0 } => {\n-                Vec::new()\n-            }\n-            Source::Rustc { stage } => {\n-                let compiler = Compiler::new(stage - 1, &build.config.build);\n-                vec![self.librustc(compiler)]\n-            }\n-            Source::Librustc { compiler } => {\n-                vec![self.libtest(compiler), self.llvm(())]\n-            }\n-            Source::Libtest { compiler } => {\n-                vec![self.libstd(compiler)]\n-            }\n-            Source::Libstd { compiler } => {\n-                vec![self.rustc(compiler.stage).target(compiler.host)]\n-            }\n-            Source::LibrustcLink { compiler, host } => {\n-                vec![self.librustc(compiler),\n-                     self.libtest_link(compiler, host)]\n-            }\n-            Source::LibtestLink { compiler, host } => {\n-                vec![self.libtest(compiler), self.libstd_link(compiler, host)]\n-            }\n-            Source::LibstdLink { compiler, host } => {\n-                vec![self.libstd(compiler),\n-                     self.target(host).rustc(compiler.stage)]\n-            }\n-            Source::Llvm { _dummy } => Vec::new(),\n-            Source::TestHelpers { _dummy } => Vec::new(),\n-            Source::DebuggerScripts { stage: _ } => Vec::new(),\n-\n-            // Note that all doc targets depend on artifacts from the build\n-            // architecture, not the target (which is where we're generating\n-            // docs into).\n-            Source::DocStd { stage } => {\n-                let compiler = self.target(&build.config.build).compiler(stage);\n-                vec![self.libstd(compiler)]\n-            }\n-            Source::DocTest { stage } => {\n-                let compiler = self.target(&build.config.build).compiler(stage);\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::DocBook { stage } |\n-            Source::DocNomicon { stage } => {\n-                vec![self.target(&build.config.build).tool_rustbook(stage)]\n-            }\n-            Source::DocErrorIndex { stage } => {\n-                vec![self.target(&build.config.build).tool_error_index(stage)]\n-            }\n-            Source::DocStandalone { stage } => {\n-                vec![self.target(&build.config.build).rustc(stage)]\n-            }\n-            Source::DocRustc { stage } => {\n-                vec![self.doc_test(stage)]\n-            }\n-            Source::Doc { stage } => {\n-                let mut deps = vec![\n-                    self.doc_book(stage), self.doc_nomicon(stage),\n-                    self.doc_standalone(stage), self.doc_std(stage),\n-                    self.doc_error_index(stage),\n-                ];\n-\n-                if build.config.compiler_docs {\n-                    deps.push(self.doc_rustc(stage));\n-                }\n+    fn doc<'b>(&'b mut self, name: &'a str, path: &'a str)\n+               -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Doc)\n+    }\n \n-                deps\n-            }\n-            Source::Check { stage, compiler } => {\n-                // Check is just a pseudo step which means check all targets,\n-                // so just depend on checking all targets.\n-                build.config.target.iter().map(|t| {\n-                    self.target(t).check_target(stage, compiler)\n-                }).collect()\n-            }\n-            Source::CheckTarget { stage, compiler } => {\n-                // CheckTarget here means run all possible test suites for this\n-                // target. Most of the time, however, we can't actually run\n-                // anything if we're not the build triple as we could be cross\n-                // compiling.\n-                //\n-                // As a result, the base set of targets here is quite stripped\n-                // down from the standard set of targets. These suites have\n-                // their own internal logic to run in cross-compiled situations\n-                // if they'll run at all. For example compiletest knows that\n-                // when testing Android targets we ship artifacts to the\n-                // emulator.\n-                //\n-                // When in doubt the rule of thumb for adding to this list is\n-                // \"should this test suite run on the android bot?\"\n-                let mut base = vec![\n-                    self.check_rpass(compiler),\n-                    self.check_rfail(compiler),\n-                    self.check_crate_std(compiler),\n-                    self.check_crate_test(compiler),\n-                    self.check_debuginfo(compiler),\n-                ];\n-\n-                // If we're testing the build triple, then we know we can\n-                // actually run binaries and such, so we run all possible tests\n-                // that we know about.\n-                if self.target == build.config.build {\n-                    base.extend(vec![\n-                        // docs-related\n-                        self.check_docs(compiler),\n-                        self.check_error_index(compiler),\n-                        self.check_rustdoc(compiler),\n-\n-                        // UI-related\n-                        self.check_cfail(compiler),\n-                        self.check_pfail(compiler),\n-                        self.check_ui(compiler),\n-\n-                        // codegen-related\n-                        self.check_incremental(compiler),\n-                        self.check_codegen(compiler),\n-                        self.check_codegen_units(compiler),\n-\n-                        // misc compiletest-test suites\n-                        self.check_rpass_full(compiler),\n-                        self.check_rfail_full(compiler),\n-                        self.check_cfail_full(compiler),\n-                        self.check_pretty_rpass_full(compiler),\n-                        self.check_pretty_rfail_full(compiler),\n-                        self.check_rpass_valgrind(compiler),\n-                        self.check_rmake(compiler),\n-                        self.check_mir_opt(compiler),\n-\n-                        // crates\n-                        self.check_crate_rustc(compiler),\n-\n-                        // pretty\n-                        self.check_pretty(compiler),\n-                        self.check_pretty_rpass(compiler),\n-                        self.check_pretty_rfail(compiler),\n-                        self.check_pretty_rpass_valgrind(compiler),\n-\n-                        // misc\n-                        self.check_linkcheck(stage),\n-                        self.check_tidy(stage),\n-\n-                        // can we make the distributables?\n-                        self.dist(stage),\n-                    ]);\n-                }\n-                base\n-            }\n-            Source::CheckLinkcheck { stage } => {\n-                vec![self.tool_linkchecker(stage), self.doc(stage)]\n-            }\n-            Source::CheckCargoTest { stage } => {\n-                vec![self.tool_cargotest(stage),\n-                     self.librustc(self.compiler(stage))]\n-            }\n-            Source::CheckTidy { stage } => {\n-                vec![self.tool_tidy(stage)]\n-            }\n-            Source::CheckMirOpt { compiler} |\n-            Source::CheckPrettyRPass { compiler } |\n-            Source::CheckPrettyRFail { compiler } |\n-            Source::CheckRFail { compiler } |\n-            Source::CheckPFail { compiler } |\n-            Source::CheckCodegen { compiler } |\n-            Source::CheckCodegenUnits { compiler } |\n-            Source::CheckIncremental { compiler } |\n-            Source::CheckUi { compiler } |\n-            Source::CheckPretty { compiler } |\n-            Source::CheckCFail { compiler } |\n-            Source::CheckRPassValgrind { compiler } |\n-            Source::CheckRPass { compiler } => {\n-                let mut base = vec![\n-                    self.libtest(compiler),\n-                    self.target(compiler.host).tool_compiletest(compiler.stage),\n-                    self.test_helpers(()),\n-                ];\n-                if self.target.contains(\"android\") {\n-                    base.push(self.android_copy_libs(compiler));\n-                }\n-                base\n-            }\n-            Source::CheckDebuginfo { compiler } => {\n-                vec![\n-                    self.libtest(compiler),\n-                    self.target(compiler.host).tool_compiletest(compiler.stage),\n-                    self.test_helpers(()),\n-                    self.debugger_scripts(compiler.stage),\n-                ]\n-            }\n-            Source::CheckRustdoc { compiler } |\n-            Source::CheckRPassFull { compiler } |\n-            Source::CheckRFailFull { compiler } |\n-            Source::CheckCFailFull { compiler } |\n-            Source::CheckPrettyRPassFull { compiler } |\n-            Source::CheckPrettyRFailFull { compiler } |\n-            Source::CheckPrettyRPassValgrind { compiler } |\n-            Source::CheckRMake { compiler } => {\n-                vec![self.librustc(compiler),\n-                     self.target(compiler.host).tool_compiletest(compiler.stage)]\n-            }\n-            Source::CheckDocs { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::CheckErrorIndex { compiler } => {\n-                vec![self.libstd(compiler),\n-                     self.target(compiler.host).tool_error_index(compiler.stage)]\n-            }\n-            Source::CheckCrateStd { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::CheckCrateTest { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n-            Source::CheckCrateRustc { compiler } => {\n-                vec![self.libtest(compiler)]\n-            }\n+    fn dist<'b>(&'b mut self, name: &'a str, path: &'a str)\n+                -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Dist)\n+    }\n \n-            Source::ToolLinkchecker { stage } |\n-            Source::ToolTidy { stage } => {\n-                vec![self.libstd(self.compiler(stage))]\n-            }\n-            Source::ToolErrorIndex { stage } |\n-            Source::ToolRustbook { stage } => {\n-                vec![self.librustc(self.compiler(stage))]\n-            }\n-            Source::ToolCargoTest { stage } => {\n-                vec![self.libstd(self.compiler(stage))]\n-            }\n-            Source::ToolCompiletest { stage } => {\n-                vec![self.libtest(self.compiler(stage))]\n-            }\n+    fn rule<'b>(&'b mut self,\n+                name: &'a str,\n+                path: &'a str,\n+                kind: Kind) -> RuleBuilder<'a, 'b> {\n+        RuleBuilder {\n+            rules: self,\n+            rule: Rule::new(name, path, kind),\n+        }\n+    }\n+\n+    /// Verify the dependency graph defined by all our rules are correct, e.g.\n+    /// everything points to a valid something else.\n+    fn verify(&self) {\n+        for rule in self.rules.values() {\n+            for dep in rule.deps.iter() {\n+                let dep = dep(&self.sbuild.name(rule.name));\n+                if self.rules.contains_key(&dep.name) || dep.name.starts_with(\"default:\") {\n+                    continue }\n+                panic!(\"\\\n+\n+invalid rule dependency graph detected, was a rule added and maybe typo'd?\n+\n+    `{}` depends on `{}` which does not exist\n \n-            Source::DistDocs { stage } => vec![self.doc(stage)],\n-            Source::DistMingw { _dummy: _ } => Vec::new(),\n-            Source::DistRustc { stage } => {\n-                vec![self.rustc(stage)]\n+\", rule.name, dep.name);\n             }\n-            Source::DistStd { compiler } => {\n-                // We want to package up as many target libraries as possible\n-                // for the `rust-std` package, so if this is a host target we\n-                // depend on librustc and otherwise we just depend on libtest.\n-                if build.config.host.iter().any(|t| t == self.target) {\n-                    vec![self.librustc(compiler)]\n+        }\n+    }\n+\n+    pub fn print_help(&self, command: &str) {\n+        let kind = match command {\n+            \"build\" => Kind::Build,\n+            \"doc\" => Kind::Doc,\n+            \"test\" => Kind::Test,\n+            \"dist\" => Kind::Dist,\n+            _ => return,\n+        };\n+        let rules = self.rules.values().filter(|r| r.kind == kind);\n+        let rules = rules.filter(|r| !r.path.contains(\"nowhere\"));\n+        let mut rules = rules.collect::<Vec<_>>();\n+        rules.sort_by_key(|r| r.path);\n+\n+        println!(\"Available paths:\\n\");\n+        for rule in rules {\n+            print!(\"    ./x.py {} {}\", command, rule.path);\n+\n+            println!(\"\");\n+        }\n+    }\n+\n+    /// Construct the top-level build steps that we're going to be executing,\n+    /// given the subcommand that our build is performing.\n+    fn plan(&self) -> Vec<Step<'a>> {\n+        let (kind, paths) = match self.build.flags.cmd {\n+            Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n+            Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n+            Subcommand::Test { ref paths, test_args: _ } => (Kind::Test, &paths[..]),\n+            Subcommand::Dist { install } => {\n+                if install {\n+                    return vec![self.sbuild.name(\"install\")]\n                 } else {\n-                    vec![self.libtest(compiler)]\n-                }\n-            }\n-            Source::DistSrc { _dummy: _ } => Vec::new(),\n-\n-            Source::Dist { stage } => {\n-                let mut base = Vec::new();\n-\n-                for host in build.config.host.iter() {\n-                    let host = self.target(host);\n-                    base.push(host.dist_src(()));\n-                    base.push(host.dist_rustc(stage));\n-                    if host.target.contains(\"windows-gnu\") {\n-                        base.push(host.dist_mingw(()));\n-                    }\n-\n-                    let compiler = self.compiler(stage);\n-                    for target in build.config.target.iter() {\n-                        let target = self.target(target);\n-                        if build.config.docs {\n-                            base.push(target.dist_docs(stage));\n-                        }\n-                        base.push(target.dist_std(compiler));\n-                    }\n+                    (Kind::Dist, &[][..])\n                 }\n-                base\n             }\n+            Subcommand::Clean => panic!(),\n+        };\n \n-            Source::Install { stage } => {\n-                vec![self.dist(stage)]\n-            }\n+        self.rules.values().filter(|rule| rule.kind == kind).filter(|rule| {\n+            (paths.len() == 0 && rule.default) || paths.iter().any(|path| {\n+                path.ends_with(rule.path)\n+            })\n+        }).flat_map(|rule| {\n+            let hosts = if self.build.flags.host.len() > 0 {\n+                &self.build.flags.host\n+            } else {\n+                &self.build.config.host\n+            };\n+            let targets = if self.build.flags.target.len() > 0 {\n+                &self.build.flags.target\n+            } else {\n+                &self.build.config.target\n+            };\n+            let arr = if rule.host {hosts} else {targets};\n+\n+            hosts.iter().flat_map(move |host| {\n+                arr.iter().map(move |target| {\n+                    self.sbuild.name(rule.name).target(target).host(host)\n+                })\n+            })\n+        }).collect()\n+    }\n+\n+    /// Execute all top-level targets indicated by `steps`.\n+    ///\n+    /// This will take the list returned by `plan` and then execute each step\n+    /// along with all required dependencies as it goes up the chain.\n+    fn run(&self, steps: &[Step<'a>]) {\n+        self.build.verbose(\"bootstrap top targets:\");\n+        for step in steps.iter() {\n+            self.build.verbose(&format!(\"\\t{:?}\", step));\n+        }\n+\n+        // Using `steps` as the top-level targets, make a topological ordering\n+        // of what we need to do.\n+        let mut order = Vec::new();\n+        let mut added = HashSet::new();\n+        for step in steps.iter().cloned() {\n+            self.fill(step, &mut order, &mut added);\n+        }\n \n-            Source::AndroidCopyLibs { compiler } => {\n-                vec![self.libtest(compiler)]\n+        // Print out what we're doing for debugging\n+        self.build.verbose(\"bootstrap build plan:\");\n+        for step in order.iter() {\n+            self.build.verbose(&format!(\"\\t{:?}\", step));\n+        }\n+\n+        // And finally, iterate over everything and execute it.\n+        for step in order.iter() {\n+            self.build.verbose(&format!(\"executing step {:?}\", step));\n+            (self.rules[step.name].run)(step);\n+        }\n+    }\n+\n+    fn fill(&self,\n+            step: Step<'a>,\n+            order: &mut Vec<Step<'a>>,\n+            added: &mut HashSet<Step<'a>>) {\n+        if !added.insert(step.clone()) {\n+            return\n+        }\n+        for dep in self.rules[step.name].deps.iter() {\n+            let dep = dep(&step);\n+            if dep.name.starts_with(\"default:\") {\n+                let kind = match &dep.name[8..] {\n+                    \"doc\" => Kind::Doc,\n+                    \"dist\" => Kind::Dist,\n+                    kind => panic!(\"unknown kind: `{}`\", kind),\n+                };\n+                let rules = self.rules.values().filter(|r| r.default);\n+                for rule in rules.filter(|r| r.kind == kind) {\n+                    self.fill(dep.name(rule.name), order, added);\n+                }\n+            } else {\n+                self.fill(dep, order, added);\n             }\n         }\n+        order.push(step);\n     }\n }"}, {"sha": "e028c52236662bb23d60a143d6863f7badffb3ac", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -57,8 +57,7 @@ pub fn cp_r(src: &Path, dst: &Path) {\n         let name = path.file_name().unwrap();\n         let dst = dst.join(name);\n         if t!(f.file_type()).is_dir() {\n-            let _ = fs::remove_dir_all(&dst);\n-            t!(fs::create_dir(&dst));\n+            t!(fs::create_dir_all(&dst));\n             cp_r(&path, &dst);\n         } else {\n             let _ = fs::remove_file(&dst);\n@@ -172,3 +171,21 @@ pub fn dylib_path() -> Vec<PathBuf> {\n     env::split_paths(&env::var_os(dylib_path_var()).unwrap_or(OsString::new()))\n         .collect()\n }\n+\n+/// `push` all components to `buf`. On windows, append `.exe` to the last component.\n+pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n+    let (&file, components) = components.split_last().expect(\"at least one component required\");\n+    let mut file = file.to_owned();\n+\n+    if cfg!(windows) {\n+        file.push_str(\".exe\");\n+    }\n+\n+    for c in components {\n+        buf.push(c);\n+    }\n+\n+    buf.push(file);\n+\n+    buf\n+}"}, {"sha": "ecd2b1f6d689d5afbf5debe8afb3739337323852", "filename": "src/compiler-rt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler-rt?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -1 +1 @@\n-Subproject commit f03ba5a4e8bf16dcf42dd742a4ce255c36321356\n+Subproject commit ecd2b1f6d689d5afbf5debe8afb3739337323852"}, {"sha": "fa9f66d43baa1ae7105c76516d1b8729663730f6", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -327,7 +327,7 @@ that takes a reference like so:\n fn call_with_ref<F>(some_closure:F) -> i32\n     where F: Fn(&i32) -> i32 {\n \n-    let mut value = 0;\n+    let value = 0;\n     some_closure(&value)\n }\n ```\n@@ -340,14 +340,15 @@ fn call_with_ref<'a, F>(some_closure:F) -> i32\n     where F: Fn(&'a i32) -> i32 {\n ```\n \n-However this presents a problem in our case. When you specify the explicit\n-lifetime on a function it binds that lifetime to the *entire* scope of the function\n-instead of just the invocation scope of our closure. This means that the borrow checker\n-will see a mutable reference in the same lifetime as our immutable reference and fail\n-to compile.\n+However, this presents a problem in our case. When a function has an explicit\n+lifetime parameter, that lifetime must be at least as long as the *entire*\n+call to that function.  The borrow checker will complain that `value` doesn't\n+live long enough, because it is only in scope after its declaration inside the\n+function body.\n \n-In order to say that we only need the lifetime to be valid for the invocation scope\n-of the closure we can use Higher-Ranked Trait Bounds with the `for<...>` syntax:\n+What we need is a closure that can borrow its argument only for its own\n+invocation scope, not for the outer function's scope.  In order to say that,\n+we can use Higher-Ranked Trait Bounds with the `for<...>` syntax:\n \n ```ignore\n fn call_with_ref<F>(some_closure:F) -> i32\n@@ -362,7 +363,7 @@ expect.\n fn call_with_ref<F>(some_closure:F) -> i32\n     where F: for<'a> Fn(&'a i32) -> i32 {\n \n-    let mut value = 0;\n+    let value = 0;\n     some_closure(&value)\n }\n ```"}, {"sha": "2eab449dbd421094809e0a3c0eee33172e57759d", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 12, "deletions": 99, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -4,112 +4,25 @@ This first chapter of the book will get us going with Rust and its tooling.\n First, we\u2019ll install Rust. Then, the classic \u2018Hello World\u2019 program. Finally,\n we\u2019ll talk about Cargo, Rust\u2019s build system and package manager.\n \n+We\u2019ll be showing off a number of commands using a terminal, and those lines all\n+start with `$`. You don't need to type in the `$`s, they are there to indicate\n+the start of each command. We\u2019ll see many tutorials and examples around the web\n+that follow this convention: `$` for commands run as our regular user, and `#`\n+for commands we should be running as an administrator.\n+\n # Installing Rust\n \n The first step to using Rust is to install it. Generally speaking, you\u2019ll need\n an Internet connection to run the commands in this section, as we\u2019ll be\n downloading Rust from the Internet.\n \n-We\u2019ll be showing off a number of commands using a terminal, and those lines all\n-start with `$`. You don't need to type in the `$`s, they are there to indicate\n-the start of each command. We\u2019ll see many tutorials and examples around the web\n-that follow this convention: `$` for commands run as our regular user, and `#`\n-for commands we should be running as an administrator.\n+The Rust compiler runs on, and compiles to, a great number of platforms, but is\n+best supported on Linux, Mac, and Windows, on the x86 and x86-64 CPU\n+architecture. There are official builds of the Rust compiler and standard\n+library for these platforms and more. [For full details on Rust platform support\n+see the website][platform-support].\n \n-## Platform support\n-\n-The Rust compiler runs on, and compiles to, a great number of platforms, though\n-not all platforms are equally supported. Rust's support levels are organized\n-into three tiers, each with a different set of guarantees.\n-\n-Platforms are identified by their \"target triple\" which is the string to inform\n-the compiler what kind of output should be produced. The columns below indicate\n-whether the corresponding component works on the specified platform.\n-\n-### Tier 1\n-\n-Tier 1 platforms can be thought of as \"guaranteed to build and work\".\n-Specifically they will each satisfy the following requirements:\n-\n-* Automated testing is set up to run tests for the platform.\n-* Landing changes to the `rust-lang/rust` repository's master branch is gated on\n-  tests passing.\n-* Official release artifacts are provided for the platform.\n-* Documentation for how to use and how to build the platform is available.\n-\n-|  Target                       | std |rustc|cargo| notes                      |\n-|-------------------------------|-----|-----|-----|----------------------------|\n-| `i686-apple-darwin`           |  \u2713  |  \u2713  |  \u2713  | 32-bit OSX (10.7+, Lion+)  |\n-| `i686-pc-windows-gnu`         |  \u2713  |  \u2713  |  \u2713  | 32-bit MinGW (Windows 7+)  |\n-| `i686-pc-windows-msvc`        |  \u2713  |  \u2713  |  \u2713  | 32-bit MSVC (Windows 7+)   |\n-| `i686-unknown-linux-gnu`      |  \u2713  |  \u2713  |  \u2713  | 32-bit Linux (2.6.18+)     |\n-| `x86_64-apple-darwin`         |  \u2713  |  \u2713  |  \u2713  | 64-bit OSX (10.7+, Lion+)  |\n-| `x86_64-pc-windows-gnu`       |  \u2713  |  \u2713  |  \u2713  | 64-bit MinGW (Windows 7+)  |\n-| `x86_64-pc-windows-msvc`      |  \u2713  |  \u2713  |  \u2713  | 64-bit MSVC (Windows 7+)   |\n-| `x86_64-unknown-linux-gnu`    |  \u2713  |  \u2713  |  \u2713  | 64-bit Linux (2.6.18+)     |\n-\n-### Tier 2\n-\n-Tier 2 platforms can be thought of as \"guaranteed to build\". Automated tests\n-are not run so it's not guaranteed to produce a working build, but platforms\n-often work to quite a good degree and patches are always welcome! Specifically,\n-these platforms are required to have each of the following:\n-\n-* Automated building is set up, but may not be running tests.\n-* Landing changes to the `rust-lang/rust` repository's master branch is gated on\n-  platforms **building**. Note that this means for some platforms only the\n-  standard library is compiled, but for others the full bootstrap is run.\n-* Official release artifacts are provided for the platform.\n-\n-|  Target                       | std |rustc|cargo| notes                      |\n-|-------------------------------|-----|-----|-----|----------------------------|\n-| `aarch64-apple-ios`           |  \u2713  |     |     | ARM64 iOS                  |\n-| `aarch64-unknown-linux-gnu`   |  \u2713  |  \u2713  |  \u2713  | ARM64 Linux (2.6.18+)      |\n-| `arm-linux-androideabi`       |  \u2713  |     |     | ARM Android                |\n-| `arm-unknown-linux-gnueabi`   |  \u2713  |  \u2713  |  \u2713  | ARM Linux (2.6.18+)        |\n-| `arm-unknown-linux-gnueabihf` |  \u2713  |  \u2713  |  \u2713  | ARM Linux (2.6.18+)        |\n-| `armv7-apple-ios`             |  \u2713  |     |     | ARM iOS                    |\n-|`armv7-unknown-linux-gnueabihf`|  \u2713  |  \u2713  |  \u2713  | ARMv7 Linux (2.6.18+)      |\n-| `armv7s-apple-ios`            |  \u2713  |     |     | ARM iOS                    |\n-| `i386-apple-ios`              |  \u2713  |     |     | 32-bit x86 iOS             |\n-| `i586-pc-windows-msvc`        |  \u2713  |     |     | 32-bit Windows w/o SSE     |\n-| `mips-unknown-linux-gnu`      |  \u2713  |     |     | MIPS Linux (2.6.18+)       |\n-| `mips-unknown-linux-musl`     |  \u2713  |     |     | MIPS Linux with MUSL       |\n-| `mipsel-unknown-linux-gnu`    |  \u2713  |     |     | MIPS (LE) Linux (2.6.18+)  |\n-| `mipsel-unknown-linux-musl`   |  \u2713  |     |     | MIPS (LE) Linux with MUSL  |\n-| `powerpc-unknown-linux-gnu`   |  \u2713  |     |     | PowerPC Linux (2.6.18+)    |\n-| `powerpc64-unknown-linux-gnu` |  \u2713  |     |     | PPC64 Linux (2.6.18+)      |\n-|`powerpc64le-unknown-linux-gnu`|  \u2713  |     |     | PPC64LE Linux (2.6.18+)    |\n-| `x86_64-apple-ios`            |  \u2713  |     |     | 64-bit x86 iOS             |\n-| `x86_64-rumprun-netbsd`       |  \u2713  |     |     | 64-bit NetBSD Rump Kernel  |\n-| `x86_64-unknown-freebsd`      |  \u2713  |  \u2713  |  \u2713  | 64-bit FreeBSD             |\n-| `x86_64-unknown-linux-musl`   |  \u2713  |     |     | 64-bit Linux with MUSL     |\n-| `x86_64-unknown-netbsd`       |  \u2713  |  \u2713  |  \u2713  | 64-bit NetBSD              |\n-\n-### Tier 3\n-\n-Tier 3 platforms are those which Rust has support for, but landing changes is\n-not gated on the platform either building or passing tests. Working builds for\n-these platforms may be spotty as their reliability is often defined in terms of\n-community contributions. Additionally, release artifacts and installers are not\n-provided, but there may be community infrastructure producing these in\n-unofficial locations.\n-\n-|  Target                       | std |rustc|cargo| notes                      |\n-|-------------------------------|-----|-----|-----|----------------------------|\n-| `aarch64-linux-android`       |  \u2713  |     |     | ARM64 Android              |\n-| `armv7-linux-androideabi`     |  \u2713  |     |     | ARM-v7a Android            |\n-| `i686-linux-android`          |  \u2713  |     |     | 32-bit x86 Android         |\n-| `i686-pc-windows-msvc` (XP)   |  \u2713  |     |     | Windows XP support         |\n-| `i686-unknown-freebsd`        |  \u2713  |  \u2713  |  \u2713  | 32-bit FreeBSD             |\n-| `x86_64-pc-windows-msvc` (XP) |  \u2713  |     |     | Windows XP support         |\n-| `x86_64-sun-solaris`          |  \u2713  |  \u2713  |     | 64-bit Solaris/SunOS       |\n-| `x86_64-unknown-bitrig`       |  \u2713  |  \u2713  |     | 64-bit Bitrig              |\n-| `x86_64-unknown-dragonfly`    |  \u2713  |  \u2713  |     | 64-bit DragonFlyBSD        |\n-| `x86_64-unknown-openbsd`      |  \u2713  |  \u2713  |     | 64-bit OpenBSD             |\n-\n-Note that this table can be expanded over time, this isn't the exhaustive set of\n-tier 3 platforms that will ever be!\n+[platform-support]: https://forge.rust-lang.org/platform-support.html\n \n ## Installing on Linux or Mac\n "}, {"sha": "e2a23979a819a0c637695ce5892c39d12142f250", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -19,6 +19,7 @@ has a command that does that for us. Let\u2019s give it a shot:\n ```bash\n $ cd ~/projects\n $ cargo new guessing_game --bin\n+     Created binary (application) `guessing_game` project\n $ cd guessing_game\n ```\n \n@@ -51,6 +52,7 @@ Let\u2019s try compiling what Cargo gave us:\n ```{bash}\n $ cargo build\n    Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.53 secs\n ```\n \n Excellent! Open up your `src/main.rs` again. We\u2019ll be writing all of\n@@ -61,6 +63,7 @@ Remember the `run` command from last chapter? Try it out again here:\n ```bash\n $ cargo run\n    Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n      Running `target/debug/guessing_game`\n Hello, world!\n ```\n@@ -282,10 +285,13 @@ we\u2019ll get a warning:\n ```bash\n $ cargo build\n    Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n-src/main.rs:10:5: 10:39 warning: unused result which must be used,\n-#[warn(unused_must_use)] on by default\n-src/main.rs:10     io::stdin().read_line(&mut guess);\n-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+warning: unused result which must be used, #[warn(unused_must_use)] on by default\n+  --> src/main.rs:10:5\n+   |\n+10 |     io::stdin().read_line(&mut guess);\n+   |     ^\n+\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.42 secs\n ```\n \n Rust warns us that we haven\u2019t used the `Result` value. This warning comes from\n@@ -321,6 +327,7 @@ Anyway, that\u2019s the tour. We can run what we have with `cargo run`:\n ```bash\n $ cargo run\n    Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.44 secs\n      Running `target/debug/guessing_game`\n Guess the number!\n Please input your guess.\n@@ -373,11 +380,12 @@ Now, without changing any of our code, let\u2019s build our project:\n ```bash\n $ cargo build\n     Updating registry `https://github.com/rust-lang/crates.io-index`\n- Downloading rand v0.3.8\n- Downloading libc v0.1.6\n-   Compiling libc v0.1.6\n-   Compiling rand v0.3.8\n+ Downloading rand v0.3.14\n+ Downloading libc v0.2.17\n+   Compiling libc v0.2.17\n+   Compiling rand v0.3.14\n    Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+    Finished debug [unoptimized + debuginfo] target(s) in 5.88 secs\n ```\n \n (You may see different versions, of course.)\n@@ -399,22 +407,24 @@ If we run `cargo build` again, we\u2019ll get different output:\n \n ```bash\n $ cargo build\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n ```\n \n-That\u2019s right, no output! Cargo knows that our project has been built, and that\n+That\u2019s right, nothing was done! Cargo knows that our project has been built, and that\n all of its dependencies are built, and so there\u2019s no reason to do all that\n stuff. With nothing to do, it simply exits. If we open up `src/main.rs` again,\n-make a trivial change, and then save it again, we\u2019ll only see one line:\n+make a trivial change, and then save it again, we\u2019ll only see two lines:\n \n ```bash\n $ cargo build\n    Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.45 secs\n ```\n \n So, we told Cargo we wanted any `0.3.x` version of `rand`, and so it fetched the latest\n-version at the time this was written, `v0.3.8`. But what happens when next\n-week, version `v0.3.9` comes out, with an important bugfix? While getting\n-bugfixes is important, what if `0.3.9` contains a regression that breaks our\n+version at the time this was written, `v0.3.14`. But what happens when next\n+week, version `v0.3.15` comes out, with an important bugfix? While getting\n+bugfixes is important, what if `0.3.15` contains a regression that breaks our\n code?\n \n The answer to this problem is the `Cargo.lock` file you\u2019ll now find in your\n@@ -423,11 +433,11 @@ figures out all of the versions that fit your criteria, and then writes them\n to the `Cargo.lock` file. When you build your project in the future, Cargo\n will see that the `Cargo.lock` file exists, and then use that specific version\n rather than do all the work of figuring out versions again. This lets you\n-have a repeatable build automatically. In other words, we\u2019ll stay at `0.3.8`\n+have a repeatable build automatically. In other words, we\u2019ll stay at `0.3.14`\n until we explicitly upgrade, and so will anyone who we share our code with,\n thanks to the lock file.\n \n-What about when we _do_ want to use `v0.3.9`? Cargo has another command,\n+What about when we _do_ want to use `v0.3.15`? Cargo has another command,\n `update`, which says \u2018ignore the lock, figure out all the latest versions that\n fit what we\u2019ve specified. If that works, write those versions out to the lock\n file\u2019. But, by default, Cargo will only look for versions larger than `0.3.0`\n@@ -510,13 +520,15 @@ Try running our new program a few times:\n ```bash\n $ cargo run\n    Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.55 secs\n      Running `target/debug/guessing_game`\n Guess the number!\n The secret number is: 7\n Please input your guess.\n 4\n You guessed: 4\n $ cargo run\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n      Running `target/debug/guessing_game`\n Guess the number!\n The secret number is: 83\n@@ -618,15 +630,20 @@ I did mention that this won\u2019t quite compile yet, though. Let\u2019s try it:\n ```bash\n $ cargo build\n    Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n-src/main.rs:28:21: 28:35 error: mismatched types:\n- expected `&collections::string::String`,\n-    found `&_`\n-(expected struct `collections::string::String`,\n-    found integral variable) [E0308]\n-src/main.rs:28     match guess.cmp(&secret_number) {\n-                                   ^~~~~~~~~~~~~~\n+error[E0308]: mismatched types\n+  --> src/main.rs:23:21\n+   |\n+23 |     match guess.cmp(&secret_number) {\n+   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable\n+   |\n+   = note: expected type `&std::string::String`\n+   = note:    found type `&{integer}`\n+\n error: aborting due to previous error\n-Could not compile `guessing_game`.\n+\n+error: Could not compile `guessing_game`.\n+\n+To learn more, run the command again with --verbose.\n ```\n \n Whew! This is a big error. The core of it is that we have \u2018mismatched types\u2019.\n@@ -722,6 +739,7 @@ Let\u2019s try our program out!\n ```bash\n $ cargo run\n    Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.57 secs\n      Running `target/guessing_game`\n Guess the number!\n The secret number is: 58\n@@ -785,6 +803,7 @@ and quit. Observe:\n ```bash\n $ cargo run\n    Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.58 secs\n      Running `target/guessing_game`\n Guess the number!\n The secret number is: 59\n@@ -919,6 +938,7 @@ Now we should be good! Let\u2019s try:\n ```bash\n $ cargo run\n    Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+    Finished debug [unoptimized + debuginfo] target(s) in 0.57 secs\n      Running `target/guessing_game`\n Guess the number!\n The secret number is: 61"}, {"sha": "d6960b10b0805109f4d1027462bb11a7c3a19c74", "filename": "src/doc/book/structs.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Fbook%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Fbook%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fstructs.md?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -61,7 +61,7 @@ write something like this:\n \n ```rust,ignore\n struct Point {\n-    mut x: i32,\n+    mut x: i32, // This causes an error.\n     y: i32,\n }\n ```"}, {"sha": "28403711cd701f212db25d4e9b59cbdf69b47a3b", "filename": "src/doc/book/syntax-index.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Fbook%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Fbook%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsyntax-index.md?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -94,6 +94,7 @@\n * `|=` (`var |= expr`): bitwise or & assignment. Overloadable (`BitOrAssign`).\n * `||` (`expr || expr`): logical or.\n * `_`: \"ignored\" pattern binding (see [Patterns (Ignoring bindings)]). Also used to make integer-literals readable (see [Reference (Integer literals)]).\n+* `?` (`expr?`): Error propagation. Returns early when `Err(_)` is encountered, unwraps otherwise. Similar to the [`try!` macro].\n \n ## Other Syntax\n \n@@ -210,6 +211,7 @@\n [Functions]: functions.html\n [Generics]: generics.html\n [Iterators]: iterators.html\n+[`try!` macro]: error-handling.html#the-try-macro\n [Lifetimes]: lifetimes.html\n [Loops (`for`)]: loops.html#for\n [Loops (`loop`)]: loops.html#loop"}, {"sha": "0596e476d5f6c14dfb7271a04e5a84f5ab289440", "filename": "src/doc/reference.md", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -21,6 +21,11 @@ separately by extracting documentation attributes from their source code. Many\n of the features that one might expect to be language features are library\n features in Rust, so what you're looking for may be there, not here.\n \n+Finally, this document is not normative. It may include details that are\n+specific to `rustc` itself, and should not be taken as a specification for\n+the Rust language. We intend to produce such a document someday, but this\n+is what we have for now.\n+\n You may also be interested in the [grammar].\n \n [book]: book/index.html\n@@ -2479,8 +2484,6 @@ The currently implemented features of the reference compiler are:\n * - `abi_vectorcall` - Allows the usage of the vectorcall calling convention\n                              (e.g. `extern \"vectorcall\" func fn_();`)\n \n-* - `dotdot_in_tuple_patterns` - Allows `..` in tuple (struct) patterns.\n-\n * - `abi_sysv64` - Allows the usage of the system V AMD64 calling convention\n                              (e.g. `extern \"sysv64\" func fn_();`)\n \n@@ -2860,8 +2863,8 @@ assert_eq!(x, y);\n \n ### Unary operator expressions\n \n-Rust defines the following unary operators. They are all written as prefix operators,\n-before the expression they apply to.\n+Rust defines the following unary operators. With the exception of `?`, they are\n+all written as prefix operators, before the expression they apply to.\n \n * `-`\n   : Negation. Signed integer types and floating-point types support negation. It\n@@ -2890,6 +2893,10 @@ before the expression they apply to.\n     If the `&` or `&mut` operators are applied to an rvalue, a\n     temporary value is created; the lifetime of this temporary value\n     is defined by [syntactic rules](#temporary-lifetimes).\n+* `?`\n+  : Propagating errors if applied to `Err(_)` and unwrapping if\n+    applied to `Ok(_)`. Only works on the `Result<T, E>` type,\n+    and written in postfix notation.\n \n ### Binary operator expressions\n \n@@ -3755,6 +3762,21 @@ The special type `Self` has a meaning within traits and impls. In a trait defini\n to an implicit type parameter representing the \"implementing\" type. In an impl,\n it is an alias for the implementing type. For example, in:\n \n+```\n+pub trait From<T> {\n+    fn from(T) -> Self;\n+}\n+\n+impl From<i32> for String {\n+    fn from(x: i32) -> Self {\n+        x.to_string()\n+    }\n+}\n+```\n+\n+The notation `Self` in the impl refers to the implementing type: `String`. In another \n+example:\n+\n ```\n trait Printable {\n     fn make_string(&self) -> String;"}, {"sha": "3a7da18c8deb1f23624f56142fc0ae8bb77f9e1a", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 94, "deletions": 5, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -36,6 +36,10 @@ use core::{isize, usize};\n use core::convert::From;\n use heap::deallocate;\n \n+/// A soft limit on the amount of references that may be made to an `Arc`.\n+///\n+/// Going above this limit will abort your program (although not\n+/// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n /// A thread-safe reference-counting pointer.\n@@ -270,6 +274,68 @@ impl<T> Arc<T> {\n             Ok(elem)\n         }\n     }\n+\n+    /// Consumes the `Arc`, returning the wrapped pointer.\n+    ///\n+    /// To avoid a memory leak the pointer must be converted back to an `Arc` using\n+    /// [`Arc::from_raw`][from_raw].\n+    ///\n+    /// [from_raw]: struct.Arc.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(10);\n+    /// let x_ptr = Arc::into_raw(x);\n+    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub fn into_raw(this: Self) -> *mut T {\n+        let ptr = unsafe { &mut (**this.ptr).data as *mut _ };\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Constructs an `Arc` from a raw pointer.\n+    ///\n+    /// The raw pointer must have been previously returned by a call to a\n+    /// [`Arc::into_raw`][into_raw].\n+    ///\n+    /// This function is unsafe because improper use may lead to memory problems. For example, a\n+    /// double-free may occur if the function is called twice on the same raw pointer.\n+    ///\n+    /// [into_raw]: struct.Arc.html#method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(10);\n+    /// let x_ptr = Arc::into_raw(x);\n+    ///\n+    /// unsafe {\n+    ///     // Convert back to an `Arc` to prevent leak.\n+    ///     let x = Arc::from_raw(x_ptr);\n+    ///     assert_eq!(*x, 10);\n+    ///\n+    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n+    /// }\n+    ///\n+    /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub unsafe fn from_raw(ptr: *mut T) -> Self {\n+        // To find the corresponding pointer to the `ArcInner` we need to subtract the offset of the\n+        // `data` field from the pointer.\n+        Arc { ptr: Shared::new((ptr as *mut u8).offset(-offset_of!(ArcInner<T>, data)) as *mut _) }\n+    }\n }\n \n impl<T: ?Sized> Arc<T> {\n@@ -315,11 +381,14 @@ impl<T: ?Sized> Arc<T> {\n \n     /// Gets the number of [`Weak`][weak] pointers to this value.\n     ///\n-    /// Be careful how you use this information, because another thread\n-    /// may change the weak count at any time.\n-    ///\n     /// [weak]: struct.Weak.html\n     ///\n+    /// # Safety\n+    ///\n+    /// This method by itself is safe, but using it correctly requires extra care.\n+    /// Another thread can change the weak count at any time,\n+    /// including potentially between calling this method and acting on the result.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -343,8 +412,11 @@ impl<T: ?Sized> Arc<T> {\n \n     /// Gets the number of strong (`Arc`) pointers to this value.\n     ///\n-    /// Be careful how you use this information, because another thread\n-    /// may change the strong count at any time.\n+    /// # Safety\n+    ///\n+    /// This method by itself is safe, but using it correctly requires extra care.\n+    /// Another thread can change the strong count at any time,\n+    /// including potentially between calling this method and acting on the result.\n     ///\n     /// # Examples\n     ///\n@@ -1179,6 +1251,23 @@ mod tests {\n         assert_eq!(Arc::try_unwrap(x), Ok(5));\n     }\n \n+    #[test]\n+    fn into_from_raw() {\n+        let x = Arc::new(box \"hello\");\n+        let y = x.clone();\n+\n+        let x_ptr = Arc::into_raw(x);\n+        drop(y);\n+        unsafe {\n+            assert_eq!(**x_ptr, \"hello\");\n+\n+            let x = Arc::from_raw(x_ptr);\n+            assert_eq!(**x, \"hello\");\n+\n+            assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+        }\n+    }\n+\n     #[test]\n     fn test_cowarc_clone_make_mut() {\n         let mut cow0 = Arc::new(75);"}, {"sha": "0d450184ed8773fc10339485ef53d11a638e35eb", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -99,6 +99,10 @@\n #[macro_use]\n extern crate std;\n \n+// Module with internal macros used by other modules (needs to be included before other modules).\n+#[macro_use]\n+mod macros;\n+\n // Heaps provided for low-level allocation strategies\n \n pub mod heap;"}, {"sha": "7da91c87e967e5beff35a4e4795985115934cb24", "filename": "src/liballoc/macros.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Private macro to get the offset of a struct field in bytes from the address of the struct.\n+macro_rules! offset_of {\n+    ($container:path, $field:ident) => {{\n+        // Make sure the field actually exists. This line ensures that a compile-time error is\n+        // generated if $field is accessed through a Deref impl.\n+        let $container { $field : _, .. };\n+\n+        // Create an (invalid) instance of the container and calculate the offset to its\n+        // field. Using a null pointer might be UB if `&(*(0 as *const T)).field` is interpreted to\n+        // be nullptr deref.\n+        let invalid: $container = ::core::mem::uninitialized();\n+        let offset = &invalid.$field as *const _ as usize - &invalid as *const _ as usize;\n+\n+        // Do not run destructors on the made up invalid instance.\n+        ::core::mem::forget(invalid);\n+        offset as isize\n+    }};\n+}"}, {"sha": "8d863d7d9e917ba6656141f13dcab74dbda32551", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -364,6 +364,68 @@ impl<T> Rc<T> {\n     pub fn would_unwrap(this: &Self) -> bool {\n         Rc::strong_count(&this) == 1\n     }\n+\n+    /// Consumes the `Rc`, returning the wrapped pointer.\n+    ///\n+    /// To avoid a memory leak the pointer must be converted back to an `Rc` using\n+    /// [`Rc::from_raw`][from_raw].\n+    ///\n+    /// [from_raw]: struct.Rc.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x = Rc::new(10);\n+    /// let x_ptr = Rc::into_raw(x);\n+    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub fn into_raw(this: Self) -> *mut T {\n+        let ptr = unsafe { &mut (**this.ptr).value as *mut _ };\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Constructs an `Rc` from a raw pointer.\n+    ///\n+    /// The raw pointer must have been previously returned by a call to a\n+    /// [`Rc::into_raw`][into_raw].\n+    ///\n+    /// This function is unsafe because improper use may lead to memory problems. For example, a\n+    /// double-free may occur if the function is called twice on the same raw pointer.\n+    ///\n+    /// [into_raw]: struct.Rc.html#method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x = Rc::new(10);\n+    /// let x_ptr = Rc::into_raw(x);\n+    ///\n+    /// unsafe {\n+    ///     // Convert back to an `Rc` to prevent leak.\n+    ///     let x = Rc::from_raw(x_ptr);\n+    ///     assert_eq!(*x, 10);\n+    ///\n+    ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory unsafe.\n+    /// }\n+    ///\n+    /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub unsafe fn from_raw(ptr: *mut T) -> Self {\n+        // To find the corresponding pointer to the `RcBox` we need to subtract the offset of the\n+        // `value` field from the pointer.\n+        Rc { ptr: Shared::new((ptr as *mut u8).offset(-offset_of!(RcBox<T>, value)) as *mut _) }\n+    }\n }\n \n impl Rc<str> {\n@@ -1287,6 +1349,23 @@ mod tests {\n         assert_eq!(Rc::try_unwrap(x), Ok(5));\n     }\n \n+    #[test]\n+    fn into_from_raw() {\n+        let x = Rc::new(box \"hello\");\n+        let y = x.clone();\n+\n+        let x_ptr = Rc::into_raw(x);\n+        drop(y);\n+        unsafe {\n+            assert_eq!(**x_ptr, \"hello\");\n+\n+            let x = Rc::from_raw(x_ptr);\n+            assert_eq!(**x, \"hello\");\n+\n+            assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+        }\n+    }\n+\n     #[test]\n     fn get_mut() {\n         let mut x = Rc::new(3);"}, {"sha": "37618b7600a045d340869403f786709a0b0b235e", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -17,6 +17,7 @@ use core::hash::{Hash, Hasher};\n use core::ops::{Add, AddAssign, Deref};\n \n use fmt;\n+use string::String;\n \n use self::Cow::*;\n \n@@ -159,7 +160,10 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n         match *self {\n             Borrowed(borrowed) => {\n                 *self = Owned(borrowed.to_owned());\n-                self.to_mut()\n+                match *self {\n+                    Borrowed(..) => unreachable!(),\n+                    Owned(ref mut owned) => owned,\n+                }\n             }\n             Owned(ref mut owned) => owned,\n         }\n@@ -284,48 +288,60 @@ impl<'a, T: ?Sized + ToOwned> AsRef<T> for Cow<'a, T> {\n     }\n }\n \n-#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+#[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> Add<&'a str> for Cow<'a, str> {\n     type Output = Cow<'a, str>;\n \n-    fn add(self, rhs: &'a str) -> Self {\n-        if self == \"\" {\n-            Cow::Borrowed(rhs)\n-        } else if rhs == \"\" {\n-            self\n-        } else {\n-            Cow::Owned(self.into_owned() + rhs)\n-        }\n+    #[inline]\n+    fn add(mut self, rhs: &'a str) -> Self::Output {\n+        self += rhs;\n+        self\n     }\n }\n \n-#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+#[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> Add<Cow<'a, str>> for Cow<'a, str> {\n     type Output = Cow<'a, str>;\n \n-    fn add(self, rhs: Cow<'a, str>) -> Self {\n-        if self == \"\" {\n-            rhs\n-        } else if rhs == \"\" {\n-            self\n-        } else {\n-            Cow::Owned(self.into_owned() + rhs.borrow())\n-        }\n+    #[inline]\n+    fn add(mut self, rhs: Cow<'a, str>) -> Self::Output {\n+        self += rhs;\n+        self\n     }\n }\n \n-#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+#[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> AddAssign<&'a str> for Cow<'a, str> {\n     fn add_assign(&mut self, rhs: &'a str) {\n-        if rhs == \"\" { return; }\n-        self.to_mut().push_str(rhs);\n+        if self.is_empty() {\n+            *self = Cow::Borrowed(rhs)\n+        } else if rhs.is_empty() {\n+            return;\n+        } else {\n+            if let Cow::Borrowed(lhs) = *self {\n+                let mut s = String::with_capacity(lhs.len() + rhs.len());\n+                s.push_str(lhs);\n+                *self = Cow::Owned(s);\n+            }\n+            self.to_mut().push_str(rhs);\n+        }\n     }\n }\n \n-#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+#[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> AddAssign<Cow<'a, str>> for Cow<'a, str> {\n     fn add_assign(&mut self, rhs: Cow<'a, str>) {\n-        if rhs == \"\" { return; }\n-        self.to_mut().push_str(rhs.borrow());\n+        if self.is_empty() {\n+            *self = rhs\n+        } else if rhs.is_empty() {\n+            return;\n+        } else {\n+            if let Cow::Borrowed(lhs) = *self {\n+                let mut s = String::with_capacity(lhs.len() + rhs.len());\n+                s.push_str(lhs);\n+                *self = Cow::Owned(s);\n+            }\n+            self.to_mut().push_str(&rhs);\n+        }\n     }\n }"}, {"sha": "23d6edd6d794e88c86cc7b2cfc2d0267365a2ee6", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -50,6 +50,7 @@\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(step_by)]\n+#![feature(trusted_len)]\n #![feature(unicode)]\n #![feature(unique)]\n #![cfg_attr(test, feature(rand, test))]"}, {"sha": "348eb6fb5ffa4806c5ff7b1fcfcefd9db5166735", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -1904,10 +1904,10 @@ impl<'a> FromIterator<String> for Cow<'a, str> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Into<Vec<u8>> for String {\n-    fn into(self) -> Vec<u8> {\n-        self.into_bytes()\n+#[stable(feature = \"from_string_for_vec_u8\", since = \"1.14.0\")]\n+impl From<String> for Vec<u8> {\n+    fn from(string : String) -> Vec<u8> {\n+        string.into_bytes()\n     }\n }\n "}, {"sha": "71c49ee616cbced754c823e495b7b31aaea477e0", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -75,15 +75,14 @@ use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n use core::intrinsics::{arith_offset, assume};\n-use core::iter::{FromIterator, FusedIterator};\n+use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::mem;\n use core::ops::{Index, IndexMut};\n use core::ops;\n use core::ptr;\n use core::ptr::Shared;\n use core::slice;\n \n-use super::SpecExtend;\n use super::range::RangeArgument;\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n@@ -1245,26 +1244,7 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     #[stable(feature = \"vec_extend_from_slice\", since = \"1.6.0\")]\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n-        self.reserve(other.len());\n-\n-        // Unsafe code so this can be optimised to a memcpy (or something\n-        // similarly fast) when T is Copy. LLVM is easily confused, so any\n-        // extra operations during the loop can prevent this optimisation.\n-        unsafe {\n-            let len = self.len();\n-            let ptr = self.get_unchecked_mut(len) as *mut T;\n-            // Use SetLenOnDrop to work around bug where compiler\n-            // may not realize the store through `ptr` trough self.set_len()\n-            // don't alias.\n-            let mut local_len = SetLenOnDrop::new(&mut self.len);\n-\n-            for i in 0..other.len() {\n-                ptr::write(ptr.offset(i as isize), other.get_unchecked(i).clone());\n-                local_len.increment_len(1);\n-            }\n-\n-            // len set by scope guard\n-        }\n+        self.extend(other.iter().cloned())\n     }\n }\n \n@@ -1606,19 +1586,25 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n-        <Self as SpecExtend<I>>::spec_extend(self, iter);\n+        self.extend_desugared(iter.into_iter())\n     }\n }\n \n-impl<I: IntoIterator> SpecExtend<I> for Vec<I::Item> {\n-    default fn spec_extend(&mut self, iter: I) {\n-        self.extend_desugared(iter.into_iter())\n-    }\n+trait IsTrustedLen : Iterator {\n+    fn trusted_len(&self) -> Option<usize> { None }\n }\n+impl<I> IsTrustedLen for I where I: Iterator { }\n \n-impl<T> SpecExtend<Vec<T>> for Vec<T> {\n-    fn spec_extend(&mut self, ref mut other: Vec<T>) {\n-        self.append(other);\n+impl<I> IsTrustedLen for I where I: TrustedLen\n+{\n+    fn trusted_len(&self) -> Option<usize> {\n+        let (low, high) = self.size_hint();\n+        if let Some(high_value) = high {\n+            debug_assert_eq!(low, high_value,\n+                             \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                             (low, high));\n+        }\n+        high\n     }\n }\n \n@@ -1629,16 +1615,30 @@ impl<T> Vec<T> {\n         //      for item in iterator {\n         //          self.push(item);\n         //      }\n-        while let Some(element) = iterator.next() {\n-            let len = self.len();\n-            if len == self.capacity() {\n-                let (lower, _) = iterator.size_hint();\n-                self.reserve(lower.saturating_add(1));\n-            }\n+        if let Some(additional) = iterator.trusted_len() {\n+            self.reserve(additional);\n             unsafe {\n-                ptr::write(self.get_unchecked_mut(len), element);\n-                // NB can't overflow since we would have had to alloc the address space\n-                self.set_len(len + 1);\n+                let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n+                let mut local_len = SetLenOnDrop::new(&mut self.len);\n+                for element in iterator {\n+                    ptr::write(ptr, element);\n+                    ptr = ptr.offset(1);\n+                    // NB can't overflow since we would have had to alloc the address space\n+                    local_len.increment_len(1);\n+                }\n+            }\n+        } else {\n+            while let Some(element) = iterator.next() {\n+                let len = self.len();\n+                if len == self.capacity() {\n+                    let (lower, _) = iterator.size_hint();\n+                    self.reserve(lower.saturating_add(1));\n+                }\n+                unsafe {\n+                    ptr::write(self.get_unchecked_mut(len), element);\n+                    // NB can't overflow since we would have had to alloc the address space\n+                    self.set_len(len + 1);\n+                }\n             }\n         }\n     }\n@@ -1647,24 +1647,7 @@ impl<T> Vec<T> {\n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n-        <I as SpecExtendVec<T>>::extend_vec(iter, self);\n-    }\n-}\n-\n-// helper trait for specialization of Vec's Extend impl\n-trait SpecExtendVec<T> {\n-    fn extend_vec(self, vec: &mut Vec<T>);\n-}\n-\n-impl <'a, T: 'a + Copy, I: IntoIterator<Item=&'a T>> SpecExtendVec<T> for I {\n-    default fn extend_vec(self, vec: &mut Vec<T>) {\n-        vec.extend(self.into_iter().cloned());\n-    }\n-}\n-\n-impl<'a, T: Copy> SpecExtendVec<T> for &'a [T] {\n-    fn extend_vec(self, vec: &mut Vec<T>) {\n-        vec.extend_from_slice(self);\n+        self.extend(iter.into_iter().map(|&x| x))\n     }\n }\n \n@@ -1988,6 +1971,9 @@ impl<T> ExactSizeIterator for IntoIter<T> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for IntoIter<T> {}\n+\n #[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\n impl<T: Clone> Clone for IntoIter<T> {\n     fn clone(&self) -> IntoIter<T> {"}, {"sha": "b29245121daadeb52d6c206130090d43e9406008", "filename": "src/libcollectionstest/cow_str.rs", "status": "modified", "additions": 105, "deletions": 29, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollectionstest%2Fcow_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollectionstest%2Fcow_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fcow_str.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,54 +12,130 @@ use std::borrow::Cow;\n \n // check that Cow<'a, str> implements addition\n #[test]\n-fn check_cow_add() {\n-    borrowed1 = Cow::Borrowed(\"Hello, \");\n-    borrowed2 = Cow::Borrowed(\"World!\");\n-    borrow_empty = Cow::Borrowed(\"\");\n+fn check_cow_add_cow() {\n+    let borrowed1 = Cow::Borrowed(\"Hello, \");\n+    let borrowed2 = Cow::Borrowed(\"World!\");\n+    let borrow_empty = Cow::Borrowed(\"\");\n \n-    owned1 = Cow::Owned(\"Hi, \".into());\n-    owned2 = Cow::Owned(\"Rustaceans!\".into());\n-    owned_empty = Cow::Owned(\"\".into());\n+    let owned1: Cow<str> = Cow::Owned(String::from(\"Hi, \"));\n+    let owned2: Cow<str> = Cow::Owned(String::from(\"Rustaceans!\"));\n+    let owned_empty: Cow<str> = Cow::Owned(String::new());\n \n-    assert_eq!(\"Hello, World!\", borrowed1 + borrowed2);\n-    assert_eq!(\"Hello, Rustaceans!\", borrowed1 + owned2);\n+    assert_eq!(\"Hello, World!\", borrowed1.clone() + borrowed2.clone());\n+    assert_eq!(\"Hello, Rustaceans!\", borrowed1.clone() + owned2.clone());\n \n-    assert_eq!(\"Hello, World!\", owned1 + borrowed2);\n-    assert_eq!(\"Hello, Rustaceans!\", owned1 + owned2);\n+    assert_eq!(\"Hi, World!\", owned1.clone() + borrowed2.clone());\n+    assert_eq!(\"Hi, Rustaceans!\", owned1.clone() + owned2.clone());\n \n-    if let Cow::Owned(_) = borrowed1 + borrow_empty {\n+    if let Cow::Owned(_) = borrowed1.clone() + borrow_empty.clone() {\n         panic!(\"Adding empty strings to a borrow should note allocate\");\n     }\n-    if let Cow::Owned(_) = borrow_empty + borrowed1 {\n+    if let Cow::Owned(_) = borrow_empty.clone() + borrowed1.clone() {\n         panic!(\"Adding empty strings to a borrow should note allocate\");\n     }\n-    if let Cow::Owned(_) = borrowed1 + owned_empty {\n+    if let Cow::Owned(_) = borrowed1.clone() + owned_empty.clone() {\n         panic!(\"Adding empty strings to a borrow should note allocate\");\n     }\n-    if let Cow::Owned(_) = owned_empty + borrowed1 {\n+    if let Cow::Owned(_) = owned_empty.clone() + borrowed1.clone() {\n         panic!(\"Adding empty strings to a borrow should note allocate\");\n     }\n }\n \n-fn check_cow_add_assign() {\n-    borrowed1 = Cow::Borrowed(\"Hello, \");\n-    borrowed2 = Cow::Borrowed(\"World!\");\n-    borrow_empty = Cow::Borrowed(\"\");\n+#[test]\n+fn check_cow_add_str() {\n+    let borrowed = Cow::Borrowed(\"Hello, \");\n+    let borrow_empty = Cow::Borrowed(\"\");\n+\n+    let owned: Cow<str> = Cow::Owned(String::from(\"Hi, \"));\n+    let owned_empty: Cow<str> = Cow::Owned(String::new());\n \n-    owned1 = Cow::Owned(\"Hi, \".into());\n-    owned2 = Cow::Owned(\"Rustaceans!\".into());\n-    owned_empty = Cow::Owned(\"\".into());\n+    assert_eq!(\"Hello, World!\", borrowed.clone() + \"World!\");\n \n-    let borrowed1clone = borrowed1.clone();\n-    borrowed1clone += borrow_empty;\n-    assert_eq!((&borrowed1clone).as_ptr(), (&borrowed1).as_ptr());\n+    assert_eq!(\"Hi, World!\", owned.clone() + \"World!\");\n \n-    borrowed1clone += owned_empty;\n-    assert_eq!((&borrowed1clone).as_ptr(), (&borrowed1).as_ptr());\n+    if let Cow::Owned(_) = borrowed.clone() + \"\" {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    if let Cow::Owned(_) = borrow_empty.clone() + \"Hello, \" {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    if let Cow::Owned(_) = owned_empty.clone() + \"Hello, \" {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+}\n+\n+#[test]\n+fn check_cow_add_assign_cow() {\n+    let mut borrowed1 = Cow::Borrowed(\"Hello, \");\n+    let borrowed2 = Cow::Borrowed(\"World!\");\n+    let borrow_empty = Cow::Borrowed(\"\");\n+\n+    let mut owned1: Cow<str> = Cow::Owned(String::from(\"Hi, \"));\n+    let owned2: Cow<str> = Cow::Owned(String::from(\"Rustaceans!\"));\n+    let owned_empty: Cow<str> = Cow::Owned(String::new());\n+\n+    let mut s = borrowed1.clone();\n+    s += borrow_empty.clone();\n+    assert_eq!(\"Hello, \", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    let mut s = borrow_empty.clone();\n+    s += borrowed1.clone();\n+    assert_eq!(\"Hello, \", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    let mut s = borrowed1.clone();\n+    s += owned_empty.clone();\n+    assert_eq!(\"Hello, \", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    let mut s = owned_empty.clone();\n+    s += borrowed1.clone();\n+    assert_eq!(\"Hello, \", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n \n     owned1 += borrowed2;\n     borrowed1 += owned2;\n \n-    assert_eq!(\"Hello, World!\", owned1);\n+    assert_eq!(\"Hi, World!\", owned1);\n     assert_eq!(\"Hello, Rustaceans!\", borrowed1);\n }\n+\n+#[test]\n+fn check_cow_add_assign_str() {\n+    let mut borrowed = Cow::Borrowed(\"Hello, \");\n+    let borrow_empty = Cow::Borrowed(\"\");\n+\n+    let mut owned: Cow<str> = Cow::Owned(String::from(\"Hi, \"));\n+    let owned_empty: Cow<str> = Cow::Owned(String::new());\n+\n+    let mut s = borrowed.clone();\n+    s += \"\";\n+    assert_eq!(\"Hello, \", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    let mut s = borrow_empty.clone();\n+    s += \"World!\";\n+    assert_eq!(\"World!\", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    let mut s = owned_empty.clone();\n+    s += \"World!\";\n+    assert_eq!(\"World!\", s);\n+    if let Cow::Owned(_) = s {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+\n+    owned += \"World!\";\n+    borrowed += \"World!\";\n+\n+    assert_eq!(\"Hi, World!\", owned);\n+    assert_eq!(\"Hello, World!\", borrowed);\n+}"}, {"sha": "14ec8d58bef61065ad669414be9eb19850670a8d", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -42,6 +42,7 @@ mod bench;\n \n mod binary_heap;\n mod btree;\n+mod cow_str;\n mod enum_set;\n mod fmt;\n mod linked_list;"}, {"sha": "5f5d07b6682372a3dd04ec92c552283ae1f27e76", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -24,7 +24,8 @@ use mem;\n ///\n /// See: https://131002.net/siphash/\n #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-#[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+#[rustc_deprecated(since = \"1.13.0\",\n+                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher13 {\n     hasher: Hasher<Sip13Rounds>,\n@@ -34,7 +35,8 @@ pub struct SipHasher13 {\n ///\n /// See: https://131002.net/siphash/\n #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-#[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+#[rustc_deprecated(since = \"1.13.0\",\n+                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher24 {\n     hasher: Hasher<Sip24Rounds>,\n@@ -53,7 +55,8 @@ pub struct SipHasher24 {\n /// it is not intended for cryptographic purposes. As such, all\n /// cryptographic uses of this implementation are _strongly discouraged_.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+#[rustc_deprecated(since = \"1.13.0\",\n+                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher(SipHasher24);\n \n@@ -140,15 +143,17 @@ impl SipHasher {\n     /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher` that is keyed off the provided keys.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n         SipHasher(SipHasher24::new_with_keys(key0, key1))\n     }\n@@ -158,15 +163,17 @@ impl SipHasher13 {\n     /// Creates a new `SipHasher13` with the two initial keys set to 0.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new() -> SipHasher13 {\n         SipHasher13::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher13` that is keyed off the provided keys.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n         SipHasher13 {\n             hasher: Hasher::new_with_keys(key0, key1)\n@@ -178,15 +185,17 @@ impl SipHasher24 {\n     /// Creates a new `SipHasher24` with the two initial keys set to 0.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new() -> SipHasher24 {\n         SipHasher24::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher24` that is keyed off the provided keys.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n+    #[rustc_deprecated(since = \"1.13.0\",\n+                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher24 {\n         SipHasher24 {\n             hasher: Hasher::new_with_keys(key0, key1)"}, {"sha": "f2cdc9d6a98c540de1c55271509687c2f0a89b71", "filename": "src/libcore/internal_macros.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// implements the unary operator \"op &T\"\n+// based on \"op T\" where T is expected to be `Copy`able\n+macro_rules! forward_ref_unop {\n+    (impl $imp:ident, $method:ident for $t:ty) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a> $imp for &'a $t {\n+            type Output = <$t as $imp>::Output;\n+\n+            #[inline]\n+            fn $method(self) -> <$t as $imp>::Output {\n+                $imp::$method(*self)\n+            }\n+        }\n+    }\n+}\n+\n+// implements binary operators \"&T op U\", \"T op &U\", \"&T op &U\"\n+// based on \"T op U\" where T and U are expected to be `Copy`able\n+macro_rules! forward_ref_binop {\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a> $imp<$u> for &'a $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(*self, other)\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a> $imp<&'a $u> for $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(self, *other)\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, 'b> $imp<&'a $u> for &'b $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(*self, *other)\n+            }\n+        }\n+    }\n+}"}, {"sha": "f6b74a91c193b7110fb8561ae626f327bd960de4", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 92, "deletions": 54, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -35,11 +35,14 @@ pub trait Iterator {\n \n     /// Advances the iterator and returns the next value.\n     ///\n-    /// Returns `None` when iteration is finished. Individual iterator\n+    /// Returns [`None`] when iteration is finished. Individual iterator\n     /// implementations may choose to resume iteration, and so calling `next()`\n-    /// again may or may not eventually start returning `Some(Item)` again at some\n+    /// again may or may not eventually start returning [`Some(Item)`] again at some\n     /// point.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Some(Item)`]: ../../std/option/enum.Option.html#variant.Some\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -69,9 +72,9 @@ pub trait Iterator {\n     /// Specifically, `size_hint()` returns a tuple where the first element\n     /// is the lower bound, and the second element is the upper bound.\n     ///\n-    /// The second half of the tuple that is returned is an `Option<usize>`. A\n-    /// `None` here means that either there is no known upper bound, or the\n-    /// upper bound is larger than `usize`.\n+    /// The second half of the tuple that is returned is an [`Option`]`<`[`usize`]`>`.\n+    /// A [`None`] here means that either there is no known upper bound, or the\n+    /// upper bound is larger than [`usize`].\n     ///\n     /// # Implementation notes\n     ///\n@@ -91,6 +94,10 @@ pub trait Iterator {\n     /// The default implementation returns `(0, None)` which is correct for any\n     /// iterator.\n     ///\n+    /// [`usize`]: ../../std/primitive.usize.html\n+    /// [`Option`]: ../../std/option/enum.Option.html\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -134,23 +141,26 @@ pub trait Iterator {\n     /// Consumes the iterator, counting the number of iterations and returning it.\n     ///\n     /// This method will evaluate the iterator until its [`next()`] returns\n-    /// `None`. Once `None` is encountered, `count()` returns the number of\n+    /// [`None`]. Once [`None`] is encountered, `count()` returns the number of\n     /// times it called [`next()`].\n     ///\n     /// [`next()`]: #tymethod.next\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Overflow Behavior\n     ///\n     /// The method does no guarding against overflows, so counting elements of\n-    /// an iterator with more than `usize::MAX` elements either produces the\n+    /// an iterator with more than [`usize::MAX`] elements either produces the\n     /// wrong result or panics. If debug assertions are enabled, a panic is\n     /// guaranteed.\n     ///\n     /// # Panics\n     ///\n-    /// This function might panic if the iterator has more than `usize::MAX`\n+    /// This function might panic if the iterator has more than [`usize::MAX`]\n     /// elements.\n     ///\n+    /// [`usize::MAX`]: ../../std/isize/constant.MAX.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -172,10 +182,12 @@ pub trait Iterator {\n \n     /// Consumes the iterator, returning the last element.\n     ///\n-    /// This method will evaluate the iterator until it returns `None`. While\n-    /// doing so, it keeps track of the current element. After `None` is\n+    /// This method will evaluate the iterator until it returns [`None`]. While\n+    /// doing so, it keeps track of the current element. After [`None`] is\n     /// returned, `last()` will then return the last element it saw.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -202,9 +214,11 @@ pub trait Iterator {\n     /// Like most indexing operations, the count starts from zero, so `nth(0)`\n     /// returns the first value, `nth(1)` the second, and so on.\n     ///\n-    /// `nth()` will return `None` if `n` is greater than or equal to the length of the\n+    /// `nth()` will return [`None`] if `n` is greater than or equal to the length of the\n     /// iterator.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -306,8 +320,8 @@ pub trait Iterator {\n     ///\n     /// In other words, it zips two iterators together, into a single one.\n     ///\n-    /// When either iterator returns `None`, all further calls to `next()`\n-    /// will return `None`.\n+    /// When either iterator returns [`None`], all further calls to [`next()`]\n+    /// will return [`None`].\n     ///\n     /// # Examples\n     ///\n@@ -346,7 +360,7 @@ pub trait Iterator {\n     /// ```\n     ///\n     /// `zip()` is often used to zip an infinite iterator to a finite one.\n-    /// This works because the finite iterator will eventually return `None`,\n+    /// This works because the finite iterator will eventually return [`None`],\n     /// ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate()`]:\n     ///\n     /// ```\n@@ -365,6 +379,8 @@ pub trait Iterator {\n     /// ```\n     ///\n     /// [`enumerate()`]: trait.Iterator.html#method.enumerate\n+    /// [`next()`]: ../../std/iter/trait.Iterator.html#tymethod.next\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter> where\n@@ -501,23 +517,21 @@ pub trait Iterator {\n     ///\n     /// The closure must return an [`Option<T>`]. `filter_map()` creates an\n     /// iterator which calls this closure on each element. If the closure\n-    /// returns `Some(element)`, then that element is returned. If the\n-    /// closure returns `None`, it will try again, and call the closure on the\n-    /// next element, seeing if it will return `Some`.\n-    ///\n-    /// [`Option<T>`]: ../../std/option/enum.Option.html\n+    /// returns [`Some(element)`][`Some`], then that element is returned. If the\n+    /// closure returns [`None`], it will try again, and call the closure on the\n+    /// next element, seeing if it will return [`Some`].\n     ///\n     /// Why `filter_map()` and not just [`filter()`].[`map()`]? The key is in this\n     /// part:\n     ///\n     /// [`filter()`]: #method.filter\n     /// [`map()`]: #method.map\n     ///\n-    /// > If the closure returns `Some(element)`, then that element is returned.\n+    /// > If the closure returns [`Some(element)`][`Some`], then that element is returned.\n     ///\n     /// In other words, it removes the [`Option<T>`] layer automatically. If your\n     /// mapping is already returning an [`Option<T>`] and you want to skip over\n-    /// `None`s, then `filter_map()` is much, much nicer to use.\n+    /// [`None`]s, then `filter_map()` is much, much nicer to use.\n     ///\n     /// # Examples\n     ///\n@@ -547,7 +561,11 @@ pub trait Iterator {\n     /// assert_eq!(iter.next(), None);\n     /// ```\n     ///\n-    /// There's an extra layer of `Some` in there.\n+    /// There's an extra layer of [`Some`] in there.\n+    ///\n+    /// [`Option<T>`]: ../../std/option/enum.Option.html\n+    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n@@ -567,21 +585,20 @@ pub trait Iterator {\n     /// different sized integer, the [`zip()`] function provides similar\n     /// functionality.\n     ///\n-    /// [`usize`]: ../../std/primitive.usize.html\n-    /// [`zip()`]: #method.zip\n-    ///\n     /// # Overflow Behavior\n     ///\n     /// The method does no guarding against overflows, so enumerating more than\n     /// [`usize::MAX`] elements either produces the wrong result or panics. If\n     /// debug assertions are enabled, a panic is guaranteed.\n     ///\n-    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n-    ///\n     /// # Panics\n     ///\n     /// The returned iterator might panic if the to-be-returned index would\n-    /// overflow a `usize`.\n+    /// overflow a [`usize`].\n+    ///\n+    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+    /// [`usize`]: ../../std/primitive.usize.html\n+    /// [`zip()`]: #method.zip\n     ///\n     /// # Examples\n     ///\n@@ -607,12 +624,13 @@ pub trait Iterator {\n     /// Adds a [`peek()`] method to an iterator. See its documentation for\n     /// more information.\n     ///\n-    /// Note that the underlying iterator is still advanced when `peek` is\n+    /// Note that the underlying iterator is still advanced when [`peek()`] is\n     /// called for the first time: In order to retrieve the next element,\n-    /// `next` is called on the underlying iterator, hence any side effects of\n-    /// the `next` method will occur.\n+    /// [`next()`] is called on the underlying iterator, hence any side effects of\n+    /// the [`next()`] method will occur.\n     ///\n     /// [`peek()`]: struct.Peekable.html#method.peek\n+    /// [`next()`]: ../../std/iter/trait.Iterator.html#tymethod.next\n     ///\n     /// # Examples\n     ///\n@@ -894,12 +912,12 @@ pub trait Iterator {\n     /// an extra layer of indirection. `flat_map()` will remove this extra layer\n     /// on its own.\n     ///\n-    /// [`map()`]: #method.map\n-    ///\n     /// Another way of thinking about `flat_map()`: [`map()`]'s closure returns\n     /// one item for each element, and `flat_map()`'s closure returns an\n     /// iterator for each element.\n     ///\n+    /// [`map()`]: #method.map\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -921,11 +939,14 @@ pub trait Iterator {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n \n-    /// Creates an iterator which ends after the first `None`.\n+    /// Creates an iterator which ends after the first [`None`].\n     ///\n-    /// After an iterator returns `None`, future calls may or may not yield\n-    /// `Some(T)` again. `fuse()` adapts an iterator, ensuring that after a\n-    /// `None` is given, it will always return `None` forever.\n+    /// After an iterator returns [`None`], future calls may or may not yield\n+    /// [`Some(T)`] again. `fuse()` adapts an iterator, ensuring that after a\n+    /// [`None`] is given, it will always return [`None`] forever.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Some(T)`]: ../../std/option/enum.Option.html#variant.Some\n     ///\n     /// # Examples\n     ///\n@@ -1082,19 +1103,15 @@ pub trait Iterator {\n     /// library, used in a variety of contexts.\n     ///\n     /// The most basic pattern in which `collect()` is used is to turn one\n-    /// collection into another. You take a collection, call `iter()` on it,\n+    /// collection into another. You take a collection, call [`iter()`] on it,\n     /// do a bunch of transformations, and then `collect()` at the end.\n     ///\n     /// One of the keys to `collect()`'s power is that many things you might\n     /// not think of as 'collections' actually are. For example, a [`String`]\n     /// is a collection of [`char`]s. And a collection of [`Result<T, E>`] can\n-    /// be thought of as single `Result<Collection<T>, E>`. See the examples\n+    /// be thought of as single [`Result`]`<Collection<T>, E>`. See the examples\n     /// below for more.\n     ///\n-    /// [`String`]: ../../std/string/struct.String.html\n-    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// Because `collect()` is so general, it can cause problems with type\n     /// inference. As such, `collect()` is one of the few times you'll see\n     /// the syntax affectionately known as the 'turbofish': `::<>`. This\n@@ -1172,7 +1189,7 @@ pub trait Iterator {\n     /// assert_eq!(\"hello\", hello);\n     /// ```\n     ///\n-    /// If you have a list of [`Result<T, E>`]s, you can use `collect()` to\n+    /// If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n     /// see if any of them failed:\n     ///\n     /// ```\n@@ -1190,6 +1207,11 @@ pub trait Iterator {\n     /// // gives us the list of answers\n     /// assert_eq!(Ok(vec![1, 3]), result);\n     /// ```\n+    ///\n+    /// [`iter()`]: ../../std/iter/trait.Iterator.html#tymethod.next\n+    /// [`String`]: ../../std/string/struct.String.html\n+    /// [`char`]: ../../std/primitive.char.html\n+    /// [`Result`]: ../../std/result/enum.Result.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized {\n@@ -1281,6 +1303,8 @@ pub trait Iterator {\n     /// use a `for` loop with a list of things to build up a result. Those\n     /// can be turned into `fold()`s:\n     ///\n+    /// [`for`]: ../../book/loops.html#for\n+    ///\n     /// ```\n     /// let numbers = [1, 2, 3, 4, 5];\n     ///\n@@ -1414,8 +1438,8 @@ pub trait Iterator {\n     ///\n     /// `find()` takes a closure that returns `true` or `false`. It applies\n     /// this closure to each element of the iterator, and if any of them return\n-    /// `true`, then `find()` returns `Some(element)`. If they all return\n-    /// `false`, it returns `None`.\n+    /// `true`, then `find()` returns [`Some(element)`]. If they all return\n+    /// `false`, it returns [`None`].\n     ///\n     /// `find()` is short-circuiting; in other words, it will stop processing\n     /// as soon as the closure returns `true`.\n@@ -1425,6 +1449,9 @@ pub trait Iterator {\n     /// argument is a double reference. You can see this effect in the\n     /// examples below, with `&&x`.\n     ///\n+    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1465,16 +1492,16 @@ pub trait Iterator {\n     ///\n     /// `position()` takes a closure that returns `true` or `false`. It applies\n     /// this closure to each element of the iterator, and if one of them\n-    /// returns `true`, then `position()` returns `Some(index)`. If all of\n-    /// them return `false`, it returns `None`.\n+    /// returns `true`, then `position()` returns [`Some(index)`]. If all of\n+    /// them return `false`, it returns [`None`].\n     ///\n     /// `position()` is short-circuiting; in other words, it will stop\n     /// processing as soon as it finds a `true`.\n     ///\n     /// # Overflow Behavior\n     ///\n     /// The method does no guarding against overflows, so if there are more\n-    /// than `usize::MAX` non-matching elements, it either produces the wrong\n+    /// than [`usize::MAX`] non-matching elements, it either produces the wrong\n     /// result or panics. If debug assertions are enabled, a panic is\n     /// guaranteed.\n     ///\n@@ -1483,6 +1510,10 @@ pub trait Iterator {\n     /// This function might panic if the iterator has more than `usize::MAX`\n     /// non-matching elements.\n     ///\n+    /// [`Some(index)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1528,11 +1559,14 @@ pub trait Iterator {\n     /// `rposition()` takes a closure that returns `true` or `false`. It applies\n     /// this closure to each element of the iterator, starting from the end,\n     /// and if one of them returns `true`, then `rposition()` returns\n-    /// `Some(index)`. If all of them return `false`, it returns `None`.\n+    /// [`Some(index)`]. If all of them return `false`, it returns [`None`].\n     ///\n     /// `rposition()` is short-circuiting; in other words, it will stop\n     /// processing as soon as it finds a `true`.\n     ///\n+    /// [`Some(index)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1798,11 +1832,13 @@ pub trait Iterator {\n         (ts, us)\n     }\n \n-    /// Creates an iterator which `clone()`s all of its elements.\n+    /// Creates an iterator which [`clone()`]s all of its elements.\n     ///\n     /// This is useful when you have an iterator over `&T`, but you need an\n     /// iterator over `T`.\n     ///\n+    /// [`clone()`]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1827,10 +1863,12 @@ pub trait Iterator {\n \n     /// Repeats an iterator endlessly.\n     ///\n-    /// Instead of stopping at `None`, the iterator will instead start again,\n+    /// Instead of stopping at [`None`], the iterator will instead start again,\n     /// from the beginning. After iterating again, it will start at the\n     /// beginning again. And again. And again. Forever.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1862,7 +1900,7 @@ pub trait Iterator {\n     ///\n     /// # Panics\n     ///\n-    /// When calling `sum` and a primitive integer type is being returned, this\n+    /// When calling `sum()` and a primitive integer type is being returned, this\n     /// method will panic if the computation overflows and debug assertions are\n     /// enabled.\n     ///\n@@ -1890,7 +1928,7 @@ pub trait Iterator {\n     ///\n     /// # Panics\n     ///\n-    /// When calling `product` and a primitive integer type is being returned,\n+    /// When calling `product()` and a primitive integer type is being returned,\n     /// method will panic if the computation overflows and debug assertions are\n     /// enabled.\n     ///"}, {"sha": "cd2e0cb11d35e0a2c3362cd217337648b94f6175", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -328,6 +328,8 @@ pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend};\n pub use self::traits::{ExactSizeIterator, Sum, Product};\n #[unstable(feature = \"fused\", issue = \"35602\")]\n pub use self::traits::FusedIterator;\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+pub use self::traits::TrustedLen;\n \n mod iterator;\n mod range;\n@@ -372,6 +374,10 @@ impl<I> ExactSizeIterator for Rev<I>\n impl<I> FusedIterator for Rev<I>\n     where I: FusedIterator + DoubleEndedIterator {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Rev<I>\n+    where I: TrustedLen + DoubleEndedIterator {}\n+\n /// An iterator that clones the elements of an underlying iterator.\n ///\n /// This `struct` is created by the [`cloned()`] method on [`Iterator`]. See its\n@@ -438,6 +444,12 @@ unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n     fn may_have_side_effect() -> bool { true }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n+    where I: TrustedLen<Item=&'a T>,\n+          T: Clone\n+{}\n+\n /// An iterator that repeats endlessly.\n ///\n /// This `struct` is created by the [`cycle()`] method on [`Iterator`]. See its\n@@ -667,6 +679,11 @@ impl<A, B> FusedIterator for Chain<A, B>\n           B: FusedIterator<Item=A::Item>,\n {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, B> TrustedLen for Chain<A, B>\n+    where A: TrustedLen, B: TrustedLen<Item=A::Item>,\n+{}\n+\n /// An iterator that iterates two other iterators simultaneously.\n ///\n /// This `struct` is created by the [`zip()`] method on [`Iterator`]. See its\n@@ -884,6 +901,11 @@ unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n impl<A, B> FusedIterator for Zip<A, B>\n     where A: FusedIterator, B: FusedIterator, {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, B> TrustedLen for Zip<A, B>\n+    where A: TrustedLen, B: TrustedLen,\n+{}\n+\n /// An iterator that maps the values of `iter` with `f`.\n ///\n /// This `struct` is created by the [`map()`] method on [`Iterator`]. See its\n@@ -991,6 +1013,11 @@ impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n     where F: FnMut(I::Item) -> B {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<B, I, F> TrustedLen for Map<I, F>\n+    where I: TrustedLen,\n+          F: FnMut(I::Item) -> B {}\n+\n #[doc(hidden)]\n unsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n     where I: TrustedRandomAccess,\n@@ -1227,6 +1254,12 @@ unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Enumerate<I>\n+    where I: TrustedLen,\n+{}\n+\n+\n /// An iterator with a `peek()` that returns an optional reference to the next\n /// element.\n ///\n@@ -1341,10 +1374,7 @@ impl<I: Iterator> Peekable<I> {\n         if self.peeked.is_none() {\n             self.peeked = self.iter.next();\n         }\n-        match self.peeked {\n-            Some(ref value) => Some(value),\n-            None => None,\n-        }\n+        self.peeked.as_ref()\n     }\n }\n "}, {"sha": "e6f21d6c17ae0ffb8aca334df72b7878d2c0172a", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -12,7 +12,7 @@ use mem;\n use ops::{self, Add, Sub};\n use usize;\n \n-use super::FusedIterator;\n+use super::{FusedIterator, TrustedLen};\n \n /// Objects that can be stepped over in both directions.\n ///\n@@ -96,12 +96,12 @@ macro_rules! step_impl_unsigned {\n \n             #[inline]\n             fn add_one(&self) -> Self {\n-                *self + 1\n+                Add::add(*self, 1)\n             }\n \n             #[inline]\n             fn sub_one(&self) -> Self {\n-                *self - 1\n+                Sub::sub(*self, 1)\n             }\n \n             #[inline]\n@@ -167,12 +167,12 @@ macro_rules! step_impl_signed {\n \n             #[inline]\n             fn add_one(&self) -> Self {\n-                *self + 1\n+                Add::add(*self, 1)\n             }\n \n             #[inline]\n             fn sub_one(&self) -> Self {\n-                *self - 1\n+                Sub::sub(*self, 1)\n             }\n \n             #[inline]\n@@ -216,12 +216,12 @@ macro_rules! step_impl_no_between {\n \n             #[inline]\n             fn add_one(&self) -> Self {\n-                *self + 1\n+                Add::add(*self, 1)\n             }\n \n             #[inline]\n             fn sub_one(&self) -> Self {\n-                *self - 1\n+                Sub::sub(*self, 1)\n             }\n \n             #[inline]\n@@ -480,6 +480,22 @@ macro_rules! range_incl_exact_iter_impl {\n     )*)\n }\n \n+macro_rules! range_trusted_len_impl {\n+    ($($t:ty)*) => ($(\n+        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+        unsafe impl TrustedLen for ops::Range<$t> { }\n+    )*)\n+}\n+\n+macro_rules! range_incl_trusted_len_impl {\n+    ($($t:ty)*) => ($(\n+        #[unstable(feature = \"inclusive_range\",\n+                   reason = \"recently added, follows RFC\",\n+                   issue = \"28237\")]\n+        unsafe impl TrustedLen for ops::RangeInclusive<$t> { }\n+    )*)\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step> Iterator for ops::Range<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>\n@@ -513,6 +529,13 @@ impl<A: Step> Iterator for ops::Range<A> where\n range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n range_incl_exact_iter_impl!(u8 u16 i8 i16);\n \n+// These macros generate `TrustedLen` impls.\n+//\n+// They need to guarantee that .size_hint() is either exact, or that\n+// the upper bound is None when it does not fit the type limits.\n+range_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\n+range_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step + Clone> DoubleEndedIterator for ops::Range<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>,"}, {"sha": "9d402971d18d0085fcd10ee286b4ed53617ffd74", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n use ops::{Mul, Add};\n+use num::Wrapping;\n \n /// Conversion from an `Iterator`.\n ///\n@@ -555,10 +556,14 @@ impl<'a, I: ExactSizeIterator + ?Sized> ExactSizeIterator for &'a mut I {}\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///\n-/// This trait is used to implement the `sum` method on iterators. Types which\n-/// implement the trait can be generated by the `sum` method. Like\n-/// `FromIterator` this trait should rarely be called directly and instead\n-/// interacted with through `Iterator::sum`.\n+/// This trait is used to implement the [`sum()`] method on iterators. Types which\n+/// implement the trait can be generated by the [`sum()`] method. Like\n+/// [`FromIterator`] this trait should rarely be called directly and instead\n+/// interacted with through [`Iterator::sum()`].\n+///\n+/// [`sum()`]: ../../std/iter/trait.Sum.html#tymethod.sum\n+/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n+/// [`Iterator::sum()`]: ../../std/iter/trait.Iterator.html#method.sum\n #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n pub trait Sum<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n@@ -570,10 +575,14 @@ pub trait Sum<A = Self>: Sized {\n /// Trait to represent types that can be created by multiplying elements of an\n /// iterator.\n ///\n-/// This trait is used to implement the `product` method on iterators. Types\n-/// which implement the trait can be generated by the `product` method. Like\n-/// `FromIterator` this trait should rarely be called directly and instead\n-/// interacted with through `Iterator::product`.\n+/// This trait is used to implement the [`product()`] method on iterators. Types\n+/// which implement the trait can be generated by the [`product()`] method. Like\n+/// [`FromIterator`] this trait should rarely be called directly and instead\n+/// interacted with through [`Iterator::product()`].\n+///\n+/// [`product()`]: ../../std/iter/trait.Product.html#tymethod.product\n+/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n+/// [`Iterator::product()`]: ../../std/iter/trait.Iterator.html#method.product\n #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n pub trait Product<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n@@ -584,35 +593,39 @@ pub trait Product<A = Self>: Sized {\n \n // NB: explicitly use Add and Mul here to inherit overflow checks\n macro_rules! integer_sum_product {\n-    ($($a:ident)*) => ($(\n+    (@impls $zero:expr, $one:expr, $($a:ty)*) => ($(\n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Sum for $a {\n             fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(0, Add::add)\n+                iter.fold($zero, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Product for $a {\n             fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(1, Mul::mul)\n+                iter.fold($one, Mul::mul)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Sum<&'a $a> for $a {\n             fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.cloned().fold(0, Add::add)\n+                iter.fold($zero, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Product<&'a $a> for $a {\n             fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.cloned().fold(1, Mul::mul)\n+                iter.fold($one, Mul::mul)\n             }\n         }\n-    )*)\n+    )*);\n+    ($($a:ty)*) => (\n+        integer_sum_product!(@impls 0, 1, $($a)+);\n+        integer_sum_product!(@impls Wrapping(0), Wrapping(1), $(Wrapping<$a>)+);\n+    );\n }\n \n macro_rules! float_sum_product {\n@@ -665,3 +678,22 @@ pub trait FusedIterator: Iterator {}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, I: FusedIterator + ?Sized> FusedIterator for &'a mut I {}\n+\n+/// An iterator that reports an accurate length using size_hint.\n+///\n+/// The iterator reports a size hint where it is either exact\n+/// (lower bound is equal to upper bound), or the upper bound is `None`.\n+/// The upper bound must only be `None` if the actual iterator length is\n+/// larger than `usize::MAX`.\n+///\n+/// The iterator must produce exactly the number of elements it reported.\n+///\n+/// # Safety\n+///\n+/// This trait must only be implemented when the contract is upheld.\n+/// Consumers of this trait must inspect `.size_hint()`\u2019s upper bound.\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+pub unsafe trait TrustedLen : Iterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, I: TrustedLen + ?Sized> TrustedLen for &'a mut I {}"}, {"sha": "07f5e725e2003bbcb7001b448a1072972e33e83d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -100,6 +100,9 @@ use prelude::v1::*;\n #[macro_use]\n mod macros;\n \n+#[macro_use]\n+mod internal_macros;\n+\n #[path = \"num/float_macros.rs\"]\n #[macro_use]\n mod float_macros;"}, {"sha": "3cf32d1a559196d02c8048147beb1b8509528584", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -350,6 +350,21 @@ macro_rules! try {\n ///\n /// assert_eq!(w, b\"testformatted arguments\");\n /// ```\n+///\n+/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n+/// implementing either, as objects do not typically implement both. However, the module must\n+/// import the traits qualified so their names do not conflict:\n+///\n+/// ```\n+/// use std::fmt::Write as FmtWrite;\n+/// use std::io::Write as IoWrite;\n+///\n+/// let mut s = String::new();\n+/// let mut v = Vec::new();\n+/// write!(&mut s, \"{} {}\", \"abc\", 123).unwrap(); // uses fmt::Write::write_fmt\n+/// write!(&mut v, \"s = {:?}\", s).unwrap(); // uses io::Write::write_fmt\n+/// assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n+/// ```\n #[macro_export]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! write {\n@@ -394,6 +409,21 @@ macro_rules! write {\n ///\n /// assert_eq!(&w[..], \"test\\nformatted arguments\\n\".as_bytes());\n /// ```\n+///\n+/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n+/// implementing either, as objects do not typically implement both. However, the module must\n+/// import the traits qualified so their names do not conflict:\n+///\n+/// ```\n+/// use std::fmt::Write as FmtWrite;\n+/// use std::io::Write as IoWrite;\n+///\n+/// let mut s = String::new();\n+/// let mut v = Vec::new();\n+/// writeln!(&mut s, \"{} {}\", \"abc\", 123).unwrap(); // uses fmt::Write::write_fmt\n+/// writeln!(&mut v, \"s = {:?}\", s).unwrap(); // uses io::Write::write_fmt\n+/// assert_eq!(v, b\"s = \\\"abc 123\\\\n\\\"\\n\");\n+/// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! writeln {"}, {"sha": "50d64838a5c0b0507af36fc83ff86c716df3781d", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -131,6 +131,7 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0.wrapping_add(other.0))\n             }\n         }\n+        forward_ref_binop! { impl Add, add for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl AddAssign for Wrapping<$t> {\n@@ -149,6 +150,7 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0.wrapping_sub(other.0))\n             }\n         }\n+        forward_ref_binop! { impl Sub, sub for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl SubAssign for Wrapping<$t> {\n@@ -167,6 +169,7 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0.wrapping_mul(other.0))\n             }\n         }\n+        forward_ref_binop! { impl Mul, mul for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl MulAssign for Wrapping<$t> {\n@@ -185,6 +188,7 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0.wrapping_div(other.0))\n             }\n         }\n+        forward_ref_binop! { impl Div, div for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl DivAssign for Wrapping<$t> {\n@@ -203,6 +207,7 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0.wrapping_rem(other.0))\n             }\n         }\n+        forward_ref_binop! { impl Rem, rem for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl RemAssign for Wrapping<$t> {\n@@ -221,6 +226,7 @@ macro_rules! wrapping_impl {\n                 Wrapping(!self.0)\n             }\n         }\n+        forward_ref_unop! { impl Not, not for Wrapping<$t> }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitXor for Wrapping<$t> {\n@@ -231,6 +237,7 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0 ^ other.0)\n             }\n         }\n+        forward_ref_binop! { impl BitXor, bitxor for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl BitXorAssign for Wrapping<$t> {\n@@ -249,6 +256,7 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0 | other.0)\n             }\n         }\n+        forward_ref_binop! { impl BitOr, bitor for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl BitOrAssign for Wrapping<$t> {\n@@ -267,6 +275,7 @@ macro_rules! wrapping_impl {\n                 Wrapping(self.0 & other.0)\n             }\n         }\n+        forward_ref_binop! { impl BitAnd, bitand for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl BitAndAssign for Wrapping<$t> {\n@@ -284,6 +293,7 @@ macro_rules! wrapping_impl {\n                 Wrapping(0) - self\n             }\n         }\n+        forward_ref_unop! { impl Neg, neg for Wrapping<$t> }\n     )*)\n }\n "}, {"sha": "07ae5b920b27b1b61399823fb5d520e75ff86c56", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -196,58 +196,6 @@ pub trait Drop {\n     fn drop(&mut self);\n }\n \n-// implements the unary operator \"op &T\"\n-// based on \"op T\" where T is expected to be `Copy`able\n-macro_rules! forward_ref_unop {\n-    (impl $imp:ident, $method:ident for $t:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a> $imp for &'a $t {\n-            type Output = <$t as $imp>::Output;\n-\n-            #[inline]\n-            fn $method(self) -> <$t as $imp>::Output {\n-                $imp::$method(*self)\n-            }\n-        }\n-    }\n-}\n-\n-// implements binary operators \"&T op U\", \"T op &U\", \"&T op &U\"\n-// based on \"T op U\" where T and U are expected to be `Copy`able\n-macro_rules! forward_ref_binop {\n-    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a> $imp<$u> for &'a $t {\n-            type Output = <$t as $imp<$u>>::Output;\n-\n-            #[inline]\n-            fn $method(self, other: $u) -> <$t as $imp<$u>>::Output {\n-                $imp::$method(*self, other)\n-            }\n-        }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a> $imp<&'a $u> for $t {\n-            type Output = <$t as $imp<$u>>::Output;\n-\n-            #[inline]\n-            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n-                $imp::$method(self, *other)\n-            }\n-        }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b> $imp<&'a $u> for &'b $t {\n-            type Output = <$t as $imp<$u>>::Output;\n-\n-            #[inline]\n-            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n-                $imp::$method(*self, *other)\n-            }\n-        }\n-    }\n-}\n-\n /// The `Add` trait is used to specify the functionality of `+`.\n ///\n /// # Examples"}, {"sha": "607e16887a831b8faaa0fcb22a351ec481f5909d", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -145,7 +145,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use iter::{FromIterator, FusedIterator};\n+use iter::{FromIterator, FusedIterator, TrustedLen};\n use mem;\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n@@ -803,6 +803,7 @@ impl<A> DoubleEndedIterator for Item<A> {\n \n impl<A> ExactSizeIterator for Item<A> {}\n impl<A> FusedIterator for Item<A> {}\n+unsafe impl<A> TrustedLen for Item<A> {}\n \n /// An iterator over a reference of the contained item in an [`Option`].\n ///\n@@ -833,6 +834,9 @@ impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, A> FusedIterator for Iter<'a, A> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, A> TrustedLen for Iter<'a, A> {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Clone for Iter<'a, A> {\n     fn clone(&self) -> Iter<'a, A> {\n@@ -868,6 +872,8 @@ impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, A> FusedIterator for IterMut<'a, A> {}\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n \n /// An iterator over the item contained inside an [`Option`].\n ///\n@@ -898,6 +904,9 @@ impl<A> ExactSizeIterator for IntoIter<A> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<A> FusedIterator for IntoIter<A> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A> TrustedLen for IntoIter<A> {}\n+\n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "2ad38de72b1b95140ea35472449181e8e0c98670", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -344,6 +344,46 @@ impl<T: ?Sized> *const T {\n     pub unsafe fn offset(self, count: isize) -> *const T where T: Sized {\n         intrinsics::offset(self, count)\n     }\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// offset of `3 * sizeof::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resulting pointer does not need to be in bounds, but it is\n+    /// potentially hazardous to dereference (which requires `unsafe`).\n+    ///\n+    /// Always use `.offset(count)` instead when possible, because `offset`\n+    /// allows the compiler to optimize better.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset)]\n+    /// // Iterate using a raw pointer in increments of two elements\n+    /// let data = [1u8, 2, 3, 4, 5];\n+    /// let mut ptr: *const u8 = data.as_ptr();\n+    /// let step = 2;\n+    /// let end_rounded_up = ptr.wrapping_offset(6);\n+    ///\n+    /// // This loop prints \"1, 3, 5, \"\n+    /// while ptr != end_rounded_up {\n+    ///     unsafe {\n+    ///         print!(\"{}, \", *ptr);\n+    ///     }\n+    ///     ptr = ptr.wrapping_offset(step);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset\", issue = \"37570\")]\n+    #[inline]\n+    pub fn wrapping_offset(self, count: isize) -> *const T where T: Sized {\n+        unsafe {\n+            intrinsics::arith_offset(self, count)\n+        }\n+    }\n }\n \n #[lang = \"mut_ptr\"]\n@@ -429,6 +469,46 @@ impl<T: ?Sized> *mut T {\n         intrinsics::offset(self, count) as *mut T\n     }\n \n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// offset of `3 * sizeof::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resulting pointer does not need to be in bounds, but it is\n+    /// potentially hazardous to dereference (which requires `unsafe`).\n+    ///\n+    /// Always use `.offset(count)` instead when possible, because `offset`\n+    /// allows the compiler to optimize better.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset)]\n+    /// // Iterate using a raw pointer in increments of two elements\n+    /// let mut data = [1u8, 2, 3, 4, 5];\n+    /// let mut ptr: *mut u8 = data.as_mut_ptr();\n+    /// let step = 2;\n+    /// let end_rounded_up = ptr.wrapping_offset(6);\n+    ///\n+    /// while ptr != end_rounded_up {\n+    ///     unsafe {\n+    ///         *ptr = 0;\n+    ///     }\n+    ///     ptr = ptr.wrapping_offset(step);\n+    /// }\n+    /// assert_eq!(&data, &[0, 2, 0, 4, 0]);\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset\", issue = \"37570\")]\n+    #[inline]\n+    pub fn wrapping_offset(self, count: isize) -> *mut T where T: Sized {\n+        unsafe {\n+            intrinsics::arith_offset(self, count) as *mut T\n+        }\n+    }\n+\n     /// Returns `None` if the pointer is null, or else returns a mutable\n     /// reference to the value wrapped in `Some`.\n     ///"}, {"sha": "afed99d265f1921cebedd29697934b6a6a5bf8fe", "filename": "src/libcore/result.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -249,7 +249,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use fmt;\n-use iter::{FromIterator, FusedIterator};\n+use iter::{FromIterator, FusedIterator, TrustedLen};\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n@@ -924,6 +924,9 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, A> TrustedLen for Iter<'a, A> {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n@@ -962,6 +965,9 @@ impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n+\n /// An iterator over the value in a [`Ok`] variant of a [`Result`]. This struct is\n /// created by the [`into_iter`] method on [`Result`][`Result`] (provided by\n /// the [`IntoIterator`] trait).\n@@ -999,6 +1005,9 @@ impl<T> ExactSizeIterator for IntoIter<T> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A> TrustedLen for IntoIter<A> {}\n+\n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "871b63145ca6d24c8981bae053aadc54bfee7a6c", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -988,6 +988,9 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, T> TrustedLen for Iter<'a, T> {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }\n@@ -1109,6 +1112,9 @@ impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, T> TrustedLen for IterMut<'a, T> {}\n+\n /// An internal abstraction over the splitting iterators, so that\n /// splitn, splitn_mut etc can be implemented once.\n #[doc(hidden)]"}, {"sha": "8f85bfe2c638eafeb2de9e46f4583a6201ceabec", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -53,7 +53,7 @@ pub unsafe extern fn __rust_maybe_catch_panic(f: fn(*mut u8),\n // now hopefully.\n #[no_mangle]\n pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n-    return abort();\n+    abort();\n \n     #[cfg(unix)]\n     unsafe fn abort() -> ! {"}, {"sha": "73264fab69c266c4f88ff8b5b03182b12493664b", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -124,7 +124,7 @@ const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX\n #[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1 / X0, X1\n \n-#[cfg(any(target_arch = \"mips\", target_arch = \"mipsel\", target_arch = \"mips64\"))]\n+#[cfg(any(target_arch = \"mips\", target_arch = \"mips64\"))]\n const UNWIND_DATA_REG: (i32, i32) = (4, 5); // A0, A1\n \n #[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]"}, {"sha": "5ee9fecfb21b3ce0d9b70aead5a85a72da01c546", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -95,7 +95,8 @@ pub mod __internal {\n     pub trait Registry {\n         fn register_custom_derive(&mut self,\n                                   trait_name: &str,\n-                                  expand: fn(TokenStream) -> TokenStream);\n+                                  expand: fn(TokenStream) -> TokenStream,\n+                                  attributes: &[&'static str]);\n     }\n \n     // Emulate scoped_thread_local!() here essentially"}, {"sha": "5ab4fcd5dab29a74648bc3627f5a90f47717b978", "filename": "src/libproc_macro_tokens/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibproc_macro_tokens%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibproc_macro_tokens%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fparse.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -15,12 +15,12 @@ extern crate syntax;\n use syntax::parse::{ParseSess, filemap_to_tts};\n use syntax::tokenstream::TokenStream;\n \n-/// Map a string to tts, using a made-up filename. For example, `lex(15)` will return a\n+/// Map a string to tts, using a made-up filename. For example, `lex(\"15\")` will return a\n /// TokenStream containing the literal 15.\n pub fn lex(source_str: &str) -> TokenStream {\n     let ps = ParseSess::new();\n     TokenStream::from_tts(filemap_to_tts(&ps,\n-                                         ps.codemap().new_filemap(\"procmacro_lex\".to_string(),\n+                                         ps.codemap().new_filemap(\"<procmacro_lex>\".to_string(),\n                                                                   None,\n                                                                   source_str.to_owned())))\n }"}, {"sha": "22c7d14be29d205dbe172c7a96ca322605d7df6d", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -33,25 +33,25 @@ struct LoopScope {\n }\n \n pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           blk: &hir::Block) -> CFG {\n+                           body: &hir::Expr) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n \n     // `fn_exit` is target of return exprs, which lies somewhere\n-    // outside input `blk`. (Distinguishing `fn_exit` and `block_exit`\n+    // outside input `body`. (Distinguishing `fn_exit` and `body_exit`\n     // also resolves chicken-and-egg problem that arises if you try to\n-    // have return exprs jump to `block_exit` during construction.)\n+    // have return exprs jump to `body_exit` during construction.)\n     let fn_exit = graph.add_node(CFGNodeData::Exit);\n-    let block_exit;\n+    let body_exit;\n \n     let mut cfg_builder = CFGBuilder {\n         graph: graph,\n         fn_exit: fn_exit,\n         tcx: tcx,\n         loop_scopes: Vec::new()\n     };\n-    block_exit = cfg_builder.block(blk, entry);\n-    cfg_builder.add_contained_edge(block_exit, fn_exit);\n+    body_exit = cfg_builder.expr(body, entry);\n+    cfg_builder.add_contained_edge(body_exit, fn_exit);\n     let CFGBuilder {graph, ..} = cfg_builder;\n     CFG {graph: graph,\n          entry: entry,\n@@ -311,11 +311,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) if self.tcx.is_method_call(expr.id) => {\n+            hir::ExprBinary(_, ref l, ref r) if self.tcx.tables().is_method_call(expr.id) => {\n                 self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n-            hir::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n+            hir::ExprUnary(_, ref e) if self.tcx.tables().is_method_call(expr.id) => {\n                 self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n \n@@ -372,9 +372,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &hir::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n-        let fn_ty = match self.tcx.tables.borrow().method_map.get(&method_call) {\n+        let fn_ty = match self.tcx.tables().method_map.get(&method_call) {\n             Some(method) => method.ty,\n-            None => self.tcx.expr_ty_adjusted(func_or_rcvr)\n+            None => self.tcx.tables().expr_ty_adjusted(func_or_rcvr)\n         };\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);"}, {"sha": "43434b884c8d4b7e55b96c41c678565362ad7ef4", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -59,8 +59,8 @@ pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n     pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         blk: &hir::Block) -> CFG {\n-        construct::construct(tcx, blk)\n+                         body: &hir::Expr) -> CFG {\n+        construct::construct(tcx, body)\n     }\n \n     pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {"}, {"sha": "351feaba0346ab7e47a28146a074c0623f614528", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -103,11 +103,11 @@ pub enum DepNode<D: Clone + Debug> {\n     // nodes. Often we map multiple tables to the same node if there\n     // is no point in distinguishing them (e.g., both the type and\n     // predicates for an item wind up in `ItemSignature`).\n-    ImplOrTraitItems(D),\n+    AssociatedItems(D),\n     ItemSignature(D),\n     FieldTy(D),\n     SizedConstraint(D),\n-    ImplOrTraitItemDefIds(D),\n+    AssociatedItemDefIds(D),\n     InherentImpls(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n@@ -153,10 +153,10 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrateItem,\n             TypeckItemType,\n             TypeckItemBody,\n-            ImplOrTraitItems,\n+            AssociatedItems,\n             ItemSignature,\n             FieldTy,\n-            ImplOrTraitItemDefIds,\n+            AssociatedItemDefIds,\n             InherentImpls,\n             TraitImpls,\n             ReprHints,\n@@ -219,11 +219,11 @@ impl<D: Clone + Debug> DepNode<D> {\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n             TransCrateItem(ref d) => op(d).map(TransCrateItem),\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n-            ImplOrTraitItems(ref d) => op(d).map(ImplOrTraitItems),\n+            AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n             FieldTy(ref d) => op(d).map(FieldTy),\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n-            ImplOrTraitItemDefIds(ref d) => op(d).map(ImplOrTraitItemDefIds),\n+            AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),"}, {"sha": "50a478fcc2fd91d8da5b6e6bd6ecdbbe01de571f", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n use std::ops::Index;\n use std::hash::Hash;\n@@ -24,7 +24,7 @@ use super::{DepNode, DepGraph};\n pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n     phantom: PhantomData<M>,\n     graph: DepGraph,\n-    map: FnvHashMap<M::Key, M::Value>,\n+    map: FxHashMap<M::Key, M::Value>,\n }\n \n pub trait DepTrackingMapConfig {\n@@ -38,7 +38,7 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n         DepTrackingMap {\n             phantom: PhantomData,\n             graph: graph,\n-            map: FnvHashMap()\n+            map: FxHashMap()\n         }\n     }\n "}, {"sha": "8657a3e5a587899f80ebb536847bcb8f8a9a9f0c", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::fmt::Debug;\n use std::hash::Hash;\n use super::{DepGraphQuery, DepNode};\n \n pub struct DepGraphEdges<D: Clone + Debug + Eq + Hash> {\n     nodes: Vec<DepNode<D>>,\n-    indices: FnvHashMap<DepNode<D>, IdIndex>,\n-    edges: FnvHashSet<(IdIndex, IdIndex)>,\n+    indices: FxHashMap<DepNode<D>, IdIndex>,\n+    edges: FxHashSet<(IdIndex, IdIndex)>,\n     open_nodes: Vec<OpenNode>,\n }\n \n@@ -46,8 +46,8 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n     pub fn new() -> DepGraphEdges<D> {\n         DepGraphEdges {\n             nodes: vec![],\n-            indices: FnvHashMap(),\n-            edges: FnvHashSet(),\n+            indices: FxHashMap(),\n+            edges: FxHashSet(),\n             open_nodes: Vec::new()\n         }\n     }"}, {"sha": "2637d34c5c56e569d91a3e1bcff2ad47310efa50", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n@@ -34,19 +34,19 @@ struct DepGraphData {\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n     /// this map. We can later look for and extract that data.\n-    previous_work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n+    previous_work_products: RefCell<FxHashMap<Arc<WorkProductId>, WorkProduct>>,\n \n     /// Work-products that we generate in this run.\n-    work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n+    work_products: RefCell<FxHashMap<Arc<WorkProductId>, WorkProduct>>,\n }\n \n impl DepGraph {\n     pub fn new(enabled: bool) -> DepGraph {\n         DepGraph {\n             data: Rc::new(DepGraphData {\n                 thread: DepGraphThreadData::new(enabled),\n-                previous_work_products: RefCell::new(FnvHashMap()),\n-                work_products: RefCell::new(FnvHashMap()),\n+                previous_work_products: RefCell::new(FxHashMap()),\n+                work_products: RefCell::new(FxHashMap()),\n             })\n         }\n     }\n@@ -117,7 +117,7 @@ impl DepGraph {\n \n     /// Access the map of work-products created during this run. Only\n     /// used during saving of the dep-graph.\n-    pub fn work_products(&self) -> Ref<FnvHashMap<Arc<WorkProductId>, WorkProduct>> {\n+    pub fn work_products(&self) -> Ref<FxHashMap<Arc<WorkProductId>, WorkProduct>> {\n         self.data.work_products.borrow()\n     }\n }"}, {"sha": "4c791f9655342e8fae1ad00a057766e67037f6f4", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{Direction, INCOMING, Graph, NodeIndex, OUTGOING};\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -17,15 +17,15 @@ use super::DepNode;\n \n pub struct DepGraphQuery<D: Clone + Debug + Hash + Eq> {\n     pub graph: Graph<DepNode<D>, ()>,\n-    pub indices: FnvHashMap<DepNode<D>, NodeIndex>,\n+    pub indices: FxHashMap<DepNode<D>, NodeIndex>,\n }\n \n impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n     pub fn new(nodes: &[DepNode<D>],\n                edges: &[(DepNode<D>, DepNode<D>)])\n                -> DepGraphQuery<D> {\n         let mut graph = Graph::new();\n-        let mut indices = FnvHashMap();\n+        let mut indices = FxHashMap();\n         for node in nodes {\n             indices.insert(node.clone(), graph.next_node_index());\n             graph.add_node(node.clone());"}, {"sha": "ec09877ae121cdfeba73bc638f2ecf3492afee51", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -672,120 +672,6 @@ extern \"C\" {\n ```\n \"##,\n \n-E0269: r##\"\n-A returned value was expected but not all control paths return one.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0269\n-fn abracada_FAIL() -> String {\n-    \"this won't work\".to_string();\n-    // error: not all control paths return a value\n-}\n-```\n-\n-In the previous code, the function is supposed to return a `String`, however,\n-the code returns nothing (because of the ';'). Another erroneous code would be:\n-\n-```compile_fail\n-fn abracada_FAIL(b: bool) -> u32 {\n-    if b {\n-        0\n-    } else {\n-        \"a\" // It fails because an `u32` was expected and something else is\n-            // returned.\n-    }\n-}\n-```\n-\n-It is advisable to find out what the unhandled cases are and check for them,\n-returning an appropriate value or panicking if necessary. Check if you need\n-to remove a semicolon from the last expression, like in the first erroneous\n-code example.\n-\"##,\n-\n-E0270: r##\"\n-Rust lets you define functions which are known to never return, i.e. are\n-'diverging', by marking its return type as `!`.\n-\n-For example, the following functions never return:\n-\n-```no_run\n-fn foo() -> ! {\n-    loop {}\n-}\n-\n-fn bar() -> ! {\n-    foo() // foo() is diverging, so this will diverge too\n-}\n-\n-fn baz() -> ! {\n-    panic!(); // this macro internally expands to a call to a diverging function\n-}\n-```\n-\n-Such functions can be used in a place where a value is expected without\n-returning a value of that type, for instance:\n-\n-```no_run\n-fn foo() -> ! {\n-    loop {}\n-}\n-\n-let x = 3;\n-\n-let y = match x {\n-    1 => 1,\n-    2 => 4,\n-    _ => foo() // diverging function called here\n-};\n-\n-println!(\"{}\", y)\n-```\n-\n-If the third arm of the match block is reached, since `foo()` doesn't ever\n-return control to the match block, it is fine to use it in a place where an\n-integer was expected. The `match` block will never finish executing, and any\n-point where `y` (like the print statement) is needed will not be reached.\n-\n-However, if we had a diverging function that actually does finish execution:\n-\n-```ignore\n-fn foo() -> ! {\n-    loop {break;}\n-}\n-```\n-\n-Then we would have an unknown value for `y` in the following code:\n-\n-```no_run\n-fn foo() -> ! {\n-    loop {}\n-}\n-\n-let x = 3;\n-\n-let y = match x {\n-    1 => 1,\n-    2 => 4,\n-    _ => foo()\n-};\n-\n-println!(\"{}\", y);\n-```\n-\n-In the previous example, the print statement was never reached when the\n-wildcard match arm was hit, so we were okay with `foo()` not returning an\n-integer that we could set to `y`. But in this example, `foo()` actually does\n-return control, so the print statement will be executed with an uninitialized\n-value.\n-\n-Obviously we cannot have functions which are allowed to be used in such\n-positions and yet can return control. So, if you are defining a function that\n-returns `!`, make sure that there is no way for it to actually finish\n-executing.\n-\"##,\n-\n E0271: r##\"\n This is because of a type mismatch between the associated type of some\n trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)"}, {"sha": "044e36e5c9cd46fdc15aadd9e5ee0a01d401113d", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -52,6 +52,9 @@ pub enum Def {\n           ast::NodeId), // expr node that creates the closure\n     Label(ast::NodeId),\n \n+    // Macro namespace\n+    Macro(DefId),\n+\n     // Both namespaces\n     Err,\n }\n@@ -133,7 +136,7 @@ impl Def {\n             Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) | Def::TyAlias(id) |\n             Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n-            Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) => {\n+            Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) | Def::Macro(id) => {\n                 id\n             }\n \n@@ -173,6 +176,7 @@ impl Def {\n             Def::Upvar(..) => \"closure capture\",\n             Def::Label(..) => \"label\",\n             Def::SelfTy(..) => \"self type\",\n+            Def::Macro(..) => \"macro\",\n             Def::Err => \"unresolved item\",\n         }\n     }"}, {"sha": "d3771b1755b1659d5b36c61d908a50981a4ba444", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -34,6 +34,10 @@ impl Idx for CrateNum {\n /// LOCAL_CRATE in their DefId.\n pub const LOCAL_CRATE: CrateNum = CrateNum(0);\n \n+/// Virtual crate for builtin macros\n+// FIXME(jseyfried): this is also used for custom derives until proc-macro crates get `CrateNum`s.\n+pub const BUILTIN_MACROS_CRATE: CrateNum = CrateNum(!0);\n+\n impl CrateNum {\n     pub fn new(x: usize) -> CrateNum {\n         assert!(x < (u32::MAX as usize));"}, {"sha": "9932e5fe6862305cd366b9fd34f38ced1191f38d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -138,7 +138,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_where_predicate(&mut self, predicate: &'v WherePredicate) {\n         walk_where_predicate(self, predicate)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, id: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Expr, s: Span, id: NodeId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n@@ -635,13 +635,13 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_kind: FnKind<'v>,\n                                    function_declaration: &'v FnDecl,\n-                                   function_body: &'v Block,\n+                                   function_body: &'v Expr,\n                                    _span: Span,\n                                    id: NodeId) {\n     visitor.visit_id(id);\n     walk_fn_decl(visitor, function_declaration);\n     walk_fn_kind(visitor, function_kind);\n-    visitor.visit_block(function_body)\n+    visitor.visit_expr(function_body)\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n@@ -925,7 +925,7 @@ impl<'v> Visitor<'v> for IdRangeComputingVisitor {\n /// Computes the id range for a single fn body, ignoring nested items.\n pub fn compute_id_range_for_fn_body(fk: FnKind,\n                                     decl: &FnDecl,\n-                                    body: &Block,\n+                                    body: &Expr,\n                                     sp: Span,\n                                     id: NodeId)\n                                     -> IdRange {"}, {"sha": "b985298e47cc2f8ed0d7ccecab551a0edae0e99f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -595,12 +595,13 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemConst(self.lower_ty(t), self.lower_expr(e))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n+                let body = self.lower_block(body);\n                 hir::ItemFn(self.lower_fn_decl(decl),\n                             self.lower_unsafety(unsafety),\n                             self.lower_constness(constness),\n                             abi,\n                             self.lower_generics(generics),\n-                            self.lower_block(body))\n+                            self.expr_block(body, ThinVec::new()))\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n@@ -665,7 +666,10 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     TraitItemKind::Method(ref sig, ref body) => {\n                         hir::MethodTraitItem(this.lower_method_sig(sig),\n-                                             body.as_ref().map(|x| this.lower_block(x)))\n+                                             body.as_ref().map(|x| {\n+                            let body = this.lower_block(x);\n+                            this.expr_block(body, ThinVec::new())\n+                        }))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n                         hir::TypeTraitItem(this.lower_bounds(bounds),\n@@ -691,8 +695,9 @@ impl<'a> LoweringContext<'a> {\n                         hir::ImplItemKind::Const(this.lower_ty(ty), this.lower_expr(expr))\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n+                        let body = this.lower_block(body);\n                         hir::ImplItemKind::Method(this.lower_method_sig(sig),\n-                                                  this.lower_block(body))\n+                                                  this.expr_block(body, ThinVec::new()))\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -1110,7 +1115,7 @@ impl<'a> LoweringContext<'a> {\n                     self.with_parent_def(e.id, |this| {\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         this.lower_block(body),\n+                                         this.lower_expr(body),\n                                          fn_decl_span)\n                     })\n                 }\n@@ -1208,38 +1213,32 @@ impl<'a> LoweringContext<'a> {\n                 ExprKind::Break(opt_ident) => hir::ExprBreak(self.lower_opt_sp_ident(opt_ident)),\n                 ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| self.lower_expr(x))),\n-                ExprKind::InlineAsm(InlineAsm {\n-                        ref inputs,\n-                        ref outputs,\n-                        ref asm,\n-                        asm_str_style,\n-                        ref clobbers,\n-                        volatile,\n-                        alignstack,\n-                        dialect,\n-                        expn_id,\n-                    }) => hir::ExprInlineAsm(P(hir::InlineAsm {\n-                    inputs: inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n-                    outputs: outputs.iter()\n-                                    .map(|out| {\n-                                        hir::InlineAsmOutput {\n-                                            constraint: out.constraint.clone(),\n-                                            is_rw: out.is_rw,\n-                                            is_indirect: out.is_indirect,\n-                                        }\n-                                    })\n-                                    .collect(),\n-                    asm: asm.clone(),\n-                    asm_str_style: asm_str_style,\n-                    clobbers: clobbers.clone().into(),\n-                    volatile: volatile,\n-                    alignstack: alignstack,\n-                    dialect: dialect,\n-                    expn_id: expn_id,\n-                }), outputs.iter().map(|out| self.lower_expr(&out.expr)).collect(),\n-                   inputs.iter().map(|&(_, ref input)| self.lower_expr(input)).collect()),\n+                ExprKind::InlineAsm(ref asm) => {\n+                    let hir_asm = hir::InlineAsm {\n+                        inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n+                        outputs: asm.outputs.iter().map(|out| {\n+                            hir::InlineAsmOutput {\n+                                constraint: out.constraint.clone(),\n+                                is_rw: out.is_rw,\n+                                is_indirect: out.is_indirect,\n+                            }\n+                        }).collect(),\n+                        asm: asm.asm.clone(),\n+                        asm_str_style: asm.asm_str_style,\n+                        clobbers: asm.clobbers.clone().into(),\n+                        volatile: asm.volatile,\n+                        alignstack: asm.alignstack,\n+                        dialect: asm.dialect,\n+                        expn_id: asm.expn_id,\n+                    };\n+                    let outputs =\n+                        asm.outputs.iter().map(|out| self.lower_expr(&out.expr)).collect();\n+                    let inputs =\n+                        asm.inputs.iter().map(|&(_, ref input)| self.lower_expr(input)).collect();\n+                    hir::ExprInlineAsm(P(hir_asm), outputs, inputs)\n+                }\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                    hir::ExprStruct(self.lower_path(path),\n+                    hir::ExprStruct(P(self.lower_path(path)),\n                                     fields.iter().map(|x| self.lower_field(x)).collect(),\n                                     maybe_expr.as_ref().map(|x| self.lower_expr(x)))\n                 }\n@@ -1743,7 +1742,7 @@ impl<'a> LoweringContext<'a> {\n                    e: Option<P<hir::Expr>>,\n                    attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, false);\n-        let expr = self.expr(sp, hir::ExprStruct(path, fields, e), attrs);\n+        let expr = self.expr(sp, hir::ExprStruct(P(path), fields, e), attrs);\n         self.resolver.record_resolution(expr.id, def);\n         expr\n     }"}, {"sha": "325a90ea91e0ec25b18cd60d50f9c3fa4a548a66", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -21,11 +21,9 @@\n //! nested within a uniquely determined `FnLike`), and users can ask\n //! for the `Code` associated with a particular NodeId.\n \n-pub use self::Code::*;\n-\n use hir as ast;\n use hir::map::{self, Node};\n-use hir::{Block, FnDecl};\n+use hir::{Expr, FnDecl};\n use hir::intravisit::FnKind;\n use syntax::abi;\n use syntax::ast::{Attribute, Name, NodeId};\n@@ -50,7 +48,7 @@ pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n /// Components shared by fn-like things (fn items, methods, closures).\n pub struct FnParts<'a> {\n     pub decl: &'a FnDecl,\n-    pub body: &'a Block,\n+    pub body: &'a Expr,\n     pub kind: FnKind<'a>,\n     pub span: Span,\n     pub id:   NodeId,\n@@ -77,29 +75,32 @@ impl MaybeFnLike for ast::Expr {\n     }\n }\n \n-/// Carries either an FnLikeNode or a Block, as these are the two\n+/// Carries either an FnLikeNode or a Expr, as these are the two\n /// constructs that correspond to \"code\" (as in, something from which\n /// we can construct a control-flow graph).\n #[derive(Copy, Clone)]\n pub enum Code<'a> {\n-    FnLikeCode(FnLikeNode<'a>),\n-    BlockCode(&'a Block),\n+    FnLike(FnLikeNode<'a>),\n+    Expr(&'a Expr),\n }\n \n impl<'a> Code<'a> {\n     pub fn id(&self) -> NodeId {\n         match *self {\n-            FnLikeCode(node) => node.id(),\n-            BlockCode(block) => block.id,\n+            Code::FnLike(node) => node.id(),\n+            Code::Expr(block) => block.id,\n         }\n     }\n \n-    /// Attempts to construct a Code from presumed FnLike or Block node input.\n-    pub fn from_node(node: Node) -> Option<Code> {\n-        if let map::NodeBlock(block) = node {\n-            Some(BlockCode(block))\n-        } else {\n-            FnLikeNode::from_node(node).map(|fn_like| FnLikeCode(fn_like))\n+    /// Attempts to construct a Code from presumed FnLike or Expr node input.\n+    pub fn from_node(map: &map::Map<'a>, id: NodeId) -> Option<Code<'a>> {\n+        match map.get(id) {\n+            map::NodeBlock(_) => {\n+                //  Use the parent, hopefully an expression node.\n+                Code::from_node(map, map.get_parent_node(id))\n+            }\n+            map::NodeExpr(expr) => Some(Code::Expr(expr)),\n+            node => FnLikeNode::from_node(node).map(Code::FnLike)\n         }\n     }\n }\n@@ -114,7 +115,7 @@ struct ItemFnParts<'a> {\n     abi:      abi::Abi,\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n-    body:     &'a Block,\n+    body:     &'a Expr,\n     id:       NodeId,\n     span:     Span,\n     attrs:    &'a [Attribute],\n@@ -124,14 +125,14 @@ struct ItemFnParts<'a> {\n /// for use when implementing FnLikeNode operations.\n struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n-    body: &'a Block,\n+    body: &'a Expr,\n     id: NodeId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: &'a Block, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(d: &'a FnDecl, b: &'a Expr, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n         ClosureParts {\n             decl: d,\n             body: b,\n@@ -171,9 +172,9 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n-    pub fn body(self) -> &'a Block {\n+    pub fn body(self) -> &'a Expr {\n         self.handle(|i: ItemFnParts<'a>|  &*i.body,\n-                    |_, _, _: &'a ast::MethodSig, _, body: &'a ast::Block, _, _|  body,\n+                    |_, _, _: &'a ast::MethodSig, _, body: &'a ast::Expr, _, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n@@ -214,7 +215,7 @@ impl<'a> FnLikeNode<'a> {\n                   Name,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n-                  &'a ast::Block,\n+                  &'a ast::Expr,\n                   Span,\n                   &'a [Attribute])\n                   -> A,"}, {"sha": "04fcf7e84508e986c4b6c0151a65d39525513062", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -211,7 +211,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Block, s: Span, id: NodeId) {\n+                b: &'ast Expr, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }\n@@ -226,4 +226,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+        self.insert_entry(macro_def.id, NotPresent);\n+    }\n }"}, {"sha": "38157c7e565646c45b21a5dc985ad32606c56998", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n@@ -22,7 +22,7 @@ use util::nodemap::NodeMap;\n #[derive(Clone)]\n pub struct Definitions {\n     data: Vec<DefData>,\n-    key_map: FnvHashMap<DefKey, DefIndex>,\n+    key_map: FxHashMap<DefKey, DefIndex>,\n     node_map: NodeMap<DefIndex>,\n }\n \n@@ -219,7 +219,7 @@ impl Definitions {\n     pub fn new() -> Definitions {\n         Definitions {\n             data: vec![],\n-            key_map: FnvHashMap(),\n+            key_map: FxHashMap(),\n             node_map: NodeMap(),\n         }\n     }"}, {"sha": "6b5b8101a146ca57fd92184ab0300bd74030e905", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -33,7 +33,7 @@ pub use self::PathParameters::*;\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use util::nodemap::{NodeMap, FnvHashSet};\n+use util::nodemap::{NodeMap, FxHashSet};\n \n use syntax_pos::{mk_sp, Span, ExpnId, DUMMY_SP};\n use syntax::codemap::{self, respan, Spanned};\n@@ -840,8 +840,8 @@ pub enum UnsafeSource {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Expr {\n     pub id: NodeId,\n-    pub node: Expr_,\n     pub span: Span,\n+    pub node: Expr_,\n     pub attrs: ThinVec<Attribute>,\n }\n \n@@ -904,7 +904,7 @@ pub enum Expr_ {\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    ExprClosure(CaptureClause, P<FnDecl>, P<Block>, Span),\n+    ExprClosure(CaptureClause, P<FnDecl>, P<Expr>, Span),\n     /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n@@ -946,7 +946,7 @@ pub enum Expr_ {\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(Path, HirVec<Field>, Option<P<Expr>>),\n+    ExprStruct(P<Path>, HirVec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n@@ -1035,7 +1035,7 @@ pub enum TraitItem_ {\n     /// must contain a value)\n     ConstTraitItem(P<Ty>, Option<P<Expr>>),\n     /// A method with an optional body\n-    MethodTraitItem(MethodSig, Option<P<Block>>),\n+    MethodTraitItem(MethodSig, Option<P<Expr>>),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n@@ -1060,7 +1060,7 @@ pub enum ImplItemKind {\n     /// of the expression\n     Const(P<Ty>, P<Expr>),\n     /// A method implementation with the given signature and body\n-    Method(MethodSig, P<Block>),\n+    Method(MethodSig, P<Expr>),\n     /// An associated type\n     Type(P<Ty>),\n }\n@@ -1501,7 +1501,7 @@ pub enum Item_ {\n     /// A `const` item\n     ItemConst(P<Ty>, P<Expr>),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Block>),\n+    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Expr>),\n     /// A module\n     ItemMod(Mod),\n     /// An external module\n@@ -1605,4 +1605,4 @@ pub type TraitMap = NodeMap<Vec<TraitCandidate>>;\n \n // Map from the NodeId of a glob import to a list of items which are actually\n // imported.\n-pub type GlobMap = NodeMap<FnvHashSet<Name>>;\n+pub type GlobMap = NodeMap<FxHashSet<Name>>;"}, {"sha": "2c4ffb853c1f3af157a3d5e4d57e45a3e80191f0", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -713,7 +713,9 @@ impl<'a> State<'a> {\n                               typarams,\n                               &item.vis)?;\n                 word(&mut self.s, \" \")?;\n-                self.print_block_with_attrs(&body, &item.attrs)?;\n+                self.end()?; // need to close a box\n+                self.end()?; // need to close a box\n+                self.print_expr(&body)?;\n             }\n             hir::ItemMod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n@@ -1002,7 +1004,9 @@ impl<'a> State<'a> {\n                 self.print_method_sig(ti.name, sig, &hir::Inherited)?;\n                 if let Some(ref body) = *body {\n                     self.nbsp()?;\n-                    self.print_block_with_attrs(body, &ti.attrs)?;\n+                    self.end()?; // need to close a box\n+                    self.end()?; // need to close a box\n+                    self.print_expr(body)?;\n                 } else {\n                     word(&mut self.s, \";\")?;\n                 }\n@@ -1034,7 +1038,9 @@ impl<'a> State<'a> {\n                 self.head(\"\")?;\n                 self.print_method_sig(ii.name, sig, &ii.vis)?;\n                 self.nbsp()?;\n-                self.print_block_with_attrs(body, &ii.attrs)?;\n+                self.end()?; // need to close a box\n+                self.end()?; // need to close a box\n+                self.print_expr(body)?;\n             }\n             hir::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.name, None, Some(ty))?;\n@@ -1402,26 +1408,10 @@ impl<'a> State<'a> {\n                 self.print_fn_block_args(&decl)?;\n                 space(&mut self.s)?;\n \n-                let default_return = match decl.output {\n-                    hir::DefaultReturn(..) => true,\n-                    _ => false,\n-                };\n+                // this is a bare expression\n+                self.print_expr(body)?;\n+                self.end()?; // need to close a box\n \n-                if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n-                    self.print_block_unclosed(&body)?;\n-                } else {\n-                    // we extract the block, so as not to create another set of boxes\n-                    match body.expr.as_ref().unwrap().node {\n-                        hir::ExprBlock(ref blk) => {\n-                            self.print_block_unclosed(&blk)?;\n-                        }\n-                        _ => {\n-                            // this is a bare expression\n-                            self.print_expr(body.expr.as_ref().map(|e| &**e).unwrap())?;\n-                            self.end()?; // need to close a box\n-                        }\n-                    }\n-                }\n                 // a box will be closed by print_expr, but we didn't want an overall\n                 // wrapper so we closed the corresponding opening. so create an\n                 // empty box to satisfy the close."}, {"sha": "47c0bc5fd60c56f8a9daabbf4f65111b9a475dcd", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 73, "deletions": 22, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -245,6 +245,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n \n         for error in errors {\n+            debug!(\"report_region_errors: error = {:?}\", error);\n             match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n                     self.report_concrete_failure(origin, sub, sup).emit();\n@@ -299,44 +300,64 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut bound_failures = Vec::new();\n \n         for error in errors {\n+            // Check whether we can process this error into some other\n+            // form; if not, fall through.\n             match *error {\n                 ConcreteFailure(ref origin, sub, sup) => {\n                     debug!(\"processing ConcreteFailure\");\n-                    match free_regions_from_same_fn(self.tcx, sub, sup) {\n-                        Some(ref same_frs) => {\n-                            origins.push(\n-                                ProcessedErrorOrigin::ConcreteFailure(\n-                                    origin.clone(),\n-                                    sub,\n-                                    sup));\n-                            append_to_same_regions(&mut same_regions, same_frs);\n-                        }\n-                        _ => {\n-                            other_errors.push(error.clone());\n-                        }\n+                    if let SubregionOrigin::CompareImplMethodObligation { .. } = *origin {\n+                        // When comparing an impl method against a\n+                        // trait method, it is not helpful to suggest\n+                        // changes to the impl method.  This is\n+                        // because the impl method signature is being\n+                        // checked using the trait's environment, so\n+                        // usually the changes we suggest would\n+                        // actually have to be applied to the *trait*\n+                        // method (and it's not clear that the trait\n+                        // method is even under the user's control).\n+                    } else if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n+                        origins.push(\n+                            ProcessedErrorOrigin::ConcreteFailure(\n+                                origin.clone(),\n+                                sub,\n+                                sup));\n+                        append_to_same_regions(&mut same_regions, &same_frs);\n+                        continue;\n                     }\n                 }\n-                SubSupConflict(ref var_origin, _, sub_r, _, sup_r) => {\n-                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub_r, sup_r);\n-                    match free_regions_from_same_fn(self.tcx, sub_r, sup_r) {\n-                        Some(ref same_frs) => {\n-                            origins.push(\n-                                ProcessedErrorOrigin::VariableFailure(\n-                                    var_origin.clone()));\n-                            append_to_same_regions(&mut same_regions, same_frs);\n+                SubSupConflict(ref var_origin, ref sub_origin, sub, ref sup_origin, sup) => {\n+                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub, sup);\n+                    match (sub_origin, sup_origin) {\n+                        (&SubregionOrigin::CompareImplMethodObligation { .. }, _) => {\n+                            // As above, when comparing an impl method\n+                            // against a trait method, it is not helpful\n+                            // to suggest changes to the impl method.\n                         }\n-                        None => {\n-                            other_errors.push(error.clone());\n+                        (_, &SubregionOrigin::CompareImplMethodObligation { .. }) => {\n+                            // See above.\n+                        }\n+                        _ => {\n+                            if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n+                                origins.push(\n+                                    ProcessedErrorOrigin::VariableFailure(\n+                                        var_origin.clone()));\n+                                append_to_same_regions(&mut same_regions, &same_frs);\n+                                continue;\n+                            }\n                         }\n                     }\n                 }\n                 GenericBoundFailure(ref origin, ref kind, region) => {\n                     bound_failures.push((origin.clone(), kind.clone(), region));\n+                    continue;\n                 }\n                 ProcessedErrors(..) => {\n                     bug!(\"should not encounter a `ProcessedErrors` yet: {:?}\", error)\n                 }\n             }\n+\n+            // No changes to this error.\n+            other_errors.push(error.clone());\n         }\n \n         // ok, let's pull together the errors, sorted in an order that\n@@ -630,6 +651,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"the associated type `{}`\", p),\n         };\n \n+        if let SubregionOrigin::CompareImplMethodObligation {\n+            span, item_name, impl_item_def_id, trait_item_def_id, lint_id\n+        } = origin {\n+            self.report_extra_impl_obligation(span,\n+                                              item_name,\n+                                              impl_item_def_id,\n+                                              trait_item_def_id,\n+                                              &format!(\"`{}: {}`\", bound_kind, sub),\n+                                              lint_id)\n+                .emit();\n+            return;\n+        }\n+\n         let mut err = match *sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n@@ -947,6 +981,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     \"\");\n                 err\n             }\n+            infer::CompareImplMethodObligation { span,\n+                                                 item_name,\n+                                                 impl_item_def_id,\n+                                                 trait_item_def_id,\n+                                                 lint_id } => {\n+                self.report_extra_impl_obligation(span,\n+                                                  item_name,\n+                                                  impl_item_def_id,\n+                                                  trait_item_def_id,\n+                                                  &format!(\"`{}: {}`\", sup, sub),\n+                                                  lint_id)\n+            }\n         }\n     }\n \n@@ -1792,6 +1838,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     \"...so that references are valid when the destructor \\\n                      runs\");\n             }\n+            infer::CompareImplMethodObligation { span, .. } => {\n+                err.span_note(\n+                    span,\n+                    \"...so that the definition in impl matches the definition from the trait\");\n+            }\n         }\n     }\n }"}, {"sha": "30e18a4c569b2fa7093c9b53b66aeb7c8cea8e81", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -32,7 +32,7 @@\n \n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeFolder;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use std::collections::hash_map::Entry;\n \n use super::InferCtxt;\n@@ -41,7 +41,7 @@ use super::unify_key::ToType;\n pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     freshen_count: u32,\n-    freshen_map: FnvHashMap<ty::InferTy, Ty<'tcx>>,\n+    freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -50,7 +50,7 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n         TypeFreshener {\n             infcx: infcx,\n             freshen_count: 0,\n-            freshen_map: FnvHashMap(),\n+            freshen_map: FxHashMap(),\n         }\n     }\n "}, {"sha": "737ce8bdf681daf25cd0b3dc30e3888b9d1b3623", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -24,7 +24,7 @@ use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n use syntax_pos::Span;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n pub struct HrMatchResult<U> {\n     pub value: U,\n@@ -135,7 +135,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // Map each skolemized region to a vector of other regions that it\n             // must be equated with. (Note that this vector may include other\n             // skolemized regions from `skol_map`.)\n-            let skol_resolution_map: FnvHashMap<_, _> =\n+            let skol_resolution_map: FxHashMap<_, _> =\n                 skol_map\n                 .iter()\n                 .map(|(&br, &skol)| {\n@@ -158,7 +158,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // `skol_map`. There should always be a representative if things\n             // are properly well-formed.\n             let mut unconstrained_regions = vec![];\n-            let skol_representatives: FnvHashMap<_, _> =\n+            let skol_representatives: FxHashMap<_, _> =\n                 skol_resolution_map\n                 .iter()\n                 .map(|(&skol, &(br, ref regions))| {\n@@ -268,7 +268,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                             a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n                                              r0: &'tcx ty::Region)\n                                              -> &'tcx ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n@@ -364,8 +364,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FnvHashMap<ty::BoundRegion,\n-                                                                &'tcx ty::Region>,\n+                                             a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n                                              a_vars: &[ty::RegionVid],\n                                              b_vars: &[ty::RegionVid],\n                                              r0: &'tcx ty::Region)\n@@ -434,7 +433,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                       span: Span,\n-                                      a_map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                      a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n                                       r: &'tcx ty::Region) -> &'tcx ty::Region\n         {\n             for (a_br, a_r) in a_map {\n@@ -457,7 +456,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n }\n \n fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+                           map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n                            -> Vec<ty::RegionVid> {\n     map.iter()\n        .map(|(_, &r)| match *r {\n@@ -504,7 +503,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        snapshot: &CombinedSnapshot,\n                        r: &'tcx ty::Region,\n                        directions: TaintDirections)\n-                       -> FnvHashSet<&'tcx ty::Region> {\n+                       -> FxHashSet<&'tcx ty::Region> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r, directions)\n     }\n \n@@ -568,7 +567,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let escaping_types =\n             self.type_variables.borrow_mut().types_escaping_snapshot(&snapshot.type_snapshot);\n \n-        let mut escaping_region_vars = FnvHashSet();\n+        let mut escaping_region_vars = FxHashSet();\n         for ty in &escaping_types {\n             self.tcx.collect_regions(ty, &mut escaping_region_vars);\n         }\n@@ -764,7 +763,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // region back to the `ty::BoundRegion` that it originally\n         // represented. Because `leak_check` passed, we know that\n         // these taint sets are mutually disjoint.\n-        let inv_skol_map: FnvHashMap<&'tcx ty::Region, ty::BoundRegion> =\n+        let inv_skol_map: FxHashMap<&'tcx ty::Region, ty::BoundRegion> =\n             skol_map\n             .iter()\n             .flat_map(|(&skol_br, &skol)| {\n@@ -837,7 +836,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                           snapshot: &CombinedSnapshot)\n     {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n-        let skol_regions: FnvHashSet<_> = skol_map.values().cloned().collect();\n+        let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n         self.region_vars.pop_skolemized(&skol_regions, &snapshot.region_vars_snapshot);\n         if !skol_map.is_empty() {\n             self.projection_cache.borrow_mut().rollback_skolemized("}, {"sha": "ebafd206e26e293e1dff442946ecd5efcaaa2d0e", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 63, "deletions": 35, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -39,7 +39,7 @@ use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n-use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n+use util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n \n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n@@ -134,7 +134,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     // the set of predicates on which errors have been reported, to\n     // avoid reporting the same error twice.\n-    pub reported_trait_errors: RefCell<FnvHashSet<traits::TraitErrorKey<'tcx>>>,\n+    pub reported_trait_errors: RefCell<FxHashSet<traits::TraitErrorKey<'tcx>>>,\n \n     // Sadly, the behavior of projection varies a bit depending on the\n     // stage of compilation. The specifics are given in the\n@@ -170,7 +170,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap<'tcx> = FnvHashMap<ty::BoundRegion, &'tcx ty::Region>;\n+pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, &'tcx ty::Region>;\n \n /// Why did we require that the two types be related?\n ///\n@@ -355,6 +355,19 @@ pub enum SubregionOrigin<'tcx> {\n \n     // Region constraint arriving from destructor safety\n     SafeDestructor(Span),\n+\n+    // Comparing the signature and requirements of an impl method against\n+    // the containing trait.\n+    CompareImplMethodObligation {\n+        span: Span,\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+\n+        // this is `Some(_)` if this error arises from the bug fix for\n+        // #18937. This is a temporary measure.\n+        lint_id: Option<ast::NodeId>,\n+    },\n }\n \n /// Places that type/region parameters can appear.\n@@ -479,7 +492,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n-            reported_trait_errors: RefCell::new(FnvHashSet()),\n+            reported_trait_errors: RefCell::new(FxHashSet()),\n             projection_mode: Reveal::NotSpecializable,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n@@ -518,7 +531,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             parameter_environment: param_env,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            reported_trait_errors: RefCell::new(FnvHashSet()),\n+            reported_trait_errors: RefCell::new(FxHashSet()),\n             projection_mode: projection_mode,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n@@ -1056,7 +1069,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.probe(|_| {\n             let origin = TypeOrigin::Misc(syntax_pos::DUMMY_SP);\n             let trace = TypeTrace::types(origin, true, a, b);\n-            self.sub(true, trace, &a, &b).map(|_| ())\n+            self.sub(true, trace, &a, &b).map(|InferOk { obligations, .. }| {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            })\n         })\n     }\n \n@@ -1147,16 +1163,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn region_outlives_predicate(&self,\n-                                     span: Span,\n+                                     cause: &traits::ObligationCause<'tcx>,\n                                      predicate: &ty::PolyRegionOutlivesPredicate<'tcx>)\n         -> UnitResult<'tcx>\n     {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n-            let origin = RelateRegionParamBound(span);\n+            let origin =\n+                SubregionOrigin::from_obligation_cause(cause,\n+                                                       || RelateRegionParamBound(cause.span));\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, span, &skol_map, snapshot)?;\n+            self.leak_check(false, cause.span, &skol_map, snapshot)?;\n             Ok(self.pop_skolemized(skol_map, snapshot))\n         })\n     }\n@@ -1251,26 +1269,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.region_vars.new_bound(debruijn)\n     }\n \n-    /// Apply `adjustment` to the type of `expr`\n-    pub fn adjust_expr_ty(&self,\n-                          expr: &hir::Expr,\n-                          adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n-                          -> Ty<'tcx>\n-    {\n-        let raw_ty = self.expr_ty(expr);\n-        let raw_ty = self.shallow_resolve(raw_ty);\n-        let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n-        raw_ty.adjust(self.tcx,\n-                      expr.span,\n-                      expr.id,\n-                      adjustment,\n-                      |method_call| self.tables\n-                                        .borrow()\n-                                        .method_map\n-                                        .get(&method_call)\n-                                        .map(|method| resolve_ty(method.ty)))\n-    }\n-\n     /// True if errors have been reported since this infcx was\n     /// created.  This is sometimes used as a heuristic to skip\n     /// reporting errors that often occur as a result of earlier\n@@ -1532,7 +1530,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n-        -> (T, FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+        -> (T, FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n         where T : TypeFoldable<'tcx>\n     {\n         self.tcx.replace_late_bound_regions(\n@@ -1597,8 +1595,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // anyhow. We should make this typetrace stuff more\n             // generic so we don't have to do anything quite this\n             // terrible.\n-            self.equate(true, TypeTrace::dummy(self.tcx), a, b)\n-        }).map(|_| ())\n+            let trace = TypeTrace::dummy(self.tcx);\n+            self.equate(true, trace, a, b).map(|InferOk { obligations, .. }| {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            })\n+        })\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n@@ -1607,7 +1609,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        let ty = self.adjust_expr_ty(expr, self.tables.borrow().adjustments.get(&expr.id));\n+        let ty = self.tables.borrow().expr_ty_adjusted(expr);\n         self.resolve_type_vars_or_error(&ty)\n     }\n \n@@ -1651,9 +1653,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .map(|method| method.def_id)\n     }\n \n-    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::AutoAdjustment<'tcx>>> {\n+    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::Adjustment<'tcx>>> {\n         fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n-                                        -> &'a NodeMap<adjustment::AutoAdjustment<'tcx>> {\n+                                        -> &'a NodeMap<adjustment::Adjustment<'tcx>> {\n             &tables.adjustments\n         }\n \n@@ -1786,6 +1788,32 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             AddrOf(a) => a,\n             AutoBorrow(a) => a,\n             SafeDestructor(a) => a,\n+            CompareImplMethodObligation { span, .. } => span,\n+        }\n+    }\n+\n+    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>,\n+                                    default: F)\n+                                    -> Self\n+        where F: FnOnce() -> Self\n+    {\n+        match cause.code {\n+            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) =>\n+                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span),\n+\n+            traits::ObligationCauseCode::CompareImplMethodObligation { item_name,\n+                                                                       impl_item_def_id,\n+                                                                       trait_item_def_id,\n+                                                                       lint_id } =>\n+                SubregionOrigin::CompareImplMethodObligation {\n+                    span: cause.span,\n+                    item_name: item_name,\n+                    impl_item_def_id: impl_item_def_id,\n+                    trait_item_def_id: trait_item_def_id,\n+                    lint_id: lint_id,\n+                },\n+\n+            _ => default(),\n         }\n     }\n }"}, {"sha": "95ce8d39ff488b0c7fc099d60528988f94b4ed37", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -23,7 +23,7 @@ use middle::region::CodeExtent;\n use super::Constraint;\n use infer::SubregionOrigin;\n use infer::region_inference::RegionVarBindings;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry::Vacant;\n@@ -122,8 +122,8 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     graph_name: String,\n-    map: &'a FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n-    node_ids: FnvHashMap<Node, usize>,\n+    map: &'a FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n+    node_ids: FxHashMap<Node, usize>,\n }\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]\n@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n            map: &'a ConstraintMap<'tcx>)\n            -> ConstraintGraph<'a, 'gcx, 'tcx> {\n         let mut i = 0;\n-        let mut node_ids = FnvHashMap();\n+        let mut node_ids = FxHashMap();\n         {\n             let mut add_node = |node| {\n                 if let Vacant(e) = node_ids.entry(node) {\n@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     type Node = Node;\n     type Edge = Edge<'tcx>;\n     fn nodes(&self) -> dot::Nodes<Node> {\n-        let mut set = FnvHashSet();\n+        let mut set = FxHashSet();\n         for node in self.node_ids.keys() {\n             set.insert(*node);\n         }\n@@ -261,7 +261,7 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub type ConstraintMap<'tcx> = FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n+pub type ConstraintMap<'tcx> = FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n \n fn dump_region_constraints_to<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                               map: &ConstraintMap<'tcx>,"}, {"sha": "af6f2c50e72fc2b0ebfbeefb59f76c99811ec4b3", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -19,7 +19,7 @@ pub use self::VarValue::*;\n use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n use super::unify_key;\n \n-use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n@@ -213,7 +213,7 @@ impl SameRegions {\n     }\n }\n \n-pub type CombineMap<'tcx> = FnvHashMap<TwoRegions<'tcx>, RegionVid>;\n+pub type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -222,7 +222,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // Constraints of the form `A <= B` introduced by the region\n     // checker.  Here at least one of `A` and `B` must be a region\n     // variable.\n-    constraints: RefCell<FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n+    constraints: RefCell<FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n \n     // A \"verify\" is something that we need to verify after inference is\n     // done, but which does not directly affect inference in any way.\n@@ -248,7 +248,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // record the fact that `'a <= 'b` is implied by the fn signature,\n     // and then ignore the constraint when solving equations. This is\n     // a bit of a hack but seems to work.\n-    givens: RefCell<FnvHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n+    givens: RefCell<FxHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap<'tcx>>,\n     glbs: RefCell<CombineMap<'tcx>>,\n@@ -305,14 +305,14 @@ impl TaintDirections {\n \n struct TaintSet<'tcx> {\n     directions: TaintDirections,\n-    regions: FnvHashSet<&'tcx ty::Region>\n+    regions: FxHashSet<&'tcx ty::Region>\n }\n \n impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n     fn new(directions: TaintDirections,\n            initial_region: &'tcx ty::Region)\n            -> Self {\n-        let mut regions = FnvHashSet();\n+        let mut regions = FxHashSet();\n         regions.insert(initial_region);\n         TaintSet { directions: directions, regions: regions }\n     }\n@@ -362,7 +362,7 @@ impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n         }\n     }\n \n-    fn into_set(self) -> FnvHashSet<&'tcx ty::Region> {\n+    fn into_set(self) -> FxHashSet<&'tcx ty::Region> {\n         self.regions\n     }\n \n@@ -393,11 +393,11 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             tcx: tcx,\n             var_origins: RefCell::new(Vec::new()),\n             values: RefCell::new(None),\n-            constraints: RefCell::new(FnvHashMap()),\n+            constraints: RefCell::new(FxHashMap()),\n             verifys: RefCell::new(Vec::new()),\n-            givens: RefCell::new(FnvHashSet()),\n-            lubs: RefCell::new(FnvHashMap()),\n-            glbs: RefCell::new(FnvHashMap()),\n+            givens: RefCell::new(FxHashSet()),\n+            lubs: RefCell::new(FxHashMap()),\n+            glbs: RefCell::new(FxHashMap()),\n             skolemization_count: Cell::new(0),\n             bound_count: Cell::new(0),\n             undo_log: RefCell::new(Vec::new()),\n@@ -547,7 +547,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// completes to remove all trace of the skolemized regions\n     /// created in that time.\n     pub fn pop_skolemized(&self,\n-                          skols: &FnvHashSet<&'tcx ty::Region>,\n+                          skols: &FxHashSet<&'tcx ty::Region>,\n                           snapshot: &RegionSnapshot) {\n         debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n \n@@ -601,7 +601,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         self.skolemization_count.set(snapshot.skolemization_count);\n         return;\n \n-        fn kill_constraint<'tcx>(skols: &FnvHashSet<&'tcx ty::Region>,\n+        fn kill_constraint<'tcx>(skols: &FxHashSet<&'tcx ty::Region>,\n                                  undo_entry: &UndoLogEntry<'tcx>)\n                                  -> bool {\n             match undo_entry {\n@@ -905,7 +905,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                    mark: &RegionSnapshot,\n                    r0: &'tcx Region,\n                    directions: TaintDirections)\n-                   -> FnvHashSet<&'tcx ty::Region> {\n+                   -> FxHashSet<&'tcx ty::Region> {\n         debug!(\"tainted(mark={:?}, r0={:?}, directions={:?})\",\n                mark, r0, directions);\n \n@@ -1414,13 +1414,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                                 dup_vec: &mut [u32])\n                                 -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n         struct WalkState<'tcx> {\n-            set: FnvHashSet<RegionVid>,\n+            set: FxHashSet<RegionVid>,\n             stack: Vec<RegionVid>,\n             result: Vec<RegionAndOrigin<'tcx>>,\n             dup_found: bool,\n         }\n         let mut state = WalkState {\n-            set: FnvHashSet(),\n+            set: FxHashSet(),\n             stack: vec![orig_node_idx],\n             result: Vec::new(),\n             dup_found: false,"}, {"sha": "fa49e5c7289515b56d5725036c8927e922285ccb", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -31,7 +31,7 @@\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(enumset)]\n #![feature(libc)]\n #![feature(nonzero)]"}, {"sha": "82a46f76401d52a2a559bc6edd0fce550069009a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -198,6 +198,12 @@ declare_lint! {\n     \"patterns in functions without body were erroneously allowed\"\n }\n \n+declare_lint! {\n+    pub EXTRA_REQUIREMENT_IN_IMPL,\n+    Warn,\n+    \"detects extra requirements in impls that were erroneously allowed\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -235,7 +241,8 @@ impl LintPass for HardwiredLints {\n             HR_LIFETIME_IN_ASSOC_TYPE,\n             LIFETIME_UNDERSCORE,\n             SAFE_EXTERN_STATICS,\n-            PATTERNS_IN_FNS_WITHOUT_BODY\n+            PATTERNS_IN_FNS_WITHOUT_BODY,\n+            EXTRA_REQUIREMENT_IN_IMPL\n         )\n     }\n }"}, {"sha": "f44f82860077e21498288a59f723c02962d33ad0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 103, "deletions": 51, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -33,16 +33,17 @@ use lint::{Level, LevelSource, Lint, LintId, LintPass, LintSource};\n use lint::{EarlyLintPassObject, LateLintPassObject};\n use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n use lint::builtin;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use std::cmp;\n use std::default::Default as StdDefault;\n use std::mem;\n+use std::fmt;\n use syntax::attr;\n use syntax::parse::token::InternedString;\n use syntax::ast;\n-use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n+use syntax_pos::{MultiSpan, Span};\n+use errors::{self, Diagnostic, DiagnosticBuilder};\n use hir;\n use hir::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n@@ -63,23 +64,63 @@ pub struct LintStore {\n     late_passes: Option<Vec<LateLintPassObject>>,\n \n     /// Lints indexed by name.\n-    by_name: FnvHashMap<String, TargetLint>,\n+    by_name: FxHashMap<String, TargetLint>,\n \n     /// Current levels of each lint, and where they were set.\n-    levels: FnvHashMap<LintId, LevelSource>,\n+    levels: FxHashMap<LintId, LevelSource>,\n \n     /// Map of registered lint groups to what lints they expand to. The bool\n     /// is true if the lint group was added by a plugin.\n-    lint_groups: FnvHashMap<&'static str, (Vec<LintId>, bool)>,\n+    lint_groups: FxHashMap<&'static str, (Vec<LintId>, bool)>,\n \n     /// Extra info for future incompatibility lints, descibing the\n     /// issue or RFC that caused the incompatibility.\n-    future_incompatible: FnvHashMap<LintId, FutureIncompatibleInfo>,\n+    future_incompatible: FxHashMap<LintId, FutureIncompatibleInfo>,\n \n     /// Maximum level a lint can be\n     lint_cap: Option<Level>,\n }\n \n+/// When you call `add_lint` on the session, you wind up storing one\n+/// of these, which records a \"potential lint\" at a particular point.\n+#[derive(PartialEq)]\n+pub struct EarlyLint {\n+    /// what lint is this? (e.g., `dead_code`)\n+    pub id: LintId,\n+\n+    /// the main message\n+    pub diagnostic: Diagnostic,\n+}\n+\n+impl fmt::Debug for EarlyLint {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"EarlyLint\")\n+            .field(\"id\", &self.id)\n+            .field(\"span\", &self.diagnostic.span)\n+            .field(\"diagnostic\", &self.diagnostic)\n+            .finish()\n+    }\n+}\n+\n+pub trait IntoEarlyLint {\n+    fn into_early_lint(self, id: LintId) -> EarlyLint;\n+}\n+\n+impl<'a> IntoEarlyLint for (Span, &'a str) {\n+    fn into_early_lint(self, id: LintId) -> EarlyLint {\n+        let (span, msg) = self;\n+        let mut diagnostic = Diagnostic::new(errors::Level::Warning, msg);\n+        diagnostic.set_span(span);\n+        EarlyLint { id: id, diagnostic: diagnostic }\n+    }\n+}\n+\n+impl IntoEarlyLint for Diagnostic {\n+    fn into_early_lint(self, id: LintId) -> EarlyLint {\n+        EarlyLint { id: id, diagnostic: self }\n+    }\n+}\n+\n /// Extra information for a future incompatibility lint. See the call\n /// to `register_future_incompatible` in `librustc_lint/lib.rs` for\n /// guidelines.\n@@ -130,10 +171,10 @@ impl LintStore {\n             lints: vec![],\n             early_passes: Some(vec![]),\n             late_passes: Some(vec![]),\n-            by_name: FnvHashMap(),\n-            levels: FnvHashMap(),\n-            future_incompatible: FnvHashMap(),\n-            lint_groups: FnvHashMap(),\n+            by_name: FxHashMap(),\n+            levels: FxHashMap(),\n+            future_incompatible: FxHashMap(),\n+            lint_groups: FxHashMap(),\n             lint_cap: None,\n         }\n     }\n@@ -263,8 +304,8 @@ impl LintStore {\n                 Err(FindLintError::Removed) => { }\n                 Err(_) => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n-                                                 .collect::<FnvHashMap<&'static str,\n-                                                                       Vec<LintId>>>()\n+                                                 .collect::<FxHashMap<&'static str,\n+                                                                      Vec<LintId>>>()\n                                                  .get(&lint_name[..]) {\n                         Some(v) => {\n                             v.iter()\n@@ -388,22 +429,24 @@ pub fn gather_attr(attr: &ast::Attribute)\n /// in trans that run after the main lint pass is finished. Most\n /// lints elsewhere in the compiler should call\n /// `Session::add_lint()` instead.\n-pub fn raw_emit_lint(sess: &Session,\n-                     lints: &LintStore,\n-                     lint: &'static Lint,\n-                     lvlsrc: LevelSource,\n-                     span: Option<Span>,\n-                     msg: &str) {\n+pub fn raw_emit_lint<S: Into<MultiSpan>>(sess: &Session,\n+                                         lints: &LintStore,\n+                                         lint: &'static Lint,\n+                                         lvlsrc: LevelSource,\n+                                         span: Option<S>,\n+                                         msg: &str) {\n     raw_struct_lint(sess, lints, lint, lvlsrc, span, msg).emit();\n }\n \n-pub fn raw_struct_lint<'a>(sess: &'a Session,\n-                           lints: &LintStore,\n-                           lint: &'static Lint,\n-                           lvlsrc: LevelSource,\n-                           span: Option<Span>,\n-                           msg: &str)\n-                           -> DiagnosticBuilder<'a> {\n+pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n+                              lints: &LintStore,\n+                              lint: &'static Lint,\n+                              lvlsrc: LevelSource,\n+                              span: Option<S>,\n+                              msg: &str)\n+                              -> DiagnosticBuilder<'a>\n+    where S: Into<MultiSpan>\n+{\n     let (mut level, source) = lvlsrc;\n     if level == Allow {\n         return sess.diagnostic().struct_dummy();\n@@ -496,11 +539,11 @@ pub trait LintContext: Sized {\n         raw_emit_lint(&self.sess(), self.lints(), lint, (level, src), span, msg);\n     }\n \n-    fn lookup(&self,\n-              lint: &'static Lint,\n-              span: Option<Span>,\n-              msg: &str)\n-              -> DiagnosticBuilder {\n+    fn lookup<S: Into<MultiSpan>>(&self,\n+                                  lint: &'static Lint,\n+                                  span: Option<S>,\n+                                  msg: &str)\n+                                  -> DiagnosticBuilder {\n         let (level, src) = match self.level_src(lint) {\n             None => return self.sess().diagnostic().struct_dummy(),\n             Some(pair) => pair,\n@@ -514,11 +557,20 @@ pub trait LintContext: Sized {\n         self.lookup_and_emit(lint, Some(span), msg);\n     }\n \n-    fn struct_span_lint(&self,\n-                        lint: &'static Lint,\n-                        span: Span,\n-                        msg: &str)\n-                        -> DiagnosticBuilder {\n+    fn early_lint(&self, early_lint: EarlyLint) {\n+        let span = early_lint.diagnostic.span.primary_span().expect(\"early lint w/o primary span\");\n+        let mut err = self.struct_span_lint(early_lint.id.lint,\n+                                            span,\n+                                            &early_lint.diagnostic.message);\n+        err.copy_details_not_message(&early_lint.diagnostic);\n+        err.emit();\n+    }\n+\n+    fn struct_span_lint<S: Into<MultiSpan>>(&self,\n+                                            lint: &'static Lint,\n+                                            span: S,\n+                                            msg: &str)\n+                                            -> DiagnosticBuilder {\n         self.lookup(lint, Some(span), msg)\n     }\n \n@@ -786,7 +838,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'v>, decl: &'v hir::FnDecl,\n-                body: &'v hir::Block, span: Span, id: ast::NodeId) {\n+                body: &'v hir::Expr, span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n@@ -942,10 +994,10 @@ impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n     }\n \n     fn visit_fn(&mut self, fk: ast_visit::FnKind, decl: &ast::FnDecl,\n-                body: &ast::Block, span: Span, id: ast::NodeId) {\n-        run_lints!(self, check_fn, early_passes, fk, decl, body, span, id);\n-        ast_visit::walk_fn(self, fk, decl, body, span);\n-        run_lints!(self, check_fn_post, early_passes, fk, decl, body, span, id);\n+                span: Span, id: ast::NodeId) {\n+        run_lints!(self, check_fn, early_passes, fk, decl, span, id);\n+        ast_visit::walk_fn(self, fk, decl, span);\n+        run_lints!(self, check_fn_post, early_passes, fk, decl, span, id);\n     }\n \n     fn visit_variant_data(&mut self,\n@@ -1065,8 +1117,8 @@ impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n     fn visit_id(&mut self, id: ast::NodeId) {\n         if let Some(lints) = self.cx.sess().lints.borrow_mut().remove(&id) {\n             debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);\n-            for (lint_id, span, msg) in lints {\n-                self.cx.span_lint(lint_id.lint, span, &msg[..])\n+            for early_lint in lints {\n+                self.cx.early_lint(early_lint);\n             }\n         }\n     }\n@@ -1211,10 +1263,10 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n     for (id, v) in tcx.sess.lints.borrow().iter() {\n-        for &(lint, span, ref msg) in v {\n-            span_bug!(span,\n-                      \"unprocessed lint {} at {}: {}\",\n-                      lint.to_string(), tcx.map.node_to_string(*id), *msg)\n+        for early_lint in v {\n+            span_bug!(early_lint.diagnostic.span.clone(),\n+                      \"unprocessed lint {:?} at {}\",\n+                      early_lint, tcx.map.node_to_string(*id));\n         }\n     }\n \n@@ -1229,8 +1281,8 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     cx.with_lint_attrs(&krate.attrs, |cx| {\n         // Lints may be assigned to the whole crate.\n         if let Some(lints) = cx.sess.lints.borrow_mut().remove(&ast::CRATE_NODE_ID) {\n-            for (lint_id, span, msg) in lints {\n-                cx.span_lint(lint_id.lint, span, &msg[..])\n+            for early_lint in lints {\n+                cx.early_lint(early_lint);\n             }\n         }\n \n@@ -1249,8 +1301,8 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n     for (_, v) in sess.lints.borrow().iter() {\n-        for &(lint, span, ref msg) in v {\n-            span_bug!(span, \"unprocessed lint {}: {}\", lint.to_string(), *msg)\n+        for early_lint in v {\n+            span_bug!(early_lint.diagnostic.span.clone(), \"unprocessed lint {:?}\", early_lint);\n         }\n     }\n }"}, {"sha": "6f7102229f8d6150ecef22853b687cfe78b26216", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -41,7 +41,7 @@ use hir;\n \n pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n                         raw_emit_lint, check_crate, check_ast_crate, gather_attrs,\n-                        raw_struct_lint, FutureIncompatibleInfo};\n+                        raw_struct_lint, FutureIncompatibleInfo, EarlyLint, IntoEarlyLint};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]\n@@ -151,9 +151,9 @@ pub trait LateLintPass: LintPass {\n     fn check_ty(&mut self, _: &LateContext, _: &hir::Ty) { }\n     fn check_generics(&mut self, _: &LateContext, _: &hir::Generics) { }\n     fn check_fn(&mut self, _: &LateContext,\n-        _: FnKind, _: &hir::FnDecl, _: &hir::Block, _: Span, _: ast::NodeId) { }\n+        _: FnKind, _: &hir::FnDecl, _: &hir::Expr, _: Span, _: ast::NodeId) { }\n     fn check_fn_post(&mut self, _: &LateContext,\n-        _: FnKind, _: &hir::FnDecl, _: &hir::Block, _: Span, _: ast::NodeId) { }\n+        _: FnKind, _: &hir::FnDecl, _: &hir::Expr, _: Span, _: ast::NodeId) { }\n     fn check_trait_item(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n     fn check_trait_item_post(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n     fn check_impl_item(&mut self, _: &LateContext, _: &hir::ImplItem) { }\n@@ -200,9 +200,9 @@ pub trait EarlyLintPass: LintPass {\n     fn check_ty(&mut self, _: &EarlyContext, _: &ast::Ty) { }\n     fn check_generics(&mut self, _: &EarlyContext, _: &ast::Generics) { }\n     fn check_fn(&mut self, _: &EarlyContext,\n-        _: ast_visit::FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n+        _: ast_visit::FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) { }\n     fn check_fn_post(&mut self, _: &EarlyContext,\n-        _: ast_visit::FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n+        _: ast_visit::FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) { }\n     fn check_trait_item(&mut self, _: &EarlyContext, _: &ast::TraitItem) { }\n     fn check_trait_item_post(&mut self, _: &EarlyContext, _: &ast::TraitItem) { }\n     fn check_impl_item(&mut self, _: &EarlyContext, _: &ast::ImplItem) { }"}, {"sha": "3583ccdb97bad097da77239959c45cf1477d9872", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -34,6 +34,7 @@ use session::Session;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n@@ -61,7 +62,18 @@ pub struct LinkMeta {\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n-    pub cnum: CrateNum,\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n+pub enum DepKind {\n+    /// A dependency that is only used for its macros.\n+    MacrosOnly,\n+    /// A dependency that is always injected into the dependency list and so\n+    /// doesn't need to be linked to an rlib, e.g. the injected allocator.\n+    Implicit,\n+    /// A dependency that is required by an rlib version of this crate.\n+    /// Ordinary `extern crate`s result in `Explicit` dependencies.\n+    Explicit,\n }\n \n #[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable)]\n@@ -95,6 +107,11 @@ pub enum InlinedItemRef<'a> {\n     ImplItem(DefId, &'a hir::ImplItem)\n }\n \n+pub enum LoadedMacro {\n+    MacroRules(ast::MacroDef),\n+    ProcMacro(Rc<SyntaxExtension>),\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct ExternCrate {\n     /// def_id of an `extern crate` in the current crate that caused\n@@ -147,7 +164,7 @@ pub trait CrateStore<'tcx> {\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>;\n+    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>;\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>;\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n@@ -157,8 +174,8 @@ pub trait CrateStore<'tcx> {\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId>;\n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>>;\n+    fn associated_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> Option<ty::AssociatedItem>;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n@@ -170,10 +187,10 @@ pub trait CrateStore<'tcx> {\n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n                                     -> Vec<(CrateNum, LinkagePreference)>;\n+    fn dep_kind(&self, cnum: CrateNum) -> DepKind;\n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>;\n     fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>;\n     fn is_staged_api(&self, cnum: CrateNum) -> bool;\n-    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool;\n     fn is_allocator(&self, cnum: CrateNum) -> bool;\n     fn is_panic_runtime(&self, cnum: CrateNum) -> bool;\n     fn is_compiler_builtins(&self, cnum: CrateNum) -> bool;\n@@ -200,6 +217,7 @@ pub trait CrateStore<'tcx> {\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<def::Export>;\n+    fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -311,8 +329,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     }\n \n     // impl info\n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>\n-        { bug!(\"impl_or_trait_items\") }\n+    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>\n+        { bug!(\"associated_items\") }\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity { bug!(\"impl_polarity\") }\n@@ -323,8 +341,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId> { bug!(\"trait_of_item\") }\n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>> { bug!(\"impl_or_trait_item\") }\n+    fn associated_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> Option<ty::AssociatedItem> { bug!(\"associated_item\") }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n@@ -342,7 +360,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>\n         { bug!(\"missing_lang_items\") }\n     fn is_staged_api(&self, cnum: CrateNum) -> bool { bug!(\"is_staged_api\") }\n-    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n+    fn dep_kind(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n     fn is_allocator(&self, cnum: CrateNum) -> bool { bug!(\"is_allocator\") }\n     fn is_panic_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n     fn is_compiler_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n@@ -371,6 +389,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n     fn item_children(&self, did: DefId) -> Vec<def::Export> { bug!(\"item_children\") }\n+    fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -410,22 +429,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n-pub enum LoadedMacros {\n-    MacroRules(Vec<ast::MacroDef>),\n-    ProcMacros(Vec<(ast::Name, SyntaxExtension)>),\n-}\n-\n-impl LoadedMacros {\n-    pub fn is_proc_macros(&self) -> bool {\n-        match *self {\n-            LoadedMacros::ProcMacros(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n pub trait CrateLoader {\n-    fn process_item(&mut self, item: &ast::Item, defs: &Definitions, load_macros: bool)\n-                    -> Option<LoadedMacros>;\n+    fn process_item(&mut self, item: &ast::Item, defs: &Definitions);\n     fn postprocess(&mut self, krate: &ast::Crate);\n }"}, {"sha": "1ec3d0db8e0aa3a4a57efcc6371a48a70d1c4b75", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n //                                ^^^^^^^^^^^^^ only needed for pretty printing\n-    pub fn propagate(&mut self, cfg: &cfg::CFG, blk: &hir::Block) {\n+    pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Expr) {\n         //! Performs the data flow analysis.\n \n         if self.bits_per_id == 0 {\n@@ -524,17 +524,17 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n         debug!(\"{}\", {\n             let mut v = Vec::new();\n-            self.pretty_print_to(box &mut v, blk).unwrap();\n+            self.pretty_print_to(box &mut v, body).unwrap();\n             String::from_utf8(v).unwrap()\n         });\n     }\n \n     fn pretty_print_to<'b>(&self, wr: Box<io::Write + 'b>,\n-                           blk: &hir::Block) -> io::Result<()> {\n+                           body: &hir::Expr) -> io::Result<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self, None);\n         ps.cbox(pprust::indent_unit)?;\n         ps.ibox(0)?;\n-        ps.print_block(blk)?;\n+        ps.print_expr(body)?;\n         pp::eof(&mut ps.s)\n     }\n }"}, {"sha": "23fc5911259dc920685fa5b65364afe2d62678ef", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -22,7 +22,7 @@ use ty::{self, TyCtxt};\n use hir::def::Def;\n use hir::def_id::{DefId};\n use lint;\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n \n use syntax::{ast, codemap};\n use syntax::attr;\n@@ -48,7 +48,7 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: Box<FnvHashSet<ast::NodeId>>,\n+    live_symbols: Box<FxHashSet<ast::NodeId>>,\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n     inherited_pub_visibility: bool,\n@@ -61,7 +61,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             tcx: tcx,\n-            live_symbols: box FnvHashSet(),\n+            live_symbols: box FxHashSet(),\n             struct_has_extern_repr: false,\n             ignore_non_const_paths: false,\n             inherited_pub_visibility: false,\n@@ -92,7 +92,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         match def {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n             if self.tcx.trait_of_item(def.def_id()).is_some() => {\n-                if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n+                if let Some(substs) = self.tcx.tables().item_substs.get(&id) {\n                     if let ty::TyAdt(tyid, _) = substs.substs.type_at(0).sty {\n                         self.check_def_id(tyid.did);\n                     }\n@@ -123,12 +123,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n         let method_call = ty::MethodCall::expr(id);\n-        let method = self.tcx.tables.borrow().method_map[&method_call];\n+        let method = self.tcx.tables().method_map[&method_call];\n         self.check_def_id(method.def_id);\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n+        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().field_named(name).did);\n             }\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n+        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().fields[idx].did);\n             }\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n-        let variant = match self.tcx.node_id_to_type(lhs.id).sty {\n+        let variant = match self.tcx.tables().node_id_to_type(lhs.id).sty {\n             ty::TyAdt(adt, _) => {\n                 adt.variant_of_def(self.tcx.expect_def(lhs.id))\n             }\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn mark_live_symbols(&mut self) {\n-        let mut scanned = FnvHashSet();\n+        let mut scanned = FxHashSet();\n         while !self.worklist.is_empty() {\n             let id = self.worklist.pop().unwrap();\n             if scanned.contains(&id) {\n@@ -396,7 +396,7 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n-                       -> Box<FnvHashSet<ast::NodeId>> {\n+                       -> Box<FxHashSet<ast::NodeId>> {\n     let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n     symbol_visitor.mark_live_symbols();\n@@ -414,7 +414,7 @@ fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n \n struct DeadVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: Box<FnvHashSet<ast::NodeId>>,\n+    live_symbols: Box<FxHashSet<ast::NodeId>>,\n }\n \n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n@@ -433,7 +433,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.node_id_to_type(field.id);\n+        let field_type = self.tcx.tables().node_id_to_type(field.id);\n         let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n             _ => false\n@@ -471,11 +471,10 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n         if let Some(impl_list) =\n                 self.tcx.inherent_impls.borrow().get(&self.tcx.map.local_def_id(id)) {\n-            for impl_did in impl_list.iter() {\n-                for &item_did in &impl_items[impl_did][..] {\n+            for &impl_did in impl_list.iter() {\n+                for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n                     if let Some(item_node_id) = self.tcx.map.as_local_node_id(item_did) {\n                         if self.live_symbols.contains(&item_node_id) {\n                             return true;\n@@ -567,7 +566,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"method\");\n                 }\n-                intravisit::walk_block(self, body)\n+                intravisit::walk_expr(self, body)\n             }\n             hir::ImplItemKind::Type(..) => {}\n         }\n@@ -576,11 +575,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     // Overwrite so that we don't warn the trait item itself.\n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         match trait_item.node {\n-            hir::ConstTraitItem(_, Some(ref expr)) => {\n-                intravisit::walk_expr(self, expr)\n-            }\n+            hir::ConstTraitItem(_, Some(ref body))|\n             hir::MethodTraitItem(_, Some(ref body)) => {\n-                intravisit::walk_block(self, body)\n+                intravisit::walk_expr(self, body)\n             }\n             hir::ConstTraitItem(_, None) |\n             hir::MethodTraitItem(_, None) |"}, {"sha": "92d1ab85c5a05afcf806eb14e7330c9d595b22a1", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -65,8 +65,9 @@ use hir::def_id::CrateNum;\n \n use session;\n use session::config;\n+use middle::cstore::DepKind;\n use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use rustc_back::PanicStrategy;\n \n /// A list of dependencies for a certain crate type.\n@@ -80,7 +81,7 @@ pub type DependencyList = Vec<Linkage>;\n /// A mapping of all required dependencies for a particular flavor of output.\n ///\n /// This is local to the tcx, and is generally relevant to one session.\n-pub type Dependencies = FnvHashMap<config::CrateType, DependencyList>;\n+pub type Dependencies = FxHashMap<config::CrateType, DependencyList>;\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum Linkage {\n@@ -123,6 +124,7 @@ fn calculate_type(sess: &session::Session,\n                 return v;\n             }\n             for cnum in sess.cstore.crates() {\n+                if sess.cstore.dep_kind(cnum) == DepKind::MacrosOnly { continue }\n                 let src = sess.cstore.used_crate_source(cnum);\n                 if src.rlib.is_some() { continue }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n@@ -149,12 +151,13 @@ fn calculate_type(sess: &session::Session,\n         config::CrateTypeProcMacro => {},\n     }\n \n-    let mut formats = FnvHashMap();\n+    let mut formats = FxHashMap();\n \n     // Sweep all crates for found dylibs. Add all dylibs, as well as their\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n     // dependency to be relied upon twice is for both cases to rely on a dylib.\n     for cnum in sess.cstore.crates() {\n+        if sess.cstore.dep_kind(cnum) == DepKind::MacrosOnly { continue }\n         let name = sess.cstore.crate_name(cnum);\n         let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_some() {\n@@ -188,7 +191,7 @@ fn calculate_type(sess: &session::Session,\n         let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_none() &&\n            !formats.contains_key(&cnum) &&\n-           sess.cstore.is_explicitly_linked(cnum) {\n+           sess.cstore.dep_kind(cnum) == DepKind::Explicit {\n             assert!(src.rlib.is_some());\n             info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n             add_library(sess, cnum, RequireStatic, &mut formats);\n@@ -240,7 +243,7 @@ fn calculate_type(sess: &session::Session,\n fn add_library(sess: &session::Session,\n                cnum: CrateNum,\n                link: LinkagePreference,\n-               m: &mut FnvHashMap<CrateNum, LinkagePreference>) {\n+               m: &mut FxHashMap<CrateNum, LinkagePreference>) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library\n@@ -272,7 +275,7 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n     // everything in explicitly so long as it's actually required.\n     let last_crate = sess.cstore.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        if sess.cstore.is_explicitly_linked(CrateNum::new(cnum)) {\n+        if sess.cstore.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n             Linkage::Static\n         } else {\n             Linkage::NotLinked"}, {"sha": "5634e2012c971209c9d0afbce238f3ddcb6cfaa3", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self, fn_kind: FnKind<'v>, fn_decl: &'v hir::FnDecl,\n-                block: &'v hir::Block, span: Span, id: ast::NodeId) {\n+                block: &'v hir::Expr, span: Span, id: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             FnKind::ItemFn(_, _, unsafety, ..) =>\n@@ -159,7 +159,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.tables.borrow().method_map[&method_call].ty;\n+                let base_type = self.tcx.tables().method_map[&method_call].ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n@@ -168,15 +168,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprCall(ref base, _) => {\n-                let base_type = self.tcx.expr_ty_adjusted(base);\n+                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             hir::ExprUnary(hir::UnDeref, ref base) => {\n-                let base_type = self.tcx.expr_ty_adjusted(base);\n+                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n                 debug!(\"effect: unary case, base type is {:?}\",\n                         base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n@@ -200,7 +200,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprField(ref base_expr, field) => {\n-                if let ty::TyAdt(adt, ..) = self.tcx.expr_ty_adjusted(base_expr).sty {\n+                if let ty::TyAdt(adt, ..) = self.tcx.tables().expr_ty_adjusted(base_expr).sty {\n                     if adt.is_union() {\n                         self.require_unsafe(field.span, \"access to union field\");\n                     }\n@@ -214,7 +214,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &hir::Pat) {\n         if let PatKind::Struct(_, ref fields, _) = pat.node {\n-            if let ty::TyAdt(adt, ..) = self.tcx.pat_ty(pat).sty {\n+            if let ty::TyAdt(adt, ..) = self.tcx.tables().pat_ty(pat).sty {\n                 if adt.is_union() {\n                     for field in fields {\n                         self.require_unsafe(field.span, \"matching on union field\");"}, {"sha": "231da576f2b99d8f821a1d2aeed6480fac018a05", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -227,8 +227,8 @@ impl OverloadedCallType {\n     }\n \n     fn from_method_id(tcx: TyCtxt, method_id: DefId) -> OverloadedCallType {\n-        let method = tcx.impl_or_trait_item(method_id);\n-        OverloadedCallType::from_trait_id(tcx, method.container().id())\n+        let method = tcx.associated_item(method_id);\n+        OverloadedCallType::from_trait_id(tcx, method.container.id())\n     }\n }\n \n@@ -290,14 +290,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     pub fn walk_fn(&mut self,\n                    decl: &hir::FnDecl,\n-                   body: &hir::Block) {\n+                   body: &hir::Expr) {\n         self.walk_arg_patterns(decl, body);\n-        self.walk_block(body);\n+        self.consume_expr(body);\n     }\n \n     fn walk_arg_patterns(&mut self,\n                          decl: &hir::FnDecl,\n-                         body: &hir::Block) {\n+                         body: &hir::Expr) {\n         for arg in &decl.inputs {\n             let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n \n@@ -720,20 +720,33 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n         let adj = infcx.adjustments().get(&expr.id).map(|x| x.clone());\n         if let Some(adjustment) = adj {\n-            match adjustment {\n-                adjustment::AdjustNeverToAny(..) |\n-                adjustment::AdjustReifyFnPointer |\n-                adjustment::AdjustUnsafeFnPointer |\n-                adjustment::AdjustMutToConstPointer => {\n+            match adjustment.kind {\n+                adjustment::Adjust::NeverToAny |\n+                adjustment::Adjust::ReifyFnPointer |\n+                adjustment::Adjust::UnsafeFnPointer |\n+                adjustment::Adjust::MutToConstPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n                     debug!(\"walk_adjustment: trivial adjustment\");\n                     let cmt_unadjusted =\n                         return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                     self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 }\n-                adjustment::AdjustDerefRef(ref adj) => {\n-                    self.walk_autoderefref(expr, adj);\n+                adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n+                    debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n+\n+                    self.walk_autoderefs(expr, autoderefs);\n+\n+                    let cmt_derefd =\n+                        return_if_err!(self.mc.cat_expr_autoderefd(expr, autoderefs));\n+\n+                    let cmt_refd =\n+                        self.walk_autoref(expr, cmt_derefd, autoref);\n+\n+                    if unsize {\n+                        // Unsizing consumes the thin pointer and produces a fat one.\n+                        self.delegate_consume(expr.id, expr.span, cmt_refd);\n+                    }\n                 }\n             }\n         }\n@@ -770,28 +783,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn walk_autoderefref(&mut self,\n-                         expr: &hir::Expr,\n-                         adj: &adjustment::AutoDerefRef<'tcx>) {\n-        debug!(\"walk_autoderefref expr={:?} adj={:?}\",\n-               expr,\n-               adj);\n-\n-        self.walk_autoderefs(expr, adj.autoderefs);\n-\n-        let cmt_derefd =\n-            return_if_err!(self.mc.cat_expr_autoderefd(expr, adj.autoderefs));\n-\n-        let cmt_refd =\n-            self.walk_autoref(expr, cmt_derefd, adj.autoref);\n-\n-        if adj.unsize.is_some() {\n-            // Unsizing consumes the thin pointer and produces a fat one.\n-            self.delegate_consume(expr.id, expr.span, cmt_refd);\n-        }\n-    }\n-\n-\n     /// Walks the autoref `opt_autoref` applied to the autoderef'd\n     /// `expr`. `cmt_derefd` is the mem-categorized form of `expr`\n     /// after all relevant autoderefs have occurred. Because AutoRefs\n@@ -803,7 +794,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n                     cmt_base: mc::cmt<'tcx>,\n-                    opt_autoref: Option<adjustment::AutoRef<'tcx>>)\n+                    opt_autoref: Option<adjustment::AutoBorrow<'tcx>>)\n                     -> mc::cmt<'tcx>\n     {\n         debug!(\"walk_autoref(expr.id={} cmt_derefd={:?} opt_autoref={:?})\",\n@@ -822,7 +813,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         };\n \n         match *autoref {\n-            adjustment::AutoPtr(r, m) => {\n+            adjustment::AutoBorrow::Ref(r, m) => {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n                                      cmt_base,\n@@ -831,7 +822,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                      AutoRef);\n             }\n \n-            adjustment::AutoUnsafe(m) => {\n+            adjustment::AutoBorrow::RawPtr(m) => {\n                 debug!(\"walk_autoref: expr.id={} cmt_base={:?}\",\n                        expr.id,\n                        cmt_base);"}, {"sha": "7dbf9aa74144d4a4254aba531afbde1ca8ab4cb1", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, id: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"intrinsicck: closure outside of function\")\n         }\n@@ -163,7 +163,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n         if let hir::ExprPath(..) = expr.node {\n             match self.infcx.tcx.expect_def(expr.id) {\n                 Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                    let typ = self.infcx.tcx.node_id_to_type(expr.id);\n+                    let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n                     match typ.sty {\n                         ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             let from = bare_fn_ty.sig.0.inputs[0];"}, {"sha": "3e7de79246b667b59b41ac7a0f3fdbd9d573757f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -27,7 +27,7 @@ use session::Session;\n use hir::def_id::DefId;\n use ty;\n use middle::weak_lang_items;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -146,7 +146,7 @@ struct LanguageItemCollector<'a, 'tcx: 'a> {\n \n     session: &'a Session,\n \n-    item_refs: FnvHashMap<&'static str, usize>,\n+    item_refs: FxHashMap<&'static str, usize>,\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n@@ -169,7 +169,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     pub fn new(session: &'a Session, ast_map: &'a hir_map::Map<'tcx>)\n                -> LanguageItemCollector<'a, 'tcx> {\n-        let mut item_refs = FnvHashMap();\n+        let mut item_refs = FxHashMap();\n \n         $( item_refs.insert($name, $variant as usize); )*\n "}, {"sha": "a654d65bc67961af65392e9a8abf56b26f921555", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 28, "deletions": 77, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -123,10 +123,9 @@ use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n-use syntax::codemap::original_sp;\n use syntax::parse::token::keywords;\n use syntax::ptr::P;\n-use syntax_pos::{BytePos, Span};\n+use syntax_pos::Span;\n \n use hir::Expr;\n use hir;\n@@ -187,7 +186,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt) -> String {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, id: NodeId) {\n+                b: &'v hir::Expr, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n     fn visit_local(&mut self, l: &hir::Local) { visit_local(self, l); }\n@@ -352,9 +351,9 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, n: NodeId) {\n-        check_fn(self, fk, fd, b, s, n);\n+    fn visit_fn(&mut self, _: FnKind<'v>, _: &'v hir::FnDecl,\n+                _: &'v hir::Expr, _: Span, _: NodeId) {\n+        // do not check contents of nested fns\n     }\n     fn visit_local(&mut self, l: &hir::Local) {\n         check_local(self, l);\n@@ -370,7 +369,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n fn visit_fn(ir: &mut IrMaps,\n             fk: FnKind,\n             decl: &hir::FnDecl,\n-            body: &hir::Block,\n+            body: &hir::Expr,\n             sp: Span,\n             id: ast::NodeId) {\n     debug!(\"visit_fn\");\n@@ -405,10 +404,10 @@ fn visit_fn(ir: &mut IrMaps,\n \n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, specials);\n-    let entry_ln = lsets.compute(decl, body);\n+    let entry_ln = lsets.compute(body);\n \n     // check for various error conditions\n-    lsets.visit_block(body);\n+    lsets.visit_expr(body);\n     lsets.check_ret(id, sp, fk, entry_ln, body);\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n@@ -821,17 +820,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     // _______________________________________________________________________\n \n-    fn compute(&mut self, decl: &hir::FnDecl, body: &hir::Block) -> LiveNode {\n+    fn compute(&mut self, body: &hir::Expr) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for block, {}\", block_to_string(body));\n+        debug!(\"compute: using id for body, {}\", expr_to_string(body));\n \n         let exit_ln = self.s.exit_ln;\n-        let entry_ln: LiveNode =\n-            self.with_loop_nodes(body.id, exit_ln, exit_ln,\n-              |this| this.propagate_through_fn_block(decl, body));\n+        let entry_ln: LiveNode = self.with_loop_nodes(body.id, exit_ln, exit_ln, |this| {\n+            // the fallthrough exit is only for those cases where we do not\n+            // explicitly return:\n+            let s = this.s;\n+            this.init_from_succ(s.fallthrough_ln, s.exit_ln);\n+            this.acc(s.fallthrough_ln, s.clean_exit_var, ACC_READ);\n+\n+            this.propagate_through_expr(body, s.fallthrough_ln)\n+        });\n \n         // hack to skip the loop unless debug! is enabled:\n         debug!(\"^^ liveness computation results for body {} (entry={:?})\",\n@@ -846,20 +851,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(&mut self, _: &hir::FnDecl, blk: &hir::Block)\n-                                  -> LiveNode {\n-        // the fallthrough exit is only for those cases where we do not\n-        // explicitly return:\n-        let s = self.s;\n-        self.init_from_succ(s.fallthrough_ln, s.exit_ln);\n-        if blk.expr.is_none() {\n-            self.acc(s.fallthrough_ln, s.no_ret_var, ACC_READ)\n-        }\n-        self.acc(s.fallthrough_ln, s.clean_exit_var, ACC_READ);\n-\n-        self.propagate_through_block(blk, s.fallthrough_ln)\n-    }\n-\n     fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode)\n                                -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n@@ -1081,7 +1072,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAssignOp(_, ref l, ref r) => {\n             // an overloaded assign op is like a method call\n-            if self.ir.tcx.is_method_call(expr.id) {\n+            if self.ir.tcx.tables().is_method_call(expr.id) {\n                 let succ = self.propagate_through_expr(&l, succ);\n                 self.propagate_through_expr(&r, succ)\n             } else {\n@@ -1113,8 +1104,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprCall(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n-                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().0.is_never();\n+            let diverges = !self.ir.tcx.tables().is_method_call(expr.id) &&\n+                self.ir.tcx.tables().expr_ty_adjusted(&f).fn_ret().0.is_never();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1126,7 +1117,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprMethodCall(.., ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.tables.borrow().method_map[&method_call].ty;\n+            let method_ty = self.ir.tcx.tables().method_map[&method_call].ty;\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let succ = if method_ty.fn_ret().0.is_never() {\n                 self.s.exit_ln\n@@ -1409,7 +1400,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n-        if !this.ir.tcx.is_method_call(expr.id) {\n+        if !this.ir.tcx.tables().is_method_call(expr.id) {\n             this.check_lvalue(&l);\n         }\n \n@@ -1448,18 +1439,9 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n     }\n }\n \n-fn check_fn(_v: &Liveness,\n-            _fk: FnKind,\n-            _decl: &hir::FnDecl,\n-            _body: &hir::Block,\n-            _sp: Span,\n-            _id: NodeId) {\n-    // do not check contents of nested fns\n-}\n-\n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::Binder<Ty<'tcx>> {\n-        let fn_ty = self.ir.tcx.node_id_to_type(id);\n+        let fn_ty = self.ir.tcx.tables().node_id_to_type(id);\n         match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n@@ -1472,7 +1454,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  sp: Span,\n                  _fk: FnKind,\n                  entry_ln: LiveNode,\n-                 body: &hir::Block)\n+                 body: &hir::Expr)\n     {\n         // within the fn body, late-bound regions are liberated\n         // and must outlive the *call-site* of the function.\n@@ -1481,13 +1463,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 self.ir.tcx.region_maps.call_site_extent(id, body.id),\n                 &self.fn_ret(id));\n \n-        if fn_ret.is_never() {\n-            // FIXME(durka) this rejects code like `fn foo(x: !) -> ! { x }`\n-            if self.live_on_entry(entry_ln, self.s.clean_exit_var).is_some() {\n-                span_err!(self.ir.tcx.sess, sp, E0270,\n-                          \"computation may converge in a function marked as diverging\");\n-            }\n-        } else if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n+        if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n             let t_ret_subst = fn_ret.subst(self.ir.tcx, &param_env.free_substs);\n             let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n@@ -1498,32 +1474,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             // for nil return types, it is ok to not return a value expl.\n             if !is_nil {\n-                let ends_with_stmt = match body.expr {\n-                    None if !body.stmts.is_empty() =>\n-                        match body.stmts.last().unwrap().node {\n-                            hir::StmtSemi(ref e, _) => {\n-                                self.ir.tcx.expr_ty(&e) == fn_ret\n-                            },\n-                            _ => false\n-                        },\n-                    _ => false\n-                };\n-                let mut err = struct_span_err!(self.ir.tcx.sess,\n-                                               sp,\n-                                               E0269,\n-                                               \"not all control paths return a value\");\n-                if ends_with_stmt {\n-                    let last_stmt = body.stmts.last().unwrap();\n-                    let original_span = original_sp(self.ir.tcx.sess.codemap(),\n-                                                    last_stmt.span, sp);\n-                    let span_semicolon = Span {\n-                        lo: original_span.hi - BytePos(1),\n-                        hi: original_span.hi,\n-                        expn_id: original_span.expn_id\n-                    };\n-                    err.span_help(span_semicolon, \"consider removing this semicolon:\");\n-                }\n-                err.emit();\n+                span_bug!(sp, \"not all control paths return a value\");\n             }\n         }\n     }"}, {"sha": "e3ed13e1e40173501cab2d79040731b8d07b67e0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -354,11 +354,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        let unadjusted_ty = self.expr_ty(expr)?;\n-        Ok(unadjusted_ty.adjust(\n-            self.tcx(), expr.span, expr.id,\n-            self.infcx.adjustments().get(&expr.id),\n-            |method_call| self.infcx.node_method_ty(method_call)))\n+        self.infcx.expr_ty_adjusted(expr)\n     }\n \n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n@@ -396,19 +392,21 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n \n             Some(adjustment) => {\n-                match *adjustment {\n-                    adjustment::AdjustDerefRef(\n-                        adjustment::AutoDerefRef {\n-                            autoref: None, unsize: None, autoderefs, ..}) => {\n+                match adjustment.kind {\n+                    adjustment::Adjust::DerefRef {\n+                        autoderefs,\n+                        autoref: None,\n+                        unsize: false\n+                    } => {\n                         // Equivalent to *expr or something similar.\n                         self.cat_expr_autoderefd(expr, autoderefs)\n                     }\n \n-                    adjustment::AdjustNeverToAny(..) |\n-                    adjustment::AdjustReifyFnPointer |\n-                    adjustment::AdjustUnsafeFnPointer |\n-                    adjustment::AdjustMutToConstPointer |\n-                    adjustment::AdjustDerefRef(_) => {\n+                    adjustment::Adjust::NeverToAny |\n+                    adjustment::Adjust::ReifyFnPointer |\n+                    adjustment::Adjust::UnsafeFnPointer |\n+                    adjustment::Adjust::MutToConstPointer |\n+                    adjustment::Adjust::DerefRef {..} => {\n                         debug!(\"cat_expr({:?}): {:?}\",\n                                adjustment,\n                                expr);"}, {"sha": "1376886968f74a4b9535569bbe8133f774a32e5d", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -12,7 +12,7 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n-use util::nodemap::{DefIdSet, FnvHashMap};\n+use util::nodemap::{DefIdSet, FxHashMap};\n \n use std::hash::Hash;\n use std::fmt;\n@@ -35,7 +35,7 @@ pub enum AccessLevel {\n // Accessibility levels for reachable HIR nodes\n #[derive(Clone)]\n pub struct AccessLevels<Id = NodeId> {\n-    pub map: FnvHashMap<Id, AccessLevel>\n+    pub map: FxHashMap<Id, AccessLevel>\n }\n \n impl<Id: Hash + Eq> AccessLevels<Id> {"}, {"sha": "7868e700f2701c0c03cb1e2ed6005d83aa4dba12", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -22,7 +22,7 @@ use hir::def_id::DefId;\n use ty::{self, TyCtxt};\n use middle::privacy;\n use session::config;\n-use util::nodemap::{NodeSet, FnvHashSet};\n+use util::nodemap::{NodeSet, FxHashSet};\n \n use syntax::abi::Abi;\n use syntax::ast;\n@@ -116,7 +116,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                let def_id = self.tcx.tables().method_map[&method_call].def_id;\n \n                 // Mark the trait item (and, possibly, its default impl) as reachable\n                 // Or mark inherent impl item as reachable\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     fn propagate(&mut self) {\n-        let mut scanned = FnvHashSet();\n+        let mut scanned = FxHashSet();\n         loop {\n             let search_item = match self.worklist.pop() {\n                 Some(item) => item,\n@@ -248,9 +248,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemFn(.., ref search_block) => {\n+                    hir::ItemFn(.., ref body) => {\n                         if item_might_be_inlined(&item) {\n-                            intravisit::walk_block(self, &search_block)\n+                            self.visit_expr(body);\n                         }\n                     }\n \n@@ -278,11 +278,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    hir::ConstTraitItem(_, Some(ref expr)) => {\n-                        self.visit_expr(&expr);\n-                    }\n+                    hir::ConstTraitItem(_, Some(ref body)) |\n                     hir::MethodTraitItem(_, Some(ref body)) => {\n-                        intravisit::walk_block(self, body);\n+                        self.visit_expr(body);\n                     }\n                     hir::TypeTraitItem(..) => {}\n                 }\n@@ -295,7 +293,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Method(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n-                            intravisit::walk_block(self, body)\n+                            self.visit_expr(body)\n                         }\n                     }\n                     hir::ImplItemKind::Type(_) => {}"}, {"sha": "34a6a547d9440fb84a391ff851152b6fb3602e61", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -19,7 +19,7 @@\n use dep_graph::DepNode;\n use hir::map as ast_map;\n use session::Session;\n-use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n+use util::nodemap::{FxHashMap, NodeMap, NodeSet};\n use ty;\n \n use std::cell::RefCell;\n@@ -251,7 +251,7 @@ impl CodeExtent {\n /// The region maps encode information about region relationships.\n pub struct RegionMaps {\n     code_extents: RefCell<Vec<CodeExtentData>>,\n-    code_extent_interner: RefCell<FnvHashMap<CodeExtentData, CodeExtent>>,\n+    code_extent_interner: RefCell<FxHashMap<CodeExtentData, CodeExtent>>,\n     /// `scope_map` maps from a scope id to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n@@ -490,12 +490,7 @@ impl RegionMaps {\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let expr_extent = self.node_extent(expr_id);\n-        // For some reason, the expr's scope itself is skipped here.\n-        let mut id = match scope_map[expr_extent.0 as usize].into_option() {\n-            Some(i) => i,\n-            _ => return None\n-        };\n+        let mut id = self.node_extent(expr_id);\n \n         while let Some(p) = scope_map[id.0 as usize].into_option() {\n             match code_extents[p.0 as usize] {\n@@ -1086,7 +1081,7 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &hir::Item) {\n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               kind: FnKind,\n               decl: &hir::FnDecl,\n-              body: &hir::Block,\n+              body: &hir::Expr,\n               sp: Span,\n               id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={:?}, \\\n@@ -1128,7 +1123,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n         parent: fn_decl_scope,\n         var_parent: fn_decl_scope\n     };\n-    visitor.visit_block(body);\n+    visitor.visit_expr(body);\n \n     // Restore context we had at the start.\n     visitor.cx = outer_cx;\n@@ -1191,7 +1186,7 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, n: NodeId) {\n+                b: &'v Expr, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n     }\n     fn visit_arm(&mut self, a: &Arm) {\n@@ -1217,7 +1212,7 @@ pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n \n     let maps = RegionMaps {\n         code_extents: RefCell::new(vec![]),\n-        code_extent_interner: RefCell::new(FnvHashMap()),\n+        code_extent_interner: RefCell::new(FxHashMap()),\n         scope_map: RefCell::new(vec![]),\n         var_map: RefCell::new(NodeMap()),\n         rvalue_scopes: RefCell::new(NodeMap()),"}, {"sha": "292d9592ceb0cf0bc60a978e49d95244397760f8", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -31,7 +31,7 @@ use syntax::parse::token::keywords;\n use syntax_pos::Span;\n use util::nodemap::NodeMap;\n \n-use rustc_data_structures::fnv::FnvHashSet;\n+use rustc_data_structures::fx::FxHashSet;\n use hir;\n use hir::print::lifetime_to_string;\n use hir::intravisit::{self, Visitor, FnKind};\n@@ -202,7 +202,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, fn_id: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n@@ -403,7 +403,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n+fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n         scope: Scope<'a>,\n@@ -415,7 +415,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n-    gather.visit_block(b);\n+    gather.visit_expr(b);\n     return;\n \n     impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n@@ -493,7 +493,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn add_scope_and_walk_fn<'b>(&mut self,\n                                  fk: FnKind,\n                                  fd: &hir::FnDecl,\n-                                 fb: &'b hir::Block,\n+                                 fb: &'b hir::Expr,\n                                  _span: Span,\n                                  fn_id: ast::NodeId) {\n \n@@ -516,7 +516,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         extract_labels(self, fb);\n \n         self.with(FnScope { fn_id: fn_id, body_id: fb.id, s: self.scope },\n-                  |_old_scope, this| this.visit_block(fb))\n+                  |_old_scope, this| this.visit_expr(fb))\n     }\n \n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n@@ -847,13 +847,13 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n                                generics: &hir::Generics) {\n     debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n \n-    let mut constrained_by_input = ConstrainedCollector { regions: FnvHashSet() };\n+    let mut constrained_by_input = ConstrainedCollector { regions: FxHashSet() };\n     for arg in &decl.inputs {\n         constrained_by_input.visit_ty(&arg.ty);\n     }\n \n     let mut appears_in_output = AllCollector {\n-        regions: FnvHashSet(),\n+        regions: FxHashSet(),\n         impl_trait: false\n     };\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n@@ -866,7 +866,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     // Subtle point: because we disallow nested bindings, we can just\n     // ignore binders here and scrape up all names we see.\n     let mut appears_in_where_clause = AllCollector {\n-        regions: FnvHashSet(),\n+        regions: FxHashSet(),\n         impl_trait: false\n     };\n     for ty_param in generics.ty_params.iter() {\n@@ -926,7 +926,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     return;\n \n     struct ConstrainedCollector {\n-        regions: FnvHashSet<ast::Name>,\n+        regions: FxHashSet<ast::Name>,\n     }\n \n     impl<'v> Visitor<'v> for ConstrainedCollector {\n@@ -961,7 +961,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     }\n \n     struct AllCollector {\n-        regions: FnvHashSet<ast::Name>,\n+        regions: FxHashSet<ast::Name>,\n         impl_trait: bool\n     }\n "}, {"sha": "d79833998d6c8ec442ae048f4dccb1bb2eef5b48", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -27,7 +27,7 @@ use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err, find_lang_feature_accepted_version};\n use syntax::attr::{self, Stability, Deprecation};\n-use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n+use util::nodemap::{DefIdMap, FxHashSet, FxHashMap};\n \n use hir;\n use hir::{Item, Generics, StructField, Variant, PatKind};\n@@ -102,7 +102,7 @@ pub struct Index<'tcx> {\n     depr_map: DefIdMap<Option<DeprecationEntry>>,\n \n     /// Maps for each crate whether it is part of the staged API.\n-    staged_api: FnvHashMap<CrateNum, bool>\n+    staged_api: FxHashMap<CrateNum, bool>\n }\n \n // A private tree-walker for producing an Index.\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> Index<'tcx> {\n             }\n         }\n \n-        let mut staged_api = FnvHashMap();\n+        let mut staged_api = FxHashMap();\n         staged_api.insert(LOCAL_CRATE, is_staged_api);\n         Index {\n             staged_api: staged_api,\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> Index<'tcx> {\n /// features and possibly prints errors. Returns a list of all\n /// features used.\n pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                          -> FnvHashMap<InternedString, attr::StabilityLevel> {\n+                                          -> FxHashMap<InternedString, attr::StabilityLevel> {\n     let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n     let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n@@ -367,7 +367,7 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     let mut checker = Checker {\n         tcx: tcx,\n         active_features: active_features,\n-        used_features: FnvHashMap(),\n+        used_features: FxHashMap(),\n         in_skip_block: 0,\n     };\n     intravisit::walk_crate(&mut checker, tcx.map.krate());\n@@ -377,8 +377,8 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n struct Checker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    active_features: FnvHashSet<InternedString>,\n-    used_features: FnvHashMap<InternedString, attr::StabilityLevel>,\n+    active_features: FxHashSet<InternedString>,\n+    used_features: FxHashMap<InternedString, attr::StabilityLevel>,\n     // Within a block where feature gate checking can be skipped.\n     in_skip_block: u32,\n }\n@@ -529,14 +529,11 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // items.\n         hir::ItemImpl(.., Some(ref t), _, ref impl_items) => {\n             let trait_did = tcx.expect_def(t.ref_id).def_id();\n-            let trait_items = tcx.trait_items(trait_did);\n-\n             for impl_item in impl_items {\n-                let item = trait_items.iter().find(|item| {\n-                    item.name() == impl_item.name\n-                }).unwrap();\n+                let item = tcx.associated_items(trait_did)\n+                    .find(|item| item.name == impl_item.name).unwrap();\n                 if warn_about_defns {\n-                    maybe_do_stability_check(tcx, item.def_id(), impl_item.span, cb);\n+                    maybe_do_stability_check(tcx, item.def_id, impl_item.span, cb);\n                 }\n             }\n         }\n@@ -555,11 +552,11 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         hir::ExprMethodCall(i, ..) => {\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n-            tcx.tables.borrow().method_map[&method_call].def_id\n+            tcx.tables().method_map[&method_call].def_id\n         }\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n-            match tcx.expr_ty_adjusted(base_e).sty {\n+            match tcx.tables().expr_ty_adjusted(base_e).sty {\n                 ty::TyAdt(def, _) => {\n                     def.struct_variant().field_named(field.node).did\n                 }\n@@ -569,7 +566,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         }\n         hir::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n-            match tcx.expr_ty_adjusted(base_e).sty {\n+            match tcx.tables().expr_ty_adjusted(base_e).sty {\n                 ty::TyAdt(def, _) => {\n                     def.struct_variant().fields[field.node].did\n                 }\n@@ -580,7 +577,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n             }\n         }\n         hir::ExprStruct(_, ref expr_fields, _) => {\n-            match tcx.expr_ty(e).sty {\n+            match tcx.tables().expr_ty(e).sty {\n                 ty::TyAdt(adt, ..) => match adt.adt_kind() {\n                     AdtKind::Struct | AdtKind::Union => {\n                         // check the stability of each field that appears\n@@ -637,7 +634,7 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    let v = match tcx.pat_ty_opt(pat).map(|ty| &ty.sty) {\n+    let v = match tcx.tables().pat_ty_opt(pat).map(|ty| &ty.sty) {\n         Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => adt.struct_variant(),\n         _ => return,\n     };\n@@ -685,15 +682,8 @@ fn is_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) -> bool {\n }\n \n fn is_staged_api<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> bool {\n-    match tcx.trait_item_of_item(id) {\n-        Some(trait_method_id) if trait_method_id != id => {\n-            is_staged_api(tcx, trait_method_id)\n-        }\n-        _ => {\n-            *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n-                || tcx.sess.cstore.is_staged_api(id.krate))\n-        }\n-    }\n+    *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n+        || tcx.sess.cstore.is_staged_api(id.krate))\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n@@ -746,10 +736,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n pub fn check_unused_or_stable_features(sess: &Session,\n-                                       lib_features_used: &FnvHashMap<InternedString,\n-                                                                      attr::StabilityLevel>) {\n+                                       lib_features_used: &FxHashMap<InternedString,\n+                                                                     attr::StabilityLevel>) {\n     let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n-    let mut remaining_lib_features: FnvHashMap<InternedString, Span>\n+    let mut remaining_lib_features: FxHashMap<InternedString, Span>\n         = declared_lib_features.clone().into_iter().collect();\n \n     fn format_stable_since_msg(version: &str) -> String {"}, {"sha": "b5da304a10986d353f3499d1648194a578f24cc9", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -157,14 +157,14 @@ macro_rules! make_mir_visitor {\n \n             fn visit_projection(&mut self,\n                                 lvalue: & $($mutability)* LvalueProjection<'tcx>,\n-                                context: LvalueContext,\n+                                context: LvalueContext<'tcx>,\n                                 location: Location) {\n                 self.super_projection(lvalue, context, location);\n             }\n \n             fn visit_projection_elem(&mut self,\n                                      lvalue: & $($mutability)* LvalueElem<'tcx>,\n-                                     context: LvalueContext,\n+                                     context: LvalueContext<'tcx>,\n                                      location: Location) {\n                 self.super_projection_elem(lvalue, context, location);\n             }\n@@ -579,7 +579,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_projection(&mut self,\n                                 proj: & $($mutability)* LvalueProjection<'tcx>,\n-                                context: LvalueContext,\n+                                context: LvalueContext<'tcx>,\n                                 location: Location) {\n                 let Projection {\n                     ref $($mutability)* base,\n@@ -596,7 +596,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_projection_elem(&mut self,\n                                      proj: & $($mutability)* LvalueElem<'tcx>,\n-                                     _context: LvalueContext,\n+                                     _context: LvalueContext<'tcx>,\n                                      location: Location) {\n                 match *proj {\n                     ProjectionElem::Deref => {\n@@ -739,7 +739,7 @@ macro_rules! make_mir_visitor {\n make_mir_visitor!(Visitor,);\n make_mir_visitor!(MutVisitor,mut);\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum LvalueContext<'tcx> {\n     // Appears as LHS of an assignment\n     Store,"}, {"sha": "16522a73f56a514fa2b551f47545edc00014753f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -793,7 +793,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n     remark: Passes = (SomePasses(Vec::new()), parse_passes, [UNTRACKED],\n         \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n     no_stack_check: bool = (false, parse_bool, [UNTRACKED],\n-        \"disable checks for stack exhaustion (a memory-safety hazard!)\"),\n+        \"the --no-stack-check flag is deprecated and does nothing\"),\n     debuginfo: Option<usize> = (None, parse_opt_uint, [TRACKED],\n         \"debug info emission level, 0 = no debug info, 1 = line tables only, \\\n          2 = full debug info with variable and type information\"),\n@@ -918,6 +918,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"the directory the MIR is dumped into\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n           \"print some performance-related statistics\"),\n+    hir_stats: bool = (false, parse_bool, [UNTRACKED],\n+          \"print some statistics about AST and HIR\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "724b32d2cd7150e5aa377555921f04dc034fccd7", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -17,7 +17,7 @@ use middle::dependency_format;\n use session::search_paths::PathKind;\n use session::config::DebugInfoLevel;\n use ty::tls;\n-use util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n use util::common::duration_to_secs_str;\n use mir::transform as mir_pass;\n \n@@ -74,11 +74,11 @@ pub struct Session {\n     pub local_crate_source_file: Option<PathBuf>,\n     pub working_dir: PathBuf,\n     pub lint_store: RefCell<lint::LintStore>,\n-    pub lints: RefCell<NodeMap<Vec<(lint::LintId, Span, String)>>>,\n+    pub lints: RefCell<NodeMap<Vec<lint::EarlyLint>>>,\n     /// Set of (LintId, span, message) tuples tracking lint (sub)diagnostics\n     /// that have been set once, but should not be set again, in order to avoid\n     /// redundantly verbose output (Issue #24690).\n-    pub one_time_diagnostics: RefCell<FnvHashSet<(lint::LintId, Span, String)>>,\n+    pub one_time_diagnostics: RefCell<FxHashSet<(lint::LintId, Span, String)>>,\n     pub plugin_llvm_passes: RefCell<Vec<String>>,\n     pub mir_passes: RefCell<mir_pass::Passes>,\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n@@ -262,17 +262,26 @@ impl Session {\n                     lint: &'static lint::Lint,\n                     id: ast::NodeId,\n                     sp: Span,\n-                    msg: String) {\n+                    msg: String)\n+    {\n+        self.add_lint_diagnostic(lint, id, (sp, &msg[..]))\n+    }\n+    pub fn add_lint_diagnostic<M>(&self,\n+                                  lint: &'static lint::Lint,\n+                                  id: ast::NodeId,\n+                                  msg: M)\n+        where M: lint::IntoEarlyLint,\n+    {\n         let lint_id = lint::LintId::of(lint);\n         let mut lints = self.lints.borrow_mut();\n+        let early_lint = msg.into_early_lint(lint_id);\n         if let Some(arr) = lints.get_mut(&id) {\n-            let tuple = (lint_id, sp, msg);\n-            if !arr.contains(&tuple) {\n-                arr.push(tuple);\n+            if !arr.contains(&early_lint) {\n+                arr.push(early_lint);\n             }\n             return;\n         }\n-        lints.insert(id, vec![(lint_id, sp, msg)]);\n+        lints.insert(id, vec![early_lint]);\n     }\n     pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n         let id = self.next_node_id.get();\n@@ -594,12 +603,12 @@ pub fn build_session_(sopts: config::Options,\n         working_dir: env::current_dir().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap()),\n-        one_time_diagnostics: RefCell::new(FnvHashSet()),\n+        one_time_diagnostics: RefCell::new(FxHashSet()),\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n         mir_passes: RefCell::new(mir_pass::Passes::new()),\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n-        dependency_formats: RefCell::new(FnvHashMap()),\n+        dependency_formats: RefCell::new(FxHashMap()),\n         crate_disambiguator: RefCell::new(token::intern(\"\").as_str()),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),"}, {"sha": "1ccd048cedcaa31458097b787b5e3445eb915481", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -14,7 +14,7 @@ use super::{SelectionContext, Obligation, ObligationCause};\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n-use infer::{InferCtxt, TypeOrigin};\n+use infer::{InferCtxt, InferOk, TypeOrigin};\n use syntax_pos::DUMMY_SP;\n \n #[derive(Copy, Clone)]\n@@ -55,11 +55,13 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n-    if let Err(_) = selcx.infcx().eq_impl_headers(true,\n-                                                  TypeOrigin::Misc(DUMMY_SP),\n-                                                  &a_impl_header,\n-                                                  &b_impl_header) {\n-        return None;\n+    match selcx.infcx().eq_impl_headers(true, TypeOrigin::Misc(DUMMY_SP), &a_impl_header,\n+                                                                          &b_impl_header) {\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty());\n+        }\n+        Err(_) => return None\n     }\n \n     debug!(\"overlap: unification check succeeded\");"}, {"sha": "7e70fdb92e68b6ce1d9a476819a91822eac3226e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 70, "deletions": 21, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -27,15 +27,17 @@ use super::{\n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n use infer::{self, InferCtxt, TypeOrigin};\n+use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::Subst;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n use std::cmp;\n use std::fmt;\n+use syntax::ast;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n@@ -250,7 +252,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     let generic_map = def.generics.types.iter().map(|param| {\n                         (param.name.as_str().to_string(),\n                          trait_ref.substs.type_for_def(param).to_string())\n-                    }).collect::<FnvHashMap<String, String>>();\n+                    }).collect::<FxHashMap<String, String>>();\n                     let parser = Parser::new(&istring);\n                     let mut errored = false;\n                     let err: String = parser.filter_map(|p| {\n@@ -417,19 +419,63 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.report_overflow_error(&cycle[0], false);\n     }\n \n+    pub fn report_extra_impl_obligation(&self,\n+                                        error_span: Span,\n+                                        item_name: ast::Name,\n+                                        _impl_item_def_id: DefId,\n+                                        trait_item_def_id: DefId,\n+                                        requirement: &fmt::Display,\n+                                        lint_id: Option<ast::NodeId>) // (*)\n+                                        -> DiagnosticBuilder<'tcx>\n+    {\n+        // (*) This parameter is temporary and used only for phasing\n+        // in the bug fix to #18937. If it is `Some`, it has a kind of\n+        // weird effect -- the diagnostic is reported as a lint, and\n+        // the builder which is returned is marked as canceled.\n+\n+        let mut err =\n+            struct_span_err!(self.tcx.sess,\n+                             error_span,\n+                             E0276,\n+                             \"impl has stricter requirements than trait\");\n+\n+        if let Some(trait_item_span) = self.tcx.map.span_if_local(trait_item_def_id) {\n+            err.span_label(trait_item_span,\n+                           &format!(\"definition of `{}` from trait\", item_name));\n+        }\n+\n+        err.span_label(\n+            error_span,\n+            &format!(\"impl has extra requirement {}\", requirement));\n+\n+        if let Some(node_id) = lint_id {\n+            self.tcx.sess.add_lint_diagnostic(EXTRA_REQUIREMENT_IN_IMPL,\n+                                              node_id,\n+                                              (*err).clone());\n+            err.cancel();\n+        }\n+\n+        err\n+    }\n+\n     pub fn report_selection_error(&self,\n                                   obligation: &PredicateObligation<'tcx>,\n                                   error: &SelectionError<'tcx>)\n     {\n         let span = obligation.cause.span;\n         let mut err = match *error {\n             SelectionError::Unimplemented => {\n-                if let ObligationCauseCode::CompareImplMethodObligation = obligation.cause.code {\n-                    span_err!(\n-                        self.tcx.sess, span, E0276,\n-                        \"the requirement `{}` appears on the impl \\\n-                         method but not on the corresponding trait method\",\n-                        obligation.predicate);\n+                if let ObligationCauseCode::CompareImplMethodObligation {\n+                    item_name, impl_item_def_id, trait_item_def_id, lint_id\n+                } = obligation.cause.code {\n+                    self.report_extra_impl_obligation(\n+                        span,\n+                        item_name,\n+                        impl_item_def_id,\n+                        trait_item_def_id,\n+                        &format!(\"`{}`\", obligation.predicate),\n+                        lint_id)\n+                        .emit();\n                     return;\n                 } else {\n                     match obligation.predicate {\n@@ -492,7 +538,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         ty::Predicate::RegionOutlives(ref predicate) => {\n                             let predicate = self.resolve_type_vars_if_possible(predicate);\n-                            let err = self.region_outlives_predicate(span,\n+                            let err = self.region_outlives_predicate(&obligation.cause,\n                                                                      &predicate).err().unwrap();\n                             struct_span_err!(self.tcx.sess, span, E0279,\n                                 \"the requirement `{}` is not satisfied (`{}`)\",\n@@ -601,7 +647,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             \"the trait `{}` cannot be made into an object\", trait_str\n         ));\n \n-        let mut reported_violations = FnvHashSet();\n+        let mut reported_violations = FxHashSet();\n         for violation in violations {\n             if !reported_violations.insert(violation.clone()) {\n                 continue;\n@@ -617,25 +663,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                          in the supertrait listing\"\n                 }\n \n-                ObjectSafetyViolation::Method(method,\n+                ObjectSafetyViolation::Method(name,\n                                               MethodViolationCode::StaticMethod) => {\n-                    buf = format!(\"method `{}` has no receiver\",\n-                                  method.name);\n+                    buf = format!(\"method `{}` has no receiver\", name);\n                     &buf\n                 }\n \n-                ObjectSafetyViolation::Method(method,\n+                ObjectSafetyViolation::Method(name,\n                                               MethodViolationCode::ReferencesSelf) => {\n                     buf = format!(\"method `{}` references the `Self` type \\\n                                        in its arguments or return type\",\n-                                  method.name);\n+                                  name);\n                     &buf\n                 }\n \n-                ObjectSafetyViolation::Method(method,\n+                ObjectSafetyViolation::Method(name,\n                                               MethodViolationCode::Generic) => {\n-                    buf = format!(\"method `{}` has generic type parameters\",\n-                                  method.name);\n+                    buf = format!(\"method `{}` has generic type parameters\", name);\n                     &buf\n                 }\n             };\n@@ -740,7 +784,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-            var_map: FnvHashMap<Ty<'tcx>, Ty<'tcx>>\n+            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n         }\n \n         impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ParamToVarFolder<'a, 'gcx, 'tcx> {\n@@ -761,7 +805,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n                 infcx: self,\n-                var_map: FnvHashMap()\n+                var_map: FxHashMap()\n             });\n \n             let cleaned_pred = super::project::normalize(\n@@ -822,6 +866,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.note(&format!(\"required so that reference `{}` does not outlive its referent\",\n                                   ref_ty));\n             }\n+            ObligationCauseCode::ObjectTypeBound(object_ty, region) => {\n+                err.note(&format!(\"required so that the lifetime bound of `{}` for `{}` \\\n+                                   is satisfied\",\n+                                  region, object_ty));\n+            }\n             ObligationCauseCode::ItemObligation(item_def_id) => {\n                 let item_name = tcx.item_path_str(item_def_id);\n                 err.note(&format!(\"required by `{}`\", item_name));\n@@ -886,7 +935,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                 &parent_predicate,\n                                                 &data.parent_code);\n             }\n-            ObligationCauseCode::CompareImplMethodObligation => {\n+            ObligationCauseCode::CompareImplMethodObligation { .. } => {\n                 err.note(\n                     &format!(\"the requirement `{}` appears on the impl method \\\n                               but not on the corresponding trait method\","}, {"sha": "6de93adce3f8302ee80a23f9e6dcb424b11ca520", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -18,7 +18,7 @@ use std::marker::PhantomData;\n use std::mem;\n use syntax::ast;\n use util::common::ErrorReported;\n-use util::nodemap::{FnvHashSet, NodeMap};\n+use util::nodemap::{FxHashSet, NodeMap};\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n@@ -37,7 +37,7 @@ impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n }\n \n pub struct GlobalFulfilledPredicates<'tcx> {\n-    set: FnvHashSet<ty::PolyTraitPredicate<'tcx>>,\n+    set: FxHashSet<ty::PolyTraitPredicate<'tcx>>,\n     dep_graph: DepGraph,\n }\n \n@@ -526,7 +526,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Predicate::RegionOutlives(ref binder) => {\n-            match selcx.infcx().region_outlives_predicate(obligation.cause.span, binder) {\n+            match selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n                 Ok(()) => Ok(Some(Vec::new())),\n                 Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }\n@@ -673,7 +673,7 @@ fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n     pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'gcx> {\n         GlobalFulfilledPredicates {\n-            set: FnvHashSet(),\n+            set: FxHashSet(),\n             dep_graph: dep_graph,\n         }\n     }"}, {"sha": "36405df6325af31618be834348c5ac2909512ad6", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -111,6 +111,9 @@ pub enum ObligationCauseCode<'tcx> {\n     /// A type like `&'a T` is WF only if `T: 'a`.\n     ReferenceOutlivesReferent(Ty<'tcx>),\n \n+    /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n+    ObjectTypeBound(Ty<'tcx>, &'tcx ty::Region),\n+\n     /// Obligation incurred due to an object cast.\n     ObjectCastObligation(/* Object type */ Ty<'tcx>),\n \n@@ -138,7 +141,13 @@ pub enum ObligationCauseCode<'tcx> {\n \n     ImplDerivedObligation(DerivedObligationCause<'tcx>),\n \n-    CompareImplMethodObligation,\n+    // error derived when matching traits/impls; see ObligationCause for more details\n+    CompareImplMethodObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+        lint_id: Option<ast::NodeId>,\n+    },\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -569,18 +578,14 @@ pub fn get_vtable_methods<'a, 'tcx>(\n     supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n         tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n \n-        let trait_item_def_ids = tcx.impl_or_trait_items(trait_ref.def_id());\n-        let trait_methods = (0..trait_item_def_ids.len()).filter_map(move |i| {\n-            match tcx.impl_or_trait_item(trait_item_def_ids[i]) {\n-                ty::MethodTraitItem(m) => Some(m),\n-                _ => None\n-            }\n-        });\n+        let trait_methods = tcx.associated_items(trait_ref.def_id())\n+            .filter(|item| item.kind == ty::AssociatedKind::Method);\n \n         // Now list each method's DefId and Substs (for within its trait).\n         // If the method can never be called from this object, produce None.\n         trait_methods.map(move |trait_method| {\n             debug!(\"get_vtable_methods: trait_method={:?}\", trait_method);\n+            let def_id = trait_method.def_id;\n \n             // Some methods cannot be called on an object; skip those.\n             if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n@@ -590,21 +595,21 @@ pub fn get_vtable_methods<'a, 'tcx>(\n \n             // the method may have some early-bound lifetimes, add\n             // regions for those\n-            let substs = Substs::for_item(tcx, trait_method.def_id,\n-                                            |_, _| tcx.mk_region(ty::ReErased),\n-                                            |def, _| trait_ref.substs().type_for_def(def));\n+            let substs = Substs::for_item(tcx, def_id,\n+                                          |_, _| tcx.mk_region(ty::ReErased),\n+                                          |def, _| trait_ref.substs().type_for_def(def));\n \n             // It's possible that the method relies on where clauses that\n             // do not hold for this particular set of type parameters.\n             // Note that this method could then never be called, so we\n             // do not want to try and trans it, in that case (see #23435).\n-            let predicates = trait_method.predicates.instantiate_own(tcx, substs);\n+            let predicates = tcx.lookup_predicates(def_id).instantiate_own(tcx, substs);\n             if !normalize_and_test_predicates(tcx, predicates.predicates) {\n                 debug!(\"get_vtable_methods: predicates do not hold\");\n                 return None;\n             }\n \n-            Some((trait_method.def_id, substs))\n+            Some((def_id, substs))\n         })\n     })\n }"}, {"sha": "c783bd561bb1a7bd73042397359218cb2424fe6f", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -22,11 +22,10 @@ use super::elaborate_predicates;\n use hir::def_id::DefId;\n use traits;\n use ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n-use std::rc::Rc;\n use syntax::ast;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ObjectSafetyViolation<'tcx> {\n+pub enum ObjectSafetyViolation {\n     /// Self : Sized declared on the trait\n     SizedSelf,\n \n@@ -35,7 +34,7 @@ pub enum ObjectSafetyViolation<'tcx> {\n     SupertraitSelf,\n \n     /// Method has something illegal\n-    Method(Rc<ty::Method<'tcx>>, MethodViolationCode),\n+    Method(ast::Name, MethodViolationCode),\n }\n \n /// Reasons a method might not be object-safe.\n@@ -77,7 +76,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// because `object_safety_violations` can't be used during\n     /// type collection.\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n-                                            -> Vec<ObjectSafetyViolation<'tcx>>\n+                                            -> Vec<ObjectSafetyViolation>\n     {\n         let mut violations = vec![];\n \n@@ -93,29 +92,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn object_safety_violations(self, trait_def_id: DefId)\n-                                    -> Vec<ObjectSafetyViolation<'tcx>>\n+                                    -> Vec<ObjectSafetyViolation>\n     {\n         traits::supertrait_def_ids(self, trait_def_id)\n             .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n             .collect()\n     }\n \n     fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n-                                          -> Vec<ObjectSafetyViolation<'tcx>>\n+                                          -> Vec<ObjectSafetyViolation>\n     {\n         // Check methods for violations.\n-        let mut violations: Vec<_> =\n-            self.trait_items(trait_def_id).iter()\n+        let mut violations: Vec<_> = self.associated_items(trait_def_id)\n+            .filter(|item| item.kind == ty::AssociatedKind::Method)\n             .filter_map(|item| {\n-                match *item {\n-                    ty::MethodTraitItem(ref m) => {\n-                        self.object_safety_violation_for_method(trait_def_id, &m)\n-                            .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n-                    }\n-                    _ => None,\n-                }\n-            })\n-            .collect();\n+                self.object_safety_violation_for_method(trait_def_id, &item)\n+                    .map(|code| ObjectSafetyViolation::Method(item.name, code))\n+            }).collect();\n \n         // Check the trait itself.\n         if self.trait_has_sized_self(trait_def_id) {\n@@ -198,7 +191,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns `Some(_)` if this method makes the containing trait not object safe.\n     fn object_safety_violation_for_method(self,\n                                           trait_def_id: DefId,\n-                                          method: &ty::Method<'gcx>)\n+                                          method: &ty::AssociatedItem)\n                                           -> Option<MethodViolationCode>\n     {\n         // Any method that has a `Self : Sized` requisite is otherwise\n@@ -216,7 +209,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// otherwise ensure that they cannot be used when `Self=Trait`.\n     pub fn is_vtable_safe_method(self,\n                                  trait_def_id: DefId,\n-                                 method: &ty::Method<'gcx>)\n+                                 method: &ty::AssociatedItem)\n                                  -> bool\n     {\n         // Any method that has a `Self : Sized` requisite can't be called.\n@@ -233,26 +226,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `Self:Sized`.\n     fn virtual_call_violation_for_method(self,\n                                          trait_def_id: DefId,\n-                                         method: &ty::Method<'tcx>)\n+                                         method: &ty::AssociatedItem)\n                                          -> Option<MethodViolationCode>\n     {\n         // The method's first parameter must be something that derefs (or\n         // autorefs) to `&self`. For now, we only accept `self`, `&self`\n         // and `Box<Self>`.\n-        match method.explicit_self {\n-            ty::ExplicitSelfCategory::Static => {\n-                return Some(MethodViolationCode::StaticMethod);\n-            }\n-\n-            ty::ExplicitSelfCategory::ByValue |\n-            ty::ExplicitSelfCategory::ByReference(..) |\n-            ty::ExplicitSelfCategory::ByBox => {\n-            }\n+        if !method.method_has_self_argument {\n+            return Some(MethodViolationCode::StaticMethod);\n         }\n \n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n-        let ref sig = method.fty.sig;\n+        let ref sig = self.lookup_item_type(method.def_id).ty.fn_sig();\n         for &input_ty in &sig.0.inputs[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n@@ -263,7 +249,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if !method.generics.types.is_empty() {\n+        if !self.lookup_generics(method.def_id).types.is_empty() {\n             return Some(MethodViolationCode::Generic);\n         }\n "}, {"sha": "b1ab61b09757e69babf1719dd7d415768a097858", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -33,8 +33,6 @@ use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n use util::common::FN_OUTPUT_NAME;\n \n-use std::rc::Rc;\n-\n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n@@ -945,7 +943,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                         // an error when we confirm the candidate\n                         // (which will ultimately lead to `normalize_to_error`\n                         // being invoked).\n-                        node_item.item.ty.is_some()\n+                        node_item.item.has_value\n                     } else {\n                         node_item.item.defaultness.is_default()\n                     };\n@@ -1305,7 +1303,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n \n     match assoc_ty {\n         Some(node_item) => {\n-            let ty = node_item.item.ty.unwrap_or_else(|| {\n+            let ty = if !node_item.item.has_value {\n                 // This means that the impl is missing a definition for the\n                 // associated type. This error will be reported by the type\n                 // checker method `check_impl_items_against_trait`, so here we\n@@ -1314,7 +1312,9 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n                        node_item.item.name,\n                        obligation.predicate.trait_ref);\n                 tcx.types.err\n-            });\n+            } else {\n+                tcx.lookup_item_type(node_item.item.def_id).ty\n+            };\n             let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n             Progress {\n                 ty: ty.subst(tcx, substs),\n@@ -1339,27 +1339,25 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'gcx, 'tcx>,\n     impl_def_id: DefId,\n     assoc_ty_name: ast::Name)\n-    -> Option<specialization_graph::NodeItem<Rc<ty::AssociatedType<'tcx>>>>\n+    -> Option<specialization_graph::NodeItem<ty::AssociatedItem>>\n {\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n \n     if selcx.projection_mode() == Reveal::ExactMatch {\n         let impl_node = specialization_graph::Node::Impl(impl_def_id);\n         for item in impl_node.items(selcx.tcx()) {\n-            if let ty::TypeTraitItem(assoc_ty) = item {\n-                if assoc_ty.name == assoc_ty_name {\n-                    return Some(specialization_graph::NodeItem {\n-                        node: specialization_graph::Node::Impl(impl_def_id),\n-                        item: assoc_ty,\n-                    });\n-                }\n+            if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n+                return Some(specialization_graph::NodeItem {\n+                    node: specialization_graph::Node::Impl(impl_def_id),\n+                    item: item,\n+                });\n             }\n         }\n         None\n     } else {\n         selcx.tcx().lookup_trait_def(trait_def_id)\n             .ancestors(impl_def_id)\n-            .type_defs(selcx.tcx(), assoc_ty_name)\n+            .defs(selcx.tcx(), assoc_ty_name, ty::AssociatedKind::Type)\n             .next()\n     }\n }"}, {"sha": "5e3f78b1208d51d096d1c360065787b9743ed091", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -51,7 +51,7 @@ use std::mem;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n struct InferredObligationsSnapshotVecDelegate<'tcx> {\n     phantom: PhantomData<&'tcx i32>,\n@@ -104,8 +104,8 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n \n #[derive(Clone)]\n pub struct SelectionCache<'tcx> {\n-    hashmap: RefCell<FnvHashMap<ty::TraitRef<'tcx>,\n-                                SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n+    hashmap: RefCell<FxHashMap<ty::TraitRef<'tcx>,\n+                               SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n }\n \n pub enum MethodMatchResult {\n@@ -306,7 +306,7 @@ enum EvaluationResult {\n \n #[derive(Clone)]\n pub struct EvaluationCache<'tcx> {\n-    hashmap: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n+    hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n }\n \n impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n@@ -2937,15 +2937,15 @@ impl<'tcx> TraitObligation<'tcx> {\n impl<'tcx> SelectionCache<'tcx> {\n     pub fn new() -> SelectionCache<'tcx> {\n         SelectionCache {\n-            hashmap: RefCell::new(FnvHashMap())\n+            hashmap: RefCell::new(FxHashMap())\n         }\n     }\n }\n \n impl<'tcx> EvaluationCache<'tcx> {\n     pub fn new() -> EvaluationCache<'tcx> {\n         EvaluationCache {\n-            hashmap: RefCell::new(FnvHashMap())\n+            hashmap: RefCell::new(FxHashMap())\n         }\n     }\n }"}, {"sha": "91c40a5cc85161872f5a37ff4764676014741e2b", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -20,9 +20,9 @@\n use super::{SelectionContext, FulfillmentContext};\n use super::util::impl_trait_ref_and_oblig;\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use hir::def_id::DefId;\n-use infer::{InferCtxt, TypeOrigin};\n+use infer::{InferCtxt, InferOk, TypeOrigin};\n use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause};\n@@ -120,7 +120,8 @@ pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n     let trait_def = tcx.lookup_trait_def(trait_def_id);\n \n-    match trait_def.ancestors(impl_data.impl_def_id).fn_defs(tcx, name).next() {\n+    let ancestors = trait_def.ancestors(impl_data.impl_def_id);\n+    match ancestors.defs(tcx, name, ty::AssociatedKind::Method).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n@@ -222,14 +223,18 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                                                    target_substs);\n \n     // do the impls unify? If not, no specialization.\n-    if let Err(_) = infcx.eq_trait_refs(true,\n-                                        TypeOrigin::Misc(DUMMY_SP),\n-                                        source_trait_ref,\n-                                        target_trait_ref) {\n-        debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n-               source_trait_ref,\n-               target_trait_ref);\n-        return Err(());\n+    match infcx.eq_trait_refs(true, TypeOrigin::Misc(DUMMY_SP), source_trait_ref,\n+                                                                target_trait_ref) {\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty())\n+        }\n+        Err(_) => {\n+            debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n+                   source_trait_ref,\n+                   target_trait_ref);\n+            return Err(());\n+        }\n     }\n \n     // attempt to prove all of the predicates for impl2 given those for impl1\n@@ -266,13 +271,13 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n pub struct SpecializesCache {\n-    map: FnvHashMap<(DefId, DefId), bool>\n+    map: FxHashMap<(DefId, DefId), bool>\n }\n \n impl SpecializesCache {\n     pub fn new() -> Self {\n         SpecializesCache {\n-            map: FnvHashMap()\n+            map: FxHashMap()\n         }\n     }\n "}, {"sha": "5a6809f1fad6829824078529e8d4b106f492645e", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 17, "deletions": 131, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n-\n use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n use traits::{self, Reveal};\n-use ty::{self, TyCtxt, ImplOrTraitItem, TraitDef, TypeFoldable};\n+use ty::{self, TyCtxt, TraitDef, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use syntax::ast::Name;\n-use util::nodemap::{DefIdMap, FnvHashMap};\n+use util::nodemap::{DefIdMap, FxHashMap};\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n /// graph forms a tree rooted with the trait itself, with all other nodes\n@@ -57,7 +55,7 @@ struct Children {\n     // the specialization graph.\n \n     /// Impls of the trait.\n-    nonblanket_impls: FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n+    nonblanket_impls: FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n \n     /// Blanket impls associated with the trait.\n     blanket_impls: Vec<DefId>,\n@@ -78,7 +76,7 @@ enum Inserted {\n impl<'a, 'gcx, 'tcx> Children {\n     fn new() -> Children {\n         Children {\n-            nonblanket_impls: FnvHashMap(),\n+            nonblanket_impls: FxHashMap(),\n             blanket_impls: vec![],\n         }\n     }\n@@ -285,12 +283,10 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeItems<'a, 'gcx> {\n-        NodeItems {\n-            tcx: tcx.global_tcx(),\n-            items: tcx.impl_or_trait_items(self.def_id()),\n-            idx: 0,\n-        }\n+    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+    pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                 -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+        tcx.associated_items(self.def_id())\n     }\n \n     pub fn def_id(&self) -> DefId {\n@@ -301,28 +297,6 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n }\n \n-/// An iterator over the items defined within a trait or impl.\n-pub struct NodeItems<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    items: Rc<Vec<DefId>>,\n-    idx: usize\n-}\n-\n-impl<'a, 'tcx> Iterator for NodeItems<'a, 'tcx> {\n-    type Item = ImplOrTraitItem<'tcx>;\n-    fn next(&mut self) -> Option<ImplOrTraitItem<'tcx>> {\n-        if self.idx < self.items.len() {\n-            let item_def_id = self.items[self.idx];\n-            let items_table = self.tcx.impl_or_trait_items.borrow();\n-            let item = items_table[&item_def_id].clone();\n-            self.idx += 1;\n-            Some(item)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n pub struct Ancestors<'a, 'tcx: 'a> {\n     trait_def: &'a TraitDef<'tcx>,\n     current_source: Option<Node>,\n@@ -358,104 +332,16 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-pub struct TypeDefs<'a, 'tcx: 'a> {\n-    // generally only invoked once or twice, so the box doesn't hurt\n-    iter: Box<Iterator<Item = NodeItem<Rc<ty::AssociatedType<'tcx>>>> + 'a>,\n-}\n-\n-impl<'a, 'tcx> Iterator for TypeDefs<'a, 'tcx> {\n-    type Item = NodeItem<Rc<ty::AssociatedType<'tcx>>>;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.iter.next()\n-    }\n-}\n-\n-pub struct FnDefs<'a, 'tcx: 'a> {\n-    // generally only invoked once or twice, so the box doesn't hurt\n-    iter: Box<Iterator<Item = NodeItem<Rc<ty::Method<'tcx>>>> + 'a>,\n-}\n-\n-impl<'a, 'tcx> Iterator for FnDefs<'a, 'tcx> {\n-    type Item = NodeItem<Rc<ty::Method<'tcx>>>;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.iter.next()\n-    }\n-}\n-\n-pub struct ConstDefs<'a, 'tcx: 'a> {\n-    // generally only invoked once or twice, so the box doesn't hurt\n-    iter: Box<Iterator<Item = NodeItem<Rc<ty::AssociatedConst<'tcx>>>> + 'a>,\n-}\n-\n-impl<'a, 'tcx> Iterator for ConstDefs<'a, 'tcx> {\n-    type Item = NodeItem<Rc<ty::AssociatedConst<'tcx>>>;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.iter.next()\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> Ancestors<'a, 'tcx> {\n-    /// Search the items from the given ancestors, returning each type definition\n-    /// with the given name.\n-    pub fn type_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> TypeDefs<'a, 'gcx> {\n-        let iter = self.flat_map(move |node| {\n-            node.items(tcx)\n-                .filter_map(move |item| {\n-                    if let ty::TypeTraitItem(assoc_ty) = item {\n-                        if assoc_ty.name == name {\n-                            return Some(NodeItem {\n-                                node: node,\n-                                item: assoc_ty,\n-                            });\n-                        }\n-                    }\n-                    None\n-                })\n-\n-        });\n-        TypeDefs { iter: Box::new(iter) }\n-    }\n-\n-    /// Search the items from the given ancestors, returning each fn definition\n-    /// with the given name.\n-    pub fn fn_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> FnDefs<'a, 'gcx> {\n-        let iter = self.flat_map(move |node| {\n-            node.items(tcx)\n-                .filter_map(move |item| {\n-                    if let ty::MethodTraitItem(method) = item {\n-                        if method.name == name {\n-                            return Some(NodeItem {\n-                                node: node,\n-                                item: method,\n-                            });\n-                        }\n-                    }\n-                    None\n-                })\n-\n-        });\n-        FnDefs { iter: Box::new(iter) }\n-    }\n-\n-    /// Search the items from the given ancestors, returning each const\n-    /// definition with the given name.\n-    pub fn const_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> ConstDefs<'a, 'gcx> {\n-        let iter = self.flat_map(move |node| {\n-            node.items(tcx)\n-                .filter_map(move |item| {\n-                    if let ty::ConstTraitItem(konst) = item {\n-                        if konst.name == name {\n-                            return Some(NodeItem {\n-                                node: node,\n-                                item: konst,\n-                            });\n-                        }\n-                    }\n-                    None\n-                })\n-\n-        });\n-        ConstDefs { iter: Box::new(iter) }\n+    /// Search the items from the given ancestors, returning each definition\n+    /// with the given name and the given kind.\n+    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+    pub fn defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name, kind: ty::AssociatedKind)\n+                -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + 'a {\n+        self.flat_map(move |node| {\n+            node.items(tcx).filter(move |item| item.kind == kind && item.name == name)\n+                           .map(move |item| NodeItem { node: node, item: item })\n+        })\n     }\n }\n "}, {"sha": "d33e8b5675f55a4e655e6a1b820c0b7558441f82", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -175,6 +175,13 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ReferenceOutlivesReferent(ty) => {\n                 tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n             }\n+            super::ObjectTypeBound(ty, r) => {\n+                tcx.lift(&ty).and_then(|ty| {\n+                    tcx.lift(&r).and_then(|r| {\n+                        Some(super::ObjectTypeBound(ty, r))\n+                    })\n+                })\n+            }\n             super::ObjectCastObligation(ty) => {\n                 tcx.lift(&ty).map(super::ObjectCastObligation)\n             }\n@@ -195,8 +202,16 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ImplDerivedObligation(ref cause) => {\n                 tcx.lift(cause).map(super::ImplDerivedObligation)\n             }\n-            super::CompareImplMethodObligation => {\n-                Some(super::CompareImplMethodObligation)\n+            super::CompareImplMethodObligation { item_name,\n+                                                 impl_item_def_id,\n+                                                 trait_item_def_id,\n+                                                 lint_id } => {\n+                Some(super::CompareImplMethodObligation {\n+                    item_name: item_name,\n+                    impl_item_def_id: impl_item_def_id,\n+                    trait_item_def_id: trait_item_def_id,\n+                    lint_id: lint_id,\n+                })\n             }\n         }\n     }\n@@ -459,12 +474,15 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |\n-            super::CompareImplMethodObligation => self.clone(),\n+            super::CompareImplMethodObligation { .. } => self.clone(),\n \n             super::ProjectionWf(proj) => super::ProjectionWf(proj.fold_with(folder)),\n             super::ReferenceOutlivesReferent(ty) => {\n                 super::ReferenceOutlivesReferent(ty.fold_with(folder))\n             }\n+            super::ObjectTypeBound(ty, r) => {\n+                super::ObjectTypeBound(ty.fold_with(folder), r.fold_with(folder))\n+            }\n             super::ObjectCastObligation(ty) => {\n                 super::ObjectCastObligation(ty.fold_with(folder))\n             }\n@@ -492,10 +510,11 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |\n-            super::CompareImplMethodObligation => false,\n+            super::CompareImplMethodObligation { .. } => false,\n \n             super::ProjectionWf(proj) => proj.visit_with(visitor),\n             super::ReferenceOutlivesReferent(ty) => ty.visit_with(visitor),\n+            super::ObjectTypeBound(ty, r) => ty.visit_with(visitor) || r.visit_with(visitor),\n             super::ObjectCastObligation(ty) => ty.visit_with(visitor),\n             super::BuiltinDerivedObligation(ref cause) => cause.visit_with(visitor),\n             super::ImplDerivedObligation(ref cause) => cause.visit_with(visitor)"}, {"sha": "9346bbd30f9ceb2485db154e88e44c162480e732", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 67, "deletions": 34, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -11,8 +11,9 @@\n use hir::def_id::DefId;\n use ty::subst::{Subst, Substs};\n use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n+use ty::outlives::Component;\n use util::common::ErrorReported;\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n@@ -49,12 +50,12 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n struct PredicateSet<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    set: FnvHashSet<ty::Predicate<'tcx>>,\n+    set: FxHashSet<ty::Predicate<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PredicateSet<'a, 'gcx, 'tcx> {\n-        PredicateSet { tcx: tcx, set: FnvHashSet() }\n+        PredicateSet { tcx: tcx, set: FxHashSet() }\n     }\n \n     fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n@@ -166,27 +167,63 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n             ty::Predicate::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n-            ty::Predicate::RegionOutlives(..) |\n-            ty::Predicate::TypeOutlives(..) => {\n-                // Currently, we do not \"elaborate\" predicates like\n-                // `'a : 'b` or `T : 'a`.  We could conceivably do\n-                // more here.  For example,\n-                //\n-                //     &'a int : 'b\n-                //\n-                // implies that\n-                //\n-                //     'a : 'b\n-                //\n-                // and we could get even more if we took WF\n-                // constraints into account. For example,\n-                //\n-                //     &'a &'b int : 'c\n-                //\n-                // implies that\n+\n+            ty::Predicate::RegionOutlives(..) => {\n+                // Nothing to elaborate from `'a: 'b`.\n+            }\n+\n+            ty::Predicate::TypeOutlives(ref data) => {\n+                // We know that `T: 'a` for some type `T`. We can\n+                // often elaborate this. For example, if we know that\n+                // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n+                // we know `&'a U: 'b`, then we know that `'a: 'b` and\n+                // `U: 'b`.\n                 //\n-                //     'b : 'a\n-                //     'a : 'c\n+                // We can basically ignore bound regions here. So for\n+                // example `for<'c> Foo<'a,'c>: 'b` can be elaborated to\n+                // `'a: 'b`.\n+\n+                // Ignore `for<'a> T: 'a` -- we might in the future\n+                // consider this as evidence that `T: 'static`, but\n+                // I'm a bit wary of such constructions and so for now\n+                // I want to be conservative. --nmatsakis\n+                let ty_max = data.skip_binder().0;\n+                let r_min = data.skip_binder().1;\n+                if r_min.is_bound() {\n+                    return;\n+                }\n+\n+                let visited = &mut self.visited;\n+                self.stack.extend(\n+                    tcx.outlives_components(ty_max)\n+                       .into_iter()\n+                       .filter_map(|component| match component {\n+                           Component::Region(r) => if r.is_bound() {\n+                               None\n+                           } else {\n+                               Some(ty::Predicate::RegionOutlives(\n+                                   ty::Binder(ty::OutlivesPredicate(r, r_min))))\n+                           },\n+\n+                           Component::Param(p) => {\n+                               let ty = tcx.mk_param(p.idx, p.name);\n+                               Some(ty::Predicate::TypeOutlives(\n+                                   ty::Binder(ty::OutlivesPredicate(ty, r_min))))\n+                           },\n+\n+                           Component::UnresolvedInferenceVariable(_) => {\n+                               None\n+                           },\n+\n+                           Component::Projection(_) |\n+                           Component::EscapingProjection(_) => {\n+                               // We can probably do more here. This\n+                               // corresponds to a case like `<T as\n+                               // Foo<'a>>::U: 'b`.\n+                               None\n+                           },\n+                       })\n+                       .filter(|p| visited.insert(p)));\n             }\n         }\n     }\n@@ -235,7 +272,7 @@ pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n pub struct SupertraitDefIds<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     stack: Vec<DefId>,\n-    visited: FnvHashSet<DefId>,\n+    visited: FxHashSet<DefId>,\n }\n \n pub fn supertrait_def_ids<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n@@ -440,8 +477,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let mut entries = 0;\n         // Count number of methods and add them to the total offset.\n         // Skip over associated types and constants.\n-        for trait_item in &self.trait_items(trait_ref.def_id())[..] {\n-            if let ty::MethodTraitItem(_) = *trait_item {\n+        for trait_item in self.associated_items(trait_ref.def_id()) {\n+            if trait_item.kind == ty::AssociatedKind::Method {\n                 entries += 1;\n             }\n         }\n@@ -458,17 +495,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // add them to the total offset.\n         // Skip over associated types and constants.\n         let mut entries = object.vtable_base;\n-        for trait_item in &self.trait_items(object.upcast_trait_ref.def_id())[..] {\n-            if trait_item.def_id() == method_def_id {\n+        for trait_item in self.associated_items(object.upcast_trait_ref.def_id()) {\n+            if trait_item.def_id == method_def_id {\n                 // The item with the ID we were given really ought to be a method.\n-                assert!(match *trait_item {\n-                    ty::MethodTraitItem(_) => true,\n-                    _ => false\n-                });\n-\n+                assert_eq!(trait_item.kind, ty::AssociatedKind::Method);\n                 return entries;\n             }\n-            if let ty::MethodTraitItem(_) = *trait_item {\n+            if trait_item.kind == ty::AssociatedKind::Method {\n                 entries += 1;\n             }\n         }"}, {"sha": "333a5c74cb45cb309c73e62317493ffed343530c", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 107, "deletions": 182, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::AutoAdjustment::*;\n-pub use self::AutoRef::*;\n-\n-use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeAndMut};\n use ty::LvaluePreference::{NoPreference};\n \n use syntax::ast;\n@@ -20,116 +17,122 @@ use syntax_pos::Span;\n use hir;\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum AutoAdjustment<'tcx> {\n-    AdjustNeverToAny(Ty<'tcx>), // go from ! to any type\n-    AdjustReifyFnPointer,       // go from a fn-item type to a fn-pointer type\n-    AdjustUnsafeFnPointer,      // go from a safe fn pointer to an unsafe fn pointer\n-    AdjustMutToConstPointer,    // go from a mut raw pointer to a const raw pointer\n-    AdjustDerefRef(AutoDerefRef<'tcx>),\n+pub struct Adjustment<'tcx> {\n+    pub kind: Adjust<'tcx>,\n+    pub target: Ty<'tcx>\n }\n \n-/// Represents coercing a pointer to a different kind of pointer - where 'kind'\n-/// here means either or both of raw vs borrowed vs unique and fat vs thin.\n-///\n-/// We transform pointers by following the following steps in order:\n-/// 1. Deref the pointer `self.autoderefs` times (may be 0).\n-/// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n-///    `&` or `*` pointer.\n-/// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n-///    which will do things like convert thin pointers to fat\n-///    pointers, or convert structs containing thin pointers to\n-///    structs containing fat pointers, or convert between fat\n-///    pointers.  We don't store the details of how the transform is\n-///    done (in fact, we don't know that, because it might depend on\n-///    the precise type parameters). We just store the target\n-///    type. Trans figures out what has to be done at monomorphization\n-///    time based on the precise source/target type at hand.\n-///\n-/// To make that more concrete, here are some common scenarios:\n-///\n-/// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n-/// Here the pointer will be dereferenced N times (where a dereference can\n-/// happen to raw or borrowed pointers or any smart pointer which implements\n-/// Deref, including Box<_>). The number of dereferences is given by\n-/// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n-/// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n-/// None.\n-///\n-/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n-/// with a thin pointer, deref a number of times, unsize the underlying data,\n-/// then autoref. The 'unsize' phase may change a fixed length array to a\n-/// dynamically sized one, a concrete object to a trait object, or statically\n-/// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n-/// represented by:\n-///\n-/// ```\n-/// AutoDerefRef {\n-///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n-///     autoref: Some(AutoPtr), // [i32] -> &[i32]\n-///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n-/// }\n-/// ```\n-///\n-/// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n-/// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n-/// The autoderef and -ref are the same as in the above example, but the type\n-/// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n-/// the underlying conversions from `[i32; 4]` to `[i32]`.\n-///\n-/// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n-/// that case, we have the pointer we need coming in, so there are no\n-/// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n-/// At some point, of course, `Box` should move out of the compiler, in which\n-/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n-/// Box<[i32]> is represented by:\n-///\n-/// ```\n-/// AutoDerefRef {\n-///     autoderefs: 0,\n-///     autoref: None,\n-///     unsize: Some(Box<[i32]>),\n-/// }\n-/// ```\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub struct AutoDerefRef<'tcx> {\n-    /// Step 1. Apply a number of dereferences, producing an lvalue.\n-    pub autoderefs: usize,\n-\n-    /// Step 2. Optionally produce a pointer/reference from the value.\n-    pub autoref: Option<AutoRef<'tcx>>,\n-\n-    /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n-    /// `&[T]`. The stored type is the target pointer type. Note that\n-    /// the source could be a thin or fat pointer.\n-    pub unsize: Option<Ty<'tcx>>,\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum Adjust<'tcx> {\n+    /// Go from ! to any type.\n+    NeverToAny,\n+\n+    /// Go from a fn-item type to a fn-pointer type.\n+    ReifyFnPointer,\n+\n+    /// Go from a safe fn pointer to an unsafe fn pointer.\n+    UnsafeFnPointer,\n+\n+    /// Go from a mut raw pointer to a const raw pointer.\n+    MutToConstPointer,\n+\n+    /// Represents coercing a pointer to a different kind of pointer - where 'kind'\n+    /// here means either or both of raw vs borrowed vs unique and fat vs thin.\n+    ///\n+    /// We transform pointers by following the following steps in order:\n+    /// 1. Deref the pointer `self.autoderefs` times (may be 0).\n+    /// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n+    ///    `&` or `*` pointer.\n+    /// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n+    ///    which will do things like convert thin pointers to fat\n+    ///    pointers, or convert structs containing thin pointers to\n+    ///    structs containing fat pointers, or convert between fat\n+    ///    pointers.  We don't store the details of how the transform is\n+    ///    done (in fact, we don't know that, because it might depend on\n+    ///    the precise type parameters). We just store the target\n+    ///    type. Trans figures out what has to be done at monomorphization\n+    ///    time based on the precise source/target type at hand.\n+    ///\n+    /// To make that more concrete, here are some common scenarios:\n+    ///\n+    /// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n+    /// Here the pointer will be dereferenced N times (where a dereference can\n+    /// happen to raw or borrowed pointers or any smart pointer which implements\n+    /// Deref, including Box<_>). The number of dereferences is given by\n+    /// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+    /// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n+    /// None.\n+    ///\n+    /// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n+    /// with a thin pointer, deref a number of times, unsize the underlying data,\n+    /// then autoref. The 'unsize' phase may change a fixed length array to a\n+    /// dynamically sized one, a concrete object to a trait object, or statically\n+    /// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n+    /// represented by:\n+    ///\n+    /// ```\n+    /// Adjust::DerefRef {\n+    ///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n+    ///     autoref: Some(AutoBorrow::Ref), // [i32] -> &[i32]\n+    ///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n+    /// }\n+    /// ```\n+    ///\n+    /// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n+    /// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n+    /// The autoderef and -ref are the same as in the above example, but the type\n+    /// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n+    /// the underlying conversions from `[i32; 4]` to `[i32]`.\n+    ///\n+    /// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n+    /// that case, we have the pointer we need coming in, so there are no\n+    /// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n+    /// At some point, of course, `Box` should move out of the compiler, in which\n+    /// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n+    /// Box<[i32]> is represented by:\n+    ///\n+    /// ```\n+    /// Adjust::DerefRef {\n+    ///     autoderefs: 0,\n+    ///     autoref: None,\n+    ///     unsize: Some(Box<[i32]>),\n+    /// }\n+    /// ```\n+    DerefRef {\n+        /// Step 1. Apply a number of dereferences, producing an lvalue.\n+        autoderefs: usize,\n+\n+        /// Step 2. Optionally produce a pointer/reference from the value.\n+        autoref: Option<AutoBorrow<'tcx>>,\n+\n+        /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n+        /// `&[T]`. Note that the source could be a thin or fat pointer.\n+        unsize: bool,\n+    }\n }\n \n-impl<'tcx> AutoAdjustment<'tcx> {\n+impl<'tcx> Adjustment<'tcx> {\n     pub fn is_identity(&self) -> bool {\n-        match *self {\n-            AdjustNeverToAny(ty) => ty.is_never(),\n-            AdjustReifyFnPointer |\n-            AdjustUnsafeFnPointer |\n-            AdjustMutToConstPointer => false,\n-            AdjustDerefRef(ref r) => r.is_identity(),\n+        match self.kind {\n+            Adjust::NeverToAny => self.target.is_never(),\n+\n+            Adjust::DerefRef { autoderefs: 0, autoref: None, unsize: false } => true,\n+\n+            Adjust::ReifyFnPointer |\n+            Adjust::UnsafeFnPointer |\n+            Adjust::MutToConstPointer |\n+            Adjust::DerefRef {..} => false,\n         }\n     }\n }\n-impl<'tcx> AutoDerefRef<'tcx> {\n-    pub fn is_identity(&self) -> bool {\n-        self.autoderefs == 0 && self.unsize.is_none() && self.autoref.is_none()\n-    }\n-}\n-\n \n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n-pub enum AutoRef<'tcx> {\n+pub enum AutoBorrow<'tcx> {\n     /// Convert from T to &T.\n-    AutoPtr(&'tcx ty::Region, hir::Mutability),\n+    Ref(&'tcx ty::Region, hir::Mutability),\n \n     /// Convert from T to *T.\n-    /// Value to thin pointer.\n-    AutoUnsafe(hir::Mutability),\n+    RawPtr(hir::Mutability),\n }\n \n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n@@ -139,84 +142,6 @@ pub enum CustomCoerceUnsized {\n }\n \n impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n-    /// See `expr_ty_adjusted`\n-    pub fn adjust<F>(&'tcx self,\n-                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     span: Span,\n-                     expr_id: ast::NodeId,\n-                     adjustment: Option<&AutoAdjustment<'tcx>>,\n-                     mut method_type: F)\n-                     -> Ty<'tcx> where\n-        F: FnMut(ty::MethodCall) -> Option<Ty<'tcx>>,\n-    {\n-        if let ty::TyError = self.sty {\n-            return self;\n-        }\n-\n-        return match adjustment {\n-            Some(adjustment) => {\n-                match *adjustment {\n-                    AdjustNeverToAny(ref ty) => ty,\n-\n-                    AdjustReifyFnPointer => {\n-                        match self.sty {\n-                            ty::TyFnDef(.., f) => tcx.mk_fn_ptr(f),\n-                            _ => {\n-                                bug!(\"AdjustReifyFnPointer adjustment on non-fn-item: {:?}\",\n-                                     self);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustUnsafeFnPointer => {\n-                        match self.sty {\n-                            ty::TyFnPtr(b) => tcx.safe_to_unsafe_fn_ty(b),\n-                            ref b => {\n-                                bug!(\"AdjustUnsafeFnPointer adjustment on non-fn-ptr: {:?}\",\n-                                     b);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustMutToConstPointer => {\n-                        match self.sty {\n-                            ty::TyRawPtr(mt) => tcx.mk_ptr(ty::TypeAndMut {\n-                                ty: mt.ty,\n-                                mutbl: hir::MutImmutable\n-                            }),\n-                            ref b => {\n-                                bug!(\"AdjustMutToConstPointer on non-raw-ptr: {:?}\",\n-                                     b);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustDerefRef(ref adj) => {\n-                        let mut adjusted_ty = self;\n-\n-                        if !adjusted_ty.references_error() {\n-                            for i in 0..adj.autoderefs {\n-                                adjusted_ty =\n-                                    adjusted_ty.adjust_for_autoderef(tcx,\n-                                                                     expr_id,\n-                                                                     span,\n-                                                                     i as u32,\n-                                                                     &mut method_type);\n-                            }\n-                        }\n-\n-                        if let Some(target) = adj.unsize {\n-                            target\n-                        } else {\n-                            adjusted_ty.adjust_for_autoref(tcx, adj.autoref)\n-                        }\n-                    }\n-                }\n-            }\n-            None => self\n-        };\n-    }\n-\n     pub fn adjust_for_autoderef<F>(&'tcx self,\n                                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                    expr_id: ast::NodeId,\n@@ -247,14 +172,14 @@ impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                              autoref: Option<AutoRef<'tcx>>)\n+                              autoref: Option<AutoBorrow<'tcx>>)\n                               -> Ty<'tcx> {\n         match autoref {\n             None => self,\n-            Some(AutoPtr(r, m)) => {\n+            Some(AutoBorrow::Ref(r, m)) => {\n                 tcx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n             }\n-            Some(AutoUnsafe(m)) => {\n+            Some(AutoBorrow::RawPtr(m)) => {\n                 tcx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n             }\n         }"}, {"sha": "7ed4de38be97eef26ceedafc418491b0e27a2859", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -11,7 +11,7 @@\n use hir::def_id::{DefId};\n use ty::{self, Ty, TyCtxt};\n use util::common::MemoizationMap;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use std::fmt;\n use std::ops;\n@@ -141,11 +141,11 @@ impl fmt::Debug for TypeContents {\n \n impl<'a, 'tcx> ty::TyS<'tcx> {\n     pub fn type_contents(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeContents {\n-        return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FnvHashMap()));\n+        return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FxHashMap()));\n \n         fn tc_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            ty: Ty<'tcx>,\n-                           cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n+                           cache: &mut FxHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n         {\n             // Subtle: Note that we are *not* using tcx.tc_cache here but rather a\n             // private cache for this walk.  This is needed in the case of cyclic"}, {"sha": "60a48ba580a0deca18da0de083cf263d7792344a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 103, "deletions": 55, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -36,12 +36,12 @@ use ty::layout::{Layout, TargetDataLayout};\n use ty::maps;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n use arena::TypedArena;\n use std::borrow::Borrow;\n-use std::cell::{Cell, RefCell, Ref};\n+use std::cell::{Cell, RefCell};\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n@@ -96,26 +96,26 @@ pub struct CtxtInterners<'tcx> {\n \n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n-    type_: RefCell<FnvHashSet<Interned<'tcx, TyS<'tcx>>>>,\n-    type_list: RefCell<FnvHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n-    substs: RefCell<FnvHashSet<Interned<'tcx, Substs<'tcx>>>>,\n-    bare_fn: RefCell<FnvHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n-    region: RefCell<FnvHashSet<Interned<'tcx, Region>>>,\n-    stability: RefCell<FnvHashSet<&'tcx attr::Stability>>,\n-    layout: RefCell<FnvHashSet<&'tcx Layout>>,\n+    type_: RefCell<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n+    type_list: RefCell<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n+    substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n+    bare_fn: RefCell<FxHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n+    region: RefCell<FxHashSet<Interned<'tcx, Region>>>,\n+    stability: RefCell<FxHashSet<&'tcx attr::Stability>>,\n+    layout: RefCell<FxHashSet<&'tcx Layout>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n     fn new(arenas: &'tcx CtxtArenas<'tcx>) -> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arenas: arenas,\n-            type_: RefCell::new(FnvHashSet()),\n-            type_list: RefCell::new(FnvHashSet()),\n-            substs: RefCell::new(FnvHashSet()),\n-            bare_fn: RefCell::new(FnvHashSet()),\n-            region: RefCell::new(FnvHashSet()),\n-            stability: RefCell::new(FnvHashSet()),\n-            layout: RefCell::new(FnvHashSet())\n+            type_: RefCell::new(FxHashSet()),\n+            type_list: RefCell::new(FxHashSet()),\n+            substs: RefCell::new(FxHashSet()),\n+            bare_fn: RefCell::new(FxHashSet()),\n+            region: RefCell::new(FxHashSet()),\n+            stability: RefCell::new(FxHashSet()),\n+            layout: RefCell::new(FxHashSet())\n         }\n     }\n \n@@ -212,7 +212,7 @@ pub struct Tables<'tcx> {\n     /// other items.\n     pub item_substs: NodeMap<ty::ItemSubsts<'tcx>>,\n \n-    pub adjustments: NodeMap<ty::adjustment::AutoAdjustment<'tcx>>,\n+    pub adjustments: NodeMap<ty::adjustment::Adjustment<'tcx>>,\n \n     pub method_map: ty::MethodMap<'tcx>,\n \n@@ -244,17 +244,87 @@ pub struct Tables<'tcx> {\n impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n     pub fn empty() -> Tables<'tcx> {\n         Tables {\n-            node_types: FnvHashMap(),\n+            node_types: FxHashMap(),\n             item_substs: NodeMap(),\n             adjustments: NodeMap(),\n-            method_map: FnvHashMap(),\n-            upvar_capture_map: FnvHashMap(),\n+            method_map: FxHashMap(),\n+            upvar_capture_map: FxHashMap(),\n             closure_tys: DefIdMap(),\n             closure_kinds: DefIdMap(),\n             liberated_fn_sigs: NodeMap(),\n             fru_field_types: NodeMap()\n         }\n     }\n+\n+    pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n+        match self.node_id_to_type_opt(id) {\n+            Some(ty) => ty,\n+            None => {\n+                bug!(\"node_id_to_type: no type for node `{}`\",\n+                     tls::with(|tcx| tcx.map.node_to_string(id)))\n+            }\n+        }\n+    }\n+\n+    pub fn node_id_to_type_opt(&self, id: NodeId) -> Option<Ty<'tcx>> {\n+        self.node_types.get(&id).cloned()\n+    }\n+\n+    pub fn node_id_item_substs(&self, id: NodeId) -> Option<&'tcx Substs<'tcx>> {\n+        self.item_substs.get(&id).map(|ts| ts.substs)\n+    }\n+\n+    // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n+    // doesn't provide type parameter substitutions.\n+    pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n+        self.node_id_to_type(pat.id)\n+    }\n+\n+    pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n+        self.node_id_to_type_opt(pat.id)\n+    }\n+\n+    // Returns the type of an expression as a monotype.\n+    //\n+    // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+    // some cases, we insert `Adjustment` annotations such as auto-deref or\n+    // auto-ref.  The type returned by this function does not consider such\n+    // adjustments.  See `expr_ty_adjusted()` instead.\n+    //\n+    // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n+    // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n+    // instead of \"fn(ty) -> T with T = isize\".\n+    pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+        self.node_id_to_type(expr.id)\n+    }\n+\n+    pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+        self.node_id_to_type_opt(expr.id)\n+    }\n+\n+    /// Returns the type of `expr`, considering any `Adjustment`\n+    /// entry recorded for that expression.\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+        self.adjustments.get(&expr.id)\n+            .map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n+    }\n+\n+    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+        self.adjustments.get(&expr.id)\n+            .map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n+    }\n+\n+    pub fn is_method_call(&self, expr_id: NodeId) -> bool {\n+        self.method_map.contains_key(&ty::MethodCall::expr(expr_id))\n+    }\n+\n+    pub fn is_overloaded_autoderef(&self, expr_id: NodeId, autoderefs: u32) -> bool {\n+        self.method_map.contains_key(&ty::MethodCall::autoderef(expr_id, autoderefs))\n+    }\n+\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n+        Some(self.upvar_capture_map.get(&upvar_id).unwrap().clone())\n+    }\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n@@ -333,14 +403,10 @@ pub struct GlobalCtxt<'tcx> {\n     pub tables: RefCell<Tables<'tcx>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n-    pub impl_or_trait_items: RefCell<DepTrackingMap<maps::ImplOrTraitItems<'tcx>>>,\n+    pub associated_items: RefCell<DepTrackingMap<maps::AssociatedItems<'tcx>>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    pub impl_or_trait_item_def_ids: RefCell<DepTrackingMap<maps::ImplOrTraitItemDefIds<'tcx>>>,\n-\n-    /// A cache for the trait_items() routine; note that the routine\n-    /// itself pushes the `TraitItems` dependency node.\n-    trait_items_cache: RefCell<DepTrackingMap<maps::TraitItems<'tcx>>>,\n+    pub associated_item_def_ids: RefCell<DepTrackingMap<maps::AssociatedItemDefIds<'tcx>>>,\n \n     pub impl_trait_refs: RefCell<DepTrackingMap<maps::ImplTraitRefs<'tcx>>>,\n     pub trait_defs: RefCell<DepTrackingMap<maps::TraitDefs<'tcx>>>,\n@@ -381,16 +447,16 @@ pub struct GlobalCtxt<'tcx> {\n     pub tcache: RefCell<DepTrackingMap<maps::Tcache<'tcx>>>,\n \n     // Internal cache for metadata decoding. No need to track deps on this.\n-    pub rcache: RefCell<FnvHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+    pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n     // Cache for the type-contents routine. FIXME -- track deps?\n-    pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n+    pub tc_cache: RefCell<FxHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n \n     // FIXME no dep tracking, but we should be able to remove this\n     pub ty_param_defs: RefCell<NodeMap<ty::TypeParameterDef<'tcx>>>,\n \n     // FIXME dep tracking -- should be harmless enough\n-    pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n+    pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n     pub lang_items: middle::lang_items::LanguageItems,\n \n@@ -501,7 +567,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub data_layout: TargetDataLayout,\n \n     /// Cache for layouts computed from types.\n-    pub layout_cache: RefCell<FnvHashMap<Ty<'tcx>, &'tcx Layout>>,\n+    pub layout_cache: RefCell<FxHashMap<Ty<'tcx>, &'tcx Layout>>,\n \n     /// Used to prevent layout from recursing too deeply.\n     pub layout_depth: Cell<usize>,\n@@ -599,14 +665,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n-    pub fn node_types(self) -> Ref<'a, NodeMap<Ty<'tcx>>> {\n-        fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) -> &'a NodeMap<Ty<'tcx>> {\n-            &tables.node_types\n-        }\n-\n-        Ref::map(self.tables.borrow(), projection)\n-    }\n-\n     pub fn node_type_insert(self, id: NodeId, ty: Ty<'gcx>) {\n         self.tables.borrow_mut().node_types.insert(id, ty);\n     }\n@@ -739,7 +797,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             types: common_types,\n             named_region_map: named_region_map,\n             region_maps: region_maps,\n-            free_region_maps: RefCell::new(FnvHashMap()),\n+            free_region_maps: RefCell::new(FxHashMap()),\n             item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n@@ -758,13 +816,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             freevars: RefCell::new(freevars),\n             maybe_unused_trait_imports: maybe_unused_trait_imports,\n             tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            rcache: RefCell::new(FnvHashMap()),\n-            tc_cache: RefCell::new(FnvHashMap()),\n-            impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            impl_or_trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            trait_items_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            rcache: RefCell::new(FxHashMap()),\n+            tc_cache: RefCell::new(FxHashMap()),\n+            associated_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            associated_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n-            normalized_cache: RefCell::new(FnvHashMap()),\n+            normalized_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,\n             inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n@@ -784,7 +841,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: token::intern_and_get_ident(crate_name),\n             data_layout: data_layout,\n-            layout_cache: RefCell::new(FnvHashMap()),\n+            layout_cache: RefCell::new(FxHashMap()),\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n        }, f)\n@@ -1477,15 +1534,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_substs(iter::once(s).chain(t.into_iter().cloned()).map(Kind::from))\n     }\n \n-    pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'gcx>>> {\n-        self.trait_items_cache.memoize(trait_did, || {\n-            let def_ids = self.impl_or_trait_items(trait_did);\n-            Rc::new(def_ids.iter()\n-                           .map(|&def_id| self.impl_or_trait_item(def_id))\n-                           .collect())\n-        })\n-    }\n-\n     /// Obtain the representation annotation for a struct definition.\n     pub fn lookup_repr_hints(self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n         self.repr_hint_cache.memoize(did, || {"}, {"sha": "354658ec4397f3cd284e1a4a580f6db642616b87", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -45,7 +45,7 @@ use ty::adjustment;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n use std::fmt;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n@@ -176,8 +176,8 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         r.super_fold_with(self)\n     }\n \n-    fn fold_autoref(&mut self, ar: &adjustment::AutoRef<'tcx>)\n-                    -> adjustment::AutoRef<'tcx> {\n+    fn fold_autoref(&mut self, ar: &adjustment::AutoBorrow<'tcx>)\n+                    -> adjustment::AutoBorrow<'tcx> {\n         ar.super_fold_with(self)\n     }\n }\n@@ -225,7 +225,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n         value: &T,\n-        region_set: &mut FnvHashSet<&'tcx ty::Region>)\n+        region_set: &mut FxHashSet<&'tcx ty::Region>)\n         -> bool\n         where T : TypeFoldable<'tcx>\n     {\n@@ -319,14 +319,14 @@ struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::BoundRegion) -> &'tcx ty::Region + 'a),\n-    map: FnvHashMap<ty::BoundRegion, &'tcx ty::Region>\n+    map: FxHashMap<ty::BoundRegion, &'tcx ty::Region>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n-        -> (T, FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+        -> (T, FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n         where F : FnMut(ty::BoundRegion) -> &'tcx ty::Region,\n               T : TypeFoldable<'tcx>,\n     {\n@@ -390,22 +390,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// variables and equate `value` with something else, those\n     /// variables will also be equated.\n     pub fn collect_constrained_late_bound_regions<T>(&self, value: &Binder<T>)\n-                                                     -> FnvHashSet<ty::BoundRegion>\n+                                                     -> FxHashSet<ty::BoundRegion>\n         where T : TypeFoldable<'tcx>\n     {\n         self.collect_late_bound_regions(value, true)\n     }\n \n     /// Returns a set of all late-bound regions that appear in `value` anywhere.\n     pub fn collect_referenced_late_bound_regions<T>(&self, value: &Binder<T>)\n-                                                    -> FnvHashSet<ty::BoundRegion>\n+                                                    -> FxHashSet<ty::BoundRegion>\n         where T : TypeFoldable<'tcx>\n     {\n         self.collect_late_bound_regions(value, false)\n     }\n \n     fn collect_late_bound_regions<T>(&self, value: &Binder<T>, just_constraint: bool)\n-                                     -> FnvHashSet<ty::BoundRegion>\n+                                     -> FxHashSet<ty::BoundRegion>\n         where T : TypeFoldable<'tcx>\n     {\n         let mut collector = LateBoundRegionsCollector::new(just_constraint);\n@@ -450,7 +450,7 @@ impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n             tcx: tcx,\n             current_depth: 1,\n             fld_r: fld_r,\n-            map: FnvHashMap()\n+            map: FxHashMap()\n         }\n     }\n }\n@@ -650,15 +650,15 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n /// Collects all the late-bound regions it finds into a hash set.\n struct LateBoundRegionsCollector {\n     current_depth: u32,\n-    regions: FnvHashSet<ty::BoundRegion>,\n+    regions: FxHashSet<ty::BoundRegion>,\n     just_constrained: bool,\n }\n \n impl LateBoundRegionsCollector {\n     fn new(just_constrained: bool) -> Self {\n         LateBoundRegionsCollector {\n             current_depth: 1,\n-            regions: FnvHashSet(),\n+            regions: FxHashSet(),\n             just_constrained: just_constrained,\n         }\n     }"}, {"sha": "43abb61e7fcd83ff08943bd24180d8a96e922c21", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -16,7 +16,7 @@ use ty::{self, Ty};\n use std::cell::RefCell;\n use std::marker::PhantomData;\n use std::rc::Rc;\n-use syntax::{attr, ast};\n+use syntax::attr;\n \n macro_rules! dep_map_ty {\n     ($ty_name:ident : $node_name:ident ($key:ty) -> $value:ty) => {\n@@ -32,18 +32,16 @@ macro_rules! dep_map_ty {\n     }\n }\n \n-dep_map_ty! { ImplOrTraitItems: ImplOrTraitItems(DefId) -> ty::ImplOrTraitItem<'tcx> }\n+dep_map_ty! { AssociatedItems: AssociatedItems(DefId) -> ty::AssociatedItem }\n dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n-dep_map_ty! { ImplOrTraitItemDefIds: ImplOrTraitItemDefIds(DefId) -> Rc<Vec<DefId>> }\n+dep_map_ty! { AssociatedItemDefIds: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n-dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n-dep_map_ty! { InlinedClosures: Hir(DefId) -> ast::NodeId }\n dep_map_ty! { Mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>> }"}, {"sha": "1d260fd65feffba808d69a2217b61c51ba28544d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 165, "deletions": 342, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -10,9 +10,8 @@\n \n pub use self::Variance::*;\n pub use self::DtorKind::*;\n-pub use self::ImplOrTraitItemContainer::*;\n+pub use self::AssociatedItemContainer::*;\n pub use self::BorrowKind::*;\n-pub use self::ImplOrTraitItem::*;\n pub use self::IntVarValue::*;\n pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n@@ -31,7 +30,7 @@ use ty::subst::{Subst, Substs};\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n use util::nodemap::NodeSet;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -135,12 +134,12 @@ impl DtorKind {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum ImplOrTraitItemContainer {\n+pub enum AssociatedItemContainer {\n     TraitContainer(DefId),\n     ImplContainer(DefId),\n }\n \n-impl ImplOrTraitItemContainer {\n+impl AssociatedItemContainer {\n     pub fn id(&self) -> DefId {\n         match *self {\n             TraitContainer(id) => id,\n@@ -183,58 +182,34 @@ impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n     }\n }\n \n-#[derive(Clone)]\n-pub enum ImplOrTraitItem<'tcx> {\n-    ConstTraitItem(Rc<AssociatedConst<'tcx>>),\n-    MethodTraitItem(Rc<Method<'tcx>>),\n-    TypeTraitItem(Rc<AssociatedType<'tcx>>),\n-}\n-\n-impl<'tcx> ImplOrTraitItem<'tcx> {\n-    pub fn def(&self) -> Def {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => Def::AssociatedConst(associated_const.def_id),\n-            MethodTraitItem(ref method) => Def::Method(method.def_id),\n-            TypeTraitItem(ref ty) => Def::AssociatedTy(ty.def_id),\n-        }\n-    }\n-\n-    pub fn def_id(&self) -> DefId {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.def_id,\n-            MethodTraitItem(ref method) => method.def_id,\n-            TypeTraitItem(ref associated_type) => associated_type.def_id,\n-        }\n-    }\n-\n-    pub fn name(&self) -> Name {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.name,\n-            MethodTraitItem(ref method) => method.name,\n-            TypeTraitItem(ref associated_type) => associated_type.name,\n-        }\n-    }\n+#[derive(Copy, Clone, Debug)]\n+pub struct AssociatedItem {\n+    pub def_id: DefId,\n+    pub name: Name,\n+    pub kind: AssociatedKind,\n+    pub vis: Visibility,\n+    pub defaultness: hir::Defaultness,\n+    pub has_value: bool,\n+    pub container: AssociatedItemContainer,\n \n-    pub fn vis(&self) -> Visibility {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.vis,\n-            MethodTraitItem(ref method) => method.vis,\n-            TypeTraitItem(ref associated_type) => associated_type.vis,\n-        }\n-    }\n+    /// Whether this is a method with an explicit self\n+    /// as its first argument, allowing method calls.\n+    pub method_has_self_argument: bool,\n+}\n \n-    pub fn container(&self) -> ImplOrTraitItemContainer {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => associated_const.container,\n-            MethodTraitItem(ref method) => method.container,\n-            TypeTraitItem(ref associated_type) => associated_type.container,\n-        }\n-    }\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n+pub enum AssociatedKind {\n+    Const,\n+    Method,\n+    Type\n+}\n \n-    pub fn as_opt_method(&self) -> Option<Rc<Method<'tcx>>> {\n-        match *self {\n-            MethodTraitItem(ref m) => Some((*m).clone()),\n-            _ => None,\n+impl AssociatedItem {\n+    pub fn def(&self) -> Def {\n+        match self.kind {\n+            AssociatedKind::Const => Def::AssociatedConst(self.def_id),\n+            AssociatedKind::Method => Def::Method(self.def_id),\n+            AssociatedKind::Type => Def::AssociatedTy(self.def_id),\n         }\n     }\n }\n@@ -308,64 +283,6 @@ impl Visibility {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Method<'tcx> {\n-    pub name: Name,\n-    pub generics: &'tcx Generics<'tcx>,\n-    pub predicates: GenericPredicates<'tcx>,\n-    pub fty: &'tcx BareFnTy<'tcx>,\n-    pub explicit_self: ExplicitSelfCategory<'tcx>,\n-    pub vis: Visibility,\n-    pub defaultness: hir::Defaultness,\n-    pub has_body: bool,\n-    pub def_id: DefId,\n-    pub container: ImplOrTraitItemContainer,\n-}\n-\n-impl<'tcx> Method<'tcx> {\n-    pub fn container_id(&self) -> DefId {\n-        match self.container {\n-            TraitContainer(id) => id,\n-            ImplContainer(id) => id,\n-        }\n-    }\n-}\n-\n-impl<'tcx> PartialEq for Method<'tcx> {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool { self.def_id == other.def_id }\n-}\n-\n-impl<'tcx> Eq for Method<'tcx> {}\n-\n-impl<'tcx> Hash for Method<'tcx> {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        self.def_id.hash(s)\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-pub struct AssociatedConst<'tcx> {\n-    pub name: Name,\n-    pub ty: Ty<'tcx>,\n-    pub vis: Visibility,\n-    pub defaultness: hir::Defaultness,\n-    pub def_id: DefId,\n-    pub container: ImplOrTraitItemContainer,\n-    pub has_value: bool\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-pub struct AssociatedType<'tcx> {\n-    pub name: Name,\n-    pub ty: Option<Ty<'tcx>>,\n-    pub vis: Visibility,\n-    pub defaultness: hir::Defaultness,\n-    pub def_id: DefId,\n-    pub container: ImplOrTraitItemContainer,\n-}\n-\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Copy)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n@@ -418,7 +335,7 @@ impl MethodCall {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap<'tcx> = FnvHashMap<MethodCall, MethodCallee<'tcx>>;\n+pub type MethodMap<'tcx> = FxHashMap<MethodCall, MethodCallee<'tcx>>;\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n@@ -650,7 +567,7 @@ pub struct UpvarBorrow<'tcx> {\n     pub region: &'tcx ty::Region,\n }\n \n-pub type UpvarCaptureMap<'tcx> = FnvHashMap<UpvarId, UpvarCapture<'tcx>>;\n+pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n #[derive(Copy, Clone)]\n pub struct ClosureUpvar<'tcx> {\n@@ -1251,10 +1168,10 @@ pub struct ParameterEnvironment<'tcx> {\n     pub free_id_outlive: CodeExtent,\n \n     /// A cache for `moves_by_default`.\n-    pub is_copy_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n+    pub is_copy_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n \n     /// A cache for `type_is_sized`\n-    pub is_sized_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n+    pub is_sized_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n }\n \n impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n@@ -1267,8 +1184,8 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             implicit_region_bound: self.implicit_region_bound,\n             caller_bounds: caller_bounds,\n             free_id_outlive: self.free_id_outlive,\n-            is_copy_cache: RefCell::new(FnvHashMap()),\n-            is_sized_cache: RefCell::new(FnvHashMap()),\n+            is_copy_cache: RefCell::new(FxHashMap()),\n+            is_sized_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -1288,19 +1205,10 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n-                        let method_def_id = tcx.map.local_def_id(id);\n-                        match tcx.impl_or_trait_item(method_def_id) {\n-                            MethodTraitItem(ref method_ty) => {\n-                                tcx.construct_parameter_environment(\n-                                    impl_item.span,\n-                                    method_ty.def_id,\n-                                    tcx.region_maps.call_site_extent(id, body.id))\n-                            }\n-                            _ => {\n-                                bug!(\"ParameterEnvironment::for_item(): \\\n-                                      got non-method item from impl method?!\")\n-                            }\n-                        }\n+                        tcx.construct_parameter_environment(\n+                            impl_item.span,\n+                            tcx.map.local_def_id(id),\n+                            tcx.region_maps.call_site_extent(id, body.id))\n                     }\n                 }\n             }\n@@ -1319,27 +1227,17 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n-                        let method_def_id = tcx.map.local_def_id(id);\n-                        match tcx.impl_or_trait_item(method_def_id) {\n-                            MethodTraitItem(ref method_ty) => {\n-                                let extent = if let Some(ref body) = *body {\n-                                    // default impl: use call_site extent as free_id_outlive bound.\n-                                    tcx.region_maps.call_site_extent(id, body.id)\n-                                } else {\n-                                    // no default impl: use item extent as free_id_outlive bound.\n-                                    tcx.region_maps.item_extent(id)\n-                                };\n-                                tcx.construct_parameter_environment(\n-                                    trait_item.span,\n-                                    method_ty.def_id,\n-                                    extent)\n-                            }\n-                            _ => {\n-                                bug!(\"ParameterEnvironment::for_item(): \\\n-                                      got non-method item from provided \\\n-                                      method?!\")\n-                            }\n-                        }\n+                        let extent = if let Some(ref body) = *body {\n+                            // default impl: use call_site extent as free_id_outlive bound.\n+                            tcx.region_maps.call_site_extent(id, body.id)\n+                        } else {\n+                            // no default impl: use item extent as free_id_outlive bound.\n+                            tcx.region_maps.item_extent(id)\n+                        };\n+                        tcx.construct_parameter_environment(\n+                            trait_item.span,\n+                            tcx.map.local_def_id(id),\n+                            extent)\n                     }\n                 }\n             }\n@@ -2065,7 +1963,7 @@ impl LvaluePreference {\n }\n \n /// Helper for looking things up in the various maps that are populated during\n-/// typeck::collect (e.g., `tcx.impl_or_trait_items`, `tcx.tcache`, etc).  All of\n+/// typeck::collect (e.g., `tcx.associated_items`, `tcx.tcache`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded\n /// into the map by the `typeck::collect` phase.  If the def-id is external,\n /// then we have to go consult the crate loading code (and cache the result for\n@@ -2120,80 +2018,8 @@ impl BorrowKind {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn node_id_to_type(self, id: NodeId) -> Ty<'gcx> {\n-        match self.node_id_to_type_opt(id) {\n-           Some(ty) => ty,\n-           None => bug!(\"node_id_to_type: no type for node `{}`\",\n-                        self.map.node_to_string(id))\n-        }\n-    }\n-\n-    pub fn node_id_to_type_opt(self, id: NodeId) -> Option<Ty<'gcx>> {\n-        self.tables.borrow().node_types.get(&id).cloned()\n-    }\n-\n-    pub fn node_id_item_substs(self, id: NodeId) -> ItemSubsts<'gcx> {\n-        match self.tables.borrow().item_substs.get(&id) {\n-            None => ItemSubsts {\n-                substs: self.global_tcx().intern_substs(&[])\n-            },\n-            Some(ts) => ts.clone(),\n-        }\n-    }\n-\n-    // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n-    // doesn't provide type parameter substitutions.\n-    pub fn pat_ty(self, pat: &hir::Pat) -> Ty<'gcx> {\n-        self.node_id_to_type(pat.id)\n-    }\n-    pub fn pat_ty_opt(self, pat: &hir::Pat) -> Option<Ty<'gcx>> {\n-        self.node_id_to_type_opt(pat.id)\n-    }\n-\n-    // Returns the type of an expression as a monotype.\n-    //\n-    // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n-    // some cases, we insert `AutoAdjustment` annotations such as auto-deref or\n-    // auto-ref.  The type returned by this function does not consider such\n-    // adjustments.  See `expr_ty_adjusted()` instead.\n-    //\n-    // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n-    // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n-    // instead of \"fn(ty) -> T with T = isize\".\n-    pub fn expr_ty(self, expr: &hir::Expr) -> Ty<'gcx> {\n-        self.node_id_to_type(expr.id)\n-    }\n-\n-    pub fn expr_ty_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n-        self.node_id_to_type_opt(expr.id)\n-    }\n-\n-    /// Returns the type of `expr`, considering any `AutoAdjustment`\n-    /// entry recorded for that expression.\n-    ///\n-    /// It would almost certainly be better to store the adjusted ty in with\n-    /// the `AutoAdjustment`, but I opted not to do this because it would\n-    /// require serializing and deserializing the type and, although that's not\n-    /// hard to do, I just hate that code so much I didn't want to touch it\n-    /// unless it was to fix it properly, which seemed a distraction from the\n-    /// thread at hand! -nmatsakis\n-    pub fn expr_ty_adjusted(self, expr: &hir::Expr) -> Ty<'gcx> {\n-        self.expr_ty(expr)\n-            .adjust(self.global_tcx(), expr.span, expr.id,\n-                    self.tables.borrow().adjustments.get(&expr.id),\n-                    |method_call| {\n-            self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n-        })\n-    }\n-\n-    pub fn expr_ty_adjusted_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n-        self.expr_ty_opt(expr).map(|t| t.adjust(self.global_tcx(),\n-                                                expr.span,\n-                                                expr.id,\n-                                                self.tables.borrow().adjustments.get(&expr.id),\n-                                                |method_call| {\n-            self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n-        }))\n+    pub fn tables(self) -> Ref<'a, Tables<'gcx>> {\n+        self.tables.borrow()\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n@@ -2276,13 +2102,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn provided_trait_methods(self, id: DefId) -> Vec<Rc<Method<'gcx>>> {\n-        self.impl_or_trait_items(id).iter().filter_map(|&def_id| {\n-            match self.impl_or_trait_item(def_id) {\n-                MethodTraitItem(ref m) if m.has_body => Some(m.clone()),\n-                _ => None\n-            }\n-        }).collect()\n+    pub fn provided_trait_methods(self, id: DefId) -> Vec<AssociatedItem> {\n+        self.associated_items(id)\n+            .filter(|item| item.kind == AssociatedKind::Method && item.has_value)\n+            .collect()\n     }\n \n     pub fn trait_impl_polarity(self, id: DefId) -> hir::ImplPolarity {\n@@ -2315,17 +2138,105 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn impl_or_trait_item(self, id: DefId) -> ImplOrTraitItem<'gcx> {\n-        lookup_locally_or_in_crate_store(\n-            \"impl_or_trait_items\", id, &self.impl_or_trait_items,\n-            || self.sess.cstore.impl_or_trait_item(self.global_tcx(), id)\n-                   .expect(\"missing ImplOrTraitItem in metadata\"))\n+    pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n+        self.associated_items.memoize(def_id, || {\n+            if !def_id.is_local() {\n+                return self.sess.cstore.associated_item(self.global_tcx(), def_id)\n+                           .expect(\"missing AssociatedItem in metadata\");\n+            }\n+\n+            let id = self.map.as_local_node_id(def_id).unwrap();\n+            let parent_id = self.map.get_parent(id);\n+            let parent_def_id = self.map.local_def_id(parent_id);\n+            match self.map.get(id) {\n+                ast_map::NodeTraitItem(trait_item) => {\n+                    let (kind, has_self, has_value) = match trait_item.node {\n+                        hir::MethodTraitItem(ref sig, ref body) => {\n+                            (AssociatedKind::Method, sig.decl.get_self().is_some(),\n+                             body.is_some())\n+                        }\n+                        hir::ConstTraitItem(_, ref value) => {\n+                            (AssociatedKind::Const, false, value.is_some())\n+                        }\n+                        hir::TypeTraitItem(_, ref ty) => {\n+                            (AssociatedKind::Type, false, ty.is_some())\n+                        }\n+                    };\n+\n+                    AssociatedItem {\n+                        name: trait_item.name,\n+                        kind: kind,\n+                        vis: Visibility::from_hir(&hir::Inherited, id, self),\n+                        defaultness: hir::Defaultness::Default,\n+                        has_value: has_value,\n+                        def_id: def_id,\n+                        container: TraitContainer(parent_def_id),\n+                        method_has_self_argument: has_self\n+                    }\n+                }\n+                ast_map::NodeImplItem(impl_item) => {\n+                    let (kind, has_self) = match impl_item.node {\n+                        hir::ImplItemKind::Method(ref sig, _) => {\n+                            (AssociatedKind::Method, sig.decl.get_self().is_some())\n+                        }\n+                        hir::ImplItemKind::Const(..) => (AssociatedKind::Const, false),\n+                        hir::ImplItemKind::Type(..) => (AssociatedKind::Type, false)\n+                    };\n+\n+                    // Trait impl items are always public.\n+                    let public = hir::Public;\n+                    let parent_item = self.map.expect_item(parent_id);\n+                    let vis = if let hir::ItemImpl(.., Some(_), _, _) = parent_item.node {\n+                        &public\n+                    } else {\n+                        &impl_item.vis\n+                    };\n+\n+                    AssociatedItem {\n+                        name: impl_item.name,\n+                        kind: kind,\n+                        vis: Visibility::from_hir(vis, id, self),\n+                        defaultness: impl_item.defaultness,\n+                        has_value: true,\n+                        def_id: def_id,\n+                        container: ImplContainer(parent_def_id),\n+                        method_has_self_argument: has_self\n+                    }\n+                }\n+                item => bug!(\"associated_item: {:?} not an associated item\", item)\n+            }\n+        })\n     }\n \n-    pub fn impl_or_trait_items(self, id: DefId) -> Rc<Vec<DefId>> {\n-        lookup_locally_or_in_crate_store(\n-            \"impl_or_trait_items\", id, &self.impl_or_trait_item_def_ids,\n-            || Rc::new(self.sess.cstore.impl_or_trait_items(id)))\n+    pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n+        self.associated_item_def_ids.memoize(def_id, || {\n+            if !def_id.is_local() {\n+                return Rc::new(self.sess.cstore.associated_item_def_ids(def_id));\n+            }\n+\n+            let id = self.map.as_local_node_id(def_id).unwrap();\n+            let item = self.map.expect_item(id);\n+            match item.node {\n+                hir::ItemTrait(.., ref trait_items) => {\n+                    Rc::new(trait_items.iter().map(|trait_item| {\n+                        self.map.local_def_id(trait_item.id)\n+                    }).collect())\n+                }\n+                hir::ItemImpl(.., ref impl_items) => {\n+                    Rc::new(impl_items.iter().map(|impl_item| {\n+                        self.map.local_def_id(impl_item.id)\n+                    }).collect())\n+                }\n+                _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")\n+            }\n+        })\n+    }\n+\n+    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+    pub fn associated_items(self, def_id: DefId)\n+                            -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+        let def_ids = self.associated_item_def_ids(def_id);\n+        (0..def_ids.len()).map(move |i| self.associated_item(def_ids[i]))\n     }\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n@@ -2611,31 +2522,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         def.flags.set(def.flags.get() | TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n-    /// Load primitive inherent implementations if necessary\n-    pub fn populate_implementations_for_primitive_if_necessary(self,\n-                                                               primitive_def_id: DefId) {\n-        if primitive_def_id.is_local() {\n-            return\n-        }\n-\n-        // The primitive is not local, hence we are reading this out\n-        // of metadata.\n-        let _ignore = self.dep_graph.in_ignore();\n-\n-        if self.populated_external_primitive_impls.borrow().contains(&primitive_def_id) {\n-            return\n-        }\n-\n-        debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\",\n-               primitive_def_id);\n-\n-        let impl_items = self.sess.cstore.impl_or_trait_items(primitive_def_id);\n-\n-        // Store the implementation info.\n-        self.impl_or_trait_item_def_ids.borrow_mut().insert(primitive_def_id, Rc::new(impl_items));\n-        self.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n-    }\n-\n     /// Populates the type context with all the inherent implementations for\n     /// the given type if necessary.\n     pub fn populate_inherent_implementations_for_type_if_necessary(self,\n@@ -2656,11 +2542,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                type_id);\n \n         let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n-        for &impl_def_id in &inherent_impls {\n-            // Store the implementation info.\n-            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n-            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n-        }\n \n         self.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n         self.populated_external_types.borrow_mut().insert(type_id);\n@@ -2689,23 +2570,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         for impl_def_id in self.sess.cstore.implementations_of_trait(Some(trait_id)) {\n-            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n \n             // Record the trait->implementation mapping.\n             let parent = self.sess.cstore.impl_parent(impl_def_id).unwrap_or(trait_id);\n             def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n-\n-            // For any methods that use a default implementation, add them to\n-            // the map. This is a bit unfortunate.\n-            for &impl_item_def_id in &impl_items {\n-                // load impl items eagerly for convenience\n-                // FIXME: we may want to load these lazily\n-                self.impl_or_trait_item(impl_item_def_id);\n-            }\n-\n-            // Store the implementation info.\n-            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n         }\n \n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n@@ -2751,17 +2620,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.impl_or_trait_item(self.global_tcx(), def_id)\n+            return self.sess.cstore.associated_item(self.global_tcx(), def_id)\n                        .and_then(|item| {\n-                match item.container() {\n+                match item.container {\n                     TraitContainer(_) => None,\n                     ImplContainer(def_id) => Some(def_id),\n                 }\n             });\n         }\n-        match self.impl_or_trait_items.borrow().get(&def_id).cloned() {\n+        match self.associated_items.borrow().get(&def_id).cloned() {\n             Some(trait_item) => {\n-                match trait_item.container() {\n+                match trait_item.container {\n                     TraitContainer(_) => None,\n                     ImplContainer(def_id) => Some(def_id),\n                 }\n@@ -2777,9 +2646,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if def_id.krate != LOCAL_CRATE {\n             return self.sess.cstore.trait_of_item(def_id);\n         }\n-        match self.impl_or_trait_items.borrow().get(&def_id) {\n-            Some(impl_or_trait_item) => {\n-                match impl_or_trait_item.container() {\n+        match self.associated_items.borrow().get(&def_id) {\n+            Some(associated_item) => {\n+                match associated_item.container {\n                     TraitContainer(def_id) => Some(def_id),\n                     ImplContainer(_) => None\n                 }\n@@ -2788,30 +2657,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// If the given def ID describes an item belonging to a trait, (either a\n-    /// default method or an implementation of a trait method), return the ID of\n-    /// the method inside trait definition (this means that if the given def ID\n-    /// is already that of the original trait method, then the return value is\n-    /// the same).\n-    /// Otherwise, return `None`.\n-    pub fn trait_item_of_item(self, def_id: DefId) -> Option<DefId> {\n-        let impl_or_trait_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n-            Some(m) => m.clone(),\n-            None => return None,\n-        };\n-        match impl_or_trait_item.container() {\n-            TraitContainer(_) => Some(impl_or_trait_item.def_id()),\n-            ImplContainer(def_id) => {\n-                self.trait_id_of_impl(def_id).and_then(|trait_did| {\n-                    let name = impl_or_trait_item.name();\n-                    self.trait_items(trait_did).iter()\n-                        .find(|item| item.name() == name)\n-                        .map(|item| item.def_id())\n-                })\n-            }\n-        }\n-    }\n-\n     /// Construct a parameter environment suitable for static contexts or other contexts where there\n     /// are no free type/lifetime parameters in scope.\n     pub fn empty_parameter_environment(self) -> ParameterEnvironment<'tcx> {\n@@ -2824,8 +2669,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             caller_bounds: Vec::new(),\n             implicit_region_bound: self.mk_region(ty::ReEmpty),\n             free_id_outlive: free_id_outlive,\n-            is_copy_cache: RefCell::new(FnvHashMap()),\n-            is_sized_cache: RefCell::new(FnvHashMap()),\n+            is_copy_cache: RefCell::new(FxHashMap()),\n+            is_sized_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -2896,8 +2741,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             implicit_region_bound: tcx.mk_region(ty::ReScope(free_id_outlive)),\n             caller_bounds: predicates,\n             free_id_outlive: free_id_outlive,\n-            is_copy_cache: RefCell::new(FnvHashMap()),\n-            is_sized_cache: RefCell::new(FnvHashMap()),\n+            is_copy_cache: RefCell::new(FxHashMap()),\n+            is_sized_cache: RefCell::new(FxHashMap()),\n         };\n \n         let cause = traits::ObligationCause::misc(span, free_id_outlive.node_id(&self.region_maps));\n@@ -2908,19 +2753,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_region(ty::ReScope(self.region_maps.node_extent(id)))\n     }\n \n-    pub fn is_method_call(self, expr_id: NodeId) -> bool {\n-        self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n-    }\n-\n-    pub fn is_overloaded_autoderef(self, expr_id: NodeId, autoderefs: u32) -> bool {\n-        self.tables.borrow().method_map.contains_key(&MethodCall::autoderef(expr_id,\n-                                                                            autoderefs))\n-    }\n-\n-    pub fn upvar_capture(self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n-        Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n-    }\n-\n     pub fn visit_all_items_in_krate<V,F>(self,\n                                          dep_node_fn: F,\n                                          visitor: &mut V)\n@@ -2941,15 +2773,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// The category of explicit self.\n-#[derive(Clone, Copy, Eq, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n-pub enum ExplicitSelfCategory<'tcx> {\n-    Static,\n-    ByValue,\n-    ByReference(&'tcx Region, hir::Mutability),\n-    ByBox,\n-}\n-\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,"}, {"sha": "51feab9d40c9a72d0d02bea8b7e3b2969ff1bc0b", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -12,8 +12,7 @@\n // refers to rules defined in RFC 1214 (`OutlivesFooBar`), so see that\n // RFC for reference.\n \n-use infer::InferCtxt;\n-use ty::{self, Ty, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n #[derive(Debug)]\n pub enum Component<'tcx> {\n@@ -55,9 +54,9 @@ pub enum Component<'tcx> {\n     EscapingProjection(Vec<Component<'tcx>>),\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns all the things that must outlive `'a` for the condition\n-    /// `ty0: 'a` to hold.\n+    /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n     pub fn outlives_components(&self, ty0: Ty<'tcx>)\n                                -> Vec<Component<'tcx>> {\n         let mut components = vec![];\n@@ -148,16 +147,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            // If we encounter an inference variable, try to resolve it\n-            // and proceed with resolved version. If we cannot resolve it,\n-            // then record the unresolved variable as a component.\n-            ty::TyInfer(_) => {\n-                let ty = self.resolve_type_vars_if_possible(&ty);\n-                if let ty::TyInfer(infer_ty) = ty.sty {\n-                    out.push(Component::UnresolvedInferenceVariable(infer_ty));\n-                } else {\n-                    self.compute_components(ty, out);\n-                }\n+            // We assume that inference variables are fully resolved.\n+            // So, if we encounter an inference variable, just record\n+            // the unresolved variable as a component.\n+            ty::TyInfer(infer_ty) => {\n+                out.push(Component::UnresolvedInferenceVariable(infer_ty));\n             }\n \n             // Most types do not introduce any region binders, nor"}, {"sha": "9ca911837b517855e3dcbce3e0aa5c69b22a4bfd", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -218,15 +218,15 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ItemSubsts<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoRef<'a> {\n-    type Lifted = ty::adjustment::AutoRef<'tcx>;\n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n+    type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            ty::adjustment::AutoPtr(r, m) => {\n-                tcx.lift(&r).map(|r| ty::adjustment::AutoPtr(r, m))\n+            ty::adjustment::AutoBorrow::Ref(r, m) => {\n+                tcx.lift(&r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n             }\n-            ty::adjustment::AutoUnsafe(m) => {\n-                Some(ty::adjustment::AutoUnsafe(m))\n+            ty::adjustment::AutoBorrow::RawPtr(m) => {\n+                Some(ty::adjustment::AutoBorrow::RawPtr(m))\n             }\n         }\n     }\n@@ -676,13 +676,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ty::adjustment::AutoPtr(ref r, m) => {\n-                ty::adjustment::AutoPtr(r.fold_with(folder), m)\n+            ty::adjustment::AutoBorrow::Ref(ref r, m) => {\n+                ty::adjustment::AutoBorrow::Ref(r.fold_with(folder), m)\n             }\n-            ty::adjustment::AutoUnsafe(m) => ty::adjustment::AutoUnsafe(m)\n+            ty::adjustment::AutoBorrow::RawPtr(m) => ty::adjustment::AutoBorrow::RawPtr(m)\n         }\n     }\n \n@@ -692,8 +692,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            ty::adjustment::AutoPtr(r, _m) => r.visit_with(visitor),\n-            ty::adjustment::AutoUnsafe(_m) => false,\n+            ty::adjustment::AutoBorrow::Ref(r, _m) => r.visit_with(visitor),\n+            ty::adjustment::AutoBorrow::RawPtr(_m) => false,\n         }\n     }\n }"}, {"sha": "fc32029948388d3046d37672b55e440e12d3a225", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -16,7 +16,7 @@ use ty::fast_reject;\n use ty::{Ty, TyCtxt, TraitRef};\n use std::cell::{Cell, RefCell};\n use hir;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n /// As `TypeScheme` but for a trait ref.\n pub struct TraitDef<'tcx> {\n@@ -55,7 +55,7 @@ pub struct TraitDef<'tcx> {\n \n     /// Impls of the trait.\n     nonblanket_impls: RefCell<\n-        FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n+        FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n     >,\n \n     /// Blanket impls associated with the trait.\n@@ -84,7 +84,7 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n             unsafety: unsafety,\n             generics: generics,\n             trait_ref: trait_ref,\n-            nonblanket_impls: RefCell::new(FnvHashMap()),\n+            nonblanket_impls: RefCell::new(FxHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n             specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),"}, {"sha": "b1aeaeb48d144c771aca644a7780a699754d01c8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -20,7 +20,7 @@ use ty::{Disr, ParameterEnvironment};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n \n@@ -594,7 +594,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     fn impls_bound(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    param_env: &ParameterEnvironment<'tcx>,\n                    bound: ty::BuiltinBound,\n-                   cache: &RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n+                   cache: &RefCell<FxHashMap<Ty<'tcx>, bool>>,\n                    span: Span) -> bool\n     {\n         if self.has_param_types() || self.has_self_ty() {"}, {"sha": "155fa4989ea3cb716452b7b5bda64d89ae7e6207", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -178,7 +178,8 @@ pub fn implied_bounds<'a, 'gcx, 'tcx>(\n                         match infcx.tcx.no_late_bound_regions(data) {\n                             None => vec![],\n                             Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                                let components = infcx.outlives_components(ty_a);\n+                                let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n+                                let components = infcx.tcx.outlives_components(ty_a);\n                                 implied_bounds_from_components(r_b, components)\n                             }\n                         },\n@@ -497,7 +498,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n             let explicit_bound = data.region_bound;\n \n             for implicit_bound in implicit_bounds {\n-                let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n+                let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n                 let outlives = ty::Binder(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n                 self.out.push(traits::Obligation::new(cause, outlives.to_predicate()));\n             }"}, {"sha": "7cd5fd78df528981329792c6f9585bf522e6d81a", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -75,6 +75,26 @@ pub fn duration_to_secs_str(dur: Duration) -> String {\n     format!(\"{:.3}\", secs)\n }\n \n+pub fn to_readable_str(mut val: usize) -> String {\n+    let mut groups = vec![];\n+    loop {\n+        let group = val % 1000;\n+\n+        val /= 1000;\n+\n+        if val == 0 {\n+            groups.push(format!(\"{}\", group));\n+            break\n+        } else {\n+            groups.push(format!(\"{:03}\", group));\n+        }\n+    }\n+\n+    groups.reverse();\n+\n+    groups.join(\"_\")\n+}\n+\n pub fn record_time<T, F>(accu: &Cell<Duration>, f: F) -> T where\n     F: FnOnce() -> T,\n {\n@@ -264,3 +284,17 @@ pub fn path2cstr(p: &Path) -> CString {\n pub fn path2cstr(p: &Path) -> CString {\n     CString::new(p.to_str().unwrap()).unwrap()\n }\n+\n+\n+#[test]\n+fn test_to_readable_str() {\n+    assert_eq!(\"0\", to_readable_str(0));\n+    assert_eq!(\"1\", to_readable_str(1));\n+    assert_eq!(\"99\", to_readable_str(99));\n+    assert_eq!(\"999\", to_readable_str(999));\n+    assert_eq!(\"1_000\", to_readable_str(1_000));\n+    assert_eq!(\"1_001\", to_readable_str(1_001));\n+    assert_eq!(\"999_999\", to_readable_str(999_999));\n+    assert_eq!(\"1_000_000\", to_readable_str(1_000_000));\n+    assert_eq!(\"1_234_567\", to_readable_str(1_234_567));\n+}"}, {"sha": "b03011fcb216dbc4e783f695fde007bc384936b5", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -15,17 +15,17 @@\n use hir::def_id::DefId;\n use syntax::ast;\n \n-pub use rustc_data_structures::fnv::FnvHashMap;\n-pub use rustc_data_structures::fnv::FnvHashSet;\n+pub use rustc_data_structures::fx::FxHashMap;\n+pub use rustc_data_structures::fx::FxHashSet;\n \n-pub type NodeMap<T> = FnvHashMap<ast::NodeId, T>;\n-pub type DefIdMap<T> = FnvHashMap<DefId, T>;\n+pub type NodeMap<T> = FxHashMap<ast::NodeId, T>;\n+pub type DefIdMap<T> = FxHashMap<DefId, T>;\n \n-pub type NodeSet = FnvHashSet<ast::NodeId>;\n-pub type DefIdSet = FnvHashSet<DefId>;\n+pub type NodeSet = FxHashSet<ast::NodeId>;\n+pub type DefIdSet = FxHashSet<DefId>;\n \n-pub fn NodeMap<T>() -> NodeMap<T> { FnvHashMap() }\n-pub fn DefIdMap<T>() -> DefIdMap<T> { FnvHashMap() }\n-pub fn NodeSet() -> NodeSet { FnvHashSet() }\n-pub fn DefIdSet() -> DefIdSet { FnvHashSet() }\n+pub fn NodeMap<T>() -> NodeMap<T> { FxHashMap() }\n+pub fn DefIdMap<T>() -> DefIdMap<T> { FxHashMap() }\n+pub fn NodeSet() -> NodeSet { FxHashSet() }\n+pub fn DefIdSet() -> DefIdSet { FxHashSet() }\n "}, {"sha": "01b44ced8e08ec0308e0b3ba0fd88af13a4b1176", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 51, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -447,32 +447,9 @@ impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::adjustment::AutoAdjustment<'tcx> {\n+impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::adjustment::AdjustNeverToAny(ref target) => {\n-                write!(f, \"AdjustNeverToAny({:?})\", target)\n-            }\n-            ty::adjustment::AdjustReifyFnPointer => {\n-                write!(f, \"AdjustReifyFnPointer\")\n-            }\n-            ty::adjustment::AdjustUnsafeFnPointer => {\n-                write!(f, \"AdjustUnsafeFnPointer\")\n-            }\n-            ty::adjustment::AdjustMutToConstPointer => {\n-                write!(f, \"AdjustMutToConstPointer\")\n-            }\n-            ty::adjustment::AdjustDerefRef(ref data) => {\n-                write!(f, \"{:?}\", data)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::adjustment::AutoDerefRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"AutoDerefRef({}, unsize={:?}, {:?})\",\n-               self.autoderefs, self.unsize, self.autoref)\n+        write!(f, \"{:?} -> {}\", self.kind, self.target)\n     }\n }\n \n@@ -693,18 +670,6 @@ impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ImplOrTraitItem<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ImplOrTraitItem(\")?;\n-        match *self {\n-            ty::ImplOrTraitItem::MethodTraitItem(ref i) => write!(f, \"{:?}\", i),\n-            ty::ImplOrTraitItem::ConstTraitItem(ref i) => write!(f, \"{:?}\", i),\n-            ty::ImplOrTraitItem::TypeTraitItem(ref i) => write!(f, \"{:?}\", i),\n-        }?;\n-        write!(f, \")\")\n-    }\n-}\n-\n impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"fn\")?;\n@@ -1018,20 +983,6 @@ impl fmt::Display for ty::InferTy {\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::ExplicitSelfCategory<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(match *self {\n-            ty::ExplicitSelfCategory::Static => \"static\",\n-            ty::ExplicitSelfCategory::ByValue => \"self\",\n-            ty::ExplicitSelfCategory::ByReference(_, hir::MutMutable) => {\n-                \"&mut self\"\n-            }\n-            ty::ExplicitSelfCategory::ByReference(_, hir::MutImmutable) => \"&self\",\n-            ty::ExplicitSelfCategory::ByBox => \"Box<self>\",\n-        })\n-    }\n-}\n-\n impl fmt::Display for ty::ParamTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.name)"}, {"sha": "6ba1732e67f7930937fc493cda5ee3c4aa92b776", "filename": "src/librustc_back/target/aarch64_unknown_fuchsia.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_fuchsia.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use target::{Target, TargetResult};\n+use target::{Target, TargetOptions, TargetResult};\n \n pub fn target() -> TargetResult {\n     let mut base = super::fuchsia_base::opts();\n@@ -23,6 +23,9 @@ pub fn target() -> TargetResult {\n         target_os: \"fuchsia\".to_string(),\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n-        options: base,\n+        options: TargetOptions {\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            .. base\n+        },\n     })\n }"}, {"sha": "5ed628d7dcae5f8be847efa4e5c71043bfd67c3f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -190,7 +190,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      fn_id: ast::NodeId,\n                                      decl: &hir::FnDecl,\n-                                     body: &hir::Block) {\n+                                     body: &hir::Expr) {\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);"}, {"sha": "51574868f9bfb5b72a2f8483f4356bef9539311b", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -37,7 +37,7 @@ pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              decl_id: ast::NodeId,\n                              _decl_span: Span,\n                              var_id: ast::NodeId) {\n-    let ty = bccx.tcx.node_id_to_type(var_id);\n+    let ty = bccx.tcx.tables().node_id_to_type(var_id);\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), ty));\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }"}, {"sha": "8f2afa7f808227d1f2eef48a54505112c7c9db01", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -42,7 +42,7 @@ mod move_error;\n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     fn_id: NodeId,\n                                     decl: &hir::FnDecl,\n-                                    body: &hir::Block)\n+                                    body: &hir::Expr)\n                                     -> (Vec<Loan<'tcx>>,\n                                         move_data::MoveData<'tcx>) {\n     let mut glcx = GatherLoanCtxt {"}, {"sha": "be85069db3135d7b1e2ce6218fc6cd0d5a2b1467", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -21,7 +21,7 @@ use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n@@ -63,7 +63,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n                 env: &env,\n                 flow_inits: flow_inits,\n                 flow_uninits: flow_uninits,\n-                drop_flags: FnvHashMap(),\n+                drop_flags: FxHashMap(),\n                 patch: MirPatch::new(mir),\n             }.elaborate()\n         };\n@@ -118,7 +118,7 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     env: &'a MoveDataParamEnv<'tcx>,\n     flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n     flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>,\n-    drop_flags: FnvHashMap<MovePathIndex, Local>,\n+    drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }\n "}, {"sha": "02064b52cb1fb2c24b264f621bc879294d29e021", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -11,7 +11,7 @@\n \n use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n use rustc::mir::*;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n \n use syntax::codemap::DUMMY_SP;\n@@ -181,7 +181,7 @@ pub struct MovePathLookup<'tcx> {\n     /// subsequent search so that it is solely relative to that\n     /// base-lvalue). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n-    projections: FnvHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n+    projections: FxHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n }\n \n struct MoveDataBuilder<'a, 'tcx: 'a> {\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                     locals: mir.local_decls.indices().map(Lvalue::Local).map(|v| {\n                         Self::new_move_path(&mut move_paths, &mut path_map, None, v)\n                     }).collect(),\n-                    projections: FnvHashMap(),\n+                    projections: FxHashMap(),\n                 },\n                 move_paths: move_paths,\n                 path_map: path_map,"}, {"sha": "836832de5b9c40f52d55daba45721962135764a7", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -58,7 +58,7 @@ pub struct MoveDataParamEnv<'tcx> {\n pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n                     fk: FnKind,\n                     _decl: &hir::FnDecl,\n-                    body: &hir::Block,\n+                    body: &hir::Expr,\n                     _sp: Span,\n                     id: ast::NodeId,\n                     attributes: &[ast::Attribute]) {"}, {"sha": "fb842f70a54a15bc71e68829d326f53704607bd2", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -47,9 +47,7 @@ use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n \n use rustc::hir;\n-use rustc::hir::{FnDecl, Block};\n-use rustc::hir::intravisit;\n-use rustc::hir::intravisit::{Visitor, FnKind};\n+use rustc::hir::intravisit::{self, Visitor, FnKind};\n \n pub mod check_loans;\n \n@@ -65,8 +63,8 @@ pub struct LoanDataFlowOperator;\n pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(..) |\n             FnKind::Method(..) => {\n@@ -159,7 +157,7 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n fn borrowck_fn(this: &mut BorrowckCtxt,\n                fk: FnKind,\n                decl: &hir::FnDecl,\n-               body: &hir::Block,\n+               body: &hir::Expr,\n                sp: Span,\n                id: ast::NodeId,\n                attributes: &[ast::Attribute]) {\n@@ -200,7 +198,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                           fk: FnKind,\n                                           decl: &hir::FnDecl,\n                                           cfg: &cfg::CFG,\n-                                          body: &hir::Block,\n+                                          body: &hir::Expr,\n                                           sp: Span,\n                                           id: ast::NodeId)\n                                           -> AnalysisData<'a, 'tcx>"}, {"sha": "32bda5e11620ac2429a3dd22be4257b4dc18adf4", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -23,7 +23,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n use rustc::middle::mem_categorization as mc;\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::{FnvHashMap, NodeSet};\n+use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -41,7 +41,7 @@ pub struct MoveData<'tcx> {\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n \n     /// Cache of loan path to move path index, for easy lookup.\n-    pub path_map: RefCell<FnvHashMap<Rc<LoanPath<'tcx>>, MovePathIndex>>,\n+    pub path_map: RefCell<FxHashMap<Rc<LoanPath<'tcx>>, MovePathIndex>>,\n \n     /// Each move or uninitialized variable gets an entry here.\n     pub moves: RefCell<Vec<Move>>,\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     pub fn new() -> MoveData<'tcx> {\n         MoveData {\n             paths: RefCell::new(Vec::new()),\n-            path_map: RefCell::new(FnvHashMap()),\n+            path_map: RefCell::new(FxHashMap()),\n             moves: RefCell::new(Vec::new()),\n             path_assignments: RefCell::new(Vec::new()),\n             var_assignments: RefCell::new(Vec::new()),\n@@ -656,7 +656,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                cfg: &cfg::CFG,\n                id_range: IdRange,\n                decl: &hir::FnDecl,\n-               body: &hir::Block)\n+               body: &hir::Expr)\n                -> FlowedMoveData<'a, 'tcx> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,"}, {"sha": "2cd709dbd36eb016f384537f7304646f2469cbad", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -19,7 +19,7 @@\n \n #![allow(non_camel_case_types)]\n \n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "c48811cb295bd60d681e82c29138a42b04764938", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 100, "deletions": 11, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -17,7 +17,7 @@ use eval::{compare_const_vals};\n \n use rustc_const_math::ConstInt;\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n use pattern::{FieldPattern, Pattern, PatternKind};\n@@ -39,7 +39,7 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use arena::TypedArena;\n \n-use std::cmp::Ordering;\n+use std::cmp::{self, Ordering};\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator, repeat};\n \n@@ -160,7 +160,7 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     /// associated types to get field types.\n     pub wild_pattern: &'a Pattern<'tcx>,\n     pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n-    pub byte_array_map: FnvHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n+    pub byte_array_map: FxHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             tcx: tcx,\n             wild_pattern: &wild_pattern,\n             pattern_arena: &pattern_arena,\n-            byte_array_map: FnvHashMap(),\n+            byte_array_map: FxHashMap(),\n         })\n     }\n \n@@ -419,6 +419,99 @@ fn all_constructors(_cx: &mut MatchCheckCtxt, pcx: PatternContext) -> Vec<Constr\n     }\n }\n \n+fn max_slice_length<'a, 'tcx, I>(\n+    _cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+    patterns: I) -> usize\n+    where I: Iterator<Item=&'a Pattern<'tcx>>\n+{\n+    // The exhaustiveness-checking paper does not include any details on\n+    // checking variable-length slice patterns. However, they are matched\n+    // by an infinite collection of fixed-length array patterns.\n+    //\n+    // Checking the infinite set directly would take an infinite amount\n+    // of time. However, it turns out that for each finite set of\n+    // patterns `P`, all sufficiently large array lengths are equivalent:\n+    //\n+    // Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n+    // to exactly the subset `P\u209c` of `P` can be transformed to a slice\n+    // `s\u2098` for each sufficiently-large length `m` that applies to exactly\n+    // the same subset of `P`.\n+    //\n+    // Because of that, each witness for reachability-checking from one\n+    // of the sufficiently-large lengths can be transformed to an\n+    // equally-valid witness from any other length, so we only have\n+    // to check slice lengths from the \"minimal sufficiently-large length\"\n+    // and below.\n+    //\n+    // Note that the fact that there is a *single* `s\u2098` for each `m`\n+    // not depending on the specific pattern in `P` is important: if\n+    // you look at the pair of patterns\n+    //     `[true, ..]`\n+    //     `[.., false]`\n+    // Then any slice of length \u22651 that matches one of these two\n+    // patterns can be  be trivially turned to a slice of any\n+    // other length \u22651 that matches them and vice-versa - for\n+    // but the slice from length 2 `[false, true]` that matches neither\n+    // of these patterns can't be turned to a slice from length 1 that\n+    // matches neither of these patterns, so we have to consider\n+    // slices from length 2 there.\n+    //\n+    // Now, to see that that length exists and find it, observe that slice\n+    // patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n+    // \"variable-length\" patterns (`[_, .., _]`).\n+    //\n+    // For fixed-length patterns, all slices with lengths *longer* than\n+    // the pattern's length have the same outcome (of not matching), so\n+    // as long as `L` is greater than the pattern's length we can pick\n+    // any `s\u2098` from that length and get the same result.\n+    //\n+    // For variable-length patterns, the situation is more complicated,\n+    // because as seen above the precise value of `s\u2098` matters.\n+    //\n+    // However, for each variable-length pattern `p` with a prefix of length\n+    // `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n+    // `sl\u209a` elements are examined.\n+    //\n+    // Therefore, as long as `L` is positive (to avoid concerns about empty\n+    // types), all elements after the maximum prefix length and before\n+    // the maximum suffix length are not examined by any variable-length\n+    // pattern, and therefore can be added/removed without affecting\n+    // them - creating equivalent patterns from any sufficiently-large\n+    // length.\n+    //\n+    // Of course, if fixed-length patterns exist, we must be sure\n+    // that our length is large enough to miss them all, so\n+    // we can pick `L = max(FIXED_LEN+1 \u222a {max(PREFIX_LEN) + max(SUFFIX_LEN)})`\n+    //\n+    // for example, with the above pair of patterns, all elements\n+    // but the first and last can be added/removed, so any\n+    // witness of length \u22652 (say, `[false, false, true]`) can be\n+    // turned to a witness from any other length \u22652.\n+\n+    let mut max_prefix_len = 0;\n+    let mut max_suffix_len = 0;\n+    let mut max_fixed_len = 0;\n+\n+    for row in patterns {\n+        match *row.kind {\n+            PatternKind::Constant { value: ConstVal::ByteStr(ref data) } => {\n+                max_fixed_len = cmp::max(max_fixed_len, data.len());\n+            }\n+            PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n+                let fixed_len = prefix.len() + suffix.len();\n+                max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n+            }\n+            PatternKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n+                max_prefix_len = cmp::max(max_prefix_len, prefix.len());\n+                max_suffix_len = cmp::max(max_suffix_len, suffix.len());\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    cmp::max(max_fixed_len + 1, max_prefix_len + max_suffix_len)\n+}\n+\n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n ///\n /// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n@@ -453,16 +546,12 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n     let &Matrix(ref rows) = matrix;\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n+\n+\n     let pcx = PatternContext {\n         ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error())\n             .unwrap_or(v[0].ty),\n-        max_slice_length: rows.iter().filter_map(|row| match *row[0].kind {\n-            PatternKind::Slice { ref prefix, slice: _, ref suffix } =>\n-                Some(prefix.len() + suffix.len()),\n-            PatternKind::Constant { value: ConstVal::ByteStr(ref data) } =>\n-                Some(data.len()),\n-            _ => None\n-        }).max().map_or(0, |v| v + 1)\n+        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0])))\n     };\n \n     debug!(\"is_useful_expand_first_col: pcx={:?}, expanding {:?}\", pcx, v[0]);"}, {"sha": "e0e8a215919217c126c940138e8bf06278c1b85c", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for OuterVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, id: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"check_match: closure outside of function\")\n         }\n@@ -113,7 +113,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, n: ast::NodeId) {\n+                b: &'v hir::Expr, s: Span, n: ast::NodeId) {\n         intravisit::walk_fn(self, fk, fd, b, s, n);\n \n         for input in &fd.inputs {\n@@ -201,7 +201,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = self.tcx.node_id_to_type(scrut.id);\n+            let pat_ty = self.tcx.tables().node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n                 if !pat_ty.is_uninhabited(self.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n-            let pat_ty = cx.tcx.pat_ty(p);\n+            let pat_ty = cx.tcx.tables().pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n                 if edef.is_enum() {\n                     if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n@@ -486,7 +486,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n-                let pat_ty = cx.tcx.node_id_to_type(p.id);\n+                let pat_ty = cx.tcx.tables().node_id_to_type(p.id);\n                 if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                     check_move(p, sub.as_ref().map(|p| &**p));\n                 }"}, {"sha": "5f0c94744a1185f78b63246241a8c395fec2d734", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -27,7 +27,7 @@ use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::Substs;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::NodeMap;\n+use rustc::util::nodemap::DefIdMap;\n use rustc::lint;\n \n use graphviz::IntoCow;\n@@ -246,7 +246,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    pat_id: ast::NodeId,\n                                    span: Span)\n                                    -> Result<P<hir::Pat>, DefId> {\n-    let pat_ty = tcx.expr_ty(expr);\n+    let pat_ty = tcx.tables().expr_ty(expr);\n     debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n     match pat_ty.sty {\n         ty::TyFloat(_) => {\n@@ -314,7 +314,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           },\n                       }))\n                       .collect::<Result<_, _>>()?;\n-            PatKind::Struct(path.clone(), field_pats, false)\n+            PatKind::Struct((**path).clone(), field_pats, false)\n         }\n \n         hir::ExprArray(ref exprs) => {\n@@ -329,7 +329,8 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 Def::StructCtor(_, CtorKind::Const) |\n                 Def::VariantCtor(_, CtorKind::Const) => PatKind::Path(None, path.clone()),\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                    let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n+                    let substs = Some(tcx.tables().node_id_item_substs(expr.id)\n+                        .unwrap_or_else(|| tcx.intern_substs(&[])));\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n                     return const_expr_to_pat(tcx, expr, pat_id, span);\n                 },\n@@ -413,7 +414,7 @@ pub fn eval_const_expr_checked<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     eval_const_expr_partial(tcx, e, ExprTypeChecked, None)\n }\n \n-pub type FnArgMap<'a> = Option<&'a NodeMap<ConstVal>>;\n+pub type FnArgMap<'a> = Option<&'a DefIdMap<ConstVal>>;\n \n #[derive(Clone, Debug)]\n pub struct ConstEvalErr {\n@@ -606,7 +607,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let ety = match ty_hint {\n         ExprTypeChecked => {\n             // After type-checking, expr_ty is guaranteed to succeed.\n-            Some(tcx.expr_ty(e))\n+            Some(tcx.tables().expr_ty(e))\n         }\n         UncheckedExprHint(ty) => {\n             // Use the type hint; it's not guaranteed to be right, but it's\n@@ -617,7 +618,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // This expression might not be type-checked, and we have no hint.\n             // Try to query the context for a type anyway; we might get lucky\n             // (for example, if the expression was imported from another crate).\n-            tcx.expr_ty_opt(e)\n+            tcx.tables().expr_ty_opt(e)\n         }\n     };\n     let result = match e.node {\n@@ -759,7 +760,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked\n         } else {\n-            match tcx.expr_ty_opt(&base) {\n+            match tcx.tables().expr_ty_opt(&base) {\n                 Some(t) => UncheckedExprHint(t),\n                 None => ty_hint\n             }\n@@ -798,7 +799,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {\n-                      Some(tcx.node_id_item_substs(e.id).substs)\n+                      Some(tcx.tables().node_id_item_substs(e.id)\n+                        .unwrap_or_else(|| tcx.intern_substs(&[])))\n                   } else {\n                       None\n                   };\n@@ -835,9 +837,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   ConstVal::Struct(e.id)\n               }\n               Def::Local(def_id) => {\n-                  let id = tcx.map.as_local_node_id(def_id).unwrap();\n-                  debug!(\"Def::Local({:?}): {:?}\", id, fn_args);\n-                  if let Some(val) = fn_args.and_then(|args| args.get(&id)) {\n+                  debug!(\"Def::Local({:?}): {:?}\", def_id, fn_args);\n+                  if let Some(val) = fn_args.and_then(|args| args.get(&def_id)) {\n                       val.clone()\n                   } else {\n                       signal!(e, NonConstPath);\n@@ -856,14 +857,13 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               callee => signal!(e, CallOn(callee)),\n           };\n           let (decl, result) = if let Some(fn_like) = lookup_const_fn_by_id(tcx, did) {\n-              (fn_like.decl(), &fn_like.body().expr)\n+              (fn_like.decl(), fn_like.body())\n           } else {\n               signal!(e, NonConstPath)\n           };\n-          let result = result.as_ref().expect(\"const fn has no result expression\");\n           assert_eq!(decl.inputs.len(), args.len());\n \n-          let mut call_args = NodeMap();\n+          let mut call_args = DefIdMap();\n           for (arg, arg_expr) in decl.inputs.iter().zip(args.iter()) {\n               let arg_hint = ty_hint.erase_hint();\n               let arg_val = eval_const_expr_partial(\n@@ -873,7 +873,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   fn_args\n               )?;\n               debug!(\"const call arg: {:?}\", arg);\n-              let old = call_args.insert(arg.pat.id, arg_val);\n+              let old = call_args.insert(tcx.expect_def(arg.pat.id).def_id(), arg_val);\n               assert!(old.is_none());\n           }\n           debug!(\"const call({:?})\", call_args);\n@@ -1090,13 +1090,8 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // when constructing the inference context above.\n         match selection {\n             traits::VtableImpl(ref impl_data) => {\n-                let ac = tcx.impl_or_trait_items(impl_data.impl_def_id)\n-                    .iter().filter_map(|&def_id| {\n-                        match tcx.impl_or_trait_item(def_id) {\n-                            ty::ConstTraitItem(ic) => Some(ic),\n-                            _ => None\n-                        }\n-                    }).find(|ic| ic.name == ti.name);\n+                let ac = tcx.associated_items(impl_data.impl_def_id)\n+                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == ti.name);\n                 match ac {\n                     Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                     None => match ti.node {"}, {"sha": "3fa60f86c98c47d041059acff59ec90e37b3ba42", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -22,7 +22,7 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "241920f2949f3354cec75c1c090a4f4222e4f83e", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.tcx.node_id_to_type(pat.id);\n+        let mut ty = self.tcx.tables().node_id_to_type(pat.id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n@@ -167,8 +167,9 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 match self.tcx.expect_def(pat.id) {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.tcx.global_tcx();\n-                        let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n-                        match eval::lookup_const_by_id(tcx, def_id, substs) {\n+                        let substs = tcx.tables().node_id_item_substs(pat.id)\n+                            .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                        match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n                             Some((const_expr, _const_ty)) => {\n                                 match eval::const_expr_to_pat(\n                                     tcx, const_expr, pat.id, pat.span)\n@@ -197,7 +198,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.tcx.node_id_to_type(pat.id);\n+                let ty = self.tcx.tables().node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n@@ -222,7 +223,8 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                match self.tcx.node_id_to_type(pat.id).sty {\n+                let ty = self.tcx.tables().node_id_to_type(pat.id);\n+                match ty.sty {\n                     ty::TyTuple(ref tys) => {\n                         let subpatterns =\n                             subpatterns.iter()\n@@ -243,7 +245,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             PatKind::Binding(bm, ref ident, ref sub) => {\n                 let def_id = self.tcx.expect_def(pat.id).def_id();\n                 let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n-                let var_ty = self.tcx.node_id_to_type(pat.id);\n+                let var_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n@@ -280,7 +282,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n-                let pat_ty = self.tcx.node_id_to_type(pat.id);\n+                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n@@ -299,7 +301,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Struct(_, ref fields, _) => {\n-                let pat_ty = self.tcx.node_id_to_type(pat.id);\n+                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {"}, {"sha": "1fb7673521d880029037f94d529df6025b8fccf3", "filename": "src/librustc_data_structures/fx.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_data_structures%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_data_structures%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffx.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::{HashMap, HashSet};\n+use std::default::Default;\n+use std::hash::{Hasher, Hash, BuildHasherDefault};\n+use std::ops::BitXor;\n+\n+pub type FxHashMap<K, V> = HashMap<K, V, BuildHasherDefault<FxHasher>>;\n+pub type FxHashSet<V> = HashSet<V, BuildHasherDefault<FxHasher>>;\n+\n+#[allow(non_snake_case)]\n+pub fn FxHashMap<K: Hash + Eq, V>() -> FxHashMap<K, V> {\n+    HashMap::default()\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn FxHashSet<V: Hash + Eq>() -> FxHashSet<V> {\n+    HashSet::default()\n+}\n+\n+/// A speedy hash algorithm for use within rustc. The hashmap in libcollections\n+/// by default uses SipHash which isn't quite as speedy as we want. In the\n+/// compiler we're not really worried about DOS attempts, so we use a fast\n+/// non-cryptographic hash.\n+///\n+/// This is the same as the algorithm used by Firefox -- which is a homespun\n+/// one not based on any widely-known algorithm -- though modified to produce\n+/// 64-bit hash values instead of 32-bit hash values. It consistently\n+/// out-performs an FNV-based hash within rustc itself -- the collision rate is\n+/// similar or slightly worse than FNV, but the speed of the hash function\n+/// itself is much higher because it works on up to 8 bytes at a time.\n+pub struct FxHasher {\n+    hash: usize\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+const K: usize = 0x9e3779b9;\n+#[cfg(target_pointer_width = \"64\")]\n+const K: usize = 0x517cc1b727220a95;\n+\n+impl Default for FxHasher {\n+    #[inline]\n+    fn default() -> FxHasher {\n+        FxHasher { hash: 0 }\n+    }\n+}\n+\n+impl FxHasher {\n+    #[inline]\n+    fn add_to_hash(&mut self, i: usize) {\n+        self.hash = self.hash.rotate_left(5).bitxor(i).wrapping_mul(K);\n+    }\n+}\n+\n+impl Hasher for FxHasher {\n+    #[inline]\n+    fn write(&mut self, bytes: &[u8]) {\n+        for byte in bytes {\n+            let i = *byte;\n+            self.add_to_hash(i as usize);\n+        }\n+    }\n+\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+        self.add_to_hash((i >> 32) as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.add_to_hash(i);\n+    }\n+\n+    #[inline]\n+    fn finish(&self) -> u64 {\n+        self.hash as u64\n+    }\n+}\n+\n+pub fn hash<T: Hash>(v: &T) -> u64 {\n+    let mut state = FxHasher::default();\n+    v.hash(&mut state);\n+    state.finish()\n+}"}, {"sha": "00cea9cbdf6b7100aac27aa01164f32810c28afe", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -149,6 +149,21 @@ impl<I: Idx, T> IndexVec<I, T> {\n     pub fn last(&self) -> Option<I> {\n         self.len().checked_sub(1).map(I::new)\n     }\n+\n+    #[inline]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.raw.shrink_to_fit()\n+    }\n+\n+    #[inline]\n+    pub fn swap(&mut self, a: usize, b: usize) {\n+        self.raw.swap(a, b)\n+    }\n+\n+    #[inline]\n+    pub fn truncate(&mut self, a: usize) {\n+        self.raw.truncate(a)\n+    }\n }\n \n impl<I: Idx, T> Index<I> for IndexVec<I, T> {"}, {"sha": "fdcbec6bac11a97f3867f70ce14eababca389755", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -60,6 +60,7 @@ pub mod snapshot_vec;\n pub mod transitive_relation;\n pub mod unify;\n pub mod fnv;\n+pub mod fx;\n pub mod tuple_slice;\n pub mod veccell;\n pub mod control_flow_graph;"}, {"sha": "a46238309bb46a87e16b16ee72ee1505cbb65b65", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -15,7 +15,7 @@\n //! in the first place). See README.md for a general overview of how\n //! to use this class.\n \n-use fnv::{FnvHashMap, FnvHashSet};\n+use fx::{FxHashMap, FxHashSet};\n \n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n@@ -68,9 +68,9 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n     /// A cache of predicates that have been successfully completed.\n-    done_cache: FnvHashSet<O::Predicate>,\n+    done_cache: FxHashSet<O::Predicate>,\n     /// An cache of the nodes in `nodes`, indexed by predicate.\n-    waiting_cache: FnvHashMap<O::Predicate, NodeIndex>,\n+    waiting_cache: FxHashMap<O::Predicate, NodeIndex>,\n     /// A list of the obligations added in snapshots, to allow\n     /// for their removal.\n     cache_list: Vec<O::Predicate>,\n@@ -158,8 +158,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n             snapshots: vec![],\n-            done_cache: FnvHashSet(),\n-            waiting_cache: FnvHashMap(),\n+            done_cache: FxHashSet(),\n+            waiting_cache: FxHashMap(),\n             cache_list: vec![],\n             scratch: Some(vec![]),\n         }"}, {"sha": "cd7143ad3ce8470d05826d005c44c9ff3efeae3a", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use fnv::FnvHashMap;\n+use fx::FxHashMap;\n use std::hash::Hash;\n use std::ops;\n use std::mem;\n@@ -19,7 +19,7 @@ mod test;\n pub struct SnapshotMap<K, V>\n     where K: Hash + Clone + Eq\n {\n-    map: FnvHashMap<K, V>,\n+    map: FxHashMap<K, V>,\n     undo_log: Vec<UndoLog<K, V>>,\n }\n \n@@ -40,7 +40,7 @@ impl<K, V> SnapshotMap<K, V>\n {\n     pub fn new() -> Self {\n         SnapshotMap {\n-            map: FnvHashMap(),\n+            map: FxHashMap(),\n             undo_log: vec![],\n         }\n     }"}, {"sha": "d83918495676c99c8fc6d13ccf1bf60c64a2f4f7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -37,7 +37,8 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{ast_validation, no_asm, loops, consts, rvalues, static_recursion};\n+use rustc_passes::{ast_validation, no_asm, loops, consts, rvalues,\n+                   static_recursion, hir_stats};\n use rustc_const_eval::check_match;\n use super::Compilation;\n \n@@ -513,6 +514,10 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session, input: &Input) -> PResult<'a,\n         syntax::show_span::run(sess.diagnostic(), s, &krate);\n     }\n \n+    if sess.opts.debugging_opts.hir_stats {\n+        hir_stats::print_ast_stats(&krate, \"PRE EXPANSION AST STATS\");\n+    }\n+\n     Ok(krate)\n }\n \n@@ -718,6 +723,10 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n \n+    if sess.opts.debugging_opts.hir_stats {\n+        hir_stats::print_ast_stats(&krate, \"POST EXPANSION AST STATS\");\n+    }\n+\n     if sess.opts.debugging_opts.ast_json {\n         println!(\"{}\", json::as_json(&krate));\n     }\n@@ -758,7 +767,13 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n \n     // Lower ast -> hir.\n     let hir_forest = time(sess.time_passes(), \"lowering ast -> hir\", || {\n-        hir_map::Forest::new(lower_crate(sess, &krate, &mut resolver), &sess.dep_graph)\n+        let hir_crate = lower_crate(sess, &krate, &mut resolver);\n+\n+        if sess.opts.debugging_opts.hir_stats {\n+            hir_stats::print_hir_stats(&hir_crate);\n+        }\n+\n+        hir_map::Forest::new(hir_crate, &sess.dep_graph)\n     });\n \n     // Discard hygiene data, which isn't required past lowering to HIR.\n@@ -917,17 +932,19 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"MIR dump\",\n              || mir::mir_map::build_mir_for_crate(tcx));\n \n-        time(time_passes, \"MIR passes\", || {\n+        time(time_passes, \"MIR cleanup and validation\", || {\n             let mut passes = sess.mir_passes.borrow_mut();\n-            // Push all the built-in passes.\n+            // Push all the built-in validation passes.\n+            // NB: if you\u2019re adding an *optimisation* it ought to go to another set of passes\n+            // in stage 4 below.\n             passes.push_hook(box mir::transform::dump_mir::DumpMir);\n-            passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"initial\"));\n+            passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"initial\"));\n             passes.push_pass(\n                 box mir::transform::qualify_consts::QualifyAndPromoteConstants::default());\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n             passes.push_pass(\n                 box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n-            passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"qualify-consts\"));\n+            passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n             // And run everything.\n             passes.run_passes(tcx);\n         });\n@@ -989,27 +1006,28 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n          \"resolving dependency formats\",\n          || dependency_format::calculate(&tcx.sess));\n \n-    // Run the passes that transform the MIR into a more suitable for translation\n-    // to LLVM code.\n-    time(time_passes, \"Prepare MIR codegen passes\", || {\n+    // Run the passes that transform the MIR into a more suitable form for translation to LLVM\n+    // code.\n+    time(time_passes, \"MIR optimisations\", || {\n         let mut passes = ::rustc::mir::transform::Passes::new();\n         passes.push_hook(box mir::transform::dump_mir::DumpMir);\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"no-landing-pads\"));\n+        passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"no-landing-pads\"));\n \n         // From here on out, regions are gone.\n         passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n \n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box borrowck::ElaborateDrops);\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"elaborate-drops\"));\n+        passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n \n         // No lifetime analysis based on borrowing can be done from here on out.\n         passes.push_pass(box mir::transform::instcombine::InstCombine::new());\n         passes.push_pass(box mir::transform::deaggregator::Deaggregator);\n         passes.push_pass(box mir::transform::copy_prop::CopyPropagation);\n \n+        passes.push_pass(box mir::transform::simplify::SimplifyLocals);\n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box mir::transform::dump_mir::Marker(\"PreTrans\"));\n "}, {"sha": "7e60c40220f84eed8acb55dac747dc42f71be9c6", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -24,7 +24,7 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(box_syntax)]\n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n@@ -75,7 +75,7 @@ use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n use rustc::session::config::nightly_options;\n-use rustc::session::early_error;\n+use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc_metadata::locator;\n@@ -455,8 +455,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             1 => panic!(\"make_input should have provided valid inputs\"),\n             _ => early_error(sopts.error_format, \"multiple input filenames provided\"),\n         }\n-\n-        None\n     }\n \n     fn late_callback(&mut self,\n@@ -1011,6 +1009,11 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n         return None;\n     }\n \n+    if cg_flags.iter().any(|x| *x == \"no-stack-check\") {\n+        early_warn(ErrorOutputType::default(),\n+                   \"the --no-stack-check flag is deprecated and does nothing\");\n+    }\n+\n     if cg_flags.contains(&\"passes=list\".to_string()) {\n         unsafe {\n             ::llvm::LLVMRustPrintPasses();"}, {"sha": "ecbf28c1082f989e2e58f19d2065efe38095e6ea", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 pp::space(&mut s.s)?;\n                 pp::word(&mut s.s, \"as\")?;\n                 pp::space(&mut s.s)?;\n-                pp::word(&mut s.s, &self.tcx.expr_ty(expr).to_string())?;\n+                pp::word(&mut s.s, &self.tcx.tables().expr_ty(expr).to_string())?;\n                 s.pclose()\n             }\n             _ => Ok(()),\n@@ -701,8 +701,8 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n                                        mut out: W)\n                                        -> io::Result<()> {\n     let cfg = match code {\n-        blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n-        blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),\n+        blocks::Code::Expr(expr) => cfg::CFG::new(tcx, expr),\n+        blocks::Code::FnLike(fn_like) => cfg::CFG::new(tcx, fn_like.body()),\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n@@ -717,12 +717,12 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n             let r = dot::render(&lcfg, &mut out);\n             return expand_err_details(r);\n         }\n-        blocks::BlockCode(_) => {\n+        blocks::Code::Expr(_) => {\n             tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print annotations requires \\\n                           fn-like node id.\");\n             return Ok(());\n         }\n-        blocks::FnLikeCode(fn_like) => {\n+        blocks::Code::FnLike(fn_like) => {\n             let (bccx, analysis_data) =\n                 borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_like.to_fn_parts(), &cfg);\n \n@@ -990,8 +990,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n                 });\n \n-                let code = blocks::Code::from_node(node);\n-                match code {\n+                match blocks::Code::from_node(&tcx.map, nodeid) {\n                     Some(code) => {\n                         let variants = gather_flowgraph_variants(tcx.sess);\n "}, {"sha": "c92e4d8f5aba563c35cbb876c7c449f5e59b38c6", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -11,4 +11,4 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = { path = \"../liblog\" }\n serialize = { path = \"../libserialize\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "730ca8f9e2e4474e97735ffd13ad6a553f51183c", "filename": "src/librustc_errors/diagnostic.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -0,0 +1,202 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use CodeSuggestion;\n+use Level;\n+use RenderSpan;\n+use RenderSpan::Suggestion;\n+use std::fmt;\n+use syntax_pos::{MultiSpan, Span};\n+\n+#[must_use]\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct Diagnostic {\n+    pub level: Level,\n+    pub message: String,\n+    pub code: Option<String>,\n+    pub span: MultiSpan,\n+    pub children: Vec<SubDiagnostic>,\n+}\n+\n+/// For example a note attached to an error.\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct SubDiagnostic {\n+    pub level: Level,\n+    pub message: String,\n+    pub span: MultiSpan,\n+    pub render_span: Option<RenderSpan>,\n+}\n+\n+impl Diagnostic {\n+    pub fn new(level: Level, message: &str) -> Self {\n+        Diagnostic::new_with_code(level, None, message)\n+    }\n+\n+    pub fn new_with_code(level: Level, code: Option<String>, message: &str) -> Self {\n+        Diagnostic {\n+            level: level,\n+            message: message.to_owned(),\n+            code: code,\n+            span: MultiSpan::new(),\n+            children: vec![],\n+        }\n+    }\n+\n+    /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n+    /// cancelled or it will panic when dropped).\n+    /// BEWARE: if this DiagnosticBuilder is an error, then creating it will\n+    /// bump the error count on the Handler and cancelling it won't undo that.\n+    /// If you want to decrement the error count you should use `Handler::cancel`.\n+    pub fn cancel(&mut self) {\n+        self.level = Level::Cancelled;\n+    }\n+\n+    pub fn cancelled(&self) -> bool {\n+        self.level == Level::Cancelled\n+    }\n+\n+    pub fn is_fatal(&self) -> bool {\n+        self.level == Level::Fatal\n+    }\n+\n+    /// Add a span/label to be included in the resulting snippet.\n+    /// This is pushed onto the `MultiSpan` that was created when the\n+    /// diagnostic was first built. If you don't call this function at\n+    /// all, and you just supplied a `Span` to create the diagnostic,\n+    /// then the snippet will just include that `Span`, which is\n+    /// called the primary span.\n+    pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n+                      -> &mut Self {\n+        self.span.push_span_label(span, format!(\"{}\", label));\n+        self\n+    }\n+\n+    pub fn note_expected_found(&mut self,\n+                               label: &fmt::Display,\n+                               expected: &fmt::Display,\n+                               found: &fmt::Display)\n+                               -> &mut Self\n+    {\n+        self.note_expected_found_extra(label, expected, found, &\"\", &\"\")\n+    }\n+\n+    pub fn note_expected_found_extra(&mut self,\n+                                     label: &fmt::Display,\n+                                     expected: &fmt::Display,\n+                                     found: &fmt::Display,\n+                                     expected_extra: &fmt::Display,\n+                                     found_extra: &fmt::Display)\n+                                     -> &mut Self\n+    {\n+        // For now, just attach these as notes\n+        self.note(&format!(\"expected {} `{}`{}\", label, expected, expected_extra));\n+        self.note(&format!(\"   found {} `{}`{}\", label, found, found_extra));\n+        self\n+    }\n+\n+    pub fn note(&mut self, msg: &str) -> &mut Self {\n+        self.sub(Level::Note, msg, MultiSpan::new(), None);\n+        self\n+    }\n+\n+    pub fn span_note<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut Self {\n+        self.sub(Level::Note, msg, sp.into(), None);\n+        self\n+    }\n+\n+    pub fn warn(&mut self, msg: &str) -> &mut Self {\n+        self.sub(Level::Warning, msg, MultiSpan::new(), None);\n+        self\n+    }\n+\n+    pub fn span_warn<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut Self {\n+        self.sub(Level::Warning, msg, sp.into(), None);\n+        self\n+    }\n+\n+    pub fn help(&mut self , msg: &str) -> &mut Self {\n+        self.sub(Level::Help, msg, MultiSpan::new(), None);\n+        self\n+    }\n+\n+    pub fn span_help<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut Self {\n+        self.sub(Level::Help, msg, sp.into(), None);\n+        self\n+    }\n+\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    pub fn span_suggestion<S: Into<MultiSpan>>(&mut self,\n+                                               sp: S,\n+                                               msg: &str,\n+                                               suggestion: String)\n+                                               -> &mut Self {\n+        self.sub(Level::Help,\n+                 msg,\n+                 MultiSpan::new(),\n+                 Some(Suggestion(CodeSuggestion {\n+                     msp: sp.into(),\n+                     substitutes: vec![suggestion],\n+                 })));\n+        self\n+    }\n+\n+    pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n+        self.span = sp.into();\n+        self\n+    }\n+\n+    pub fn code(&mut self, s: String) -> &mut Self {\n+        self.code = Some(s);\n+        self\n+    }\n+\n+    pub fn message(&self) -> &str {\n+        &self.message\n+    }\n+\n+    pub fn level(&self) -> Level {\n+        self.level\n+    }\n+\n+    /// Used by a lint. Copies over all details *but* the \"main\n+    /// message\".\n+    pub fn copy_details_not_message(&mut self, from: &Diagnostic) {\n+        self.span = from.span.clone();\n+        self.code = from.code.clone();\n+        self.children.extend(from.children.iter().cloned())\n+    }\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// public methods above.\n+    fn sub(&mut self,\n+           level: Level,\n+           message: &str,\n+           span: MultiSpan,\n+           render_span: Option<RenderSpan>) {\n+        let sub = SubDiagnostic {\n+            level: level,\n+            message: message.to_owned(),\n+            span: span,\n+            render_span: render_span,\n+        };\n+        self.children.push(sub);\n+    }\n+}"}, {"sha": "7dfea6b8951b05f2aebd649e338124e57af9fbf6", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -0,0 +1,196 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use Diagnostic;\n+use Level;\n+use Handler;\n+use std::fmt::{self, Debug};\n+use std::ops::{Deref, DerefMut};\n+use std::thread::panicking;\n+use syntax_pos::{MultiSpan, Span};\n+\n+/// Used for emitting structured error messages and other diagnostic information.\n+#[must_use]\n+#[derive(Clone)]\n+pub struct DiagnosticBuilder<'a> {\n+    handler: &'a Handler,\n+    diagnostic: Diagnostic,\n+}\n+\n+/// In general, the `DiagnosticBuilder` uses deref to allow access to\n+/// the fields and methods of the embedded `diagnostic` in a\n+/// transparent way.  *However,* many of the methods are intended to\n+/// be used in a chained way, and hence ought to return `self`. In\n+/// that case, we can't just naively forward to the method on the\n+/// `diagnostic`, because the return type would be a `&Diagnostic`\n+/// instead of a `&DiagnosticBuilder<'a>`. This `forward!` macro makes\n+/// it easy to declare such methods on the builder.\n+macro_rules! forward {\n+    // Forward pattern for &self -> &Self\n+    (pub fn $n:ident(&self, $($name:ident: $ty:ty),*) -> &Self) => {\n+        pub fn $n(&self, $($name: $ty),*) -> &Self {\n+            self.diagnostic.$n($($name),*);\n+            self\n+        }\n+    };\n+\n+    // Forward pattern for &mut self -> &mut Self\n+    (pub fn $n:ident(&mut self, $($name:ident: $ty:ty),*) -> &mut Self) => {\n+        pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n+            self.diagnostic.$n($($name),*);\n+            self\n+        }\n+    };\n+\n+    // Forward pattern for &mut self -> &mut Self, with S: Into<MultiSpan>\n+    // type parameter. No obvious way to make this more generic.\n+    (pub fn $n:ident<S: Into<MultiSpan>>(&mut self, $($name:ident: $ty:ty),*) -> &mut Self) => {\n+        pub fn $n<S: Into<MultiSpan>>(&mut self, $($name: $ty),*) -> &mut Self {\n+            self.diagnostic.$n($($name),*);\n+            self\n+        }\n+    };\n+}\n+\n+impl<'a> Deref for DiagnosticBuilder<'a> {\n+    type Target = Diagnostic;\n+\n+    fn deref(&self) -> &Diagnostic {\n+        &self.diagnostic\n+    }\n+}\n+\n+impl<'a> DerefMut for DiagnosticBuilder<'a> {\n+    fn deref_mut(&mut self) -> &mut Diagnostic {\n+        &mut self.diagnostic\n+    }\n+}\n+\n+impl<'a> DiagnosticBuilder<'a> {\n+    /// Emit the diagnostic.\n+    pub fn emit(&mut self) {\n+        if self.cancelled() {\n+            return;\n+        }\n+\n+        match self.level {\n+            Level::Bug |\n+            Level::Fatal |\n+            Level::PhaseFatal |\n+            Level::Error => {\n+                self.handler.bump_err_count();\n+            }\n+\n+            Level::Warning |\n+            Level::Note |\n+            Level::Help |\n+            Level::Cancelled => {\n+            }\n+        }\n+\n+        self.handler.emitter.borrow_mut().emit(&self);\n+        self.cancel();\n+        self.handler.panic_if_treat_err_as_bug();\n+\n+        // if self.is_fatal() {\n+        //     panic!(FatalError);\n+        // }\n+    }\n+\n+    /// Add a span/label to be included in the resulting snippet.\n+    /// This is pushed onto the `MultiSpan` that was created when the\n+    /// diagnostic was first built. If you don't call this function at\n+    /// all, and you just supplied a `Span` to create the diagnostic,\n+    /// then the snippet will just include that `Span`, which is\n+    /// called the primary span.\n+    forward!(pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n+                               -> &mut Self);\n+\n+    forward!(pub fn note_expected_found(&mut self,\n+                                        label: &fmt::Display,\n+                                        expected: &fmt::Display,\n+                                        found: &fmt::Display)\n+                                        -> &mut Self);\n+\n+    forward!(pub fn note_expected_found_extra(&mut self,\n+                                              label: &fmt::Display,\n+                                              expected: &fmt::Display,\n+                                              found: &fmt::Display,\n+                                              expected_extra: &fmt::Display,\n+                                              found_extra: &fmt::Display)\n+                                              -> &mut Self);\n+\n+    forward!(pub fn note(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn span_note<S: Into<MultiSpan>>(&mut self,\n+                                                  sp: S,\n+                                                  msg: &str)\n+                                                  -> &mut Self);\n+    forward!(pub fn warn(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self);\n+    forward!(pub fn help(&mut self , msg: &str) -> &mut Self);\n+    forward!(pub fn span_help<S: Into<MultiSpan>>(&mut self,\n+                                                  sp: S,\n+                                                  msg: &str)\n+                                                  -> &mut Self);\n+    forward!(pub fn span_suggestion<S: Into<MultiSpan>>(&mut self,\n+                                                        sp: S,\n+                                                        msg: &str,\n+                                                        suggestion: String)\n+                                                        -> &mut Self);\n+    forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n+    forward!(pub fn code(&mut self, s: String) -> &mut Self);\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// struct_* methods on Handler.\n+    pub fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder::new_with_code(handler, level, None, message)\n+    }\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// struct_* methods on Handler.\n+    pub fn new_with_code(handler: &'a Handler,\n+                         level: Level,\n+                         code: Option<String>,\n+                         message: &str)\n+                         -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder {\n+            handler: handler,\n+            diagnostic: Diagnostic::new_with_code(level, code, message)\n+        }\n+    }\n+\n+    pub fn into_diagnostic(mut self) -> Diagnostic {\n+        // annoyingly, the Drop impl means we can't actually move\n+        let result = self.diagnostic.clone();\n+        self.cancel();\n+        result\n+    }\n+}\n+\n+impl<'a> Debug for DiagnosticBuilder<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.diagnostic.fmt(f)\n+    }\n+}\n+\n+/// Destructor bomb - a DiagnosticBuilder must be either emitted or cancelled or\n+/// we emit a bug.\n+impl<'a> Drop for DiagnosticBuilder<'a> {\n+    fn drop(&mut self) {\n+        if !panicking() && !self.cancelled() {\n+            let mut db = DiagnosticBuilder::new(self.handler,\n+                                                Level::Bug,\n+                                                \"Error constructed but not emitted\");\n+            db.emit();\n+            panic!();\n+        }\n+    }\n+}\n+"}, {"sha": "badee66b83dea3de14e591632a5dfd59b121d652", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 6, "deletions": 237, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -39,15 +39,15 @@ extern crate syntax_pos;\n pub use emitter::ColorConfig;\n \n use self::Level::*;\n-use self::RenderSpan::*;\n \n use emitter::{Emitter, EmitterWriter};\n \n use std::cell::{RefCell, Cell};\n use std::{error, fmt};\n use std::rc::Rc;\n-use std::thread::panicking;\n \n+pub mod diagnostic;\n+pub mod diagnostic_builder;\n pub mod emitter;\n pub mod snippet;\n pub mod registry;\n@@ -57,7 +57,7 @@ mod lock;\n use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION};\n use syntax_pos::MacroBacktrace;\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug, PartialEq)]\n pub enum RenderSpan {\n     /// A FullSpan renders with both with an initial line for the\n     /// message, prefixed by file:linenum, followed by a summary of\n@@ -71,7 +71,7 @@ pub enum RenderSpan {\n     Suggestion(CodeSuggestion),\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug, PartialEq)]\n pub struct CodeSuggestion {\n     pub msp: MultiSpan,\n     pub substitutes: Vec<String>,\n@@ -211,219 +211,8 @@ impl error::Error for ExplicitBug {\n     }\n }\n \n-/// Used for emitting structured error messages and other diagnostic information.\n-#[must_use]\n-#[derive(Clone)]\n-pub struct DiagnosticBuilder<'a> {\n-    handler: &'a Handler,\n-    pub level: Level,\n-    pub message: String,\n-    pub code: Option<String>,\n-    pub span: MultiSpan,\n-    pub children: Vec<SubDiagnostic>,\n-}\n-\n-/// For example a note attached to an error.\n-#[derive(Clone)]\n-pub struct SubDiagnostic {\n-    pub level: Level,\n-    pub message: String,\n-    pub span: MultiSpan,\n-    pub render_span: Option<RenderSpan>,\n-}\n-\n-impl<'a> DiagnosticBuilder<'a> {\n-    /// Emit the diagnostic.\n-    pub fn emit(&mut self) {\n-        if self.cancelled() {\n-            return;\n-        }\n-\n-        self.handler.emitter.borrow_mut().emit(&self);\n-        self.cancel();\n-        self.handler.panic_if_treat_err_as_bug();\n-\n-        // if self.is_fatal() {\n-        //     panic!(FatalError);\n-        // }\n-    }\n-\n-    /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n-    /// cancelled or it will panic when dropped).\n-    /// BEWARE: if this DiagnosticBuilder is an error, then creating it will\n-    /// bump the error count on the Handler and cancelling it won't undo that.\n-    /// If you want to decrement the error count you should use `Handler::cancel`.\n-    pub fn cancel(&mut self) {\n-        self.level = Level::Cancelled;\n-    }\n-\n-    pub fn cancelled(&self) -> bool {\n-        self.level == Level::Cancelled\n-    }\n-\n-    pub fn is_fatal(&self) -> bool {\n-        self.level == Level::Fatal\n-    }\n-\n-    /// Add a span/label to be included in the resulting snippet.\n-    /// This is pushed onto the `MultiSpan` that was created when the\n-    /// diagnostic was first built. If you don't call this function at\n-    /// all, and you just supplied a `Span` to create the diagnostic,\n-    /// then the snippet will just include that `Span`, which is\n-    /// called the primary span.\n-    pub fn span_label(&mut self, span: Span, label: &fmt::Display) -> &mut DiagnosticBuilder<'a> {\n-        self.span.push_span_label(span, format!(\"{}\", label));\n-        self\n-    }\n-\n-    pub fn note_expected_found(&mut self,\n-                               label: &fmt::Display,\n-                               expected: &fmt::Display,\n-                               found: &fmt::Display)\n-                               -> &mut DiagnosticBuilder<'a> {\n-        self.note_expected_found_extra(label, expected, found, &\"\", &\"\")\n-    }\n-\n-    pub fn note_expected_found_extra(&mut self,\n-                                     label: &fmt::Display,\n-                                     expected: &fmt::Display,\n-                                     found: &fmt::Display,\n-                                     expected_extra: &fmt::Display,\n-                                     found_extra: &fmt::Display)\n-                                     -> &mut DiagnosticBuilder<'a> {\n-        // For now, just attach these as notes\n-        self.note(&format!(\"expected {} `{}`{}\", label, expected, expected_extra));\n-        self.note(&format!(\"   found {} `{}`{}\", label, found, found_extra));\n-        self\n-    }\n-\n-    pub fn note(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, MultiSpan::new(), None);\n-        self\n-    }\n-    pub fn span_note<S: Into<MultiSpan>>(&mut self,\n-                                         sp: S,\n-                                         msg: &str)\n-                                         -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, sp.into(), None);\n-        self\n-    }\n-    pub fn warn(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, MultiSpan::new(), None);\n-        self\n-    }\n-    pub fn span_warn<S: Into<MultiSpan>>(&mut self,\n-                                         sp: S,\n-                                         msg: &str)\n-                                         -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, sp.into(), None);\n-        self\n-    }\n-    pub fn help(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, MultiSpan::new(), None);\n-        self\n-    }\n-    pub fn span_help<S: Into<MultiSpan>>(&mut self,\n-                                         sp: S,\n-                                         msg: &str)\n-                                         -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, sp.into(), None);\n-        self\n-    }\n-    /// Prints out a message with a suggested edit of the code.\n-    ///\n-    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n-    pub fn span_suggestion<S: Into<MultiSpan>>(&mut self,\n-                                               sp: S,\n-                                               msg: &str,\n-                                               suggestion: String)\n-                                               -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help,\n-                 msg,\n-                 MultiSpan::new(),\n-                 Some(Suggestion(CodeSuggestion {\n-                     msp: sp.into(),\n-                     substitutes: vec![suggestion],\n-                 })));\n-        self\n-    }\n-\n-    pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n-        self.span = sp.into();\n-        self\n-    }\n-\n-    pub fn code(&mut self, s: String) -> &mut Self {\n-        self.code = Some(s);\n-        self\n-    }\n-\n-    pub fn message(&self) -> &str {\n-        &self.message\n-    }\n-\n-    pub fn level(&self) -> Level {\n-        self.level\n-    }\n-\n-    /// Convenience function for internal use, clients should use one of the\n-    /// struct_* methods on Handler.\n-    fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder::new_with_code(handler, level, None, message)\n-    }\n-\n-    /// Convenience function for internal use, clients should use one of the\n-    /// struct_* methods on Handler.\n-    fn new_with_code(handler: &'a Handler,\n-                     level: Level,\n-                     code: Option<String>,\n-                     message: &str)\n-                     -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder {\n-            handler: handler,\n-            level: level,\n-            message: message.to_owned(),\n-            code: code,\n-            span: MultiSpan::new(),\n-            children: vec![],\n-        }\n-    }\n-\n-    /// Convenience function for internal use, clients should use one of the\n-    /// public methods above.\n-    fn sub(&mut self,\n-           level: Level,\n-           message: &str,\n-           span: MultiSpan,\n-           render_span: Option<RenderSpan>) {\n-        let sub = SubDiagnostic {\n-            level: level,\n-            message: message.to_owned(),\n-            span: span,\n-            render_span: render_span,\n-        };\n-        self.children.push(sub);\n-    }\n-}\n-\n-impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.message.fmt(f)\n-    }\n-}\n-\n-/// Destructor bomb - a DiagnosticBuilder must be either emitted or cancelled or\n-/// we emit a bug.\n-impl<'a> Drop for DiagnosticBuilder<'a> {\n-    fn drop(&mut self) {\n-        if !panicking() && !self.cancelled() {\n-            let mut db =\n-                DiagnosticBuilder::new(self.handler, Bug, \"Error constructed but not emitted\");\n-            db.emit();\n-            panic!();\n-        }\n-    }\n-}\n+pub use diagnostic::{Diagnostic, SubDiagnostic};\n+pub use diagnostic_builder::DiagnosticBuilder;\n \n /// A handler deals with errors; certain errors\n /// (fatal, bug, unimpl) may cause immediate exit,\n@@ -504,7 +293,6 @@ impl Handler {\n                                                    sp: S,\n                                                    msg: &str)\n                                                    -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.set_span(sp);\n         result\n@@ -514,21 +302,18 @@ impl Handler {\n                                                              msg: &str,\n                                                              code: &str)\n                                                              -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.set_span(sp);\n         result.code(code.to_owned());\n         result\n     }\n     pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         DiagnosticBuilder::new(self, Level::Error, msg)\n     }\n     pub fn struct_span_fatal<'a, S: Into<MultiSpan>>(&'a self,\n                                                      sp: S,\n                                                      msg: &str)\n                                                      -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n         result.set_span(sp);\n         result\n@@ -538,24 +323,16 @@ impl Handler {\n                                                                msg: &str,\n                                                                code: &str)\n                                                                -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n         result.set_span(sp);\n         result.code(code.to_owned());\n         result\n     }\n     pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n     pub fn cancel(&self, err: &mut DiagnosticBuilder) {\n-        if err.level == Level::Error || err.level == Level::Fatal {\n-            self.err_count.set(self.err_count\n-                .get()\n-                .checked_sub(1)\n-                .expect(\"cancelled an error but err_count is 0\"));\n-        }\n         err.cancel();\n     }\n \n@@ -567,7 +344,6 @@ impl Handler {\n \n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n         self.emit(&sp.into(), msg, Fatal);\n-        self.bump_err_count();\n         self.panic_if_treat_err_as_bug();\n         return FatalError;\n     }\n@@ -577,13 +353,11 @@ impl Handler {\n                                                     code: &str)\n                                                     -> FatalError {\n         self.emit_with_code(&sp.into(), msg, code, Fatal);\n-        self.bump_err_count();\n         self.panic_if_treat_err_as_bug();\n         return FatalError;\n     }\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Error);\n-        self.bump_err_count();\n         self.panic_if_treat_err_as_bug();\n     }\n     pub fn mut_span_err<'a, S: Into<MultiSpan>>(&'a self,\n@@ -592,12 +366,10 @@ impl Handler {\n                                                 -> DiagnosticBuilder<'a> {\n         let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.set_span(sp);\n-        self.bump_err_count();\n         result\n     }\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n         self.emit_with_code(&sp.into(), msg, code, Error);\n-        self.bump_err_count();\n         self.panic_if_treat_err_as_bug();\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n@@ -616,7 +388,6 @@ impl Handler {\n     }\n     pub fn span_bug_no_panic<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Bug);\n-        self.bump_err_count();\n     }\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Note);\n@@ -630,7 +401,6 @@ impl Handler {\n         }\n         let mut db = DiagnosticBuilder::new(self, Fatal, msg);\n         db.emit();\n-        self.bump_err_count();\n         FatalError\n     }\n     pub fn err(&self, msg: &str) {\n@@ -639,7 +409,6 @@ impl Handler {\n         }\n         let mut db = DiagnosticBuilder::new(self, Error, msg);\n         db.emit();\n-        self.bump_err_count();\n     }\n     pub fn warn(&self, msg: &str) {\n         let mut db = DiagnosticBuilder::new(self, Warning, msg);"}, {"sha": "37477da755c9fb24226b42936c91aa27fdaba7fe", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -48,7 +48,7 @@ use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashSet;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc::hir;\n use rustc::hir::intravisit::Visitor;\n@@ -244,7 +244,7 @@ fn dump_graph(tcx: TyCtxt) {\n     }\n }\n \n-pub struct GraphvizDepGraph<'q>(FnvHashSet<&'q DepNode<DefId>>,\n+pub struct GraphvizDepGraph<'q>(FxHashSet<&'q DepNode<DefId>>,\n                                 Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>);\n \n impl<'a, 'tcx, 'q> dot::GraphWalk<'a> for GraphvizDepGraph<'q> {\n@@ -288,7 +288,7 @@ impl<'a, 'tcx, 'q> dot::Labeller<'a> for GraphvizDepGraph<'q> {\n // filter) or the set of nodes whose labels contain all of those\n // substrings.\n fn node_set<'q>(query: &'q DepGraphQuery<DefId>, filter: &DepNodeFilter)\n-                -> Option<FnvHashSet<&'q DepNode<DefId>>>\n+                -> Option<FxHashSet<&'q DepNode<DefId>>>\n {\n     debug!(\"node_set(filter={:?})\", filter);\n \n@@ -300,9 +300,9 @@ fn node_set<'q>(query: &'q DepGraphQuery<DefId>, filter: &DepNodeFilter)\n }\n \n fn filter_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n-                    sources: &Option<FnvHashSet<&'q DepNode<DefId>>>,\n-                    targets: &Option<FnvHashSet<&'q DepNode<DefId>>>)\n-                    -> FnvHashSet<&'q DepNode<DefId>>\n+                    sources: &Option<FxHashSet<&'q DepNode<DefId>>>,\n+                    targets: &Option<FxHashSet<&'q DepNode<DefId>>>)\n+                    -> FxHashSet<&'q DepNode<DefId>>\n {\n     if let &Some(ref sources) = sources {\n         if let &Some(ref targets) = targets {\n@@ -318,11 +318,11 @@ fn filter_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n }\n \n fn walk_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n-                  starts: &FnvHashSet<&'q DepNode<DefId>>,\n+                  starts: &FxHashSet<&'q DepNode<DefId>>,\n                   direction: Direction)\n-                  -> FnvHashSet<&'q DepNode<DefId>>\n+                  -> FxHashSet<&'q DepNode<DefId>>\n {\n-    let mut set = FnvHashSet();\n+    let mut set = FxHashSet();\n     for &start in starts {\n         debug!(\"walk_nodes: start={:?} outgoing?={:?}\", start, direction == OUTGOING);\n         if set.insert(start) {\n@@ -342,9 +342,9 @@ fn walk_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n }\n \n fn walk_between<'q>(query: &'q DepGraphQuery<DefId>,\n-                    sources: &FnvHashSet<&'q DepNode<DefId>>,\n-                    targets: &FnvHashSet<&'q DepNode<DefId>>)\n-                    -> FnvHashSet<&'q DepNode<DefId>>\n+                    sources: &FxHashSet<&'q DepNode<DefId>>,\n+                    targets: &FxHashSet<&'q DepNode<DefId>>)\n+                    -> FxHashSet<&'q DepNode<DefId>>\n {\n     // This is a bit tricky. We want to include a node only if it is:\n     // (a) reachable from a source and (b) will reach a target. And we\n@@ -410,7 +410,7 @@ fn walk_between<'q>(query: &'q DepGraphQuery<DefId>,\n }\n \n fn filter_edges<'q>(query: &'q DepGraphQuery<DefId>,\n-                    nodes: &FnvHashSet<&'q DepNode<DefId>>)\n+                    nodes: &FxHashSet<&'q DepNode<DefId>>)\n                     -> Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>\n {\n     query.edges()"}, {"sha": "d7d9c231a91f48ea772b72585da7cd23dcfd316b", "filename": "src/librustc_incremental/calculate_svh/hasher.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -9,13 +9,16 @@\n // except according to those terms.\n \n use std::mem;\n+use std::hash::Hasher;\n use rustc_data_structures::blake2b::Blake2bHasher;\n use rustc::ty::util::ArchIndependentHasher;\n use ich::Fingerprint;\n+use rustc_serialize::leb128::write_unsigned_leb128;\n \n #[derive(Debug)]\n pub struct IchHasher {\n     state: ArchIndependentHasher<Blake2bHasher>,\n+    leb128_helper: Vec<u8>,\n     bytes_hashed: u64,\n }\n \n@@ -24,6 +27,7 @@ impl IchHasher {\n         let hash_size = mem::size_of::<Fingerprint>();\n         IchHasher {\n             state: ArchIndependentHasher::new(Blake2bHasher::new(hash_size, &[])),\n+            leb128_helper: vec![],\n             bytes_hashed: 0\n         }\n     }\n@@ -37,9 +41,19 @@ impl IchHasher {\n         fingerprint.0.copy_from_slice(self.state.into_inner().finalize());\n         fingerprint\n     }\n+\n+    #[inline]\n+    fn write_uleb128(&mut self, value: u64) {\n+        let len = write_unsigned_leb128(&mut self.leb128_helper, 0, value);\n+        self.state.write(&self.leb128_helper[0..len]);\n+        self.bytes_hashed += len as u64;\n+    }\n }\n \n-impl ::std::hash::Hasher for IchHasher {\n+// For the non-u8 integer cases we leb128 encode them first. Because small\n+// integers dominate, this significantly and cheaply reduces the number of\n+// bytes hashed, which is good because blake2b is expensive.\n+impl Hasher for IchHasher {\n     fn finish(&self) -> u64 {\n         bug!(\"Use other finish() implementation to get the full 128-bit hash.\");\n     }\n@@ -49,4 +63,26 @@ impl ::std::hash::Hasher for IchHasher {\n         self.state.write(bytes);\n         self.bytes_hashed += bytes.len() as u64;\n     }\n+\n+    // There is no need to leb128-encode u8 values.\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.write_uleb128(i);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.write_uleb128(i as u64);\n+    }\n }"}, {"sha": "58a21529974106bb65c538acda91c9fa7e185a13", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -35,7 +35,7 @@ use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n \n@@ -51,21 +51,21 @@ mod caching_codemap_view;\n pub mod hasher;\n \n pub struct IncrementalHashesMap {\n-    hashes: FnvHashMap<DepNode<DefId>, Fingerprint>,\n+    hashes: FxHashMap<DepNode<DefId>, Fingerprint>,\n \n     // These are the metadata hashes for the current crate as they were stored\n     // during the last compilation session. They are only loaded if\n     // -Z query-dep-graph was specified and are needed for auto-tests using\n     // the #[rustc_metadata_dirty] and #[rustc_metadata_clean] attributes to\n     // check whether some metadata hash has changed in between two revisions.\n-    pub prev_metadata_hashes: RefCell<FnvHashMap<DefId, Fingerprint>>,\n+    pub prev_metadata_hashes: RefCell<FxHashMap<DefId, Fingerprint>>,\n }\n \n impl IncrementalHashesMap {\n     pub fn new() -> IncrementalHashesMap {\n         IncrementalHashesMap {\n-            hashes: FnvHashMap(),\n-            prev_metadata_hashes: RefCell::new(FnvHashMap()),\n+            hashes: FxHashMap(),\n+            prev_metadata_hashes: RefCell::new(FxHashMap()),\n         }\n     }\n "}, {"sha": "0b0dd596784e91cf43b3af98f1bb8474c0fcc401", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -88,6 +88,8 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     // within the CodeMap.\n     // Also note that we are hashing byte offsets for the column, not unicode\n     // codepoint offsets. For the purpose of the hash that's sufficient.\n+    // Also, hashing filenames is expensive so we avoid doing it twice when the\n+    // span starts and ends in the same file, which is almost always the case.\n     fn hash_span(&mut self, span: Span) {\n         debug!(\"hash_span: st={:?}\", self.st);\n \n@@ -103,21 +105,35 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             span.hi\n         };\n \n-        let loc1 = self.codemap.byte_pos_to_line_and_col(span.lo);\n-        let loc2 = self.codemap.byte_pos_to_line_and_col(span_hi);\n-\n-        let expansion_kind = match span.expn_id {\n+        let expn_kind = match span.expn_id {\n             NO_EXPANSION => SawSpanExpnKind::NoExpansion,\n             COMMAND_LINE_EXPN => SawSpanExpnKind::CommandLine,\n             _ => SawSpanExpnKind::SomeExpansion,\n         };\n \n-        SawSpan(loc1.as_ref().map(|&(ref fm, line, col)| (&fm.name[..], line, col)),\n-                loc2.as_ref().map(|&(ref fm, line, col)| (&fm.name[..], line, col)),\n-                expansion_kind)\n-            .hash(self.st);\n+        let loc1 = self.codemap.byte_pos_to_line_and_col(span.lo);\n+        let loc1 = loc1.as_ref()\n+                       .map(|&(ref fm, line, col)| (&fm.name[..], line, col))\n+                       .unwrap_or((\"???\", 0, BytePos(0)));\n+\n+        let loc2 = self.codemap.byte_pos_to_line_and_col(span_hi);\n+        let loc2 = loc2.as_ref()\n+                       .map(|&(ref fm, line, col)| (&fm.name[..], line, col))\n+                       .unwrap_or((\"???\", 0, BytePos(0)));\n+\n+        let saw = if loc1.0 == loc2.0 {\n+            SawSpan(loc1.0,\n+                    loc1.1, loc1.2,\n+                    loc2.1, loc2.2,\n+                    expn_kind)\n+        } else {\n+            SawSpanTwoFiles(loc1.0, loc1.1, loc1.2,\n+                            loc2.0, loc2.1, loc2.2,\n+                            expn_kind)\n+        };\n+        saw.hash(self.st);\n \n-        if expansion_kind == SawSpanExpnKind::SomeExpansion {\n+        if expn_kind == SawSpanExpnKind::SomeExpansion {\n             let call_site = self.codemap.codemap().source_callsite(span);\n             self.hash_span(call_site);\n         }\n@@ -189,9 +205,13 @@ enum SawAbiComponent<'a> {\n     SawAssocTypeBinding,\n     SawAttribute(ast::AttrStyle),\n     SawMacroDef,\n-    SawSpan(Option<(&'a str, usize, BytePos)>,\n-            Option<(&'a str, usize, BytePos)>,\n+    SawSpan(&'a str,\n+            usize, BytePos,\n+            usize, BytePos,\n             SawSpanExpnKind),\n+    SawSpanTwoFiles(&'a str, usize, BytePos,\n+                    &'a str, usize, BytePos,\n+                    SawSpanExpnKind),\n }\n \n /// SawExprComponent carries all of the information that we want\n@@ -814,7 +834,8 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             Def::Const(..) |\n             Def::AssociatedConst(..) |\n             Def::Local(..) |\n-            Def::Upvar(..) => {\n+            Def::Upvar(..) |\n+            Def::Macro(..) => {\n                 DefHash::SawDefId.hash(self.st);\n                 self.hash_def_id(def.def_id());\n             }"}, {"sha": "4a5a6b9bea90072bcc0c1c122b2368478c342026", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -19,7 +19,7 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![cfg_attr(stage0, feature(question_mark))]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "f0e4f4f99ef08e2977bbf069262e598db9d8bb8a", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -13,7 +13,7 @@\n use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n use std::sync::Arc;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use ich::Fingerprint;\n \n use super::directory::DefPathIndex;\n@@ -106,7 +106,7 @@ pub struct SerializedMetadataHashes {\n     /// is only populated if -Z query-dep-graph is specified. It will be\n     /// empty otherwise. Importing crates are perfectly happy with just having\n     /// the DefIndex.\n-    pub index_map: FnvHashMap<DefIndex, DefPathIndex>\n+    pub index_map: FxHashMap<DefIndex, DefPathIndex>\n }\n \n /// The hash for some metadata that (when saving) will be exported"}, {"sha": "69b9be12de46c2de35a2438896546a3b81f80db8", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -47,7 +47,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::Visitor;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n-use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n@@ -67,7 +67,7 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    let dirty_inputs: FnvHashSet<DepNode<DefId>> =\n+    let dirty_inputs: FxHashSet<DepNode<DefId>> =\n         dirty_inputs.iter()\n                    .filter_map(|d| retraced.map(d))\n                    .collect();\n@@ -84,7 +84,7 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     query: &'a DepGraphQuery<DefId>,\n-    dirty_inputs: FnvHashSet<DepNode<DefId>>,\n+    dirty_inputs: FxHashSet<DepNode<DefId>>,\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n@@ -187,8 +187,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n }\n \n pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  prev_metadata_hashes: &FnvHashMap<DefId, Fingerprint>,\n-                                  current_metadata_hashes: &FnvHashMap<DefId, Fingerprint>) {\n+                                  prev_metadata_hashes: &FxHashMap<DefId, Fingerprint>,\n+                                  current_metadata_hashes: &FxHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return;\n     }\n@@ -205,8 +205,8 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    prev_metadata_hashes: &'m FnvHashMap<DefId, Fingerprint>,\n-    current_metadata_hashes: &'m FnvHashMap<DefId, Fingerprint>,\n+    prev_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n+    current_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n }\n \n impl<'a, 'tcx, 'm> Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {"}, {"sha": "ca9c119202322038911521a217625f81e2fc56c6", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -120,7 +120,7 @@ use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::util::fs as fs_util;\n use rustc_data_structures::flock;\n-use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use std::ffi::OsString;\n use std::fs as std_fs;\n@@ -195,7 +195,7 @@ pub fn prepare_session_directory(tcx: TyCtxt) -> Result<bool, ()> {\n     debug!(\"crate-dir: {}\", crate_dir.display());\n     try!(create_dir(tcx.sess, &crate_dir, \"crate\"));\n \n-    let mut source_directories_already_tried = FnvHashSet();\n+    let mut source_directories_already_tried = FxHashSet();\n \n     loop {\n         // Generate a session directory of the form:\n@@ -490,7 +490,7 @@ fn delete_session_dir_lock_file(sess: &Session,\n /// Find the most recent published session directory that is not in the\n /// ignore-list.\n fn find_source_directory(crate_dir: &Path,\n-                         source_directories_already_tried: &FnvHashSet<PathBuf>)\n+                         source_directories_already_tried: &FxHashSet<PathBuf>)\n                          -> Option<PathBuf> {\n     let iter = crate_dir.read_dir()\n                         .unwrap() // FIXME\n@@ -500,7 +500,7 @@ fn find_source_directory(crate_dir: &Path,\n }\n \n fn find_source_directory_in_iter<I>(iter: I,\n-                                    source_directories_already_tried: &FnvHashSet<PathBuf>)\n+                                    source_directories_already_tried: &FxHashSet<PathBuf>)\n                                     -> Option<PathBuf>\n     where I: Iterator<Item=PathBuf>\n {\n@@ -704,8 +704,8 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n \n     // First do a pass over the crate directory, collecting lock files and\n     // session directories\n-    let mut session_directories = FnvHashSet();\n-    let mut lock_files = FnvHashSet();\n+    let mut session_directories = FxHashSet();\n+    let mut lock_files = FxHashSet();\n \n     for dir_entry in try!(crate_directory.read_dir()) {\n         let dir_entry = match dir_entry {\n@@ -731,7 +731,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     }\n \n     // Now map from lock files to session directories\n-    let lock_file_to_session_dir: FnvHashMap<String, Option<String>> =\n+    let lock_file_to_session_dir: FxHashMap<String, Option<String>> =\n         lock_files.into_iter()\n                   .map(|lock_file_name| {\n                         assert!(lock_file_name.ends_with(LOCK_FILE_EXT));\n@@ -774,7 +774,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     }\n \n     // Filter out `None` directories\n-    let lock_file_to_session_dir: FnvHashMap<String, String> =\n+    let lock_file_to_session_dir: FxHashMap<String, String> =\n         lock_file_to_session_dir.into_iter()\n                                 .filter_map(|(lock_file_name, directory_name)| {\n                                     directory_name.map(|n| (lock_file_name, n))\n@@ -898,7 +898,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n }\n \n fn all_except_most_recent(deletion_candidates: Vec<(SystemTime, PathBuf, Option<flock::Lock>)>)\n-                          -> FnvHashMap<PathBuf, Option<flock::Lock>> {\n+                          -> FxHashMap<PathBuf, Option<flock::Lock>> {\n     let most_recent = deletion_candidates.iter()\n                                          .map(|&(timestamp, ..)| timestamp)\n                                          .max();\n@@ -909,7 +909,7 @@ fn all_except_most_recent(deletion_candidates: Vec<(SystemTime, PathBuf, Option<\n                            .map(|(_, path, lock)| (path, lock))\n                            .collect()\n     } else {\n-        FnvHashMap()\n+        FxHashMap()\n     }\n }\n \n@@ -946,19 +946,19 @@ fn test_all_except_most_recent() {\n             (UNIX_EPOCH + Duration::new(5, 0), PathBuf::from(\"5\"), None),\n             (UNIX_EPOCH + Duration::new(3, 0), PathBuf::from(\"3\"), None),\n             (UNIX_EPOCH + Duration::new(2, 0), PathBuf::from(\"2\"), None),\n-        ]).keys().cloned().collect::<FnvHashSet<PathBuf>>(),\n+        ]).keys().cloned().collect::<FxHashSet<PathBuf>>(),\n         vec![\n             PathBuf::from(\"1\"),\n             PathBuf::from(\"2\"),\n             PathBuf::from(\"3\"),\n             PathBuf::from(\"4\"),\n-        ].into_iter().collect::<FnvHashSet<PathBuf>>()\n+        ].into_iter().collect::<FxHashSet<PathBuf>>()\n     );\n \n     assert_eq!(all_except_most_recent(\n         vec![\n-        ]).keys().cloned().collect::<FnvHashSet<PathBuf>>(),\n-        FnvHashSet()\n+        ]).keys().cloned().collect::<FxHashSet<PathBuf>>(),\n+        FxHashSet()\n     );\n }\n \n@@ -973,7 +973,7 @@ fn test_timestamp_serialization() {\n \n #[test]\n fn test_find_source_directory_in_iter() {\n-    let already_visited = FnvHashSet();\n+    let already_visited = FxHashSet();\n \n     // Find newest\n     assert_eq!(find_source_directory_in_iter("}, {"sha": "73311ee96c5308712fae79aa667076efcbb20d63", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -12,7 +12,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::svh::Svh;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::flock;\n use rustc_serialize::Decodable;\n use rustc_serialize::opaque::Decoder;\n@@ -26,8 +26,8 @@ use super::file_format;\n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     incremental_hashes_map: &'a IncrementalHashesMap,\n-    item_metadata_hashes: FnvHashMap<DefId, Fingerprint>,\n-    crate_hashes: FnvHashMap<CrateNum, Svh>,\n+    item_metadata_hashes: FxHashMap<DefId, Fingerprint>,\n+    crate_hashes: FxHashMap<CrateNum, Svh>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n@@ -37,8 +37,8 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         HashContext {\n             tcx: tcx,\n             incremental_hashes_map: incremental_hashes_map,\n-            item_metadata_hashes: FnvHashMap(),\n-            crate_hashes: FnvHashMap(),\n+            item_metadata_hashes: FxHashMap(),\n+            crate_hashes: FxHashMap(),\n         }\n     }\n "}, {"sha": "12bf74c95116d508b197daf711a824071bcd511a", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -15,7 +15,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::fs;\n@@ -30,7 +30,7 @@ use super::hash::*;\n use super::fs::*;\n use super::file_format;\n \n-pub type DirtyNodes = FnvHashSet<DepNode<DefPathIndex>>;\n+pub type DirtyNodes = FxHashSet<DepNode<DefPathIndex>>;\n \n /// If we are in incremental mode, and a previous dep-graph exists,\n /// then load up those nodes/edges that are still valid into the\n@@ -183,7 +183,7 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Compute which work-products have an input that has changed or\n     // been removed. Put the dirty ones into a set.\n-    let mut dirty_target_nodes = FnvHashSet();\n+    let mut dirty_target_nodes = FxHashSet();\n     for &(raw_source_node, ref target_node) in &retraced_edges {\n         if dirty_raw_source_nodes.contains(raw_source_node) {\n             if !dirty_target_nodes.contains(target_node) {\n@@ -239,7 +239,7 @@ fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          retraced: &RetracedDefIdDirectory)\n                          -> DirtyNodes {\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n-    let mut dirty_nodes = FnvHashSet();\n+    let mut dirty_nodes = FxHashSet();\n \n     for hash in serialized_hashes {\n         if let Some(dep_node) = retraced.map(&hash.dep_node) {\n@@ -270,7 +270,7 @@ fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// otherwise no longer applicable.\n fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      work_products: Vec<SerializedWorkProduct>,\n-                                     dirty_target_nodes: &FnvHashSet<DepNode<DefId>>) {\n+                                     dirty_target_nodes: &FxHashSet<DepNode<DefId>>) {\n     debug!(\"reconcile_work_products({:?})\", work_products);\n     for swp in work_products {\n         if dirty_target_nodes.contains(&DepNode::WorkProduct(swp.id.clone())) {\n@@ -314,7 +314,7 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n \n fn load_prev_metadata_hashes(tcx: TyCtxt,\n                              retraced: &RetracedDefIdDirectory,\n-                             output: &mut FnvHashMap<DefId, Fingerprint>) {\n+                             output: &mut FxHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return\n     }"}, {"sha": "e1968ce8d7b6ad541234ed9ff990b36022941633", "filename": "src/librustc_incremental/persist/preds.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir::def_id::DefId;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{DepthFirstTraversal, INCOMING, NodeIndex};\n \n use super::hash::*;\n@@ -23,11 +23,11 @@ pub struct Predecessors<'query> {\n     //   nodes.\n     // - Values: transitive predecessors of the key that are hashable\n     //   (e.g., HIR nodes, input meta-data nodes)\n-    pub inputs: FnvHashMap<&'query DepNode<DefId>, Vec<&'query DepNode<DefId>>>,\n+    pub inputs: FxHashMap<&'query DepNode<DefId>, Vec<&'query DepNode<DefId>>>,\n \n     // - Keys: some hashable node\n     // - Values: the hash thereof\n-    pub hashes: FnvHashMap<&'query DepNode<DefId>, Fingerprint>,\n+    pub hashes: FxHashMap<&'query DepNode<DefId>, Fingerprint>,\n }\n \n impl<'q> Predecessors<'q> {\n@@ -37,7 +37,7 @@ impl<'q> Predecessors<'q> {\n         let all_nodes = query.graph.all_nodes();\n         let tcx = hcx.tcx;\n \n-        let inputs: FnvHashMap<_, _> = all_nodes.iter()\n+        let inputs: FxHashMap<_, _> = all_nodes.iter()\n             .enumerate()\n             .filter(|&(_, node)| match node.data {\n                 DepNode::WorkProduct(_) => true,\n@@ -60,7 +60,7 @@ impl<'q> Predecessors<'q> {\n             })\n             .collect();\n \n-        let mut hashes = FnvHashMap();\n+        let mut hashes = FxHashMap();\n         for input in inputs.values().flat_map(|v| v.iter().cloned()) {\n             hashes.entry(input)\n                   .or_insert_with(|| hcx.hash(input).unwrap());"}, {"sha": "289eebb2162083a1ee44de841288d95e5b45b918", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n use std::hash::Hash;\n@@ -46,7 +46,7 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let query = tcx.dep_graph.query();\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let preds = Predecessors::new(&query, &mut hcx);\n-    let mut current_metadata_hashes = FnvHashMap();\n+    let mut current_metadata_hashes = FxHashMap();\n \n     // IMPORTANT: We are saving the metadata hashes *before* the dep-graph,\n     //            since metadata-encoding might add new entries to the\n@@ -186,7 +186,7 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n                               svh: Svh,\n                               preds: &Predecessors,\n                               builder: &mut DefIdDirectoryBuilder,\n-                              current_metadata_hashes: &mut FnvHashMap<DefId, Fingerprint>,\n+                              current_metadata_hashes: &mut FxHashMap<DefId, Fingerprint>,\n                               encoder: &mut Encoder)\n                               -> io::Result<()> {\n     // For each `MetaData(X)` node where `X` is local, accumulate a\n@@ -198,10 +198,10 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n     // (I initially wrote this with an iterator, but it seemed harder to read.)\n     let mut serialized_hashes = SerializedMetadataHashes {\n         hashes: vec![],\n-        index_map: FnvHashMap()\n+        index_map: FxHashMap()\n     };\n \n-    let mut def_id_hashes = FnvHashMap();\n+    let mut def_id_hashes = FxHashMap();\n \n     for (&target, sources) in &preds.inputs {\n         let def_id = match *target {"}, {"sha": "6320a923d690c720004d972187252c76e93729e7", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -29,10 +29,10 @@ pub enum MethodLateContext {\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n     let def_id = cx.tcx.map.local_def_id(id);\n-    match cx.tcx.impl_or_trait_items.borrow().get(&def_id) {\n+    match cx.tcx.associated_items.borrow().get(&def_id) {\n         None => span_bug!(span, \"missing method descriptor?!\"),\n         Some(item) => {\n-            match item.container() {\n+            match item.container {\n                 ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n                 ty::ImplContainer(cid) => {\n                     match cx.tcx.impl_trait_ref(cid) {\n@@ -250,7 +250,7 @@ impl LateLintPass for NonSnakeCase {\n                 cx: &LateContext,\n                 fk: FnKind,\n                 _: &hir::FnDecl,\n-                _: &hir::Block,\n+                _: &hir::Expr,\n                 span: Span,\n                 id: ast::NodeId) {\n         match fk {"}, {"sha": "c19b3c40f65c09ad40481e33cdc2ad429e32ead0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -34,7 +34,6 @@ use middle::stability;\n use rustc::cfg;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::adjustment;\n use rustc::traits::{self, Reveal};\n use rustc::hir::map as hir_map;\n use util::nodemap::NodeSet;\n@@ -118,7 +117,9 @@ impl LateLintPass for BoxPointers {\n             hir::ItemTy(..) |\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => self.check_heap_type(cx, it.span, cx.tcx.node_id_to_type(it.id)),\n+            hir::ItemUnion(..) => {\n+                self.check_heap_type(cx, it.span, cx.tcx.tables().node_id_to_type(it.id))\n+            }\n             _ => (),\n         }\n \n@@ -129,15 +130,15 @@ impl LateLintPass for BoxPointers {\n                 for struct_field in struct_def.fields() {\n                     self.check_heap_type(cx,\n                                          struct_field.span,\n-                                         cx.tcx.node_id_to_type(struct_field.id));\n+                                         cx.tcx.tables().node_id_to_type(struct_field.id));\n                 }\n             }\n             _ => (),\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        let ty = cx.tcx.node_id_to_type(e.id);\n+        let ty = cx.tcx.tables().node_id_to_type(e.id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -221,7 +222,7 @@ impl LateLintPass for UnsafeCode {\n                 cx: &LateContext,\n                 fk: FnKind,\n                 _: &hir::FnDecl,\n-                _: &hir::Block,\n+                _: &hir::Expr,\n                 span: Span,\n                 _: ast::NodeId) {\n         match fk {\n@@ -585,7 +586,7 @@ impl LateLintPass for MissingDebugImplementations {\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n                 if let Some(n) = cx.tcx.map.as_local_node_id(d) {\n-                    if let Some(ty_def) = cx.tcx.node_id_to_type(n).ty_to_def_id() {\n+                    if let Some(ty_def) = cx.tcx.tables().node_id_to_type(n).ty_to_def_id() {\n                         if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n                             impls.insert(node_id);\n                         }\n@@ -811,13 +812,13 @@ impl LateLintPass for UnconditionalRecursion {\n                 cx: &LateContext,\n                 fn_kind: FnKind,\n                 _: &hir::FnDecl,\n-                blk: &hir::Block,\n+                blk: &hir::Expr,\n                 sp: Span,\n                 id: ast::NodeId) {\n         let method = match fn_kind {\n             FnKind::ItemFn(..) => None,\n             FnKind::Method(..) => {\n-                cx.tcx.impl_or_trait_item(cx.tcx.map.local_def_id(id)).as_opt_method()\n+                Some(cx.tcx.associated_item(cx.tcx.map.local_def_id(id)))\n             }\n             // closures can't recur, so they don't matter.\n             FnKind::Closure(_) => return,\n@@ -936,27 +937,26 @@ impl LateLintPass for UnconditionalRecursion {\n \n         // Check if the expression `id` performs a call to `method`.\n         fn expr_refers_to_this_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                method: &ty::Method,\n+                                                method: &ty::AssociatedItem,\n                                                 id: ast::NodeId)\n                                                 -> bool {\n+            use rustc::ty::adjustment::*;\n+\n             // Check for method calls and overloaded operators.\n-            let opt_m = tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)).cloned();\n+            let opt_m = tcx.tables().method_map.get(&ty::MethodCall::expr(id)).cloned();\n             if let Some(m) = opt_m {\n                 if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                     return true;\n                 }\n             }\n \n             // Check for overloaded autoderef method calls.\n-            let opt_adj = tcx.tables.borrow().adjustments.get(&id).cloned();\n-            if let Some(adjustment::AdjustDerefRef(adj)) = opt_adj {\n-                for i in 0..adj.autoderefs {\n+            let opt_adj = tcx.tables().adjustments.get(&id).cloned();\n+            if let Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) = opt_adj {\n+                for i in 0..autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = tcx.tables\n-                        .borrow()\n-                        .method_map\n-                        .get(&method_call)\n-                        .cloned() {\n+                    if let Some(m) = tcx.tables().method_map.get(&method_call)\n+                                                            .cloned() {\n                         if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                             return true;\n                         }\n@@ -971,12 +971,10 @@ impl LateLintPass for UnconditionalRecursion {\n                     // it doesn't necessarily have a definition.\n                     match tcx.expect_def_or_none(callee.id) {\n                         Some(Def::Method(def_id)) => {\n-                            let item_substs = tcx.node_id_item_substs(callee.id);\n-                            method_call_refers_to_method(tcx,\n-                                                         method,\n-                                                         def_id,\n-                                                         &item_substs.substs,\n-                                                         id)\n+                            let substs = tcx.tables().node_id_item_substs(callee.id)\n+                                .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                            method_call_refers_to_method(\n+                                tcx, method, def_id, substs, id)\n                         }\n                         _ => false,\n                     }\n@@ -988,14 +986,14 @@ impl LateLintPass for UnconditionalRecursion {\n         // Check if the method call to the method with the ID `callee_id`\n         // and instantiated with `callee_substs` refers to method `method`.\n         fn method_call_refers_to_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                  method: &ty::Method,\n+                                                  method: &ty::AssociatedItem,\n                                                   callee_id: DefId,\n                                                   callee_substs: &Substs<'tcx>,\n                                                   expr_id: ast::NodeId)\n                                                   -> bool {\n-            let callee_item = tcx.impl_or_trait_item(callee_id);\n+            let callee_item = tcx.associated_item(callee_id);\n \n-            match callee_item.container() {\n+            match callee_item.container {\n                 // This is an inherent method, so the `def_id` refers\n                 // directly to the method definition.\n                 ty::ImplContainer(_) => callee_id == method.def_id,\n@@ -1036,7 +1034,7 @@ impl LateLintPass for UnconditionalRecursion {\n                                 let container = ty::ImplContainer(vtable_impl.impl_def_id);\n                                 // It matches if it comes from the same impl,\n                                 // and has the same method name.\n-                                container == method.container && callee_item.name() == method.name\n+                                container == method.container && callee_item.name == method.name\n                             }\n \n                             // There's no way to know if this call is\n@@ -1213,7 +1211,7 @@ impl LateLintPass for MutableTransmutes {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let typ = cx.tcx.node_id_to_type(expr.id);\n+                let typ = cx.tcx.tables().node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyFnDef(.., ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n                         let from = bare_fn.sig.0.inputs[0];\n@@ -1284,7 +1282,7 @@ impl LateLintPass for UnionsWithDropFields {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {\n-                let field_ty = ctx.tcx.node_id_to_type(field.id);\n+                let field_ty = ctx.tcx.tables().node_id_to_type(field.id);\n                 if ctx.tcx.type_needs_drop_given_env(field_ty, param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,"}, {"sha": "114c0ea556ef5f6b712721da87b618f3da336977", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -31,13 +31,12 @@\n #![cfg_attr(test, feature(test))]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n-#![feature(dotdot_in_tuple_patterns)]\n \n #[macro_use]\n extern crate syntax;\n@@ -229,6 +228,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(PATTERNS_IN_FNS_WITHOUT_BODY),\n             reference: \"issue #35203 <https://github.com/rust-lang/rust/issues/35203>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(EXTRA_REQUIREMENT_IN_IMPL),\n+            reference: \"issue #37166 <https://github.com/rust-lang/rust/issues/37166>\",\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "48471282672adf8563ba7d0de76ad0ca99fa21ab", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -18,7 +18,7 @@ use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n \n@@ -113,14 +113,14 @@ impl LateLintPass for TypeLimits {\n                             forbid_unsigned_negation(cx, e.span);\n                         }\n                         ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n-                            if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n+                            if let ty::TyUint(_) = cx.tcx.tables().node_id_to_type(e.id).sty {\n                                 forbid_unsigned_negation(cx, e.span);\n                             }\n                         }\n                         _ => (),\n                     }\n                 } else {\n-                    let t = cx.tcx.node_id_to_type(expr.id);\n+                    let t = cx.tcx.tables().node_id_to_type(expr.id);\n                     if let ty::TyUint(_) = t.sty {\n                         forbid_unsigned_negation(cx, e.span);\n                     }\n@@ -138,7 +138,7 @@ impl LateLintPass for TypeLimits {\n                 }\n \n                 if binop.node.is_shift() {\n-                    let opt_ty_bits = match cx.tcx.node_id_to_type(l.id).sty {\n+                    let opt_ty_bits = match cx.tcx.tables().node_id_to_type(l.id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None,\n@@ -171,7 +171,7 @@ impl LateLintPass for TypeLimits {\n                 }\n             }\n             hir::ExprLit(ref lit) => {\n-                match cx.tcx.node_id_to_type(e.id).sty {\n+                match cx.tcx.tables().node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -324,7 +324,7 @@ impl LateLintPass for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match tcx.node_id_to_type(expr.id).sty {\n+            match tcx.tables().node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n@@ -428,7 +428,7 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n-    fn check_type_for_ffi(&self, cache: &mut FnvHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult {\n+    fn check_type_for_ffi(&self, cache: &mut FxHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult {\n         use self::FfiResult::*;\n         let cx = self.cx.tcx;\n \n@@ -639,7 +639,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         // any generic types right now:\n         let ty = self.cx.tcx.normalize_associated_type(&ty);\n \n-        match self.check_type_for_ffi(&mut FnvHashSet(), ty) {\n+        match self.check_type_for_ffi(&mut FxHashSet(), ty) {\n             FfiResult::FfiSafe => {}\n             FfiResult::FfiUnsafe(s) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp, s);\n@@ -740,7 +740,7 @@ impl LateLintPass for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-                let t = cx.tcx.node_id_to_type(it.id);\n+                let t = cx.tcx.tables().node_id_to_type(it.id);\n                 let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n                     ty.layout(&infcx)"}, {"sha": "0668d362037dd3450a3f98c37086cde0f35b1eba", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -11,15 +11,15 @@\n use rustc::hir::pat_util;\n use rustc::ty;\n use rustc::ty::adjustment;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use lint::{LateContext, EarlyContext, LintContext, LintArray};\n use lint::{LintPass, EarlyLintPass, LateLintPass};\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n+use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n use syntax::parse::token::keywords;\n use syntax::ptr::P;\n use syntax_pos::Span;\n@@ -42,7 +42,7 @@ impl UnusedMut {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n         // avoid false warnings in match arms with multiple patterns\n \n-        let mut mutables = FnvHashMap();\n+        let mut mutables = FxHashMap();\n         for p in pats {\n             pat_util::pat_bindings(p, |mode, id, _, path1| {\n                 let name = path1.node;\n@@ -99,7 +99,7 @@ impl LateLintPass for UnusedMut {\n                 cx: &LateContext,\n                 _: FnKind,\n                 decl: &hir::FnDecl,\n-                _: &hir::Block,\n+                _: &hir::Expr,\n                 _: Span,\n                 _: ast::NodeId) {\n         for a in &decl.inputs {\n@@ -140,7 +140,7 @@ impl LateLintPass for UnusedResults {\n             return;\n         }\n \n-        let t = cx.tcx.expr_ty(&expr);\n+        let t = cx.tcx.tables().expr_ty(&expr);\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyNever => return,\n@@ -245,7 +245,7 @@ impl LateLintPass for UnusedAttributes {\n         debug!(\"checking attribute: {:?}\", attr);\n \n         // Note that check_name() marks the attribute as used if it matches.\n-        for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n+        for &(ref name, ty, _) in BUILTIN_ATTRIBUTES {\n             match ty {\n                 AttributeType::Whitelisted if attr.check_name(name) => {\n                     debug!(\"{:?} is Whitelisted\", name);\n@@ -267,7 +267,7 @@ impl LateLintPass for UnusedAttributes {\n             debug!(\"Emitting warning for: {:?}\", attr);\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n-            let known_crate = KNOWN_ATTRIBUTES.iter()\n+            let known_crate = BUILTIN_ATTRIBUTES.iter()\n                 .find(|&&(name, ty, _)| attr.name() == name && ty == AttributeType::CrateLevel)\n                 .is_some();\n \n@@ -441,16 +441,15 @@ impl LateLintPass for UnusedAllocation {\n             _ => return,\n         }\n \n-        if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n-            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef { ref autoref, .. }) =\n-                *adjustment {\n+        if let Some(adjustment) = cx.tcx.tables().adjustments.get(&e.id) {\n+            if let adjustment::Adjust::DerefRef { autoref, .. } = adjustment.kind {\n                 match autoref {\n-                    &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n+                    Some(adjustment::AutoBorrow::Ref(_, hir::MutImmutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION,\n                                      e.span,\n                                      \"unnecessary allocation, use & instead\");\n                     }\n-                    &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n+                    Some(adjustment::AutoBorrow::Ref(_, hir::MutMutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION,\n                                      e.span,\n                                      \"unnecessary allocation, use &mut instead\");"}, {"sha": "8656bb8bf00360f459f62c26190cc1c531265988", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -128,6 +128,19 @@ fn main() {\n     // of llvm-config, not the target that we're attempting to link.\n     let mut cmd = Command::new(&llvm_config);\n     cmd.arg(\"--libs\");\n+\n+    // Force static linking with \"--link-static\" if available.\n+    let mut version_cmd = Command::new(&llvm_config);\n+    version_cmd.arg(\"--version\");\n+    let version_output = output(&mut version_cmd);\n+    let mut parts = version_output.split('.');\n+    if let (Some(major), Some(minor)) = (parts.next().and_then(|s| s.parse::<u32>().ok()),\n+                                         parts.next().and_then(|s| s.parse::<u32>().ok())) {\n+        if major > 3 || (major == 3 && minor >= 9) {\n+            cmd.arg(\"--link-static\");\n+        }\n+    }\n+\n     if !is_crossed {\n         cmd.arg(\"--system-libs\");\n     }"}, {"sha": "07b87072c435e6ef14d9ebc0322285e6fe3446ca", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -29,6 +29,7 @@\n #![feature(staged_api)]\n #![feature(linked_from)]\n #![feature(concat_idents)]\n+#![cfg_attr(not(stage0), feature(rustc_private))]\n \n extern crate libc;\n #[macro_use]"}, {"sha": "e009955b92ee4a67cc7f13f05bf4f3e93189ddcf", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -38,7 +38,7 @@ enum TableEntry<'tcx> {\n     Def(Def),\n     NodeType(Ty<'tcx>),\n     ItemSubsts(ty::ItemSubsts<'tcx>),\n-    Adjustment(ty::adjustment::AutoAdjustment<'tcx>),\n+    Adjustment(ty::adjustment::Adjustment<'tcx>),\n     ConstQualif(ConstQualif),\n }\n \n@@ -94,9 +94,9 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx>\n         };\n \n         encode(tcx.expect_def_or_none(id).map(TableEntry::Def));\n-        encode(tcx.node_types().get(&id).cloned().map(TableEntry::NodeType));\n-        encode(tcx.tables.borrow().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n-        encode(tcx.tables.borrow().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n+        encode(tcx.tables().node_types.get(&id).cloned().map(TableEntry::NodeType));\n+        encode(tcx.tables().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n+        encode(tcx.tables().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n         encode(tcx.const_qualif_map.borrow().get(&id).cloned().map(TableEntry::ConstQualif));\n     }\n }"}, {"sha": "75944122f5c10ab93b18455c215a8f63f1f52479", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 120, "deletions": 197, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -16,28 +16,27 @@ use schema::CrateRoot;\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::LoadedMacros;\n+use rustc::middle::cstore::DepKind;\n use rustc::session::{config, Session};\n use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc::hir::map::Definitions;\n \n use std::cell::{RefCell, Cell};\n use std::ops::Deref;\n use std::path::PathBuf;\n use std::rc::Rc;\n-use std::fs;\n+use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::parse;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::parse::token::{InternedString, intern};\n-use syntax_pos::{self, Span, mk_sp};\n+use syntax_pos::{Span, DUMMY_SP};\n use log;\n \n pub struct Library {\n@@ -50,35 +49,29 @@ pub struct CrateLoader<'a> {\n     pub sess: &'a Session,\n     cstore: &'a CStore,\n     next_crate_num: CrateNum,\n-    foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n+    foreign_item_map: FxHashMap<String, Vec<ast::NodeId>>,\n     local_crate_name: String,\n }\n \n fn dump_crates(cstore: &CStore) {\n     info!(\"resolved crates:\");\n-    cstore.iter_crate_data_origins(|_, data, opt_source| {\n+    cstore.iter_crate_data(|_, data| {\n         info!(\"  name: {}\", data.name());\n         info!(\"  cnum: {}\", data.cnum);\n         info!(\"  hash: {}\", data.hash());\n-        info!(\"  reqd: {}\", data.explicitly_linked.get());\n-        opt_source.map(|cs| {\n-            let CrateSource { dylib, rlib, cnum: _ } = cs;\n-            dylib.map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n-            rlib.map(|rl|  info!(\"   rlib: {}\", rl.0.display()));\n-        });\n+        info!(\"  reqd: {:?}\", data.dep_kind.get());\n+        let CrateSource { dylib, rlib } = data.source.clone();\n+        dylib.map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n+        rlib.map(|rl|  info!(\"   rlib: {}\", rl.0.display()));\n     })\n }\n \n-fn should_link(i: &ast::Item) -> bool {\n-    !attr::contains_name(&i.attrs, \"no_link\")\n-}\n-\n #[derive(Debug)]\n struct ExternCrateInfo {\n     ident: String,\n     name: String,\n     id: ast::NodeId,\n-    should_link: bool,\n+    dep_kind: DepKind,\n }\n \n fn register_native_lib(sess: &Session,\n@@ -148,7 +141,7 @@ impl<'a> CrateLoader<'a> {\n             sess: sess,\n             cstore: cstore,\n             next_crate_num: cstore.next_crate_num(),\n-            foreign_item_map: FnvHashMap(),\n+            foreign_item_map: FxHashMap(),\n             local_crate_name: local_crate_name.to_owned(),\n         }\n     }\n@@ -170,7 +163,11 @@ impl<'a> CrateLoader<'a> {\n                     ident: i.ident.to_string(),\n                     name: name,\n                     id: i.id,\n-                    should_link: should_link(i),\n+                    dep_kind: if attr::contains_name(&i.attrs, \"no_link\") {\n+                        DepKind::MacrosOnly\n+                    } else {\n+                        DepKind::Explicit\n+                    },\n                 })\n             }\n             _ => None\n@@ -260,9 +257,8 @@ impl<'a> CrateLoader<'a> {\n                       name: &str,\n                       span: Span,\n                       lib: Library,\n-                      explicitly_linked: bool)\n-                      -> (CrateNum, Rc<cstore::CrateMetadata>,\n-                          cstore::CrateSource) {\n+                      dep_kind: DepKind)\n+                      -> (CrateNum, Rc<cstore::CrateMetadata>) {\n         info!(\"register crate `extern crate {} as {}`\", name, ident);\n         let crate_root = lib.metadata.get_root();\n         self.verify_no_symbol_conflicts(span, &crate_root);\n@@ -286,34 +282,29 @@ impl<'a> CrateLoader<'a> {\n \n         let Library { dylib, rlib, metadata } = lib;\n \n-        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span);\n-\n-        if crate_root.macro_derive_registrar.is_some() {\n-            self.sess.span_err(span, \"crates of the `proc-macro` crate type \\\n-                                      cannot be linked at runtime\");\n-        }\n+        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let cmeta = Rc::new(cstore::CrateMetadata {\n             name: name.to_string(),\n             extern_crate: Cell::new(None),\n             key_map: metadata.load_key_map(crate_root.index),\n+            proc_macros: crate_root.macro_derive_registrar.map(|_| {\n+                self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n+            }),\n             root: crate_root,\n             blob: metadata,\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n             codemap_import_info: RefCell::new(vec![]),\n-            explicitly_linked: Cell::new(explicitly_linked),\n+            dep_kind: Cell::new(dep_kind),\n+            source: cstore::CrateSource {\n+                dylib: dylib,\n+                rlib: rlib,\n+            },\n         });\n \n-        let source = cstore::CrateSource {\n-            dylib: dylib,\n-            rlib: rlib,\n-            cnum: cnum,\n-        };\n-\n         self.cstore.set_crate_data(cnum, cmeta.clone());\n-        self.cstore.add_used_crate_source(source.clone());\n-        (cnum, cmeta, source)\n+        (cnum, cmeta)\n     }\n \n     fn resolve_crate(&mut self,\n@@ -323,47 +314,58 @@ impl<'a> CrateLoader<'a> {\n                      hash: Option<&Svh>,\n                      span: Span,\n                      kind: PathKind,\n-                     explicitly_linked: bool)\n-                     -> (CrateNum, Rc<cstore::CrateMetadata>, cstore::CrateSource) {\n+                     mut dep_kind: DepKind)\n+                     -> (CrateNum, Rc<cstore::CrateMetadata>) {\n         info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n-        let result = match self.existing_match(name, hash, kind) {\n-            Some(cnum) => LoadResult::Previous(cnum),\n-            None => {\n-                info!(\"falling back to a load\");\n-                let mut locate_ctxt = locator::Context {\n-                    sess: self.sess,\n-                    span: span,\n-                    ident: ident,\n-                    crate_name: name,\n-                    hash: hash.map(|a| &*a),\n-                    filesearch: self.sess.target_filesearch(kind),\n-                    target: &self.sess.target.target,\n-                    triple: &self.sess.opts.target_triple,\n-                    root: root,\n+        let result = if let Some(cnum) = self.existing_match(name, hash, kind) {\n+            LoadResult::Previous(cnum)\n+        } else {\n+            info!(\"falling back to a load\");\n+            let mut locate_ctxt = locator::Context {\n+                sess: self.sess,\n+                span: span,\n+                ident: ident,\n+                crate_name: name,\n+                hash: hash.map(|a| &*a),\n+                filesearch: self.sess.target_filesearch(kind),\n+                target: &self.sess.target.target,\n+                triple: &self.sess.opts.target_triple,\n+                root: root,\n+                rejected_via_hash: vec![],\n+                rejected_via_triple: vec![],\n+                rejected_via_kind: vec![],\n+                rejected_via_version: vec![],\n+                should_match_name: true,\n+                is_proc_macro: Some(false),\n+            };\n+\n+            self.load(&mut locate_ctxt).or_else(|| {\n+                dep_kind = DepKind::MacrosOnly;\n+\n+                let mut proc_macro_locator = locator::Context {\n+                    target: &self.sess.host,\n+                    triple: config::host_triple(),\n+                    filesearch: self.sess.host_filesearch(PathKind::Crate),\n                     rejected_via_hash: vec![],\n                     rejected_via_triple: vec![],\n                     rejected_via_kind: vec![],\n                     rejected_via_version: vec![],\n-                    should_match_name: true,\n+                    is_proc_macro: Some(true),\n+                    ..locate_ctxt\n                 };\n-                match self.load(&mut locate_ctxt) {\n-                    Some(result) => result,\n-                    None => locate_ctxt.report_errs(),\n-                }\n-            }\n+\n+                self.load(&mut proc_macro_locator)\n+            }).unwrap_or_else(|| locate_ctxt.report_errs())\n         };\n \n         match result {\n             LoadResult::Previous(cnum) => {\n                 let data = self.cstore.get_crate_data(cnum);\n-                if explicitly_linked && !data.explicitly_linked.get() {\n-                    data.explicitly_linked.set(explicitly_linked);\n-                }\n-                (cnum, data, self.cstore.used_crate_source(cnum))\n+                data.dep_kind.set(cmp::max(data.dep_kind.get(), dep_kind));\n+                (cnum, data)\n             }\n             LoadResult::Loaded(library) => {\n-                self.register_crate(root, ident, name, span, library,\n-                                    explicitly_linked)\n+                self.register_crate(root, ident, name, span, library, dep_kind)\n             }\n         }\n     }\n@@ -401,7 +403,7 @@ impl<'a> CrateLoader<'a> {\n     fn update_extern_crate(&mut self,\n                            cnum: CrateNum,\n                            mut extern_crate: ExternCrate,\n-                           visited: &mut FnvHashSet<(CrateNum, bool)>)\n+                           visited: &mut FxHashSet<(CrateNum, bool)>)\n     {\n         if !visited.insert((cnum, extern_crate.direct)) { return }\n \n@@ -436,21 +438,27 @@ impl<'a> CrateLoader<'a> {\n                           crate_root: &CrateRoot,\n                           metadata: &MetadataBlob,\n                           krate: CrateNum,\n-                          span: Span)\n+                          span: Span,\n+                          dep_kind: DepKind)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n+        if crate_root.macro_derive_registrar.is_some() {\n+            return cstore::CrateNumMap::new();\n+        }\n+\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n         let deps = crate_root.crate_deps.decode(metadata);\n-        let map: FnvHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n+        let map: FxHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n-            let (local_cnum, ..) = self.resolve_crate(root,\n-                                                        &dep.name.as_str(),\n-                                                        &dep.name.as_str(),\n-                                                        Some(&dep.hash),\n-                                                        span,\n-                                                        PathKind::Dependency,\n-                                                        dep.explicitly_linked);\n+            let dep_name = &dep.name.as_str();\n+            let dep_kind = match dep_kind {\n+                DepKind::MacrosOnly => DepKind::MacrosOnly,\n+                _ => dep.kind,\n+            };\n+            let (local_cnum, ..) = self.resolve_crate(\n+                root, dep_name, dep_name, Some(&dep.hash), span, PathKind::Dependency, dep_kind,\n+            );\n             (CrateNum::new(crate_num + 1), local_cnum)\n         }).collect();\n \n@@ -464,8 +472,8 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn read_extension_crate(&mut self, span: Span, info: &ExternCrateInfo) -> ExtensionCrate {\n-        info!(\"read extension crate {} `extern crate {} as {}` linked={}\",\n-              info.id, info.name, info.ident, info.should_link);\n+        info!(\"read extension crate {} `extern crate {} as {}` dep_kind={:?}\",\n+              info.id, info.name, info.ident, info.dep_kind);\n         let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n         let mut target_only = false;\n@@ -486,6 +494,7 @@ impl<'a> CrateLoader<'a> {\n             rejected_via_kind: vec![],\n             rejected_via_version: vec![],\n             should_match_name: true,\n+            is_proc_macro: None,\n         };\n         let library = self.load(&mut locate_ctxt).or_else(|| {\n             if !is_cross {\n@@ -508,9 +517,8 @@ impl<'a> CrateLoader<'a> {\n \n         let (dylib, metadata) = match library {\n             LoadResult::Previous(cnum) => {\n-                let dylib = self.cstore.opt_used_crate_source(cnum).unwrap().dylib;\n                 let data = self.cstore.get_crate_data(cnum);\n-                (dylib, PMDSource::Registered(data))\n+                (data.source.dylib.clone(), PMDSource::Registered(data))\n             }\n             LoadResult::Loaded(library) => {\n                 let dylib = library.dylib.clone();\n@@ -526,107 +534,54 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn read_macros(&mut self, item: &ast::Item, ekrate: &ExtensionCrate) -> LoadedMacros {\n-        let root = ekrate.metadata.get_root();\n-        let source_name = format!(\"<{} macros>\", item.ident);\n-        let mut macro_rules = Vec::new();\n-\n-        for def in root.macro_defs.decode(&*ekrate.metadata) {\n-            // NB: Don't use parse::parse_tts_from_source_str because it parses with\n-            // quote_depth > 0.\n-            let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n-                                                          source_name.clone(),\n-                                                          def.body);\n-            let lo = p.span.lo;\n-            let body = match p.parse_all_token_trees() {\n-                Ok(body) => body,\n-                Err(mut err) => {\n-                    err.emit();\n-                    self.sess.abort_if_errors();\n-                    unreachable!();\n-                }\n-            };\n-            let local_span = mk_sp(lo, p.prev_span.hi);\n-\n-            // Mark the attrs as used\n-            for attr in &def.attrs {\n-                attr::mark_used(attr);\n-            }\n-\n-            macro_rules.push(ast::MacroDef {\n-                ident: ast::Ident::with_empty_ctxt(def.name),\n-                id: ast::DUMMY_NODE_ID,\n-                span: local_span,\n-                imported_from: Some(item.ident),\n-                allow_internal_unstable: attr::contains_name(&def.attrs, \"allow_internal_unstable\"),\n-                attrs: def.attrs,\n-                body: body,\n-            });\n-            self.sess.imported_macro_spans.borrow_mut()\n-                .insert(local_span, (def.name.as_str().to_string(), def.span));\n-        }\n-\n-        if let Some(id) = root.macro_derive_registrar {\n-            let dylib = match ekrate.dylib.clone() {\n-                Some(dylib) => dylib,\n-                None => span_bug!(item.span, \"proc-macro crate not dylib\"),\n-            };\n-            if ekrate.target_only {\n-                let message = format!(\"proc-macro crate is not available for \\\n-                                       triple `{}` (only found {})\",\n-                                      config::host_triple(),\n-                                      self.sess.opts.target_triple);\n-                self.sess.span_fatal(item.span, &message);\n-            }\n-\n-            // custom derive crates currently should not have any macro_rules!\n-            // exported macros, enforced elsewhere\n-            assert_eq!(macro_rules.len(), 0);\n-            LoadedMacros::ProcMacros(self.load_derive_macros(item, id, root.hash, dylib))\n-        } else {\n-            LoadedMacros::MacroRules(macro_rules)\n-        }\n-    }\n-\n     /// Load custom derive macros.\n     ///\n     /// Note that this is intentionally similar to how we load plugins today,\n     /// but also intentionally separate. Plugins are likely always going to be\n     /// implemented as dynamic libraries, but we have a possible future where\n     /// custom derive (and other macro-1.1 style features) are implemented via\n     /// executables and custom IPC.\n-    fn load_derive_macros(&mut self, item: &ast::Item, index: DefIndex, svh: Svh, path: PathBuf)\n-                          -> Vec<(ast::Name, SyntaxExtension)> {\n+    fn load_derive_macros(&mut self, root: &CrateRoot, dylib: Option<PathBuf>, span: Span)\n+                          -> Vec<(ast::Name, Rc<SyntaxExtension>)> {\n         use std::{env, mem};\n         use proc_macro::TokenStream;\n         use proc_macro::__internal::Registry;\n         use rustc_back::dynamic_lib::DynamicLibrary;\n         use syntax_ext::deriving::custom::CustomDerive;\n \n+        let path = match dylib {\n+            Some(dylib) => dylib,\n+            None => span_bug!(span, \"proc-macro crate not dylib\"),\n+        };\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,\n-            Err(err) => self.sess.span_fatal(item.span, &err),\n+            Err(err) => self.sess.span_fatal(span, &err),\n         };\n \n-        let sym = self.sess.generate_derive_registrar_symbol(&svh, index);\n+        let sym = self.sess.generate_derive_registrar_symbol(&root.hash,\n+                                                             root.macro_derive_registrar.unwrap());\n         let registrar = unsafe {\n             let sym = match lib.symbol(&sym) {\n                 Ok(f) => f,\n-                Err(err) => self.sess.span_fatal(item.span, &err),\n+                Err(err) => self.sess.span_fatal(span, &err),\n             };\n             mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n         };\n \n-        struct MyRegistrar(Vec<(ast::Name, SyntaxExtension)>);\n+        struct MyRegistrar(Vec<(ast::Name, Rc<SyntaxExtension>)>);\n \n         impl Registry for MyRegistrar {\n             fn register_custom_derive(&mut self,\n                                       trait_name: &str,\n-                                      expand: fn(TokenStream) -> TokenStream) {\n-                let derive = SyntaxExtension::CustomDerive(Box::new(CustomDerive::new(expand)));\n-                self.0.push((intern(trait_name), derive));\n+                                      expand: fn(TokenStream) -> TokenStream,\n+                                      attributes: &[&'static str]) {\n+                let attrs = attributes.iter().map(|s| InternedString::new(s)).collect();\n+                let derive = SyntaxExtension::CustomDerive(\n+                    Box::new(CustomDerive::new(expand, attrs))\n+                );\n+                self.0.push((intern(trait_name), Rc::new(derive)));\n             }\n         }\n \n@@ -647,7 +602,7 @@ impl<'a> CrateLoader<'a> {\n              name: name.to_string(),\n              ident: name.to_string(),\n              id: ast::DUMMY_NODE_ID,\n-             should_link: false,\n+             dep_kind: DepKind::MacrosOnly,\n         });\n \n         if ekrate.target_only {\n@@ -721,7 +676,7 @@ impl<'a> CrateLoader<'a> {\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n                                           &|data| data.needs_panic_runtime());\n-                runtime_found = runtime_found || data.explicitly_linked.get();\n+                runtime_found = runtime_found || data.dep_kind.get() == DepKind::Explicit;\n             }\n         });\n \n@@ -750,9 +705,9 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let (cnum, data, _) = self.resolve_crate(&None, name, name, None,\n-                                                 syntax_pos::DUMMY_SP,\n-                                                 PathKind::Crate, false);\n+        let dep_kind = DepKind::Implicit;\n+        let (cnum, data) =\n+            self.resolve_crate(&None, name, name, None, DUMMY_SP, PathKind::Crate, dep_kind);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n@@ -786,7 +741,7 @@ impl<'a> CrateLoader<'a> {\n                 self.inject_dependency_if(cnum, \"an allocator\",\n                                           &|data| data.needs_allocator());\n                 found_required_allocator = found_required_allocator ||\n-                    data.explicitly_linked.get();\n+                    data.dep_kind.get() == DepKind::Explicit;\n             }\n         });\n         if !needs_allocator || found_required_allocator { return }\n@@ -832,9 +787,9 @@ impl<'a> CrateLoader<'a> {\n         } else {\n             &self.sess.target.target.options.exe_allocation_crate\n         };\n-        let (cnum, data, _) = self.resolve_crate(&None, name, name, None,\n-                                                 syntax_pos::DUMMY_SP,\n-                                                 PathKind::Crate, false);\n+        let dep_kind = DepKind::Implicit;\n+        let (cnum, data) =\n+            self.resolve_crate(&None, name, name, None, DUMMY_SP, PathKind::Crate, dep_kind);\n \n         // Sanity check the crate we loaded to ensure that it is indeed an\n         // allocator.\n@@ -974,56 +929,24 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n         self.register_statically_included_foreign_items();\n     }\n \n-    fn process_item(&mut self, item: &ast::Item, definitions: &Definitions, load_macros: bool)\n-                    -> Option<LoadedMacros> {\n+    fn process_item(&mut self, item: &ast::Item, definitions: &Definitions) {\n         match item.node {\n             ast::ItemKind::ExternCrate(_) => {}\n-            ast::ItemKind::ForeignMod(ref fm) => {\n-                self.process_foreign_mod(item, fm);\n-                return None;\n-            }\n-            _ => return None,\n+            ast::ItemKind::ForeignMod(ref fm) => return self.process_foreign_mod(item, fm),\n+            _ => return,\n         }\n \n         let info = self.extract_crate_info(item).unwrap();\n-        let loaded_macros = if load_macros {\n-            let ekrate = self.read_extension_crate(item.span, &info);\n-            let loaded_macros = self.read_macros(item, &ekrate);\n-\n-            // If this is a proc-macro crate or `#[no_link]` crate, it is only used at compile time,\n-            // so we return here to avoid registering the crate.\n-            if loaded_macros.is_proc_macros() || !info.should_link {\n-                return Some(loaded_macros);\n-            }\n-\n-            // Register crate now to avoid double-reading metadata\n-            if let PMDSource::Owned(lib) = ekrate.metadata {\n-                if ekrate.target_only || config::host_triple() == self.sess.opts.target_triple {\n-                    let ExternCrateInfo { ref ident, ref name, .. } = info;\n-                    self.register_crate(&None, ident, name, item.span, lib, true);\n-                }\n-            }\n-\n-            Some(loaded_macros)\n-        } else {\n-            if !info.should_link {\n-                return None;\n-            }\n-            None\n-        };\n-\n         let (cnum, ..) = self.resolve_crate(\n-            &None, &info.ident, &info.name, None, item.span, PathKind::Crate, true,\n+            &None, &info.ident, &info.name, None, item.span, PathKind::Crate, info.dep_kind,\n         );\n \n         let def_id = definitions.opt_local_def_id(item.id).unwrap();\n         let len = definitions.def_path(def_id.index).data.len();\n \n         let extern_crate =\n             ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n-        self.update_extern_crate(cnum, extern_crate, &mut FnvHashSet());\n+        self.update_extern_crate(cnum, extern_crate, &mut FxHashSet());\n         self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-\n-        loaded_macros\n     }\n }"}, {"sha": "8c95e4aec0a0457d346a80f5dd12c4346fe95bad", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 22, "deletions": 52, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -18,16 +18,17 @@ use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex, DefId};\n use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::ExternCrate;\n+use rustc::middle::cstore::{DepKind, ExternCrate};\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n+use rustc::util::nodemap::{FxHashMap, NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n use std::path::PathBuf;\n use flate::Bytes;\n use syntax::{ast, attr};\n+use syntax::ext::base::SyntaxExtension;\n use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibraryKind, LinkagePreference};\n@@ -76,13 +77,12 @@ pub struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping.  This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    pub key_map: FnvHashMap<DefKey, DefIndex>,\n+    pub key_map: FxHashMap<DefKey, DefIndex>,\n \n-    /// Flag if this crate is required by an rlib version of this crate, or in\n-    /// other words whether it was explicitly linked to. An example of a crate\n-    /// where this is false is when an allocator crate is injected into the\n-    /// dependency list, and therefore isn't actually needed to link an rlib.\n-    pub explicitly_linked: Cell<bool>,\n+    pub dep_kind: Cell<DepKind>,\n+    pub source: CrateSource,\n+\n+    pub proc_macros: Option<Vec<(ast::Name, Rc<SyntaxExtension>)>>,\n }\n \n pub struct CachedInlinedItem {\n@@ -94,10 +94,9 @@ pub struct CachedInlinedItem {\n \n pub struct CStore {\n     pub dep_graph: DepGraph,\n-    metas: RefCell<FnvHashMap<CrateNum, Rc<CrateMetadata>>>,\n+    metas: RefCell<FxHashMap<CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n-    used_crate_sources: RefCell<Vec<CrateSource>>,\n     used_libraries: RefCell<Vec<(String, NativeLibraryKind)>>,\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<NodeSet>,\n@@ -110,15 +109,14 @@ impl CStore {\n     pub fn new(dep_graph: &DepGraph) -> CStore {\n         CStore {\n             dep_graph: dep_graph.clone(),\n-            metas: RefCell::new(FnvHashMap()),\n-            extern_mod_crate_map: RefCell::new(FnvHashMap()),\n-            used_crate_sources: RefCell::new(Vec::new()),\n+            metas: RefCell::new(FxHashMap()),\n+            extern_mod_crate_map: RefCell::new(FxHashMap()),\n             used_libraries: RefCell::new(Vec::new()),\n             used_link_args: RefCell::new(Vec::new()),\n             statically_included_foreign_items: RefCell::new(NodeSet()),\n-            visible_parent_map: RefCell::new(FnvHashMap()),\n-            inlined_item_cache: RefCell::new(FnvHashMap()),\n-            defid_for_inlined_node: RefCell::new(FnvHashMap()),\n+            visible_parent_map: RefCell::new(FxHashMap()),\n+            inlined_item_cache: RefCell::new(FxHashMap()),\n+            defid_for_inlined_node: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -146,38 +144,9 @@ impl CStore {\n         }\n     }\n \n-    /// Like `iter_crate_data`, but passes source paths (if available) as well.\n-    pub fn iter_crate_data_origins<I>(&self, mut i: I)\n-        where I: FnMut(CrateNum, &CrateMetadata, Option<CrateSource>)\n-    {\n-        for (&k, v) in self.metas.borrow().iter() {\n-            let origin = self.opt_used_crate_source(k);\n-            origin.as_ref().map(|cs| {\n-                assert!(k == cs.cnum);\n-            });\n-            i(k, &v, origin);\n-        }\n-    }\n-\n-    pub fn add_used_crate_source(&self, src: CrateSource) {\n-        let mut used_crate_sources = self.used_crate_sources.borrow_mut();\n-        if !used_crate_sources.contains(&src) {\n-            used_crate_sources.push(src);\n-        }\n-    }\n-\n-    pub fn opt_used_crate_source(&self, cnum: CrateNum) -> Option<CrateSource> {\n-        self.used_crate_sources\n-            .borrow_mut()\n-            .iter()\n-            .find(|source| source.cnum == cnum)\n-            .cloned()\n-    }\n-\n     pub fn reset(&self) {\n         self.metas.borrow_mut().clear();\n         self.extern_mod_crate_map.borrow_mut().clear();\n-        self.used_crate_sources.borrow_mut().clear();\n         self.used_libraries.borrow_mut().clear();\n         self.used_link_args.borrow_mut().clear();\n         self.statically_included_foreign_items.borrow_mut().clear();\n@@ -223,15 +192,16 @@ impl CStore {\n         }\n         info!(\"topological ordering: {:?}\", ordering);\n         ordering.reverse();\n-        let mut libs = self.used_crate_sources\n+        let mut libs = self.metas\n             .borrow()\n             .iter()\n-            .map(|src| {\n-                (src.cnum,\n-                 match prefer {\n-                     LinkagePreference::RequireDynamic => src.dylib.clone().map(|p| p.0),\n-                     LinkagePreference::RequireStatic => src.rlib.clone().map(|p| p.0),\n-                 })\n+            .filter_map(|(&cnum, data)| {\n+                if data.dep_kind.get() == DepKind::MacrosOnly { return None; }\n+                let path = match prefer {\n+                    LinkagePreference::RequireDynamic => data.source.dylib.clone().map(|p| p.0),\n+                    LinkagePreference::RequireStatic => data.source.rlib.clone().map(|p| p.0),\n+                };\n+                Some((cnum, path))\n             })\n             .collect::<Vec<_>>();\n         libs.sort_by(|&(a, _), &(b, _)| {"}, {"sha": "83de8acdb60565c3c68af466bd52155d7399b77b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 59, "deletions": 15, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -13,10 +13,11 @@ use encoder;\n use locator;\n use schema;\n \n-use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, ExternCrate};\n-use rustc::middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n+use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, DepKind, ExternCrate};\n+use rustc::middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n+use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n \n@@ -30,7 +31,8 @@ use rustc_back::PanicStrategy;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n-use syntax::parse::token;\n+use syntax::parse::{token, new_parser_from_source_str};\n+use syntax_pos::mk_sp;\n use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n use rustc::hir;\n@@ -144,7 +146,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId> {\n+    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId> {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n         self.get_crate_data(def_id.krate)\n@@ -182,11 +184,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def_id.krate).get_trait_of_item(def_id.index)\n     }\n \n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>>\n+    fn associated_item<'a>(&self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> Option<ty::AssociatedItem>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_impl_or_trait_item(def.index, tcx)\n+        self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n \n     fn is_const_fn(&self, did: DefId) -> bool\n@@ -221,6 +223,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).get_dylib_dependency_formats()\n     }\n \n+    fn dep_kind(&self, cnum: CrateNum) -> DepKind\n+    {\n+        self.get_crate_data(cnum).dep_kind.get()\n+    }\n+\n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n     {\n         self.get_crate_data(cnum).get_lang_items()\n@@ -237,11 +244,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).is_staged_api()\n     }\n \n-    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool\n-    {\n-        self.get_crate_data(cnum).explicitly_linked.get()\n-    }\n-\n     fn is_allocator(&self, cnum: CrateNum) -> bool\n     {\n         self.get_crate_data(cnum).is_allocator()\n@@ -351,6 +353,48 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n+    fn load_macro(&self, id: DefId, sess: &Session) -> LoadedMacro {\n+        let data = self.get_crate_data(id.krate);\n+        if let Some(ref proc_macros) = data.proc_macros {\n+            return LoadedMacro::ProcMacro(proc_macros[id.index.as_usize()].1.clone());\n+        }\n+\n+        let (name, def) = data.get_macro(id.index);\n+        let source_name = format!(\"<{} macros>\", name);\n+\n+        // NB: Don't use parse_tts_from_source_str because it parses with quote_depth > 0.\n+        let mut parser = new_parser_from_source_str(&sess.parse_sess, source_name, def.body);\n+\n+        let lo = parser.span.lo;\n+        let body = match parser.parse_all_token_trees() {\n+            Ok(body) => body,\n+            Err(mut err) => {\n+                err.emit();\n+                sess.abort_if_errors();\n+                unreachable!();\n+            }\n+        };\n+        let local_span = mk_sp(lo, parser.prev_span.hi);\n+\n+        // Mark the attrs as used\n+        for attr in &def.attrs {\n+            attr::mark_used(attr);\n+        }\n+\n+        sess.imported_macro_spans.borrow_mut()\n+            .insert(local_span, (def.name.as_str().to_string(), def.span));\n+\n+        LoadedMacro::MacroRules(ast::MacroDef {\n+            ident: ast::Ident::with_empty_ctxt(def.name),\n+            id: ast::DUMMY_NODE_ID,\n+            span: local_span,\n+            imported_from: None, // FIXME\n+            allow_internal_unstable: attr::contains_name(&def.attrs, \"allow_internal_unstable\"),\n+            attrs: def.attrs,\n+            body: body,\n+        })\n+    }\n+\n     fn maybe_get_item_ast<'a>(&'tcx self,\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId)\n@@ -427,9 +471,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                 // the logic to do that already exists in `middle`. In order to\n                 // reuse that code, it needs to be able to look up the traits for\n                 // inlined items.\n-                let ty_trait_item = tcx.impl_or_trait_item(def_id).clone();\n+                let ty_trait_item = tcx.associated_item(def_id).clone();\n                 let trait_item_def_id = tcx.map.local_def_id(trait_item.id);\n-                tcx.impl_or_trait_items.borrow_mut()\n+                tcx.associated_items.borrow_mut()\n                    .insert(trait_item_def_id, ty_trait_item);\n             }\n             Some(&InlinedItem::ImplItem(_, ref impl_item)) => {\n@@ -507,7 +551,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource\n     {\n-        self.opt_used_crate_source(cnum).unwrap()\n+        self.get_crate_data(cnum).source.clone()\n     }\n \n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>"}, {"sha": "78cde4c2fcb7eb3a3826705b25e5ec036aa21041", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 54, "deletions": 32, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -17,11 +17,11 @@ use schema::*;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::{DefKey, DefPathData};\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n-use rustc::middle::cstore::{InlinedItem, LinkagePreference};\n+use rustc::middle::cstore::{DepKind, InlinedItem, LinkagePreference};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc::middle::lang_items;\n@@ -36,7 +36,6 @@ use std::borrow::Cow;\n use std::cell::Ref;\n use std::io;\n use std::mem;\n-use std::rc::Rc;\n use std::str;\n use std::u32;\n \n@@ -432,7 +431,7 @@ impl<'a, 'tcx> MetadataBlob {\n \n     /// Go through each item in the metadata and create a map from that\n     /// item's def-key to the item's DefIndex.\n-    pub fn load_key_map(&self, index: LazySeq<Index>) -> FnvHashMap<DefKey, DefIndex> {\n+    pub fn load_key_map(&self, index: LazySeq<Index>) -> FxHashMap<DefKey, DefIndex> {\n         index.iter_enumerated(self.raw_bytes())\n             .map(|(index, item)| (item.decode(self).def_key.decode(self), index))\n             .collect()\n@@ -469,6 +468,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Variant(_) => Def::Variant(did),\n             EntryKind::Trait(_) => Def::Trait(did),\n             EntryKind::Enum => Def::Enum(did),\n+            EntryKind::MacroDef(_) => Def::Macro(did),\n \n             EntryKind::ForeignMod |\n             EntryKind::Impl(_) |\n@@ -691,17 +691,38 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F)\n         where F: FnMut(def::Export)\n     {\n+        if let Some(ref proc_macros) = self.proc_macros {\n+            for (id, &(name, _)) in proc_macros.iter().enumerate() {\n+                callback(def::Export {\n+                    name: name,\n+                    def: Def::Macro(DefId { krate: self.cnum, index: DefIndex::new(id), }),\n+                })\n+            }\n+            return\n+        }\n+\n         // Find the item.\n         let item = match self.maybe_entry(id) {\n             None => return,\n             Some(item) => item.decode(self),\n         };\n \n         // Iterate over all children.\n+        let macros_only = self.dep_kind.get() == DepKind::MacrosOnly;\n         for child_index in item.children.decode(self) {\n+            if macros_only {\n+                continue\n+            }\n+\n             // Get the item.\n             if let Some(child) = self.maybe_entry(child_index) {\n                 let child = child.decode(self);\n+                match child.kind {\n+                    EntryKind::MacroDef(..) => {}\n+                    _ if macros_only => continue,\n+                    _ => {}\n+                }\n+\n                 // Hand off the item to the callback.\n                 match child.kind {\n                     // FIXME(eddyb) Don't encode these in children.\n@@ -760,6 +781,11 @@ impl<'a, 'tcx> CrateMetadata {\n \n         if let EntryKind::Mod(data) = item.kind {\n             for exp in data.decode(self).reexports.decode(self) {\n+                match exp.def {\n+                    Def::Macro(..) => {}\n+                    _ if macros_only => continue,\n+                    _ => {}\n+                }\n                 callback(exp);\n             }\n         }\n@@ -792,10 +818,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id).mir.map(|mir| mir.decode((self, tcx)))\n     }\n \n-    pub fn get_impl_or_trait_item(&self,\n-                                  id: DefIndex,\n-                                  tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                  -> Option<ty::ImplOrTraitItem<'tcx>> {\n+    pub fn get_associated_item(&self, id: DefIndex) -> Option<ty::AssociatedItem> {\n         let item = self.entry(id);\n         let parent_and_name = || {\n             let def_key = item.def_key.decode(self);\n@@ -806,52 +829,43 @@ impl<'a, 'tcx> CrateMetadata {\n         Some(match item.kind {\n             EntryKind::AssociatedConst(container) => {\n                 let (parent, name) = parent_and_name();\n-                ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n+                ty::AssociatedItem {\n                     name: name,\n-                    ty: item.ty.unwrap().decode((self, tcx)),\n+                    kind: ty::AssociatedKind::Const,\n                     vis: item.visibility,\n                     defaultness: container.defaultness(),\n+                    has_value: container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n-                    has_value: container.has_body(),\n-                }))\n+                    method_has_self_argument: false\n+                }\n             }\n             EntryKind::Method(data) => {\n                 let (parent, name) = parent_and_name();\n-                let ity = item.ty.unwrap().decode((self, tcx));\n-                let fty = match ity.sty {\n-                    ty::TyFnDef(.., fty) => fty,\n-                    _ => {\n-                        bug!(\"the type {:?} of the method {:?} is not a function?\",\n-                             ity,\n-                             name)\n-                    }\n-                };\n-\n                 let data = data.decode(self);\n-                ty::MethodTraitItem(Rc::new(ty::Method {\n+                ty::AssociatedItem {\n                     name: name,\n-                    generics: tcx.lookup_generics(self.local_def_id(id)),\n-                    predicates: item.predicates.unwrap().decode((self, tcx)),\n-                    fty: fty,\n-                    explicit_self: data.explicit_self.decode((self, tcx)),\n+                    kind: ty::AssociatedKind::Method,\n                     vis: item.visibility,\n                     defaultness: data.container.defaultness(),\n-                    has_body: data.container.has_body(),\n+                    has_value: data.container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: data.container.with_def_id(parent),\n-                }))\n+                    method_has_self_argument: data.has_self\n+                }\n             }\n             EntryKind::AssociatedType(container) => {\n                 let (parent, name) = parent_and_name();\n-                ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n+                ty::AssociatedItem {\n                     name: name,\n-                    ty: item.ty.map(|ty| ty.decode((self, tcx))),\n+                    kind: ty::AssociatedKind::Type,\n                     vis: item.visibility,\n                     defaultness: container.defaultness(),\n+                    has_value: container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n-                }))\n+                    method_has_self_argument: false\n+                }\n             }\n             _ => return None,\n         })\n@@ -1000,6 +1014,14 @@ impl<'a, 'tcx> CrateMetadata {\n         self.root.reachable_ids.decode(self).map(|index| self.local_def_id(index)).collect()\n     }\n \n+    pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n+        let entry = self.entry(id);\n+        match entry.kind {\n+            EntryKind::MacroDef(macro_def) => (self.item_name(&entry), macro_def.decode(self)),\n+            _ => bug!(),\n+        }\n+    }\n+\n     pub fn is_const_fn(&self, id: DefIndex) -> bool {\n         let constness = match self.entry(id).kind {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,"}, {"sha": "ac1f2afcb2adbeba5eefcb8476a57011051b98d7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 83, "deletions": 72, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -23,7 +23,7 @@ use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n \n use rustc::session::config::{self, CrateTypeProcMacro};\n-use rustc::util::nodemap::{FnvHashMap, NodeSet};\n+use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n use std::hash::Hash;\n@@ -52,8 +52,8 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     reachable: &'a NodeSet,\n \n     lazy_state: LazyState,\n-    type_shorthands: FnvHashMap<Ty<'tcx>, usize>,\n-    predicate_shorthands: FnvHashMap<ty::Predicate<'tcx>, usize>,\n+    type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n+    predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n }\n \n macro_rules! encoder_methods {\n@@ -200,7 +200,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                                       variant: &U,\n                                       map: M)\n                                       -> Result<(), <Self as Encoder>::Error>\n-        where M: for<'b> Fn(&'b mut Self) -> &'b mut FnvHashMap<T, usize>,\n+        where M: for<'b> Fn(&'b mut Self) -> &'b mut FxHashMap<T, usize>,\n               T: Clone + Eq + Hash,\n               U: Encodable\n     {\n@@ -457,19 +457,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = tcx.map.expect_trait_item(node_id);\n-        let trait_item = tcx.impl_or_trait_item(def_id);\n+        let trait_item = tcx.associated_item(def_id);\n \n-        let container = |has_body| if has_body {\n+        let container = if trait_item.has_value {\n             AssociatedContainer::TraitWithDefault\n         } else {\n             AssociatedContainer::TraitRequired\n         };\n \n-        let kind = match trait_item {\n-            ty::ConstTraitItem(ref associated_const) => {\n-                EntryKind::AssociatedConst(container(associated_const.has_value))\n-            }\n-            ty::MethodTraitItem(ref method_ty) => {\n+        let kind = match trait_item.kind {\n+            ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n+            ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::MethodTraitItem(ref sig, _) = ast_item.node {\n                     FnData {\n                         constness: hir::Constness::NotConst,\n@@ -478,39 +476,44 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                let data = MethodData {\n+                EntryKind::Method(self.lazy(&MethodData {\n                     fn_data: fn_data,\n-                    container: container(method_ty.has_body),\n-                    explicit_self: self.lazy(&method_ty.explicit_self),\n-                };\n-                EntryKind::Method(self.lazy(&data))\n+                    container: container,\n+                    has_self: trait_item.method_has_self_argument,\n+                }))\n             }\n-            ty::TypeTraitItem(_) => EntryKind::AssociatedType(container(false)),\n+            ty::AssociatedKind::Type => EntryKind::AssociatedType(container),\n         };\n \n         Entry {\n             kind: kind,\n-            visibility: trait_item.vis().simplify(),\n+            visibility: trait_item.vis.simplify(),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n-            ty: match trait_item {\n-                ty::ConstTraitItem(_) |\n-                ty::MethodTraitItem(_) => Some(self.encode_item_type(def_id)),\n-                ty::TypeTraitItem(ref associated_type) => {\n-                    associated_type.ty.map(|ty| self.lazy(&ty))\n+            ty: match trait_item.kind {\n+                ty::AssociatedKind::Const |\n+                ty::AssociatedKind::Method => {\n+                    Some(self.encode_item_type(def_id))\n+                }\n+                ty::AssociatedKind::Type => {\n+                    if trait_item.has_value {\n+                        Some(self.encode_item_type(def_id))\n+                    } else {\n+                        None\n+                    }\n                 }\n             },\n             inherent_impls: LazySeq::empty(),\n             variances: LazySeq::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: if let ty::ConstTraitItem(_) = trait_item {\n-                let trait_def_id = trait_item.container().id();\n+            ast: if trait_item.kind == ty::AssociatedKind::Const {\n+                let trait_def_id = trait_item.container.id();\n                 Some(self.encode_inlined_item(InlinedItemRef::TraitItem(trait_def_id, ast_item)))\n             } else {\n                 None\n@@ -522,17 +525,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.map.expect_impl_item(node_id);\n-        let impl_item = self.tcx.impl_or_trait_item(def_id);\n-        let impl_def_id = impl_item.container().id();\n+        let impl_item = self.tcx.associated_item(def_id);\n+        let impl_def_id = impl_item.container.id();\n \n-        let container = match ast_item.defaultness {\n+        let container = match impl_item.defaultness {\n             hir::Defaultness::Default => AssociatedContainer::ImplDefault,\n             hir::Defaultness::Final => AssociatedContainer::ImplFinal,\n         };\n \n-        let kind = match impl_item {\n-            ty::ConstTraitItem(_) => EntryKind::AssociatedConst(container),\n-            ty::MethodTraitItem(ref method_ty) => {\n+        let kind = match impl_item.kind {\n+            ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n+            ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n                     FnData {\n                         constness: sig.constness,\n@@ -541,17 +544,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                let data = MethodData {\n+                EntryKind::Method(self.lazy(&MethodData {\n                     fn_data: fn_data,\n                     container: container,\n-                    explicit_self: self.lazy(&method_ty.explicit_self),\n-                };\n-                EntryKind::Method(self.lazy(&data))\n+                    has_self: impl_item.method_has_self_argument,\n+                }))\n             }\n-            ty::TypeTraitItem(_) => EntryKind::AssociatedType(container),\n+            ty::AssociatedKind::Type => EntryKind::AssociatedType(container)\n         };\n \n-        let (ast, mir) = if let ty::ConstTraitItem(_) = impl_item {\n+        let (ast, mir) = if impl_item.kind == ty::AssociatedKind::Const {\n             (true, true)\n         } else if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n             let generics = self.tcx.lookup_generics(def_id);\n@@ -565,20 +567,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: kind,\n-            visibility: impl_item.vis().simplify(),\n+            visibility: impl_item.vis.simplify(),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n-            ty: match impl_item {\n-                ty::ConstTraitItem(_) |\n-                ty::MethodTraitItem(_) => Some(self.encode_item_type(def_id)),\n-                ty::TypeTraitItem(ref associated_type) => {\n-                    associated_type.ty.map(|ty| self.lazy(&ty))\n-                }\n-            },\n+            ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n             variances: LazySeq::empty(),\n             generics: Some(self.encode_generics(def_id)),\n@@ -758,7 +754,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n                 hir::ItemImpl(..) |\n                 hir::ItemTrait(..) => {\n-                    self.lazy_seq(tcx.impl_or_trait_items(def_id).iter().map(|&def_id| {\n+                    self.lazy_seq(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n                         assert!(def_id.is_local());\n                         def_id.index\n                     }))\n@@ -834,6 +830,34 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             },\n         }\n     }\n+\n+    /// Serialize the text of exported macros\n+    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n+        let def_id = self.tcx.map.local_def_id(macro_def.id);\n+        let macro_def = MacroDef {\n+            name: macro_def.name,\n+            attrs: macro_def.attrs.to_vec(),\n+            span: macro_def.span,\n+            body: ::syntax::print::pprust::tts_to_string(&macro_def.body)\n+        };\n+        Entry {\n+            kind: EntryKind::MacroDef(self.lazy(&macro_def)),\n+            visibility: ty::Visibility::Public,\n+            def_key: self.encode_def_key(def_id),\n+\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: None,\n+            deprecation: None,\n+            ty: None,\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: None,\n+            predicates: None,\n+            ast: None,\n+            mir: None,\n+        }\n+    }\n }\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n@@ -880,14 +904,14 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 self.encode_fields(def_id);\n             }\n             hir::ItemImpl(..) => {\n-                for &trait_item_def_id in &self.tcx.impl_or_trait_items(def_id)[..] {\n+                for &trait_item_def_id in &self.tcx.associated_item_def_ids(def_id)[..] {\n                     self.record(trait_item_def_id,\n                                 EncodeContext::encode_info_for_impl_item,\n                                 trait_item_def_id);\n                 }\n             }\n             hir::ItemTrait(..) => {\n-                for &item_def_id in &self.tcx.impl_or_trait_items(def_id)[..] {\n+                for &item_def_id in &self.tcx.associated_item_def_ids(def_id)[..] {\n                     self.record(item_def_id,\n                                 EncodeContext::encode_info_for_trait_item,\n                                 item_def_id);\n@@ -968,6 +992,10 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_ty(self, ty);\n         self.index.encode_info_for_ty(ty);\n     }\n+    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n+        let def_id = self.index.tcx.map.local_def_id(macro_def.id);\n+        self.index.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n+    }\n }\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n@@ -1016,7 +1044,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.tables.borrow().closure_tys[&def_id]),\n+            ty: self.lazy(&tcx.tables().closure_tys[&def_id]),\n         };\n \n         Entry {\n@@ -1047,6 +1075,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                      FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n         let mut visitor = EncodeVisitor { index: index };\n         krate.visit_all_items(&mut visitor);\n+        for macro_def in &krate.exported_macros {\n+            visitor.visit_macro_def(macro_def);\n+        }\n         visitor.index.into_items()\n     }\n \n@@ -1084,7 +1115,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             CrateDep {\n                 name: syntax::parse::token::intern(dep.name()),\n                 hash: dep.hash(),\n-                explicitly_linked: dep.explicitly_linked.get(),\n+                kind: dep.dep_kind.get(),\n             }\n         }))\n     }\n@@ -1126,24 +1157,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             })\n             .map(|filemap| &**filemap))\n     }\n-\n-    /// Serialize the text of the exported macros\n-    fn encode_macro_defs(&mut self) -> LazySeq<MacroDef> {\n-        let tcx = self.tcx;\n-        self.lazy_seq(tcx.map.krate().exported_macros.iter().map(|def| {\n-            MacroDef {\n-                name: def.name,\n-                attrs: def.attrs.to_vec(),\n-                span: def.span,\n-                body: ::syntax::print::pprust::tts_to_string(&def.body),\n-            }\n-        }))\n-    }\n }\n \n struct ImplVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    impls: FnvHashMap<DefId, Vec<DefIndex>>,\n+    impls: FxHashMap<DefId, Vec<DefIndex>>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n@@ -1165,7 +1183,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n         let mut visitor = ImplVisitor {\n             tcx: self.tcx,\n-            impls: FnvHashMap(),\n+            impls: FxHashMap(),\n         };\n         self.tcx.map.krate().visit_all_items(&mut visitor);\n \n@@ -1232,11 +1250,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let codemap = self.encode_codemap();\n         let codemap_bytes = self.position() - i;\n \n-        // Encode macro definitions\n-        i = self.position();\n-        let macro_defs = self.encode_macro_defs();\n-        let macro_defs_bytes = self.position() - i;\n-\n         // Encode the def IDs of impls, for coherence checking.\n         i = self.position();\n         let impls = self.encode_impls();\n@@ -1283,7 +1296,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             lang_items_missing: lang_items_missing,\n             native_libraries: native_libraries,\n             codemap: codemap,\n-            macro_defs: macro_defs,\n             impls: impls,\n             reachable_ids: reachable_ids,\n             index: index,\n@@ -1304,7 +1316,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             println!(\"       lang item bytes: {}\", lang_item_bytes);\n             println!(\"          native bytes: {}\", native_lib_bytes);\n             println!(\"         codemap bytes: {}\", codemap_bytes);\n-            println!(\"       macro def bytes: {}\", macro_defs_bytes);\n             println!(\"            impl bytes: {}\", impl_bytes);\n             println!(\"       reachable bytes: {}\", reachable_bytes);\n             println!(\"            item bytes: {}\", item_bytes);"}, {"sha": "1a74a925454770928ff937df59978be95e5e5e33", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -195,6 +195,7 @@ read_hir!(hir::Item);\n read_hir!(hir::ImplItem);\n read_hir!(hir::TraitItem);\n read_hir!(hir::ForeignItem);\n+read_hir!(hir::MacroDef);\n \n /// Leaks access to a value of type T without any tracking. This is\n /// suitable for ambiguous types like `usize`, which *could* represent"}, {"sha": "2fd40181d7c7411c0a7747526ba16a0de170183d", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -20,7 +20,7 @@\n #![feature(box_patterns)]\n #![feature(conservative_impl_trait)]\n #![feature(core_intrinsics)]\n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_lib)]\n #![cfg_attr(stage0, feature(question_mark))]"}, {"sha": "b6b347fff5f26fcf5de2f7ad5066c34b90915009", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -221,7 +221,7 @@ use rustc::session::Session;\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n use rustc::util::common;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n \n use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n@@ -262,6 +262,7 @@ pub struct Context<'a> {\n     pub rejected_via_kind: Vec<CrateMismatch>,\n     pub rejected_via_version: Vec<CrateMismatch>,\n     pub should_match_name: bool,\n+    pub is_proc_macro: Option<bool>,\n }\n \n pub struct ArchiveMetadata {\n@@ -430,7 +431,7 @@ impl<'a> Context<'a> {\n         let rlib_prefix = format!(\"lib{}\", self.crate_name);\n         let staticlib_prefix = format!(\"{}{}\", staticpair.0, self.crate_name);\n \n-        let mut candidates = FnvHashMap();\n+        let mut candidates = FxHashMap();\n         let mut staticlibs = vec![];\n \n         // First, find all possible candidate rlibs and dylibs purely based on\n@@ -469,7 +470,7 @@ impl<'a> Context<'a> {\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str)\n-                .or_insert_with(|| (FnvHashMap(), FnvHashMap()));\n+                .or_insert_with(|| (FxHashMap(), FxHashMap()));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             fs::canonicalize(path)\n                 .map(|p| {\n@@ -492,7 +493,7 @@ impl<'a> Context<'a> {\n         // A Library candidate is created if the metadata for the set of\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n-        let mut libraries = FnvHashMap();\n+        let mut libraries = FxHashMap();\n         for (_hash, (rlibs, dylibs)) in candidates {\n             let mut slot = None;\n             let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n@@ -544,7 +545,7 @@ impl<'a> Context<'a> {\n     // be read, it is assumed that the file isn't a valid rust library (no\n     // errors are emitted).\n     fn extract_one(&mut self,\n-                   m: FnvHashMap<PathBuf, PathKind>,\n+                   m: FxHashMap<PathBuf, PathKind>,\n                    flavor: CrateFlavor,\n                    slot: &mut Option<(Svh, MetadataBlob)>)\n                    -> Option<(PathBuf, PathKind)> {\n@@ -623,6 +624,12 @@ impl<'a> Context<'a> {\n \n     fn crate_matches(&mut self, metadata: &MetadataBlob, libpath: &Path) -> Option<Svh> {\n         let root = metadata.get_root();\n+        if let Some(is_proc_macro) = self.is_proc_macro {\n+            if root.macro_derive_registrar.is_some() != is_proc_macro {\n+                return None;\n+            }\n+        }\n+\n         let rustc_version = rustc_version();\n         if root.rustc_version != rustc_version {\n             info!(\"Rejecting via version: expected {} got {}\",\n@@ -690,8 +697,8 @@ impl<'a> Context<'a> {\n         // rlibs/dylibs.\n         let sess = self.sess;\n         let dylibname = self.dylibname();\n-        let mut rlibs = FnvHashMap();\n-        let mut dylibs = FnvHashMap();\n+        let mut rlibs = FxHashMap();\n+        let mut dylibs = FxHashMap();\n         {\n             let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n                 if !loc.exists() {"}, {"sha": "d7a5f7ad71544ed42ebc851cdb9594796fc45dec", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -14,7 +14,7 @@ use index;\n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n-use rustc::middle::cstore::{LinkagePreference, NativeLibraryKind};\n+use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibraryKind};\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n@@ -177,7 +177,6 @@ pub struct CrateRoot {\n     pub lang_items_missing: LazySeq<lang_items::LangItem>,\n     pub native_libraries: LazySeq<(NativeLibraryKind, String)>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n-    pub macro_defs: LazySeq<MacroDef>,\n     pub impls: LazySeq<TraitImpls>,\n     pub reachable_ids: LazySeq<DefIndex>,\n     pub index: LazySeq<index::Index>,\n@@ -187,7 +186,7 @@ pub struct CrateRoot {\n pub struct CrateDep {\n     pub name: ast::Name,\n     pub hash: hir::svh::Svh,\n-    pub explicitly_linked: bool,\n+    pub kind: DepKind,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -241,11 +240,12 @@ pub enum EntryKind<'tcx> {\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n+    MacroDef(Lazy<MacroDef>),\n     Closure(Lazy<ClosureData<'tcx>>),\n     Trait(Lazy<TraitData<'tcx>>),\n     Impl(Lazy<ImplData<'tcx>>),\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n-    Method(Lazy<MethodData<'tcx>>),\n+    Method(Lazy<MethodData>),\n     AssociatedType(AssociatedContainer),\n     AssociatedConst(AssociatedContainer),\n }\n@@ -300,7 +300,7 @@ pub enum AssociatedContainer {\n }\n \n impl AssociatedContainer {\n-    pub fn with_def_id(&self, def_id: DefId) -> ty::ImplOrTraitItemContainer {\n+    pub fn with_def_id(&self, def_id: DefId) -> ty::AssociatedItemContainer {\n         match *self {\n             AssociatedContainer::TraitRequired |\n             AssociatedContainer::TraitWithDefault => ty::TraitContainer(def_id),\n@@ -310,7 +310,7 @@ impl AssociatedContainer {\n         }\n     }\n \n-    pub fn has_body(&self) -> bool {\n+    pub fn has_value(&self) -> bool {\n         match *self {\n             AssociatedContainer::TraitRequired => false,\n \n@@ -332,10 +332,10 @@ impl AssociatedContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MethodData<'tcx> {\n+pub struct MethodData {\n     pub fn_data: FnData,\n     pub container: AssociatedContainer,\n-    pub explicit_self: Lazy<ty::ExplicitSelfCategory<'tcx>>,\n+    pub has_self: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "b75e52fd4b10d99ce80988d1178da245847d443c", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -13,7 +13,7 @@\n use std;\n \n use rustc_const_math::{ConstMathErr, Op};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n@@ -190,7 +190,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 // first process the set of fields that were provided\n                 // (evaluating them in order given by user)\n-                let fields_map: FnvHashMap<_, _> =\n+                let fields_map: FxHashMap<_, _> =\n                     fields.into_iter()\n                           .map(|f| (f.name, unpack!(block = this.as_operand(block, f.expr))))\n                           .collect();"}, {"sha": "786299c370d82f964243d1790413dd3822f39f0d", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -14,7 +14,7 @@\n //! details.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{AdtDef, Ty};\n@@ -309,7 +309,7 @@ enum TestKind<'tcx> {\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n         options: Vec<ConstVal>,\n-        indices: FnvHashMap<ConstVal, usize>,\n+        indices: FxHashMap<ConstVal, usize>,\n     },\n \n     // test for equality"}, {"sha": "948ba7338cddb9800335e76aac567e686e05a741", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -18,7 +18,7 @@\n use build::Builder;\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         // these maps are empty to start; cases are\n                         // added below in add_cases_to_switch\n                         options: vec![],\n-                        indices: FnvHashMap(),\n+                        indices: FxHashMap(),\n                     }\n                 }\n             }\n@@ -110,7 +110,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n                                      options: &mut Vec<ConstVal>,\n-                                     indices: &mut FnvHashMap<ConstVal, usize>)\n+                                     indices: &mut FxHashMap<ConstVal, usize>)\n                                      -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {"}, {"sha": "902798ec980061fe0bcfdf6276b45b7bbd65dd77", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -156,7 +156,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        fn_id: ast::NodeId,\n                                        arguments: A,\n                                        return_ty: Ty<'gcx>,\n-                                       ast_block: &'gcx hir::Block)\n+                                       ast_body: &'gcx hir::Expr)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec)\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n@@ -166,7 +166,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let span = tcx.map.span(fn_id);\n     let mut builder = Builder::new(hir, span, arguments.len(), return_ty);\n \n-    let body_id = ast_block.id;\n+    let body_id = ast_body.id;\n     let call_site_extent =\n         tcx.region_maps.lookup_code_extent(\n             CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id });\n@@ -176,7 +176,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let mut block = START_BLOCK;\n     unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n         unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n-            builder.args_and_body(block, return_ty, &arguments, arg_extent, ast_block)\n+            builder.args_and_body(block, &arguments, arg_extent, ast_body)\n         }));\n         // Attribute epilogue to function's closing brace\n         let fn_end = Span { lo: span.hi, ..span };\n@@ -191,7 +191,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     assert_eq!(block, builder.return_block());\n \n     let mut spread_arg = None;\n-    match tcx.node_id_to_type(fn_id).sty {\n+    match tcx.tables().node_id_to_type(fn_id).sty {\n         ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n             // RustCall pseudo-ABI untuples the last argument.\n             spread_arg = Some(Local::new(arguments.len()));\n@@ -203,7 +203,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n             let var_id = tcx.map.as_local_node_id(fv.def.def_id()).unwrap();\n-            let by_ref = tcx.upvar_capture(ty::UpvarId {\n+            let by_ref = tcx.tables().upvar_capture(ty::UpvarId {\n                 var_id: var_id,\n                 closure_expr_id: fn_id\n             }).map_or(false, |capture| match capture {\n@@ -233,7 +233,7 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        ast_expr: &'tcx hir::Expr)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n     let tcx = hir.tcx();\n-    let ty = tcx.expr_ty_adjusted(ast_expr);\n+    let ty = tcx.tables().expr_ty_adjusted(ast_expr);\n     let span = tcx.map.span(item_id);\n     let mut builder = Builder::new(hir, span, 0, ty);\n \n@@ -310,10 +310,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n-                     return_ty: Ty<'tcx>,\n                      arguments: &[(Ty<'gcx>, Option<&'gcx hir::Pat>)],\n                      argument_extent: CodeExtent,\n-                     ast_block: &'gcx hir::Block)\n+                     ast_body: &'gcx hir::Expr)\n                      -> BlockAnd<()>\n     {\n         // Allocate locals for the function arguments\n@@ -342,12 +341,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             if let Some(pattern) = pattern {\n                 let pattern = Pattern::from_hir(self.hir.tcx(), pattern);\n-                scope = self.declare_bindings(scope, ast_block.span, &pattern);\n+                scope = self.declare_bindings(scope, ast_body.span, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n-            self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n+            self.schedule_drop(pattern.as_ref().map_or(ast_body.span, |pat| pat.span),\n                                argument_extent, &lvalue, ty);\n \n         }\n@@ -357,13 +356,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.visibility_scope = visibility_scope;\n         }\n \n-        // FIXME(#32959): temporary hack for the issue at hand\n-        let return_is_unit = return_ty.is_nil();\n-        // start the first basic block and translate the body\n-        unpack!(block = self.ast_block(&Lvalue::Local(RETURN_POINTER),\n-                return_is_unit, block, ast_block));\n-\n-        block.unit()\n+        let body = self.hir.mirror(ast_body);\n+        self.into(&Lvalue::Local(RETURN_POINTER), block, body)\n     }\n \n     fn get_unit_temp(&mut self) -> Lvalue<'tcx> {"}, {"sha": "b5343975a9cdf39f1826fdba24bf4c6fa15048ab", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -94,7 +94,7 @@ use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::*;\n use syntax_pos::Span;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n \n pub struct Scope<'tcx> {\n     /// the scope-id within the scope_auxiliary\n@@ -140,7 +140,7 @@ pub struct Scope<'tcx> {\n     free: Option<FreeData<'tcx>>,\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n-    cached_exits: FnvHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n+    cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n }\n \n struct DropData<'tcx> {\n@@ -298,7 +298,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             needs_cleanup: false,\n             drops: vec![],\n             free: None,\n-            cached_exits: FnvHashMap()\n+            cached_exits: FxHashMap()\n         });\n         self.scope_auxiliary.push(ScopeAuxiliary {\n             extent: extent,"}, {"sha": "cb69de2cb3cace0923c907f0218e471cc3010649", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -77,7 +77,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n-    let block_ty = cx.tcx.node_id_to_type(block.id);\n+    let block_ty = cx.tcx.tables().node_id_to_type(block.id);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n     let expr = Expr {\n         ty: block_ty,"}, {"sha": "ba0d3b49a6c1ae28315fd51bd8085db29f982470", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 57, "deletions": 60, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -35,62 +35,61 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let mut expr = make_mirror_unadjusted(cx, self);\n+        let adj = cx.tcx.tables().adjustments.get(&self.id).cloned();\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n-               expr, cx.tcx.tables.borrow().adjustments.get(&self.id));\n+               expr, adj);\n \n         // Now apply adjustments, if any.\n-        match cx.tcx.tables.borrow().adjustments.get(&self.id) {\n+        match adj.map(|adj| (adj.kind, adj.target)) {\n             None => {}\n-            Some(&ty::adjustment::AdjustReifyFnPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::ReifyFnPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::ReifyFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustUnsafeFnPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::UnsafeFnPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustNeverToAny(adjusted_ty)) => {\n+            Some((ty::adjustment::Adjust::NeverToAny, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::NeverToAny { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustMutToConstPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::MutToConstPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::Cast { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustDerefRef(ref adj)) => {\n-                for i in 0..adj.autoderefs {\n+            Some((ty::adjustment::Adjust::DerefRef { autoderefs, autoref, unsize },\n+                  adjusted_ty)) => {\n+                for i in 0..autoderefs {\n                     let i = i as u32;\n                     let adjusted_ty =\n                         expr.ty.adjust_for_autoderef(\n                             cx.tcx,\n                             self.id,\n                             self.span,\n                             i,\n-                            |mc| cx.tcx.tables.borrow().method_map.get(&mc).map(|m| m.ty));\n+                            |mc| cx.tcx.tables().method_map.get(&mc).map(|m| m.ty));\n                     debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\", i, adjusted_ty);\n                     let method_key = ty::MethodCall::autoderef(self.id, i);\n                     let meth_ty =\n-                        cx.tcx.tables.borrow().method_map.get(&method_key).map(|m| m.ty);\n+                        cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n                     let kind = if let Some(meth_ty) = meth_ty {\n                         debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n \n@@ -128,10 +127,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     };\n                 }\n \n-                if let Some(autoref) = adj.autoref {\n+                if let Some(autoref) = autoref {\n                     let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n                     match autoref {\n-                        ty::adjustment::AutoPtr(r, m) => {\n+                        ty::adjustment::AutoBorrow::Ref(r, m) => {\n                             expr = Expr {\n                                 temp_lifetime: temp_lifetime,\n                                 ty: adjusted_ty,\n@@ -143,7 +142,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 },\n                             };\n                         }\n-                        ty::adjustment::AutoUnsafe(m) => {\n+                        ty::adjustment::AutoBorrow::RawPtr(m) => {\n                             // Convert this to a suitable `&foo` and\n                             // then an unsafe coercion. Limit the region to be just this\n                             // expression.\n@@ -169,10 +168,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     }\n                 }\n \n-                if let Some(target) = adj.unsize {\n+                if unsize {\n                     expr = Expr {\n                         temp_lifetime: temp_lifetime,\n-                        ty: target,\n+                        ty: adjusted_ty,\n                         span: self.span,\n                         kind: ExprKind::Unsize { source: expr.to_ref() },\n                     };\n@@ -212,7 +211,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n-    let expr_ty = cx.tcx.expr_ty(expr);\n+    let expr_ty = cx.tcx.tables().expr_ty(expr);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     let kind = match expr.node {\n@@ -231,7 +230,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprCall(ref fun, ref args) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n                 // build the appropriate UFCS call expression with the\n@@ -282,7 +281,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     })\n                 } else { None };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx.node_id_item_substs(fun.id).substs;\n+                    let substs = cx.tcx.tables().node_id_item_substs(fun.id)\n+                        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n                     let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n                         name: Field::new(idx),\n                         expr: e.to_ref()\n@@ -296,7 +296,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                 } else {\n                     ExprKind::Call {\n-                        ty: cx.tcx.node_id_to_type(fun.id),\n+                        ty: cx.tcx.tables().node_id_to_type(fun.id),\n                         fun: fun.to_ref(),\n                         args: args.to_ref(),\n                     }\n@@ -328,7 +328,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -350,7 +350,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -406,7 +406,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprIndex(ref lhs, ref index) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n                                   PassArgs::ByValue, lhs.to_ref(), vec![index])\n             } else {\n@@ -418,7 +418,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n                                   PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -427,7 +427,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n                                     PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -439,7 +439,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-            if cx.tcx.is_method_call(expr.id) {\n+            if cx.tcx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n                                     PassArgs::ByValue, arg.to_ref(), vec![])\n             } else {\n@@ -470,10 +470,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             base: base.as_ref().map(|base| {\n                                 FruInfo {\n                                     base: base.to_ref(),\n-                                    field_types: cx.tcx.tables\n-                                        .borrow()\n-                                        .fru_field_types[&expr.id]\n-                                        .clone()\n+                                    field_types:\n+                                        cx.tcx.tables().fru_field_types[&expr.id].clone()\n                                 }\n                             })\n                         }\n@@ -512,7 +510,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprClosure(..) => {\n-            let closure_ty = cx.tcx.expr_ty(expr);\n+            let closure_ty = cx.tcx.tables().expr_ty(expr);\n             let (def_id, substs) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n@@ -551,7 +549,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRepeat(ref v, ref c) => ExprKind::Repeat {\n             value: v.to_ref(),\n             count: TypedConstVal {\n-                ty: cx.tcx.expr_ty(c),\n+                ty: cx.tcx.tables().expr_ty(c),\n                 span: c.span,\n                 value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n                     ConstVal::Integral(ConstInt::Usize(u)) => u,\n@@ -579,7 +577,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::Loop { condition: None,\n                              body: block::to_expr_ref(cx, body) },\n         hir::ExprField(ref source, name) => {\n-            let index = match cx.tcx.expr_ty_adjusted(source).sty {\n+            let index = match cx.tcx.tables().expr_ty_adjusted(source).sty {\n                 ty::TyAdt(adt_def, _) =>\n                     adt_def.variants[0].index_of_field_named(name.node),\n                 ref ty =>\n@@ -631,8 +629,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n                                  method_call: ty::MethodCall)\n                                  -> Expr<'tcx> {\n-    let tables = cx.tcx.tables.borrow();\n-    let callee = &tables.method_map[&method_call];\n+    let callee = cx.tcx.tables().method_map[&method_call];\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n@@ -666,8 +663,8 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tcx.node_id_item_substs(expr.id).substs;\n-    // Otherwise there may be def_map borrow conflicts\n+    let substs = cx.tcx.tables().node_id_item_substs(expr.id)\n+        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n     let def = cx.tcx.expect_def(expr.id);\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n@@ -677,18 +674,20 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Const(def_id) | Def::AssociatedConst(def_id) => def_id,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n-        Def::VariantCtor(def_id, CtorKind::Const) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A unit struct/variant which is used as a value.\n-            // We return a completely different ExprKind here to account for this special case.\n-            ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n-                adt_def: adt_def,\n-                variant_index: adt_def.variant_index_with_id(def_id),\n-                substs: substs,\n-                fields: vec![],\n-                base: None,\n-            },\n-            ref sty => bug!(\"unexpected sty: {:?}\", sty)\n-        },\n+        Def::VariantCtor(def_id, CtorKind::Const) => {\n+            match cx.tcx.tables().node_id_to_type(expr.id).sty {\n+                // A unit struct/variant which is used as a value.\n+                // We return a completely different ExprKind here to account for this special case.\n+                ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n+                    adt_def: adt_def,\n+                    variant_index: adt_def.variant_index_with_id(def_id),\n+                    substs: substs,\n+                    fields: vec![],\n+                    base: None,\n+                },\n+                ref sty => bug!(\"unexpected sty: {:?}\", sty)\n+            }\n+        }\n \n         Def::Static(node_id, _) => return ExprKind::StaticRef {\n             id: node_id,\n@@ -720,7 +719,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Upvar(def_id, index, closure_expr_id) => {\n             let id_var = cx.tcx.map.as_local_node_id(def_id).unwrap();\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n-            let var_ty = cx.tcx.node_id_to_type(id_var);\n+            let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n \n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n                 Some(map::NodeExpr(expr)) => {\n@@ -737,7 +736,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n \n             // FIXME free regions in closures are not right\n-            let closure_ty = cx.tcx.node_id_to_type(closure_expr_id);\n+            let closure_ty = cx.tcx.tables().node_id_to_type(closure_expr_id);\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n@@ -809,7 +808,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 var_id: id_var,\n                 closure_expr_id: closure_expr_id,\n             };\n-            let upvar_capture = match cx.tcx.upvar_capture(upvar_id) {\n+            let upvar_capture = match cx.tcx.tables().upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n                     span_bug!(\n@@ -893,7 +892,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             argrefs.extend(\n                 args.iter()\n                     .map(|arg| {\n-                        let arg_ty = cx.tcx.expr_ty_adjusted(arg);\n+                        let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n                         let adjusted_ty =\n                             cx.tcx.mk_ref(region,\n                                        ty::TypeAndMut { ty: arg_ty,\n@@ -931,9 +930,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n \n     // to find the type &T of the content returned by the method;\n-    let tables = cx.tcx.tables.borrow();\n-    let callee = &tables.method_map[&method_call];\n-    let ref_ty = callee.ty.fn_ret();\n+    let ref_ty = cx.tcx.tables().method_map[&method_call].ty.fn_ret();\n     let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap();\n     // callees always have all late-bound regions fully instantiated,\n \n@@ -962,9 +959,9 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         var_id: id_var,\n         closure_expr_id: closure_expr.id,\n     };\n-    let upvar_capture = cx.tcx.upvar_capture(upvar_id).unwrap();\n+    let upvar_capture = cx.tcx.tables().upvar_capture(upvar_id).unwrap();\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(closure_expr.id);\n-    let var_ty = cx.tcx.node_id_to_type(id_var);\n+    let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,\n         ty: var_ty,"}, {"sha": "ecc2d8fe050adc23be4a56ecb8277856e20c3240", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -147,20 +147,14 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         -> (Ty<'tcx>, Literal<'tcx>) {\n         let method_name = token::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n-        for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n-            match *trait_item {\n-                ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n-                    if method.name == method_name {\n-                        let method_ty = self.tcx.lookup_item_type(method.def_id);\n-                        let method_ty = method_ty.ty.subst(self.tcx, substs);\n-                        return (method_ty, Literal::Item {\n-                            def_id: method.def_id,\n-                            substs: substs,\n-                        });\n-                    }\n-                }\n-                ty::ImplOrTraitItem::ConstTraitItem(..) |\n-                ty::ImplOrTraitItem::TypeTraitItem(..) => {}\n+        for item in self.tcx.associated_items(trait_def_id) {\n+            if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n+                let method_ty = self.tcx.lookup_item_type(item.def_id);\n+                let method_ty = method_ty.ty.subst(self.tcx, substs);\n+                return (method_ty, Literal::Item {\n+                    def_id: item.def_id,\n+                    substs: substs,\n+                });\n             }\n         }\n "}, {"sha": "aa56daf88894483d48e6768689d0115b1f66faf8", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -22,7 +22,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #![feature(associated_consts)]\n #![feature(box_patterns)]\n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "af2f9adfc9a8ccc77aa9c4909ae2f789627db8a1", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -209,12 +209,12 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: FnKind<'tcx>,\n                 decl: &'tcx hir::FnDecl,\n-                body: &'tcx hir::Block,\n+                body: &'tcx hir::Expr,\n                 span: Span,\n                 id: ast::NodeId) {\n         // fetch the fully liberated fn signature (that is, all bound\n         // types/lifetimes replaced)\n-        let fn_sig = match self.tcx.tables.borrow().liberated_fn_sigs.get(&id) {\n+        let fn_sig = match self.tcx.tables().liberated_fn_sigs.get(&id) {\n             Some(f) => f.clone(),\n             None => {\n                 span_bug!(span, \"no liberated fn sig for {:?}\", id);\n@@ -248,7 +248,7 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: ast::NodeId)\n                              -> Ty<'tcx> {\n-    let closure_ty = tcx.node_id_to_type(closure_expr_id);\n+    let closure_ty = tcx.tables().node_id_to_type(closure_expr_id);\n \n     // We're just hard-coding the idea that the signature will be\n     // &self or &mut self and hence will have a bound region with"}, {"sha": "d6f514cfb913616b15d8176a584376529bdef3f7", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx};\n use std::fmt::Display;\n use std::fs;\n@@ -122,10 +122,10 @@ enum Annotation {\n }\n \n fn scope_entry_exit_annotations(auxiliary: Option<&ScopeAuxiliaryVec>)\n-                                -> FnvHashMap<Location, Vec<Annotation>>\n+                                -> FxHashMap<Location, Vec<Annotation>>\n {\n     // compute scope/entry exit annotations\n-    let mut annotations = FnvHashMap();\n+    let mut annotations = FxHashMap();\n     if let Some(auxiliary) = auxiliary {\n         for (scope_id, auxiliary) in auxiliary.iter_enumerated() {\n             annotations.entry(auxiliary.dom)\n@@ -166,7 +166,7 @@ fn write_basic_block(tcx: TyCtxt,\n                      block: BasicBlock,\n                      mir: &Mir,\n                      w: &mut Write,\n-                     annotations: &FnvHashMap<Location, Vec<Annotation>>)\n+                     annotations: &FxHashMap<Location, Vec<Annotation>>)\n                      -> io::Result<()> {\n     let data = &mir[block];\n \n@@ -217,7 +217,7 @@ fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n /// Returns the total number of variables printed.\n fn write_scope_tree(tcx: TyCtxt,\n                     mir: &Mir,\n-                    scope_tree: &FnvHashMap<VisibilityScope, Vec<VisibilityScope>>,\n+                    scope_tree: &FxHashMap<VisibilityScope, Vec<VisibilityScope>>,\n                     w: &mut Write,\n                     parent: VisibilityScope,\n                     depth: usize)\n@@ -283,7 +283,7 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     writeln!(w, \" {{\")?;\n \n     // construct a scope tree and write it out\n-    let mut scope_tree: FnvHashMap<VisibilityScope, Vec<VisibilityScope>> = FnvHashMap();\n+    let mut scope_tree: FxHashMap<VisibilityScope, Vec<VisibilityScope>> = FxHashMap();\n     for (index, scope_data) in mir.visibility_scopes.iter().enumerate() {\n         if let Some(parent) = scope_data.parent_scope {\n             scope_tree.entry(parent)"}, {"sha": "c4a8d34bda008c8fa6f4ef2494e793ff519a4c98", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -14,7 +14,7 @@ use rustc::mir::{Location, Lvalue, Mir, Operand, ProjectionElem, Rvalue, Local};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::TyCtxt;\n-use rustc::util::nodemap::FnvHashSet;\n+use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use std::mem;\n \n@@ -107,5 +107,5 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n \n #[derive(Default)]\n struct OptimizationList {\n-    and_stars: FnvHashSet<Location>,\n+    and_stars: FxHashSet<Location>,\n }"}, {"sha": "ae255f70fb78892ac21ca8e0e813427692053639", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub mod simplify_branches;\n-pub mod simplify_cfg;\n+pub mod simplify;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;"}, {"sha": "d5fc90289e2cc20465af956a30abf84cd3c8d18b", "filename": "src/librustc_mir/transform/simplify.rs", "status": "renamed", "additions": 104, "deletions": 14, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -8,35 +8,41 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A pass that removes various redundancies in the CFG. It should be\n-//! called after every significant CFG modification to tidy things\n-//! up.\n+//! A number of passes which remove various redundancies in the CFG.\n //!\n-//! This pass must also be run before any analysis passes because it removes\n-//! dead blocks, and some of these can be ill-typed.\n+//! The `SimplifyCfg` pass gets rid of unnecessary blocks in the CFG, whereas the `SimplifyLocals`\n+//! gets rid of all the unnecessary local variable declarations.\n //!\n-//! The cause of that is that typeck lets most blocks whose end is not\n-//! reachable have an arbitrary return type, rather than having the\n-//! usual () return type (as a note, typeck's notion of reachability\n-//! is in fact slightly weaker than MIR CFG reachability - see #31617).\n+//! The `SimplifyLocals` pass is kinda expensive and therefore not very suitable to be run often.\n+//! Most of the passes should not care or be impacted in meaningful ways due to extra locals\n+//! either, so running the pass once, right before translation, should suffice.\n+//!\n+//! On the other side of the spectrum, the `SimplifyCfg` pass is considerably cheap to run, thus\n+//! one should run it after every pass which may modify CFG in significant ways. This pass must\n+//! also be run before any analysis passes because it removes dead blocks, and some of these can be\n+//! ill-typed.\n+//!\n+//! The cause of this typing issue is typeck allowing most blocks whose end is not reachable have\n+//! an arbitrary return type, rather than having the usual () return type (as a note, typeck's\n+//! notion of reachability is in fact slightly weaker than MIR CFG reachability - see #31617). A\n+//! standard example of the situation is:\n //!\n-//! A standard example of the situation is:\n //! ```rust\n //!   fn example() {\n //!       let _a: char = { return; };\n //!   }\n //! ```\n //!\n-//! Here the block (`{ return; }`) has the return type `char`,\n-//! rather than `()`, but the MIR we naively generate still contains\n-//! the `_a = ()` write in the unreachable block \"after\" the return.\n-\n+//! Here the block (`{ return; }`) has the return type `char`, rather than `()`, but the MIR we\n+//! naively generate still contains the `_a = ()` write in the unreachable block \"after\" the\n+//! return.\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::visit::{MutVisitor, Visitor, LvalueContext};\n use std::fmt;\n \n pub struct SimplifyCfg<'a> { label: &'a str }\n@@ -257,3 +263,87 @@ fn remove_dead_blocks(mir: &mut Mir) {\n         }\n     }\n }\n+\n+\n+pub struct SimplifyLocals;\n+\n+impl Pass for SimplifyLocals {\n+    fn name(&self) -> ::std::borrow::Cow<'static, str> { \"SimplifyLocals\".into() }\n+}\n+\n+impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+        let mut marker = DeclMarker { locals: BitVector::new(mir.local_decls.len()) };\n+        marker.visit_mir(mir);\n+        // Return pointer and arguments are always live\n+        marker.locals.insert(0);\n+        for idx in mir.args_iter() {\n+            marker.locals.insert(idx.index());\n+        }\n+        let map = make_local_map(&mut mir.local_decls, marker.locals);\n+        // Update references to all vars and tmps now\n+        LocalUpdater { map: map }.visit_mir(mir);\n+        mir.local_decls.shrink_to_fit();\n+    }\n+}\n+\n+/// Construct the mapping while swapping out unused stuff out from the `vec`.\n+fn make_local_map<'tcx, I: Idx, V>(vec: &mut IndexVec<I, V>, mask: BitVector) -> Vec<usize> {\n+    let mut map: Vec<usize> = ::std::iter::repeat(!0).take(vec.len()).collect();\n+    let mut used = 0;\n+    for alive_index in mask.iter() {\n+        map[alive_index] = used;\n+        if alive_index != used {\n+            vec.swap(alive_index, used);\n+        }\n+        used += 1;\n+    }\n+    vec.truncate(used);\n+    map\n+}\n+\n+struct DeclMarker {\n+    pub locals: BitVector,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for DeclMarker {\n+    fn visit_lvalue(&mut self, lval: &Lvalue<'tcx>, ctx: LvalueContext<'tcx>, loc: Location) {\n+        if ctx == LvalueContext::StorageLive || ctx == LvalueContext::StorageDead {\n+            // ignore these altogether, they get removed along with their otherwise unused decls.\n+            return;\n+        }\n+        if let Lvalue::Local(ref v) = *lval {\n+            self.locals.insert(v.index());\n+        }\n+        self.super_lvalue(lval, ctx, loc);\n+    }\n+}\n+\n+struct LocalUpdater {\n+    map: Vec<usize>,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n+    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n+        // Remove unnecessary StorageLive and StorageDead annotations.\n+        data.statements.retain(|stmt| {\n+            match stmt.kind {\n+                StatementKind::StorageLive(ref lval) | StatementKind::StorageDead(ref lval) => {\n+                    match *lval {\n+                        Lvalue::Local(l) => self.map[l.index()] != !0,\n+                        _ => true\n+                    }\n+                }\n+                _ => true\n+            }\n+        });\n+        self.super_basic_block_data(block, data);\n+    }\n+    fn visit_lvalue(&mut self, lval: &mut Lvalue<'tcx>, ctx: LvalueContext<'tcx>, loc: Location) {\n+        match *lval {\n+            Lvalue::Local(ref mut l) => *l = Local::new(self.map[l.index()]),\n+            _ => (),\n+        };\n+        self.super_lvalue(lval, ctx, loc);\n+    }\n+}", "previous_filename": "src/librustc_mir/transform/simplify_cfg.rs"}, {"sha": "02a0b3ab28d622026e73f87f912a7e92d0ad4ab6", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn fn_like(&mut self,\n                fk: FnKind,\n                fd: &hir::FnDecl,\n-               b: &hir::Block,\n+               b: &hir::Expr,\n                s: Span,\n                fn_id: ast::NodeId)\n                -> ConstQualif {\n@@ -265,7 +265,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n-                b: &'v hir::Block,\n+                b: &'v hir::Expr,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         self.fn_like(fk, fd, b, s, fn_id);\n@@ -319,7 +319,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         let mut outer = self.qualif;\n         self.qualif = ConstQualif::empty();\n \n-        let node_ty = self.tcx.node_id_to_type(ex.id);\n+        let node_ty = self.tcx.tables().node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n@@ -449,14 +449,14 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n     match e.node {\n         hir::ExprUnary(..) |\n         hir::ExprBinary(..) |\n-        hir::ExprIndex(..) if v.tcx.tables.borrow().method_map.contains_key(&method_call) => {\n+        hir::ExprIndex(..) if v.tcx.tables().method_map.contains_key(&method_call) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n         }\n         hir::ExprBox(_) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n         }\n         hir::ExprUnary(op, ref inner) => {\n-            match v.tcx.node_id_to_type(inner.id).sty {\n+            match v.tcx.tables().node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n@@ -466,7 +466,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprBinary(op, ref lhs, _) => {\n-            match v.tcx.node_id_to_type(lhs.id).sty {\n+            match v.tcx.tables().node_id_to_type(lhs.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n                             op.node == hir::BiLe || op.node == hir::BiLt ||\n@@ -503,7 +503,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                     }\n                 }\n                 Def::Const(did) | Def::AssociatedConst(did) => {\n-                    let substs = Some(v.tcx.node_id_item_substs(e.id).substs);\n+                    let substs = Some(v.tcx.tables().node_id_item_substs(e.id)\n+                        .unwrap_or_else(|| v.tcx.intern_substs(&[])));\n                     if let Some((expr, _)) = lookup_const_by_id(v.tcx, did, substs) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n@@ -541,7 +542,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                     v.handle_const_fn_call(e, did, node_ty)\n                 }\n                 Some(Def::Method(did)) => {\n-                    match v.tcx.impl_or_trait_item(did).container() {\n+                    match v.tcx.associated_item(did).container {\n                         ty::ImplContainer(_) => {\n                             v.handle_const_fn_call(e, did, node_ty)\n                         }\n@@ -555,8 +556,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let method = v.tcx.tables.borrow().method_map[&method_call];\n-            let is_const = match v.tcx.impl_or_trait_item(method.def_id).container() {\n+            let method = v.tcx.tables().method_map[&method_call];\n+            let is_const = match v.tcx.associated_item(method.def_id).container {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(e, method.def_id, node_ty),\n                 ty::TraitContainer(_) => false\n             };\n@@ -565,7 +566,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprStruct(..) => {\n-            if let ty::TyAdt(adt, ..) = v.tcx.expr_ty(e).sty {\n+            if let ty::TyAdt(adt, ..) = v.tcx.tables().expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n                     v.add_qualif(ConstQualif::MUTABLE_MEM);\n@@ -624,16 +625,18 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n \n /// Check the adjustments of an expression\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n-    match v.tcx.tables.borrow().adjustments.get(&e.id) {\n+    use rustc::ty::adjustment::*;\n+\n+    match v.tcx.tables().adjustments.get(&e.id).map(|adj| adj.kind) {\n         None |\n-        Some(&ty::adjustment::AdjustNeverToAny(..)) |\n-        Some(&ty::adjustment::AdjustReifyFnPointer) |\n-        Some(&ty::adjustment::AdjustUnsafeFnPointer) |\n-        Some(&ty::adjustment::AdjustMutToConstPointer) => {}\n+        Some(Adjust::NeverToAny) |\n+        Some(Adjust::ReifyFnPointer) |\n+        Some(Adjust::UnsafeFnPointer) |\n+        Some(Adjust::MutToConstPointer) => {}\n \n-        Some(&ty::adjustment::AdjustDerefRef(ty::adjustment::AutoDerefRef { autoderefs, .. })) => {\n+        Some(Adjust::DerefRef { autoderefs, .. }) => {\n             if (0..autoderefs as u32)\n-                .any(|autoderef| v.tcx.is_overloaded_autoderef(e.id, autoderef)) {\n+                .any(|autoderef| v.tcx.tables().is_overloaded_autoderef(e.id, autoderef)) {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n             }\n         }"}, {"sha": "417987d9664e0f3533e651fa0d9e74b4e92db517", "filename": "src/librustc_passes/hir_stats.rs", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -0,0 +1,373 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The visitors in this module collect sizes and counts of the most important\n+// pieces of AST and HIR. The resulting numbers are good approximations but not\n+// completely accurate (some things might be counted twice, others missed).\n+\n+use rustc::hir;\n+use rustc::hir::intravisit as hir_visit;\n+use rustc::util::common::to_readable_str;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use syntax::ast::{self, NodeId, AttrId};\n+use syntax::visit as ast_visit;\n+use syntax_pos::Span;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+enum Id {\n+    Node(NodeId),\n+    Attr(AttrId),\n+    None,\n+}\n+\n+struct NodeData {\n+    count: usize,\n+    size: usize,\n+}\n+\n+struct StatCollector<'k> {\n+    krate: Option<&'k hir::Crate>,\n+    data: FxHashMap<&'static str, NodeData>,\n+    seen: FxHashSet<Id>,\n+}\n+\n+pub fn print_hir_stats(krate: &hir::Crate) {\n+    let mut collector = StatCollector {\n+        krate: Some(krate),\n+        data: FxHashMap(),\n+        seen: FxHashSet(),\n+    };\n+    hir_visit::walk_crate(&mut collector, krate);\n+    collector.print(\"HIR STATS\");\n+}\n+\n+pub fn print_ast_stats(krate: &ast::Crate, title: &str) {\n+    let mut collector = StatCollector {\n+        krate: None,\n+        data: FxHashMap(),\n+        seen: FxHashSet(),\n+    };\n+    ast_visit::walk_crate(&mut collector, krate);\n+    collector.print(title);\n+}\n+\n+impl<'k> StatCollector<'k> {\n+\n+    fn record<T>(&mut self, label: &'static str, id: Id, node: &T) {\n+        if id != Id::None {\n+            if !self.seen.insert(id) {\n+                return\n+            }\n+        }\n+\n+        let entry = self.data.entry(label).or_insert(NodeData {\n+            count: 0,\n+            size: 0,\n+        });\n+\n+        entry.count += 1;\n+        entry.size = ::std::mem::size_of_val(node);\n+    }\n+\n+    fn print(&self, title: &str) {\n+        let mut stats: Vec<_> = self.data.iter().collect();\n+\n+        stats.sort_by_key(|&(_, ref d)| d.count * d.size);\n+\n+        let mut total_size = 0;\n+\n+        println!(\"\\n{}\\n\", title);\n+\n+        println!(\"{:<18}{:>18}{:>14}{:>14}\",\n+            \"Name\", \"Accumulated Size\", \"Count\", \"Item Size\");\n+        println!(\"----------------------------------------------------------------\");\n+\n+        for (label, data) in stats {\n+            println!(\"{:<18}{:>18}{:>14}{:>14}\",\n+                label,\n+                to_readable_str(data.count * data.size),\n+                to_readable_str(data.count),\n+                to_readable_str(data.size));\n+\n+            total_size += data.count * data.size;\n+        }\n+        println!(\"----------------------------------------------------------------\");\n+        println!(\"{:<18}{:>18}\\n\",\n+                \"Total\",\n+                to_readable_str(total_size));\n+    }\n+}\n+\n+impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n+\n+    fn visit_nested_item(&mut self, id: hir::ItemId) {\n+        let nested_item = self.krate.unwrap().item(id.id);\n+        self.visit_item(nested_item)\n+    }\n+\n+    fn visit_item(&mut self, i: &'v hir::Item) {\n+        self.record(\"Item\", Id::Node(i.id), i);\n+        hir_visit::walk_item(self, i)\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+\n+    fn visit_mod(&mut self, m: &'v hir::Mod, _s: Span, n: NodeId) {\n+        self.record(\"Mod\", Id::None, m);\n+        hir_visit::walk_mod(self, m, n)\n+    }\n+    fn visit_foreign_item(&mut self, i: &'v hir::ForeignItem) {\n+        self.record(\"ForeignItem\", Id::Node(i.id), i);\n+        hir_visit::walk_foreign_item(self, i)\n+    }\n+    fn visit_local(&mut self, l: &'v hir::Local) {\n+        self.record(\"Local\", Id::Node(l.id), l);\n+        hir_visit::walk_local(self, l)\n+    }\n+    fn visit_block(&mut self, b: &'v hir::Block) {\n+        self.record(\"Block\", Id::Node(b.id), b);\n+        hir_visit::walk_block(self, b)\n+    }\n+    fn visit_stmt(&mut self, s: &'v hir::Stmt) {\n+        self.record(\"Stmt\", Id::Node(s.node.id()), s);\n+        hir_visit::walk_stmt(self, s)\n+    }\n+    fn visit_arm(&mut self, a: &'v hir::Arm) {\n+        self.record(\"Arm\", Id::None, a);\n+        hir_visit::walk_arm(self, a)\n+    }\n+    fn visit_pat(&mut self, p: &'v hir::Pat) {\n+        self.record(\"Pat\", Id::Node(p.id), p);\n+        hir_visit::walk_pat(self, p)\n+    }\n+    fn visit_decl(&mut self, d: &'v hir::Decl) {\n+        self.record(\"Decl\", Id::None, d);\n+        hir_visit::walk_decl(self, d)\n+    }\n+    fn visit_expr(&mut self, ex: &'v hir::Expr) {\n+        self.record(\"Expr\", Id::Node(ex.id), ex);\n+        hir_visit::walk_expr(self, ex)\n+    }\n+\n+    fn visit_ty(&mut self, t: &'v hir::Ty) {\n+        self.record(\"Ty\", Id::Node(t.id), t);\n+        hir_visit::walk_ty(self, t)\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fk: hir_visit::FnKind<'v>,\n+                fd: &'v hir::FnDecl,\n+                b: &'v hir::Expr,\n+                s: Span,\n+                id: NodeId) {\n+        self.record(\"FnDecl\", Id::None, fd);\n+        hir_visit::walk_fn(self, fk, fd, b, s, id)\n+    }\n+\n+    fn visit_where_predicate(&mut self, predicate: &'v hir::WherePredicate) {\n+        self.record(\"WherePredicate\", Id::None, predicate);\n+        hir_visit::walk_where_predicate(self, predicate)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'v hir::TraitItem) {\n+        self.record(\"TraitItem\", Id::Node(ti.id), ti);\n+        hir_visit::walk_trait_item(self, ti)\n+    }\n+    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n+        self.record(\"ImplItem\", Id::Node(ii.id), ii);\n+        hir_visit::walk_impl_item(self, ii)\n+    }\n+\n+    fn visit_ty_param_bound(&mut self, bounds: &'v hir::TyParamBound) {\n+        self.record(\"TyParamBound\", Id::None, bounds);\n+        hir_visit::walk_ty_param_bound(self, bounds)\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'v hir::StructField) {\n+        self.record(\"StructField\", Id::Node(s.id), s);\n+        hir_visit::walk_struct_field(self, s)\n+    }\n+\n+    fn visit_variant(&mut self,\n+                     v: &'v hir::Variant,\n+                     g: &'v hir::Generics,\n+                     item_id: NodeId) {\n+        self.record(\"Variant\", Id::None, v);\n+        hir_visit::walk_variant(self, v, g, item_id)\n+    }\n+    fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n+        self.record(\"Lifetime\", Id::Node(lifetime.id), lifetime);\n+        hir_visit::walk_lifetime(self, lifetime)\n+    }\n+    fn visit_lifetime_def(&mut self, lifetime: &'v hir::LifetimeDef) {\n+        self.record(\"LifetimeDef\", Id::None, lifetime);\n+        hir_visit::walk_lifetime_def(self, lifetime)\n+    }\n+    fn visit_path(&mut self, path: &'v hir::Path, _id: NodeId) {\n+        self.record(\"Path\", Id::None, path);\n+        hir_visit::walk_path(self, path)\n+    }\n+    fn visit_path_list_item(&mut self,\n+                            prefix: &'v hir::Path,\n+                            item: &'v hir::PathListItem) {\n+        self.record(\"PathListItem\", Id::Node(item.node.id), item);\n+        hir_visit::walk_path_list_item(self, prefix, item)\n+    }\n+    fn visit_path_segment(&mut self,\n+                          path_span: Span,\n+                          path_segment: &'v hir::PathSegment) {\n+        self.record(\"PathSegment\", Id::None, path_segment);\n+        hir_visit::walk_path_segment(self, path_span, path_segment)\n+    }\n+\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'v hir::TypeBinding) {\n+        self.record(\"TypeBinding\", Id::Node(type_binding.id), type_binding);\n+        hir_visit::walk_assoc_type_binding(self, type_binding)\n+    }\n+    fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n+        self.record(\"Attribute\", Id::Attr(attr.node.id), attr);\n+    }\n+    fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef) {\n+        self.record(\"MacroDef\", Id::Node(macro_def.id), macro_def);\n+        hir_visit::walk_macro_def(self, macro_def)\n+    }\n+}\n+\n+impl<'v> ast_visit::Visitor for StatCollector<'v> {\n+\n+    fn visit_mod(&mut self, m: &ast::Mod, _s: Span, _n: NodeId) {\n+        self.record(\"Mod\", Id::None, m);\n+        ast_visit::walk_mod(self, m)\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n+        self.record(\"ForeignItem\", Id::None, i);\n+        ast_visit::walk_foreign_item(self, i)\n+    }\n+\n+    fn visit_item(&mut self, i: &ast::Item) {\n+        self.record(\"Item\", Id::None, i);\n+        ast_visit::walk_item(self, i)\n+    }\n+\n+    fn visit_local(&mut self, l: &ast::Local) {\n+        self.record(\"Local\", Id::None, l);\n+        ast_visit::walk_local(self, l)\n+    }\n+\n+    fn visit_block(&mut self, b: &ast::Block) {\n+        self.record(\"Block\", Id::None, b);\n+        ast_visit::walk_block(self, b)\n+    }\n+\n+    fn visit_stmt(&mut self, s: &ast::Stmt) {\n+        self.record(\"Stmt\", Id::None, s);\n+        ast_visit::walk_stmt(self, s)\n+    }\n+\n+    fn visit_arm(&mut self, a: &ast::Arm) {\n+        self.record(\"Arm\", Id::None, a);\n+        ast_visit::walk_arm(self, a)\n+    }\n+\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n+        self.record(\"Pat\", Id::None, p);\n+        ast_visit::walk_pat(self, p)\n+    }\n+\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n+        self.record(\"Expr\", Id::None, ex);\n+        ast_visit::walk_expr(self, ex)\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n+        self.record(\"Ty\", Id::None, t);\n+        ast_visit::walk_ty(self, t)\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fk: ast_visit::FnKind,\n+                fd: &ast::FnDecl,\n+                s: Span,\n+                _: NodeId) {\n+        self.record(\"FnDecl\", Id::None, fd);\n+        ast_visit::walk_fn(self, fk, fd, s)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        self.record(\"TraitItem\", Id::None, ti);\n+        ast_visit::walk_trait_item(self, ti)\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        self.record(\"ImplItem\", Id::None, ii);\n+        ast_visit::walk_impl_item(self, ii)\n+    }\n+\n+    fn visit_ty_param_bound(&mut self, bounds: &ast::TyParamBound) {\n+        self.record(\"TyParamBound\", Id::None, bounds);\n+        ast_visit::walk_ty_param_bound(self, bounds)\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &ast::StructField) {\n+        self.record(\"StructField\", Id::None, s);\n+        ast_visit::walk_struct_field(self, s)\n+    }\n+\n+    fn visit_variant(&mut self,\n+                     v: &ast::Variant,\n+                     g: &ast::Generics,\n+                     item_id: NodeId) {\n+        self.record(\"Variant\", Id::None, v);\n+        ast_visit::walk_variant(self, v, g, item_id)\n+    }\n+\n+    fn visit_lifetime(&mut self, lifetime: &ast::Lifetime) {\n+        self.record(\"Lifetime\", Id::None, lifetime);\n+        ast_visit::walk_lifetime(self, lifetime)\n+    }\n+\n+    fn visit_lifetime_def(&mut self, lifetime: &ast::LifetimeDef) {\n+        self.record(\"LifetimeDef\", Id::None, lifetime);\n+        ast_visit::walk_lifetime_def(self, lifetime)\n+    }\n+\n+    fn visit_mac(&mut self, mac: &ast::Mac) {\n+        self.record(\"Mac\", Id::None, mac);\n+    }\n+\n+    fn visit_path_list_item(&mut self,\n+                            prefix: &ast::Path,\n+                            item: &ast::PathListItem) {\n+        self.record(\"PathListItem\", Id::None, item);\n+        ast_visit::walk_path_list_item(self, prefix, item)\n+    }\n+\n+    fn visit_path_segment(&mut self,\n+                          path_span: Span,\n+                          path_segment: &ast::PathSegment) {\n+        self.record(\"PathSegment\", Id::None, path_segment);\n+        ast_visit::walk_path_segment(self, path_span, path_segment)\n+    }\n+\n+    fn visit_assoc_type_binding(&mut self, type_binding: &ast::TypeBinding) {\n+        self.record(\"TypeBinding\", Id::None, type_binding);\n+        ast_visit::walk_assoc_type_binding(self, type_binding)\n+    }\n+\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+        self.record(\"Attribute\", Id::None, attr);\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &ast::MacroDef) {\n+        self.record(\"MacroDef\", Id::None, macro_def);\n+        ast_visit::walk_macro_def(self, macro_def)\n+    }\n+}"}, {"sha": "039a76d25c7e10ac205e9a9127eb6fc7da30825f", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -23,7 +23,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(rustc_diagnostic_macros)]\n #![feature(staged_api)]\n #![feature(rustc_private)]\n@@ -45,6 +45,7 @@ pub mod diagnostics;\n \n pub mod ast_validation;\n pub mod consts;\n+pub mod hir_stats;\n pub mod loops;\n pub mod no_asm;\n pub mod rvalues;"}, {"sha": "e58cd893819339636d12191b447389d37fcc862b", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n                 self.with_context(Loop, |v| v.visit_block(&b));\n             }\n             hir::ExprClosure(.., ref b, _) => {\n-                self.with_context(Closure, |v| v.visit_block(&b));\n+                self.with_context(Closure, |v| v.visit_expr(&b));\n             }\n             hir::ExprBreak(_) => self.require_loop(\"break\", e.span),\n             hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),"}, {"sha": "d55ce4c356384618062967a8f35089f8131f343b", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: intravisit::FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n-                b: &'v hir::Block,\n+                b: &'v hir::Expr,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         // FIXME (@jroesch) change this to be an inference context"}, {"sha": "dc7399e228908bee2ad0a3daec05455c8527ffaa", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -17,7 +17,7 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n     // Checks that a method is in scope.\n     fn check_method(&mut self, span: Span, method_def_id: DefId) {\n-        match self.tcx.impl_or_trait_item(method_def_id).container() {\n+        match self.tcx.associated_item(method_def_id).container {\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n             ty::TraitContainer(trait_def_id) if !self.item_is_accessible(trait_def_id) => {\n@@ -430,11 +430,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method = self.tcx.tables.borrow().method_map[&method_call];\n+                let method = self.tcx.tables().method_map[&method_call];\n                 self.check_method(expr.span, method.def_id);\n             }\n             hir::ExprStruct(_, ref expr_fields, _) => {\n-                let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(expr.id));\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n@@ -495,14 +495,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             PatKind::Struct(_, ref fields, _) => {\n-                let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().pat_ty(pattern).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(pattern.id));\n                 for field in fields {\n                     self.check_field(field.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n             PatKind::TupleStruct(_, ref fields, ddpos) => {\n-                match self.tcx.pat_ty(pattern).sty {\n+                match self.tcx.tables().pat_ty(pattern).sty {\n                     // enum fields have no privacy at this time\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let expected_len = def.struct_variant().fields.len();"}, {"sha": "99e7a9042c0ceb939c8a49de6b7d62d87a9e4458", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 119, "deletions": 144, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -14,18 +14,17 @@\n //! any imports resolved.\n \n use macros::{InvocationData, LegacyScope};\n+use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n-use {Module, ModuleS, ModuleKind};\n-use Namespace::{self, TypeNS, ValueNS};\n-use {NameBinding, NameBindingKind, ToNameBinding};\n-use Resolver;\n+use {Resolver, Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n+use Namespace::{self, TypeNS, ValueNS, MacroNS};\n+use ResolveResult::Success;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::LoadedMacros;\n+use rustc::middle::cstore::{DepKind, LoadedMacro};\n use rustc::hir::def::*;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n-use rustc::util::nodemap::FnvHashMap;\n \n use std::cell::Cell;\n use std::rc::Rc;\n@@ -37,10 +36,9 @@ use syntax::parse::token;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use syntax::ext::base::{SyntaxExtension, Resolver as SyntaxResolver};\n+use syntax::ext::base::SyntaxExtension;\n use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n-use syntax::feature_gate::{self, emit_feature_err};\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::keywords;\n use syntax::visit::{self, Visitor};\n@@ -64,7 +62,6 @@ struct LegacyMacroImports {\n     import_all: Option<Span>,\n     imports: Vec<(Name, Span)>,\n     reexports: Vec<(Name, Span)>,\n-    no_link: bool,\n }\n \n impl<'b> Resolver<'b> {\n@@ -215,53 +212,26 @@ impl<'b> Resolver<'b> {\n             }\n \n             ItemKind::ExternCrate(_) => {\n-                let legacy_imports = self.legacy_macro_imports(&item.attrs);\n-                // `#[macro_use]` and `#[macro_reexport]` are only allowed at the crate root.\n-                if self.current_module.parent.is_some() && {\n-                    legacy_imports.import_all.is_some() || !legacy_imports.imports.is_empty() ||\n-                    !legacy_imports.reexports.is_empty()\n-                } {\n-                    if self.current_module.parent.is_some() {\n-                        span_err!(self.session, item.span, E0468,\n-                                  \"an `extern crate` loading macros must be at the crate root\");\n-                    }\n-                }\n-\n-                let loaded_macros = if legacy_imports != LegacyMacroImports::default() {\n-                    self.crate_loader.process_item(item, &self.definitions, true)\n-                } else {\n-                    self.crate_loader.process_item(item, &self.definitions, false)\n-                };\n+                self.crate_loader.process_item(item, &self.definitions);\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id);\n-                let module = if let Some(crate_id) = crate_id {\n-                    let def_id = DefId {\n-                        krate: crate_id,\n-                        index: CRATE_DEF_INDEX,\n-                    };\n-                    let module = self.arenas.alloc_module(ModuleS {\n-                        extern_crate_id: Some(item.id),\n-                        populated: Cell::new(false),\n-                        ..ModuleS::new(Some(parent), ModuleKind::Def(Def::Mod(def_id), name))\n-                    });\n-                    self.define(parent, name, TypeNS, (module, sp, vis));\n-                    self.populate_module_if_necessary(module);\n-                    module\n-                } else {\n-                    // Define an empty module\n-                    let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                    let module = ModuleS::new(Some(parent), ModuleKind::Def(def, name));\n-                    let module = self.arenas.alloc_module(module);\n-                    self.define(parent, name, TypeNS, (module, sp, vis));\n-                    module\n-                };\n-\n-                if let Some(loaded_macros) = loaded_macros {\n-                    self.import_extern_crate_macros(\n-                        item, module, loaded_macros, legacy_imports, expansion == Mark::root(),\n-                    );\n-                }\n+                let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n+                let module = self.get_extern_crate_root(crate_id);\n+                let binding = (module, sp, ty::Visibility::Public).to_name_binding();\n+                let binding = self.arenas.alloc_name_binding(binding);\n+                let directive = self.arenas.alloc_import_directive(ImportDirective {\n+                    id: item.id,\n+                    parent: parent,\n+                    imported_module: Cell::new(Some(module)),\n+                    subclass: ImportDirectiveSubclass::ExternCrate,\n+                    span: item.span,\n+                    module_path: Vec::new(),\n+                    vis: Cell::new(vis),\n+                });\n+                let imported_binding = self.import(binding, directive);\n+                self.define(parent, name, TypeNS, imported_binding);\n+                self.populate_module_if_necessary(module);\n+                self.process_legacy_macro_imports(item, module, expansion);\n             }\n \n             ItemKind::Mod(..) if item.ident == keywords::Invalid.ident() => {} // Crate root\n@@ -282,9 +252,7 @@ impl<'b> Resolver<'b> {\n                 self.current_module = module;\n             }\n \n-            ItemKind::ForeignMod(..) => {\n-                self.crate_loader.process_item(item, &self.definitions, false);\n-            }\n+            ItemKind::ForeignMod(..) => self.crate_loader.process_item(item, &self.definitions),\n \n             // These items live in the value namespace.\n             ItemKind::Static(_, m, _) => {\n@@ -427,10 +395,10 @@ impl<'b> Resolver<'b> {\n         let name = child.name;\n         let def = child.def;\n         let def_id = def.def_id();\n-        let vis = if parent.is_trait() {\n-            ty::Visibility::Public\n-        } else {\n-            self.session.cstore.visibility(def_id)\n+        let vis = match def {\n+            Def::Macro(..) => ty::Visibility::Public,\n+            _ if parent.is_trait() => ty::Visibility::Public,\n+            _ => self.session.cstore.visibility(def_id),\n         };\n \n         match def {\n@@ -456,7 +424,7 @@ impl<'b> Resolver<'b> {\n                 self.define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n \n                 // If this is a trait, add all the trait item names to the trait info.\n-                let trait_item_def_ids = self.session.cstore.impl_or_trait_items(def_id);\n+                let trait_item_def_ids = self.session.cstore.associated_item_def_ids(def_id);\n                 for trait_item_def_id in trait_item_def_ids {\n                     let trait_item_name = self.session.cstore.def_key(trait_item_def_id)\n                                               .disambiguated_data.data.get_opt_name()\n@@ -484,6 +452,9 @@ impl<'b> Resolver<'b> {\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n+            Def::Macro(..) => {\n+                self.define(parent, name, MacroNS, (def, DUMMY_SP, vis));\n+            }\n             Def::Local(..) |\n             Def::PrimTy(..) |\n             Def::TyParam(..) |\n@@ -496,6 +467,47 @@ impl<'b> Resolver<'b> {\n         }\n     }\n \n+    fn get_extern_crate_root(&mut self, cnum: CrateNum) -> Module<'b> {\n+        let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+        let macros_only = self.session.cstore.dep_kind(cnum) == DepKind::MacrosOnly;\n+        let arenas = self.arenas;\n+        *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n+            arenas.alloc_module(ModuleS {\n+                populated: Cell::new(false),\n+                ..ModuleS::new(None, ModuleKind::Def(Def::Mod(def_id), keywords::Invalid.name()))\n+            })\n+        })\n+    }\n+\n+    pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> {\n+        let def_id = match def {\n+            Def::Macro(def_id) => def_id,\n+            _ => panic!(\"Expected Def::Macro(..)\"),\n+        };\n+        if let Some(ext) = self.macro_map.get(&def_id) {\n+            return ext.clone();\n+        }\n+\n+        let mut macro_rules = match self.session.cstore.load_macro(def_id, &self.session) {\n+            LoadedMacro::MacroRules(macro_rules) => macro_rules,\n+            LoadedMacro::ProcMacro(ext) => return ext,\n+        };\n+\n+        let mark = Mark::fresh();\n+        let invocation = self.arenas.alloc_invocation_data(InvocationData {\n+            module: Cell::new(self.get_extern_crate_root(def_id.krate)),\n+            def_index: CRATE_DEF_INDEX,\n+            const_integer: false,\n+            legacy_scope: Cell::new(LegacyScope::Empty),\n+            expansion: Cell::new(LegacyScope::Empty),\n+        });\n+        self.invocations.insert(mark, invocation);\n+        macro_rules.body = mark_tts(&macro_rules.body, mark);\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &macro_rules));\n+        self.macro_map.insert(def_id, ext.clone());\n+        ext\n+    }\n+\n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n     pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {\n@@ -506,90 +518,55 @@ impl<'b> Resolver<'b> {\n         module.populated.set(true)\n     }\n \n-    fn import_extern_crate_macros(&mut self,\n-                                  extern_crate: &Item,\n-                                  module: Module<'b>,\n-                                  loaded_macros: LoadedMacros,\n-                                  legacy_imports: LegacyMacroImports,\n-                                  allow_shadowing: bool) {\n-        let import_macro = |this: &mut Self, name, ext: Rc<_>, span| {\n-            this.used_crates.insert(module.def_id().unwrap().krate);\n-            if let SyntaxExtension::NormalTT(..) = *ext {\n-                this.macro_names.insert(name);\n-            }\n-            if this.builtin_macros.insert(name, ext).is_some() && !allow_shadowing {\n-                let msg = format!(\"`{}` is already in scope\", name);\n-                let note =\n-                    \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n-                this.session.struct_span_err(span, &msg).note(note).emit();\n-            }\n-        };\n-\n-        match loaded_macros {\n-            LoadedMacros::MacroRules(macros) => {\n-                let mark = Mark::fresh();\n-                if !macros.is_empty() {\n-                    let invocation = self.arenas.alloc_invocation_data(InvocationData {\n-                        module: Cell::new(module),\n-                        def_index: CRATE_DEF_INDEX,\n-                        const_integer: false,\n-                        legacy_scope: Cell::new(LegacyScope::Empty),\n-                        expansion: Cell::new(LegacyScope::Empty),\n-                    });\n-                    self.invocations.insert(mark, invocation);\n-                }\n+    fn legacy_import_macro(&mut self, name: Name, def: Def, span: Span, allow_shadowing: bool) {\n+        self.used_crates.insert(def.def_id().krate);\n+        self.macro_names.insert(name);\n+        if self.builtin_macros.insert(name, def.def_id()).is_some() && !allow_shadowing {\n+            let msg = format!(\"`{}` is already in scope\", name);\n+            let note =\n+                \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n+            self.session.struct_span_err(span, &msg).note(note).emit();\n+        }\n+    }\n \n-                let mut macros: FnvHashMap<_, _> = macros.into_iter().map(|mut def| {\n-                    def.body = mark_tts(&def.body, mark);\n-                    let ext = macro_rules::compile(&self.session.parse_sess, &def);\n-                    (def.ident.name, (def, Rc::new(ext)))\n-                }).collect();\n+    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'b>, expansion: Mark) {\n+        let allow_shadowing = expansion == Mark::root();\n+        let legacy_imports = self.legacy_macro_imports(&item.attrs);\n+        let cnum = module.def_id().unwrap().krate;\n+\n+        // `#[macro_use]` and `#[macro_reexport]` are only allowed at the crate root.\n+        if self.current_module.parent.is_some() && legacy_imports != LegacyMacroImports::default() {\n+            span_err!(self.session, item.span, E0468,\n+                      \"an `extern crate` loading macros must be at the crate root\");\n+        } else if self.session.cstore.dep_kind(cnum) == DepKind::MacrosOnly &&\n+                  legacy_imports == LegacyMacroImports::default() {\n+            let msg = \"custom derive crates and `#[no_link]` crates have no effect without \\\n+                       `#[macro_use]`\";\n+            self.session.span_warn(item.span, msg);\n+            self.used_crates.insert(cnum); // Avoid the normal unused extern crate warning\n+        }\n \n-                if let Some(span) = legacy_imports.import_all {\n-                    for (&name, &(_, ref ext)) in macros.iter() {\n-                        import_macro(self, name, ext.clone(), span);\n-                    }\n+        if let Some(span) = legacy_imports.import_all {\n+            module.for_each_child(|name, ns, binding| if ns == MacroNS {\n+                self.legacy_import_macro(name, binding.def(), span, allow_shadowing);\n+            });\n+        } else {\n+            for (name, span) in legacy_imports.imports {\n+                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+                if let Success(binding) = result {\n+                    self.legacy_import_macro(name, binding.def(), span, allow_shadowing);\n                 } else {\n-                    for (name, span) in legacy_imports.imports {\n-                        if let Some(&(_, ref ext)) = macros.get(&name) {\n-                            import_macro(self, name, ext.clone(), span);\n-                        } else {\n-                            span_err!(self.session, span, E0469, \"imported macro not found\");\n-                        }\n-                    }\n-                }\n-                for (name, span) in legacy_imports.reexports {\n-                    if let Some((mut def, _)) = macros.remove(&name) {\n-                        def.id = self.next_node_id();\n-                        self.exported_macros.push(def);\n-                    } else {\n-                        span_err!(self.session, span, E0470, \"reexported macro not found\");\n-                    }\n+                    span_err!(self.session, span, E0469, \"imported macro not found\");\n                 }\n             }\n-\n-            LoadedMacros::ProcMacros(macros) => {\n-                if !self.session.features.borrow().proc_macro {\n-                    let sess = &self.session.parse_sess;\n-                    let issue = feature_gate::GateIssue::Language;\n-                    let msg =\n-                        \"loading custom derive macro crates is experimentally supported\";\n-                    emit_feature_err(sess, \"proc_macro\", extern_crate.span, issue, msg);\n-                }\n-                if !legacy_imports.imports.is_empty() {\n-                    let msg = \"`proc-macro` crates cannot be selectively imported from, \\\n-                               must use `#[macro_use]`\";\n-                    self.session.span_err(extern_crate.span, msg);\n-                }\n-                if !legacy_imports.reexports.is_empty() {\n-                    let msg = \"`proc-macro` crates cannot be reexported from\";\n-                    self.session.span_err(extern_crate.span, msg);\n-                }\n-                if let Some(span) = legacy_imports.import_all {\n-                    for (name, ext) in macros {\n-                        import_macro(self, name, Rc::new(ext), span);\n-                    }\n-                }\n+        }\n+        for (name, span) in legacy_imports.reexports {\n+            self.used_crates.insert(module.def_id().unwrap().krate);\n+            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+            if let Success(binding) = result {\n+                self.macro_exports.push(Export { name: name, def: binding.def() });\n+            } else {\n+                span_err!(self.session, span, E0470, \"reexported macro not found\");\n             }\n         }\n     }\n@@ -647,8 +624,6 @@ impl<'b> Resolver<'b> {\n                 } else {\n                     bad_macro_reexport(self, attr.span());\n                 }\n-            } else if attr.check_name(\"no_link\") {\n-                imports.no_link = true;\n             }\n         }\n         imports"}, {"sha": "fe90cd34687c017aa3b5bba18e550d4a7a96f807", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 144, "deletions": 123, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -19,7 +19,7 @@\n \n #![feature(associated_consts)]\n #![feature(borrow_state)]\n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -51,7 +51,7 @@ use rustc::hir::def::*;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n-use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet};\n \n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, FloatTy};\n@@ -76,7 +76,7 @@ use std::fmt;\n use std::mem::replace;\n use std::rc::Rc;\n \n-use resolve_imports::{ImportDirective, NameResolution};\n+use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution};\n use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n // NB: This module needs to be declared first so diagnostics are\n@@ -108,7 +108,7 @@ enum ResolutionError<'a> {\n     /// error E0403: the name is already used for a type parameter in this type parameter list\n     NameAlreadyUsedInTypeParameterList(Name, &'a Span),\n     /// error E0404: is not a trait\n-    IsNotATrait(&'a str),\n+    IsNotATrait(&'a str, &'a str),\n     /// error E0405: use of undeclared trait name\n     UndeclaredTraitName(&'a str, SuggestedCandidates),\n     /// error E0407: method is not a member of trait\n@@ -223,13 +223,13 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n              err\n \n         }\n-        ResolutionError::IsNotATrait(name) => {\n+        ResolutionError::IsNotATrait(name, kind_name) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0404,\n                                            \"`{}` is not a trait\",\n                                            name);\n-            err.span_label(span, &format!(\"not a trait\"));\n+            err.span_label(span, &format!(\"expected trait, found {}\", kind_name));\n             err\n         }\n         ResolutionError::UndeclaredTraitName(name, candidates) => {\n@@ -498,7 +498,7 @@ struct BindingInfo {\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = FnvHashMap<Ident, BindingInfo>;\n+type BindingMap = FxHashMap<Ident, BindingInfo>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n@@ -533,6 +533,7 @@ impl PatternSource {\n pub enum Namespace {\n     TypeNS,\n     ValueNS,\n+    MacroNS,\n }\n \n impl<'a> Visitor for Resolver<'a> {\n@@ -555,7 +556,7 @@ impl<'a> Visitor for Resolver<'a> {\n         self.resolve_type(ty);\n     }\n     fn visit_poly_trait_ref(&mut self, tref: &ast::PolyTraitRef, m: &ast::TraitBoundModifier) {\n-        match self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0) {\n+        match self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0, None) {\n             Ok(def) => self.record_def(tref.trait_ref.ref_id, def),\n             Err(_) => {\n                 // error already reported\n@@ -596,21 +597,52 @@ impl<'a> Visitor for Resolver<'a> {\n     fn visit_fn(&mut self,\n                 function_kind: FnKind,\n                 declaration: &FnDecl,\n-                block: &Block,\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_generics(generics);\n                 ItemRibKind\n             }\n-            FnKind::Method(_, sig, _) => {\n+            FnKind::Method(_, sig, _, _) => {\n                 self.visit_generics(&sig.generics);\n                 MethodRibKind(!sig.decl.has_self())\n             }\n-            FnKind::Closure => ClosureRibKind(node_id),\n+            FnKind::Closure(_) => ClosureRibKind(node_id),\n         };\n-        self.resolve_function(rib_kind, declaration, block);\n+\n+        // Create a value rib for the function.\n+        self.value_ribs.push(Rib::new(rib_kind));\n+\n+        // Create a label rib for the function.\n+        self.label_ribs.push(Rib::new(rib_kind));\n+\n+        // Add each argument to the rib.\n+        let mut bindings_list = FxHashMap();\n+        for argument in &declaration.inputs {\n+            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+\n+            self.visit_ty(&argument.ty);\n+\n+            debug!(\"(resolving function) recorded argument\");\n+        }\n+        visit::walk_fn_ret_ty(self, &declaration.output);\n+\n+        // Resolve the function body.\n+        match function_kind {\n+            FnKind::ItemFn(.., body) |\n+            FnKind::Method(.., body) => {\n+                self.visit_block(body);\n+            }\n+            FnKind::Closure(body) => {\n+                self.visit_expr(body);\n+            }\n+        };\n+\n+        debug!(\"(resolving function) leaving function\");\n+\n+        self.label_ribs.pop();\n+        self.value_ribs.pop();\n     }\n }\n \n@@ -703,14 +735,14 @@ enum ModulePrefixResult<'a> {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: FnvHashMap<Ident, Def>,\n+    bindings: FxHashMap<Ident, Def>,\n     kind: RibKind<'a>,\n }\n \n impl<'a> Rib<'a> {\n     fn new(kind: RibKind<'a>) -> Rib<'a> {\n         Rib {\n-            bindings: FnvHashMap(),\n+            bindings: FxHashMap(),\n             kind: kind,\n         }\n     }\n@@ -765,11 +797,7 @@ pub struct ModuleS<'a> {\n     // The node id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: Option<NodeId>,\n \n-    // If the module is an extern crate, `def` is root of the external crate and `extern_crate_id`\n-    // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n-    extern_crate_id: Option<NodeId>,\n-\n-    resolutions: RefCell<FnvHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n \n     no_implicit_prelude: bool,\n \n@@ -793,8 +821,7 @@ impl<'a> ModuleS<'a> {\n             parent: parent,\n             kind: kind,\n             normal_ancestor_id: None,\n-            extern_crate_id: None,\n-            resolutions: RefCell::new(FnvHashMap()),\n+            resolutions: RefCell::new(FxHashMap()),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n@@ -922,7 +949,14 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_extern_crate(&self) -> bool {\n-        self.module().ok().and_then(|module| module.extern_crate_id).is_some()\n+        match self.kind {\n+            NameBindingKind::Import {\n+                directive: &ImportDirective {\n+                    subclass: ImportDirectiveSubclass::ExternCrate, ..\n+                }, ..\n+            } => true,\n+            _ => false,\n+        }\n     }\n \n     fn is_import(&self) -> bool {\n@@ -950,12 +984,12 @@ impl<'a> NameBinding<'a> {\n \n /// Interns the names of the primitive types.\n struct PrimitiveTypeTable {\n-    primitive_types: FnvHashMap<Name, PrimTy>,\n+    primitive_types: FxHashMap<Name, PrimTy>,\n }\n \n impl PrimitiveTypeTable {\n     fn new() -> PrimitiveTypeTable {\n-        let mut table = PrimitiveTypeTable { primitive_types: FnvHashMap() };\n+        let mut table = PrimitiveTypeTable { primitive_types: FxHashMap() };\n \n         table.intern(\"bool\", TyBool);\n         table.intern(\"char\", TyChar);\n@@ -989,17 +1023,17 @@ pub struct Resolver<'a> {\n \n     // Maps the node id of a statement to the expansions of the `macro_rules!`s\n     // immediately above the statement (if appropriate).\n-    macros_at_scope: FnvHashMap<NodeId, Vec<Mark>>,\n+    macros_at_scope: FxHashMap<NodeId, Vec<Mark>>,\n \n     graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n \n-    trait_item_map: FnvHashMap<(Name, DefId), bool /* is static method? */>,\n+    trait_item_map: FxHashMap<(Name, DefId), bool /* is static method? */>,\n \n     // Names of fields of an item `DefId` accessible with dot syntax.\n     // Used for hints during error reporting.\n-    field_names: FnvHashMap<DefId, Vec<Name>>,\n+    field_names: FxHashMap<DefId, Vec<Name>>,\n \n     // All imports known to succeed or fail.\n     determined_imports: Vec<&'a ImportDirective<'a>>,\n@@ -1050,6 +1084,7 @@ pub struct Resolver<'a> {\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n     module_map: NodeMap<Module<'a>>,\n+    extern_crate_roots: FxHashMap<(CrateNum, bool /* MacrosOnly? */), Module<'a>>,\n \n     // Whether or not to print error messages. Can be set to true\n     // when getting additional info for error message suggestions,\n@@ -1061,25 +1096,28 @@ pub struct Resolver<'a> {\n     // all imports, but only glob imports are actually interesting).\n     pub glob_map: GlobMap,\n \n-    used_imports: FnvHashSet<(NodeId, Namespace)>,\n-    used_crates: FnvHashSet<CrateNum>,\n+    used_imports: FxHashSet<(NodeId, Namespace)>,\n+    used_crates: FxHashSet<CrateNum>,\n     pub maybe_unused_trait_imports: NodeSet,\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n     ambiguity_errors: Vec<AmbiguityError<'a>>,\n-    disallowed_shadowing: Vec<(Name, Span, LegacyScope<'a>)>,\n+    disallowed_shadowing: Vec<&'a LegacyBinding<'a>>,\n \n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n \n     pub exported_macros: Vec<ast::MacroDef>,\n     crate_loader: &'a mut CrateLoader,\n-    macro_names: FnvHashSet<Name>,\n-    builtin_macros: FnvHashMap<Name, Rc<SyntaxExtension>>,\n+    macro_names: FxHashSet<Name>,\n+    builtin_macros: FxHashMap<Name, DefId>,\n+    lexical_macro_resolutions: Vec<(Name, LegacyScope<'a>)>,\n+    macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n+    macro_exports: Vec<Export>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n-    invocations: FnvHashMap<Mark, &'a InvocationData<'a>>,\n+    invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1205,23 +1243,23 @@ impl<'a> Resolver<'a> {\n         let mut definitions = Definitions::new();\n         DefCollector::new(&mut definitions).collect_root();\n \n-        let mut invocations = FnvHashMap();\n+        let mut invocations = FxHashMap();\n         invocations.insert(Mark::root(),\n                            arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n         Resolver {\n             session: session,\n \n             definitions: definitions,\n-            macros_at_scope: FnvHashMap(),\n+            macros_at_scope: FxHashMap(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n             graph_root: graph_root,\n             prelude: None,\n \n-            trait_item_map: FnvHashMap(),\n-            field_names: FnvHashMap(),\n+            trait_item_map: FxHashMap(),\n+            field_names: FxHashMap(),\n \n             determined_imports: Vec::new(),\n             indeterminate_imports: Vec::new(),\n@@ -1242,13 +1280,14 @@ impl<'a> Resolver<'a> {\n             export_map: NodeMap(),\n             trait_map: NodeMap(),\n             module_map: module_map,\n+            extern_crate_roots: FxHashMap(),\n \n             emit_errors: true,\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n \n-            used_imports: FnvHashSet(),\n-            used_crates: FnvHashSet(),\n+            used_imports: FxHashSet(),\n+            used_crates: FxHashSet(),\n             maybe_unused_trait_imports: NodeSet(),\n \n             privacy_errors: Vec::new(),\n@@ -1265,8 +1304,11 @@ impl<'a> Resolver<'a> {\n \n             exported_macros: Vec::new(),\n             crate_loader: crate_loader,\n-            macro_names: FnvHashSet(),\n-            builtin_macros: FnvHashMap(),\n+            macro_names: FxHashSet(),\n+            builtin_macros: FxHashMap(),\n+            lexical_macro_resolutions: Vec::new(),\n+            macro_map: FxHashMap(),\n+            macro_exports: Vec::new(),\n             invocations: invocations,\n         }\n     }\n@@ -1285,13 +1327,6 @@ impl<'a> Resolver<'a> {\n \n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n-        // Collect `DefId`s for exported macro defs.\n-        for def in &krate.exported_macros {\n-            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n-                collector.visit_macro_def(def)\n-            })\n-        }\n-\n         self.current_module = self.graph_root;\n         visit::walk_crate(self, krate);\n \n@@ -1309,7 +1344,11 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn get_ribs<'b>(&'b mut self, ns: Namespace) -> &'b mut Vec<Rib<'a>> {\n-        match ns { ValueNS => &mut self.value_ribs, TypeNS => &mut self.type_ribs }\n+        match ns {\n+            ValueNS => &mut self.value_ribs,\n+            TypeNS => &mut self.type_ribs,\n+            MacroNS => panic!(\"The macro namespace has no ribs\"),\n+        }\n     }\n \n     fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n@@ -1338,7 +1377,7 @@ impl<'a> Resolver<'a> {\n \n     fn add_to_glob_map(&mut self, id: NodeId, name: Name) {\n         if self.make_glob_map {\n-            self.glob_map.entry(id).or_insert_with(FnvHashSet).insert(name);\n+            self.glob_map.entry(id).or_insert_with(FxHashSet).insert(name);\n         }\n     }\n \n@@ -1697,7 +1736,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemKind::DefaultImpl(_, ref trait_ref) => {\n-                self.with_optional_trait_ref(Some(trait_ref), |_, _| {});\n+                self.with_optional_trait_ref(Some(trait_ref), |_, _| {}, None);\n             }\n             ItemKind::Impl(.., ref generics, ref opt_trait_ref, ref self_type, ref impl_items) =>\n                 self.resolve_implementation(generics,\n@@ -1801,7 +1840,7 @@ impl<'a> Resolver<'a> {\n         match type_parameters {\n             HasTypeParameters(generics, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n-                let mut seen_bindings = FnvHashMap();\n+                let mut seen_bindings = FxHashMap();\n                 for type_parameter in &generics.ty_params {\n                     let name = type_parameter.ident.name;\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n@@ -1854,40 +1893,11 @@ impl<'a> Resolver<'a> {\n         self.value_ribs.pop();\n     }\n \n-    fn resolve_function(&mut self,\n-                        rib_kind: RibKind<'a>,\n-                        declaration: &FnDecl,\n-                        block: &Block) {\n-        // Create a value rib for the function.\n-        self.value_ribs.push(Rib::new(rib_kind));\n-\n-        // Create a label rib for the function.\n-        self.label_ribs.push(Rib::new(rib_kind));\n-\n-        // Add each argument to the rib.\n-        let mut bindings_list = FnvHashMap();\n-        for argument in &declaration.inputs {\n-            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n-\n-            self.visit_ty(&argument.ty);\n-\n-            debug!(\"(resolving function) recorded argument\");\n-        }\n-        visit::walk_fn_ret_ty(self, &declaration.output);\n-\n-        // Resolve the function body.\n-        self.visit_block(block);\n-\n-        debug!(\"(resolving function) leaving function\");\n-\n-        self.label_ribs.pop();\n-        self.value_ribs.pop();\n-    }\n-\n     fn resolve_trait_reference(&mut self,\n                                id: NodeId,\n                                trait_path: &Path,\n-                               path_depth: usize)\n+                               path_depth: usize,\n+                               generics: Option<&Generics>)\n                                -> Result<PathResolution, ()> {\n         self.resolve_path(id, trait_path, path_depth, TypeNS).and_then(|path_res| {\n             match path_res.base_def {\n@@ -1900,8 +1910,16 @@ impl<'a> Resolver<'a> {\n             }\n \n             let mut err = resolve_struct_error(self, trait_path.span, {\n-                ResolutionError::IsNotATrait(&path_names_to_string(trait_path, path_depth))\n+                ResolutionError::IsNotATrait(&path_names_to_string(trait_path, path_depth),\n+                                             path_res.base_def.kind_name())\n             });\n+            if let Some(generics) = generics {\n+                if let Some(span) = generics.span_for_name(\n+                    &path_names_to_string(trait_path, path_depth)) {\n+\n+                    err.span_label(span, &\"type parameter defined here\");\n+                }\n+            }\n \n             // If it's a typedef, give a note\n             if let Def::TyAlias(..) = path_res.base_def {\n@@ -1946,15 +1964,20 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n+    fn with_optional_trait_ref<T, F>(&mut self,\n+                                     opt_trait_ref: Option<&TraitRef>,\n+                                     f: F,\n+                                     generics: Option<&Generics>)\n+        -> T\n         where F: FnOnce(&mut Resolver, Option<DefId>) -> T\n     {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n             if let Ok(path_res) = self.resolve_trait_reference(trait_ref.ref_id,\n                                                                &trait_ref.path,\n-                                                               0) {\n+                                                               0,\n+                                                               generics) {\n                 assert!(path_res.depth == 0);\n                 self.record_def(trait_ref.ref_id, path_res);\n                 new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n@@ -2042,7 +2065,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     });\n                 });\n-            });\n+            }, Some(&generics));\n         });\n     }\n \n@@ -2067,15 +2090,15 @@ impl<'a> Resolver<'a> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FnvHashMap());\n+        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FxHashMap());\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n     // this is done hygienically. This could arise for a macro\n     // that expands into an or-pattern where one 'x' was from the\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n-        let mut binding_map = FnvHashMap();\n+        let mut binding_map = FxHashMap();\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n@@ -2135,7 +2158,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_arm(&mut self, arm: &Arm) {\n         self.value_ribs.push(Rib::new(NormalRibKind));\n \n-        let mut bindings_list = FnvHashMap();\n+        let mut bindings_list = FxHashMap();\n         for pattern in &arm.pats {\n             self.resolve_pattern(&pattern, PatternSource::Match, &mut bindings_list);\n         }\n@@ -2276,7 +2299,7 @@ impl<'a> Resolver<'a> {\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n-                     bindings: &mut FnvHashMap<Ident, NodeId>)\n+                     bindings: &mut FxHashMap<Ident, NodeId>)\n                      -> PathResolution {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n@@ -2389,7 +2412,7 @@ impl<'a> Resolver<'a> {\n                        pat_src: PatternSource,\n                        // Maps idents to the node ID for the\n                        // outermost pattern that binds them.\n-                       bindings: &mut FnvHashMap<Ident, NodeId>) {\n+                       bindings: &mut FxHashMap<Ident, NodeId>) {\n         // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n@@ -2492,7 +2515,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 max_assoc_types = path.segments.len() - qself.position;\n                 // Make sure the trait is valid.\n-                let _ = self.resolve_trait_reference(id, path, max_assoc_types);\n+                let _ = self.resolve_trait_reference(id, path, max_assoc_types, None);\n             }\n             None => {\n                 max_assoc_types = path.segments.len();\n@@ -3046,7 +3069,7 @@ impl<'a> Resolver<'a> {\n                 self.visit_expr(subexpression);\n \n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::IfLet, &mut FnvHashMap());\n+                self.resolve_pattern(pattern, PatternSource::IfLet, &mut FxHashMap());\n                 self.visit_block(if_block);\n                 self.value_ribs.pop();\n \n@@ -3063,7 +3086,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FnvHashMap());\n+                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n@@ -3073,7 +3096,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::For, &mut FnvHashMap());\n+                self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n@@ -3216,7 +3239,7 @@ impl<'a> Resolver<'a> {\n             in_module.for_each_child(|name, ns, name_binding| {\n \n                 // avoid imports entirely\n-                if name_binding.is_import() { return; }\n+                if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n \n                 // collect results based on the filter function\n                 if name == lookup_name && ns == namespace {\n@@ -3252,21 +3275,11 @@ impl<'a> Resolver<'a> {\n                 // collect submodules to explore\n                 if let Ok(module) = name_binding.module() {\n                     // form the path\n-                    let path_segments = match module.kind {\n-                        _ if module.parent.is_none() => path_segments.clone(),\n-                        ModuleKind::Def(_, name) => {\n-                            let mut paths = path_segments.clone();\n-                            let ident = Ident::with_empty_ctxt(name);\n-                            let params = PathParameters::none();\n-                            let segm = PathSegment {\n-                                identifier: ident,\n-                                parameters: params,\n-                            };\n-                            paths.push(segm);\n-                            paths\n-                        }\n-                        _ => bug!(),\n-                    };\n+                    let mut path_segments = path_segments.clone();\n+                    path_segments.push(PathSegment {\n+                        identifier: Ident::with_empty_ctxt(name),\n+                        parameters: PathParameters::none(),\n+                    });\n \n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n@@ -3335,7 +3348,7 @@ impl<'a> Resolver<'a> {\n \n     fn report_errors(&mut self) {\n         self.report_shadowing_errors();\n-        let mut reported_spans = FnvHashSet();\n+        let mut reported_spans = FxHashSet();\n \n         for &AmbiguityError { span, name, b1, b2 } in &self.ambiguity_errors {\n             if !reported_spans.insert(span) { continue }\n@@ -3352,7 +3365,10 @@ impl<'a> Resolver<'a> {\n             if !reported_spans.insert(span) { continue }\n             if binding.is_extern_crate() {\n                 // Warn when using an inaccessible extern crate.\n-                let node_id = binding.module().unwrap().extern_crate_id.unwrap();\n+                let node_id = match binding.kind {\n+                    NameBindingKind::Import { directive, .. } => directive.id,\n+                    _ => unreachable!(),\n+                };\n                 let msg = format!(\"extern crate `{}` is private\", name);\n                 self.session.add_lint(lint::builtin::INACCESSIBLE_EXTERN_CRATE, node_id, span, msg);\n             } else {\n@@ -3363,12 +3379,16 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn report_shadowing_errors(&mut self) {\n-        let mut reported_errors = FnvHashSet();\n-        for (name, span, scope) in replace(&mut self.disallowed_shadowing, Vec::new()) {\n-            if self.resolve_macro_name(scope, name, false).is_some() &&\n-               reported_errors.insert((name, span)) {\n-                let msg = format!(\"`{}` is already in scope\", name);\n-                self.session.struct_span_err(span, &msg)\n+        for (name, scope) in replace(&mut self.lexical_macro_resolutions, Vec::new()) {\n+            self.resolve_macro_name(scope, name);\n+        }\n+\n+        let mut reported_errors = FxHashSet();\n+        for binding in replace(&mut self.disallowed_shadowing, Vec::new()) {\n+            if self.resolve_macro_name(binding.parent, binding.name).is_some() &&\n+               reported_errors.insert((binding.name, binding.span)) {\n+                let msg = format!(\"`{}` is already in scope\", binding.name);\n+                self.session.struct_span_err(binding.span, &msg)\n                     .note(\"macro-expanded `macro_rules!`s may not shadow \\\n                            existing macros (see RFC 1560)\")\n                     .emit();\n@@ -3394,7 +3414,7 @@ impl<'a> Resolver<'a> {\n             _ => \"enum\",\n         };\n \n-        let (participle, noun) = match old_binding.is_import() || old_binding.is_extern_crate() {\n+        let (participle, noun) = match old_binding.is_import() {\n             true => (\"imported\", \"import\"),\n             false => (\"defined\", \"definition\"),\n         };\n@@ -3403,7 +3423,8 @@ impl<'a> Resolver<'a> {\n         let msg = {\n             let kind = match (ns, old_binding.module()) {\n                 (ValueNS, _) => \"a value\",\n-                (TypeNS, Ok(module)) if module.extern_crate_id.is_some() => \"an extern crate\",\n+                (MacroNS, _) => \"a macro\",\n+                (TypeNS, _) if old_binding.is_extern_crate() => \"an extern crate\",\n                 (TypeNS, Ok(module)) if module.is_normal() => \"a module\",\n                 (TypeNS, Ok(module)) if module.is_trait() => \"a trait\",\n                 (TypeNS, _) => \"a type\",\n@@ -3418,7 +3439,7 @@ impl<'a> Resolver<'a> {\n                 e.span_label(span, &format!(\"`{}` was already imported\", name));\n                 e\n             },\n-            (true, _) | (_, true) if binding.is_import() || old_binding.is_import() => {\n+            (true, _) | (_, true) if binding.is_import() && old_binding.is_import() => {\n                 let mut e = struct_span_err!(self.session, span, E0254, \"{}\", msg);\n                 e.span_label(span, &\"already imported\");\n                 e"}, {"sha": "f30c129c48fd21c0ab6fb8d19b6177992150a415", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 63, "deletions": 15, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {Module, Resolver};\n+use {Module, ModuleKind, Resolver};\n use build_reduced_graph::BuildReducedGraphVisitor;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n+use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex};\n+use rustc::hir::def::{Def, Export};\n use rustc::hir::map::{self, DefCollector};\n use std::cell::Cell;\n use std::rc::Rc;\n@@ -21,8 +22,11 @@ use syntax::ext::base::{NormalTT, SyntaxExtension};\n use syntax::ext::expand::Expansion;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n+use syntax::fold::Folder;\n use syntax::parse::token::intern;\n+use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::visit::Visitor;\n use syntax_pos::Span;\n \n #[derive(Clone)]\n@@ -73,10 +77,10 @@ impl<'a> LegacyScope<'a> {\n }\n \n pub struct LegacyBinding<'a> {\n-    parent: LegacyScope<'a>,\n-    name: ast::Name,\n+    pub parent: LegacyScope<'a>,\n+    pub name: ast::Name,\n     ext: Rc<SyntaxExtension>,\n-    span: Span,\n+    pub span: Span,\n }\n \n impl<'a> base::Resolver for Resolver<'a> {\n@@ -97,6 +101,31 @@ impl<'a> base::Resolver for Resolver<'a> {\n         mark\n     }\n \n+    fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> {\n+        struct EliminateCrateVar<'b, 'a: 'b>(&'b mut Resolver<'a>);\n+\n+        impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n+            fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n+                let ident = path.segments[0].identifier;\n+                if &ident.name.as_str() == \"$crate\" {\n+                    path.global = true;\n+                    let module = self.0.resolve_crate_var(ident.ctxt);\n+                    if module.is_local() {\n+                        path.segments.remove(0);\n+                    } else {\n+                        path.segments[0].identifier = match module.kind {\n+                            ModuleKind::Def(_, name) => ast::Ident::with_empty_ctxt(name),\n+                            _ => unreachable!(),\n+                        };\n+                    }\n+                }\n+                path\n+            }\n+        }\n+\n+        EliminateCrateVar(self).fold_item(item).expect_one(\"\")\n+    }\n+\n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n         let invocation = self.invocations[&mark];\n         self.collect_def_ids(invocation, expansion);\n@@ -128,6 +157,13 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         if export {\n             def.id = self.next_node_id();\n+            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n+                collector.visit_macro_def(&def)\n+            });\n+            self.macro_exports.push(Export {\n+                name: def.ident.name,\n+                def: Def::Macro(self.definitions.local_def_id(def.id)),\n+            });\n             self.exported_macros.push(def);\n         }\n     }\n@@ -136,7 +172,12 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n         }\n-        self.builtin_macros.insert(ident.name, ext);\n+        let def_id = DefId {\n+            krate: BUILTIN_MACROS_CRATE,\n+            index: DefIndex::new(self.macro_map.len()),\n+        };\n+        self.macro_map.insert(def_id, ext);\n+        self.builtin_macros.insert(ident.name, def_id);\n     }\n \n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n@@ -147,7 +188,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n             match self.builtin_macros.get(&name) {\n-                Some(ext) => match **ext {\n+                Some(&def_id) => match *self.get_macro(Def::Macro(def_id)) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n                     }\n@@ -171,7 +212,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let LegacyScope::Expansion(parent) = invocation.legacy_scope.get() {\n             invocation.legacy_scope.set(LegacyScope::simplify_expansion(parent));\n         }\n-        self.resolve_macro_name(invocation.legacy_scope.get(), name, true).ok_or_else(|| {\n+        self.resolve_macro_name(invocation.legacy_scope.get(), name).ok_or_else(|| {\n             if force {\n                 let msg = format!(\"macro undefined: '{}!'\", name);\n                 let mut err = self.session.struct_span_err(path.span, &msg);\n@@ -186,17 +227,18 @@ impl<'a> base::Resolver for Resolver<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn resolve_macro_name(&mut self,\n-                              mut scope: LegacyScope<'a>,\n-                              name: ast::Name,\n-                              record_used: bool)\n+    pub fn resolve_macro_name(&mut self, mut scope: LegacyScope<'a>, name: ast::Name)\n                               -> Option<Rc<SyntaxExtension>> {\n+        let mut possible_time_travel = None;\n         let mut relative_depth: u32 = 0;\n         loop {\n             scope = match scope {\n                 LegacyScope::Empty => break,\n                 LegacyScope::Expansion(invocation) => {\n                     if let LegacyScope::Empty = invocation.expansion.get() {\n+                        if possible_time_travel.is_none() {\n+                            possible_time_travel = Some(scope);\n+                        }\n                         invocation.legacy_scope.get()\n                     } else {\n                         relative_depth += 1;\n@@ -209,8 +251,11 @@ impl<'a> Resolver<'a> {\n                 }\n                 LegacyScope::Binding(binding) => {\n                     if binding.name == name {\n-                        if record_used && relative_depth > 0 {\n-                            self.disallowed_shadowing.push((name, binding.span, binding.parent));\n+                        if let Some(scope) = possible_time_travel {\n+                            // Check for disallowed shadowing later\n+                            self.lexical_macro_resolutions.push((name, scope));\n+                        } else if relative_depth > 0 {\n+                            self.disallowed_shadowing.push(binding);\n                         }\n                         return Some(binding.ext.clone());\n                     }\n@@ -219,7 +264,10 @@ impl<'a> Resolver<'a> {\n             };\n         }\n \n-        self.builtin_macros.get(&name).cloned()\n+        if let Some(scope) = possible_time_travel {\n+            self.lexical_macro_resolutions.push((name, scope));\n+        }\n+        self.builtin_macros.get(&name).cloned().map(|def_id| self.get_macro(Def::Macro(def_id)))\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {"}, {"sha": "5d66caec31b3ed9958883f7ce3bf67eaaf741295", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -30,6 +30,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n+use std::mem;\n \n impl<'a> Resolver<'a> {\n     pub fn resolve_imports(&mut self) {\n@@ -51,6 +52,7 @@ pub enum ImportDirectiveSubclass<'a> {\n         max_vis: Cell<ty::Visibility>, // The visibility of the greatest reexport.\n         // n.b. `max_vis` is only used in `finalize_import` to check for reexport errors.\n     },\n+    ExternCrate,\n }\n \n impl<'a> ImportDirectiveSubclass<'a> {\n@@ -68,12 +70,12 @@ impl<'a> ImportDirectiveSubclass<'a> {\n #[derive(Debug,Clone)]\n pub struct ImportDirective<'a> {\n     pub id: NodeId,\n-    parent: Module<'a>,\n-    module_path: Vec<Ident>,\n-    imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n-    subclass: ImportDirectiveSubclass<'a>,\n-    span: Span,\n-    vis: Cell<ty::Visibility>,\n+    pub parent: Module<'a>,\n+    pub module_path: Vec<Ident>,\n+    pub imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n+    pub subclass: ImportDirectiveSubclass<'a>,\n+    pub span: Span,\n+    pub vis: Cell<ty::Visibility>,\n }\n \n impl<'a> ImportDirective<'a> {\n@@ -169,7 +171,8 @@ impl<'a> Resolver<'a> {\n         let new_import_semantics = self.new_import_semantics;\n         let is_disallowed_private_import = |binding: &NameBinding| {\n             !new_import_semantics && !allow_private_imports && // disallowed\n-            binding.vis != ty::Visibility::Public && binding.is_import() // non-`pub` import\n+            binding.vis != ty::Visibility::Public && binding.is_import() && // non-`pub` import\n+            !binding.is_extern_crate() // not an `extern crate`\n         };\n \n         if let Some(span) = record_used {\n@@ -237,7 +240,7 @@ impl<'a> Resolver<'a> {\n                 };\n                 let name = match directive.subclass {\n                     SingleImport { source, .. } => source,\n-                    GlobImport { .. } => unreachable!(),\n+                    _ => unreachable!(),\n                 };\n                 match self.resolve_name_in_module(module, name, ns, true, None) {\n                     Failed(_) => {}\n@@ -280,13 +283,14 @@ impl<'a> Resolver<'a> {\n             // which are not relevant to import resolution.\n             GlobImport { is_prelude: true, .. } => {}\n             GlobImport { .. } => self.current_module.globs.borrow_mut().push(directive),\n+            _ => unreachable!(),\n         }\n     }\n \n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n-    fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n-              -> NameBinding<'a> {\n+    pub fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n+                  -> NameBinding<'a> {\n         let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n                      !directive.is_glob() && binding.is_extern_crate() { // c.f. `PRIVATE_IN_PUBLIC`\n             directive.vis.get()\n@@ -529,6 +533,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 self.resolve_glob_import(directive);\n                 return Success(());\n             }\n+            _ => unreachable!(),\n         };\n \n         let mut indeterminate = false;\n@@ -616,6 +621,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 }\n                 return Success(());\n             }\n+            _ => unreachable!(),\n         };\n \n         for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n@@ -767,6 +773,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         *module.globs.borrow_mut() = Vec::new();\n \n         let mut reexports = Vec::new();\n+        if module as *const _ == self.graph_root as *const _ {\n+            reexports = mem::replace(&mut self.macro_exports, Vec::new());\n+        }\n+\n         for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n             let resolution = resolution.borrow();\n             let binding = match resolution.binding {\n@@ -831,5 +841,6 @@ fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass) -> St\n     match *subclass {\n         SingleImport { source, .. } => source.to_string(),\n         GlobImport { .. } => \"*\".to_string(),\n+        ExternCrate => \"<extern crate>\".to_string(),\n     }\n }"}, {"sha": "e83c2359979c057466fec319fcdd533094343eb3", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -32,7 +32,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::map::{Node, NodeItem};\n use rustc::session::Session;\n-use rustc::ty::{self, TyCtxt, ImplOrTraitItem, ImplOrTraitItemContainer};\n+use rustc::ty::{self, TyCtxt, AssociatedItemContainer};\n \n use std::collections::HashSet;\n use std::collections::hash_map::DefaultHasher;\n@@ -341,6 +341,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Def::AssociatedTy(..) |\n             Def::AssociatedConst(..) |\n             Def::PrimTy(_) |\n+            Def::Macro(_) |\n             Def::Err => {\n                span_bug!(span,\n                          \"process_def_kind for unexpected item: {:?}\",\n@@ -356,7 +357,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, ..) in &collector.collected_paths {\n-                let typ = self.tcx.node_types().get(&id).unwrap().to_string();\n+                let typ = self.tcx.tables().node_types.get(&id).unwrap().to_string();\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 let sub_span = span_utils.span_for_last_ident(p.span);\n@@ -402,19 +403,19 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             // with the right name.\n             if !self.span.filter_generated(Some(method_data.span), span) {\n                 let container =\n-                    self.tcx.impl_or_trait_item(self.tcx.map.local_def_id(id)).container();\n+                    self.tcx.associated_item(self.tcx.map.local_def_id(id)).container;\n                 let mut trait_id;\n                 let mut decl_id = None;\n                 match container {\n-                    ImplOrTraitItemContainer::ImplContainer(id) => {\n+                    AssociatedItemContainer::ImplContainer(id) => {\n                         trait_id = self.tcx.trait_id_of_impl(id);\n \n                         match trait_id {\n                             Some(id) => {\n-                                for item in &**self.tcx.trait_items(id) {\n-                                    if let &ImplOrTraitItem::MethodTraitItem(ref m) = item {\n-                                        if m.name == name {\n-                                            decl_id = Some(m.def_id);\n+                                for item in self.tcx.associated_items(id) {\n+                                    if item.kind == ty::AssociatedKind::Method {\n+                                        if item.name == name {\n+                                            decl_id = Some(item.def_id);\n                                             break;\n                                         }\n                                     }\n@@ -429,7 +430,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             }\n                         }\n                     }\n-                    ImplOrTraitItemContainer::TraitContainer(id) => {\n+                    AssociatedItemContainer::TraitContainer(id) => {\n                         trait_id = Some(id);\n                     }\n                 }\n@@ -916,11 +917,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         // Modules or types in the path prefix.\n         match self.tcx.expect_def(id) {\n             Def::Method(did) => {\n-                let ti = self.tcx.impl_or_trait_item(did);\n-                if let ty::MethodTraitItem(m) = ti {\n-                    if m.explicit_self == ty::ExplicitSelfCategory::Static {\n-                        self.write_sub_path_trait_truncated(path);\n-                    }\n+                let ti = self.tcx.associated_item(did);\n+                if ti.kind == ty::AssociatedKind::Method && ti.method_has_self_argument {\n+                    self.write_sub_path_trait_truncated(path);\n                 }\n             }\n             Def::Fn(..) |\n@@ -988,7 +987,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         match p.node {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n-                let adt = self.tcx.node_id_to_type(p.id).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().node_id_to_type(p.id).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(p.id));\n \n                 for &Spanned { node: ref field, span } in fields {\n@@ -1023,8 +1022,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n             };\n-            let types = self.tcx.node_types();\n-            let typ = match types.get(&id) {\n+            let typ = match self.tcx.tables().node_types.get(&id) {\n                 Some(typ) => {\n                     let typ = typ.to_string();\n                     if !value.is_empty() {\n@@ -1355,7 +1353,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n             }\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.map.expect_expr(ex.id);\n-                let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n+                let adt = self.tcx.tables().expr_ty(&hir_expr).ty_adt_def().unwrap();\n                 let def = self.tcx.expect_def(hir_expr.id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n@@ -1381,7 +1379,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                         return;\n                     }\n                 };\n-                let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n+                let ty = &self.tcx.tables().expr_ty_adjusted(&hir_node).sty;\n                 match *ty {\n                     ty::TyAdt(def, _) => {\n                         let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n@@ -1415,7 +1413,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                 }\n \n                 // walk the body\n-                self.nest(ex.id, |v| v.visit_block(&body));\n+                self.nest(ex.id, |v| v.visit_expr(body));\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n             ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {\n@@ -1468,7 +1466,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n-                    let typ = self.tcx.node_types()\n+                    let typ = self.tcx.tables().node_types\n                                   .get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n                     value.push_str(\": \");\n                     value.push_str(&typ);"}, {"sha": "ab5bbea07a301582999a7fc9847f34781c6e77b6", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 27, "deletions": 49, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -18,7 +18,7 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(custom_attribute)]\n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![allow(unused_attributes)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -286,7 +286,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                           scope: NodeId) -> Option<VariableData> {\n         if let Some(ident) = field.ident {\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n-            let typ = self.tcx.node_types().get(&field.id).unwrap().to_string();\n+            let typ = self.tcx.tables().node_types.get(&field.id).unwrap().to_string();\n             let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n             filter!(self.span_utils, sub_span, field.span, None);\n             Some(VariableData {\n@@ -313,7 +313,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                            name: ast::Name, span: Span) -> Option<FunctionData> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let (qualname, parent_scope, vis, docs) =\n+        let (qualname, parent_scope, decl_id, vis, docs) =\n           match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n             Some(impl_id) => match self.tcx.map.get_if_local(impl_id) {\n                 Some(NodeItem(item)) => {\n@@ -323,12 +323,19 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             result.push_str(&rustc::hir::print::ty_to_string(&ty));\n \n                             let trait_id = self.tcx.trait_id_of_impl(impl_id);\n+                            let mut decl_id = None;\n                             if let Some(def_id) = trait_id {\n                                 result.push_str(\" as \");\n                                 result.push_str(&self.tcx.item_path_str(def_id));\n+                                self.tcx.associated_items(def_id)\n+                                    .find(|item| item.name == name)\n+                                    .map(|item| decl_id = Some(item.def_id));\n                             }\n                             result.push_str(\">\");\n-                            (result, trait_id, From::from(&item.vis), docs_for_attrs(&item.attrs))\n+\n+                            (result, trait_id, decl_id,\n+                             From::from(&item.vis),\n+                             docs_for_attrs(&item.attrs))\n                         }\n                         _ => {\n                             span_bug!(span,\n@@ -351,7 +358,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     match self.tcx.map.get_if_local(def_id) {\n                         Some(NodeItem(item)) => {\n                             (format!(\"::{}\", self.tcx.item_path_str(def_id)),\n-                             Some(def_id),\n+                             Some(def_id), None,\n                              From::from(&item.vis),\n                              docs_for_attrs(&item.attrs))\n                         }\n@@ -373,15 +380,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         let qualname = format!(\"{}::{}\", qualname, name);\n \n-        let def_id = self.tcx.map.local_def_id(id);\n-        let decl_id = self.tcx.trait_item_of_item(def_id).and_then(|new_def_id| {\n-            if new_def_id != def_id {\n-                Some(new_def_id)\n-            } else {\n-                None\n-            }\n-        });\n-\n         let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n         filter!(self.span_utils, sub_span, span, None);\n         Some(FunctionData {\n@@ -418,7 +416,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         let hir_node = self.tcx.map.expect_expr(expr.id);\n-        let ty = self.tcx.expr_ty_adjusted_opt(&hir_node);\n+        let ty = self.tcx.tables().expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().sty == ty::TyError {\n             return None;\n         }\n@@ -432,7 +430,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         return None;\n                     }\n                 };\n-                match self.tcx.expr_ty_adjusted(&hir_node).sty {\n+                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -451,7 +449,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::Struct(ref path, ..) => {\n-                match self.tcx.expr_ty_adjusted(&hir_node).sty {\n+                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);\n@@ -472,8 +470,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ExprKind::MethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n-                let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n+                let method_id = self.tcx.tables().method_map[&method_call].def_id;\n+                let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n                 };\n@@ -535,21 +533,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n                 filter!(self.span_utils, sub_span, path.span, None);\n                 let def_id = if decl_id.is_local() {\n-                    let ti = self.tcx.impl_or_trait_item(decl_id);\n-                    match ti.container() {\n-                        ty::TraitContainer(def_id) => {\n-                            self.tcx\n-                                .trait_items(def_id)\n-                                .iter()\n-                                .find(|mr| mr.name() == ti.name() && self.trait_method_has_body(mr))\n-                                .map(|mr| mr.def_id())\n-                        }\n-                        ty::ImplContainer(def_id) => {\n-                            Some(*self.tcx.impl_or_trait_items(def_id).iter().find(|&&mr| {\n-                                self.tcx.impl_or_trait_item(mr).name() == ti.name()\n-                            }).unwrap())\n-                        }\n-                    }\n+                    let ti = self.tcx.associated_item(decl_id);\n+                    self.tcx.associated_items(ti.container.id())\n+                        .find(|item| item.name == ti.name && item.has_value)\n+                        .map(|item| item.def_id)\n                 } else {\n                     None\n                 };\n@@ -578,24 +565,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Def::PrimTy(..) |\n             Def::SelfTy(..) |\n             Def::Label(..) |\n+            Def::Macro(..) |\n             Def::Err => None,\n         }\n     }\n \n-    fn trait_method_has_body(&self, mr: &ty::ImplOrTraitItem) -> bool {\n-        let def_id = mr.def_id();\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-            let trait_item = self.tcx.map.expect_trait_item(node_id);\n-            if let hir::TraitItem_::MethodTraitItem(_, Some(_)) = trait_item.node {\n-                true\n-            } else {\n-                false\n-            }\n-        } else {\n-            false\n-        }\n-    }\n-\n     pub fn get_field_ref_data(&self,\n                               field_ref: &ast::Field,\n                               variant: ty::VariantDef,\n@@ -759,7 +733,11 @@ fn docs_for_attrs(attrs: &[Attribute]) -> String {\n     for attr in attrs {\n         if attr.name() == doc {\n             if let Some(ref val) = attr.value_str() {\n-                result.push_str(&strip_doc_comment_decoration(val));\n+                if attr.node.is_sugared_doc {\n+                    result.push_str(&strip_doc_comment_decoration(val));\n+                } else {\n+                    result.push_str(val);\n+                }\n                 result.push('\\n');\n             }\n         }"}, {"sha": "ad8e0c1ee59f6dac0ce2f2edb7b72245733f0654", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -636,7 +636,7 @@ fn link_natively(sess: &Session,\n     {\n         let mut linker = trans.linker_info.to_linker(&mut cmd, &sess);\n         link_args(&mut *linker, sess, crate_type, tmpdir,\n-                  objects, out_filename, outputs);\n+                  objects, out_filename, outputs, trans);\n     }\n     cmd.args(&sess.target.target.options.late_link_args);\n     for obj in &sess.target.target.options.post_link_objects {\n@@ -711,7 +711,8 @@ fn link_args(cmd: &mut Linker,\n              tmpdir: &Path,\n              objects: &[PathBuf],\n              out_filename: &Path,\n-             outputs: &OutputFilenames) {\n+             outputs: &OutputFilenames,\n+             trans: &CrateTranslation) {\n \n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n@@ -726,6 +727,13 @@ fn link_args(cmd: &mut Linker,\n     }\n     cmd.output_filename(out_filename);\n \n+    if crate_type == config::CrateTypeExecutable &&\n+       sess.target.target.options.is_like_windows {\n+        if let Some(ref s) = trans.windows_subsystem {\n+            cmd.subsystem(s);\n+        }\n+    }\n+\n     // If we're building a dynamic library then some platforms need to make sure\n     // that all symbols are exported correctly from the dynamic library.\n     if crate_type != config::CrateTypeExecutable {"}, {"sha": "860903d259fe5394128256821f237a13199f31af", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -92,6 +92,7 @@ pub trait Linker {\n     fn whole_archives(&mut self);\n     fn no_whole_archives(&mut self);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n+    fn subsystem(&mut self, subsystem: &str);\n }\n \n pub struct GnuLinker<'a> {\n@@ -294,6 +295,10 @@ impl<'a> Linker for GnuLinker<'a> {\n \n         self.cmd.arg(arg);\n     }\n+\n+    fn subsystem(&mut self, subsystem: &str) {\n+        self.cmd.arg(&format!(\"-Wl,--subsystem,{}\", subsystem));\n+    }\n }\n \n pub struct MsvcLinker<'a> {\n@@ -441,6 +446,30 @@ impl<'a> Linker for MsvcLinker<'a> {\n         arg.push(path);\n         self.cmd.arg(&arg);\n     }\n+\n+    fn subsystem(&mut self, subsystem: &str) {\n+        // Note that previous passes of the compiler validated this subsystem,\n+        // so we just blindly pass it to the linker.\n+        self.cmd.arg(&format!(\"/SUBSYSTEM:{}\", subsystem));\n+\n+        // Windows has two subsystems we're interested in right now, the console\n+        // and windows subsystems. These both implicitly have different entry\n+        // points (starting symbols). The console entry point starts with\n+        // `mainCRTStartup` and the windows entry point starts with\n+        // `WinMainCRTStartup`. These entry points, defined in system libraries,\n+        // will then later probe for either `main` or `WinMain`, respectively to\n+        // start the application.\n+        //\n+        // In Rust we just always generate a `main` function so we want control\n+        // to always start there, so we force the entry point on the windows\n+        // subsystem to be `mainCRTStartup` to get everything booted up\n+        // correctly.\n+        //\n+        // For more information see RFC #1665\n+        if subsystem == \"windows\" {\n+            self.cmd.arg(\"/ENTRY:mainCRTStartup\");\n+        }\n+    }\n }\n \n fn exported_symbols(scx: &SharedCrateContext,"}, {"sha": "d50669272f726bf0be560f5839cd2975d54b7097", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -79,7 +79,7 @@ use type_::Type;\n use type_of;\n use value::Value;\n use Disr;\n-use util::nodemap::{NodeSet, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n \n use arena::TypedArena;\n use libc::c_uint;\n@@ -1196,6 +1196,9 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         }\n         let llfn = declare::declare_cfn(ccx, \"main\", llfty);\n \n+        // `main` should respect same config for frame pointer elimination as rest of code\n+        attributes::set_frame_pointer_elimination(ccx, llfn);\n+\n         let llbb = unsafe {\n             llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, \"top\\0\".as_ptr() as *const _)\n         };\n@@ -1315,7 +1318,7 @@ fn write_metadata(cx: &SharedCrateContext,\n fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                                  ccxs: &CrateContextList<'a, 'tcx>,\n                                  symbol_map: &SymbolMap<'tcx>,\n-                                 reachable: &FnvHashSet<&str>) {\n+                                 reachable: &FxHashSet<&str>) {\n     let scx = ccxs.shared();\n     let tcx = scx.tcx();\n \n@@ -1329,7 +1332,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n     // 'unsafe' because we are holding on to CStr's from the LLVM module within\n     // this block.\n     unsafe {\n-        let mut referenced_somewhere = FnvHashSet();\n+        let mut referenced_somewhere = FxHashSet();\n \n         // Collect all symbols that need to stay externally visible because they\n         // are referenced via a declaration in some other codegen unit.\n@@ -1350,7 +1353,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n \n         // Also collect all symbols for which we cannot adjust linkage, because\n         // it is fixed by some directive in the source code (e.g. #[no_mangle]).\n-        let linkage_fixed_explicitly: FnvHashSet<_> = scx\n+        let linkage_fixed_explicitly: FxHashSet<_> = scx\n             .translation_items()\n             .borrow()\n             .iter()\n@@ -1611,7 +1614,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             metadata: metadata,\n             reachable: vec![],\n             no_builtins: no_builtins,\n-            linker_info: linker_info\n+            linker_info: linker_info,\n+            windows_subsystem: None,\n         };\n     }\n \n@@ -1747,14 +1751,26 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let linker_info = LinkerInfo::new(&shared_ccx, &reachable_symbols);\n \n+    let subsystem = attr::first_attr_value_str_by_name(&krate.attrs,\n+                                                       \"windows_subsystem\");\n+    let windows_subsystem = subsystem.map(|subsystem| {\n+        if subsystem != \"windows\" && subsystem != \"console\" {\n+            tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n+                                     `windows` and `console` are allowed\",\n+                                    subsystem));\n+        }\n+        subsystem.to_string()\n+    });\n+\n     CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,\n         link: link_meta,\n         metadata: metadata,\n         reachable: reachable_symbols,\n         no_builtins: no_builtins,\n-        linker_info: linker_info\n+        linker_info: linker_info,\n+        windows_subsystem: windows_subsystem,\n     }\n }\n \n@@ -1846,7 +1862,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n     }\n \n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n-        let mut item_to_cgus = FnvHashMap();\n+        let mut item_to_cgus = FxHashMap();\n \n         for cgu in &codegen_units {\n             for (&trans_item, &linkage) in cgu.items() {"}, {"sha": "0480bb82a998e902396d78f98b282d1f0ec00875", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -19,7 +19,7 @@ use common::*;\n use machine::llalign_of_pref;\n use type_::Type;\n use value::Value;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use libc::{c_uint, c_char};\n \n use std::borrow::Cow;\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Build version of path with cycles removed.\n \n                 // Pass 1: scan table mapping str -> rightmost pos.\n-                let mut mm = FnvHashMap();\n+                let mut mm = FxHashMap();\n                 let len = v.len();\n                 let mut i = 0;\n                 while i < len {"}, {"sha": "ffb13a833a582543e615fe7dba8e971f289e3590", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> Callee<'tcx> {\n     pub fn method_call<'blk>(bcx: Block<'blk, 'tcx>,\n                              method_call: ty::MethodCall)\n                              -> Callee<'tcx> {\n-        let method = bcx.tcx().tables.borrow().method_map[&method_call];\n+        let method = bcx.tcx().tables().method_map[&method_call];\n         Callee::method(bcx, method)\n     }\n "}, {"sha": "2c0ba36f3b412fd4c7cbbcf1e1d0bc73936320c7", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -211,7 +211,7 @@ use context::SharedCrateContext;\n use common::{fulfill_obligation, type_is_sized};\n use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n-use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n+use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n use trans_item::{TransItem, type_to_string, def_id_to_string};\n \n@@ -228,15 +228,15 @@ pub struct InliningMap<'tcx> {\n     // that are potentially inlined by LLVM into the source.\n     // The two numbers in the tuple are the start (inclusive) and\n     // end index (exclusive) within the `targets` vecs.\n-    index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n+    index: FxHashMap<TransItem<'tcx>, (usize, usize)>,\n     targets: Vec<TransItem<'tcx>>,\n }\n \n impl<'tcx> InliningMap<'tcx> {\n \n     fn new() -> InliningMap<'tcx> {\n         InliningMap {\n-            index: FnvHashMap(),\n+            index: FxHashMap(),\n             targets: Vec::new(),\n         }\n     }\n@@ -269,15 +269,15 @@ impl<'tcx> InliningMap<'tcx> {\n \n pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n-                                                 -> (FnvHashSet<TransItem<'tcx>>,\n+                                                 -> (FxHashSet<TransItem<'tcx>>,\n                                                      InliningMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n     scx.tcx().dep_graph.with_ignore(|| {\n         let roots = collect_roots(scx, mode);\n \n         debug!(\"Building translation item graph, beginning at roots\");\n-        let mut visited = FnvHashSet();\n+        let mut visited = FxHashSet();\n         let mut recursion_depths = DefIdMap();\n         let mut inlining_map = InliningMap::new();\n \n@@ -318,7 +318,7 @@ fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n // Collect all monomorphized translation items reachable from `starting_point`\n fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n-                                   visited: &mut FnvHashSet<TransItem<'tcx>>,\n+                                   visited: &mut FxHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n                                    inlining_map: &mut InliningMap<'tcx>) {\n     if !visited.insert(starting_point.clone()) {\n@@ -844,17 +844,12 @@ fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n            param_substs);\n \n     if let Some(trait_def_id) = scx.tcx().trait_of_item(fn_def_id) {\n-        match scx.tcx().impl_or_trait_item(fn_def_id) {\n-            ty::MethodTraitItem(ref method) => {\n-                debug!(\" => trait method, attempting to find impl\");\n-                do_static_trait_method_dispatch(scx,\n-                                                method,\n-                                                trait_def_id,\n-                                                fn_substs,\n-                                                param_substs)\n-            }\n-            _ => bug!()\n-        }\n+        debug!(\" => trait method, attempting to find impl\");\n+        do_static_trait_method_dispatch(scx,\n+                                        &scx.tcx().associated_item(fn_def_id),\n+                                        trait_def_id,\n+                                        fn_substs,\n+                                        param_substs)\n     } else {\n         debug!(\" => regular function\");\n         // The function is not part of an impl or trait, no dispatching\n@@ -866,7 +861,7 @@ fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n // Given a trait-method and substitution information, find out the actual\n // implementation of the trait method.\n fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                             trait_method: &ty::Method,\n+                                             trait_method: &ty::AssociatedItem,\n                                              trait_id: DefId,\n                                              callee_substs: &'tcx Substs<'tcx>,\n                                              param_substs: &'tcx Substs<'tcx>)\n@@ -1082,10 +1077,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n-                    let ty = {\n-                        let tables = self.scx.tcx().tables.borrow();\n-                        tables.node_types[&item.id]\n-                    };\n+                    let ty = self.scx.tcx().tables().node_types[&item.id];\n \n                     if self.mode == TransItemCollectionMode::Eager {\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n@@ -1182,15 +1174,15 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let callee_substs = tcx.erase_regions(&trait_ref.substs);\n-                let overridden_methods: FnvHashSet<_> = items.iter()\n-                                                             .map(|item| item.name)\n-                                                             .collect();\n+                let overridden_methods: FxHashSet<_> = items.iter()\n+                                                            .map(|item| item.name)\n+                                                            .collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n                     if overridden_methods.contains(&method.name) {\n                         continue;\n                     }\n \n-                    if !method.generics.types.is_empty() {\n+                    if !tcx.lookup_generics(method.def_id).types.is_empty() {\n                         continue;\n                     }\n "}, {"sha": "264d4940c17f91d4a4ff3c7c3b5e9b09773587ab", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -32,7 +32,7 @@ use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n use symbol_map::SymbolMap;\n-use util::nodemap::{NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -52,7 +52,7 @@ pub struct Stats {\n     pub n_inlines: Cell<usize>,\n     pub n_closures: Cell<usize>,\n     pub n_llvm_insns: Cell<usize>,\n-    pub llvm_insns: RefCell<FnvHashMap<String, usize>>,\n+    pub llvm_insns: RefCell<FxHashMap<String, usize>>,\n     // (ident, llvm-instructions)\n     pub fn_stats: RefCell<Vec<(String, usize)> >,\n }\n@@ -74,7 +74,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n \n     use_dll_storage_attrs: bool,\n \n-    translation_items: RefCell<FnvHashSet<TransItem<'tcx>>>,\n+    translation_items: RefCell<FxHashSet<TransItem<'tcx>>>,\n     trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n     project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n }\n@@ -89,15 +89,15 @@ pub struct LocalCrateContext<'tcx> {\n     previous_work_product: Option<WorkProduct>,\n     tn: TypeNames, // FIXME: This seems to be largely unused.\n     codegen_unit: CodegenUnit<'tcx>,\n-    needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n-    fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n-    drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n+    needs_unwind_cleanup_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n+    fn_pointer_shims: RefCell<FxHashMap<Ty<'tcx>, ValueRef>>,\n+    drop_glues: RefCell<FxHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n     /// Cache instances of monomorphic and polymorphic items\n-    instances: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n+    instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n+    vtables: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n     /// Cache of constant strings,\n-    const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n+    const_cstr_cache: RefCell<FxHashMap<InternedString, ValueRef>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n     /// Key is a ValueRef holding a *T,\n@@ -107,48 +107,48 @@ pub struct LocalCrateContext<'tcx> {\n     /// when we ptrcast, and we have to ptrcast during translation\n     /// of a [T] const because we form a slice, a (*T,usize) pair, not\n     /// a pointer to an LLVM array type. Similar for trait objects.\n-    const_unsized: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n+    const_unsized: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// Cache of emitted const globals (value -> global)\n-    const_globals: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n+    const_globals: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// Cache of emitted const values\n-    const_values: RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n+    const_values: RefCell<FxHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n \n     /// Cache of external const values\n     extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n     /// Mapping from static definitions to their DefId's.\n-    statics: RefCell<FnvHashMap<ValueRef, DefId>>,\n+    statics: RefCell<FxHashMap<ValueRef, DefId>>,\n \n-    impl_method_cache: RefCell<FnvHashMap<(DefId, ast::Name), DefId>>,\n+    impl_method_cache: RefCell<FxHashMap<(DefId, ast::Name), DefId>>,\n \n     /// Cache of closure wrappers for bare fn's.\n-    closure_bare_wrapper_cache: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n+    closure_bare_wrapper_cache: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// List of globals for static variables which need to be passed to the\n     /// LLVM function ReplaceAllUsesWith (RAUW) when translation is complete.\n     /// (We have to make sure we don't invalidate any ValueRefs referring\n     /// to constants.)\n     statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n \n-    lltypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n-    llsizingtypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n-    type_hashcodes: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n+    lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    llsizingtypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    type_hashcodes: RefCell<FxHashMap<Ty<'tcx>, String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    closure_vals: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n+    closure_vals: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n     eh_personality: Cell<Option<ValueRef>>,\n     eh_unwind_resume: Cell<Option<ValueRef>>,\n     rust_try_fn: Cell<Option<ValueRef>>,\n \n-    intrinsics: RefCell<FnvHashMap<&'static str, ValueRef>>,\n+    intrinsics: RefCell<FxHashMap<&'static str, ValueRef>>,\n \n     /// Number of LLVM instructions translated into this `LocalCrateContext`.\n     /// This is used to perform some basic load-balancing to keep all LLVM\n@@ -502,12 +502,12 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n                 n_inlines: Cell::new(0),\n                 n_closures: Cell::new(0),\n                 n_llvm_insns: Cell::new(0),\n-                llvm_insns: RefCell::new(FnvHashMap()),\n+                llvm_insns: RefCell::new(FxHashMap()),\n                 fn_stats: RefCell::new(Vec::new()),\n             },\n             check_overflow: check_overflow,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n-            translation_items: RefCell::new(FnvHashSet()),\n+            translation_items: RefCell::new(FxHashSet()),\n             trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n             project_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n         }\n@@ -557,7 +557,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         self.use_dll_storage_attrs\n     }\n \n-    pub fn translation_items(&self) -> &RefCell<FnvHashSet<TransItem<'tcx>>> {\n+    pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n         &self.translation_items\n     }\n \n@@ -612,32 +612,32 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 previous_work_product: previous_work_product,\n                 codegen_unit: codegen_unit,\n                 tn: TypeNames::new(),\n-                needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n-                fn_pointer_shims: RefCell::new(FnvHashMap()),\n-                drop_glues: RefCell::new(FnvHashMap()),\n-                instances: RefCell::new(FnvHashMap()),\n-                vtables: RefCell::new(FnvHashMap()),\n-                const_cstr_cache: RefCell::new(FnvHashMap()),\n-                const_unsized: RefCell::new(FnvHashMap()),\n-                const_globals: RefCell::new(FnvHashMap()),\n-                const_values: RefCell::new(FnvHashMap()),\n+                needs_unwind_cleanup_cache: RefCell::new(FxHashMap()),\n+                fn_pointer_shims: RefCell::new(FxHashMap()),\n+                drop_glues: RefCell::new(FxHashMap()),\n+                instances: RefCell::new(FxHashMap()),\n+                vtables: RefCell::new(FxHashMap()),\n+                const_cstr_cache: RefCell::new(FxHashMap()),\n+                const_unsized: RefCell::new(FxHashMap()),\n+                const_globals: RefCell::new(FxHashMap()),\n+                const_values: RefCell::new(FxHashMap()),\n                 extern_const_values: RefCell::new(DefIdMap()),\n-                statics: RefCell::new(FnvHashMap()),\n-                impl_method_cache: RefCell::new(FnvHashMap()),\n-                closure_bare_wrapper_cache: RefCell::new(FnvHashMap()),\n+                statics: RefCell::new(FxHashMap()),\n+                impl_method_cache: RefCell::new(FxHashMap()),\n+                closure_bare_wrapper_cache: RefCell::new(FxHashMap()),\n                 statics_to_rauw: RefCell::new(Vec::new()),\n-                lltypes: RefCell::new(FnvHashMap()),\n-                llsizingtypes: RefCell::new(FnvHashMap()),\n-                type_hashcodes: RefCell::new(FnvHashMap()),\n+                lltypes: RefCell::new(FxHashMap()),\n+                llsizingtypes: RefCell::new(FxHashMap()),\n+                type_hashcodes: RefCell::new(FxHashMap()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                closure_vals: RefCell::new(FnvHashMap()),\n+                closure_vals: RefCell::new(FxHashMap()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: Cell::new(None),\n                 eh_unwind_resume: Cell::new(None),\n                 rust_try_fn: Cell::new(None),\n-                intrinsics: RefCell::new(FnvHashMap()),\n+                intrinsics: RefCell::new(FxHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n                 symbol_map: symbol_map,\n@@ -794,16 +794,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.link_meta\n     }\n \n-    pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, bool>> {\n+    pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FxHashMap<Ty<'tcx>, bool>> {\n         &self.local().needs_unwind_cleanup_cache\n     }\n \n-    pub fn fn_pointer_shims(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n+    pub fn fn_pointer_shims(&self) -> &RefCell<FxHashMap<Ty<'tcx>, ValueRef>> {\n         &self.local().fn_pointer_shims\n     }\n \n     pub fn drop_glues<'a>(&'a self)\n-                          -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>> {\n+                          -> &'a RefCell<FxHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>> {\n         &self.local().drop_glues\n     }\n \n@@ -815,61 +815,61 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.sess().cstore.defid_for_inlined_node(node_id)\n     }\n \n-    pub fn instances<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n+    pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().instances\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n         &self.local().vtables\n     }\n \n-    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<InternedString, ValueRef>> {\n+    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FxHashMap<InternedString, ValueRef>> {\n         &self.local().const_cstr_cache\n     }\n \n-    pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n+    pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n         &self.local().const_unsized\n     }\n \n-    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n+    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n         &self.local().const_globals\n     }\n \n-    pub fn const_values<'a>(&'a self) -> &'a RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n-                                                                ValueRef>> {\n+    pub fn const_values<'a>(&'a self) -> &'a RefCell<FxHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n+                                                               ValueRef>> {\n         &self.local().const_values\n     }\n \n     pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n         &self.local().extern_const_values\n     }\n \n-    pub fn statics<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, DefId>> {\n+    pub fn statics<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, DefId>> {\n         &self.local().statics\n     }\n \n     pub fn impl_method_cache<'a>(&'a self)\n-            -> &'a RefCell<FnvHashMap<(DefId, ast::Name), DefId>> {\n+            -> &'a RefCell<FxHashMap<(DefId, ast::Name), DefId>> {\n         &self.local().impl_method_cache\n     }\n \n-    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n+    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n         &self.local().closure_bare_wrapper_cache\n     }\n \n     pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n         &self.local().statics_to_rauw\n     }\n \n-    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n+    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n         &self.local().lltypes\n     }\n \n-    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n+    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n         &self.local().llsizingtypes\n     }\n \n-    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n+    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, String>> {\n         &self.local().type_hashcodes\n     }\n \n@@ -885,7 +885,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().opaque_vec_type\n     }\n \n-    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n+    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().closure_vals\n     }\n \n@@ -905,7 +905,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().rust_try_fn\n     }\n \n-    fn intrinsics<'a>(&'a self) -> &'a RefCell<FnvHashMap<&'static str, ValueRef>> {\n+    fn intrinsics<'a>(&'a self) -> &'a RefCell<FxHashMap<&'static str, ValueRef>> {\n         &self.local().intrinsics\n     }\n \n@@ -958,7 +958,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &*self.local().symbol_map\n     }\n \n-    pub fn translation_items(&self) -> &RefCell<FnvHashSet<TransItem<'tcx>>> {\n+    pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n         &self.shared.translation_items\n     }\n "}, {"sha": "e81461b662172ecf4eaadac326b09fc59bc0b0b7", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -36,7 +36,7 @@ use common::CrateContext;\n use type_::Type;\n use rustc::ty::{self, AdtKind, Ty, layout};\n use session::config;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n@@ -84,20 +84,20 @@ pub struct TypeMap<'tcx> {\n     // The UniqueTypeIds created so far\n     unique_id_interner: Interner,\n     // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n-    unique_id_to_metadata: FnvHashMap<UniqueTypeId, DIType>,\n+    unique_id_to_metadata: FxHashMap<UniqueTypeId, DIType>,\n     // A map from types to debuginfo metadata. This is a N:1 mapping.\n-    type_to_metadata: FnvHashMap<Ty<'tcx>, DIType>,\n+    type_to_metadata: FxHashMap<Ty<'tcx>, DIType>,\n     // A map from types to UniqueTypeId. This is a N:1 mapping.\n-    type_to_unique_id: FnvHashMap<Ty<'tcx>, UniqueTypeId>\n+    type_to_unique_id: FxHashMap<Ty<'tcx>, UniqueTypeId>\n }\n \n impl<'tcx> TypeMap<'tcx> {\n     pub fn new() -> TypeMap<'tcx> {\n         TypeMap {\n             unique_id_interner: Interner::new(),\n-            type_to_metadata: FnvHashMap(),\n-            unique_id_to_metadata: FnvHashMap(),\n-            type_to_unique_id: FnvHashMap(),\n+            type_to_metadata: FxHashMap(),\n+            unique_id_to_metadata: FxHashMap(),\n+            type_to_unique_id: FxHashMap(),\n         }\n     }\n \n@@ -1765,7 +1765,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = tcx.erase_regions(&tcx.node_id_to_type(node_id));\n+    let variable_type = tcx.erase_regions(&tcx.tables().node_id_to_type(node_id));\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");"}, {"sha": "62fb40cc389c24393ed41146e515824e188e4813", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -34,7 +34,7 @@ use monomorphize::{self, Instance};\n use rustc::ty::{self, Ty};\n use rustc::mir;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use util::nodemap::{DefIdMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n@@ -68,15 +68,15 @@ pub struct CrateDebugContext<'tcx> {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n     current_debug_location: Cell<InternalDebugLocation>,\n-    created_files: RefCell<FnvHashMap<String, DIFile>>,\n-    created_enum_disr_types: RefCell<FnvHashMap<(DefId, layout::Integer), DIType>>,\n+    created_files: RefCell<FxHashMap<String, DIFile>>,\n+    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Integer), DIType>>,\n \n     type_map: RefCell<TypeMap<'tcx>>,\n     namespace_map: RefCell<DefIdMap<DIScope>>,\n \n     // This collection is used to assert that composite types (structs, enums,\n     // ...) have their members only set once:\n-    composite_types_completed: RefCell<FnvHashSet<DIType>>,\n+    composite_types_completed: RefCell<FxHashSet<DIType>>,\n }\n \n impl<'tcx> CrateDebugContext<'tcx> {\n@@ -89,11 +89,11 @@ impl<'tcx> CrateDebugContext<'tcx> {\n             llcontext: llcontext,\n             builder: builder,\n             current_debug_location: Cell::new(InternalDebugLocation::UnknownLocation),\n-            created_files: RefCell::new(FnvHashMap()),\n-            created_enum_disr_types: RefCell::new(FnvHashMap()),\n+            created_files: RefCell::new(FxHashMap()),\n+            created_enum_disr_types: RefCell::new(FxHashMap()),\n             type_map: RefCell::new(TypeMap::new()),\n             namespace_map: RefCell::new(DefIdMap()),\n-            composite_types_completed: RefCell::new(FnvHashSet()),\n+            composite_types_completed: RefCell::new(FxHashSet()),\n         };\n     }\n }"}, {"sha": "8ef7f04d4ee14482a9f3a6b42b10d44821f0d9bd", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -28,7 +28,7 @@\n #![feature(cell_extras)]\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n-#![feature(dotdot_in_tuple_patterns)]\n+#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![allow(unused_attributes)]\n #![feature(libc)]\n #![feature(quote)]\n@@ -169,6 +169,7 @@ pub struct CrateTranslation {\n     pub metadata: Vec<u8>,\n     pub reachable: Vec<String>,\n     pub no_builtins: bool,\n+    pub windows_subsystem: Option<String>,\n     pub linker_info: back::linker::LinkerInfo\n }\n "}, {"sha": "e4d0533ec878422bc60b6e52f0ba2d1a6471afae", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -42,12 +42,6 @@ pub fn lvalue_locals<'bcx, 'tcx>(bcx: Block<'bcx,'tcx>,\n                     common::type_is_fat_ptr(bcx.tcx(), ty));\n         } else if common::type_is_imm_pair(bcx.ccx(), ty) {\n             // We allow pairs and uses of any of their 2 fields.\n-        } else if !analyzer.seen_assigned.contains(index) {\n-            // No assignment has been seen, which means that\n-            // either the local has been marked as lvalue\n-            // already, or there is no possible initialization\n-            // for the local, making any reads invalid.\n-            // This is useful in weeding out dead temps.\n         } else {\n             // These sorts of types require an alloca. Note that\n             // type_is_immediate() may *still* be true, particularly"}, {"sha": "b22bcf9825a2aa4239b23fbe49a9b11a4e0d9e40", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -29,7 +29,7 @@ use type_of;\n use glue;\n use type_::Type;\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use syntax::parse::token;\n \n use super::{MirContext, LocalRef};\n@@ -144,7 +144,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     adt::trans_get_discr(bcx, ty, discr_lvalue.llval, None, true)\n                 );\n \n-                let mut bb_hist = FnvHashMap();\n+                let mut bb_hist = FxHashMap();\n                 for target in targets {\n                     *bb_hist.entry(target).or_insert(0) += 1;\n                 }"}, {"sha": "b8d346b11c13f1500c4c4c2e2063b87b95777e72", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0", "patch": "@@ -248,13 +248,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             let vtable = common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n             if let traits::VtableImpl(vtable_impl) = vtable {\n                 let name = ccx.tcx().item_name(instance.def);\n-                let ac = ccx.tcx().impl_or_trait_items(vtable_impl.impl_def_id)\n-                    .iter().filter_map(|&def_id| {\n-                        match ccx.tcx().impl_or_trait_item(def_id) {\n-                            ty::ConstTraitItem(ac) => Some(ac),\n-                            _ => None\n-                        }\n-                    }).find(|ic| ic.name == name);\n+                let ac = ccx.tcx().associated_items(vtable_impl.impl_def_id)\n+                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 if let Some(ac) = ac {\n                     instance = Instance::new(ac.def_id, vtable_impl.substs);\n                 }"}, {"sha": "c9c12fb6d4534deb2f2dbea251e38ca64fe09faa", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "c3e0ac1fee51578d33b238f3ebb4d3e4aba06265", "filename": "src/librustc_trans/symbol_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "2a6f79d3ed57ae4fb5d3ceeb3a9ba5b314fcb58b", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "513b4860d5e8748fd30a739b7d45bec9e248fecf", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 105, "deletions": 137, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "ca630624cdb3889aafc18b40fce0b4e1b2ccc8af", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "7606a5b7a4d46cc4fd0d0e6ea11056bafedc6341", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "af834f3f84d4775c986801a0325e855adecd4716", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "16493412d690b41e042afbb1e2c9b99b2fc8fe06", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "ffde940b3f48a83b1788c2321e0fc69f39beb228", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 524, "deletions": 390, "changes": 914, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "a06b3e70881a5204c1af7a7267c4fece982ac712", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "95d2b2211f5b418bb2bc3c0adf86a0c6a50d482d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "3894a7a2097eb9375153acb3df8d45258c8b7708", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 104, "deletions": 122, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "579a54fb5318df629d10912a06c99df21a55687e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 58, "deletions": 84, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "7068b2dea7263b847a920708c23be6987cc2c756", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 45, "deletions": 74, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "0cb8cf2a58886af8247dcb97fc7271b15538f063", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "08242cff112ceee9221179aa6a3bd69987f4cb7a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 441, "deletions": 360, "changes": 801, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "8b4975b7e3a2f723331219af60397986596beed3", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "d4e5e9a5bb355f5b0520b77f2574c23d6ff598dd", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 23, "deletions": 46, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "2fea86cb212070844afd79696d14dc6c1100b609", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "4136f543cccaf2dd2c1f477141947bb6430f11dc", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 69, "deletions": 64, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "9f3214a0d813e6e88d392810727b598a751178f3", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "90541539c1e23551dcdfafa9ef0887eb82d3934d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "b5aba512a66bd6c0172c5a3b8184fd830c657002", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "d92a98485103cd6ef4b8ad5cc1ad3db9ffa9b7c7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 67, "deletions": 197, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "7918537a6c08f7ec4173a51fe68814c8ff3aeb42", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "be012d8976f6c1ab9836e131845a92bf48359067", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "d7573c7a7bd2e5ae00e583ff8b92174eb45febfd", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "a2955169cbb81d70947c05fb76fde65e1a4a806c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "9e29d191946b71957dbc68f07af6b63b33ecb69c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 112, "deletions": 126, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "a25cb0bacc5cf785610a2bc634d8535868b80882", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "2db771d771119c6192bde2af5b17fdfe9728469f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 83, "deletions": 37, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "474d2bbe7fcb54c6d4880a3b792f91c05b5968da", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "46b34b5a638b337876fd513601561115bee8091d", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 373, "deletions": 365, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "ee395e0616b81ccbd033bddd853a465be6be0b9e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "12d33dcb207f7c78ab170e5cbb69439a8b27b098", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "d0407162793ee98a5a75ef9d52e98c71fd91bc34", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "ece51d6d82616753a762bc1c7c36705efe872d4f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "d1b8fcd74400310323417f0e51c97a0c6a981405", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "795c89c0007472d09acd1a52a1e946efac5eb373", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "ad9ae5638b6ac454c1f0abe1825f9d45b62426d8", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "f6ee0be47fad7a99e47b1c2022b79001aeb64d2b", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "12dbbe3c46918a95cc81be7bfc69ca4c624059c2", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "559250adac5ed24c47a7ac2fe7f5938d5bf14345", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "bb6883236e8024b9aa3753f8ab1e2a7732db43a9", "filename": "src/libstd/path.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "e4b0d980c921aa1381e7cec2ecda0cdc7e88fa12", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "9b1cf6ffd0e2200a4b395e45ffc3c5948e2ffe07", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "5c07e36508c69128f34b6c6b2547ec7e219a9135", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "f5cd089e923d7c7efe3dbbcdf7001d45656e5e06", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "57a936bf9b0cf40c09b082571f186e698c28ab0a", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "63eee7df9e85d2632d665dee7a257ca13f7a575a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "c3e28cbb006a07795499c4af50cae727df286ed4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "969cfa292ce8068315fea22fd6d587851647264f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "1066646aa8e8a82a2c7830b6631502634e5d2401", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "552d4de961740f4c59b749b30ba9fde36719d75e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "37e329e5d3b29fb581e7d3b77838da3acda067d5", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 11, "deletions": 54, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "9116b392f178460857b2c33c0977ac615bb52f21", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "2e62f23578d815884167938f18949d42c69beb9a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "feed400897c0f13a75ca3586a7393d94f6f44173", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "983c882eafca31298542d0a2a53ee7d44eca1dd8", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "cf48c445c80ebf24f2be8bb15467ecba278aab70", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "7d15334ff9f4e3634ef8b977f9edea18ccaa9182", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 137, "deletions": 197, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "0198ee073d23982c3534787ab2c950fa2a44076e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "203c19285ac2c366e01f83b5d4eebc32cd35f772", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "9ef6c07e489dce7de227d349cbeef5b313358422", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "a1f07381db705910e14e766b5520b8d95c463929", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "7c1ff617ab64d00b46d07021b15c5f83ab79abb7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "e4d0cb74046037a9407e421640445adaaacb8d16", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "e101757ad23220dfabebc1a5a1ba707b245ca084", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "dc1f7b4e6201e7132f989a8929b0337d7a6652cc", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "ebbddc6e48084464208cd33b9dacce183863b98b", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "b1d473820f774b1914c37cac18277a1843d28dee", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "e1542c9e466aad803c895713627794421ed7d14d", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}, {"sha": "d6d31200a994fcbc29d99422c4c21c56e48085f0", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 63, "deletions": 15, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb9a959074bb7f027cf05a240a0044116fa0ab0/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=0bb9a959074bb7f027cf05a240a0044116fa0ab0"}]}