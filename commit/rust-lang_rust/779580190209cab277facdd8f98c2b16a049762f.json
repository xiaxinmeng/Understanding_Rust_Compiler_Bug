{"sha": "779580190209cab277facdd8f98c2b16a049762f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3OTU4MDE5MDIwOWNhYjI3N2ZhY2RkOGY5OGMyYjE2YTA0OTc2MmY=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-19T00:00:52Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-19T02:53:12Z"}, "message": "rustc_query_system: explicitly register reused dep nodes\n\nRegister nodes that we've reused from the previous session explicitly\nwith `OnDiskCache`. Previously, we relied on this happening as a side\neffect of accessing the nodes in the `PreviousDepGraph`. For the sake of\nperformance and avoiding unintended side effects, register explictily.", "tree": {"sha": "02fef5ee99addfb46fcee89b16ec4c0275356586", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02fef5ee99addfb46fcee89b16ec4c0275356586"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/779580190209cab277facdd8f98c2b16a049762f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/779580190209cab277facdd8f98c2b16a049762f", "html_url": "https://github.com/rust-lang/rust/commit/779580190209cab277facdd8f98c2b16a049762f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/779580190209cab277facdd8f98c2b16a049762f/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb4fc71dc9024f15a0c9cc44bcc10c861e9d585e", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb4fc71dc9024f15a0c9cc44bcc10c861e9d585e", "html_url": "https://github.com/rust-lang/rust/commit/eb4fc71dc9024f15a0c9cc44bcc10c861e9d585e"}], "stats": {"total": 113, "additions": 51, "deletions": 62}, "files": [{"sha": "728bfef9f467373bf7cf712f62547afb819c20ea", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=779580190209cab277facdd8f98c2b16a049762f", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::{DefPathHash, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n \n mod dep_node;\n \n@@ -91,9 +91,9 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     type DepKind = DepKind;\n     type StableHashingContext = StableHashingContext<'tcx>;\n \n-    fn register_reused_dep_path_hash(&self, hash: DefPathHash) {\n+    fn register_reused_dep_node(&self, dep_node: &DepNode) {\n         if let Some(cache) = self.queries.on_disk_cache.as_ref() {\n-            cache.register_reused_dep_path_hash(*self, hash)\n+            cache.register_reused_dep_node(*self, dep_node)\n         }\n     }\n "}, {"sha": "8316b4c109b8efb6e1bceb8e9999643df1cfa05e", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=779580190209cab277facdd8f98c2b16a049762f", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n+use crate::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use crate::mir::{self, interpret};\n use crate::ty::codec::{OpaqueEncoder, RefDecodable, TyDecoder, TyEncoder};\n@@ -264,6 +264,13 @@ impl<'sess> OnDiskCache<'sess> {\n                 (file_to_file_index, file_index_to_stable_id)\n             };\n \n+            // Register any dep nodes that we reused from the previous session,\n+            // but didn't `DepNode::construct` in this session. This ensures\n+            // that their `DefPathHash` to `RawDefId` mappings are registered\n+            // in 'latest_foreign_def_path_hashes' if necessary, since that\n+            // normally happens in `DepNode::construct`.\n+            tcx.dep_graph.register_reused_dep_nodes(tcx);\n+\n             // Load everything into memory so we can write it out to the on-disk\n             // cache. The vast majority of cacheable query results should already\n             // be in memory, so this should be a cheap operation.\n@@ -467,7 +474,7 @@ impl<'sess> OnDiskCache<'sess> {\n             .insert(hash, RawDefId { krate: def_id.krate.as_u32(), index: def_id.index.as_u32() });\n     }\n \n-    /// If the given `hash` still exists in the current compilation,\n+    /// If the given `dep_node`'s hash still exists in the current compilation,\n     /// calls `store_foreign_def_id` with its current `DefId`.\n     ///\n     /// Normally, `store_foreign_def_id_hash` can be called directly by\n@@ -476,13 +483,22 @@ impl<'sess> OnDiskCache<'sess> {\n     /// session, we only have the `DefPathHash` available. This method is used\n     /// to that any `DepNode` that we re-use has a `DefPathHash` -> `RawId` written\n     /// out for usage in the next compilation session.\n-    pub fn register_reused_dep_path_hash(&self, tcx: TyCtxt<'tcx>, hash: DefPathHash) {\n-        // We can't simply copy the `RawDefId` from `foreign_def_path_hashes` to\n-        // `latest_foreign_def_path_hashes`, since the `RawDefId` might have\n-        // changed in the current compilation session (e.g. we've added/removed crates,\n-        // or added/removed definitions before/after the target definition).\n-        if let Some(def_id) = self.def_path_hash_to_def_id(tcx, hash) {\n-            self.store_foreign_def_id_hash(def_id, hash);\n+    pub fn register_reused_dep_node(&self, tcx: TyCtxt<'tcx>, dep_node: &DepNode) {\n+        // For reused dep nodes, we only need to store the mapping if the node\n+        // is one whose query key we can reconstruct from the hash. We use the\n+        // mapping to aid that reconstruction in the next session. While we also\n+        // use it to decode `DefId`s we encoded in the cache as `DefPathHashes`,\n+        // they're already registered during `DefId` encoding.\n+        if dep_node.kind.can_reconstruct_query_key() {\n+            let hash = DefPathHash(dep_node.hash.into());\n+\n+            // We can't simply copy the `RawDefId` from `foreign_def_path_hashes` to\n+            // `latest_foreign_def_path_hashes`, since the `RawDefId` might have\n+            // changed in the current compilation session (e.g. we've added/removed crates,\n+            // or added/removed definitions before/after the target definition).\n+            if let Some(def_id) = self.def_path_hash_to_def_id(tcx, hash) {\n+                self.store_foreign_def_id_hash(def_id, hash);\n+            }\n         }\n     }\n "}, {"sha": "ff52fdab19c50775f25b8e763faa5aff2c8d4732", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=779580190209cab277facdd8f98c2b16a049762f", "patch": "@@ -60,9 +60,8 @@ pub struct DepNode<K> {\n     // * When a `DepNode::construct` is called, `arg.to_fingerprint()`\n     //   is responsible for calling `OnDiskCache::store_foreign_def_id_hash`\n     //   if needed\n-    // * When a `DepNode` is loaded from the `PreviousDepGraph`,\n-    //   then `PreviousDepGraph::index_to_node` is responsible for calling\n-    //   `tcx.register_reused_dep_path_hash`\n+    // * When we serialize the on-disk cache, `OnDiskCache::serialize` is\n+    //   responsible for calling `DepGraph::register_reused_dep_nodes`.\n     //\n     // FIXME: Enforce this by preventing manual construction of `DefNode`\n     // (e.g. add a `_priv: ()` field)"}, {"sha": "d2f0e39ea6bbda35a6f0cbc63be82e75d72f2385", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=779580190209cab277facdd8f98c2b16a049762f", "patch": "@@ -554,7 +554,7 @@ impl<K: DepKind> DepGraph<K> {\n         // We never try to mark eval_always nodes as green\n         debug_assert!(!dep_node.kind.is_eval_always());\n \n-        data.previous.debug_assert_eq(prev_dep_node_index, *dep_node);\n+        debug_assert_eq!(data.previous.index_to_node(prev_dep_node_index), *dep_node);\n \n         let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n \n@@ -572,7 +572,7 @@ impl<K: DepKind> DepGraph<K> {\n                         \"try_mark_previous_green({:?}) --- found dependency {:?} to \\\n                             be immediately green\",\n                         dep_node,\n-                        data.previous.debug_dep_node(dep_dep_node_index),\n+                        data.previous.index_to_node(dep_dep_node_index)\n                     );\n                     current_deps.push(node_index);\n                 }\n@@ -585,12 +585,12 @@ impl<K: DepKind> DepGraph<K> {\n                         \"try_mark_previous_green({:?}) - END - dependency {:?} was \\\n                             immediately red\",\n                         dep_node,\n-                        data.previous.debug_dep_node(dep_dep_node_index)\n+                        data.previous.index_to_node(dep_dep_node_index)\n                     );\n                     return None;\n                 }\n                 None => {\n-                    let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index, tcx);\n+                    let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n \n                     // We don't know the state of this dependency. If it isn't\n                     // an eval_always node, let's try to mark it green recursively.\n@@ -801,7 +801,7 @@ impl<K: DepKind> DepGraph<K> {\n         for prev_index in data.colors.values.indices() {\n             match data.colors.get(prev_index) {\n                 Some(DepNodeColor::Green(_)) => {\n-                    let dep_node = data.previous.index_to_node(prev_index, tcx);\n+                    let dep_node = data.previous.index_to_node(prev_index);\n                     tcx.try_load_from_on_disk_cache(&dep_node);\n                 }\n                 None | Some(DepNodeColor::Red) => {\n@@ -813,6 +813,20 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    // Register reused dep nodes (i.e. nodes we've marked red or green) with the context.\n+    pub fn register_reused_dep_nodes<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n+        let data = self.data.as_ref().unwrap();\n+        for prev_index in data.colors.values.indices() {\n+            match data.colors.get(prev_index) {\n+                Some(DepNodeColor::Red) | Some(DepNodeColor::Green(_)) => {\n+                    let dep_node = data.previous.index_to_node(prev_index);\n+                    tcx.register_reused_dep_node(&dep_node);\n+                }\n+                None => {}\n+            }\n+        }\n+    }\n+\n     fn next_virtual_depnode_index(&self) -> DepNodeIndex {\n         let index = self.virtual_dep_node_index.fetch_add(1, Relaxed);\n         DepNodeIndex::from_u32(index)"}, {"sha": "da0b5aad6c811493e3a7954925f11469c76eee4a", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=779580190209cab277facdd8f98c2b16a049762f", "patch": "@@ -15,7 +15,6 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n-use rustc_span::def_id::DefPathHash;\n \n use std::fmt;\n use std::hash::Hash;\n@@ -33,7 +32,7 @@ pub trait DepContext: Copy {\n     /// Try to force a dep node to execute and see if it's green.\n     fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n \n-    fn register_reused_dep_path_hash(&self, hash: DefPathHash);\n+    fn register_reused_dep_node(&self, dep_node: &DepNode<Self::DepKind>);\n \n     /// Return whether the current session is tainted by errors.\n     fn has_errors_or_delayed_span_bugs(&self) -> bool;"}, {"sha": "29357ce9449ce26f48df11c3ac0c12c743efa0a2", "filename": "compiler/rustc_query_system/src/dep_graph/prev.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/779580190209cab277facdd8f98c2b16a049762f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs?ref=779580190209cab277facdd8f98c2b16a049762f", "patch": "@@ -1,9 +1,7 @@\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n use super::{DepKind, DepNode};\n-use crate::dep_graph::DepContext;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_span::def_id::DefPathHash;\n \n #[derive(Debug, Encodable, Decodable)]\n pub struct PreviousDepGraph<K: DepKind> {\n@@ -33,44 +31,7 @@ impl<K: DepKind> PreviousDepGraph<K> {\n     }\n \n     #[inline]\n-    pub fn index_to_node<CTX: DepContext<DepKind = K>>(\n-        &self,\n-        dep_node_index: SerializedDepNodeIndex,\n-        tcx: CTX,\n-    ) -> DepNode<K> {\n-        let dep_node = self.data.nodes[dep_node_index];\n-        // We have just loaded a deserialized `DepNode` from the previous\n-        // compilation session into the current one. If this was a foreign `DefId`,\n-        // then we stored additional information in the incr comp cache when we\n-        // initially created its fingerprint (see `DepNodeParams::to_fingerprint`)\n-        // We won't be calling `to_fingerprint` again for this `DepNode` (we no longer\n-        // have the original value), so we need to copy over this additional information\n-        // from the old incremental cache into the new cache that we serialize\n-        // and the end of this compilation session.\n-        if dep_node.kind.can_reconstruct_query_key() {\n-            tcx.register_reused_dep_path_hash(DefPathHash(dep_node.hash.into()));\n-        }\n-        dep_node\n-    }\n-\n-    /// When debug assertions are enabled, asserts that the dep node at `dep_node_index` is equal to `dep_node`.\n-    /// This method should be preferred over manually calling `index_to_node`.\n-    /// Calls to `index_to_node` may affect global state, so gating a call\n-    /// to `index_to_node` on debug assertions could cause behavior changes when debug assertions\n-    /// are enabled.\n-    #[inline]\n-    pub fn debug_assert_eq(&self, dep_node_index: SerializedDepNodeIndex, dep_node: DepNode<K>) {\n-        debug_assert_eq!(self.data.nodes[dep_node_index], dep_node);\n-    }\n-\n-    /// Obtains a debug-printable version of the `DepNode`.\n-    /// See `debug_assert_eq` for why this should be preferred over manually\n-    /// calling `dep_node_index`\n-    pub fn debug_dep_node(&self, dep_node_index: SerializedDepNodeIndex) -> impl std::fmt::Debug {\n-        // We're returning the `DepNode` without calling `register_reused_dep_path_hash`,\n-        // but `impl Debug` return type means that it can only be used for debug printing.\n-        // So, there's no risk of calls trying to create new dep nodes that have this\n-        // node as a dependency\n+    pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode<K> {\n         self.data.nodes[dep_node_index]\n     }\n "}]}