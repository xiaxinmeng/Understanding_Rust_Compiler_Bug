{"sha": "a6dd7b505615620a9181891db06d39b1b1043f30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZGQ3YjUwNTYxNTYyMGE5MTgxODkxZGIwNmQzOWIxYjEwNDNmMzA=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-01-12T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-01-12T23:33:36Z"}, "message": "Consistently avoid constructing optimized MIR when not doing codegen\n\nThe optimized MIR for closures is being encoded unconditionally, while\nbeing unnecessary for cargo check. This turns out to be especially\ncostly with MIR inlining enabled, since it triggers computation of\noptimized MIR for all callees that are being examined for inlining\npurposes.\n\nSkip encoding of optimized MIR for closures, enum constructors, struct\nconstructors, and trait fns when not doing codegen, like it is already\ndone for other items since 49433.", "tree": {"sha": "e5d8a1491a8e779101b5b6cafb2f936496bb7d26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5d8a1491a8e779101b5b6cafb2f936496bb7d26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6dd7b505615620a9181891db06d39b1b1043f30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6dd7b505615620a9181891db06d39b1b1043f30", "html_url": "https://github.com/rust-lang/rust/commit/a6dd7b505615620a9181891db06d39b1b1043f30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6dd7b505615620a9181891db06d39b1b1043f30/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bf3949398797dd499a18eb06953a7601b8eb146", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bf3949398797dd499a18eb06953a7601b8eb146", "html_url": "https://github.com/rust-lang/rust/commit/1bf3949398797dd499a18eb06953a7601b8eb146"}], "stats": {"total": 46, "additions": 30, "deletions": 16}, "files": [{"sha": "f71233c9472c11c8da15719265801e12d5a055ff", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a6dd7b505615620a9181891db06d39b1b1043f30/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6dd7b505615620a9181891db06d39b1b1043f30/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=a6dd7b505615620a9181891db06d39b1b1043f30", "patch": "@@ -792,9 +792,12 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n         self.encode_inferred_outlives(def_id);\n-        self.encode_mir_for_ctfe(def_id.expect_local());\n-        self.encode_optimized_mir(def_id.expect_local());\n+        let opt_mir = tcx.sess.opts.debugging_opts.always_encode_mir || self.emit_codegen_mir;\n+        if opt_mir {\n+            self.encode_optimized_mir(def_id.expect_local());\n+        }\n         self.encode_promoted_mir(def_id.expect_local());\n+        self.encode_mir_for_ctfe(def_id.expect_local());\n     }\n \n     fn encode_info_for_mod(&mut self, id: hir::HirId, md: &hir::Mod<'_>, attrs: &[ast::Attribute]) {\n@@ -900,7 +903,10 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n         self.encode_inferred_outlives(def_id);\n-        self.encode_optimized_mir(def_id.expect_local());\n+        let opt_mir = tcx.sess.opts.debugging_opts.always_encode_mir || self.emit_codegen_mir;\n+        if opt_mir {\n+            self.encode_optimized_mir(def_id.expect_local());\n+        }\n         self.encode_mir_for_ctfe(def_id.expect_local());\n         self.encode_promoted_mir(def_id.expect_local());\n     }\n@@ -1029,14 +1035,25 @@ impl EncodeContext<'a, 'tcx> {\n                 }\n             }\n             ty::AssocKind::Fn => {\n-                if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id.expect_local()) {\n-                    self.encode_optimized_mir(def_id.expect_local());\n-                    self.encode_promoted_mir(def_id.expect_local());\n+                let opt_mir =\n+                    tcx.sess.opts.debugging_opts.always_encode_mir || self.emit_codegen_mir;\n+                if opt_mir {\n+                    if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id.expect_local()) {\n+                        self.encode_optimized_mir(def_id.expect_local());\n+                        self.encode_promoted_mir(def_id.expect_local());\n+                    }\n                 }\n             }\n         }\n     }\n \n+    fn should_encode_fn_opt_mir(&self, def_id: DefId) -> bool {\n+        self.tcx.sess.opts.debugging_opts.always_encode_mir\n+            || (self.emit_codegen_mir\n+                && (self.tcx.generics_of(def_id).requires_monomorphization(self.tcx)\n+                    || self.tcx.codegen_fn_attrs(def_id).requests_inline()))\n+    }\n+\n     fn encode_info_for_impl_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -1105,10 +1122,7 @@ impl EncodeContext<'a, 'tcx> {\n         let (mir, mir_const) = match ast_item.kind {\n             hir::ImplItemKind::Const(..) => (false, true),\n             hir::ImplItemKind::Fn(ref sig, _) => {\n-                let opt_mir = tcx.sess.opts.debugging_opts.always_encode_mir\n-                    || (self.emit_codegen_mir\n-                        && (tcx.generics_of(def_id).requires_monomorphization(tcx)\n-                            || tcx.codegen_fn_attrs(def_id).requests_inline()));\n+                let opt_mir = self.should_encode_fn_opt_mir(def_id);\n                 let is_const_fn = sig.header.constness == hir::Constness::Const;\n                 (opt_mir, is_const_fn)\n             }\n@@ -1432,10 +1446,7 @@ impl EncodeContext<'a, 'tcx> {\n         let (mir, const_mir) = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => (false, true),\n             hir::ItemKind::Fn(ref sig, ..) => {\n-                let opt_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir\n-                    || (self.emit_codegen_mir\n-                        && (tcx.generics_of(def_id).requires_monomorphization(tcx)\n-                            || tcx.codegen_fn_attrs(def_id).requests_inline()));\n+                let opt_mir = self.should_encode_fn_opt_mir(def_id);\n                 let is_const_fn = sig.header.constness == hir::Constness::Const;\n                 // We don't need the optimized MIR for const fns.\n                 (opt_mir, is_const_fn)\n@@ -1498,8 +1509,11 @@ impl EncodeContext<'a, 'tcx> {\n             record!(self.tables.fn_sig[def_id] <- substs.as_closure().sig());\n         }\n         self.encode_generics(def_id.to_def_id());\n-        self.encode_optimized_mir(def_id);\n-        self.encode_promoted_mir(def_id);\n+        let opt_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir || self.emit_codegen_mir;\n+        if opt_mir {\n+            self.encode_optimized_mir(def_id);\n+            self.encode_promoted_mir(def_id);\n+        }\n     }\n \n     fn encode_info_for_anon_const(&mut self, def_id: LocalDefId) {"}]}