{"sha": "d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3OGI2MmUzZTRkNDVkZmEwN2U2NGY4NGE3MmNkNmJmYjg2NWQ5YTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-16T09:48:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-16T09:48:12Z"}, "message": "Merge pull request #524 from RalfJung/escape-to-raw\n\nStacked Borrows beautififcation, update for EscapeToRaw", "tree": {"sha": "143c1a757c3a9978247b3ed8567931faedc80edf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/143c1a757c3a9978247b3ed8567931faedc80edf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb7pJcCRBK7hj4Ov3rIwAAdHIIAH1Z3o/jmdZ71Hbh+6PKqumX\nr7haHudlvBicu7M+XKu9FFfc8e0gD469RAHaimYPpuxrQUJ2e/EQhrcA5IErdzNt\n/yasWyEeNqMewvSar9KKY3FyZ/YetoJg3sGPcG36iQXivv0dT2bhb+0PYdJCYgJh\nc1NjbfcgwMmPL1zCTRSDBc2A4sScsszzA6gNz9aKESWXuQPK33UuGViA+KQiMph8\n+qQR43V53mGKwju8elR+9h7unRel6ppU+XRFd0Pl8+BVMxgSHsezztd92YrM+Piv\nc+e9aikBr5vL/TuPkHkx8GirxLjFYQ3SotVJGO5EuhTJwtmORE671aqzF6taS3M=\n=j+8c\n-----END PGP SIGNATURE-----\n", "payload": "tree 143c1a757c3a9978247b3ed8567931faedc80edf\nparent 021bf1f3b38f2800fd0799f621f00ffc22849694\nparent 827e5180f20ebeec990ab8f92a4196ad8c5feb19\nauthor Ralf Jung <post@ralfj.de> 1542361692 +0100\ncommitter GitHub <noreply@github.com> 1542361692 +0100\n\nMerge pull request #524 from RalfJung/escape-to-raw\n\nStacked Borrows beautififcation, update for EscapeToRaw"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "html_url": "https://github.com/rust-lang/rust/commit/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "021bf1f3b38f2800fd0799f621f00ffc22849694", "url": "https://api.github.com/repos/rust-lang/rust/commits/021bf1f3b38f2800fd0799f621f00ffc22849694", "html_url": "https://github.com/rust-lang/rust/commit/021bf1f3b38f2800fd0799f621f00ffc22849694"}, {"sha": "827e5180f20ebeec990ab8f92a4196ad8c5feb19", "url": "https://api.github.com/repos/rust-lang/rust/commits/827e5180f20ebeec990ab8f92a4196ad8c5feb19", "html_url": "https://github.com/rust-lang/rust/commit/827e5180f20ebeec990ab8f92a4196ad8c5feb19"}], "stats": {"total": 1031, "additions": 640, "deletions": 391}, "files": [{"sha": "ca23de4208823d9cea12afd4974f260b60763f8a", "filename": ".gitignore", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -2,6 +2,5 @@ target\n /doc\n tex/*/out\n *.dot\n-*.mir\n *.rs.bk\n Cargo.lock"}, {"sha": "5eb7b34425e6e9641b4da080e4b80156926283f8", "filename": "README.md", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -45,14 +45,19 @@ in this directory.\n ## Running Miri\n \n ```sh\n-cargo +nightly run tests/run-pass/vecs.rs # Or whatever test you like.\n+cargo +nightly run -- -Zmiri-disable-validation tests/run-pass/vecs.rs # Or whatever test you like.\n ```\n \n+We have to disable validation because that can lead to errors when libstd is not\n+compiled the right way.\n+\n ## Running Miri with full libstd\n \n-Per default libstd does not contain the MIR of non-polymorphic functions. When\n-Miri hits a call to such a function, execution terminates. To fix this, it is\n-possible to compile libstd with full MIR:\n+Per default libstd does not contain the MIR of non-polymorphic functions, and\n+also does not contain some extra MIR statements that miri needs for validation.\n+When Miri hits a call to such a function, execution terminates, and even when\n+the MIR is present, validation can fail.  To fix this, it is possible to compile\n+libstd with full MIR:\n \n ```sh\n rustup component add --toolchain nightly rust-src"}, {"sha": "6c3858ccc9cd77215fdb58c4ba965782404aedcb", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -1 +1 @@\n-nightly-2018-11-15\n+nightly-2018-11-16"}, {"sha": "150cf7402a6dde831862db3fbeb7c5e586969a2d", "filename": "src/fn_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -555,7 +555,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n             \"pthread_attr_getstack\" => {\n                 // second argument is where we are supposed to write the stack size\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[1])?)?;\n+                let ptr = self.deref_operand(args[1])?;\n                 let stackaddr = Scalar::from_int(0x80000, args[1].layout.size); // just any address\n                 self.write_scalar(stackaddr, ptr.into())?;\n                 // return 0"}, {"sha": "31e297295703541b4feb2e7f3927827e6d86e0f1", "filename": "src/helpers.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -33,13 +33,13 @@ impl<Tag> ScalarExt for ScalarMaybeUndef<Tag> {\n pub trait EvalContextExt<'tcx> {\n     fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>>;\n \n-    /// Visit the memory covered by `place` that is frozen -- i.e., NOT\n-    /// what is inside an `UnsafeCell`.\n-    fn visit_frozen(\n+    /// Visit the memory covered by `place`, sensitive to freezing:  The 3rd parameter\n+    /// will be true if this is frozen, false if this is in an `UnsafeCell`.\n+    fn visit_freeze_sensitive(\n         &self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n-        action: impl FnMut(Pointer<Borrow>, Size) -> EvalResult<'tcx>,\n+        action: impl FnMut(Pointer<Borrow>, Size, bool) -> EvalResult<'tcx>,\n     ) -> EvalResult<'tcx>;\n }\n \n@@ -79,13 +79,11 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             })\n     }\n \n-    /// Visit the memory covered by `place` that is frozen -- i.e., NOT\n-    /// what is inside an `UnsafeCell`.\n-    fn visit_frozen(\n+    fn visit_freeze_sensitive(\n         &self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n-        mut frozen_action: impl FnMut(Pointer<Borrow>, Size) -> EvalResult<'tcx>,\n+        mut action: impl FnMut(Pointer<Borrow>, Size, bool) -> EvalResult<'tcx>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"visit_frozen(place={:?}, size={:?})\", *place, size);\n         debug_assert_eq!(size,\n@@ -99,18 +97,29 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         let mut end_ptr = place.ptr;\n         // Called when we detected an `UnsafeCell` at the given offset and size.\n         // Calls `action` and advances `end_ptr`.\n-        let mut unsafe_cell_action = |unsafe_cell_offset, unsafe_cell_size| {\n+        let mut unsafe_cell_action = |unsafe_cell_ptr: Scalar<Borrow>, unsafe_cell_size: Size| {\n+            if unsafe_cell_size != Size::ZERO {\n+                debug_assert_eq!(unsafe_cell_ptr.to_ptr().unwrap().alloc_id,\n+                    end_ptr.to_ptr().unwrap().alloc_id);\n+                debug_assert_eq!(unsafe_cell_ptr.to_ptr().unwrap().tag,\n+                    end_ptr.to_ptr().unwrap().tag);\n+            }\n             // We assume that we are given the fields in increasing offset order,\n             // and nothing else changes.\n+            let unsafe_cell_offset = unsafe_cell_ptr.get_ptr_offset(self);\n             let end_offset = end_ptr.get_ptr_offset(self);\n             assert!(unsafe_cell_offset >= end_offset);\n             let frozen_size = unsafe_cell_offset - end_offset;\n             // Everything between the end_ptr and this `UnsafeCell` is frozen.\n             if frozen_size != Size::ZERO {\n-                frozen_action(end_ptr.to_ptr()?, frozen_size)?;\n+                action(end_ptr.to_ptr()?, frozen_size, /*frozen*/true)?;\n+            }\n+            // This `UnsafeCell` is NOT frozen.\n+            if unsafe_cell_size != Size::ZERO {\n+                action(unsafe_cell_ptr.to_ptr()?, unsafe_cell_size, /*frozen*/false)?;\n             }\n             // Update end end_ptr.\n-            end_ptr = end_ptr.ptr_wrapping_offset(frozen_size+unsafe_cell_size, self);\n+            end_ptr = unsafe_cell_ptr.ptr_wrapping_offset(unsafe_cell_size, self);\n             // Done\n             Ok(())\n         };\n@@ -126,7 +135,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                         .unwrap_or_else(|| place.layout.size_and_align());\n                     // Now handle this `UnsafeCell`, unless it is empty.\n                     if unsafe_cell_size != Size::ZERO {\n-                        unsafe_cell_action(place.ptr.get_ptr_offset(self), unsafe_cell_size)\n+                        unsafe_cell_action(place.ptr, unsafe_cell_size)\n                     } else {\n                         Ok(())\n                     }\n@@ -136,7 +145,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         }\n         // The part between the end_ptr and the end of the place is also frozen.\n         // So pretend there is a 0-sized `UnsafeCell` at the end.\n-        unsafe_cell_action(place.ptr.get_ptr_offset(self) + size, Size::ZERO)?;\n+        unsafe_cell_action(place.ptr.ptr_wrapping_offset(size, self), Size::ZERO)?;\n         // Done!\n         return Ok(());\n "}, {"sha": "e23cadfcaf0b764a3a2a5465f7c2d047b21261c4", "filename": "src/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"atomic_load_relaxed\" |\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 let val = self.read_scalar(ptr.into())?; // make sure it fits into a scalar; otherwise it cannot be atomic\n                 self.write_scalar(val, dest)?;\n             }\n@@ -68,7 +68,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"atomic_store_relaxed\" |\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 let val = self.read_scalar(args[1])?; // make sure it fits into a scalar; otherwise it cannot be atomic\n                 self.write_scalar(val, ptr.into())?;\n             }\n@@ -78,18 +78,18 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 let new = self.read_scalar(args[1])?;\n                 let old = self.read_scalar(ptr.into())?;\n                 self.write_scalar(old, dest)?; // old value is returned\n                 self.write_scalar(new, ptr.into())?;\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n-                let expect_old = self.read_immediate(args[1])?; // read as value for the sake of `binary_op_imm()`\n+                let ptr = self.deref_operand(args[0])?;\n+                let expect_old = self.read_immediate(args[1])?; // read as immediate for the sake of `binary_op_imm()`\n                 let new = self.read_scalar(args[2])?;\n-                let old = self.read_immediate(ptr.into())?; // read as value for the sake of `binary_op_imm()`\n+                let old = self.read_immediate(ptr.into())?; // read as immediate for the sake of `binary_op_imm()`\n                 // binary_op_imm will bail if either of them is not a scalar\n                 let (eq, _) = self.binary_op_imm(mir::BinOp::Eq, old, expect_old)?;\n                 let res = Immediate::ScalarPair(old.to_scalar_or_undef(), eq.into());\n@@ -125,7 +125,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"atomic_xsub_rel\" |\n             \"atomic_xsub_acqrel\" |\n             \"atomic_xsub_relaxed\" => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 if !ptr.layout.ty.is_integral() {\n                     return err!(Unimplemented(format!(\"Atomic arithmetic operations only work on integer types\")));\n                 }\n@@ -167,7 +167,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             \"discriminant_value\" => {\n-                let place = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let place = self.deref_operand(args[0])?;\n                 let discr_val = self.read_discriminant(place.into())?.0;\n                 self.write_scalar(Scalar::from_uint(discr_val, dest.layout.size), dest)?;\n             }\n@@ -279,7 +279,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             \"move_val_init\" => {\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 self.copy_op(args[1], ptr.into())?;\n             }\n \n@@ -347,7 +347,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             }\n \n             \"size_of_val\" => {\n-                let mplace = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let mplace = self.deref_operand(args[0])?;\n                 let (size, _) = self.size_and_align_of_mplace(mplace)?\n                     .expect(\"size_of_val called on extern type\");\n                 let ptr_size = self.pointer_size();\n@@ -359,7 +359,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n \n             \"min_align_of_val\" |\n             \"align_of_val\" => {\n-                let mplace = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let mplace = self.deref_operand(args[0])?;\n                 let (_, align) = self.size_and_align_of_mplace(mplace)?\n                     .expect(\"size_of_val called on extern type\");\n                 let ptr_size = self.pointer_size();"}, {"sha": "a0ed7c8e4fdbd5d3c23da38864cf5080dd673696", "filename": "src/lib.rs", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -296,7 +296,6 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n     type AllocExtra = stacked_borrows::Stacks;\n     type PointerTag = Borrow;\n-    const ENABLE_PTR_TRACKING_HOOKS: bool = true;\n \n     type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Borrow, Self::AllocExtra>)>;\n \n@@ -309,16 +308,18 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n         // Some functions are whitelisted until we figure out how to fix them.\n         // We walk up the stack a few frames to also cover their callees.\n-        const WHITELIST: &[&str] = &[\n+        const WHITELIST: &[(&str, &str)] = &[\n             // Uses mem::uninitialized\n-            \"std::ptr::read\",\n-            \"std::sys::windows::mutex::Mutex::\",\n+            (\"std::ptr::read\", \"\"),\n+            (\"std::sys::windows::mutex::Mutex::\", \"\"),\n+            // Should directly take a raw reference\n+            (\"<std::cell::UnsafeCell<T>>\", \"::get\"),\n         ];\n         for frame in ecx.stack().iter()\n             .rev().take(3)\n         {\n             let name = frame.instance.to_string();\n-            if WHITELIST.iter().any(|white| name.starts_with(white)) {\n+            if WHITELIST.iter().any(|(prefix, suffix)| name.starts_with(prefix) && name.ends_with(suffix)) {\n                 return false;\n             }\n         }\n@@ -446,26 +447,6 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         Cow::Owned(alloc)\n     }\n \n-    #[inline(always)]\n-    fn tag_reference(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        place: MPlaceTy<'tcx, Borrow>,\n-        mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Scalar<Borrow>> {\n-        let (size, _) = ecx.size_and_align_of_mplace(place)?\n-            // for extern types, just cover what we can\n-            .unwrap_or_else(|| place.layout.size_and_align());\n-        if !ecx.machine.validate || size == Size::ZERO {\n-            // No tracking\n-            Ok(place.ptr)\n-        } else {\n-            let ptr = place.ptr.to_ptr()?;\n-            let tag = ecx.tag_reference(place, size, mutability.into())?;\n-            Ok(Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag)))\n-        }\n-    }\n-\n-    #[inline(always)]\n     fn tag_dereference(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         place: MPlaceTy<'tcx, Borrow>,\n@@ -474,11 +455,13 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         let (size, _) = ecx.size_and_align_of_mplace(place)?\n             // for extern types, just cover what we can\n             .unwrap_or_else(|| place.layout.size_and_align());\n-        if !ecx.machine.validate || size == Size::ZERO {\n+        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag ||\n+            !Self::enforce_validity(ecx) || size == Size::ZERO\n+        {\n             // No tracking\n             Ok(place.ptr)\n         } else {\n-            let ptr = place.ptr.to_ptr()?;\n+            let ptr = place.ptr.to_ptr()?; // assert this is not a scalar\n             let tag = ecx.tag_dereference(place, size, mutability.into())?;\n             Ok(Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag)))\n         }\n@@ -499,19 +482,46 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    fn escape_to_raw(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: OpTy<'tcx, Self::PointerTag>,\n+    ) -> EvalResult<'tcx> {\n+        // It is tempting to check the type here, but drop glue does EscapeToRaw\n+        // on a raw pointer.\n+        // This is deliberately NOT `deref_operand` as we do not want `tag_dereference`\n+        // to be called!  That would kill the original tag if we got a raw ptr.\n+        let place = ecx.ref_to_mplace(ecx.read_immediate(ptr)?)?;\n+        let (size, _) = ecx.size_and_align_of_mplace(place)?\n+            // for extern types, just cover what we can\n+            .unwrap_or_else(|| place.layout.size_and_align());\n+        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag ||\n+            !ecx.machine.validate || size == Size::ZERO\n+        {\n+            // No tracking, or no retagging. The latter is possible because a dependency of ours\n+            // might be called with different flags than we are, so there are `Retag`\n+            // statements but we do not want to execute them.\n+            Ok(())\n+        } else {\n+            ecx.escape_to_raw(place, size)\n+        }\n+    }\n+\n     #[inline(always)]\n     fn retag(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         fn_entry: bool,\n         place: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n         if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n-            // No tracking, or no retagging. This is possible because a dependency of ours might be\n-            // called with different flags than we are,\n+            // No tracking, or no retagging. The latter is possible because a dependency of ours\n+            // might be called with different flags than we are, so there are `Retag`\n+            // statements but we do not want to execute them.\n             // Also, honor the whitelist in `enforce_validity` because otherwise we might retag\n             // uninitialized data.\n-            return Ok(())\n+             Ok(())\n+        } else {\n+            ecx.retag(fn_entry, place)\n         }\n-        ecx.retag(fn_entry, place)\n     }\n }"}, {"sha": "f564bf9ab7612bd71363ee05bcabbe2fdd2b4f02", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 304, "deletions": 263, "changes": 567, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -1,12 +1,12 @@\n use std::cell::RefCell;\n \n use rustc::ty::{self, layout::Size};\n-use rustc::hir;\n+use rustc::hir::{Mutability, MutMutable, MutImmutable};\n \n use crate::{\n-    EvalResult, MiriEvalContext, HelpersEvalContextExt,\n+    EvalResult, EvalErrorKind, MiriEvalContext, HelpersEvalContextExt,\n     MemoryKind, MiriMemoryKind, RangeMap, AllocId, Allocation, AllocationExtra,\n-    Pointer, PlaceTy, MPlaceTy,\n+    Pointer, MemPlace, Scalar, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n pub type Timestamp = u64;\n@@ -27,15 +27,15 @@ pub enum Borrow {\n \n impl Borrow {\n     #[inline(always)]\n-    pub fn is_shr(self) -> bool {\n+    pub fn is_shared(self) -> bool {\n         match self {\n             Borrow::Shr(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline(always)]\n-    pub fn is_uniq(self) -> bool {\n+    pub fn is_unique(self) -> bool {\n         match self {\n             Borrow::Uniq(_) => true,\n             _ => false,\n@@ -96,27 +96,17 @@ impl Stack {\n     }\n }\n \n-/// What kind of usage of the pointer are we talking about?\n+/// What kind of reference is being used?\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum UsageKind {\n-    /// Write, or create &mut\n-    Write,\n-    /// Read, or create &\n-    Read,\n-    /// Create * (raw ptr)\n+pub enum RefKind {\n+    /// &mut\n+    Unique,\n+    /// & without interior mutability\n+    Frozen,\n+    /// * (raw pointer) or & to `UnsafeCell`\n     Raw,\n }\n \n-impl From<Option<hir::Mutability>> for UsageKind {\n-    fn from(mutbl: Option<hir::Mutability>) -> Self {\n-        match mutbl {\n-            None => UsageKind::Raw,\n-            Some(hir::MutMutable) => UsageKind::Write,\n-            Some(hir::MutImmutable) => UsageKind::Read,\n-        }\n-    }\n-}\n-\n /// Extra global machine state\n #[derive(Clone, Debug)]\n pub struct State {\n@@ -127,6 +117,12 @@ impl State {\n     pub fn new() -> State {\n         State { clock: 0 }\n     }\n+\n+    fn increment_clock(&mut self) -> Timestamp {\n+        let val = self.clock;\n+        self.clock = val + 1;\n+        val\n+    }\n }\n \n /// Extra per-allocation state\n@@ -136,50 +132,45 @@ pub struct Stacks {\n     stacks: RefCell<RangeMap<Stack>>,\n }\n \n-/// Core operations\n+/// Core per-location operations: deref, access, create.\n+/// We need to make at least the following things true:\n+///\n+/// U1: After creating a Uniq, it is at the top (+unfrozen).\n+/// U2: If the top is Uniq (+unfrozen), accesses must be through that Uniq or pop it.\n+/// U3: If an access (deref sufficient?) happens with a Uniq, it requires the Uniq to be in the stack.\n+///\n+/// F1: After creating a &, the parts outside `UnsafeCell` are frozen.\n+/// F2: If a write access happens, it unfreezes.\n+/// F3: If an access (well, a deref) happens with an & outside `UnsafeCell`, it requires the location to still be frozen.\n impl<'tcx> Stack {\n-    /// Check if `bor` could be activated by unfreezing and popping.\n-    /// `is_write` indicates whether this is being used to write (or, equivalently, to\n-    /// borrow as &mut).\n-    /// Returns `Err` if the answer is \"no\"; otherwise the return value indicates what to\n-    /// do: With `Some(n)` you need to unfreeze, and then additionally pop `n` items.\n-    fn reactivatable(&self, bor: Borrow, is_write: bool) -> Result<Option<usize>, String> {\n-        // Check if we can match the frozen \"item\".  Not possible on writes!\n-        if !is_write {\n-            // For now, we do NOT check the timestamp.  That might be surprising, but\n-            // we cannot even notice when a location should be frozen but is not!\n-            // Those checks are both done in `tag_dereference`, where we have type information.\n-            // Either way, it is crucial that the frozen \"item\" matches raw pointers:\n-            // Reading through a raw should not unfreeze.\n-            match (self.frozen_since, bor) {\n-                (Some(_), Borrow::Shr(_)) => {\n-                    return Ok(None)\n+    /// Deref `bor`: Check if the location is frozen and the tag in the stack.\n+    /// This dos *not* constitute an access!  \"Deref\" refers to the `*` operator\n+    /// in Rust, and includs cases like `&*x` or `(*x).foo` where no or only part\n+    /// of the memory actually gets accessed.  Also we cannot know if we are\n+    /// going to read or write.\n+    /// Returns the index of the item we matched, `None` if it was the frozen one.\n+    /// `kind` indicates which kind of reference is being dereferenced.\n+    fn deref(&self, bor: Borrow, kind: RefKind) -> Result<Option<usize>, String> {\n+        // Checks related to freezing\n+        match bor {\n+            Borrow::Shr(Some(bor_t)) if kind == RefKind::Frozen => {\n+                // We need the location to be frozen. This ensures F3.\n+                let frozen = self.frozen_since.map_or(false, |itm_t| itm_t <= bor_t);\n+                return if frozen { Ok(None) } else {\n+                    Err(format!(\"Location is not frozen long enough\"))\n                 }\n-                _ => {},\n             }\n+            Borrow::Shr(_) if self.frozen_since.is_some() => {\n+                return Ok(None) // Shared deref to frozen location, looking good\n+            }\n+            _ => {} // Not sufficient, go on looking.\n         }\n-        // See if we can find this borrow.\n-        for (idx, &itm) in self.borrows.iter().rev().enumerate() {\n-            // Check borrow and stack item for compatibility.\n+        // If we got here, we have to look for our item in the stack.\n+        for (idx, &itm) in self.borrows.iter().enumerate().rev() {\n             match (itm, bor) {\n-                (BorStackItem::FnBarrier(_), _) => {\n-                    return Err(format!(\"Trying to reactivate a borrow ({:?}) that lives \\\n-                                        behind a barrier\", bor))\n-                }\n+                (BorStackItem::FnBarrier(_), _) => break,\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n-                    // Found matching unique item.\n-                    if !is_write {\n-                        // As a special case, if we are reading and since we *did* find the `Uniq`,\n-                        // we try to pop less: We are happy with making a `Shr` or `Frz` active;\n-                        // that one will not mind concurrent reads.\n-                        match self.reactivatable(Borrow::default(), is_write) {\n-                            // If we got something better that `idx`, use that\n-                            Ok(None) => return Ok(None),\n-                            Ok(Some(shr_idx)) if shr_idx <= idx => return Ok(Some(shr_idx)),\n-                            // Otherwise just go on.\n-                            _ => {},\n-                        }\n-                    }\n+                    // Found matching unique item.  This satisfies U3.\n                     return Ok(Some(idx))\n                 }\n                 (BorStackItem::Shr, Borrow::Shr(_)) => {\n@@ -190,153 +181,170 @@ impl<'tcx> Stack {\n                 _ => {}\n             }\n         }\n-        // Nothing to be found.\n-        Err(format!(\"Borrow-to-reactivate {:?} does not exist on the stack\", bor))\n+        // If we got here, we did not find our item.  We have to error to satisfy U3.\n+        Err(format!(\n+            \"Borrow being dereferenced ({:?}) does not exist on the stack, or is guarded by a barrier\",\n+            bor\n+        ))\n     }\n \n-    /// Reactive `bor` for this stack.  `is_write` indicates whether this is being\n-    /// used to write (or, equivalently, to borrow as &mut).\n-    fn reactivate(&mut self, bor: Borrow, is_write: bool) -> EvalResult<'tcx> {\n-        let mut pop = match self.reactivatable(bor, is_write) {\n-            Ok(None) => return Ok(()),\n-            Ok(Some(pop)) => pop,\n-            Err(err) => return err!(MachineError(err)),\n-        };\n-        // Pop what `reactivatable` told us to pop. Always unfreeze.\n+    /// Perform an actual memory access using `bor`.  We do not know any types here\n+    /// or whether things should be frozen, but we *do* know if this is reading\n+    /// or writing.\n+    fn access(&mut self, bor: Borrow, is_write: bool) -> EvalResult<'tcx> {\n+        // Check if we can match the frozen \"item\".\n+        // Not possible on writes!\n         if self.is_frozen() {\n-            trace!(\"reactivate: Unfreezing\");\n+            if !is_write {\n+                // When we are frozen, we just accept all reads.  No harm in this.\n+                // The deref already checked that `Uniq` items are in the stack, and that\n+                // the location is frozen if it should be.\n+                return Ok(());\n+            }\n+            trace!(\"access: Unfreezing\");\n         }\n+        // Unfreeze on writes.  This ensures F2.\n         self.frozen_since = None;\n-        while pop > 0 {\n-            let itm = self.borrows.pop().unwrap();\n-            trace!(\"reactivate: Popping {:?}\", itm);\n-            pop -= 1;\n+        // Pop the stack until we have something matching.\n+        while let Some(&itm) = self.borrows.last() {\n+            match (itm, bor) {\n+                (BorStackItem::FnBarrier(_), _) => break,\n+                (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n+                    // Found matching unique item.\n+                    return Ok(())\n+                }\n+                (BorStackItem::Shr, _) if !is_write => {\n+                    // When reading, everything can use a shared item!\n+                    // We do not want to do this when writing: Writing to an `&mut`\n+                    // should reaffirm its exclusivity (i.e., make sure it is\n+                    // on top of the stack).\n+                    return Ok(())\n+                }\n+                (BorStackItem::Shr, Borrow::Shr(_)) => {\n+                    // Found matching shared item.\n+                    return Ok(())\n+                }\n+                _ => {\n+                    // Pop this.  This ensures U2.\n+                    let itm = self.borrows.pop().unwrap();\n+                    trace!(\"access: Popping {:?}\", itm);\n+                }\n+            }\n         }\n-        Ok(())\n+        // If we got here, we did not find our item.\n+        err!(MachineError(format!(\n+            \"Borrow being accessed ({:?}) does not exist on the stack, or is guarded by a barrier\",\n+            bor\n+        )))\n     }\n \n     /// Initiate `bor`; mostly this means pushing.\n     /// This operation cannot fail; it is up to the caller to ensure that the precondition\n-    /// is met: We cannot push onto frozen stacks.\n-    fn initiate(&mut self, bor: Borrow) {\n-        if let Some(_) = self.frozen_since {\n-            // \"Pushing\" a Shr or Frz on top is redundant.\n-            match bor {\n-                Borrow::Uniq(_) => bug!(\"Trying to create unique ref to frozen location\"),\n-                Borrow::Shr(_) => trace!(\"initiate: New shared ref to frozen location is a NOP\"),\n-            }\n-        } else {\n-            // Just push.\n-            let itm = match bor {\n-                Borrow::Uniq(t) => BorStackItem::Uniq(t),\n-                Borrow::Shr(_) if *self.borrows.last().unwrap() == BorStackItem::Shr => {\n-                    // Optimization: Don't push a Shr onto a Shr.\n-                    trace!(\"initiate: New shared ref to already shared location is a NOP\");\n-                    return\n-                },\n-                Borrow::Shr(_) => BorStackItem::Shr,\n-            };\n-            trace!(\"initiate: Pushing {:?}\", itm);\n-            self.borrows.push(itm)\n+    /// is met: We cannot push `Uniq` onto frozen stacks.\n+    /// `kind` indicates which kind of reference is being created.\n+    fn create(&mut self, bor: Borrow, kind: RefKind) {\n+        // First, push the item.  We do this even if we will later freeze, because we\n+        // will allow mutation of shared data at the expense of unfreezing.\n+        if self.frozen_since.is_some() {\n+            // A frozen location, this should be impossible!\n+            bug!(\"We should never try pushing to a frozen stack\");\n         }\n-    }\n-\n-    /// Check if this location is \"frozen enough\".\n-    fn check_frozen(&self, bor_t: Timestamp) -> EvalResult<'tcx> {\n-        let frozen = self.frozen_since.map_or(false, |itm_t| itm_t <= bor_t);\n-        if !frozen {\n-            err!(MachineError(format!(\"Location is not frozen long enough\")))\n+        // First, push.\n+        let itm = match bor {\n+            Borrow::Uniq(t) => BorStackItem::Uniq(t),\n+            Borrow::Shr(_) => BorStackItem::Shr,\n+        };\n+        if *self.borrows.last().unwrap() == itm {\n+            assert!(bor.is_shared());\n+            trace!(\"create: Sharing a shared location is a NOP\");\n         } else {\n-            Ok(())\n+            // This ensures U1.\n+            trace!(\"create: Pushing {:?}\", itm);\n+            self.borrows.push(itm);\n         }\n-    }\n-\n-    /// Freeze this location, since `bor_t`.\n-    fn freeze(&mut self, bor_t: Timestamp) {\n-        if let Some(itm_t) = self.frozen_since {\n-            assert!(itm_t <= bor_t, \"Trying to freeze shorter than it was frozen?\");\n-        } else {\n-            trace!(\"Freezing\");\n+        // Then, maybe freeze.  This is part 2 of ensuring F1.\n+        if kind == RefKind::Frozen {\n+            let bor_t = match bor {\n+                Borrow::Shr(Some(t)) => t,\n+                _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n+            };\n+            trace!(\"create: Freezing\");\n             self.frozen_since = Some(bor_t);\n         }\n     }\n }\n \n-impl State {\n-    fn increment_clock(&mut self) -> Timestamp {\n-        let val = self.clock;\n-        self.clock = val + 1;\n-        val\n-    }\n-}\n-\n-/// Higher-level operations\n+/// Higher-level per-location operations: deref, access, reborrow.\n impl<'tcx> Stacks {\n-    /// The single most important operation: Make sure that using `ptr` is okay,\n-    /// and if `new_bor` is present then make that the new current borrow.\n-    fn use_and_maybe_re_borrow(\n+    /// Check that this stack is fine with being dereferenced\n+    fn deref(\n         &self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        usage: UsageKind,\n-        new_bor: Option<Borrow>,\n+        kind: RefKind,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"use_and_maybe_re_borrow of tag {:?} as {:?}, new {:?}: {:?}, size {}\",\n-            ptr.tag, usage, new_bor, ptr, size.bytes());\n+        trace!(\"deref for tag {:?} as {:?}: {:?}, size {}\",\n+            ptr.tag, kind, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n+        // We need `iter_mut` because `iter` would skip gaps!\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.reactivate(ptr.tag, usage == UsageKind::Write)?;\n-            if let Some(new_bor) = new_bor {\n-                stack.initiate(new_bor);\n-            }\n+            stack.deref(ptr.tag, kind).map_err(EvalErrorKind::MachineError)?;\n         }\n         Ok(())\n     }\n \n-    /// Freeze the given memory range.\n-    fn freeze(\n+    /// `ptr` got used, reflect that in the stack.\n+    fn access(\n         &self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        bor_t: Timestamp\n+        is_write: bool,\n     ) -> EvalResult<'tcx> {\n+        trace!(\"{} access of tag {:?}: {:?}, size {}\",\n+            if is_write { \"read\" } else { \"write\" },\n+            ptr.tag, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.freeze(bor_t);\n+            stack.access(ptr.tag, is_write)?;\n         }\n         Ok(())\n     }\n \n-    /// Check that this stack is fine with being dereferenced\n-    fn check_deref(\n+    /// Reborrow the given pointer to the new tag for the given kind of reference.\n+    fn reborrow(\n         &self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n+        new_bor: Borrow,\n+        new_kind: RefKind,\n     ) -> EvalResult<'tcx> {\n+        assert_eq!(new_bor.is_unique(), new_kind == RefKind::Unique);\n+        trace!(\"reborrow for tag {:?} to {:?} as {:?}: {:?}, size {}\",\n+            ptr.tag, new_bor, new_kind, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n-        // We need `iter_mut` because `iter` would skip gaps!\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            // Conservatively assume we will just read\n-            if let Err(err) = stack.reactivatable(ptr.tag, /*is_write*/false) {\n-                return err!(MachineError(format!(\n-                    \"Encountered reference with non-reactivatable tag: {}\",\n-                    err\n-                )))\n+            // Access source `ptr`, create new ref.\n+            let ptr_idx = stack.deref(ptr.tag, new_kind).map_err(EvalErrorKind::MachineError)?;\n+            // If we can deref the new tag already, and if that tag lives higher on\n+            // the stack than the one we come from, just use that.\n+            // IOW, we check if `new_bor` *already* is \"derived from\" `ptr.tag`.\n+            // This also checks frozenness, if required.\n+            let bor_redundant = match (ptr_idx, stack.deref(new_bor, new_kind)) {\n+                // If the new borrow works with the frozen item, or else if it lives\n+                // above the old one in the stack, our job here is done.\n+                (_, Ok(None)) => true,\n+                (Some(ptr_idx), Ok(Some(new_idx))) if new_idx >= ptr_idx => true,\n+                // Otherwise we need to create a new borrow.\n+                _ => false,\n+            };\n+            if bor_redundant {\n+                assert!(new_bor.is_shared(), \"A unique reborrow can never be redundant\");\n+                trace!(\"reborrow is redundant\");\n+                continue;\n             }\n-        }\n-        Ok(())\n-    }\n-\n-    /// Check that this stack is appropriately frozen\n-    fn check_frozen(\n-        &self,\n-        ptr: Pointer<Borrow>,\n-        size: Size,\n-        bor_t: Timestamp\n-    ) -> EvalResult<'tcx> {\n-        let mut stacks = self.stacks.borrow_mut();\n-        for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.check_frozen(bor_t)?;\n+            // We need to do some actual work.\n+            stack.access(ptr.tag, new_kind == RefKind::Unique)?;\n+            stack.create(new_bor, new_kind);\n         }\n         Ok(())\n     }\n@@ -350,8 +358,7 @@ impl AllocationExtra<Borrow> for Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        // Reads behave exactly like the first half of a reborrow-to-shr\n-        alloc.extra.use_and_maybe_re_borrow(ptr, size, UsageKind::Read, None)\n+        alloc.extra.access(ptr, size, /*is_write*/false)\n     }\n \n     #[inline(always)]\n@@ -360,8 +367,7 @@ impl AllocationExtra<Borrow> for Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        // Writes behave exactly like the first half of a reborrow-to-mut\n-        alloc.extra.use_and_maybe_re_borrow(ptr, size, UsageKind::Write, None)\n+        alloc.extra.access(ptr, size, /*is_write*/true)\n     }\n \n     #[inline(always)]\n@@ -371,7 +377,7 @@ impl AllocationExtra<Borrow> for Stacks {\n         size: Size,\n     ) -> EvalResult<'tcx> {\n         // This is like mutating\n-        alloc.extra.use_and_maybe_re_borrow(ptr, size, UsageKind::Write, None)\n+        alloc.extra.access(ptr, size, /*is_write*/true)\n         // FIXME: Error out of there are any barriers?\n     }\n }\n@@ -395,18 +401,11 @@ impl<'tcx> Stacks {\n \n \n pub trait EvalContextExt<'tcx> {\n-    fn tag_reference(\n-        &mut self,\n-        place: MPlaceTy<'tcx, Borrow>,\n-        size: Size,\n-        usage: UsageKind,\n-    ) -> EvalResult<'tcx, Borrow>;\n-\n     fn tag_dereference(\n         &self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n-        usage: UsageKind,\n+        mutability: Option<Mutability>,\n     ) -> EvalResult<'tcx, Borrow>;\n \n     fn tag_new_allocation(\n@@ -415,87 +414,97 @@ pub trait EvalContextExt<'tcx> {\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> Borrow;\n \n+    /// Retag an indidual pointer, returning the retagged version.\n+    fn reborrow(\n+        &mut self,\n+        ptr: ImmTy<'tcx, Borrow>,\n+        mutbl: Mutability,\n+    ) -> EvalResult<'tcx, Immediate<Borrow>>;\n+\n     fn retag(\n         &mut self,\n         fn_entry: bool,\n         place: PlaceTy<'tcx, Borrow>\n     ) -> EvalResult<'tcx>;\n-}\n \n-impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n-    /// Called for place-to-value conversion.\n-    fn tag_reference(\n+    fn escape_to_raw(\n         &mut self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n-        usage: UsageKind,\n-    ) -> EvalResult<'tcx, Borrow> {\n-        let ptr = place.ptr.to_ptr()?;\n-        let time = self.machine.stacked_borrows.increment_clock();\n-        let new_bor = match usage {\n-            UsageKind::Write => Borrow::Uniq(time),\n-            UsageKind::Read => Borrow::Shr(Some(time)),\n-            UsageKind::Raw => Borrow::Shr(None),\n-        };\n-        trace!(\"tag_reference: Creating new reference ({:?}) for {:?} (pointee {}): {:?}\",\n-            usage, ptr, place.layout.ty, new_bor);\n-\n-        // Update the stacks.  First create the new ref as usual, then maybe freeze stuff.\n-        self.memory().check_bounds(ptr, size, false)?;\n-        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        alloc.extra.use_and_maybe_re_borrow(ptr, size, usage, Some(new_bor))?;\n-        // Maybe freeze stuff\n-        if let Borrow::Shr(Some(bor_t)) = new_bor {\n-            self.visit_frozen(place, size, |frz_ptr, size| {\n-                debug_assert_eq!(frz_ptr.alloc_id, ptr.alloc_id);\n-                // Be frozen!\n-                alloc.extra.freeze(frz_ptr, size, bor_t)\n-            })?;\n-        }\n+    ) -> EvalResult<'tcx>;\n+}\n \n-        Ok(new_bor)\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n+    fn tag_new_allocation(\n+        &mut self,\n+        id: AllocId,\n+        kind: MemoryKind<MiriMemoryKind>,\n+    ) -> Borrow {\n+        let time = match kind {\n+            MemoryKind::Stack => {\n+                // New unique borrow. This `Uniq` is not accessible by the program,\n+                // so it will only ever be used when using the local directly (i.e.,\n+                // not through a pointer).  IOW, whenever we directly use a local this will pop\n+                // everything else off the stack, invalidating all previous pointers\n+                // and, in particular, *all* raw pointers.  This subsumes the explicit\n+                // `reset` which the blog post [1] says to perform when accessing a local.\n+                //\n+                // [1] https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html\n+                self.machine.stacked_borrows.increment_clock()\n+            }\n+            _ => {\n+                // Nothing to do for everything else\n+                return Borrow::default()\n+            }\n+        };\n+        // Make this the active borrow for this allocation\n+        let alloc = self.memory_mut().get_mut(id).expect(\"This is a new allocation, it must still exist\");\n+        let size = Size::from_bytes(alloc.bytes.len() as u64);\n+        alloc.extra.first_item(BorStackItem::Uniq(time), size);\n+        Borrow::Uniq(time)\n     }\n \n-    /// Called for value-to-place conversion.\n+    /// Called for value-to-place conversion.  `mutability` is `None` for raw pointers.\n     ///\n     /// Note that this does NOT mean that all this memory will actually get accessed/referenced!\n     /// We could be in the middle of `&(*var).1`.\n     fn tag_dereference(\n         &self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n-        usage: UsageKind,\n+        mutability: Option<Mutability>,\n     ) -> EvalResult<'tcx, Borrow> {\n+        trace!(\"tag_dereference: Accessing {} reference for {:?} (pointee {})\",\n+            if let Some(mutability) = mutability { format!(\"{:?}\", mutability) } else { format!(\"raw\") },\n+            place.ptr, place.layout.ty);\n         let ptr = place.ptr.to_ptr()?;\n-        trace!(\"tag_dereference: Accessing reference ({:?}) for {:?} (pointee {})\",\n-            usage, ptr, place.layout.ty);\n         // In principle we should not have to do anything here.  However, with transmutes involved,\n-        // it can happen that the tag of `ptr` does not actually match `usage`, and we\n+        // it can happen that the tag of `ptr` does not actually match `mutability`, and we\n         // should adjust for that.\n         // Notably, the compiler can introduce such transmutes by optimizing away `&[mut]*`.\n         // That can transmute a raw ptr to a (shared/mut) ref, and a mut ref to a shared one.\n-        match (usage, ptr.tag) {\n-            (UsageKind::Raw, _) => {\n-                // Don't use the tag, this is a raw access!  Even if there is a tag,\n-                // that means transmute happened and we ignore the tag.\n+        match (mutability, ptr.tag) {\n+            (None, _) => {\n+                // Don't use the tag, this is a raw access!  They should happen tagless.\n+                // This is needed for `*mut` to make any sense: Writes *do* enforce the\n+                // `Uniq` tag to be up top, but we must make sure raw writes do not do that.\n+                // This does mean, however, that `&*foo` is *not* a NOP *if* `foo` is a raw ptr.\n                 // Also don't do any further validation, this is raw after all.\n                 return Ok(Borrow::default());\n             }\n-            (UsageKind::Write, Borrow::Uniq(_)) |\n-            (UsageKind::Read, Borrow::Shr(_)) => {\n+            (Some(MutMutable), Borrow::Uniq(_)) |\n+            (Some(MutImmutable), Borrow::Shr(_)) => {\n                 // Expected combinations.  Nothing to do.\n             }\n-            (UsageKind::Write, Borrow::Shr(None)) => {\n-                // Raw transmuted to mut ref.  Keep this as raw access.\n-                // We cannot reborrow here; there might be a raw in `&(*var).1` where\n-                // `var` is an `&mut`.  The other field of the struct might be already frozen,\n-                // also using `var`, and that would be okay.\n+            (Some(MutMutable), Borrow::Shr(None)) => {\n+                // Raw transmuted to mut ref.  This is something real unsafe code does.\n+                // We cannot reborrow here because we do not want to mutate state on a deref.\n             }\n-            (UsageKind::Read, Borrow::Uniq(_)) => {\n+            (Some(MutImmutable), Borrow::Uniq(_)) => {\n                 // A mut got transmuted to shr.  Can happen even from compiler transformations:\n                 // `&*x` gets optimized to `x` even when `x` is a `&mut`.\n             }\n-            (UsageKind::Write, Borrow::Shr(Some(_))) => {\n+            (Some(MutMutable), Borrow::Shr(Some(_))) => {\n                 // This is just invalid: A shr got transmuted to a mut.\n                 // If we ever allow this, we have to consider what we do when a turn a\n                 // `Raw`-tagged `&mut` into a raw pointer pointing to a frozen location.\n@@ -505,50 +514,87 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n             }\n         }\n \n-        // If we got here, we do some checking, *but* we leave the tag unchanged.\n+        // Get the allocation\n         self.memory().check_bounds(ptr, size, false)?;\n         let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        alloc.extra.check_deref(ptr, size)?;\n-        // Maybe check frozen stuff\n-        if let Borrow::Shr(Some(bor_t)) = ptr.tag {\n-            self.visit_frozen(place, size, |frz_ptr, size| {\n-                debug_assert_eq!(frz_ptr.alloc_id, ptr.alloc_id);\n-                // Are you frozen?\n-                alloc.extra.check_frozen(frz_ptr, size, bor_t)\n+        // If we got here, we do some checking, *but* we leave the tag unchanged.\n+        if let Borrow::Shr(Some(_)) = ptr.tag {\n+            assert_eq!(mutability, Some(MutImmutable));\n+            // We need a frozen-sensitive check\n+            self.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n+                let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n+                alloc.extra.deref(cur_ptr, size, kind)\n             })?;\n+        } else {\n+            // Just treat this as one big chunk\n+            let kind = if mutability == Some(MutMutable) { RefKind::Unique } else { RefKind::Raw };\n+            alloc.extra.deref(ptr, size, kind)?;\n         }\n \n         // All is good, and do not change the tag\n         Ok(ptr.tag)\n     }\n \n-    fn tag_new_allocation(\n+    /// The given place may henceforth be accessed through raw pointers.\n+    fn escape_to_raw(\n         &mut self,\n-        id: AllocId,\n-        kind: MemoryKind<MiriMemoryKind>,\n-    ) -> Borrow {\n-        let time = match kind {\n-            MemoryKind::Stack => {\n-                // New unique borrow. This `Uniq` is not accessible by the program,\n-                // so it will only ever be used when using the local directly (i.e.,\n-                // not through a pointer).  IOW, whenever we directly use a local this will pop\n-                // everything else off the stack, invalidating all previous pointers\n-                // and, in particular, *all* raw pointers.  This subsumes the explicit\n-                // `reset` which the blog post [1] says to perform when accessing a local.\n-                //\n-                // [1] https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html\n-                self.machine.stacked_borrows.increment_clock()\n-            }\n-            _ => {\n-                // Nothing to do for everything else\n-                return Borrow::default()\n-            }\n+        place: MPlaceTy<'tcx, Borrow>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"escape_to_raw: {:?} is now accessible by raw pointers\", *place);\n+        // Get the allocation\n+        let ptr = place.ptr.to_ptr()?;\n+        self.memory().check_bounds(ptr, size, false)?; // `ptr_dereference` wouldn't do any checks if this is a raw ptr\n+        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        // Re-borrow to raw.  This is a NOP for shared borrows, but we do not know the borrow\n+        // type here and that's also okay.  Freezing does not matter here.\n+        alloc.extra.reborrow(ptr, size, Borrow::default(), RefKind::Raw)\n+    }\n+\n+    fn reborrow(\n+        &mut self,\n+        val: ImmTy<'tcx, Borrow>,\n+        mutbl: Mutability,\n+    ) -> EvalResult<'tcx, Immediate<Borrow>> {\n+        // We want a place for where the ptr *points to*, so we get one.\n+        let place = self.ref_to_mplace(val)?;\n+        let size = self.size_and_align_of_mplace(place)?\n+            .map(|(size, _)| size)\n+            .unwrap_or_else(|| place.layout.size);\n+        if size == Size::ZERO {\n+            // Nothing to do for ZSTs.\n+            return Ok(*val);\n+        }\n+\n+        // Prepare to re-borrow this place.\n+        let ptr = place.ptr.to_ptr()?;\n+        let time = self.machine.stacked_borrows.increment_clock();\n+        let new_bor = match mutbl {\n+            MutMutable => Borrow::Uniq(time),\n+            MutImmutable => Borrow::Shr(Some(time)),\n         };\n-        // Make this the active borrow for this allocation\n-        let alloc = self.memory_mut().get_mut(id).expect(\"This is a new allocation, it must still exist\");\n-        let size = Size::from_bytes(alloc.bytes.len() as u64);\n-        alloc.extra.first_item(BorStackItem::Uniq(time), size);\n-        Borrow::Uniq(time)\n+        trace!(\"reborrow: Creating new {:?} reference for {:?} (pointee {}): {:?}\",\n+            mutbl, ptr, place.layout.ty, new_bor);\n+\n+        // Get the allocation.  It might not be mutable, so we cannot use `get_mut`.\n+        self.memory().check_bounds(ptr, size, false)?;\n+        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        // Update the stacks.\n+        if mutbl == MutImmutable {\n+            // Shared reference. We need a frozen-sensitive reborrow.\n+            self.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n+                let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n+                alloc.extra.reborrow(cur_ptr, size, new_bor, kind)\n+            })?;\n+        } else {\n+            // Mutable reference. Just treat this as one big chunk.\n+            alloc.extra.reborrow(ptr, size, new_bor, RefKind::Unique)?;\n+        }\n+\n+        // Return new ptr\n+        let new_ptr = Pointer::new_with_tag(ptr.alloc_id, ptr.offset, new_bor);\n+        let new_place = MemPlace { ptr: Scalar::Ptr(new_ptr), ..*place };\n+        Ok(new_place.to_ref())\n     }\n \n     fn retag(\n@@ -558,19 +604,14 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n     ) -> EvalResult<'tcx> {\n         // For now, we only retag if the toplevel type is a reference.\n         // TODO: Recurse into structs and enums, sharing code with validation.\n+        // TODO: Honor `fn_entry`.\n         let mutbl = match place.layout.ty.sty {\n             ty::Ref(_, _, mutbl) => mutbl, // go ahead\n-            _ => return Ok(()), // don't do a thing\n+            _ => return Ok(()), // do nothing, for now\n         };\n-        // We want to reborrow the reference stored there. This will call the hooks\n-        // above.  First deref, which will call `tag_dereference`.\n-        // (This is somewhat redundant because validation already did the same thing,\n-        // but what can you do.)\n+        // Retag the pointer and write it back.\n         let val = self.read_immediate(self.place_to_op(place)?)?;\n-        let dest = self.ref_to_mplace(val)?;\n-        // Now put a new ref into the old place, which will call `tag_reference`.\n-        // FIXME: Honor `fn_entry`!\n-        let val = self.create_ref(dest, Some(mutbl))?;\n+        let val = self.reborrow(val, mutbl)?;\n         self.write_immediate(val, place)?;\n         Ok(())\n     }"}, {"sha": "8e8912c81fe902de72389ff88349ea44c9f9e536", "filename": "tests/compile-fail-fullmir/copy_nonoverlapping.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fcopy_nonoverlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fcopy_nonoverlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fcopy_nonoverlapping.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/copy_nonoverlapping.rs"}, {"sha": "14a85ecd8947cd2c051013fe7678547f4c5dc448", "filename": "tests/compile-fail-fullmir/memleak_rc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fmemleak_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fmemleak_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fmemleak_rc.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/memleak_rc.rs"}, {"sha": "092f3f09ed196dff9f93b2675fb67221d05f744e", "filename": "tests/compile-fail-fullmir/stacked_borrows/alias_through_mutation.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Falias_through_mutation.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -11,5 +11,5 @@ fn main() {\n     retarget(&mut target_alias, target);\n     // now `target_alias` points to the same thing as `target`\n     *target = 13;\n-    let _val = *target_alias; //~ ERROR reference with non-reactivatable tag\n+    let _val = *target_alias; //~ ERROR does not exist on the stack\n }", "previous_filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs"}, {"sha": "e812e13e702cadbfc5dd1dece7e0ba011b0720e2", "filename": "tests/compile-fail-fullmir/stacked_borrows/aliasing_mut1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut1.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/stacked_borrows/aliasing_mut1.rs"}, {"sha": "36ebcc2b4ac6fae57a657af0c9b9c1dfdeda47a3", "filename": "tests/compile-fail-fullmir/stacked_borrows/aliasing_mut2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut2.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/stacked_borrows/aliasing_mut2.rs"}, {"sha": "ad50fbd61b451f0d1a8d1cd05b24afe11a8eff8c", "filename": "tests/compile-fail-fullmir/stacked_borrows/aliasing_mut3.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut3.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/stacked_borrows/aliasing_mut3.rs"}, {"sha": "a0f0a3cf9753a1abbb6fff23ded22eeb41f0e989", "filename": "tests/compile-fail-fullmir/stacked_borrows/aliasing_mut4.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut4.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/stacked_borrows/aliasing_mut4.rs"}, {"sha": "2f3d0793f63e1535cb7b7dc5d333a41463084f82", "filename": "tests/compile-fail-fullmir/stacked_borrows/buggy_as_mut_slice.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -1,4 +1,4 @@\n-#![allow(unused_variables)]\n+// error-pattern: mutable reference with frozen tag\n \n mod safe {\n     use std::slice::from_raw_parts_mut;\n@@ -12,8 +12,10 @@ mod safe {\n \n fn main() {\n     let v = vec![0,1,2];\n-    let v1 = safe::as_mut_slice(&v);\n+    let _v1 = safe::as_mut_slice(&v);\n+/*\n     let v2 = safe::as_mut_slice(&v);\n-    v1[1] = 5; //~ ERROR does not exist on the stack\n+    v1[1] = 5;\n     v1[1] = 6;\n+*/\n }", "previous_filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs"}, {"sha": "711544f80149c28c3cf4cc3a6fc181a4f043157c", "filename": "tests/compile-fail-fullmir/stacked_borrows/buggy_split_at_mut.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -11,7 +11,6 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            //~^ ERROR does not exist on the stack\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }\n@@ -20,6 +19,7 @@ mod safe {\n fn main() {\n     let mut array = [1,2,3,4];\n     let (a, b) = safe::split_at_mut(&mut array, 0);\n+    //~^ ERROR does not exist on the stack\n     a[1] = 5;\n     b[1] = 6;\n }", "previous_filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs"}, {"sha": "dbaccae8827211b0599a09fcf258c103183a1c36", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_read1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read1.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/stacked_borrows/illegal_read1.rs"}, {"sha": "2da755d9aabc137206a1cc8eedc4d50a91dbb2e4", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_read2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read2.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/stacked_borrows/illegal_read2.rs"}, {"sha": "b0da0511dee3fb52a748b76b39cbd616ae2a5c32", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_read3.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read3.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -0,0 +1,29 @@\n+#![feature(untagged_unions)]\n+// A callee may not read the destination of our `&mut` without\n+// us noticing.\n+// Thise code got carefully checked to not introduce any reborrows\n+// that are not explicit in the source.  Let's hope the compiler does not break this later!\n+\n+use std::mem;\n+\n+fn main() {\n+    let mut x: i32 = 15;\n+    let xref1 = &mut x;\n+    let xref1_sneaky: usize = unsafe { mem::transmute_copy(&xref1) };\n+    let xref2 = &mut *xref1; // derived from xref1, so using raw is still okay...\n+    callee(xref1_sneaky);\n+    let _val = *xref2; // ...but any use of it will invalidate our ref.\n+    //~^ ERROR: does not exist on the stack\n+}\n+\n+fn callee(xref1: usize) {\n+    // Transmuting through a union to avoid retagging\n+    union UsizeToRef {\n+        from: usize,\n+        to: &'static mut i32,\n+    }\n+    let xref1 = UsizeToRef { from: xref1 };\n+    // Doing the deref and the transmute (through the union) in the same place expression\n+    // should avoid retagging.\n+    let _val = unsafe { *xref1.to };\n+}"}, {"sha": "c86ec1286daad8121b41b45e1672521e69e91f53", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_read4.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read4.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -0,0 +1,9 @@\n+// Using a raw invalidates derived `&mut` even for reading.\n+fn main() {\n+    let mut x = 2;\n+    let xref1 = &mut x;\n+    let xraw = xref1 as *mut _;\n+    let xref2 = unsafe { &mut *xraw };\n+    let _val = unsafe { *xraw }; // use the raw again, this invalidates xref2 *even* with the special read except for uniq refs\n+    let _illegal = *xref2; //~ ERROR does not exist on the stack\n+}"}, {"sha": "863649a47b5ef374d74d4fc21fb2f672d70694c9", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_read5.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_read5.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -0,0 +1,16 @@\n+// We *can* have aliasing &RefCell<T> and &mut T, but we cannot read through the former.\n+// Else we couldn't optimize based on the assumption that `xref` below is truly unique.\n+\n+use std::cell::RefCell;\n+use std::{mem, ptr};\n+\n+fn main() {\n+    let rc = RefCell::new(0);\n+    let mut refmut = rc.borrow_mut();\n+    let xref: &mut i32 = &mut *refmut;\n+    let xshr = &rc; // creating this is okay\n+    let _val = *xref; // we can even still use our mutable reference\n+    mem::forget(unsafe { ptr::read(xshr) }); // but after reading through the shared ref\n+    let _val = *xref; // the mutable one is dead and gone\n+    //~^ ERROR does not exist on the stack\n+}"}, {"sha": "b106cc8dc403cc7d8e0387263950c1c0ee538c45", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_write1.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write1.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     let target = Box::new(42); // has an implicit raw\n     let ref_ = &*target;\n     evil(ref_); // invalidates shared ref, activates raw\n-    let _x = *ref_; //~ ERROR is not frozen long enough\n+    let _x = *ref_; //~ ERROR is not frozen\n }", "previous_filename": "tests/compile-fail/stacked_borrows/illegal_write1.rs"}, {"sha": "b53655c82147e312364940ea983d14fb4102d99a", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_write2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write2.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/stacked_borrows/illegal_write2.rs"}, {"sha": "01559af21e7c64fbcea94f6923d9bba9d8cd8770", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_write3.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     let r#ref = &target; // freeze\n     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n     unsafe { *ptr = 42; }\n-    let _val = *r#ref; //~ ERROR is not frozen long enough\n+    let _val = *r#ref; //~ ERROR is not frozen\n }", "previous_filename": "tests/compile-fail/stacked_borrows/illegal_write3.rs"}, {"sha": "37ae0f055f0ee52ca6f4951d1e4ab226f3b775bb", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_write4.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write4.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -9,5 +9,5 @@ fn main() {\n     let ptr = reference as *const _ as *mut i32; // raw ptr, with raw tag\n     let _mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n     // Now we retag, making our ref top-of-stack -- and, in particular, unfreezing.\n-    let _val = *reference; //~ ERROR is not frozen long enough\n+    let _val = *reference; //~ ERROR is not frozen\n }", "previous_filename": "tests/compile-fail/stacked_borrows/illegal_write4.rs"}, {"sha": "57b2ca87d810236ad8c75fb77bd79dd4ef63af90", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_write5.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write5.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: reference with non-reactivatable tag\n+    //~^ ERROR: does not exist on the stack\n }\n \n fn callee(xraw: *mut i32) {", "previous_filename": "tests/compile-fail/stacked_borrows/illegal_write5.rs"}, {"sha": "98b9451eda87e77a2217ad9d043f9f7cb13ef5ee", "filename": "tests/compile-fail-fullmir/stacked_borrows/load_invalid_mut.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fload_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fload_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fload_invalid_mut.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -4,6 +4,6 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n     let xref_in_mem = Box::new(xref);\n-    let _val = *x; // invalidate xraw\n+    let _val = unsafe { *xraw }; // invalidate xref\n     let _val = *xref_in_mem; //~ ERROR does not exist on the stack\n }", "previous_filename": "tests/compile-fail/stacked_borrows/load_invalid_mut.rs"}, {"sha": "6599924f0f4c49e92c9fa0e36dbfbbdda8cb1179", "filename": "tests/compile-fail-fullmir/stacked_borrows/load_invalid_shr.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fload_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fload_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fload_invalid_shr.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -4,6 +4,6 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &*xraw };\n     let xref_in_mem = Box::new(xref);\n-    *x = 42; // invalidate xraw\n-    let _val = *xref_in_mem; //~ ERROR does not exist on the stack\n+    unsafe { *xraw = 42 }; // unfreeze\n+    let _val = *xref_in_mem; //~ ERROR is not frozen\n }", "previous_filename": "tests/compile-fail/stacked_borrows/load_invalid_shr.rs"}, {"sha": "255e35b145588df57cc0d848d4bd677a7e5eaf1e", "filename": "tests/compile-fail-fullmir/stacked_borrows/mut_exclusive_violation1.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fmut_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fmut_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fmut_exclusive_violation1.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -0,0 +1,29 @@\n+fn demo_mut_advanced_unique(our: &mut i32) -> i32 {\n+  unknown_code_1(&*our);\n+\n+  // This \"re-asserts\" uniqueness of the reference: After writing, we know\n+  // our tag is at the top of the stack.\n+  *our = 5;\n+\n+  unknown_code_2();\n+\n+  // We know this will return 5\n+  *our\n+}\n+\n+// Now comes the evil context\n+use std::ptr;\n+\n+static mut LEAK: *mut i32 = ptr::null_mut();\n+\n+fn unknown_code_1(x: &i32) { unsafe {\n+    LEAK = x as *const _ as *mut _;\n+} }\n+\n+fn unknown_code_2() { unsafe {\n+    *LEAK = 7; //~ ERROR does not exist on the stack\n+} }\n+\n+fn main() {\n+    assert_eq!(demo_mut_advanced_unique(&mut 0), 5);\n+}"}, {"sha": "64a8ff69108ec06f75140bb68a00325eebd66bc1", "filename": "tests/compile-fail-fullmir/stacked_borrows/outdated_local.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Foutdated_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Foutdated_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Foutdated_local.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/stacked_borrows/outdated_local.rs"}, {"sha": "28288c6c63623154d91d8915f6900c665ea86325", "filename": "tests/compile-fail-fullmir/stacked_borrows/pass_invalid_mut.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_mut.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -5,6 +5,6 @@ fn main() {\n     let x = &mut 42;\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n-    let _val = *x; // invalidate xraw\n+    let _val = unsafe { *xraw }; // invalidate xref\n     foo(xref); //~ ERROR does not exist on the stack\n }", "previous_filename": "tests/compile-fail/stacked_borrows/pass_invalid_mut.rs"}, {"sha": "67bbc88e40fb0dc8a423a8d366618818d0b55831", "filename": "tests/compile-fail-fullmir/stacked_borrows/pass_invalid_shr.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -3,8 +3,8 @@ fn foo(_: &i32) {}\n \n fn main() {\n     let x = &mut 42;\n-    let xraw = &*x as *const _;\n+    let xraw = &*x as *const _ as *mut _;\n     let xref = unsafe { &*xraw };\n-    *x = 42; // invalidate xraw\n-    foo(xref); //~ ERROR does not exist on the stack\n+    unsafe { *xraw = 42 }; // unfreeze\n+    foo(xref); //~ ERROR is not frozen\n }", "previous_filename": "tests/compile-fail/stacked_borrows/pass_invalid_shr.rs"}, {"sha": "68f3d2923b15ff062e9695ec32a42740ef13e6ff", "filename": "tests/compile-fail-fullmir/stacked_borrows/pointer_smuggling.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpointer_smuggling.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/stacked_borrows/pointer_smuggling.rs"}, {"sha": "e7f0b9bc9ddd0e127715a1e03373fca2b0b430f9", "filename": "tests/compile-fail-fullmir/stacked_borrows/return_invalid_mut.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_mut.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -2,7 +2,7 @@\n fn foo(x: &mut (i32, i32)) -> &mut i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 };\n-    let _val = *x; // invalidate xraw and its children\n+    let _val = unsafe { *xraw }; // invalidate xref\n     ret //~ ERROR does not exist on the stack\n }\n ", "previous_filename": "tests/compile-fail/stacked_borrows/return_invalid_mut.rs"}, {"sha": "986dd18b2e0b4e1c1467c1bf68e1f9c69d4b2574", "filename": "tests/compile-fail-fullmir/stacked_borrows/return_invalid_shr.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_shr.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -2,8 +2,8 @@\n fn foo(x: &mut (i32, i32)) -> &i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &(*xraw).1 };\n-    x.1 = 42; // invalidate xraw on the 2nd field\n-    ret //~ ERROR does not exist on the stack\n+    unsafe { *xraw = (42, 23) }; // unfreeze\n+    ret //~ ERROR is not frozen\n }\n \n fn main() {", "previous_filename": "tests/compile-fail/stacked_borrows/return_invalid_shr.rs"}, {"sha": "5c605eff678436eb2934021acac69f9039e397e9", "filename": "tests/compile-fail-fullmir/stacked_borrows/static_memory_modification.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fstatic_memory_modification.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -1,3 +1,6 @@\n+// FIXME still considering whether we are okay with this not being an error\n+// ignore-test\n+\n static X: usize = 5;\n \n #[allow(mutable_transmutes)]", "previous_filename": "tests/compile-fail/stacked_borrows/static_memory_modification.rs"}, {"sha": "1ab005e3fa17dd711bae157f869eb2ba77929001", "filename": "tests/compile-fail-fullmir/stacked_borrows/transmute-is-no-escape.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Ftransmute-is-no-escape.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -0,0 +1,12 @@\n+// Make sure we cannot use raw ptrs that got transmuted from mutable references\n+// (i.e, no EscapeToRaw happened).\n+// We could, in principle, to EscapeToRaw lazily to allow this code, but that\n+// would no alleviate the need for EscapeToRaw (see `ref_raw_int_raw` in\n+// `run-pass/stacked-borrows.rs`), and thus increase overall complexity.\n+use std::mem;\n+\n+fn main() {\n+    let mut x: i32 = 42;\n+    let raw: *mut i32 = unsafe { mem::transmute(&mut x) };\n+    unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n+}"}, {"sha": "054697b04a09d8ea45b3db3b233f4c3efa480351", "filename": "tests/compile-fail-fullmir/stacked_borrows/unescaped_local.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Funescaped_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Funescaped_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Funescaped_local.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -1,10 +1,8 @@\n-use std::mem;\n-\n // Make sure we cannot use raw ptrs to access a local that\n-// has never been escaped to the raw world.\n+// we took the direct address of.\n fn main() {\n     let mut x = 42;\n-    let ptr = &mut x;\n-    let raw: *mut i32 = unsafe { mem::transmute(ptr) };\n+    let raw = &mut x as *mut i32 as usize as *mut i32;\n+    let _ptr = &mut x;\n     unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n }", "previous_filename": "tests/compile-fail/stacked_borrows/unescaped_local.rs"}, {"sha": "acc6098af7ee04a2c638d71b23fab120e9e91d78", "filename": "tests/compile-fail-fullmir/transmute-pair-undef.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Ftransmute-pair-undef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompile-fail-fullmir%2Ftransmute-pair-undef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Ftransmute-pair-undef.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "previous_filename": "tests/compile-fail/transmute-pair-undef.rs"}, {"sha": "7ecf64590b6148fd2af5e57f0bb89ceb76a96c7e", "filename": "tests/compiletest.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -99,7 +99,13 @@ fn miri_pass(sysroot: &Path, path: &str, target: &str, host: &str, need_fullmir:\n     flags.push(format!(\"--sysroot {}\", sysroot.display()));\n     flags.push(\"-Dwarnings -Dunused\".to_owned()); // overwrite the -Aunused in compiletest-rs\n     if opt {\n-        flags.push(\"-Zmir-opt-level=3\".to_owned());\n+        // FIXME: We use opt level 1 because MIR inlining defeats the validation\n+        // whitelist.\n+        flags.push(\"-Zmir-opt-level=1\".to_owned());\n+    }\n+    if !have_fullmir() {\n+        // Validation relies on the EscapeToRaw statements being emitted\n+        flags.push(\"-Zmiri-disable-validation\".to_owned());\n     }\n \n     let mut config = mk_config(\"ui\");"}, {"sha": "bc89d752e0b62122642a3647d4874bd4ba38ea1e", "filename": "tests/run-pass/rc.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Frun-pass%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Frun-pass%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frc.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -1,13 +1,33 @@\n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n+use std::sync::Arc;\n \n fn rc_refcell() {\n     let r = Rc::new(RefCell::new(42));\n+    let r2 = r.clone();\n     *r.borrow_mut() += 10;\n-    let x = *r.borrow();\n+    let x = *r2.borrow();\n     assert_eq!(x, 52);\n }\n \n+fn rc_cell() {\n+    let r = Rc::new(Cell::new(42));\n+    let r2 = r.clone();\n+    let x = r.get();\n+    r2.set(x + x);\n+    assert_eq!(r.get(), 84);\n+}\n+\n+fn rc_refcell2() {\n+    let r = Rc::new(RefCell::new(42));\n+    let r2 = r.clone();\n+    *r.borrow_mut() += 10;\n+    let x = r2.borrow();\n+    let r3 = r.clone();\n+    let y = r3.borrow();\n+    assert_eq!((*x + *y)/2, 52);\n+}\n+\n fn rc_raw() {\n     let r = Rc::new(0);\n     let r2 = Rc::into_raw(r.clone());\n@@ -17,6 +37,14 @@ fn rc_raw() {\n     assert!(Rc::try_unwrap(r2).is_ok());\n }\n \n+fn arc() {\n+    fn test() -> Arc<i32> {\n+        let a = Arc::new(42);\n+        a\n+    }\n+    assert_eq!(*test(), 42);\n+}\n+\n // Make sure this Rc doesn't fall apart when touched\n fn check_unique_rc<T: ?Sized>(mut r: Rc<T>) {\n     let r2 = r.clone();\n@@ -34,6 +62,9 @@ fn rc_from() {\n \n fn main() {\n     rc_refcell();\n+    rc_refcell2();\n+    rc_cell();\n     rc_raw();\n     rc_from();\n+    arc();\n }"}, {"sha": "5f2f3523b96b1e916fb8c5bc79b5d60b1b03bd90", "filename": "tests/run-pass/refcell.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Frun-pass%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Frun-pass%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frefcell.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -1,6 +1,6 @@\n use std::cell::RefCell;\n \n-fn main() {\n+fn lots_of_funny_borrows() {\n     let c = RefCell::new(42);\n     {\n         let s1 = c.borrow();\n@@ -31,3 +31,24 @@ fn main() {\n         let _y: i32 = *s2;\n     }\n }\n+\n+fn aliasing_mut_and_shr() {\n+    fn inner(rc: &RefCell<i32>, aliasing: &mut i32) {\n+        *aliasing += 4;\n+        let _escape_to_raw = rc as *const _;\n+        *aliasing += 4;\n+        let _shr = &*rc;\n+        *aliasing += 4;\n+    }\n+\n+    let rc = RefCell::new(23);\n+    let mut bmut = rc.borrow_mut();\n+    inner(&rc, &mut *bmut);\n+    drop(bmut);\n+    assert_eq!(*rc.borrow(), 23+12);\n+}\n+\n+fn main() {\n+    lots_of_funny_borrows();\n+    aliasing_mut_and_shr();\n+}"}, {"sha": "7b7a7c9be2030b50dc6c9f0244b42845e67c6b8f", "filename": "tests/run-pass/stacked-borrows.rs", "status": "modified", "additions": 67, "deletions": 4, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Frun-pass%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3/tests%2Frun-pass%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows.rs?ref=d78b62e3e4d45dfa07e64f84a72cd6bfb865d9a3", "patch": "@@ -3,15 +3,20 @@ fn main() {\n     deref_partially_dangling_raw();\n     read_does_not_invalidate1();\n     read_does_not_invalidate2();\n+    ref_raw_int_raw();\n+    mut_shr_raw();\n+    mut_raw_then_mut_shr();\n+    mut_raw_mut();\n }\n \n // Deref a raw ptr to access a field of a large struct, where the field\n // is allocated but not the entire struct is.\n // For now, we want to allow this.\n fn deref_partially_dangling_raw() {\n-    let x = (1, 1);\n+    let x = (1, 13);\n     let xptr = &x as *const _ as *const (i32, i32, i32);\n-    let _val = unsafe { (*xptr).1 };\n+    let val = unsafe { (*xptr).1 };\n+    assert_eq!(val, 13);\n }\n \n // Make sure that reading from an `&mut` does, like reborrowing to `&`,\n@@ -23,7 +28,7 @@ fn read_does_not_invalidate1() {\n         let _val = x.1; // we just read, this does NOT invalidate the reborrows.\n         ret\n     }\n-    foo(&mut (1, 2));\n+    assert_eq!(*foo(&mut (1, 2)), 2);\n }\n // Same as above, but this time we first create a raw, then read from `&mut`\n // and then freeze from the raw.\n@@ -34,5 +39,63 @@ fn read_does_not_invalidate2() {\n         let ret = unsafe { &(*xraw).1 };\n         ret\n     }\n-    foo(&mut (1, 2));\n+    assert_eq!(*foo(&mut (1, 2)), 2);\n+}\n+\n+// Just to make sure that casting a ref to raw, to int and back to raw\n+// and only then using it works.  This rules out ideas like \"do escape-to-raw lazily\":\n+// After casting to int and back, we lost the tag that could have let us do that.\n+fn ref_raw_int_raw() {\n+    let mut x = 3;\n+    let xref = &mut x;\n+    let xraw = xref as *mut i32 as usize as *mut i32;\n+    assert_eq!(unsafe { *xraw }, 3);\n+}\n+\n+// Creating a raw from a `&mut` through an `&` works, even if we\n+// write through that raw.\n+fn mut_shr_raw() {\n+    let mut x = 2;\n+    {\n+        let xref = &mut x;\n+        let xraw = &*xref as *const i32 as *mut i32;\n+        unsafe { *xraw = 4; }\n+    }\n+    assert_eq!(x, 4);\n+}\n+\n+// Escape a mut to raw, then share the same mut and use the share, then the raw.\n+// That should work.\n+fn mut_raw_then_mut_shr() {\n+    let mut x = 2;\n+    {\n+        let xref = &mut x;\n+        let xraw = &mut *xref as *mut _;\n+        let xshr = &*xref;\n+        assert_eq!(*xshr, 2);\n+        unsafe { *xraw = 4; }\n+    }\n+    assert_eq!(x, 4);\n+}\n+\n+// Ensure that if we derive from a mut a raw, and then from that a mut,\n+// and then read through the original mut, that does not invalidate the raw.\n+// This shows that the read-exception for `&mut` applies even if the `Shr` item\n+// on the stack is not at the top.\n+fn mut_raw_mut() {\n+    let mut x = 2;\n+    {\n+        let xref1 = &mut x;\n+        let xraw = xref1 as *mut _;\n+        let _xref2 = unsafe { &mut *xraw };\n+        let _val = *xref1;\n+        unsafe { *xraw = 4; }\n+        // we can now use both xraw and xref1, for reading\n+        assert_eq!(*xref1, 4);\n+        assert_eq!(unsafe { *xraw }, 4);\n+        assert_eq!(*xref1, 4);\n+        assert_eq!(unsafe { *xraw }, 4);\n+        // we cannot use xref2; see `compile-fail/stacked-borows/illegal_read4.rs`\n+    }\n+    assert_eq!(x, 4);\n }"}, {"sha": "7ff967b29f344e591c4afeec638287206a835ec3", "filename": "tests/run-pass/std.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/021bf1f3b38f2800fd0799f621f00ffc22849694/tests%2Frun-pass%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021bf1f3b38f2800fd0799f621f00ffc22849694/tests%2Frun-pass%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstd.rs?ref=021bf1f3b38f2800fd0799f621f00ffc22849694", "patch": "@@ -1,34 +0,0 @@\n-use std::cell::{Cell, RefCell};\n-use std::rc::Rc;\n-use std::sync::Arc;\n-\n-fn rc_cell() -> Rc<Cell<i32>> {\n-    let r = Rc::new(Cell::new(42));\n-    let x = r.get();\n-    r.set(x + x);\n-    r\n-}\n-\n-fn rc_refcell() -> i32 {\n-    let r = Rc::new(RefCell::new(42));\n-    *r.borrow_mut() += 10;\n-    let x = r.borrow();\n-    let y = r.borrow();\n-    (*x + *y)/2\n-}\n-\n-fn arc() -> Arc<i32> {\n-    let a = Arc::new(42);\n-    a\n-}\n-\n-fn true_assert() {\n-    assert_eq!(1, 1);\n-}\n-\n-fn main() {\n-    assert_eq!(*arc(), 42);\n-    assert_eq!(rc_cell().get(), 84);\n-    assert_eq!(rc_refcell(), 52);\n-    true_assert();\n-}"}]}