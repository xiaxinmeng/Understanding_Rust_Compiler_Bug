{"sha": "421fed188c66379cb2f00c7e4ad7b7381b3abaa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMWZlZDE4OGM2NjM3OWNiMmYwMGM3ZTRhZDdiNzM4MWIzYWJhYTk=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-03-14T10:57:50Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-03-19T11:44:38Z"}, "message": "Change compare_exchange to return a Result<T, T>", "tree": {"sha": "8687756bd429f93480e40acdc7a7c7590e773803", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8687756bd429f93480e40acdc7a7c7590e773803"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/421fed188c66379cb2f00c7e4ad7b7381b3abaa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/421fed188c66379cb2f00c7e4ad7b7381b3abaa9", "html_url": "https://github.com/rust-lang/rust/commit/421fed188c66379cb2f00c7e4ad7b7381b3abaa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "235d77457d80b549dad3ac36d94f235208a1eafb", "url": "https://api.github.com/repos/rust-lang/rust/commits/235d77457d80b549dad3ac36d94f235208a1eafb", "html_url": "https://github.com/rust-lang/rust/commit/235d77457d80b549dad3ac36d94f235208a1eafb"}], "stats": {"total": 308, "additions": 174, "deletions": 134}, "files": [{"sha": "1084295fac599c6ae5c0a018af0ea98e9dd4063d", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=421fed188c66379cb2f00c7e4ad7b7381b3abaa9", "patch": "@@ -53,19 +53,35 @@ extern \"rust-intrinsic\" {\n     // NB: These intrinsics take raw pointers because they mutate aliased\n     // memory, which is not valid for either `&` or `&mut`.\n \n+    #[cfg(stage0)]\n     pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> T;\n+    #[cfg(stage0)]\n     pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> T;\n+    #[cfg(stage0)]\n     pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;\n+    #[cfg(stage0)]\n     pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> T;\n+    #[cfg(stage0)]\n     pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> T;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     #[cfg(not(stage0))]\n-    pub fn atomic_cxchg_failrelaxed<T>(dst: *mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     #[cfg(not(stage0))]\n-    pub fn atomic_cxchg_failacq<T>(dst: *mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     #[cfg(not(stage0))]\n-    pub fn atomic_cxchg_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n     #[cfg(not(stage0))]\n-    pub fn atomic_cxchg_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     #[cfg(not(stage0))]\n     pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);"}, {"sha": "40555481fc0d8dc3ac46658b31d362b22227f839", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 114, "deletions": 83, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=421fed188c66379cb2f00c7e4ad7b7381b3abaa9", "patch": "@@ -77,6 +77,8 @@ use marker::{Send, Sync};\n use intrinsics;\n use cell::UnsafeCell;\n \n+use result::Result::{self, Ok, Err};\n+\n use default::Default;\n use fmt;\n \n@@ -311,13 +313,16 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n-        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n+            Ok(x) => x,\n+            Err(x) => x,\n+        }\n     }\n \n     /// Stores a value into the `bool` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `current`, then the value\n-    /// was updated.\n+    /// The return value is a result indicating whether the new value was written and containing\n+    /// the previous value. On success this value is guaranteed to be equal to `new`.\n     ///\n     /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n     /// operation. The first describes the required ordering if the operation succeeds while the\n@@ -336,13 +341,13 @@ impl AtomicBool {\n     ///                                       false,\n     ///                                       Ordering::Acquire,\n     ///                                       Ordering::Relaxed),\n-    ///            true);\n+    ///            Ok(true));\n     /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n     ///\n     /// assert_eq!(some_bool.compare_exchange(true, true,\n     ///                                       Ordering::SeqCst,\n     ///                                       Ordering::Acquire),\n-    ///            false);\n+    ///            Err(false));\n     /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n     /// ```\n     #[inline]\n@@ -351,19 +356,22 @@ impl AtomicBool {\n                             current: bool,\n                             new: bool,\n                             success: Ordering,\n-                            failure: Ordering) -> bool {\n+                            failure: Ordering) -> Result<bool, bool> {\n         let current = if current { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) > 0 }\n+        match unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) } {\n+            Ok(x) => Ok(x > 0),\n+            Err(x) => Err(x > 0),\n+        }\n     }\n \n     /// Stores a value into the `bool` if the current value is the same as the `current` value.\n     ///\n     /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n-    /// returned value is a tuple of the existing value and a flag indicating whether the\n-    /// new value was written.\n+    /// return value is a result indicating whether the new value was written and containing the\n+    /// previous value.\n     ///\n     /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n@@ -382,13 +390,9 @@ impl AtomicBool {\n     /// let new = true;\n     /// let mut old = val.load(Ordering::Relaxed);\n     /// loop {\n-    ///     let result = val.compare_exchange_weak(old, new,\n-    ///                                            Ordering::SeqCst,\n-    ///                                            Ordering::Relaxed);\n-    ///     if result.1 {\n-    ///         break;\n-    ///     } else {\n-    ///         old = result.0;\n+    ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n+    ///         Ok(_) => break,\n+    ///         Err(x) => old = x,\n     ///     }\n     /// }\n     /// ```\n@@ -398,14 +402,15 @@ impl AtomicBool {\n                                  current: bool,\n                                  new: bool,\n                                  success: Ordering,\n-                                 failure: Ordering) -> (bool, bool) {\n+                                 failure: Ordering) -> Result<bool, bool> {\n         let current = if current { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n \n-        let result = unsafe {\n-            atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n-        };\n-        (result.0 > 0, result.1)\n+        match unsafe { atomic_compare_exchange_weak(self.v.get(), current, new,\n+                                                    success, failure) } {\n+            Ok(x) => Ok(x > 0),\n+            Err(x) => Err(x > 0),\n+        }\n     }\n \n     /// Logical \"and\" with a boolean value.\n@@ -644,13 +649,16 @@ impl AtomicIsize {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: isize, new: isize, order: Ordering) -> isize {\n-        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n+            Ok(x) => x,\n+            Err(x) => x,\n+        }\n     }\n \n     /// Stores a value into the `isize` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `current`, then the value\n-    /// was updated.\n+    /// The return value is a result indicating whether the new value was written and containing\n+    /// the previous value. On success this value is guaranteed to be equal to `new`.\n     ///\n     /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n     /// operation. The first describes the required ordering if the operation succeeds while the\n@@ -668,13 +676,13 @@ impl AtomicIsize {\n     /// assert_eq!(some_isize.compare_exchange(5, 10,\n     ///                                        Ordering::Acquire,\n     ///                                        Ordering::Relaxed),\n-    ///            5);\n+    ///            Ok(5));\n     /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n     ///\n     /// assert_eq!(some_isize.compare_exchange(6, 12,\n     ///                                        Ordering::SeqCst,\n     ///                                        Ordering::Acquire),\n-    ///            10);\n+    ///            Err(10));\n     /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n     /// ```\n     #[inline]\n@@ -683,16 +691,16 @@ impl AtomicIsize {\n                             current: isize,\n                             new: isize,\n                             success: Ordering,\n-                            failure: Ordering) -> isize {\n+                            failure: Ordering) -> Result<isize, isize> {\n         unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n     }\n \n     /// Stores a value into the `isize if the current value is the same as the `current` value.\n     ///\n     /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n-    /// returned value is a tuple of the existing value and a flag indicating whether the\n-    /// new value was written.\n+    /// return value is a result indicating whether the new value was written and containing the\n+    /// previous value.\n     ///\n     /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n@@ -711,13 +719,9 @@ impl AtomicIsize {\n     /// let mut old = val.load(Ordering::Relaxed);\n     /// loop {\n     ///     let new = old * 2;\n-    ///     let result = val.compare_exchange_weak(old, new,\n-    ///                                            Ordering::SeqCst,\n-    ///                                            Ordering::Relaxed);\n-    ///     if result.1 {\n-    ///         break;\n-    ///     } else {\n-    ///         old = result.0;\n+    ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n+    ///         Ok(_) => break,\n+    ///         Err(x) => old = x,\n     ///     }\n     /// }\n     /// ```\n@@ -727,7 +731,7 @@ impl AtomicIsize {\n                                  current: isize,\n                                  new: isize,\n                                  success: Ordering,\n-                                 failure: Ordering) -> (isize, bool) {\n+                                 failure: Ordering) -> Result<isize, isize> {\n         unsafe { atomic_compare_exchange_weak(self.v.get(), current, new, success, failure) }\n     }\n \n@@ -921,13 +925,16 @@ impl AtomicUsize {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: usize, new: usize, order: Ordering) -> usize {\n-        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n+            Ok(x) => x,\n+            Err(x) => x,\n+        }\n     }\n \n     /// Stores a value into the `usize` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `current`, then the value\n-    /// was updated.\n+    /// The return value is a result indicating whether the new value was written and containing\n+    /// the previous value. On success this value is guaranteed to be equal to `new`.\n     ///\n     /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n     /// operation. The first describes the required ordering if the operation succeeds while the\n@@ -945,13 +952,13 @@ impl AtomicUsize {\n     /// assert_eq!(some_isize.compare_exchange(5, 10,\n     ///                                        Ordering::Acquire,\n     ///                                        Ordering::Relaxed),\n-    ///            5);\n+    ///            Ok(5));\n     /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n     ///\n     /// assert_eq!(some_isize.compare_exchange(6, 12,\n     ///                                        Ordering::SeqCst,\n     ///                                        Ordering::Acquire),\n-    ///            10);\n+    ///            Err(10));\n     /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n     /// ```\n     #[inline]\n@@ -960,16 +967,16 @@ impl AtomicUsize {\n                             current: usize,\n                             new: usize,\n                             success: Ordering,\n-                            failure: Ordering) -> usize {\n+                            failure: Ordering) -> Result<usize, usize> {\n         unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n     }\n \n     /// Stores a value into the `usize` if the current value is the same as the `current` value.\n     ///\n     /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n-    /// returned value is a tuple of the existing value and a flag indicating whether the\n-    /// new value was written.\n+    /// return value is a result indicating whether the new value was written and containing the\n+    /// previous value.\n     ///\n     /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n@@ -988,13 +995,9 @@ impl AtomicUsize {\n     /// let mut old = val.load(Ordering::Relaxed);\n     /// loop {\n     ///     let new = old * 2;\n-    ///     let result = val.compare_exchange_weak(old, new,\n-    ///                                            Ordering::SeqCst,\n-    ///                                            Ordering::Relaxed);\n-    ///     if result.1 {\n-    ///         break;\n-    ///     } else {\n-    ///         old = result.0;\n+    ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n+    ///         Ok(_) => break,\n+    ///         Err(x) => old = x,\n     ///     }\n     /// }\n     /// ```\n@@ -1004,7 +1007,7 @@ impl AtomicUsize {\n                                  current: usize,\n                                  new: usize,\n                                  success: Ordering,\n-                                 failure: Ordering) -> (usize, bool) {\n+                                 failure: Ordering) -> Result<usize, usize> {\n         unsafe { atomic_compare_exchange_weak(self.v.get(), current, new, success, failure) }\n     }\n \n@@ -1206,13 +1209,16 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n-        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n+            Ok(x) => x,\n+            Err(x) => x,\n+        }\n     }\n \n     /// Stores a value into the pointer if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `current`, then the value\n-    /// was updated.\n+    /// The return value is a result indicating whether the new value was written and containing\n+    /// the previous value. On success this value is guaranteed to be equal to `new`.\n     ///\n     /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n     /// operation. The first describes the required ordering if the operation succeeds while the\n@@ -1240,19 +1246,26 @@ impl<T> AtomicPtr<T> {\n                             current: *mut T,\n                             new: *mut T,\n                             success: Ordering,\n-                            failure: Ordering) -> *mut T {\n+                            failure: Ordering) -> Result<*mut T, *mut T> {\n         unsafe {\n-            atomic_compare_exchange(self.p.get() as *mut usize, current as usize,\n-                                    new as usize, success, failure) as *mut T\n+            let res = atomic_compare_exchange(self.p.get() as *mut usize,\n+                                              current as usize,\n+                                              new as usize,\n+                                              success,\n+                                              failure);\n+            match res {\n+                Ok(x) => Ok(x as *mut T),\n+                Err(x) => Err(x as *mut T),\n+            }\n         }\n     }\n \n     /// Stores a value into the pointer if the current value is the same as the `current` value.\n     ///\n     /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n-    /// returned value is a tuple of the existing value and a flag indicating whether the\n-    /// new value was written.\n+    /// return value is a result indicating whether the new value was written and containing the\n+    /// previous value.\n     ///\n     /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n@@ -1271,13 +1284,9 @@ impl<T> AtomicPtr<T> {\n     /// let new = &mut 10;\n     /// let mut old = some_ptr.load(Ordering::Relaxed);\n     /// loop {\n-    ///     let result = some_ptr.compare_exchange_weak(old, new,\n-    ///                                                 Ordering::SeqCst,\n-    ///                                                 Ordering::Relaxed);\n-    ///     if result.1 {\n-    ///         break;\n-    ///     } else {\n-    ///         old = result.0;\n+    ///     match some_ptr.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n+    ///         Ok(_) => break,\n+    ///         Err(x) => old = x,\n     ///     }\n     /// }\n     /// ```\n@@ -1287,12 +1296,18 @@ impl<T> AtomicPtr<T> {\n                                  current: *mut T,\n                                  new: *mut T,\n                                  success: Ordering,\n-                                 failure: Ordering) -> (*mut T, bool) {\n-        let result = unsafe {\n-            atomic_compare_exchange_weak(self.p.get() as *mut usize, current as usize,\n-                                         new as usize, success, failure)\n-        };\n-        (result.0 as *mut T, result.1)\n+                                 failure: Ordering) -> Result<*mut T, *mut T> {\n+        unsafe {\n+            let res = atomic_compare_exchange_weak(self.p.get() as *mut usize,\n+                                                   current as usize,\n+                                                   new as usize,\n+                                                   success,\n+                                                   failure);\n+            match res {\n+                Ok(x) => Ok(x as *mut T),\n+                Err(x) => Err(x as *mut T),\n+            }\n+        }\n     }\n }\n \n@@ -1370,8 +1385,8 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                      old: T,\n                                      new: T,\n                                      success: Ordering,\n-                                     failure: Ordering) -> T {\n-    match (success, failure) {\n+                                     failure: Ordering) -> Result<T, T> {\n+    let (val, ok) = match (success, failure) {\n         (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n         (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n         (AcqRel, Acquire)  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n@@ -1384,6 +1399,11 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n         (_, Release) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n         (_, AcqRel) => panic!(\"there is no such thing as a release failure ordering\"),\n         _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+    };\n+    if ok {\n+        Ok(val)\n+    } else {\n+        Err(val)\n     }\n }\n \n@@ -1393,13 +1413,20 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                      old: T,\n                                      new: T,\n                                      success: Ordering,\n-                                     _: Ordering) -> T {\n-    match success {\n+                                     _: Ordering) -> Result<T, T>\n+    where T: ::cmp::Eq + ::marker::Copy\n+{\n+    let val = match success {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n         Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n         AcqRel  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n         Relaxed => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n         SeqCst  => intrinsics::atomic_cxchg(dst, old, new),\n+    };\n+    if val == old {\n+        Ok(val)\n+    } else {\n+        Err(val)\n     }\n }\n \n@@ -1409,8 +1436,8 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n                                           success: Ordering,\n-                                          failure: Ordering) -> (T, bool) {\n-    match (success, failure) {\n+                                          failure: Ordering) -> Result<T, T> {\n+    let (val, ok) = match (success, failure) {\n         (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n         (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n         (AcqRel, Acquire)  => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n@@ -1423,6 +1450,11 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n         (_, Release) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n         (_, AcqRel) => panic!(\"there is no such thing as a release failure ordering\"),\n         _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+    };\n+    if ok {\n+        Ok(val)\n+    } else {\n+        Err(val)\n     }\n }\n \n@@ -1432,11 +1464,10 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n                                           success: Ordering,\n-                                          failure: Ordering) -> (T, bool)\n+                                          failure: Ordering) -> Result<T, T>\n     where T: ::cmp::Eq + ::marker::Copy\n {\n-    let result = atomic_compare_exchange(dst, old, new, success, failure);\n-    (result, result == old)\n+    atomic_compare_exchange(dst, old, new, success, failure)\n }\n \n #[inline]"}, {"sha": "164de212d568788210695e8edfaa419a43a0ed7b", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=421fed188c66379cb2f00c7e4ad7b7381b3abaa9", "patch": "@@ -697,6 +697,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, name) if name.starts_with(\"atomic_\") => {\n             let split: Vec<&str> = name.split('_').collect();\n \n+            let is_cxchg = split[1] == \"cxchg\" || split[1] == \"cxchgweak\";\n             let (order, failorder) = match split.len() {\n                 2 => (llvm::SequentiallyConsistent, llvm::SequentiallyConsistent),\n                 3 => match split[2] {\n@@ -705,39 +706,34 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     \"acq\"     => (llvm::Acquire, llvm::Acquire),\n                     \"rel\"     => (llvm::Release, llvm::Monotonic),\n                     \"acqrel\"  => (llvm::AcquireRelease, llvm::Acquire),\n-                    \"failrelaxed\" if split[1] == \"cxchg\" || split[1] == \"cxchgweak\" =>\n+                    \"failrelaxed\" if is_cxchg =>\n                         (llvm::SequentiallyConsistent, llvm::Monotonic),\n-                    \"failacq\" if split[1] == \"cxchg\" || split[1] == \"cxchgweak\" =>\n+                    \"failacq\" if is_cxchg =>\n                         (llvm::SequentiallyConsistent, llvm::Acquire),\n                     _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n                 },\n                 4 => match (split[2], split[3]) {\n-                    (\"acq\", \"failrelaxed\") if split[1] == \"cxchg\" || split[1] == \"cxchgweak\" =>\n+                    (\"acq\", \"failrelaxed\") if is_cxchg =>\n                         (llvm::Acquire, llvm::Monotonic),\n-                    (\"acqrel\", \"failrelaxed\") if split[1] == \"cxchg\" || split[1] == \"cxchgweak\" =>\n+                    (\"acqrel\", \"failrelaxed\") if is_cxchg =>\n                         (llvm::AcquireRelease, llvm::Monotonic),\n                     _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n                 },\n                 _ => ccx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n             };\n \n             match split[1] {\n-                \"cxchg\" => {\n+                \"cxchg\" | \"cxchgweak\" => {\n                     let cmp = from_immediate(bcx, llargs[1]);\n                     let src = from_immediate(bcx, llargs[2]);\n                     let ptr = PointerCast(bcx, llargs[0], val_ty(src).ptr_to());\n-                    let res = AtomicCmpXchg(bcx, ptr, cmp, src, order, failorder, llvm::False);\n-                    ExtractValue(bcx, res, 0)\n-                }\n-\n-                \"cxchgweak\" => {\n-                    let cmp = from_immediate(bcx, llargs[1]);\n-                    let src = from_immediate(bcx, llargs[2]);\n-                    let ptr = PointerCast(bcx, llargs[0], val_ty(src).ptr_to());\n-                    let val = AtomicCmpXchg(bcx, ptr, cmp, src, order, failorder, llvm::True);\n+                    let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n+                    let val = AtomicCmpXchg(bcx, ptr, cmp, src, order, failorder, weak);\n                     let result = ExtractValue(bcx, val, 0);\n                     let success = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n-                    Store(bcx, result, StructGEP(bcx, llresult, 0));\n+                    Store(bcx,\n+                          result,\n+                          PointerCast(bcx, StructGEP(bcx, llresult, 0), val_ty(src).ptr_to()));\n                     Store(bcx, success, StructGEP(bcx, llresult, 1));\n                     C_nil(ccx)\n                 }\n@@ -750,6 +746,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     }\n                     to_immediate(bcx, AtomicLoad(bcx, ptr, order), tp_ty)\n                 }\n+\n                 \"store\" => {\n                     let val = from_immediate(bcx, llargs[1]);\n                     let ptr = PointerCast(bcx, llargs[0], val_ty(val).ptr_to());"}, {"sha": "d0a8008320a39aec15bfcfaec6d7b83b44300fe0", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=421fed188c66379cb2f00c7e4ad7b7381b3abaa9", "patch": "@@ -84,14 +84,10 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n \n         //We only care about the operation here\n         let (n_tps, inputs, output) = match split[1] {\n-            \"cxchg\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)),\n-                                param(ccx, 0),\n-                                param(ccx, 0)),\n-                        param(ccx, 0)),\n-            \"cxchgweak\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)),\n-                                param(ccx, 0),\n-                                param(ccx, 0)),\n-                            tcx.mk_tup(vec!(param(ccx, 0), tcx.types.bool))),\n+            \"cxchg\" | \"cxchgweak\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)),\n+                                              param(ccx, 0),\n+                                              param(ccx, 0)),\n+                                      tcx.mk_tup(vec!(param(ccx, 0), tcx.types.bool))),\n             \"load\" => (1, vec!(tcx.mk_imm_ptr(param(ccx, 0))),\n                        param(ccx, 0)),\n             \"store\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),"}, {"sha": "1d9fa248e3d93e97d97aab24b68d2de49fa31f8f", "filename": "src/test/run-pass/atomic-compare_exchange.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Ftest%2Frun-pass%2Fatomic-compare_exchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Ftest%2Frun-pass%2Fatomic-compare_exchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fatomic-compare_exchange.rs?ref=421fed188c66379cb2f00c7e4ad7b7381b3abaa9", "patch": "@@ -16,22 +16,22 @@ static ATOMIC: AtomicIsize = ATOMIC_ISIZE_INIT;\n \n fn main() {\n     // Make sure trans can emit all the intrinsics correctly\n-    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed);\n-    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed);\n-    ATOMIC.compare_exchange(0, 1, Release, Relaxed);\n-    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed);\n-    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed);\n-    ATOMIC.compare_exchange(0, 1, Acquire, Acquire);\n-    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire);\n-    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire);\n-    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst);\n-    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed);\n-    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed);\n-    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed);\n-    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed);\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed);\n-    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire);\n-    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire);\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire);\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst);\n+    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();\n+    ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();\n+    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();\n+    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();\n+    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n }"}, {"sha": "a675528424ed23f810a5a1d56324604c42e6d80c", "filename": "src/test/run-pass/intrinsic-atomics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421fed188c66379cb2f00c7e4ad7b7381b3abaa9/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs?ref=421fed188c66379cb2f00c7e4ad7b7381b3abaa9", "patch": "@@ -15,9 +15,9 @@\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> T;\n-        pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> T;\n-        pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;\n+        pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n         pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n         pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n@@ -56,13 +56,13 @@ pub fn main() {\n         rusti::atomic_store_rel(&mut *x,1);\n         assert_eq!(*x, 1);\n \n-        assert_eq!(rusti::atomic_cxchg(&mut *x, 1, 2), 1);\n+        assert_eq!(rusti::atomic_cxchg(&mut *x, 1, 2), (1, true));\n         assert_eq!(*x, 2);\n \n-        assert_eq!(rusti::atomic_cxchg_acq(&mut *x, 1, 3), 2);\n+        assert_eq!(rusti::atomic_cxchg_acq(&mut *x, 1, 3), (2, false));\n         assert_eq!(*x, 2);\n \n-        assert_eq!(rusti::atomic_cxchg_rel(&mut *x, 2, 1), 2);\n+        assert_eq!(rusti::atomic_cxchg_rel(&mut *x, 2, 1), (2, true));\n         assert_eq!(*x, 1);\n \n         assert_eq!(rusti::atomic_xchg(&mut *x, 0), 1);"}]}