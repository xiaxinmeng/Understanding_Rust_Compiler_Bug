{"sha": "7b81106a8525f96d5a5890720cee265e49e77028", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiODExMDZhODUyNWY5NmQ1YTU4OTA3MjBjZWUyNjVlNDllNzcwMjg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-16T03:06:09Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-19T09:58:12Z"}, "message": "Use `Ident`s instead of `Name`s in `ImportDirective`'s paths.", "tree": {"sha": "6e44f63f3ee43c2240e2315a9125e1a8813caced", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e44f63f3ee43c2240e2315a9125e1a8813caced"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b81106a8525f96d5a5890720cee265e49e77028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b81106a8525f96d5a5890720cee265e49e77028", "html_url": "https://github.com/rust-lang/rust/commit/7b81106a8525f96d5a5890720cee265e49e77028", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b81106a8525f96d5a5890720cee265e49e77028/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a6ef91ba757d33d0f5155c1ebb628998158a8cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a6ef91ba757d33d0f5155c1ebb628998158a8cd", "html_url": "https://github.com/rust-lang/rust/commit/6a6ef91ba757d33d0f5155c1ebb628998158a8cd"}], "stats": {"total": 81, "additions": 37, "deletions": 44}, "files": [{"sha": "b26f40839d00961135ffbd4ab4ae16fbdfa508f6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b81106a8525f96d5a5890720cee265e49e77028/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b81106a8525f96d5a5890720cee265e49e77028/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7b81106a8525f96d5a5890720cee265e49e77028", "patch": "@@ -95,22 +95,22 @@ impl<'b> Resolver<'b> {\n                 // Extract and intern the module part of the path. For\n                 // globs and lists, the path is found directly in the AST;\n                 // for simple paths we have to munge the path a little.\n-                let module_path: Vec<Name> = match view_path.node {\n+                let module_path: Vec<_> = match view_path.node {\n                     ViewPathSimple(_, ref full_path) => {\n                         full_path.segments\n                                  .split_last()\n                                  .unwrap()\n                                  .1\n                                  .iter()\n-                                 .map(|seg| seg.identifier.name)\n+                                 .map(|seg| seg.identifier)\n                                  .collect()\n                     }\n \n                     ViewPathGlob(ref module_ident_path) |\n                     ViewPathList(ref module_ident_path, _) => {\n                         module_ident_path.segments\n                                          .iter()\n-                                         .map(|seg| seg.identifier.name)\n+                                         .map(|seg| seg.identifier)\n                                          .collect()\n                     }\n                 };\n@@ -159,7 +159,7 @@ impl<'b> Resolver<'b> {\n                                     (module_path.clone(), node.name.name, rename)\n                                 } else {\n                                     let name = match module_path.last() {\n-                                        Some(name) => *name,\n+                                        Some(ident) => ident.name,\n                                         None => {\n                                             resolve_error(\n                                                 self,"}, {"sha": "172648c01e0466f2102d207080dd108cb5f90403", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7b81106a8525f96d5a5890720cee265e49e77028/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b81106a8525f96d5a5890720cee265e49e77028/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7b81106a8525f96d5a5890720cee265e49e77028", "patch": "@@ -1178,18 +1178,18 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n }\n \n trait Named {\n-    fn name(&self) -> Name;\n+    fn ident(&self) -> Ident;\n }\n \n impl Named for ast::PathSegment {\n-    fn name(&self) -> Name {\n-        self.identifier.name\n+    fn ident(&self) -> Ident {\n+        self.identifier\n     }\n }\n \n impl Named for hir::PathSegment {\n-    fn name(&self) -> Name {\n-        self.name\n+    fn ident(&self) -> Ident {\n+        Ident::with_empty_ctxt(self.name)\n     }\n }\n \n@@ -1364,7 +1364,7 @@ impl<'a> Resolver<'a> {\n     /// Resolves the given module path from the given root `search_module`.\n     fn resolve_module_path_from_root(&mut self,\n                                      mut search_module: Module<'a>,\n-                                     module_path: &[Name],\n+                                     module_path: &[Ident],\n                                      index: usize,\n                                      span: Option<Span>)\n                                      -> ResolveResult<Module<'a>> {\n@@ -1387,7 +1387,7 @@ impl<'a> Resolver<'a> {\n         // upward though scope chains; we simply resolve names directly in\n         // modules as we go.\n         while index < module_path_len {\n-            let name = module_path[index];\n+            let name = module_path[index].name;\n             match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n                 Failed(_) => {\n                     let segment_name = name.as_str();\n@@ -1441,7 +1441,7 @@ impl<'a> Resolver<'a> {\n     /// Attempts to resolve the module part of an import directive or path\n     /// rooted at the given module.\n     fn resolve_module_path(&mut self,\n-                           module_path: &[Name],\n+                           module_path: &[Ident],\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Option<Span>)\n                            -> ResolveResult<Module<'a>> {\n@@ -1479,7 +1479,7 @@ impl<'a> Resolver<'a> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        let ident = Ident::with_empty_ctxt(module_path[0]);\n+                        let ident = module_path[0];\n                         let lexical_binding =\n                             self.resolve_ident_in_lexical_scope(ident, TypeNS, span);\n                         if let Some(binding) = lexical_binding.and_then(LexicalScopeBinding::item) {\n@@ -1577,11 +1577,11 @@ impl<'a> Resolver<'a> {\n     /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n-    fn resolve_module_prefix(&mut self, module_path: &[Name], span: Option<Span>)\n+    fn resolve_module_prefix(&mut self, module_path: &[Ident], span: Option<Span>)\n                              -> ResolveResult<ModulePrefixResult<'a>> {\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n-        let mut i = match &*module_path[0].as_str() {\n+        let mut i = match &*module_path[0].name.as_str() {\n             \"self\" => 1,\n             \"super\" => 0,\n             _ => return Success(NoPrefixFound),\n@@ -1591,7 +1591,7 @@ impl<'a> Resolver<'a> {\n             self.module_map[&self.current_module.normal_ancestor_id.unwrap()];\n \n         // Now loop through all the `super`s we find.\n-        while i < module_path.len() && \"super\" == module_path[i].as_str() {\n+        while i < module_path.len() && \"super\" == module_path[i].name.as_str() {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    module_to_string(&containing_module));\n             if let Some(parent) = containing_module.parent {\n@@ -2681,12 +2681,8 @@ impl<'a> Resolver<'a> {\n                                     namespace: Namespace)\n                                     -> Result<&'a NameBinding<'a>,\n                                               bool /* true if an error was reported */> {\n-        let module_path = segments.split_last()\n-                                  .unwrap()\n-                                  .1\n-                                  .iter()\n-                                  .map(|ps| ps.identifier.name)\n-                                  .collect::<Vec<_>>();\n+        let module_path =\n+            segments.split_last().unwrap().1.iter().map(|ps| ps.identifier).collect::<Vec<_>>();\n \n         let containing_module;\n         match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n@@ -2715,7 +2711,7 @@ impl<'a> Resolver<'a> {\n                                                 bool /* true if an error was reported */>\n         where T: Named,\n     {\n-        let module_path = segments.split_last().unwrap().1.iter().map(T::name).collect::<Vec<_>>();\n+        let module_path = segments.split_last().unwrap().1.iter().map(T::ident).collect::<Vec<_>>();\n         let root_module = self.graph_root;\n \n         let containing_module;\n@@ -2734,7 +2730,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let name = segments.last().unwrap().name();\n+        let name = segments.last().unwrap().ident().name;\n         let result =\n             self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n         result.success().ok_or(false)\n@@ -2976,9 +2972,8 @@ impl<'a> Resolver<'a> {\n                                     msg = format!(\"did you mean {}?\", msg);\n                                 } else {\n                                     // we display a help message if this is a module\n-                                    let name_path = path.segments.iter()\n-                                                        .map(|seg| seg.identifier.name)\n-                                                        .collect::<Vec<_>>();\n+                                    let name_path: Vec<_> =\n+                                        path.segments.iter().map(|seg| seg.identifier).collect();\n \n                                     match self.resolve_module_path(&name_path[..],\n                                                                    UseLexicalScope,\n@@ -3317,7 +3312,7 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier.name).collect();\n+        let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier).collect();\n         let mut path_resolution = err_path_resolution();\n         let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, Some(path.span)) {\n             Success(module) => {\n@@ -3469,26 +3464,24 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-fn names_to_string(names: &[Name]) -> String {\n+fn names_to_string(names: &[Ident]) -> String {\n     let mut first = true;\n     let mut result = String::new();\n-    for name in names {\n+    for ident in names {\n         if first {\n             first = false\n         } else {\n             result.push_str(\"::\")\n         }\n-        result.push_str(&name.as_str());\n+        result.push_str(&ident.name.as_str());\n     }\n     result\n }\n \n fn path_names_to_string(path: &Path, depth: usize) -> String {\n-    let names: Vec<ast::Name> = path.segments[..path.segments.len() - depth]\n-                                    .iter()\n-                                    .map(|seg| seg.identifier.name)\n-                                    .collect();\n-    names_to_string(&names[..])\n+    let names: Vec<_> =\n+        path.segments[..path.segments.len() - depth].iter().map(|seg| seg.identifier).collect();\n+    names_to_string(&names)\n }\n \n /// When an entity with a given name is not available in scope, we search for\n@@ -3551,15 +3544,15 @@ fn show_candidates(session: &mut DiagnosticBuilder,\n fn module_to_string(module: Module) -> String {\n     let mut names = Vec::new();\n \n-    fn collect_mod(names: &mut Vec<ast::Name>, module: Module) {\n+    fn collect_mod(names: &mut Vec<Ident>, module: Module) {\n         if let ModuleKind::Def(_, name) = module.kind {\n             if let Some(parent) = module.parent {\n-                names.push(name);\n+                names.push(Ident::with_empty_ctxt(name));\n                 collect_mod(names, parent);\n             }\n         } else {\n             // danger, shouldn't be ident?\n-            names.push(token::intern(\"<opaque>\"));\n+            names.push(token::str_to_ident(\"<opaque>\"));\n             collect_mod(names, module.parent.unwrap());\n         }\n     }\n@@ -3568,7 +3561,7 @@ fn module_to_string(module: Module) -> String {\n     if names.is_empty() {\n         return \"???\".to_string();\n     }\n-    names_to_string(&names.into_iter().rev().collect::<Vec<ast::Name>>())\n+    names_to_string(&names.into_iter().rev().collect::<Vec<_>>())\n }\n \n fn err_path_resolution() -> PathResolution {"}, {"sha": "2b3945bd0d9204e62f8acaf7978fa02a51528fc0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b81106a8525f96d5a5890720cee265e49e77028/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b81106a8525f96d5a5890720cee265e49e77028/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7b81106a8525f96d5a5890720cee265e49e77028", "patch": "@@ -24,7 +24,7 @@ use rustc::ty;\n use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n use rustc::hir::def::*;\n \n-use syntax::ast::{NodeId, Name};\n+use syntax::ast::{Ident, NodeId, Name};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n@@ -69,7 +69,7 @@ impl<'a> ImportDirectiveSubclass<'a> {\n pub struct ImportDirective<'a> {\n     pub id: NodeId,\n     parent: Module<'a>,\n-    module_path: Vec<Name>,\n+    module_path: Vec<Ident>,\n     imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n     subclass: ImportDirectiveSubclass<'a>,\n     span: Span,\n@@ -252,7 +252,7 @@ impl<'a> Resolver<'a> {\n \n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n-                                module_path: Vec<Name>,\n+                                module_path: Vec<Ident>,\n                                 subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n@@ -816,7 +816,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     }\n }\n \n-fn import_path_to_string(names: &[Name], subclass: &ImportDirectiveSubclass) -> String {\n+fn import_path_to_string(names: &[Ident], subclass: &ImportDirectiveSubclass) -> String {\n     if names.is_empty() {\n         import_directive_subclass_to_string(subclass)\n     } else {"}]}