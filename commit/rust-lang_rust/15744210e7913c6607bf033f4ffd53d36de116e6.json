{"sha": "15744210e7913c6607bf033f4ffd53d36de116e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NzQ0MjEwZTc5MTNjNjYwN2JmMDMzZjRmZmQ1M2QzNmRlMTE2ZTY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-09T15:24:53Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-11T19:33:44Z"}, "message": "Implement std::map as an iface/impl instead of an obj", "tree": {"sha": "9fdfa3473a37d7badf904dc58c220f15b90cf990", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fdfa3473a37d7badf904dc58c220f15b90cf990"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15744210e7913c6607bf033f4ffd53d36de116e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15744210e7913c6607bf033f4ffd53d36de116e6", "html_url": "https://github.com/rust-lang/rust/commit/15744210e7913c6607bf033f4ffd53d36de116e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15744210e7913c6607bf033f4ffd53d36de116e6/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c68345e57e82e7233e0f875bd416f46e1f8859e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c68345e57e82e7233e0f875bd416f46e1f8859e1", "html_url": "https://github.com/rust-lang/rust/commit/c68345e57e82e7233e0f875bd416f46e1f8859e1"}], "stats": {"total": 313, "additions": 129, "deletions": 184}, "files": [{"sha": "08df19b54e9ee4bc42fc817718d23eedff9e5d3f", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=15744210e7913c6607bf033f4ffd53d36de116e6", "patch": "@@ -20,10 +20,9 @@ export list_file_metadata;\n // Traverses an AST, reading all the information about use'd crates and native\n // libraries necessary for later resolving, typechecking, linking, etc.\n fn read_crates(sess: session::session, crate: ast::crate) {\n-    let e =\n-        @{sess: sess,\n-          crate_cache: @std::map::new_str_hash::<int>(),\n-          mutable next_crate_num: 1};\n+    let e = @{sess: sess,\n+              crate_cache: std::map::new_str_hash::<int>(),\n+              mutable next_crate_num: 1};\n     let v =\n         visit::mk_simple_visitor(@{visit_view_item:\n                                        bind visit_view_item(e, _),\n@@ -32,10 +31,9 @@ fn read_crates(sess: session::session, crate: ast::crate) {\n     visit::visit_crate(crate, (), v);\n }\n \n-type env =\n-    @{sess: session::session,\n-      crate_cache: @hashmap<str, int>,\n-      mutable next_crate_num: ast::crate_num};\n+type env = @{sess: session::session,\n+             crate_cache: hashmap<str, int>,\n+             mutable next_crate_num: ast::crate_num};\n \n fn visit_view_item(e: env, i: @ast::view_item) {\n     alt i.node {"}, {"sha": "c9382589d73c69736cf98679af7aaf894af1f47b", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 3, "deletions": 77, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=15744210e7913c6607bf033f4ffd53d36de116e6", "patch": "@@ -1,5 +1,5 @@\n import option;\n-import std::smallintmap;\n+import std::map;\n import syntax::ast::*;\n import syntax::ast_util;\n import syntax::{visit, codemap};\n@@ -18,14 +18,11 @@ tag ast_node {\n     node_res_ctor(@item);\n }\n \n-type map = std::map::hashmap<node_id, ast_node>;\n+type map = std::map::map<node_id, ast_node>;\n type ctx = @{map: map, mutable local_id: uint};\n \n fn map_crate(c: crate) -> map {\n-    // FIXME: This is using an adapter to convert the smallintmap\n-    // interface to the hashmap interface. It would be better to just\n-    // convert everything to use the smallintmap.\n-    let cx = @{map: new_smallintmap_int_adapter::<ast_node>(),\n+    let cx = @{map: std::map::new_int_hash(),\n                mutable local_id: 0u};\n \n     let v_map = visit::mk_simple_visitor\n@@ -98,77 +95,6 @@ fn map_expr(cx: ctx, ex: @expr) {\n     }\n }\n \n-fn new_smallintmap_int_adapter<V: copy>() -> std::map::hashmap<int, V> {\n-    let key_idx = fn (&&key: int) -> uint { key as uint };\n-    let idx_key = fn (idx: uint) -> int { idx as int };\n-    ret new_smallintmap_adapter(key_idx, idx_key);\n-}\n-\n-// This creates an object with the hashmap interface backed\n-// by the smallintmap type, because I don't want to go through\n-// the entire codebase adapting all the callsites to the different\n-// interface.\n-// FIXME: hashmap and smallintmap should support the same interface.\n-fn new_smallintmap_adapter<K: copy, V: copy>(key_idx: fn(K) -> uint,\n-                                           idx_key: fn(uint) -> K)\n-    -> std::map::hashmap<K, V> {\n-\n-    obj adapter<K: copy, V: copy>(map: smallintmap::smallintmap<V>,\n-                                key_idx: fn(K) -> uint,\n-                                idx_key: fn(uint) -> K) {\n-\n-        fn size() -> uint { fail }\n-\n-        fn insert(key: K, value: V) -> bool {\n-            let exists = smallintmap::contains_key(map, key_idx(key));\n-            smallintmap::insert(map, key_idx(key), value);\n-            ret !exists;\n-        }\n-\n-        fn contains_key(key: K) -> bool {\n-            ret smallintmap::contains_key(map, key_idx(key));\n-        }\n-\n-        fn get(key: K) -> V { ret smallintmap::get(map, key_idx(key)); }\n-\n-        fn find(key: K) -> option::t<V> {\n-            ret smallintmap::find(map, key_idx(key));\n-        }\n-\n-        fn remove(_key: K) -> option::t<V> { fail }\n-\n-        fn rehash() { fail }\n-\n-        fn items(it: block(K, V)) {\n-            let idx = 0u;\n-            for item in map.v {\n-                alt item {\n-                  option::some(elt) {\n-                    it(idx_key(idx), elt);\n-                  }\n-                  option::none. { }\n-                }\n-                idx += 1u;\n-            }\n-        }\n-        fn keys(it: block(K)) {\n-            let idx = 0u;\n-            for item in map.v {\n-                if item != option::none { it(idx_key(idx)); }\n-                idx += 1u;\n-            }\n-        }\n-        fn values(it: block(V)) {\n-            for item in map.v {\n-                alt item { option::some(elt) { it(elt); } _ {} }\n-            }\n-        }\n-    }\n-\n-    let map = smallintmap::mk::<V>();\n-    ret adapter(map, key_idx, idx_key);\n-}\n-\n fn node_span(node: ast_node) -> codemap::span {\n     alt node {\n       node_item(item) { item.span }"}, {"sha": "de723dc16cc4428ebaa97944aaf69897c4268498", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=15744210e7913c6607bf033f4ffd53d36de116e6", "patch": "@@ -218,7 +218,7 @@ type sp_constr = spanned<tsconstr>;\n \n type norm_constraint = {bit_num: uint, c: sp_constr};\n \n-type constr_map = @std::map::hashmap<def_id, constraint>;\n+type constr_map = std::map::hashmap<def_id, constraint>;\n \n /* Contains stuff that has to be computed up front */\n /* For easy access, the fn_info stores two special constraints for each\n@@ -278,7 +278,7 @@ type node_ann_table = @mutable [mutable ts_ann];\n \n \n /* mapping from function name to fn_info map */\n-type fn_info_map = @std::map::hashmap<node_id, fn_info>;\n+type fn_info_map = std::map::hashmap<node_id, fn_info>;\n \n type fn_ctxt =\n     {enclosing: fn_info, id: node_id, name: ident, ccx: crate_ctxt};\n@@ -483,7 +483,7 @@ fn num_constraints(m: fn_info) -> uint { ret m.num_constraints; }\n \n fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n     let na: [mutable ts_ann] = [mutable];\n-    ret {tcx: cx, node_anns: @mutable na, fm: @new_int_hash::<fn_info>()};\n+    ret {tcx: cx, node_anns: @mutable na, fm: new_int_hash::<fn_info>()};\n }\n \n /* Use e's type to determine whether it returns."}, {"sha": "939197716b4f944ffdba605fdc2fae97f7f172f3", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=15744210e7913c6607bf033f4ffd53d36de116e6", "patch": "@@ -102,7 +102,7 @@ fn mk_fn_info(ccx: crate_ctxt,\n               f_sp: span,\n               id: node_id) {\n     let name = visit::name_of_fn(fk);\n-    let res_map = @new_def_hash::<constraint>();\n+    let res_map = new_def_hash::<constraint>();\n     let next: uint = 0u;\n \n     let cx: ctxt = find_locals(ccx.tcx, fk, f_decl, f_body, f_sp, id);"}, {"sha": "244f696549e71e8e15b34cbd2923deb8baba5e3a", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=15744210e7913c6607bf033f4ffd53d36de116e6", "patch": "@@ -44,7 +44,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n             {\n              // just bogus\n              enclosing:\n-                 {constrs: @new_def_hash::<constraint>(),\n+                 {constrs: new_def_hash::<constraint>(),\n                   num_constraints: 0u,\n                   cf: return_val,\n                   i_return: ninit(0, \"\"),"}, {"sha": "3e134c743edad47a921d63e9d491dd72baf566e0", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=15744210e7913c6607bf033f4ffd53d36de116e6", "patch": "@@ -33,7 +33,7 @@ tag json {\n     /* Variant: list */\n     list(@[json]);\n     /* Variant: dict */\n-    dict(map::hashmap<str,json>);\n+    dict(map::map<str,json>);\n     /* Variant: null */\n     null;\n }"}, {"sha": "0ea2f35d719d1a2fb172f1b92653994fcbcadae1", "filename": "src/libstd/map.rs", "status": "modified", "additions": 49, "deletions": 84, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=15744210e7913c6607bf033f4ffd53d36de116e6", "patch": "@@ -1,7 +1,7 @@\n /*\n Module: map\n \n-A hashmap\n+A map type\n */\n \n /* Section: Types */\n@@ -25,14 +25,17 @@ type eqfn<K> = fn(K, K) -> bool;\n /*\n Type: hashset\n \n-A convenience type to treat a hashmap as a set\n+A convenience type to treat a map as a set\n */\n-type hashset<K> = hashmap<K, ()>;\n+type set<K> = map<K, ()>;\n+\n+// Temporary alias to make migration easier\n+type hashmap<K, V> = map<K, V>;\n \n /*\n-Obj: hashmap\n+IFace: map\n */\n-type hashmap<K, V> = obj {\n+iface map<K: copy, V: copy> {\n     /*\n     Method: size\n \n@@ -72,20 +75,14 @@ type hashmap<K, V> = obj {\n     Get the value for the specified key. If the key does not exist\n     in the map then returns none.\n     */\n-    fn find(K) -> core::option::t<V>;\n+    fn find(K) -> option::t<V>;\n     /*\n     Method: remove\n \n     Remove and return a value from the map. If the key does not exist\n     in the map then returns none.\n     */\n-    fn remove(K) -> core::option::t<V>;\n-    /*\n-    Method: rehash\n-\n-    Force map growth and rehashing\n-    */\n-    fn rehash();\n+    fn remove(K) -> option::t<V>;\n     /*\n     Method: items\n \n@@ -98,46 +95,44 @@ type hashmap<K, V> = obj {\n     Iterate over all the keys in the map\n     */\n     fn keys(block(K));\n-\n     /*\n     Iterate over all the values in the map\n     */\n     fn values(block(V));\n-};\n-\n-/* Section: Operations */\n+}\n \n+// FIXME: package this up and export it as a datatype usable for\n+// external code that doesn't want to pay the cost of a box and vtable\n+// lookups.\n mod chained {\n-    type entry<K: copy, V: copy> = {\n+    type entry<K, V> = {\n         hash: uint,\n         key: K,\n         mutable value: V,\n         mutable next: chain<K, V>\n     };\n \n-    tag chain<K: copy, V: copy> {\n+    tag chain<K, V> {\n         present(@entry<K, V>);\n         absent;\n     }\n \n-    type t<K: copy, V: copy> = {\n+    type t<K, V> = {\n         mutable size: uint,\n         mutable chains: [mutable chain<K,V>],\n         hasher: hashfn<K>,\n         eqer: eqfn<K>\n     };\n \n-    tag search_result<K: copy, V: copy> {\n+    tag search_result<K, V> {\n         not_found;\n         found_first(uint, @entry<K,V>);\n         found_after(@entry<K,V>, @entry<K,V>);\n     }\n \n-    fn search_rem<K: copy, V: copy>(tbl: t<K,V>,\n-                                  k: K,\n-                                  h: uint,\n-                                  idx: uint,\n-                                  e_root: @entry<K,V>) -> search_result<K,V> {\n+    fn search_rem<K: copy, V: copy>(\n+        tbl: t<K,V>, k: K, h: uint, idx: uint,\n+        e_root: @entry<K,V>) -> search_result<K,V> {\n         let e0 = e_root;\n         let comp = 1u;   // for logging\n         while true {\n@@ -295,62 +290,40 @@ mod chained {\n         }\n     }\n \n-    obj o<K: copy, V: copy>(tbl: @t<K,V>,\n-                          lf: util::rational) {\n-        fn size() -> uint {\n-            ret tbl.size;\n-        }\n+    impl <K: copy, V: copy> of map<K, V> for t<K, V> {\n+        fn size() -> uint { self.size }\n \n         fn insert(k: K, v: V) -> bool {\n-            let nchains = vec::len(tbl.chains);\n-            let load = {num:tbl.size + 1u as int, den:nchains as int};\n-            if !util::rational_leq(load, lf) {\n-                rehash(*tbl);\n-            }\n-            ret insert(*tbl, k, v);\n+            let nchains = vec::len(self.chains);\n+            let load = {num: self.size + 1u as int, den: nchains as int};\n+            // Structural consts would be nice. This is a const 3/4\n+            // load factor that we compare against.\n+            if !util::rational_leq(load, {num:3, den:4}) { rehash(self); }\n+            ret insert(self, k, v);\n         }\n \n-        fn contains_key(k: K) -> bool {\n-            ret core::option::is_some(get(*tbl, k));\n-        }\n+        fn contains_key(k: K) -> bool { option::is_some(get(self, k)) }\n \n-        fn get(k: K) -> V {\n-            ret core::option::get(get(*tbl, k));\n-        }\n+        fn get(k: K) -> V { option::get(get(self, k)) }\n \n-        fn find(k: K) -> core::option::t<V> {\n-            ret get(*tbl, k);\n-        }\n+        fn find(k: K) -> option::t<V> { get(self, k) }\n \n-        fn remove(k: K) -> core::option::t<V> {\n-            ret remove(*tbl, k);\n-        }\n+        fn remove(k: K) -> option::t<V> { remove(self, k) }\n \n-        fn rehash() {\n-            rehash(*tbl);\n-        }\n+        fn items(blk: block(K, V)) { items(self, blk); }\n \n-        fn items(blk: block(K, V)) {\n-            items(*tbl, blk);\n-        }\n-\n-        fn keys(blk: block(K)) {\n-            items(*tbl) { |k, _v| blk(k) }\n-        }\n+        fn keys(blk: block(K)) { items(self) { |k, _v| blk(k) } }\n \n-        fn values(blk: block(V)) {\n-            items(*tbl) { |_k, v| blk(v) }\n-        }\n+        fn values(blk: block(V)) { items(self) { |_k, v| blk(v) } }\n     }\n \n-    fn mk<K: copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>)\n-        -> hashmap<K,V> {\n+    fn mk<K: copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>) -> map<K,V> {\n         let initial_capacity: uint = 32u; // 2^5\n-        let t = @{mutable size: 0u,\n-                  mutable chains: chains(initial_capacity),\n-                  hasher: hasher,\n-                  eqer: eqer};\n-        ret o(t, {num:3, den:4});\n+        let slf: t<K, V> = {mutable size: 0u,\n+                            mutable chains: chains(initial_capacity),\n+                            hasher: hasher,\n+                            eqer: eqer};\n+        slf as map::<K, V>\n     }\n }\n \n@@ -365,16 +338,16 @@ hasher - The hash function for key type K\n eqer - The equality function for key type K\n */\n fn mk_hashmap<K: copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>)\n-    -> hashmap<K, V> {\n-    ret chained::mk(hasher, eqer);\n+    -> map<K, V> {\n+    chained::mk(hasher, eqer)\n }\n \n /*\n Function: new_str_hash\n \n Construct a hashmap for string keys\n */\n-fn new_str_hash<V: copy>() -> hashmap<str, V> {\n+fn new_str_hash<V: copy>() -> map<str, V> {\n     ret mk_hashmap(str::hash, str::eq);\n }\n \n@@ -383,7 +356,7 @@ Function: new_bytes_hash\n \n Construct a hashmap for byte string keys\n */\n-fn new_bytes_hash<V: copy>() -> hashmap<[u8], V> {\n+fn new_bytes_hash<V: copy>() -> map<[u8], V> {\n     ret mk_hashmap(vec::u8::hash, vec::u8::eq);\n }\n \n@@ -392,7 +365,7 @@ Function: new_int_hash\n \n Construct a hashmap for int keys\n */\n-fn new_int_hash<V: copy>() -> hashmap<int, V> {\n+fn new_int_hash<V: copy>() -> map<int, V> {\n     fn hash_int(&&x: int) -> uint { int::hash(x) }\n     fn eq_int(&&a: int, &&b: int) -> bool { ret a == b; }\n     ret mk_hashmap(hash_int, eq_int);\n@@ -403,7 +376,7 @@ Function: new_uint_hash\n \n Construct a hashmap for uint keys\n */\n-fn new_uint_hash<V: copy>() -> hashmap<uint, V> {\n+fn new_uint_hash<V: copy>() -> map<uint, V> {\n     fn hash_uint(&&x: uint) -> uint { uint::hash(x) }\n     fn eq_uint(&&a: uint, &&b: uint) -> bool { ret a == b; }\n     ret mk_hashmap(hash_uint, eq_uint);\n@@ -414,12 +387,4 @@ Function: set_add\n \n Convenience function for adding keys to a hashmap with nil type keys\n */\n-fn set_add<K>(set: hashset<K>, key: K) -> bool { ret set.insert(key, ()); }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n+fn set_add<K>(set: set<K>, key: K) -> bool { ret set.insert(key, ()); }"}, {"sha": "ca618baa5547b227597665c4aef99d8f24e18809", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=15744210e7913c6607bf033f4ffd53d36de116e6", "patch": "@@ -80,3 +80,67 @@ fn max_key<T>(m: smallintmap<T>) -> uint {\n     ret vec::len::<option::t<T>>(m.v);\n }\n \n+/*\n+Impl: map\n+\n+Implements the map::map interface for smallintmap\n+*/\n+impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n+    fn size() -> uint {\n+        let sz = 0u;\n+        for item in self.v {\n+            alt item { some(_) { sz += 1u; } _ {} }\n+        }\n+        sz\n+    }\n+    fn insert(&&key: uint, value: V) -> bool {\n+        let exists = contains_key(self, key);\n+        insert(self, key, value);\n+        ret !exists;\n+    }\n+    fn remove(&&key: uint) -> option::t<V> {\n+        if key >= vec::len(self.v) { ret none; }\n+        let old = self.v[key];\n+        self.v[key] = none;\n+        old\n+    }\n+    fn contains_key(&&key: uint) -> bool {\n+        contains_key(self, key)\n+    }\n+    fn get(&&key: uint) -> V { get(self, key) }\n+    fn find(&&key: uint) -> option::t<V> { find(self, key) }\n+    fn rehash() { fail }\n+    fn items(it: block(&&uint, V)) {\n+        let idx = 0u;\n+        for item in self.v {\n+            alt item {\n+              some(elt) {\n+                it(idx, elt);\n+              }\n+              none. { }\n+            }\n+            idx += 1u;\n+        }\n+    }\n+    fn keys(it: block(&&uint)) {\n+        let idx = 0u;\n+        for item in self.v {\n+            if item != none { it(idx); }\n+            idx += 1u;\n+        }\n+    }\n+    fn values(it: block(V)) {\n+        for item in self.v {\n+            alt item { some(elt) { it(elt); } _ {} }\n+        }\n+    }\n+}\n+\n+/*\n+Funtion: as_map\n+\n+Cast the given smallintmap to a map::map\n+*/\n+fn as_map<V>(s: smallintmap<V>) -> map::map<uint, V> {\n+    s as map::map::<uint, V>\n+}"}, {"sha": "8762c9e6198c10819dc553cc7b25c098e045a123", "filename": "src/test/stdtest/map.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Ftest%2Fstdtest%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15744210e7913c6607bf033f4ffd53d36de116e6/src%2Ftest%2Fstdtest%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmap.rs?ref=15744210e7913c6607bf033f4ffd53d36de116e6", "patch": "@@ -78,7 +78,7 @@ fn test_simple() {\n \n \n /**\n- * Force map growth and rehashing.\n+ * Force map growth\n  */\n #[test]\n fn test_growth() {\n@@ -107,7 +107,6 @@ fn test_growth() {\n     assert (hm_uu.insert(num_to_insert, 17u));\n     assert (hm_uu.get(num_to_insert) == 17u);\n     #debug(\"-----\");\n-    hm_uu.rehash();\n     i = 0u;\n     while i < num_to_insert {\n         #debug(\"get(%u) = %u\", i, hm_uu.get(i));\n@@ -142,7 +141,6 @@ fn test_growth() {\n     assert (str::eq(hm_ss.get(uint::to_str(num_to_insert, 2u)),\n                     uint::to_str(17u, 2u)));\n     #debug(\"-----\");\n-    hm_ss.rehash();\n     i = 0u;\n     while i < num_to_insert {\n         #debug(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n@@ -200,9 +198,6 @@ fn test_removal() {\n         i += 2u;\n     }\n     #debug(\"-----\");\n-    #debug(\"rehashing\");\n-    hm.rehash();\n-    #debug(\"-----\");\n     i = 1u;\n     while i < num_to_insert {\n         #debug(\"get(%u) = %u\", i, hm.get(i));\n@@ -225,9 +220,6 @@ fn test_removal() {\n         i += 1u;\n     }\n     #debug(\"-----\");\n-    #debug(\"rehashing\");\n-    hm.rehash();\n-    #debug(\"-----\");\n     assert (hm.size() == num_to_insert);\n     i = 0u;\n     while i < num_to_insert {"}]}