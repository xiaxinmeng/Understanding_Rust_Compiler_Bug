{"sha": "606c3907251397a42e23d3e60de31be9d32525d5", "node_id": "C_kwDOAAsO6NoAKDYwNmMzOTA3MjUxMzk3YTQyZTIzZDNlNjBkZTMxYmU5ZDMyNTI1ZDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-12T10:46:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-12T10:46:19Z"}, "message": "Auto merge of #106760 - compiler-errors:rollup-0bogyco, r=compiler-errors\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #103236 (doc: rewrite doc for signed int::{carrying_add,borrowing_sub})\n - #103800 (Stabilize `::{core,std}::pin::pin!`)\n - #106097 (Migrate mir_build diagnostics 2 of 3)\n - #106170 (Move autoderef to `rustc_hir_analysis`)\n - #106323 (Stabilize f16c_target_feature)\n - #106360 (Tweak E0277 `&`-removal suggestions)\n - #106524 (Label `struct/enum constructor` instead of `fn item`, mention that it should be called on type mismatch)\n - #106739 (Remove `<dyn AstConv<'tcx>>::fun(c, ...)` calls in favour of `c.astconv().fun(...)`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d04af6e38cfba4aac7f02930873467da917f6c31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d04af6e38cfba4aac7f02930873467da917f6c31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/606c3907251397a42e23d3e60de31be9d32525d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/606c3907251397a42e23d3e60de31be9d32525d5", "html_url": "https://github.com/rust-lang/rust/commit/606c3907251397a42e23d3e60de31be9d32525d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/606c3907251397a42e23d3e60de31be9d32525d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b8590ef3bd1221830ec8a4131ea9d02b1636746", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8590ef3bd1221830ec8a4131ea9d02b1636746", "html_url": "https://github.com/rust-lang/rust/commit/2b8590ef3bd1221830ec8a4131ea9d02b1636746"}, {"sha": "9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ec36f56684cbd0fa90ab2da3c5084811f7a3989", "html_url": "https://github.com/rust-lang/rust/commit/9ec36f56684cbd0fa90ab2da3c5084811f7a3989"}], "stats": {"total": 3061, "additions": 1676, "deletions": 1385}, "files": [{"sha": "739963fffd132b217c25d6f083805563aa99c2b7", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -187,7 +187,7 @@ const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"bmi2\", None),\n     (\"cmpxchg16b\", Some(sym::cmpxchg16b_target_feature)),\n     (\"ermsb\", Some(sym::ermsb_target_feature)),\n-    (\"f16c\", Some(sym::f16c_target_feature)),\n+    (\"f16c\", None),\n     (\"fma\", None),\n     (\"fxsr\", None),\n     (\"gfni\", Some(sym::avx512_target_feature)),\n@@ -396,7 +396,6 @@ pub fn from_target_feature(\n                 Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n                 Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n                 Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n-                Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n                 Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,\n                 Some(sym::bpf_target_feature) => rust_features.bpf_target_feature,\n                 Some(sym::aarch64_ver_target_feature) => rust_features.aarch64_ver_target_feature,"}, {"sha": "41f458f6c1785e31a83dec0c9de3efc6cc00bb60", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -120,3 +120,7 @@ hir_analysis_self_in_impl_self =\n \n hir_analysis_linkage_type =\n     invalid type for variable with `#[linkage]` attribute\n+\n+hir_analysis_auto_deref_reached_recursion_limit = reached the recursion limit while auto-dereferencing `{$ty}`\n+    .label = deref recursion limit reached\n+    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)"}, {"sha": "a082c0b61fa7ed293b873b9e054f7f9e1481957e", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -303,3 +303,64 @@ mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once a\n     .mutable_borrow = another mutable borrow, by `{$name_mut}`, occurs here\n     .immutable_borrow = also borrowed as immutable, by `{$name_immut}`, here\n     .moved = also moved into `{$name_moved}` here\n+\n+mir_build_union_pattern = cannot use unions in constant patterns\n+\n+mir_build_type_not_structural =\n+     to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+mir_build_unsized_pattern = cannot use unsized non-slice type `{$non_sm_ty}` in constant patterns\n+\n+mir_build_invalid_pattern = `{$non_sm_ty}` cannot be used in patterns\n+\n+mir_build_float_pattern = floating-point types cannot be used in patterns\n+\n+mir_build_pointer_pattern = function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.\n+\n+mir_build_indirect_structural_match =\n+    to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+mir_build_nontrivial_structural_match =\n+    to use a constant of type `{$non_sm_ty}` in a pattern, the constant's initializer must be trivial or `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+mir_build_overlapping_range_endpoints = multiple patterns overlap on their endpoints\n+    .range = ... with this range\n+    .note = you likely meant to write mutually exclusive ranges\n+\n+mir_build_non_exhaustive_omitted_pattern = some variants are not matched explicitly\n+    .help = ensure that all variants are matched explicitly by adding the suggested match arms\n+    .note = the matched value is of type `{$scrut_ty}` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+mir_build_uncovered = {$count ->\n+        [1] pattern `{$witness_1}`\n+        [2] patterns `{$witness_1}` and `{$witness_2}`\n+        [3] patterns `{$witness_1}`, `{$witness_2}` and `{$witness_3}`\n+        *[other] patterns `{$witness_1}`, `{$witness_2}`, `{$witness_3}` and {$remainder} more\n+    } not covered\n+\n+mir_build_pattern_not_covered = refutable pattern in {$origin}\n+    .pattern_ty = the matched value is of type `{$pattern_ty}`\n+\n+mir_build_inform_irrefutable = `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+\n+mir_build_more_information = for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+\n+mir_build_res_defined_here = {$res} defined here\n+\n+mir_build_adt_defined_here = `{$ty}` defined here\n+\n+mir_build_variant_defined_here = not covered\n+\n+mir_build_interpreted_as_const = introduce a variable instead\n+\n+mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as {$article} {$res} pattern, not a new variable\n+\n+mir_build_suggest_if_let = you might want to use `if let` to ignore the {$count ->\n+        [one] variant that isn't\n+        *[other] variants that aren't\n+    } matched\n+\n+mir_build_suggest_let_else = you might want to use `let else` to handle the {$count ->\n+        [one] variant that isn't\n+        *[other] variants that aren't\n+    } matched"}, {"sha": "14eb4a5502d5c2f2df139f117eba5e09f5793cf9", "filename": "compiler/rustc_error_messages/locales/en-US/trait_selection.ftl", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftrait_selection.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftrait_selection.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftrait_selection.ftl?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,10 +2,6 @@ trait_selection_dump_vtable_entries = vtable entries for `{$trait_ref}`: {$entri\n \n trait_selection_unable_to_construct_constant_value = unable to construct a constant value for the unevaluated constant {$unevaluated}\n \n-trait_selection_auto_deref_reached_recursion_limit = reached the recursion limit while auto-dereferencing `{$ty}`\n-    .label = deref recursion limit reached\n-    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n-\n trait_selection_empty_on_clause_in_rustc_on_unimplemented = empty `on`-clause in `#[rustc_on_unimplemented]`\n     .label = empty on-clause here\n "}, {"sha": "fcbc5bacfcccf12eca59cea62911ab0467600479", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -161,6 +161,8 @@ declare_features! (\n     (accepted, extern_crate_self, \"1.34.0\", Some(56409), None),\n     /// Allows access to crate names passed via `--extern` through prelude.\n     (accepted, extern_prelude, \"1.30.0\", Some(44660), None),\n+    /// Allows using F16C intrinsics from `core::arch::{x86, x86_64}`.\n+    (accepted, f16c_target_feature, \"CURRENT_RUSTC_VERSION\", Some(44839), None),\n     /// Allows field shorthands (`x` meaning `x: x`) in struct literal expressions.\n     (accepted, field_init_shorthand, \"1.17.0\", Some(37340), None),\n     /// Allows `#[must_use]` on functions, and introduces must-use operators (RFC 1940)."}, {"sha": "f0bc35d06bfd04e7697bab13e8de2fa91ad00575", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -254,7 +254,6 @@ declare_features! (\n     (active, bpf_target_feature, \"1.54.0\", Some(44839), None),\n     (active, cmpxchg16b_target_feature, \"1.32.0\", Some(44839), None),\n     (active, ermsb_target_feature, \"1.49.0\", Some(44839), None),\n-    (active, f16c_target_feature, \"1.36.0\", Some(44839), None),\n     (active, hexagon_target_feature, \"1.27.0\", Some(44839), None),\n     (active, mips_target_feature, \"1.27.0\", Some(44839), None),\n     (active, movbe_target_feature, \"1.34.0\", Some(44839), None),"}, {"sha": "ce3682a8f2d5cda48084a4566eb84e76ccb4e9c4", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 558, "deletions": 576, "changes": 1134, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,6 +1,6 @@\n use super::IsMethodCall;\n use crate::astconv::{\n-    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n+    CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n     GenericArgCountResult, GenericArgPosition,\n };\n use crate::errors::AssocTypeBindingNotAllowed;\n@@ -18,642 +18,624 @@ use rustc_session::lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS;\n use rustc_span::{symbol::kw, Span};\n use smallvec::SmallVec;\n \n-impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n-    /// Report an error that a generic argument did not match the generic parameter that was\n-    /// expected.\n-    fn generic_arg_mismatch_err(\n-        tcx: TyCtxt<'_>,\n-        arg: &GenericArg<'_>,\n-        param: &GenericParamDef,\n-        possible_ordering_error: bool,\n-        help: Option<&str>,\n-    ) {\n-        let sess = tcx.sess;\n-        let mut err = struct_span_err!(\n-            sess,\n-            arg.span(),\n-            E0747,\n-            \"{} provided when a {} was expected\",\n-            arg.descr(),\n-            param.kind.descr(),\n-        );\n-\n-        if let GenericParamDefKind::Const { .. } = param.kind {\n-            if matches!(arg, GenericArg::Type(hir::Ty { kind: hir::TyKind::Infer, .. })) {\n-                err.help(\"const arguments cannot yet be inferred with `_`\");\n-                if sess.is_nightly_build() {\n-                    err.help(\n-                        \"add `#![feature(generic_arg_infer)]` to the crate attributes to enable\",\n-                    );\n-                }\n+/// Report an error that a generic argument did not match the generic parameter that was\n+/// expected.\n+fn generic_arg_mismatch_err(\n+    tcx: TyCtxt<'_>,\n+    arg: &GenericArg<'_>,\n+    param: &GenericParamDef,\n+    possible_ordering_error: bool,\n+    help: Option<&str>,\n+) {\n+    let sess = tcx.sess;\n+    let mut err = struct_span_err!(\n+        sess,\n+        arg.span(),\n+        E0747,\n+        \"{} provided when a {} was expected\",\n+        arg.descr(),\n+        param.kind.descr(),\n+    );\n+\n+    if let GenericParamDefKind::Const { .. } = param.kind {\n+        if matches!(arg, GenericArg::Type(hir::Ty { kind: hir::TyKind::Infer, .. })) {\n+            err.help(\"const arguments cannot yet be inferred with `_`\");\n+            if sess.is_nightly_build() {\n+                err.help(\"add `#![feature(generic_arg_infer)]` to the crate attributes to enable\");\n             }\n         }\n+    }\n \n-        let add_braces_suggestion = |arg: &GenericArg<'_>, err: &mut Diagnostic| {\n-            let suggestions = vec![\n-                (arg.span().shrink_to_lo(), String::from(\"{ \")),\n-                (arg.span().shrink_to_hi(), String::from(\" }\")),\n-            ];\n-            err.multipart_suggestion(\n-                \"if this generic argument was intended as a const parameter, \\\n+    let add_braces_suggestion = |arg: &GenericArg<'_>, err: &mut Diagnostic| {\n+        let suggestions = vec![\n+            (arg.span().shrink_to_lo(), String::from(\"{ \")),\n+            (arg.span().shrink_to_hi(), String::from(\" }\")),\n+        ];\n+        err.multipart_suggestion(\n+            \"if this generic argument was intended as a const parameter, \\\n                  surround it with braces\",\n-                suggestions,\n-                Applicability::MaybeIncorrect,\n-            );\n-        };\n-\n-        // Specific suggestion set for diagnostics\n-        match (arg, &param.kind) {\n-            (\n-                GenericArg::Type(hir::Ty {\n-                    kind: hir::TyKind::Path(rustc_hir::QPath::Resolved(_, path)),\n-                    ..\n-                }),\n-                GenericParamDefKind::Const { .. },\n-            ) => match path.res {\n-                Res::Err => {\n-                    add_braces_suggestion(arg, &mut err);\n-                    err.set_primary_message(\n-                        \"unresolved item provided when a constant was expected\",\n-                    )\n+            suggestions,\n+            Applicability::MaybeIncorrect,\n+        );\n+    };\n+\n+    // Specific suggestion set for diagnostics\n+    match (arg, &param.kind) {\n+        (\n+            GenericArg::Type(hir::Ty {\n+                kind: hir::TyKind::Path(rustc_hir::QPath::Resolved(_, path)),\n+                ..\n+            }),\n+            GenericParamDefKind::Const { .. },\n+        ) => match path.res {\n+            Res::Err => {\n+                add_braces_suggestion(arg, &mut err);\n+                err.set_primary_message(\"unresolved item provided when a constant was expected\")\n                     .emit();\n-                    return;\n-                }\n-                Res::Def(DefKind::TyParam, src_def_id) => {\n-                    if let Some(param_local_id) = param.def_id.as_local() {\n-                        let param_name = tcx.hir().ty_param_name(param_local_id);\n-                        let param_type = tcx.type_of(param.def_id);\n-                        if param_type.is_suggestable(tcx, false) {\n-                            err.span_suggestion(\n-                                tcx.def_span(src_def_id),\n-                                \"consider changing this type parameter to be a `const` generic\",\n-                                format!(\"const {}: {}\", param_name, param_type),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        };\n-                    }\n-                }\n-                _ => add_braces_suggestion(arg, &mut err),\n-            },\n-            (\n-                GenericArg::Type(hir::Ty { kind: hir::TyKind::Path(_), .. }),\n-                GenericParamDefKind::Const { .. },\n-            ) => add_braces_suggestion(arg, &mut err),\n-            (\n-                GenericArg::Type(hir::Ty { kind: hir::TyKind::Array(_, len), .. }),\n-                GenericParamDefKind::Const { .. },\n-            ) if tcx.type_of(param.def_id) == tcx.types.usize => {\n-                let snippet = sess.source_map().span_to_snippet(tcx.hir().span(len.hir_id()));\n-                if let Ok(snippet) = snippet {\n-                    err.span_suggestion(\n-                        arg.span(),\n-                        \"array type provided where a `usize` was expected, try\",\n-                        format!(\"{{ {} }}\", snippet),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                return;\n+            }\n+            Res::Def(DefKind::TyParam, src_def_id) => {\n+                if let Some(param_local_id) = param.def_id.as_local() {\n+                    let param_name = tcx.hir().ty_param_name(param_local_id);\n+                    let param_type = tcx.type_of(param.def_id);\n+                    if param_type.is_suggestable(tcx, false) {\n+                        err.span_suggestion(\n+                            tcx.def_span(src_def_id),\n+                            \"consider changing this type parameter to be a `const` generic\",\n+                            format!(\"const {}: {}\", param_name, param_type),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    };\n                 }\n             }\n-            (GenericArg::Const(cnst), GenericParamDefKind::Type { .. }) => {\n-                let body = tcx.hir().body(cnst.value.body);\n-                if let rustc_hir::ExprKind::Path(rustc_hir::QPath::Resolved(_, path)) =\n-                    body.value.kind\n-                {\n-                    if let Res::Def(DefKind::Fn { .. }, id) = path.res {\n-                        err.help(&format!(\n-                            \"`{}` is a function item, not a type\",\n-                            tcx.item_name(id)\n-                        ));\n-                        err.help(\"function item types cannot be named directly\");\n-                    }\n+            _ => add_braces_suggestion(arg, &mut err),\n+        },\n+        (\n+            GenericArg::Type(hir::Ty { kind: hir::TyKind::Path(_), .. }),\n+            GenericParamDefKind::Const { .. },\n+        ) => add_braces_suggestion(arg, &mut err),\n+        (\n+            GenericArg::Type(hir::Ty { kind: hir::TyKind::Array(_, len), .. }),\n+            GenericParamDefKind::Const { .. },\n+        ) if tcx.type_of(param.def_id) == tcx.types.usize => {\n+            let snippet = sess.source_map().span_to_snippet(tcx.hir().span(len.hir_id()));\n+            if let Ok(snippet) = snippet {\n+                err.span_suggestion(\n+                    arg.span(),\n+                    \"array type provided where a `usize` was expected, try\",\n+                    format!(\"{{ {} }}\", snippet),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+        (GenericArg::Const(cnst), GenericParamDefKind::Type { .. }) => {\n+            let body = tcx.hir().body(cnst.value.body);\n+            if let rustc_hir::ExprKind::Path(rustc_hir::QPath::Resolved(_, path)) = body.value.kind\n+            {\n+                if let Res::Def(DefKind::Fn { .. }, id) = path.res {\n+                    err.help(&format!(\"`{}` is a function item, not a type\", tcx.item_name(id)));\n+                    err.help(\"function item types cannot be named directly\");\n                 }\n             }\n-            _ => {}\n         }\n+        _ => {}\n+    }\n \n-        let kind_ord = param.kind.to_ord();\n-        let arg_ord = arg.to_ord();\n+    let kind_ord = param.kind.to_ord();\n+    let arg_ord = arg.to_ord();\n \n-        // This note is only true when generic parameters are strictly ordered by their kind.\n-        if possible_ordering_error && kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n-            let (first, last) = if kind_ord < arg_ord {\n-                (param.kind.descr(), arg.descr())\n-            } else {\n-                (arg.descr(), param.kind.descr())\n-            };\n-            err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n-            if let Some(help) = help {\n-                err.help(help);\n-            }\n+    // This note is only true when generic parameters are strictly ordered by their kind.\n+    if possible_ordering_error && kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n+        let (first, last) = if kind_ord < arg_ord {\n+            (param.kind.descr(), arg.descr())\n+        } else {\n+            (arg.descr(), param.kind.descr())\n+        };\n+        err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n+        if let Some(help) = help {\n+            err.help(help);\n         }\n+    }\n+\n+    err.emit();\n+}\n \n-        err.emit();\n+/// Creates the relevant generic argument substitutions\n+/// corresponding to a set of generic parameters. This is a\n+/// rather complex function. Let us try to explain the role\n+/// of each of its parameters:\n+///\n+/// To start, we are given the `def_id` of the thing we are\n+/// creating the substitutions for, and a partial set of\n+/// substitutions `parent_substs`. In general, the substitutions\n+/// for an item begin with substitutions for all the \"parents\" of\n+/// that item -- e.g., for a method it might include the\n+/// parameters from the impl.\n+///\n+/// Therefore, the method begins by walking down these parents,\n+/// starting with the outermost parent and proceed inwards until\n+/// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n+/// first to see if the parent's substitutions are listed in there. If so,\n+/// we can append those and move on. Otherwise, it invokes the\n+/// three callback functions:\n+///\n+/// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n+///   generic arguments that were given to that parent from within\n+///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n+///   might refer to the trait `Foo`, and the arguments might be\n+///   `[T]`. The boolean value indicates whether to infer values\n+///   for arguments whose values were not explicitly provided.\n+/// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n+///   instantiate a `GenericArg`.\n+/// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n+///   creates a suitable inference variable.\n+pub fn create_substs_for_generic_args<'tcx, 'a>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    parent_substs: &[subst::GenericArg<'tcx>],\n+    has_self: bool,\n+    self_ty: Option<Ty<'tcx>>,\n+    arg_count: &GenericArgCountResult,\n+    ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n+) -> SubstsRef<'tcx> {\n+    // Collect the segments of the path; we need to substitute arguments\n+    // for parameters throughout the entire path (wherever there are\n+    // generic parameters).\n+    let mut parent_defs = tcx.generics_of(def_id);\n+    let count = parent_defs.count();\n+    let mut stack = vec![(def_id, parent_defs)];\n+    while let Some(def_id) = parent_defs.parent {\n+        parent_defs = tcx.generics_of(def_id);\n+        stack.push((def_id, parent_defs));\n     }\n \n-    /// Creates the relevant generic argument substitutions\n-    /// corresponding to a set of generic parameters. This is a\n-    /// rather complex function. Let us try to explain the role\n-    /// of each of its parameters:\n-    ///\n-    /// To start, we are given the `def_id` of the thing we are\n-    /// creating the substitutions for, and a partial set of\n-    /// substitutions `parent_substs`. In general, the substitutions\n-    /// for an item begin with substitutions for all the \"parents\" of\n-    /// that item -- e.g., for a method it might include the\n-    /// parameters from the impl.\n-    ///\n-    /// Therefore, the method begins by walking down these parents,\n-    /// starting with the outermost parent and proceed inwards until\n-    /// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n-    /// first to see if the parent's substitutions are listed in there. If so,\n-    /// we can append those and move on. Otherwise, it invokes the\n-    /// three callback functions:\n-    ///\n-    /// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n-    ///   generic arguments that were given to that parent from within\n-    ///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n-    ///   might refer to the trait `Foo`, and the arguments might be\n-    ///   `[T]`. The boolean value indicates whether to infer values\n-    ///   for arguments whose values were not explicitly provided.\n-    /// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n-    ///   instantiate a `GenericArg`.\n-    /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n-    ///   creates a suitable inference variable.\n-    pub fn create_substs_for_generic_args<'a>(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        parent_substs: &[subst::GenericArg<'tcx>],\n-        has_self: bool,\n-        self_ty: Option<Ty<'tcx>>,\n-        arg_count: &GenericArgCountResult,\n-        ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n-    ) -> SubstsRef<'tcx> {\n-        // Collect the segments of the path; we need to substitute arguments\n-        // for parameters throughout the entire path (wherever there are\n-        // generic parameters).\n-        let mut parent_defs = tcx.generics_of(def_id);\n-        let count = parent_defs.count();\n-        let mut stack = vec![(def_id, parent_defs)];\n-        while let Some(def_id) = parent_defs.parent {\n-            parent_defs = tcx.generics_of(def_id);\n-            stack.push((def_id, parent_defs));\n+    // We manually build up the substitution, rather than using convenience\n+    // methods in `subst.rs`, so that we can iterate over the arguments and\n+    // parameters in lock-step linearly, instead of trying to match each pair.\n+    let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n+    // Iterate over each segment of the path.\n+    while let Some((def_id, defs)) = stack.pop() {\n+        let mut params = defs.params.iter().peekable();\n+\n+        // If we have already computed substitutions for parents, we can use those directly.\n+        while let Some(&param) = params.peek() {\n+            if let Some(&kind) = parent_substs.get(param.index as usize) {\n+                substs.push(kind);\n+                params.next();\n+            } else {\n+                break;\n+            }\n         }\n \n-        // We manually build up the substitution, rather than using convenience\n-        // methods in `subst.rs`, so that we can iterate over the arguments and\n-        // parameters in lock-step linearly, instead of trying to match each pair.\n-        let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n-        // Iterate over each segment of the path.\n-        while let Some((def_id, defs)) = stack.pop() {\n-            let mut params = defs.params.iter().peekable();\n-\n-            // If we have already computed substitutions for parents, we can use those directly.\n-            while let Some(&param) = params.peek() {\n-                if let Some(&kind) = parent_substs.get(param.index as usize) {\n-                    substs.push(kind);\n-                    params.next();\n-                } else {\n-                    break;\n+        // `Self` is handled first, unless it's been handled in `parent_substs`.\n+        if has_self {\n+            if let Some(&param) = params.peek() {\n+                if param.index == 0 {\n+                    if let GenericParamDefKind::Type { .. } = param.kind {\n+                        substs.push(\n+                            self_ty\n+                                .map(|ty| ty.into())\n+                                .unwrap_or_else(|| ctx.inferred_kind(None, param, true)),\n+                        );\n+                        params.next();\n+                    }\n                 }\n             }\n+        }\n \n-            // `Self` is handled first, unless it's been handled in `parent_substs`.\n-            if has_self {\n-                if let Some(&param) = params.peek() {\n-                    if param.index == 0 {\n-                        if let GenericParamDefKind::Type { .. } = param.kind {\n-                            substs.push(\n-                                self_ty\n-                                    .map(|ty| ty.into())\n-                                    .unwrap_or_else(|| ctx.inferred_kind(None, param, true)),\n-                            );\n+        // Check whether this segment takes generic arguments and the user has provided any.\n+        let (generic_args, infer_args) = ctx.args_for_def_id(def_id);\n+\n+        let args_iter = generic_args.iter().flat_map(|generic_args| generic_args.args.iter());\n+        let mut args = args_iter.clone().peekable();\n+\n+        // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n+        // If we later encounter a lifetime, we know that the arguments were provided in the\n+        // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n+        // inferred, so we can use it for diagnostics later.\n+        let mut force_infer_lt = None;\n+\n+        loop {\n+            // We're going to iterate through the generic arguments that the user\n+            // provided, matching them with the generic parameters we expect.\n+            // Mismatches can occur as a result of elided lifetimes, or for malformed\n+            // input. We try to handle both sensibly.\n+            match (args.peek(), params.peek()) {\n+                (Some(&arg), Some(&param)) => {\n+                    match (arg, &param.kind, arg_count.explicit_late_bound) {\n+                        (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n+                        | (\n+                            GenericArg::Type(_) | GenericArg::Infer(_),\n+                            GenericParamDefKind::Type { .. },\n+                            _,\n+                        )\n+                        | (\n+                            GenericArg::Const(_) | GenericArg::Infer(_),\n+                            GenericParamDefKind::Const { .. },\n+                            _,\n+                        ) => {\n+                            substs.push(ctx.provided_kind(param, arg));\n+                            args.next();\n                             params.next();\n                         }\n-                    }\n-                }\n-            }\n-\n-            // Check whether this segment takes generic arguments and the user has provided any.\n-            let (generic_args, infer_args) = ctx.args_for_def_id(def_id);\n-\n-            let args_iter = generic_args.iter().flat_map(|generic_args| generic_args.args.iter());\n-            let mut args = args_iter.clone().peekable();\n-\n-            // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n-            // If we later encounter a lifetime, we know that the arguments were provided in the\n-            // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n-            // inferred, so we can use it for diagnostics later.\n-            let mut force_infer_lt = None;\n-\n-            loop {\n-                // We're going to iterate through the generic arguments that the user\n-                // provided, matching them with the generic parameters we expect.\n-                // Mismatches can occur as a result of elided lifetimes, or for malformed\n-                // input. We try to handle both sensibly.\n-                match (args.peek(), params.peek()) {\n-                    (Some(&arg), Some(&param)) => {\n-                        match (arg, &param.kind, arg_count.explicit_late_bound) {\n-                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n-                            | (\n-                                GenericArg::Type(_) | GenericArg::Infer(_),\n-                                GenericParamDefKind::Type { .. },\n-                                _,\n-                            )\n-                            | (\n-                                GenericArg::Const(_) | GenericArg::Infer(_),\n-                                GenericParamDefKind::Const { .. },\n-                                _,\n-                            ) => {\n-                                substs.push(ctx.provided_kind(param, arg));\n-                                args.next();\n-                                params.next();\n-                            }\n-                            (\n-                                GenericArg::Infer(_) | GenericArg::Type(_) | GenericArg::Const(_),\n-                                GenericParamDefKind::Lifetime,\n-                                _,\n-                            ) => {\n-                                // We expected a lifetime argument, but got a type or const\n-                                // argument. That means we're inferring the lifetimes.\n-                                substs.push(ctx.inferred_kind(None, param, infer_args));\n-                                force_infer_lt = Some((arg, param));\n-                                params.next();\n-                            }\n-                            (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n-                                // We've come across a lifetime when we expected something else in\n-                                // the presence of explicit late bounds. This is most likely\n-                                // due to the presence of the explicit bound so we're just going to\n-                                // ignore it.\n-                                args.next();\n-                            }\n-                            (_, _, _) => {\n-                                // We expected one kind of parameter, but the user provided\n-                                // another. This is an error. However, if we already know that\n-                                // the arguments don't match up with the parameters, we won't issue\n-                                // an additional error, as the user already knows what's wrong.\n-                                if arg_count.correct.is_ok() {\n-                                    // We're going to iterate over the parameters to sort them out, and\n-                                    // show that order to the user as a possible order for the parameters\n-                                    let mut param_types_present = defs\n-                                        .params\n-                                        .iter()\n-                                        .map(|param| (param.kind.to_ord(), param.clone()))\n-                                        .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n-                                    param_types_present.sort_by_key(|(ord, _)| *ord);\n-                                    let (mut param_types_present, ordered_params): (\n-                                        Vec<ParamKindOrd>,\n-                                        Vec<GenericParamDef>,\n-                                    ) = param_types_present.into_iter().unzip();\n-                                    param_types_present.dedup();\n-\n-                                    Self::generic_arg_mismatch_err(\n-                                        tcx,\n-                                        arg,\n-                                        param,\n-                                        !args_iter.clone().is_sorted_by_key(|arg| arg.to_ord()),\n-                                        Some(&format!(\n-                                            \"reorder the arguments: {}: `<{}>`\",\n-                                            param_types_present\n-                                                .into_iter()\n-                                                .map(|ord| format!(\"{}s\", ord))\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", then \"),\n-                                            ordered_params\n-                                                .into_iter()\n-                                                .filter_map(|param| {\n-                                                    if param.name == kw::SelfUpper {\n-                                                        None\n-                                                    } else {\n-                                                        Some(param.name.to_string())\n-                                                    }\n-                                                })\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", \")\n-                                        )),\n-                                    );\n-                                }\n-\n-                                // We've reported the error, but we want to make sure that this\n-                                // problem doesn't bubble down and create additional, irrelevant\n-                                // errors. In this case, we're simply going to ignore the argument\n-                                // and any following arguments. The rest of the parameters will be\n-                                // inferred.\n-                                while args.next().is_some() {}\n-                            }\n+                        (\n+                            GenericArg::Infer(_) | GenericArg::Type(_) | GenericArg::Const(_),\n+                            GenericParamDefKind::Lifetime,\n+                            _,\n+                        ) => {\n+                            // We expected a lifetime argument, but got a type or const\n+                            // argument. That means we're inferring the lifetimes.\n+                            substs.push(ctx.inferred_kind(None, param, infer_args));\n+                            force_infer_lt = Some((arg, param));\n+                            params.next();\n                         }\n-                    }\n-\n-                    (Some(&arg), None) => {\n-                        // We should never be able to reach this point with well-formed input.\n-                        // There are three situations in which we can encounter this issue.\n-                        //\n-                        //  1.  The number of arguments is incorrect. In this case, an error\n-                        //      will already have been emitted, and we can ignore it.\n-                        //  2.  There are late-bound lifetime parameters present, yet the\n-                        //      lifetime arguments have also been explicitly specified by the\n-                        //      user.\n-                        //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n-                        //      after a type or const). We want to throw an error in this case.\n-\n-                        if arg_count.correct.is_ok()\n-                            && arg_count.explicit_late_bound == ExplicitLateBound::No\n-                        {\n-                            let kind = arg.descr();\n-                            assert_eq!(kind, \"lifetime\");\n-                            let (provided_arg, param) =\n-                                force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n-                            Self::generic_arg_mismatch_err(tcx, provided_arg, param, false, None);\n+                        (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n+                            // We've come across a lifetime when we expected something else in\n+                            // the presence of explicit late bounds. This is most likely\n+                            // due to the presence of the explicit bound so we're just going to\n+                            // ignore it.\n+                            args.next();\n                         }\n+                        (_, _, _) => {\n+                            // We expected one kind of parameter, but the user provided\n+                            // another. This is an error. However, if we already know that\n+                            // the arguments don't match up with the parameters, we won't issue\n+                            // an additional error, as the user already knows what's wrong.\n+                            if arg_count.correct.is_ok() {\n+                                // We're going to iterate over the parameters to sort them out, and\n+                                // show that order to the user as a possible order for the parameters\n+                                let mut param_types_present = defs\n+                                    .params\n+                                    .iter()\n+                                    .map(|param| (param.kind.to_ord(), param.clone()))\n+                                    .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n+                                param_types_present.sort_by_key(|(ord, _)| *ord);\n+                                let (mut param_types_present, ordered_params): (\n+                                    Vec<ParamKindOrd>,\n+                                    Vec<GenericParamDef>,\n+                                ) = param_types_present.into_iter().unzip();\n+                                param_types_present.dedup();\n+\n+                                generic_arg_mismatch_err(\n+                                    tcx,\n+                                    arg,\n+                                    param,\n+                                    !args_iter.clone().is_sorted_by_key(|arg| arg.to_ord()),\n+                                    Some(&format!(\n+                                        \"reorder the arguments: {}: `<{}>`\",\n+                                        param_types_present\n+                                            .into_iter()\n+                                            .map(|ord| format!(\"{}s\", ord))\n+                                            .collect::<Vec<String>>()\n+                                            .join(\", then \"),\n+                                        ordered_params\n+                                            .into_iter()\n+                                            .filter_map(|param| {\n+                                                if param.name == kw::SelfUpper {\n+                                                    None\n+                                                } else {\n+                                                    Some(param.name.to_string())\n+                                                }\n+                                            })\n+                                            .collect::<Vec<String>>()\n+                                            .join(\", \")\n+                                    )),\n+                                );\n+                            }\n \n-                        break;\n+                            // We've reported the error, but we want to make sure that this\n+                            // problem doesn't bubble down and create additional, irrelevant\n+                            // errors. In this case, we're simply going to ignore the argument\n+                            // and any following arguments. The rest of the parameters will be\n+                            // inferred.\n+                            while args.next().is_some() {}\n+                        }\n                     }\n+                }\n \n-                    (None, Some(&param)) => {\n-                        // If there are fewer arguments than parameters, it means\n-                        // we're inferring the remaining arguments.\n-                        substs.push(ctx.inferred_kind(Some(&substs), param, infer_args));\n-                        params.next();\n+                (Some(&arg), None) => {\n+                    // We should never be able to reach this point with well-formed input.\n+                    // There are three situations in which we can encounter this issue.\n+                    //\n+                    //  1.  The number of arguments is incorrect. In this case, an error\n+                    //      will already have been emitted, and we can ignore it.\n+                    //  2.  There are late-bound lifetime parameters present, yet the\n+                    //      lifetime arguments have also been explicitly specified by the\n+                    //      user.\n+                    //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n+                    //      after a type or const). We want to throw an error in this case.\n+\n+                    if arg_count.correct.is_ok()\n+                        && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                    {\n+                        let kind = arg.descr();\n+                        assert_eq!(kind, \"lifetime\");\n+                        let (provided_arg, param) =\n+                            force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n+                        generic_arg_mismatch_err(tcx, provided_arg, param, false, None);\n                     }\n \n-                    (None, None) => break,\n+                    break;\n+                }\n+\n+                (None, Some(&param)) => {\n+                    // If there are fewer arguments than parameters, it means\n+                    // we're inferring the remaining arguments.\n+                    substs.push(ctx.inferred_kind(Some(&substs), param, infer_args));\n+                    params.next();\n                 }\n+\n+                (None, None) => break,\n             }\n         }\n-\n-        tcx.intern_substs(&substs)\n     }\n \n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// Used specifically for function calls.\n-    pub fn check_generic_arg_count_for_call(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def_id: DefId,\n-        generics: &ty::Generics,\n-        seg: &hir::PathSegment<'_>,\n-        is_method_call: IsMethodCall,\n-    ) -> GenericArgCountResult {\n-        let empty_args = hir::GenericArgs::none();\n-        let gen_args = seg.args.unwrap_or(&empty_args);\n-        let gen_pos = if is_method_call == IsMethodCall::Yes {\n-            GenericArgPosition::MethodCall\n+    tcx.intern_substs(&substs)\n+}\n+\n+/// Checks that the correct number of generic arguments have been provided.\n+/// Used specifically for function calls.\n+pub fn check_generic_arg_count_for_call(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    def_id: DefId,\n+    generics: &ty::Generics,\n+    seg: &hir::PathSegment<'_>,\n+    is_method_call: IsMethodCall,\n+) -> GenericArgCountResult {\n+    let empty_args = hir::GenericArgs::none();\n+    let gen_args = seg.args.unwrap_or(&empty_args);\n+    let gen_pos = if is_method_call == IsMethodCall::Yes {\n+        GenericArgPosition::MethodCall\n+    } else {\n+        GenericArgPosition::Value\n+    };\n+    let has_self = generics.parent.is_none() && generics.has_self;\n+\n+    check_generic_arg_count(\n+        tcx,\n+        span,\n+        def_id,\n+        seg,\n+        generics,\n+        gen_args,\n+        gen_pos,\n+        has_self,\n+        seg.infer_args,\n+    )\n+}\n+\n+/// Checks that the correct number of generic arguments have been provided.\n+/// This is used both for datatypes and function calls.\n+#[instrument(skip(tcx, gen_pos), level = \"debug\")]\n+pub(crate) fn check_generic_arg_count(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    def_id: DefId,\n+    seg: &hir::PathSegment<'_>,\n+    gen_params: &ty::Generics,\n+    gen_args: &hir::GenericArgs<'_>,\n+    gen_pos: GenericArgPosition,\n+    has_self: bool,\n+    infer_args: bool,\n+) -> GenericArgCountResult {\n+    let default_counts = gen_params.own_defaults();\n+    let param_counts = gen_params.own_counts();\n+\n+    // Subtracting from param count to ensure type params synthesized from `impl Trait`\n+    // cannot be explicitly specified.\n+    let synth_type_param_count = gen_params\n+        .params\n+        .iter()\n+        .filter(|param| matches!(param.kind, ty::GenericParamDefKind::Type { synthetic: true, .. }))\n+        .count();\n+    let named_type_param_count = param_counts.types - has_self as usize - synth_type_param_count;\n+    let infer_lifetimes =\n+        (gen_pos != GenericArgPosition::Type || infer_args) && !gen_args.has_lifetime_params();\n+\n+    if gen_pos != GenericArgPosition::Type && let Some(b) = gen_args.bindings.first() {\n+            prohibit_assoc_ty_binding(tcx, b.span);\n+        }\n+\n+    let explicit_late_bound =\n+        prohibit_explicit_late_bound_lifetimes(tcx, gen_params, gen_args, gen_pos);\n+\n+    let mut invalid_args = vec![];\n+\n+    let mut check_lifetime_args = |min_expected_args: usize,\n+                                   max_expected_args: usize,\n+                                   provided_args: usize,\n+                                   late_bounds_ignore: bool| {\n+        if (min_expected_args..=max_expected_args).contains(&provided_args) {\n+            return Ok(());\n+        }\n+\n+        if late_bounds_ignore {\n+            return Ok(());\n+        }\n+\n+        if provided_args > max_expected_args {\n+            invalid_args.extend(\n+                gen_args.args[max_expected_args..provided_args].iter().map(|arg| arg.span()),\n+            );\n+        };\n+\n+        let gen_args_info = if provided_args > min_expected_args {\n+            invalid_args.extend(\n+                gen_args.args[min_expected_args..provided_args].iter().map(|arg| arg.span()),\n+            );\n+            let num_redundant_args = provided_args - min_expected_args;\n+            GenericArgsInfo::ExcessLifetimes { num_redundant_args }\n         } else {\n-            GenericArgPosition::Value\n+            let num_missing_args = min_expected_args - provided_args;\n+            GenericArgsInfo::MissingLifetimes { num_missing_args }\n         };\n-        let has_self = generics.parent.is_none() && generics.has_self;\n \n-        Self::check_generic_arg_count(\n+        let reported = WrongNumberOfGenericArgs::new(\n             tcx,\n-            span,\n-            def_id,\n+            gen_args_info,\n             seg,\n-            generics,\n+            gen_params,\n+            has_self as usize,\n             gen_args,\n-            gen_pos,\n-            has_self,\n-            seg.infer_args,\n+            def_id,\n         )\n-    }\n-\n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// This is used both for datatypes and function calls.\n-    #[instrument(skip(tcx, gen_pos), level = \"debug\")]\n-    pub(crate) fn check_generic_arg_count(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def_id: DefId,\n-        seg: &hir::PathSegment<'_>,\n-        gen_params: &ty::Generics,\n-        gen_args: &hir::GenericArgs<'_>,\n-        gen_pos: GenericArgPosition,\n-        has_self: bool,\n-        infer_args: bool,\n-    ) -> GenericArgCountResult {\n-        let default_counts = gen_params.own_defaults();\n-        let param_counts = gen_params.own_counts();\n-\n-        // Subtracting from param count to ensure type params synthesized from `impl Trait`\n-        // cannot be explicitly specified.\n-        let synth_type_param_count = gen_params\n-            .params\n-            .iter()\n-            .filter(|param| {\n-                matches!(param.kind, ty::GenericParamDefKind::Type { synthetic: true, .. })\n-            })\n-            .count();\n-        let named_type_param_count =\n-            param_counts.types - has_self as usize - synth_type_param_count;\n-        let infer_lifetimes =\n-            (gen_pos != GenericArgPosition::Type || infer_args) && !gen_args.has_lifetime_params();\n-\n-        if gen_pos != GenericArgPosition::Type && let Some(b) = gen_args.bindings.first() {\n-            Self::prohibit_assoc_ty_binding(tcx, b.span);\n+        .diagnostic()\n+        .emit();\n+\n+        Err(reported)\n+    };\n+\n+    let min_expected_lifetime_args = if infer_lifetimes { 0 } else { param_counts.lifetimes };\n+    let max_expected_lifetime_args = param_counts.lifetimes;\n+    let num_provided_lifetime_args = gen_args.num_lifetime_params();\n+\n+    let lifetimes_correct = check_lifetime_args(\n+        min_expected_lifetime_args,\n+        max_expected_lifetime_args,\n+        num_provided_lifetime_args,\n+        explicit_late_bound == ExplicitLateBound::Yes,\n+    );\n+\n+    let mut check_types_and_consts = |expected_min,\n+                                      expected_max,\n+                                      expected_max_with_synth,\n+                                      provided,\n+                                      params_offset,\n+                                      args_offset| {\n+        debug!(\n+            ?expected_min,\n+            ?expected_max,\n+            ?provided,\n+            ?params_offset,\n+            ?args_offset,\n+            \"check_types_and_consts\"\n+        );\n+        if (expected_min..=expected_max).contains(&provided) {\n+            return Ok(());\n         }\n \n-        let explicit_late_bound =\n-            Self::prohibit_explicit_late_bound_lifetimes(tcx, gen_params, gen_args, gen_pos);\n-\n-        let mut invalid_args = vec![];\n+        let num_default_params = expected_max - expected_min;\n \n-        let mut check_lifetime_args =\n-            |min_expected_args: usize,\n-             max_expected_args: usize,\n-             provided_args: usize,\n-             late_bounds_ignore: bool| {\n-                if (min_expected_args..=max_expected_args).contains(&provided_args) {\n-                    return Ok(());\n-                }\n-\n-                if late_bounds_ignore {\n-                    return Ok(());\n-                }\n+        let gen_args_info = if provided > expected_max {\n+            invalid_args.extend(\n+                gen_args.args[args_offset + expected_max..args_offset + provided]\n+                    .iter()\n+                    .map(|arg| arg.span()),\n+            );\n+            let num_redundant_args = provided - expected_max;\n \n-                if provided_args > max_expected_args {\n-                    invalid_args.extend(\n-                        gen_args.args[max_expected_args..provided_args]\n-                            .iter()\n-                            .map(|arg| arg.span()),\n-                    );\n-                };\n-\n-                let gen_args_info = if provided_args > min_expected_args {\n-                    invalid_args.extend(\n-                        gen_args.args[min_expected_args..provided_args]\n-                            .iter()\n-                            .map(|arg| arg.span()),\n-                    );\n-                    let num_redundant_args = provided_args - min_expected_args;\n-                    GenericArgsInfo::ExcessLifetimes { num_redundant_args }\n-                } else {\n-                    let num_missing_args = min_expected_args - provided_args;\n-                    GenericArgsInfo::MissingLifetimes { num_missing_args }\n-                };\n-\n-                let reported = WrongNumberOfGenericArgs::new(\n-                    tcx,\n-                    gen_args_info,\n-                    seg,\n-                    gen_params,\n-                    has_self as usize,\n-                    gen_args,\n-                    def_id,\n-                )\n-                .diagnostic()\n-                .emit();\n-\n-                Err(reported)\n-            };\n-\n-        let min_expected_lifetime_args = if infer_lifetimes { 0 } else { param_counts.lifetimes };\n-        let max_expected_lifetime_args = param_counts.lifetimes;\n-        let num_provided_lifetime_args = gen_args.num_lifetime_params();\n-\n-        let lifetimes_correct = check_lifetime_args(\n-            min_expected_lifetime_args,\n-            max_expected_lifetime_args,\n-            num_provided_lifetime_args,\n-            explicit_late_bound == ExplicitLateBound::Yes,\n-        );\n+            // Provide extra note if synthetic arguments like `impl Trait` are specified.\n+            let synth_provided = provided <= expected_max_with_synth;\n \n-        let mut check_types_and_consts = |expected_min,\n-                                          expected_max,\n-                                          expected_max_with_synth,\n-                                          provided,\n-                                          params_offset,\n-                                          args_offset| {\n-            debug!(\n-                ?expected_min,\n-                ?expected_max,\n-                ?provided,\n-                ?params_offset,\n-                ?args_offset,\n-                \"check_types_and_consts\"\n-            );\n-            if (expected_min..=expected_max).contains(&provided) {\n-                return Ok(());\n+            GenericArgsInfo::ExcessTypesOrConsts {\n+                num_redundant_args,\n+                num_default_params,\n+                args_offset,\n+                synth_provided,\n             }\n+        } else {\n+            let num_missing_args = expected_max - provided;\n \n-            let num_default_params = expected_max - expected_min;\n-\n-            let gen_args_info = if provided > expected_max {\n-                invalid_args.extend(\n-                    gen_args.args[args_offset + expected_max..args_offset + provided]\n-                        .iter()\n-                        .map(|arg| arg.span()),\n-                );\n-                let num_redundant_args = provided - expected_max;\n+            GenericArgsInfo::MissingTypesOrConsts {\n+                num_missing_args,\n+                num_default_params,\n+                args_offset,\n+            }\n+        };\n \n-                // Provide extra note if synthetic arguments like `impl Trait` are specified.\n-                let synth_provided = provided <= expected_max_with_synth;\n+        debug!(?gen_args_info);\n \n-                GenericArgsInfo::ExcessTypesOrConsts {\n-                    num_redundant_args,\n-                    num_default_params,\n-                    args_offset,\n-                    synth_provided,\n-                }\n-            } else {\n-                let num_missing_args = expected_max - provided;\n+        let reported = WrongNumberOfGenericArgs::new(\n+            tcx,\n+            gen_args_info,\n+            seg,\n+            gen_params,\n+            params_offset,\n+            gen_args,\n+            def_id,\n+        )\n+        .diagnostic()\n+        .emit_unless(gen_args.has_err());\n \n-                GenericArgsInfo::MissingTypesOrConsts {\n-                    num_missing_args,\n-                    num_default_params,\n-                    args_offset,\n-                }\n-            };\n-\n-            debug!(?gen_args_info);\n-\n-            let reported = WrongNumberOfGenericArgs::new(\n-                tcx,\n-                gen_args_info,\n-                seg,\n-                gen_params,\n-                params_offset,\n-                gen_args,\n-                def_id,\n-            )\n-            .diagnostic()\n-            .emit_unless(gen_args.has_err());\n-\n-            Err(reported)\n-        };\n+        Err(reported)\n+    };\n \n-        let args_correct = {\n-            let expected_min = if infer_args {\n-                0\n-            } else {\n-                param_counts.consts + named_type_param_count\n-                    - default_counts.types\n-                    - default_counts.consts\n-            };\n-            debug!(?expected_min);\n-            debug!(arg_counts.lifetimes=?gen_args.num_lifetime_params());\n-\n-            check_types_and_consts(\n-                expected_min,\n-                param_counts.consts + named_type_param_count,\n-                param_counts.consts + named_type_param_count + synth_type_param_count,\n-                gen_args.num_generic_params(),\n-                param_counts.lifetimes + has_self as usize,\n-                gen_args.num_lifetime_params(),\n-            )\n+    let args_correct = {\n+        let expected_min = if infer_args {\n+            0\n+        } else {\n+            param_counts.consts + named_type_param_count\n+                - default_counts.types\n+                - default_counts.consts\n         };\n+        debug!(?expected_min);\n+        debug!(arg_counts.lifetimes=?gen_args.num_lifetime_params());\n+\n+        check_types_and_consts(\n+            expected_min,\n+            param_counts.consts + named_type_param_count,\n+            param_counts.consts + named_type_param_count + synth_type_param_count,\n+            gen_args.num_generic_params(),\n+            param_counts.lifetimes + has_self as usize,\n+            gen_args.num_lifetime_params(),\n+        )\n+    };\n \n-        GenericArgCountResult {\n-            explicit_late_bound,\n-            correct: lifetimes_correct.and(args_correct).map_err(|reported| {\n-                GenericArgCountMismatch { reported: Some(reported), invalid_args }\n-            }),\n-        }\n+    GenericArgCountResult {\n+        explicit_late_bound,\n+        correct: lifetimes_correct\n+            .and(args_correct)\n+            .map_err(|reported| GenericArgCountMismatch { reported: Some(reported), invalid_args }),\n     }\n+}\n \n-    /// Emits an error regarding forbidden type binding associations\n-    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n-        tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n-    }\n+/// Emits an error regarding forbidden type binding associations\n+pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n+    tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n+}\n \n-    /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n-    /// are present. This is used both for datatypes and function calls.\n-    pub(crate) fn prohibit_explicit_late_bound_lifetimes(\n-        tcx: TyCtxt<'_>,\n-        def: &ty::Generics,\n-        args: &hir::GenericArgs<'_>,\n-        position: GenericArgPosition,\n-    ) -> ExplicitLateBound {\n-        let param_counts = def.own_counts();\n-        let infer_lifetimes = position != GenericArgPosition::Type && !args.has_lifetime_params();\n-\n-        if infer_lifetimes {\n-            return ExplicitLateBound::No;\n-        }\n+/// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n+/// are present. This is used both for datatypes and function calls.\n+pub(crate) fn prohibit_explicit_late_bound_lifetimes(\n+    tcx: TyCtxt<'_>,\n+    def: &ty::Generics,\n+    args: &hir::GenericArgs<'_>,\n+    position: GenericArgPosition,\n+) -> ExplicitLateBound {\n+    let param_counts = def.own_counts();\n+    let infer_lifetimes = position != GenericArgPosition::Type && !args.has_lifetime_params();\n+\n+    if infer_lifetimes {\n+        return ExplicitLateBound::No;\n+    }\n \n-        if let Some(span_late) = def.has_late_bound_regions {\n-            let msg = \"cannot specify lifetime arguments explicitly \\\n+    if let Some(span_late) = def.has_late_bound_regions {\n+        let msg = \"cannot specify lifetime arguments explicitly \\\n                        if late bound lifetime parameters are present\";\n-            let note = \"the late bound lifetime parameter is introduced here\";\n-            let span = args.args[0].span();\n-\n-            if position == GenericArgPosition::Value\n-                && args.num_lifetime_params() != param_counts.lifetimes\n-            {\n-                let mut err = tcx.sess.struct_span_err(span, msg);\n-                err.span_note(span_late, note);\n-                err.emit();\n-            } else {\n-                let mut multispan = MultiSpan::from_span(span);\n-                multispan.push_span_label(span_late, note);\n-                tcx.struct_span_lint_hir(\n-                    LATE_BOUND_LIFETIME_ARGUMENTS,\n-                    args.args[0].hir_id(),\n-                    multispan,\n-                    msg,\n-                    |lint| lint,\n-                );\n-            }\n-\n-            ExplicitLateBound::Yes\n+        let note = \"the late bound lifetime parameter is introduced here\";\n+        let span = args.args[0].span();\n+\n+        if position == GenericArgPosition::Value\n+            && args.num_lifetime_params() != param_counts.lifetimes\n+        {\n+            let mut err = tcx.sess.struct_span_err(span, msg);\n+            err.span_note(span_late, note);\n+            err.emit();\n         } else {\n-            ExplicitLateBound::No\n+            let mut multispan = MultiSpan::from_span(span);\n+            multispan.push_span_label(span_late, note);\n+            tcx.struct_span_lint_hir(\n+                LATE_BOUND_LIFETIME_ARGUMENTS,\n+                args.args[0].hir_id(),\n+                multispan,\n+                msg,\n+                |lint| lint,\n+            );\n         }\n+\n+        ExplicitLateBound::Yes\n+    } else {\n+        ExplicitLateBound::No\n     }\n }"}, {"sha": "9fa0e6e8eaa646d396ca2049b9fc69c59587862e", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -3,8 +3,11 @@\n //! instance of `AstConv`.\n \n mod errors;\n-mod generics;\n+pub mod generics;\n \n+use crate::astconv::generics::{\n+    check_generic_arg_count, create_substs_for_generic_args, prohibit_assoc_ty_binding,\n+};\n use crate::bounds::Bounds;\n use crate::collect::HirPlaceholderCollector;\n use crate::errors::{\n@@ -120,6 +123,13 @@ pub trait AstConv<'tcx> {\n     fn set_tainted_by_errors(&self, e: ErrorGuaranteed);\n \n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span);\n+\n+    fn astconv(&self) -> &dyn AstConv<'tcx>\n+    where\n+        Self: Sized,\n+    {\n+        self\n+    }\n }\n \n #[derive(Debug)]\n@@ -279,7 +289,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty::BoundConstness::NotConst,\n         );\n         if let Some(b) = item_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n \n         substs\n@@ -349,7 +359,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             assert!(self_ty.is_none());\n         }\n \n-        let arg_count = Self::check_generic_arg_count(\n+        let arg_count = check_generic_arg_count(\n             tcx,\n             span,\n             def_id,\n@@ -524,7 +534,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             inferred_params: vec![],\n             infer_args,\n         };\n-        let substs = Self::create_substs_for_generic_args(\n+        let substs = create_substs_for_generic_args(\n             tcx,\n             def_id,\n             parent_substs,\n@@ -610,7 +620,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n \n         if let Some(b) = item_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n \n         args\n@@ -804,7 +814,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             constness,\n         );\n         if let Some(b) = trait_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n         self.tcx().mk_trait_ref(trait_def_id, substs)\n     }\n@@ -2301,7 +2311,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for segment in segments {\n             // Only emit the first error to avoid overloading the user with error messages.\n             if let Some(b) = segment.args().bindings.first() {\n-                Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+                prohibit_assoc_ty_binding(self.tcx(), b.span);\n                 return true;\n             }\n         }"}, {"sha": "730560cc6868627e593dad15649f951df8075093", "filename": "compiler/rustc_hir_analysis/src/autoderef.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -178,6 +178,10 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         self.state.obligations\n     }\n \n+    pub fn current_obligations(&self) -> Vec<traits::PredicateObligation<'tcx>> {\n+        self.state.obligations.clone()\n+    }\n+\n     pub fn steps(&self) -> &[(Ty<'tcx>, AutoderefKind)] {\n         &self.state.steps\n     }", "previous_filename": "compiler/rustc_trait_selection/src/autoderef.rs"}, {"sha": "d1f4dbc8d84549c3f991ff59bf1d4d51c7b125e9", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,6 @@\n+use crate::autoderef::Autoderef;\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n+\n use hir::def::DefKind;\n use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n@@ -22,7 +24,6 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;"}, {"sha": "cd745ee8cab69929e714c78fa546108a30b8ca1e", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -351,7 +351,7 @@ impl<'tcx> ItemCtxt<'tcx> {\n     }\n \n     pub fn to_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n-        <dyn AstConv<'_>>::ast_ty_to_ty(self, ast_ty)\n+        self.astconv().ast_ty_to_ty(ast_ty)\n     }\n \n     pub fn hir_id(&self) -> hir::HirId {\n@@ -413,8 +413,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n         if let Some(trait_ref) = poly_trait_ref.no_bound_vars() {\n-            let item_substs = <dyn AstConv<'tcx>>::create_substs_for_associated_item(\n-                self,\n+            let item_substs = self.astconv().create_substs_for_associated_item(\n                 span,\n                 item_def_id,\n                 item_segment,\n@@ -1112,8 +1111,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                 tcx.hir().get_parent(hir_id)\n                 && i.of_trait.is_some()\n             {\n-                <dyn AstConv<'_>>::ty_of_fn(\n-                    &icx,\n+                icx.astconv().ty_of_fn(\n                     hir_id,\n                     sig.header.unsafety,\n                     sig.header.abi,\n@@ -1130,15 +1128,9 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             kind: TraitItemKind::Fn(FnSig { header, decl, span: _ }, _),\n             generics,\n             ..\n-        }) => <dyn AstConv<'_>>::ty_of_fn(\n-            &icx,\n-            hir_id,\n-            header.unsafety,\n-            header.abi,\n-            decl,\n-            Some(generics),\n-            None,\n-        ),\n+        }) => {\n+            icx.astconv().ty_of_fn(hir_id, header.unsafety, header.abi, decl, Some(generics), None)\n+        }\n \n         ForeignItem(&hir::ForeignItem { kind: ForeignItemKind::Fn(fn_decl, _, _), .. }) => {\n             let abi = tcx.hir().get_foreign_abi(hir_id);\n@@ -1244,8 +1236,7 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n \n             ty::Binder::dummy(fn_sig)\n         }\n-        None => <dyn AstConv<'_>>::ty_of_fn(\n-            icx,\n+        None => icx.astconv().ty_of_fn(\n             hir_id,\n             sig.header.unsafety,\n             sig.header.abi,\n@@ -1354,8 +1345,7 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     match item.kind {\n         hir::ItemKind::Impl(ref impl_) => impl_.of_trait.as_ref().map(|ast_trait_ref| {\n             let selfty = tcx.type_of(def_id);\n-            <dyn AstConv<'_>>::instantiate_mono_trait_ref(\n-                &icx,\n+            icx.astconv().instantiate_mono_trait_ref(\n                 ast_trait_ref,\n                 selfty,\n                 check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n@@ -1485,15 +1475,8 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         hir::Unsafety::Unsafe\n     };\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let fty = <dyn AstConv<'_>>::ty_of_fn(\n-        &ItemCtxt::new(tcx, def_id),\n-        hir_id,\n-        unsafety,\n-        abi,\n-        decl,\n-        None,\n-        None,\n-    );\n+    let fty =\n+        ItemCtxt::new(tcx, def_id).astconv().ty_of_fn(hir_id, unsafety, abi, decl, None, None);\n \n     // Feature gate SIMD types in FFI, since I am not sure that the\n     // ABIs are handled at all correctly. -huonw"}, {"sha": "62eef710ba48f0542079996933b500f5b5643304", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -26,9 +26,9 @@ fn associated_type_bounds<'tcx>(\n     );\n \n     let icx = ItemCtxt::new(tcx, assoc_item_def_id);\n-    let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n+    let mut bounds = icx.astconv().compute_bounds(item_ty, ast_bounds);\n     // Associated types are implicitly sized unless a `?Sized` bound is found\n-    <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, item_ty, ast_bounds, None, span);\n+    icx.astconv().add_implicitly_sized(&mut bounds, item_ty, ast_bounds, None, span);\n \n     let trait_def_id = tcx.parent(assoc_item_def_id);\n     let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id.expect_local());\n@@ -70,9 +70,9 @@ fn opaque_type_bounds<'tcx>(\n         };\n \n         let icx = ItemCtxt::new(tcx, opaque_def_id);\n-        let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n+        let mut bounds = icx.astconv().compute_bounds(item_ty, ast_bounds);\n         // Opaque types are implicitly sized unless a `?Sized` bound is found\n-        <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, item_ty, ast_bounds, None, span);\n+        icx.astconv().add_implicitly_sized(&mut bounds, item_ty, ast_bounds, None, span);\n         debug!(?bounds);\n \n         tcx.arena.alloc_from_iter(bounds.predicates())"}, {"sha": "234253556845bf264283ec24fedcfbd8c7549a86", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -162,8 +162,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n                 let mut bounds = Bounds::default();\n                 // Params are implicitly sized unless a `?Sized` bound is found\n-                <dyn AstConv<'_>>::add_implicitly_sized(\n-                    &icx,\n+                icx.astconv().add_implicitly_sized(\n                     &mut bounds,\n                     param_ty,\n                     &[],\n@@ -211,22 +210,16 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 }\n \n                 let mut bounds = Bounds::default();\n-                <dyn AstConv<'_>>::add_bounds(\n-                    &icx,\n-                    ty,\n-                    bound_pred.bounds.iter(),\n-                    &mut bounds,\n-                    bound_vars,\n-                );\n+                icx.astconv().add_bounds(ty, bound_pred.bounds.iter(), &mut bounds, bound_vars);\n                 predicates.extend(bounds.predicates());\n             }\n \n             hir::WherePredicate::RegionPredicate(region_pred) => {\n-                let r1 = <dyn AstConv<'_>>::ast_region_to_region(&icx, &region_pred.lifetime, None);\n+                let r1 = icx.astconv().ast_region_to_region(&region_pred.lifetime, None);\n                 predicates.extend(region_pred.bounds.iter().map(|bound| {\n                     let (r2, span) = match bound {\n                         hir::GenericBound::Outlives(lt) => {\n-                            (<dyn AstConv<'_>>::ast_region_to_region(&icx, lt, None), lt.ident.span)\n+                            (icx.astconv().ast_region_to_region(lt, None), lt.ident.span)\n                         }\n                         _ => bug!(),\n                     };\n@@ -279,7 +272,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         debug!(?lifetimes);\n         for (arg, duplicate) in std::iter::zip(lifetimes, ast_generics.params) {\n             let hir::GenericArg::Lifetime(arg) = arg else { bug!() };\n-            let orig_region = <dyn AstConv<'_>>::ast_region_to_region(&icx, &arg, None);\n+            let orig_region = icx.astconv().ast_region_to_region(&arg, None);\n             if !matches!(orig_region.kind(), ty::ReEarlyBound(..)) {\n                 // Only early-bound regions can point to the original generic parameter.\n                 continue;\n@@ -527,14 +520,9 @@ pub(super) fn super_predicates_that_define_assoc_type(\n         // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n         let self_param_ty = tcx.types.self_param;\n         let superbounds1 = if let Some(assoc_name) = assoc_name {\n-            <dyn AstConv<'_>>::compute_bounds_that_match_assoc_type(\n-                &icx,\n-                self_param_ty,\n-                bounds,\n-                assoc_name,\n-            )\n+            icx.astconv().compute_bounds_that_match_assoc_type(self_param_ty, bounds, assoc_name)\n         } else {\n-            <dyn AstConv<'_>>::compute_bounds(&icx, self_param_ty, bounds)\n+            icx.astconv().compute_bounds(self_param_ty, bounds)\n         };\n \n         let superbounds1 = superbounds1.predicates();"}, {"sha": "04f5f3f62765a7f5eea5c46ab69bb6bdeb514d41", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -300,3 +300,15 @@ pub(crate) struct LinkageType {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[help]\n+#[diag(hir_analysis_auto_deref_reached_recursion_limit, code = \"E0055\")]\n+pub struct AutoDerefReachedRecursionLimit<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+    pub suggested_limit: rustc_session::Limit,\n+    pub crate_name: Symbol,\n+}"}, {"sha": "ddc5b7668812668e9e6f923956ba85bd0a2cb484", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -84,6 +84,7 @@ extern crate rustc_middle;\n pub mod check;\n \n pub mod astconv;\n+pub mod autoderef;\n mod bounds;\n mod check_unused;\n mod coherence;\n@@ -544,7 +545,7 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_def_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n-    <dyn AstConv<'_>>::ast_ty_to_ty(&item_cx, hir_ty)\n+    item_cx.astconv().ast_ty_to_ty(hir_ty)\n }\n \n pub fn hir_trait_to_predicates<'tcx>(\n@@ -558,8 +559,7 @@ pub fn hir_trait_to_predicates<'tcx>(\n     let env_def_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n     let mut bounds = Bounds::default();\n-    let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref(\n-        &item_cx,\n+    let _ = &item_cx.astconv().instantiate_poly_trait_ref(\n         hir_trait,\n         DUMMY_SP,\n         ty::BoundConstness::NotConst,"}, {"sha": "7873257c4e3d1c46343920842db11bcd62c01314", "filename": "compiler/rustc_hir_typeck/src/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,11 +2,11 @@\n use super::method::MethodCallee;\n use super::{FnCtxt, PlaceOp};\n \n+use rustc_hir_analysis::autoderef::{Autoderef, AutoderefKind};\n use rustc_infer::infer::InferOk;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n-use rustc_trait_selection::autoderef::{Autoderef, AutoderefKind};\n \n use std::iter;\n "}, {"sha": "8d417290407ed033049bbe2d48afb48b99d94c2a", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -8,6 +8,7 @@ use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed,\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_hir_analysis::autoderef::Autoderef;\n use rustc_infer::{\n     infer,\n     traits::{self, Obligation},\n@@ -25,7 +26,6 @@ use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n-use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;"}, {"sha": "7e1c0faa453a26f08b87472f77d09cc51b237a2e", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1807,7 +1807,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             // Get the return type.\n             && let hir::TyKind::OpaqueDef(..) = ty.kind\n         {\n-            let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n+            let ty = fcx.astconv().ast_ty_to_ty( ty);\n             // Get the `impl Trait`'s `DefId`.\n             if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = ty.kind()\n                 // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n@@ -1866,7 +1866,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     fn is_return_ty_unsized<'a>(&self, fcx: &FnCtxt<'a, 'tcx>, blk_id: hir::HirId) -> bool {\n         if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id)\n             && let hir::FnRetTy::Return(ty) = fn_decl.output\n-            && let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty)\n+            && let ty = fcx.astconv().ast_ty_to_ty( ty)\n             && let ty::Dynamic(..) = ty.kind()\n         {\n             return true;"}, {"sha": "8570715b41e59060d6ad2cbbb6e6aec20162c267", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -10,6 +10,9 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, GenericArg, Node, QPath};\n+use rustc_hir_analysis::astconv::generics::{\n+    check_generic_arg_count_for_call, create_substs_for_generic_args,\n+};\n use rustc_hir_analysis::astconv::{\n     AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n     GenericArgCountResult, IsMethodCall, PathSeg,\n@@ -374,7 +377,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> RawTy<'tcx> {\n-        let t = <dyn AstConv<'_>>::ast_ty_to_ty(self, ast_t);\n+        let t = self.astconv().ast_ty_to_ty(ast_t);\n         self.register_wf_obligation(t.into(), ast_t.span, traits::WellFormed(None));\n         self.handle_raw_ty(ast_t.span, t)\n     }\n@@ -777,7 +780,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // to be object-safe.\n                 // We manually call `register_wf_obligation` in the success path\n                 // below.\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty_in_path(self, qself);\n+                let ty = self.astconv().ast_ty_to_ty_in_path(qself);\n                 (self.handle_raw_ty(span, ty), qself, segment)\n             }\n             QPath::LangItem(..) => {\n@@ -975,8 +978,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let path_segs = match res {\n             Res::Local(_) | Res::SelfCtor(_) => vec![],\n-            Res::Def(kind, def_id) => <dyn AstConv<'_>>::def_ids_for_value_path_segments(\n-                self,\n+            Res::Def(kind, def_id) => self.astconv().def_ids_for_value_path_segments(\n                 segments,\n                 self_ty.map(|ty| ty.raw),\n                 kind,\n@@ -1027,8 +1029,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // errors if type parameters are provided in an inappropriate place.\n \n         let generic_segs: FxHashSet<_> = path_segs.iter().map(|PathSeg(_, index)| index).collect();\n-        let generics_has_err = <dyn AstConv<'_>>::prohibit_generics(\n-            self,\n+        let generics_has_err = self.astconv().prohibit_generics(\n             segments.iter().enumerate().filter_map(|(index, seg)| {\n                 if !generic_segs.contains(&index) || is_alias_variant_ctor {\n                     Some(seg)\n@@ -1069,7 +1070,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // parameter internally, but we don't allow users to specify the\n             // parameter's value explicitly, so we have to do some error-\n             // checking here.\n-            let arg_count = <dyn AstConv<'_>>::check_generic_arg_count_for_call(\n+            let arg_count = check_generic_arg_count_for_call(\n                 tcx,\n                 span,\n                 def_id,\n@@ -1177,7 +1178,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ) -> ty::GenericArg<'tcx> {\n                 match (&param.kind, arg) {\n                     (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                        <dyn AstConv<'_>>::ast_region_to_region(self.fcx, lt, Some(param)).into()\n+                        self.fcx.astconv().ast_region_to_region(lt, Some(param)).into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n                         self.fcx.to_ty(ty).raw.into()\n@@ -1235,7 +1236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let substs_raw = self_ctor_substs.unwrap_or_else(|| {\n-            <dyn AstConv<'_>>::create_substs_for_generic_args(\n+            create_substs_for_generic_args(\n                 tcx,\n                 def_id,\n                 &[],"}, {"sha": "b9e13fd20092421554e9d9d3ce9899334f100d74", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1664,15 +1664,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match *qpath {\n             QPath::Resolved(ref maybe_qself, ref path) => {\n                 let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself).raw);\n-                let ty = <dyn AstConv<'_>>::res_to_ty(self, self_ty, path, true);\n+                let ty = self.astconv().res_to_ty(self_ty, path, true);\n                 (path.res, self.handle_raw_ty(path_span, ty))\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let result = <dyn AstConv<'_>>::associated_path_to_ty(\n-                    self, hir_id, path_span, ty.raw, qself, segment, true,\n-                );\n+                let result = self\n+                    .astconv()\n+                    .associated_path_to_ty(hir_id, path_span, ty.raw, qself, segment, true);\n                 let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n                 let ty = self.handle_raw_ty(path_span, ty);\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));"}, {"sha": "428fde642bc0901bff4a7fb92c8c6cb6c589c100", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt, TypeVisitable};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n-use rustc_span::{self, Span};\n+use rustc_span::{self, Span, DUMMY_SP};\n use rustc_trait_selection::traits::{ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use std::cell::{Cell, RefCell};\n@@ -175,6 +175,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     fn_sig\n                 })\n             }),\n+            autoderef_steps: Box::new(|ty| {\n+                let mut autoderef = self.autoderef(DUMMY_SP, ty).silence_errors();\n+                let mut steps = vec![];\n+                while let Some((ty, _)) = autoderef.next() {\n+                    steps.push((ty, autoderef.current_obligations()));\n+                }\n+                steps\n+            }),\n         }\n     }\n \n@@ -286,8 +294,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             poly_trait_ref,\n         );\n \n-        let item_substs = <dyn AstConv<'tcx>>::create_substs_for_associated_item(\n-            self,\n+        let item_substs = self.astconv().create_substs_for_associated_item(\n             span,\n             item_def_id,\n             item_segment,"}, {"sha": "005bd164065d80f612a6075c2f886957796a6bef", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -5,7 +5,7 @@ use crate::method::probe::{IsSuggestion, Mode, ProbeScope};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorOf, DefKind};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n     Expr, ExprKind, GenericBound, Node, Path, QPath, Stmt, StmtKind, TyKind, WherePredicate,\n@@ -417,10 +417,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else if self.suggest_else_fn_with_closure(err, expr, found, expected) {\n             return true;\n         } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n-            && let ty::FnDef(def_id, ..) = &found.kind()\n-            && let Some(sp) = self.tcx.hir().span_if_local(*def_id)\n+            && let ty::FnDef(def_id, ..) = *found.kind()\n+            && let Some(sp) = self.tcx.hir().span_if_local(def_id)\n         {\n-            err.span_label(sp, format!(\"{found} defined here\"));\n+            let name = self.tcx.item_name(def_id);\n+            let kind = self.tcx.def_kind(def_id);\n+            if let DefKind::Ctor(of, CtorKind::Fn) = kind {\n+                err.span_label(sp, format!(\"`{name}` defines {} constructor here, which should be called\", match of {\n+                    CtorOf::Struct => \"a struct\",\n+                    CtorOf::Variant => \"an enum variant\",\n+                }));\n+            } else {\n+                let descr = kind.descr(def_id);\n+                err.span_label(sp, format!(\"{descr} `{name}` defined here\"));\n+            }\n             return true;\n         } else if self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             return true;\n@@ -783,7 +793,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // are not, the expectation must have been caused by something else.\n                 debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n                 let span = ty.span;\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+                let ty = self.astconv().ast_ty_to_ty(ty);\n                 debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n                 debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n                 let bound_vars = self.tcx.late_bound_vars(fn_id);\n@@ -854,7 +864,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ..\n                 }) => {\n                     // FIXME: Maybe these calls to `ast_ty_to_ty` can be removed (and the ones below)\n-                    let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, bounded_ty);\n+                    let ty = self.astconv().ast_ty_to_ty(bounded_ty);\n                     Some((ty, bounds))\n                 }\n                 _ => None,\n@@ -892,7 +902,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let all_bounds_str = all_matching_bounds_strs.join(\" + \");\n \n         let ty_param_used_in_fn_params = fn_parameters.iter().any(|param| {\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, param);\n+                let ty = self.astconv().ast_ty_to_ty( param);\n                 matches!(ty.kind(), ty::Param(fn_param_ty_param) if expected_ty_as_param == fn_param_ty_param)\n             });\n \n@@ -946,7 +956,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let hir::FnRetTy::Return(ty) = fn_decl.output {\n-            let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+            let ty = self.astconv().ast_ty_to_ty(ty);\n             let bound_vars = self.tcx.late_bound_vars(fn_id);\n             let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n             let ty = match self.tcx.asyncness(fn_id.owner) {\n@@ -1339,7 +1349,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::Path { segments: [segment], .. },\n             ))\n             | hir::ExprKind::Path(QPath::TypeRelative(ty, segment)) => {\n-                let self_ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+                let self_ty = self.astconv().ast_ty_to_ty(ty);\n                 if let Ok(pick) = self.probe_for_name(\n                     Mode::Path,\n                     Ident::new(capitalized_name, segment.ident.span),"}, {"sha": "7ddf9eaa4d8995463fa730d5ad653c536b174d2b", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -205,7 +205,7 @@ fn typeck_with_fallback<'tcx>(\n \n         if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n             let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n-                <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n+                fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n             } else {\n                 tcx.fn_sig(def_id)\n             };\n@@ -220,7 +220,7 @@ fn typeck_with_fallback<'tcx>(\n         } else {\n             let expected_type = body_ty\n                 .and_then(|ty| match ty.kind {\n-                    hir::TyKind::Infer => Some(<dyn AstConv<'_>>::ast_ty_to_ty(&fcx, ty)),\n+                    hir::TyKind::Infer => Some(fcx.astconv().ast_ty_to_ty(ty)),\n                     _ => None,\n                 })\n                 .unwrap_or_else(|| match tcx.hir().get(id) {"}, {"sha": "4a33a791e1b7f3b12db9c6e54ca541ab93b5c0fa", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -4,6 +4,9 @@ use crate::{callee, FnCtxt};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::GenericArg;\n+use rustc_hir_analysis::astconv::generics::{\n+    check_generic_arg_count_for_call, create_substs_for_generic_args,\n+};\n use rustc_hir_analysis::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n@@ -331,7 +334,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // variables.\n         let generics = self.tcx.generics_of(pick.item.def_id);\n \n-        let arg_count_correct = <dyn AstConv<'_>>::check_generic_arg_count_for_call(\n+        let arg_count_correct = check_generic_arg_count_for_call(\n             self.tcx,\n             self.span,\n             pick.item.def_id,\n@@ -369,8 +372,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             ) -> subst::GenericArg<'tcx> {\n                 match (&param.kind, arg) {\n                     (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                        <dyn AstConv<'_>>::ast_region_to_region(self.cfcx.fcx, lt, Some(param))\n-                            .into()\n+                        self.cfcx.fcx.astconv().ast_region_to_region(lt, Some(param)).into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n                         self.cfcx.to_ty(ty).raw.into()\n@@ -399,7 +401,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             }\n         }\n \n-        let substs = <dyn AstConv<'_>>::create_substs_for_generic_args(\n+        let substs = create_substs_for_generic_args(\n             self.tcx,\n             pick.item.def_id,\n             parent_substs,"}, {"sha": "dd827777df94e68c03c031b98af1594b06e72793", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n+use rustc_hir_analysis::autoderef::{self, Autoderef};\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -29,7 +30,6 @@ use rustc_span::lev_distance::{\n };\n use rustc_span::symbol::sym;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n-use rustc_trait_selection::autoderef::{self, Autoderef};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::query::method_autoderef::MethodAutoderefBadTy;\n use rustc_trait_selection::traits::query::method_autoderef::{"}, {"sha": "ae0df5aa8f1cf0c89b385653455f9734395569cf", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -3,14 +3,14 @@ use crate::{has_expected_num_generic_args, FnCtxt, PlaceOp};\n use rustc_ast as ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir_analysis::autoderef::Autoderef;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferOk;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n-use rustc_trait_selection::autoderef::Autoderef;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {"}, {"sha": "080ae6b94669fdf2af1c76dc6fc1431209ae939e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -55,6 +55,7 @@ use crate::infer::ExpectedFound;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+    PredicateObligation,\n };\n \n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n@@ -91,8 +92,12 @@ pub mod nice_region_error;\n pub struct TypeErrCtxt<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'tcx>,\n     pub typeck_results: Option<std::cell::Ref<'a, ty::TypeckResults<'tcx>>>,\n-    pub normalize_fn_sig: Box<dyn Fn(ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx> + 'a>,\n     pub fallback_has_occurred: bool,\n+\n+    pub normalize_fn_sig: Box<dyn Fn(ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx> + 'a>,\n+\n+    pub autoderef_steps:\n+        Box<dyn Fn(Ty<'tcx>) -> Vec<(Ty<'tcx>, Vec<PredicateObligation<'tcx>>)> + 'a>,\n }\n \n impl TypeErrCtxt<'_, '_> {"}, {"sha": "8825b5e12c3d9d44a74310e3662befdf1d113d4c", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -688,6 +688,10 @@ impl<'tcx> InferCtxt<'tcx> {\n             typeck_results: None,\n             fallback_has_occurred: false,\n             normalize_fn_sig: Box::new(|fn_sig| fn_sig),\n+            autoderef_steps: Box::new(|ty| {\n+                debug_assert!(false, \"shouldn't be using autoderef_steps outside of typeck\");\n+                vec![(ty, vec![])]\n+            }),\n         }\n     }\n "}, {"sha": "5f320708c8416944466a25137159b95386baee11", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -9,6 +9,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/thir.html\n \n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::RangeEnd;\n@@ -575,6 +576,12 @@ impl<'tcx> Pat<'tcx> {\n     }\n }\n \n+impl<'tcx> IntoDiagnosticArg for Pat<'tcx> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        format!(\"{}\", self).into_diagnostic_arg()\n+    }\n+}\n+\n #[derive(Clone, Debug, HashStable)]\n pub struct Ascription<'tcx> {\n     pub annotation: CanonicalUserTypeAnnotation<'tcx>,"}, {"sha": "5d394f71f0d764024b33c0f2e4f047a61a8743e9", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,10 +2,10 @@ use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::diagnostics::suggest_constraining_type_param;\n use crate::ty::print::{with_forced_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n-use hir::def::DefKind;\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n use rustc_errors::{pluralize, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n+use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n@@ -319,7 +319,11 @@ impl<'tcx> Ty<'tcx> {\n                     .into()\n                 }\n             }\n-            ty::FnDef(..) => \"fn item\".into(),\n+            ty::FnDef(def_id, ..) => match tcx.def_kind(def_id) {\n+                DefKind::Ctor(CtorOf::Struct, _) => \"struct constructor\".into(),\n+                DefKind::Ctor(CtorOf::Variant, _) => \"enum constructor\".into(),\n+                _ => \"fn item\".into(),\n+            },\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) if let Some(principal) = inner.principal() => {\n                 format!(\"trait object `dyn {}`\", tcx.def_path_str(principal.def_id())).into()\n@@ -366,7 +370,11 @@ impl<'tcx> Ty<'tcx> {\n                 _ => \"reference\",\n             }\n             .into(),\n-            ty::FnDef(..) => \"fn item\".into(),\n+            ty::FnDef(def_id, ..) => match tcx.def_kind(def_id) {\n+                DefKind::Ctor(CtorOf::Struct, _) => \"struct constructor\".into(),\n+                DefKind::Ctor(CtorOf::Variant, _) => \"enum constructor\".into(),\n+                _ => \"fn item\".into(),\n+            },\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(..) => \"trait object\".into(),\n             ty::Closure(..) => \"closure\".into(),"}, {"sha": "06523b0a1de84cb658fc3e410bb4d61837eeeec9", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 225, "deletions": 1, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,9 +1,13 @@\n+use crate::thir::pattern::deconstruct_pat::DeconstructedPat;\n use crate::thir::pattern::MatchCheckCtxt;\n use rustc_errors::Handler;\n use rustc_errors::{\n-    error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, MultiSpan,\n+    error_code, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    IntoDiagnostic, MultiSpan, SubdiagnosticMessage,\n };\n+use rustc_hir::def::Res;\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_middle::thir::Pat;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::{symbol::Ident, Span};\n \n@@ -624,3 +628,223 @@ pub enum MultipleMutBorrowOccurence {\n         name_moved: Ident,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_union_pattern)]\n+pub struct UnionPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_type_not_structural)]\n+pub struct TypeNotStructural<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_invalid_pattern)]\n+pub struct InvalidPattern<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_unsized_pattern)]\n+pub struct UnsizedPattern<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_float_pattern)]\n+pub struct FloatPattern;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_pointer_pattern)]\n+pub struct PointerPattern;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_indirect_structural_match)]\n+pub struct IndirectStructuralMatch<'tcx> {\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_nontrivial_structural_match)]\n+pub struct NontrivialStructuralMatch<'tcx> {\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_overlapping_range_endpoints)]\n+#[note]\n+pub struct OverlappingRangeEndpoints<'tcx> {\n+    #[label(range)]\n+    pub range: Span,\n+    #[subdiagnostic]\n+    pub overlap: Vec<Overlap<'tcx>>,\n+}\n+\n+pub struct Overlap<'tcx> {\n+    pub span: Span,\n+    pub range: Pat<'tcx>,\n+}\n+\n+impl<'tcx> AddToDiagnostic for Overlap<'tcx> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        let Overlap { span, range } = self;\n+\n+        // FIXME(mejrs) unfortunately `#[derive(LintDiagnostic)]`\n+        // does not support `#[subdiagnostic(eager)]`...\n+        let message = format!(\"this range overlaps on `{range}`...\");\n+        diag.span_label(span, message);\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_non_exhaustive_omitted_pattern)]\n+#[help]\n+#[note]\n+pub(crate) struct NonExhaustiveOmittedPattern<'tcx> {\n+    pub scrut_ty: Ty<'tcx>,\n+    #[subdiagnostic]\n+    pub uncovered: Uncovered<'tcx>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(mir_build_uncovered)]\n+pub(crate) struct Uncovered<'tcx> {\n+    #[primary_span]\n+    span: Span,\n+    count: usize,\n+    witness_1: Pat<'tcx>,\n+    witness_2: Pat<'tcx>,\n+    witness_3: Pat<'tcx>,\n+    remainder: usize,\n+}\n+\n+impl<'tcx> Uncovered<'tcx> {\n+    pub fn new<'p>(\n+        span: Span,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n+    ) -> Self {\n+        let witness_1 = witnesses.get(0).unwrap().to_pat(cx);\n+        Self {\n+            span,\n+            count: witnesses.len(),\n+            // Substitute dummy values if witnesses is smaller than 3. These will never be read.\n+            witness_2: witnesses.get(1).map(|w| w.to_pat(cx)).unwrap_or_else(|| witness_1.clone()),\n+            witness_3: witnesses.get(2).map(|w| w.to_pat(cx)).unwrap_or_else(|| witness_1.clone()),\n+            witness_1,\n+            remainder: witnesses.len().saturating_sub(3),\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_pattern_not_covered, code = \"E0005\")]\n+pub(crate) struct PatternNotCovered<'s, 'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub origin: &'s str,\n+    #[subdiagnostic]\n+    pub uncovered: Uncovered<'tcx>,\n+    #[subdiagnostic]\n+    pub inform: Option<Inform>,\n+    #[subdiagnostic]\n+    pub interpreted_as_const: Option<InterpretedAsConst>,\n+    #[subdiagnostic]\n+    pub adt_defined_here: Option<AdtDefinedHere<'tcx>>,\n+    #[note(pattern_ty)]\n+    pub _p: (),\n+    pub pattern_ty: Ty<'tcx>,\n+    #[subdiagnostic]\n+    pub let_suggestion: Option<SuggestLet>,\n+    #[subdiagnostic]\n+    pub res_defined_here: Option<ResDefinedHere>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(mir_build_inform_irrefutable)]\n+#[note(mir_build_more_information)]\n+pub struct Inform;\n+\n+pub struct AdtDefinedHere<'tcx> {\n+    pub adt_def_span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub variants: Vec<Variant>,\n+}\n+\n+pub struct Variant {\n+    pub span: Span,\n+}\n+\n+impl<'tcx> AddToDiagnostic for AdtDefinedHere<'tcx> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"ty\", self.ty);\n+        let mut spans = MultiSpan::from(self.adt_def_span);\n+\n+        for Variant { span } in self.variants {\n+            spans.push_span_label(span, rustc_errors::fluent::mir_build_variant_defined_here);\n+        }\n+\n+        diag.span_note(spans, rustc_errors::fluent::mir_build_adt_defined_here);\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(mir_build_res_defined_here)]\n+pub struct ResDefinedHere {\n+    #[primary_span]\n+    pub def_span: Span,\n+    pub res: Res,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    mir_build_interpreted_as_const,\n+    code = \"{variable}_var\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+#[label(mir_build_confused)]\n+pub struct InterpretedAsConst {\n+    #[primary_span]\n+    pub span: Span,\n+    pub article: &'static str,\n+    pub variable: String,\n+    pub res: Res,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestLet {\n+    #[multipart_suggestion(mir_build_suggest_if_let, applicability = \"has-placeholders\")]\n+    If {\n+        #[suggestion_part(code = \"if \")]\n+        start_span: Span,\n+        #[suggestion_part(code = \" {{ todo!() }}\")]\n+        semi_span: Span,\n+        count: usize,\n+    },\n+    #[suggestion(\n+        mir_build_suggest_let_else,\n+        code = \" else {{ todo!() }}\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    Else {\n+        #[primary_span]\n+        end_span: Span,\n+        count: usize,\n+    },\n+}"}, {"sha": "fb7ae6f1d242412e8e72197107f2214969a54e50", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -10,6 +10,7 @@\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(once_cell)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "e13c0662ef85f17cb45edb3bd2f7dd26820e7256", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 59, "deletions": 132, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -9,8 +9,7 @@ use crate::errors::*;\n use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n use rustc_errors::{\n-    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-    MultiSpan,\n+    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::*;\n@@ -378,8 +377,8 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n \n         let pattern = self.lower_pattern(&mut cx, pat, &mut false);\n         let pattern_ty = pattern.ty();\n-        let arms = vec![MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false }];\n-        let report = compute_match_usefulness(&cx, &arms, pat.hir_id, pattern_ty);\n+        let arm = MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false };\n+        let report = compute_match_usefulness(&cx, &[arm], pat.hir_id, pattern_ty);\n \n         // Note: we ignore whether the pattern is unreachable (i.e. whether the type is empty). We\n         // only care about exhaustiveness here.\n@@ -390,145 +389,73 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             return;\n         }\n \n-        let joined_patterns = joined_uncovered_patterns(&cx, &witnesses);\n-\n-        let mut bindings = vec![];\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            pat.span,\n-            E0005,\n-            \"refutable pattern in {}: {} not covered\",\n-            origin,\n-            joined_patterns\n-        );\n-        let suggest_if_let = match &pat.kind {\n-            hir::PatKind::Path(hir::QPath::Resolved(None, path))\n-                if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n+        let (inform, interpreted_as_const, res_defined_here,let_suggestion) =\n+            if let hir::PatKind::Path(hir::QPath::Resolved(\n+                None,\n+                hir::Path {\n+                    segments: &[hir::PathSegment { args: None, res, ident, .. }],\n+                    ..\n+                },\n+            )) = &pat.kind\n             {\n-                const_not_var(&mut err, cx.tcx, pat, path);\n-                false\n-            }\n-            _ => {\n-                pat.walk(&mut |pat: &hir::Pat<'_>| {\n-                    match pat.kind {\n-                        hir::PatKind::Binding(_, _, ident, _) => {\n-                            bindings.push(ident);\n+                (\n+                    None,\n+                    Some(InterpretedAsConst {\n+                        span: pat.span,\n+                        article: res.article(),\n+                        variable: ident.to_string().to_lowercase(),\n+                        res,\n+                    }),\n+                    try {\n+                        ResDefinedHere {\n+                            def_span: cx.tcx.hir().res_span(res)?,\n+                            res,\n                         }\n-                        _ => {}\n+                    },\n+                    None,\n+                )\n+            } else if let Some(span) = sp && self.tcx.sess.source_map().is_span_accessible(span) {\n+                let mut bindings = vec![];\n+                pat.walk_always(&mut |pat: &hir::Pat<'_>| {\n+                    if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n+                        bindings.push(ident);\n                     }\n-                    true\n                 });\n-\n-                err.span_label(pat.span, pattern_not_covered_label(&witnesses, &joined_patterns));\n-                true\n-            }\n-        };\n-\n-        if let (Some(span), true) = (sp, suggest_if_let) {\n-            err.note(\n-                \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n-                 an `enum` with only one variant\",\n-            );\n-            if self.tcx.sess.source_map().is_span_accessible(span) {\n                 let semi_span = span.shrink_to_hi().with_lo(span.hi() - BytePos(1));\n                 let start_span = span.shrink_to_lo();\n                 let end_span = semi_span.shrink_to_lo();\n-                err.multipart_suggestion(\n-                    &format!(\n-                        \"you might want to use `if let` to ignore the variant{} that {} matched\",\n-                        pluralize!(witnesses.len()),\n-                        match witnesses.len() {\n-                            1 => \"isn't\",\n-                            _ => \"aren't\",\n-                        },\n-                    ),\n-                    vec![\n-                        match &bindings[..] {\n-                            [] => (start_span, \"if \".to_string()),\n-                            [binding] => (start_span, format!(\"let {} = if \", binding)),\n-                            bindings => (\n-                                start_span,\n-                                format!(\n-                                    \"let ({}) = if \",\n-                                    bindings\n-                                        .iter()\n-                                        .map(|ident| ident.to_string())\n-                                        .collect::<Vec<_>>()\n-                                        .join(\", \")\n-                                ),\n-                            ),\n-                        },\n-                        match &bindings[..] {\n-                            [] => (semi_span, \" { todo!() }\".to_string()),\n-                            [binding] => {\n-                                (end_span, format!(\" {{ {} }} else {{ todo!() }}\", binding))\n-                            }\n-                            bindings => (\n-                                end_span,\n-                                format!(\n-                                    \" {{ ({}) }} else {{ todo!() }}\",\n-                                    bindings\n-                                        .iter()\n-                                        .map(|ident| ident.to_string())\n-                                        .collect::<Vec<_>>()\n-                                        .join(\", \")\n-                                ),\n-                            ),\n-                        },\n-                    ],\n-                    Applicability::HasPlaceholders,\n-                );\n-                if !bindings.is_empty() {\n-                    err.span_suggestion_verbose(\n-                        semi_span.shrink_to_lo(),\n-                        &format!(\n-                            \"alternatively, you might want to use \\\n-                             let else to handle the variant{} that {} matched\",\n-                            pluralize!(witnesses.len()),\n-                            match witnesses.len() {\n-                                1 => \"isn't\",\n-                                _ => \"aren't\",\n-                            },\n-                        ),\n-                        \" else { todo!() }\",\n-                        Applicability::HasPlaceholders,\n-                    );\n-                }\n-            }\n-            err.note(\n-                \"for more information, visit \\\n-                 https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n-            );\n-        }\n+                let count = witnesses.len();\n \n-        adt_defined_here(&cx, &mut err, pattern_ty, &witnesses);\n-        err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n-        err.emit();\n-    }\n-}\n+                let let_suggestion = if bindings.is_empty() {SuggestLet::If{start_span, semi_span, count}} else{ SuggestLet::Else{end_span, count }};\n+                (sp.map(|_|Inform), None, None, Some(let_suggestion))\n+            } else{\n+                (sp.map(|_|Inform), None, None,  None)\n+            };\n \n-/// A path pattern was interpreted as a constant, not a new variable.\n-/// This caused an irrefutable match failure in e.g. `let`.\n-fn const_not_var(err: &mut Diagnostic, tcx: TyCtxt<'_>, pat: &Pat<'_>, path: &hir::Path<'_>) {\n-    let descr = path.res.descr();\n-    err.span_label(\n-        pat.span,\n-        format!(\"interpreted as {} {} pattern, not a new variable\", path.res.article(), descr,),\n-    );\n+        let adt_defined_here = try {\n+            let ty = pattern_ty.peel_refs();\n+            let ty::Adt(def, _) = ty.kind() else { None? };\n+            let adt_def_span = cx.tcx.hir().get_if_local(def.did())?.ident()?.span;\n+            let mut variants = vec![];\n \n-    err.span_suggestion(\n-        pat.span,\n-        \"introduce a variable instead\",\n-        format!(\"{}_var\", path.segments[0].ident).to_lowercase(),\n-        // Cannot use `MachineApplicable` as it's not really *always* correct\n-        // because there may be such an identifier in scope or the user maybe\n-        // really wanted to match against the constant. This is quite unlikely however.\n-        Applicability::MaybeIncorrect,\n-    );\n+            for span in maybe_point_at_variant(&cx, *def, witnesses.iter().take(5)) {\n+                variants.push(Variant { span });\n+            }\n+            AdtDefinedHere { adt_def_span, ty, variants }\n+        };\n \n-    if let Some(span) = tcx.hir().res_span(path.res) {\n-        err.span_label(span, format!(\"{} defined here\", descr));\n+        self.tcx.sess.emit_err(PatternNotCovered {\n+            span: pat.span,\n+            origin,\n+            uncovered: Uncovered::new(pat.span, &cx, witnesses),\n+            inform,\n+            interpreted_as_const,\n+            _p: (),\n+            pattern_ty,\n+            let_suggestion,\n+            res_defined_here,\n+            adt_defined_here,\n+        });\n     }\n }\n "}, {"sha": "7f3519945c3fed4ea3ba3ea29da636dd456c5e02", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 51, "deletions": 137, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,11 +1,9 @@\n-use rustc_errors::DelayDm;\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::Span;\n use rustc_trait_selection::traits::predicate_for_trait_def;\n@@ -15,6 +13,10 @@ use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligation};\n use std::cell::Cell;\n \n use super::PatCtxt;\n+use crate::errors::{\n+    FloatPattern, IndirectStructuralMatch, InvalidPattern, NontrivialStructuralMatch,\n+    PointerPattern, TypeNotStructural, UnionPattern, UnsizedPattern,\n+};\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Converts an evaluated constant to a pattern (if possible).\n@@ -105,47 +107,6 @@ impl<'tcx> ConstToPat<'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn adt_derive_msg(&self, adt_def: AdtDef<'tcx>) -> String {\n-        let path = self.tcx().def_path_str(adt_def.did());\n-        format!(\n-            \"to use a constant of type `{}` in a pattern, \\\n-            `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-            path, path,\n-        )\n-    }\n-\n-    fn search_for_structural_match_violation(&self, ty: Ty<'tcx>) -> Option<String> {\n-        traits::search_for_structural_match_violation(self.span, self.tcx(), ty).map(|non_sm_ty| {\n-            with_no_trimmed_paths!(match non_sm_ty.kind() {\n-                ty::Adt(adt, _) => self.adt_derive_msg(*adt),\n-                ty::Dynamic(..) => {\n-                    \"trait objects cannot be used in patterns\".to_string()\n-                }\n-                ty::Alias(ty::Opaque, ..) => {\n-                    \"opaque types cannot be used in patterns\".to_string()\n-                }\n-                ty::Closure(..) => {\n-                    \"closures cannot be used in patterns\".to_string()\n-                }\n-                ty::Generator(..) | ty::GeneratorWitness(..) => {\n-                    \"generators cannot be used in patterns\".to_string()\n-                }\n-                ty::Float(..) => {\n-                    \"floating-point numbers cannot be used in patterns\".to_string()\n-                }\n-                ty::FnPtr(..) => {\n-                    \"function pointers cannot be used in patterns\".to_string()\n-                }\n-                ty::RawPtr(..) => {\n-                    \"raw pointers cannot be used in patterns\".to_string()\n-                }\n-                _ => {\n-                    bug!(\"use of a value of `{non_sm_ty}` inside a pattern\")\n-                }\n-            })\n-        })\n-    }\n-\n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n         ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n@@ -176,7 +137,8 @@ impl<'tcx> ConstToPat<'tcx> {\n             // If we were able to successfully convert the const to some pat,\n             // double-check that all types in the const implement `Structural`.\n \n-            let structural = self.search_for_structural_match_violation(cv.ty());\n+            let structural =\n+                traits::search_for_structural_match_violation(self.span, self.tcx(), cv.ty());\n             debug!(\n                 \"search_for_structural_match_violation cv.ty: {:?} returned: {:?}\",\n                 cv.ty(),\n@@ -194,17 +156,18 @@ impl<'tcx> ConstToPat<'tcx> {\n                 return inlined_const_as_pat;\n             }\n \n-            if let Some(msg) = structural {\n+            if let Some(non_sm_ty) = structural {\n                 if !self.type_may_have_partial_eq_impl(cv.ty()) {\n-                    // span_fatal avoids ICE from resolution of non-existent method (rare case).\n-                    self.tcx().sess.span_fatal(self.span, &msg);\n+                    // fatal avoids ICE from resolution of non-existent method (rare case).\n+                    self.tcx()\n+                        .sess\n+                        .emit_fatal(TypeNotStructural { span: self.span, non_sm_ty: non_sm_ty });\n                 } else if mir_structural_match_violation && !self.saw_const_match_lint.get() {\n-                    self.tcx().struct_span_lint_hir(\n+                    self.tcx().emit_spanned_lint(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         self.id,\n                         self.span,\n-                        msg,\n-                        |lint| lint,\n+                        IndirectStructuralMatch { non_sm_ty },\n                     );\n                 } else {\n                     debug!(\n@@ -278,42 +241,34 @@ impl<'tcx> ConstToPat<'tcx> {\n         let kind = match cv.ty().kind() {\n             ty::Float(_) => {\n                 if self.include_lint_checks {\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                         id,\n                         span,\n-                        \"floating-point types cannot be used in patterns\",\n-                        |lint| lint,\n+                        FloatPattern,\n                     );\n                 }\n                 PatKind::Constant { value: cv }\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.saw_const_match_error.set(true);\n-                let msg = \"cannot use unions in constant patterns\";\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, msg);\n-                }\n+                let err = UnionPattern { span };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             ty::Adt(..)\n                 if !self.type_may_have_partial_eq_impl(cv.ty())\n                     // FIXME(#73448): Find a way to bring const qualification into parity with\n                     // `search_for_structural_match_violation` and then remove this condition.\n-                    && self.search_for_structural_match_violation(cv.ty()).is_some() =>\n+\n+                    // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n+                    // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n+                    && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty()) =>\n             {\n-                // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n-                // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-                let msg = self.search_for_structural_match_violation(cv.ty()).unwrap();\n                 self.saw_const_match_error.set(true);\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(self.span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(self.span, &msg);\n-                }\n+                let err = TypeNotStructural { span, non_sm_ty };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             // If the type is not structurally comparable, just emit the constant directly,\n@@ -331,19 +286,11 @@ impl<'tcx> ConstToPat<'tcx> {\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        DelayDm(|| {\n-                            format!(\n-                                \"to use a constant of type `{}` in a pattern, \\\n-                                 `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                                cv.ty(),\n-                                cv.ty(),\n-                            )\n-                        }),\n-                        |lint| lint,\n+                        IndirectStructuralMatch { non_sm_ty: cv.ty() },\n                     );\n                 }\n                 // Since we are behind a reference, we can just bubble the error up so we get a\n@@ -357,18 +304,9 @@ impl<'tcx> ConstToPat<'tcx> {\n                     adt_def,\n                     cv.ty()\n                 );\n-                let path = tcx.def_path_str(adt_def.did());\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path, path,\n-                );\n                 self.saw_const_match_error.set(true);\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, &msg);\n-                }\n+                let err = TypeNotStructural { span, non_sm_ty: cv.ty() };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n@@ -401,12 +339,8 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // These are not allowed and will error elsewhere anyway.\n                 ty::Dynamic(..) => {\n                     self.saw_const_match_error.set(true);\n-                    let msg = format!(\"`{}` cannot be used in patterns\", cv.ty());\n-                    if self.include_lint_checks {\n-                        tcx.sess.span_err(span, &msg);\n-                    } else {\n-                        tcx.sess.delay_span_bug(span, &msg);\n-                    }\n+                    let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n+                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                     PatKind::Wild\n                 }\n                 // `&str` is represented as `ConstValue::Slice`, let's keep using this\n@@ -471,32 +405,26 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // this pattern to a `PartialEq::eq` comparison and `PartialEq::eq` takes a\n                 // reference. This makes the rest of the matching logic simpler as it doesn't have\n                 // to figure out how to get a reference again.\n-                ty::Adt(adt_def, _) if !self.type_marked_structural(*pointee_ty) => {\n+                ty::Adt(_, _) if !self.type_marked_structural(*pointee_ty) => {\n                     if self.behind_reference.get() {\n                         if self.include_lint_checks\n                             && !self.saw_const_match_error.get()\n                             && !self.saw_const_match_lint.get()\n                         {\n-                            self.saw_const_match_lint.set(true);\n-                            let msg = self.adt_derive_msg(adt_def);\n-                            self.tcx().struct_span_lint_hir(\n+                           self.saw_const_match_lint.set(true);\n+                           tcx.emit_spanned_lint(\n                                 lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                                 self.id,\n-                                self.span,\n-                                msg,\n-                                |lint| lint,\n+                                span,\n+                                IndirectStructuralMatch { non_sm_ty: *pointee_ty },\n                             );\n                         }\n                         PatKind::Constant { value: cv }\n                     } else {\n                         if !self.saw_const_match_error.get() {\n                             self.saw_const_match_error.set(true);\n-                            let msg = self.adt_derive_msg(adt_def);\n-                            if self.include_lint_checks {\n-                                tcx.sess.span_err(span, &msg);\n-                            } else {\n-                                tcx.sess.delay_span_bug(span, &msg);\n-                            }\n+                            let err = TypeNotStructural { span, non_sm_ty: *pointee_ty };\n+                            tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                         }\n                         PatKind::Wild\n                     }\n@@ -508,12 +436,10 @@ impl<'tcx> ConstToPat<'tcx> {\n                     if !pointee_ty.is_sized(tcx, param_env) {\n                         // `tcx.deref_mir_constant()` below will ICE with an unsized type\n                         // (except slices, which are handled in a separate arm above).\n-                        let msg = format!(\"cannot use unsized non-slice type `{}` in constant patterns\", pointee_ty);\n-                        if self.include_lint_checks {\n-                            tcx.sess.span_err(span, &msg);\n-                        } else {\n-                            tcx.sess.delay_span_bug(span, &msg);\n-                        }\n+\n+                        let err = UnsizedPattern { span, non_sm_ty: *pointee_ty };\n+                        tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+\n                         PatKind::Wild\n                     } else {\n                         let old = self.behind_reference.replace(true);\n@@ -545,27 +471,19 @@ impl<'tcx> ConstToPat<'tcx> {\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n-                    let msg = \"function pointers and unsized pointers in patterns behave \\\n-                        unpredictably and should not be relied upon. \\\n-                        See https://github.com/rust-lang/rust/issues/70861 for details.\";\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::POINTER_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        msg,\n-                        |lint| lint,\n+                        PointerPattern\n                     );\n                 }\n                 PatKind::Constant { value: cv }\n             }\n             _ => {\n                 self.saw_const_match_error.set(true);\n-                let msg = format!(\"`{}` cannot be used in patterns\", cv.ty());\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, &msg);\n-                }\n+                let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n+                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n         };\n@@ -576,21 +494,17 @@ impl<'tcx> ConstToPat<'tcx> {\n             && mir_structural_match_violation\n             // FIXME(#73448): Find a way to bring const qualification into parity with\n             // `search_for_structural_match_violation` and then remove this condition.\n-            && self.search_for_structural_match_violation(cv.ty()).is_some()\n-        {\n-            self.saw_const_match_lint.set(true);\n+\n             // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n             // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-            let msg = self.search_for_structural_match_violation(cv.ty()).unwrap().replace(\n-                \"in a pattern,\",\n-                \"in a pattern, the constant's initializer must be trivial or\",\n-            );\n-            tcx.struct_span_lint_hir(\n+            && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty())\n+        {\n+            self.saw_const_match_lint.set(true);\n+            tcx.emit_spanned_lint(\n                 lint::builtin::NONTRIVIAL_STRUCTURAL_MATCH,\n                 id,\n                 span,\n-                msg,\n-                |lint| lint,\n+                NontrivialStructuralMatch {non_sm_ty}\n             );\n         }\n "}, {"sha": "17b3c475f83c78a3d4711e65092859da5d5d147b", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -67,6 +67,7 @@ use self::SliceKind::*;\n \n use super::compare_const_vals;\n use super::usefulness::{MatchCheckCtxt, PatCtxt};\n+use crate::errors::{Overlap, OverlappingRangeEndpoints};\n \n /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n@@ -96,7 +97,7 @@ fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n /// around the (offset) space: i.e., `range.lo <= range.hi`.\n #[derive(Clone, PartialEq, Eq)]\n-pub(super) struct IntRange {\n+pub(crate) struct IntRange {\n     range: RangeInclusive<u128>,\n     /// Keeps the bias used for encoding the range. It depends on the type of the range and\n     /// possibly the pointer size of the current architecture. The algorithm ensures we never\n@@ -284,32 +285,21 @@ impl IntRange {\n             return;\n         }\n \n-        let overlaps: Vec<_> = pats\n+        let overlap: Vec<_> = pats\n             .filter_map(|pat| Some((pat.ctor().as_int_range()?, pat.span())))\n             .filter(|(range, _)| self.suspicious_intersection(range))\n-            .map(|(range, span)| (self.intersection(&range).unwrap(), span))\n+            .map(|(range, span)| Overlap {\n+                range: self.intersection(&range).unwrap().to_pat(pcx.cx.tcx, pcx.ty),\n+                span,\n+            })\n             .collect();\n \n-        if !overlaps.is_empty() {\n-            pcx.cx.tcx.struct_span_lint_hir(\n+        if !overlap.is_empty() {\n+            pcx.cx.tcx.emit_spanned_lint(\n                 lint::builtin::OVERLAPPING_RANGE_ENDPOINTS,\n                 hir_id,\n                 pcx.span,\n-                \"multiple patterns overlap on their endpoints\",\n-                |lint| {\n-                    for (int_range, span) in overlaps {\n-                        lint.span_label(\n-                            span,\n-                            &format!(\n-                                \"this range overlaps on `{}`...\",\n-                                int_range.to_pat(pcx.cx.tcx, pcx.ty)\n-                            ),\n-                        );\n-                    }\n-                    lint.span_label(pcx.span, \"... with this range\");\n-                    lint.note(\"you likely meant to write mutually exclusive ranges\");\n-                    lint\n-                },\n+                OverlappingRangeEndpoints { overlap, range: pcx.span },\n             );\n         }\n     }"}, {"sha": "3a6ef87c9c662d393768c1c8f82ea6c95925d1a4", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,7 +2,7 @@\n \n mod check_match;\n mod const_to_pat;\n-mod deconstruct_pat;\n+pub(crate) mod deconstruct_pat;\n mod usefulness;\n \n pub(crate) use self::check_match::check_match;"}, {"sha": "be66d0d476513992b4009fef5d85ba354ba4b82a", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -291,9 +291,8 @@\n \n use self::ArmType::*;\n use self::Usefulness::*;\n-\n-use super::check_match::{joined_uncovered_patterns, pattern_not_covered_label};\n use super::deconstruct_pat::{Constructor, DeconstructedPat, Fields, SplitWildcard};\n+use crate::errors::{NonExhaustiveOmittedPattern, Uncovered};\n \n use rustc_data_structures::captures::Captures;\n \n@@ -743,31 +742,6 @@ impl<'p, 'tcx> Witness<'p, 'tcx> {\n     }\n }\n \n-/// Report that a match of a `non_exhaustive` enum marked with `non_exhaustive_omitted_patterns`\n-/// is not exhaustive enough.\n-///\n-/// NB: The partner lint for structs lives in `compiler/rustc_hir_analysis/src/check/pat.rs`.\n-fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n-    cx: &MatchCheckCtxt<'p, 'tcx>,\n-    scrut_ty: Ty<'tcx>,\n-    sp: Span,\n-    hir_id: HirId,\n-    witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n-) {\n-    cx.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, hir_id, sp, \"some variants are not matched explicitly\", |lint| {\n-        let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n-        lint.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n-        lint.help(\n-            \"ensure that all variants are matched explicitly by adding the suggested match arms\",\n-        );\n-        lint.note(&format!(\n-            \"the matched value is of type `{}` and the `non_exhaustive_omitted_patterns` attribute was found\",\n-            scrut_ty,\n-        ));\n-        lint\n-    });\n-}\n-\n /// Algorithm from <http://moscova.inria.fr/~maranget/papers/warn/index.html>.\n /// The algorithm from the paper has been modified to correctly handle empty\n /// types. The changes are:\n@@ -913,7 +887,19 @@ fn is_useful<'p, 'tcx>(\n                         .collect::<Vec<_>>()\n                 };\n \n-                lint_non_exhaustive_omitted_patterns(pcx.cx, pcx.ty, pcx.span, hir_id, patterns);\n+                // Report that a match of a `non_exhaustive` enum marked with `non_exhaustive_omitted_patterns`\n+                // is not exhaustive enough.\n+                //\n+                // NB: The partner lint for structs lives in `compiler/rustc_hir_analysis/src/check/pat.rs`.\n+                cx.tcx.emit_spanned_lint(\n+                    NON_EXHAUSTIVE_OMITTED_PATTERNS,\n+                    hir_id,\n+                    pcx.span,\n+                    NonExhaustiveOmittedPattern {\n+                        scrut_ty: pcx.ty,\n+                        uncovered: Uncovered::new(pcx.span, pcx.cx, patterns),\n+                    },\n+                );\n             }\n \n             ret.extend(usefulness);"}, {"sha": "4405537c645a9ffb384407f0c8e4ffd686fdef00", "filename": "compiler/rustc_trait_selection/src/errors.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,7 +1,6 @@\n use rustc_errors::{fluent, ErrorGuaranteed, Handler, IntoDiagnostic};\n use rustc_macros::Diagnostic;\n use rustc_middle::ty::{self, PolyTraitRef, Ty};\n-use rustc_session::Limit;\n use rustc_span::{Span, Symbol};\n \n #[derive(Diagnostic)]\n@@ -21,18 +20,6 @@ pub struct UnableToConstructConstantValue<'a> {\n     pub unevaluated: ty::UnevaluatedConst<'a>,\n }\n \n-#[derive(Diagnostic)]\n-#[help]\n-#[diag(trait_selection_auto_deref_reached_recursion_limit, code = \"E0055\")]\n-pub struct AutoDerefReachedRecursionLimit<'a> {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    pub ty: Ty<'a>,\n-    pub suggested_limit: Limit,\n-    pub crate_name: Symbol,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(trait_selection_empty_on_clause_in_rustc_on_unimplemented, code = \"E0232\")]\n pub struct EmptyOnClauseInOnUnimplemented {"}, {"sha": "081ac966c696193252a769e5944aae4ac38c9090", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -35,7 +35,6 @@ extern crate rustc_middle;\n #[macro_use]\n extern crate smallvec;\n \n-pub mod autoderef;\n pub mod errors;\n pub mod infer;\n pub mod solve;"}, {"sha": "1b98ead29f851d96e076703361ea7053be52d9d0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 118, "deletions": 55, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -5,7 +5,6 @@ use super::{\n     PredicateObligation,\n };\n \n-use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n use crate::traits::{NormalizeExt, ObligationCtxt};\n \n@@ -750,26 +749,30 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n \n             if let ty::Ref(region, base_ty, mutbl) = *real_ty.skip_binder().kind() {\n-                let mut autoderef = Autoderef::new(\n-                    self,\n-                    obligation.param_env,\n-                    obligation.cause.body_id,\n-                    span,\n-                    base_ty,\n-                );\n-                if let Some(steps) = autoderef.find_map(|(ty, steps)| {\n-                    // Re-add the `&`\n-                    let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });\n-\n-                    // Remapping bound vars here\n-                    let real_trait_pred_and_ty =\n-                        real_trait_pred.map_bound(|inner_trait_pred| (inner_trait_pred, ty));\n-                    let obligation = self.mk_trait_obligation_with_new_self_ty(\n-                        obligation.param_env,\n-                        real_trait_pred_and_ty,\n-                    );\n-                    Some(steps).filter(|_| self.predicate_may_hold(&obligation))\n-                }) {\n+                let autoderef = (self.autoderef_steps)(base_ty);\n+                if let Some(steps) =\n+                    autoderef.into_iter().enumerate().find_map(|(steps, (ty, obligations))| {\n+                        // Re-add the `&`\n+                        let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });\n+\n+                        // Remapping bound vars here\n+                        let real_trait_pred_and_ty =\n+                            real_trait_pred.map_bound(|inner_trait_pred| (inner_trait_pred, ty));\n+                        let obligation = self.mk_trait_obligation_with_new_self_ty(\n+                            obligation.param_env,\n+                            real_trait_pred_and_ty,\n+                        );\n+                        if obligations\n+                            .iter()\n+                            .chain([&obligation])\n+                            .all(|obligation| self.predicate_may_hold(obligation))\n+                        {\n+                            Some(steps)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                {\n                     if steps > 0 {\n                         // Don't care about `&mut` because `DerefMut` is used less\n                         // often and user will not expect autoderef happens.\n@@ -1358,57 +1361,117 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n-        let span = obligation.cause.span;\n+        let mut span = obligation.cause.span;\n+        let mut trait_pred = trait_pred;\n+        let mut code = obligation.cause.code();\n+        while let Some((c, Some(parent_trait_pred))) = code.parent() {\n+            // We want the root obligation, in order to detect properly handle\n+            // `for _ in &mut &mut vec![] {}`.\n+            code = c;\n+            trait_pred = parent_trait_pred;\n+        }\n+        while span.desugaring_kind().is_some() {\n+            // Remove all the hir desugaring contexts while maintaining the macro contexts.\n+            span.remove_mark();\n+        }\n+        let mut expr_finder = super::FindExprBySpan::new(span);\n+        let Some(hir::Node::Expr(body)) = self.tcx.hir().find(obligation.cause.body_id) else {\n+            return false;\n+        };\n+        expr_finder.visit_expr(&body);\n+        let mut maybe_suggest = |suggested_ty, count, suggestions| {\n+            // Remapping bound vars here\n+            let trait_pred_and_suggested_ty =\n+                trait_pred.map_bound(|trait_pred| (trait_pred, suggested_ty));\n+\n+            let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n+                obligation.param_env,\n+                trait_pred_and_suggested_ty,\n+            );\n \n-        let mut suggested = false;\n-        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-            let refs_number =\n-                snippet.chars().filter(|c| !c.is_whitespace()).take_while(|c| *c == '&').count();\n-            if let Some('\\'') = snippet.chars().filter(|c| !c.is_whitespace()).nth(refs_number) {\n-                // Do not suggest removal of borrow from type arguments.\n-                return false;\n+            if self.predicate_may_hold(&new_obligation) {\n+                let msg = if count == 1 {\n+                    \"consider removing the leading `&`-reference\".to_string()\n+                } else {\n+                    format!(\"consider removing {count} leading `&`-references\")\n+                };\n+\n+                err.multipart_suggestion_verbose(\n+                    &msg,\n+                    suggestions,\n+                    Applicability::MachineApplicable,\n+                );\n+                true\n+            } else {\n+                false\n             }\n+        };\n \n-            // Skipping binder here, remapping below\n-            let mut suggested_ty = trait_pred.self_ty().skip_binder();\n+        // Maybe suggest removal of borrows from types in type parameters, like in\n+        // `src/test/ui/not-panic/not-panic-safe.rs`.\n+        let mut count = 0;\n+        let mut suggestions = vec![];\n+        // Skipping binder here, remapping below\n+        let mut suggested_ty = trait_pred.self_ty().skip_binder();\n+        if let Some(mut hir_ty) = expr_finder.ty_result {\n+            while let hir::TyKind::Ref(_, mut_ty) = &hir_ty.kind {\n+                count += 1;\n+                let span = hir_ty.span.until(mut_ty.ty.span);\n+                suggestions.push((span, String::new()));\n \n-            for refs_remaining in 0..refs_number {\n                 let ty::Ref(_, inner_ty, _) = suggested_ty.kind() else {\n                     break;\n                 };\n                 suggested_ty = *inner_ty;\n \n-                // Remapping bound vars here\n-                let trait_pred_and_suggested_ty =\n-                    trait_pred.map_bound(|trait_pred| (trait_pred, suggested_ty));\n+                hir_ty = mut_ty.ty;\n \n-                let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n-                    obligation.param_env,\n-                    trait_pred_and_suggested_ty,\n-                );\n+                if maybe_suggest(suggested_ty, count, suggestions.clone()) {\n+                    return true;\n+                }\n+            }\n+        }\n \n-                if self.predicate_may_hold(&new_obligation) {\n-                    let sp = self\n-                        .tcx\n-                        .sess\n-                        .source_map()\n-                        .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+        // Maybe suggest removal of borrows from expressions, like in `for i in &&&foo {}`.\n+        let Some(mut expr) = expr_finder.result else { return false; };\n+        let mut count = 0;\n+        let mut suggestions = vec![];\n+        // Skipping binder here, remapping below\n+        let mut suggested_ty = trait_pred.self_ty().skip_binder();\n+        'outer: loop {\n+            while let hir::ExprKind::AddrOf(_, _, borrowed) = expr.kind {\n+                count += 1;\n+                let span = if expr.span.eq_ctxt(borrowed.span) {\n+                    expr.span.until(borrowed.span)\n+                } else {\n+                    expr.span.with_hi(expr.span.lo() + BytePos(1))\n+                };\n+                suggestions.push((span, String::new()));\n \n-                    let remove_refs = refs_remaining + 1;\n+                let ty::Ref(_, inner_ty, _) = suggested_ty.kind() else {\n+                    break 'outer;\n+                };\n+                suggested_ty = *inner_ty;\n \n-                    let msg = if remove_refs == 1 {\n-                        \"consider removing the leading `&`-reference\".to_string()\n-                    } else {\n-                        format!(\"consider removing {} leading `&`-references\", remove_refs)\n-                    };\n+                expr = borrowed;\n \n-                    err.span_suggestion_short(sp, &msg, \"\", Applicability::MachineApplicable);\n-                    suggested = true;\n-                    break;\n+                if maybe_suggest(suggested_ty, count, suggestions.clone()) {\n+                    return true;\n                 }\n             }\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n+                && let hir::def::Res::Local(hir_id) = path.res\n+                && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(hir_id)\n+                && let Some(hir::Node::Local(local)) = self.tcx.hir().find_parent(binding.hir_id)\n+                && let None = local.ty\n+                && let Some(binding_expr) = local.init\n+            {\n+                expr = binding_expr;\n+            } else {\n+                break 'outer;\n+            }\n         }\n-        suggested\n+        false\n     }\n \n     fn suggest_remove_await(&self, obligation: &PredicateObligation<'tcx>, err: &mut Diagnostic) {"}, {"sha": "e898bca88e419e1b31da51398fccafaf3d36b0ac", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -239,7 +239,6 @@\n #![feature(arm_target_feature)]\n #![feature(avx512_target_feature)]\n #![feature(cmpxchg16b_target_feature)]\n-#![feature(f16c_target_feature)]\n #![feature(hexagon_target_feature)]\n #![feature(mips_target_feature)]\n #![feature(powerpc_target_feature)]\n@@ -248,6 +247,7 @@\n #![feature(sse4a_target_feature)]\n #![feature(tbm_target_feature)]\n #![feature(wasm_target_feature)]\n+#![cfg_attr(bootstrap, feature(f16c_target_feature))]\n \n // allow using `core::` in intra-doc links\n #[allow(unused_extern_crates)]"}, {"sha": "21518a3f551807356dbbf2dc484f4af1387490fc", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 75, "deletions": 36, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1514,37 +1514,50 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n-        /// Calculates `self + rhs + carry` without the ability to overflow.\n+        /// Calculates `self` + `rhs` + `carry` and checks for overflow.\n         ///\n-        /// Performs \"signed ternary addition\" which takes in an extra bit to add, and may return an\n-        /// additional bit of overflow. This signed function is used only on the highest-ordered data,\n-        /// for which the signed overflow result indicates whether the big integer overflowed or not.\n+        /// Performs \"ternary addition\" of two integer operands and a carry-in\n+        /// bit, and returns a tuple of the sum along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. On overflow, the wrapped\n+        /// value is returned.\n         ///\n-        /// # Examples\n+        /// This allows chaining together multiple additions to create a wider\n+        /// addition, and can be useful for bignum addition. This method should\n+        /// only be used for the most significant word; for the less significant\n+        /// words the unsigned method\n+        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::carrying_add`]\")]\n+        /// should be used.\n         ///\n-        /// Basic usage:\n+        /// The output boolean returned by this method is *not* a carry flag,\n+        /// and should *not* be added to a more significant word.\n         ///\n-        /// ```\n-        /// #![feature(bigint_helper_methods)]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, false), (7, false));\")]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, true), (8, false));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, false), (\", stringify!($SelfT), \"::MIN, true));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(0, true), (\", stringify!($SelfT), \"::MIN, true));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, true), (\", stringify!($SelfT), \"::MIN + 1, true));\")]\n-        #[doc = concat!(\"assert_eq!(\",\n-            stringify!($SelfT), \"::MAX.carrying_add(\", stringify!($SelfT), \"::MAX, true), \",\n-            \"(-1, true));\"\n-        )]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.carrying_add(-1, true), (\", stringify!($SelfT), \"::MIN, false));\")]\n-        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".carrying_add(\", stringify!($SelfT), \"::MAX, true), (\", stringify!($SelfT), \"::MIN, true));\")]\n-        /// ```\n+        /// If the input carry is false, this method is equivalent to\n+        /// [`overflowing_add`](Self::overflowing_add).\n         ///\n-        /// If `carry` is false, this method is equivalent to [`overflowing_add`](Self::overflowing_add):\n+        /// # Examples\n         ///\n         /// ```\n         /// #![feature(bigint_helper_methods)]\n-        #[doc = concat!(\"assert_eq!(5_\", stringify!($SelfT), \".carrying_add(2, false), 5_\", stringify!($SelfT), \".overflowing_add(2));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, false), \", stringify!($SelfT), \"::MAX.overflowing_add(1));\")]\n+        /// // Only the  most significant word is signed.\n+        /// //\n+        #[doc = concat!(\"//   10  MAX    (a = 10 \u00d7 2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n+        #[doc = concat!(\"// + -5    9    (b = -5 \u00d7 2^\", stringify!($BITS), \" + 9)\")]\n+        /// // ---------\n+        #[doc = concat!(\"//    6    8    (sum = 6 \u00d7 2^\", stringify!($BITS), \" + 8)\")]\n+        ///\n+        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (10, \", stringify!($UnsignedT), \"::MAX);\")]\n+        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n+        /// let carry0 = false;\n+        ///\n+        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::carrying_add for the less significant words\")]\n+        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n+        /// assert_eq!(carry1, true);\n+        ///\n+        #[doc = concat!(\"// \", stringify!($SelfT), \"::carrying_add for the most significant word\")]\n+        /// let (sum1, overflow) = a1.carrying_add(b1, carry1);\n+        /// assert_eq!(overflow, false);\n+        ///\n+        /// assert_eq!((sum1, sum0), (6, 8));\n         /// ```\n         #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n         #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n@@ -1608,25 +1621,51 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n-        /// Calculates `self - rhs - borrow` without the ability to overflow.\n+        /// Calculates `self` &minus; `rhs` &minus; `borrow` and checks for\n+        /// overflow.\n         ///\n-        /// Performs \"signed ternary subtraction\" which takes in an extra bit to subtract, and may return an\n-        /// additional bit of overflow. This signed function is used only on the highest-ordered data,\n-        /// for which the signed overflow result indicates whether the big integer overflowed or not.\n+        /// Performs \"ternary subtraction\" by subtracting both an integer\n+        /// operandand a borrow-in bit from `self`, and returns a tuple of the\n+        /// difference along with a boolean indicating whether an arithmetic\n+        /// overflow would occur. On overflow, the wrapped value is returned.\n         ///\n-        /// # Examples\n+        /// This allows chaining together multiple subtractions to create a\n+        /// wider subtraction, and can be useful for bignum subtraction. This\n+        /// method should only be used for the most significant word; for the\n+        /// less significant words the unsigned method\n+        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::borrowing_sub`]\")]\n+        /// should be used.\n         ///\n-        /// Basic usage:\n+        /// The output boolean returned by this method is *not* a borrow flag,\n+        /// and should *not* be subtracted from a more significant word.\n+        ///\n+        /// If the input borrow is false, this method is equivalent to\n+        /// [`overflowing_sub`](Self::overflowing_sub).\n+        ///\n+        /// # Examples\n         ///\n         /// ```\n         /// #![feature(bigint_helper_methods)]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, false), (3, false));\")]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, true), (2, false));\")]\n-        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".borrowing_sub(1, false), (-1, false));\")]\n-        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".borrowing_sub(1, true), (-2, false));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.borrowing_sub(1, true), (\", stringify!($SelfT), \"::MAX - 1, true));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.borrowing_sub(-1, false), (\", stringify!($SelfT), \"::MIN, true));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.borrowing_sub(-1, true), (\", stringify!($SelfT), \"::MAX, false));\")]\n+        /// // Only the  most significant word is signed.\n+        /// //\n+        #[doc = concat!(\"//    6    8    (a = 6 \u00d7 2^\", stringify!($BITS), \" + 8)\")]\n+        #[doc = concat!(\"// - -5    9    (b = -5 \u00d7 2^\", stringify!($BITS), \" + 9)\")]\n+        /// // ---------\n+        #[doc = concat!(\"//   10  MAX    (diff = 10 \u00d7 2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n+        ///\n+        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (6, 8);\")]\n+        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n+        /// let borrow0 = false;\n+        ///\n+        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::borrowing_sub for the less significant words\")]\n+        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n+        /// assert_eq!(borrow1, true);\n+        ///\n+        #[doc = concat!(\"// \", stringify!($SelfT), \"::borrowing_sub for the most significant word\")]\n+        /// let (diff1, overflow) = a1.borrowing_sub(b1, borrow1);\n+        /// assert_eq!(overflow, false);\n+        ///\n+        #[doc = concat!(\"assert_eq!((diff1, diff0), (10, \", stringify!($UnsignedT), \"::MAX));\")]\n         /// ```\n         #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n         #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]"}, {"sha": "2eb29d4f9c57410081309ed539b6c6f2fb34d1ac", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -622,9 +622,8 @@ impl<P: Deref> Pin<P> {\n     /// that the closure is pinned.\n     ///\n     /// The better alternative is to avoid all that trouble and do the pinning in the outer function\n-    /// instead (here using the unstable `pin` macro):\n+    /// instead (here using the [`pin!`][crate::pin::pin] macro):\n     /// ```\n-    /// #![feature(pin_macro)]\n     /// use std::pin::pin;\n     /// use std::task::Context;\n     /// use std::future::Future;\n@@ -1026,7 +1025,6 @@ impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n /// ### Basic usage\n ///\n /// ```rust\n-/// #![feature(pin_macro)]\n /// # use core::marker::PhantomPinned as Foo;\n /// use core::pin::{pin, Pin};\n ///\n@@ -1044,7 +1042,6 @@ impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n /// ### Manually polling a `Future` (without `Unpin` bounds)\n ///\n /// ```rust\n-/// #![feature(pin_macro)]\n /// use std::{\n ///     future::Future,\n ///     pin::pin,\n@@ -1083,7 +1080,7 @@ impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n /// ### With `Generator`s\n ///\n /// ```rust\n-/// #![feature(generators, generator_trait, pin_macro)]\n+/// #![feature(generators, generator_trait)]\n /// use core::{\n ///     ops::{Generator, GeneratorState},\n ///     pin::pin,\n@@ -1126,7 +1123,6 @@ impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n /// The following, for instance, fails to compile:\n ///\n /// ```rust,compile_fail\n-/// #![feature(pin_macro)]\n /// use core::pin::{pin, Pin};\n /// # use core::{marker::PhantomPinned as Foo, mem::drop as stuff};\n ///\n@@ -1168,7 +1164,7 @@ impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n /// constructor.\n ///\n /// [`Box::pin`]: ../../std/boxed/struct.Box.html#method.pin\n-#[unstable(feature = \"pin_macro\", issue = \"93178\")]\n+#[stable(feature = \"pin_macro\", since = \"CURRENT_RUSTC_VERSION\")]\n #[rustc_macro_transparency = \"semitransparent\"]\n #[allow_internal_unstable(unsafe_pin_internals)]\n pub macro pin($value:expr $(,)?) {"}, {"sha": "42a26ae1675c182fb7e7c300e220d96aec2bc115", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -48,7 +48,6 @@\n #![feature(is_sorted)]\n #![feature(layout_for_ptr)]\n #![feature(pattern)]\n-#![feature(pin_macro)]\n #![feature(sort_internals)]\n #![feature(slice_take)]\n #![feature(slice_from_ptr_range)]"}, {"sha": "fe4078f77107b244d564595b8bf06fa98add2582", "filename": "src/tools/miri/tests/pass/issues/issue-miri-2068.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-miri-2068.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-miri-2068.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-miri-2068.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,5 +1,3 @@\n-#![feature(pin_macro)]\n-\n use core::future::Future;\n use core::pin::Pin;\n use core::task::{Context, Poll};"}, {"sha": "96fc0be344dbfea2f8065c503b4df6b3057d0a7c", "filename": "src/tools/miri/tests/pass/stacked-borrows/future-self-referential.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,5 +1,3 @@\n-#![feature(pin_macro)]\n-\n use std::future::*;\n use std::marker::PhantomPinned;\n use std::pin::*;"}, {"sha": "acdc3be8c6763bcc8779dbcf8e190e8b20220bb8", "filename": "tests/ui/associated-types/substs-ppaux.normal.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fassociated-types%2Fsubsts-ppaux.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fassociated-types%2Fsubsts-ppaux.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fsubsts-ppaux.normal.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:16:17\n    |\n LL |     fn bar<'a, T>() where T: 'a {}\n-   |     --------------------------- fn() {<i8 as Foo<'static, 'static, u8>>::bar::<'static, char>} defined here\n+   |     --------------------------- associated function `bar` defined here\n ...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>;\n    |            --   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found fn item\n@@ -20,7 +20,7 @@ error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:25:17\n    |\n LL |     fn bar<'a, T>() where T: 'a {}\n-   |     --------------------------- fn() {<i8 as Foo<'static, 'static>>::bar::<'static, char>} defined here\n+   |     --------------------------- associated function `bar` defined here\n ...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;\n    |            --   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found fn item\n@@ -38,7 +38,7 @@ error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:33:17\n    |\n LL |     fn baz() {}\n-   |     -------- fn() {<i8 as Foo<'static, 'static, u8>>::baz} defined here\n+   |     -------- associated function `baz` defined here\n ...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz;\n    |            --   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found fn item\n@@ -56,7 +56,7 @@ error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:41:17\n    |\n LL | fn foo<'z>() where &'z (): Sized {\n-   | -------------------------------- fn() {foo::<'static>} defined here\n+   | -------------------------------- function `foo` defined here\n ...\n LL |     let x: () = foo::<'static>;\n    |            --   ^^^^^^^^^^^^^^ expected `()`, found fn item"}, {"sha": "e4f6ba573ca40c7b37a51266acd9e79b244ade36", "filename": "tests/ui/associated-types/substs-ppaux.verbose.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fassociated-types%2Fsubsts-ppaux.verbose.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fassociated-types%2Fsubsts-ppaux.verbose.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fsubsts-ppaux.verbose.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:16:17\n    |\n LL |     fn bar<'a, T>() where T: 'a {}\n-   |     --------------------------- fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::bar::<ReStatic, char>} defined here\n+   |     --------------------------- associated function `bar` defined here\n ...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>;\n    |            --   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found fn item\n@@ -20,7 +20,7 @@ error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:25:17\n    |\n LL |     fn bar<'a, T>() where T: 'a {}\n-   |     --------------------------- fn() {<i8 as Foo<ReStatic, ReStatic>>::bar::<ReStatic, char>} defined here\n+   |     --------------------------- associated function `bar` defined here\n ...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;\n    |            --   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found fn item\n@@ -38,7 +38,7 @@ error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:33:17\n    |\n LL |     fn baz() {}\n-   |     -------- fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::baz} defined here\n+   |     -------- associated function `baz` defined here\n ...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz;\n    |            --   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found fn item\n@@ -56,7 +56,7 @@ error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:41:17\n    |\n LL | fn foo<'z>() where &'z (): Sized {\n-   | -------------------------------- fn() {foo::<ReStatic>} defined here\n+   | -------------------------------- function `foo` defined here\n ...\n LL |     let x: () = foo::<'static>;\n    |            --   ^^^^^^^^^^^^^^ expected `()`, found fn item"}, {"sha": "bd7aaf6fb6dfcdbca247abc193101635b698f8e0", "filename": "tests/ui/auto-traits/typeck-default-trait-impl-precedence.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fauto-traits%2Ftypeck-default-trait-impl-precedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fauto-traits%2Ftypeck-default-trait-impl-precedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Ftypeck-default-trait-impl-precedence.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -4,7 +4,6 @@ error[E0277]: the trait bound `u32: Signed` is not satisfied\n LL |     is_defaulted::<&'static u32>();\n    |                    ^^^^^^^^^^^^ the trait `Signed` is not implemented for `u32`\n    |\n-   = help: the trait `Signed` is implemented for `i32`\n note: required for `&'static u32` to implement `Defaulted`\n   --> $DIR/typeck-default-trait-impl-precedence.rs:10:19\n    |\n@@ -17,6 +16,11 @@ note: required by a bound in `is_defaulted`\n    |\n LL | fn is_defaulted<T:Defaulted>() { }\n    |                   ^^^^^^^^^ required by this bound in `is_defaulted`\n+help: consider removing the leading `&`-reference\n+   |\n+LL -     is_defaulted::<&'static u32>();\n+LL +     is_defaulted::<u32>();\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "1caf1617e213cb198ad9cbf82e80804013bbd664", "filename": "tests/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:25:15\n    |\n LL |     A = { let 0 = 0; 0 },"}, {"sha": "f038ba1c8ed859314c4aa4140e4018cce0bba1c7", "filename": "tests/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:31:24\n    |\n LL |     let x: [i32; { let 0 = 0; 0 }] = [];"}, {"sha": "b1921f8a41e48db0560471f059b83b6114ab9ec5", "filename": "tests/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:4:22\n    |\n LL | const X: i32 = { let 0 = 0; 0 };\n@@ -12,7 +12,7 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL | const X: i32 = { if let 0 = 0 { todo!() } 0 };\n    |                  ++           ~~~~~~~~~~~\n \n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:8:23\n    |\n LL | static Y: i32 = { let 0 = 0; 0 };\n@@ -26,7 +26,7 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL | static Y: i32 = { if let 0 = 0 { todo!() } 0 };\n    |                   ++           ~~~~~~~~~~~\n \n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:13:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n@@ -40,7 +40,7 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL |     const X: i32 = { if let 0 = 0 { todo!() } 0 };\n    |                      ++           ~~~~~~~~~~~\n \n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:19:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };"}, {"sha": "61bdf57ffdb9445890321d9ff29c25f2f114bc59", "filename": "tests/ui/consts/const-pattern-irrefutable.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -9,8 +9,20 @@ use foo::d;\n const a: u8 = 2;\n \n fn main() {\n-    let a = 4; //~ ERROR refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX\n-    let c = 4; //~ ERROR refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX\n-    let d = 4; //~ ERROR refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX\n+    let a = 4;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+    //~| missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n+    //~| HELP introduce a variable instead\n+    let c = 4;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+    //~| missing patterns are not covered because `c` is interpreted as a constant pattern, not a new variable\n+    //~| HELP introduce a variable instead\n+    let d = 4;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+    //~| missing patterns are not covered because `d` is interpreted as a constant pattern, not a new variable\n+    //~| HELP introduce a variable instead\n     fn f() {} // Check that the `NOTE`s still work with an item here (cf. issue #35115).\n }"}, {"sha": "c156ea1610c4fca77bd67d1364f8c57981bc4306", "filename": "tests/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-pattern-irrefutable.rs:12:9\n    |\n LL | const a: u8 = 2;\n@@ -7,35 +7,38 @@ LL | const a: u8 = 2;\n LL |     let a = 4;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+   |         missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `a_var`\n    |\n    = note: the matched value is of type `u8`\n \n-error[E0005]: refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n-  --> $DIR/const-pattern-irrefutable.rs:13:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/const-pattern-irrefutable.rs:17:9\n    |\n LL |     pub const b: u8 = 2;\n    |     --------------- constant defined here\n ...\n LL |     let c = 4;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+   |         missing patterns are not covered because `c` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `c_var`\n    |\n    = note: the matched value is of type `u8`\n \n-error[E0005]: refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n-  --> $DIR/const-pattern-irrefutable.rs:14:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/const-pattern-irrefutable.rs:22:9\n    |\n LL |     pub const d: u8 = 2;\n    |     --------------- constant defined here\n ...\n LL |     let d = 4;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+   |         missing patterns are not covered because `d` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `d_var`\n    |\n    = note: the matched value is of type `u8`"}, {"sha": "d6119028f5b59dff801ad06b757fdf1d670944f8", "filename": "tests/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in function argument: `&[]`, `&[_]` and `&[_, _, _, ..]` not covered\n+error[E0005]: refutable pattern in function argument\n   --> $DIR/const_let_refutable.rs:3:16\n    |\n LL | const fn slice(&[a, b]: &[i32]) -> i32 {"}, {"sha": "fd93346101d846778efb629f929afc4d99c25012", "filename": "tests/ui/empty/empty-never-array.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fempty%2Fempty-never-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fempty%2Fempty-never-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty%2Fempty-never-array.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -8,7 +8,8 @@ enum Helper<T, U> {\n \n fn transmute<T, U>(t: T) -> U {\n     let Helper::U(u) = Helper::T(t, []);\n-    //~^ ERROR refutable pattern in local binding: `Helper::T(_, _)` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `Helper::T(_, _)` not covered\n     u\n }\n "}, {"sha": "a488e484b2bf8f49825d47d269396ce8bc797b93", "filename": "tests/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty%2Fempty-never-array.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Helper::T(_, _)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/empty-never-array.rs:10:9\n    |\n LL |     let Helper::U(u) = Helper::T(t, []);\n@@ -7,18 +7,14 @@ LL |     let Helper::U(u) = Helper::T(t, []);\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Helper<T, U>` defined here\n-  --> $DIR/empty-never-array.rs:4:5\n+  --> $DIR/empty-never-array.rs:3:6\n    |\n LL | enum Helper<T, U> {\n-   |      ------\n+   |      ^^^^^^\n LL |     T(T, [!; 0]),\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `Helper<T, U>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let u = if let Helper::U(u) = Helper::T(t, []) { u } else { todo!() };\n-   |     ++++++++++                                     ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Helper::U(u) = Helper::T(t, []) else { todo!() };\n    |                                         ++++++++++++++++"}, {"sha": "4692b66413dff8f24a3bb4b86654ef41e789a0b0", "filename": "tests/ui/error-codes/E0005.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0005.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,22 +1,13 @@\n-error[E0005]: refutable pattern in local binding: `None` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/E0005.rs:3:9\n    |\n LL |     let Some(y) = x;\n    |         ^^^^^^^ pattern `None` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Option<i32>` defined here\n-  --> $SRC_DIR/core/src/option.rs:LL:COL\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Option<i32>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let y = if let Some(y) = x { y } else { todo!() };\n-   |     ++++++++++                 ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Some(y) = x else { todo!() };\n    |                     ++++++++++++++++"}, {"sha": "293028f5f68b12cd5f827b01de66b333404dd714", "filename": "tests/ui/error-codes/E0297.stderr", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ferror-codes%2FE0297.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ferror-codes%2FE0297.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0297.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,14 +1,9 @@\n-error[E0005]: refutable pattern in `for` loop binding: `None` not covered\n+error[E0005]: refutable pattern in `for` loop binding\n   --> $DIR/E0297.rs:4:9\n    |\n LL |     for Some(x) in xs {}\n    |         ^^^^^^^ pattern `None` not covered\n    |\n-note: `Option<i32>` defined here\n-  --> $SRC_DIR/core/src/option.rs:LL:COL\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Option<i32>`\n \n error: aborting due to previous error"}, {"sha": "49e7ab6082c820b69d988e837fc929f349dd3117", "filename": "tests/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,22 +1,13 @@\n-error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/feature-gate-exhaustive-patterns.rs:8:9\n    |\n LL |     let Ok(_x) = foo();\n    |         ^^^^^^ pattern `Err(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Result<u32, !>` defined here\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Result<u32, !>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let _x = if let Ok(_x) = foo() { _x } else { todo!() };\n-   |     +++++++++++                    +++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(_x) = foo() else { todo!() };\n    |                        ++++++++++++++++"}, {"sha": "49a82a6769dce5f6fe2c7524223dc0d90605089a", "filename": "tests/ui/for/for-loop-refutable-pattern-error-message.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&i32::MIN..=0_i32` and `&2_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in `for` loop binding\n   --> $DIR/for-loop-refutable-pattern-error-message.rs:2:9\n    |\n LL |     for &1 in [1].iter() {}"}, {"sha": "18bb63745d7a5f12354106e58fba0b624dc47569", "filename": "tests/ui/impl-trait/in-trait/issue-102140.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,11 +2,15 @@ error[E0277]: the trait bound `&dyn MyTrait: MyTrait` is not satisfied\n   --> $DIR/issue-102140.rs:23:22\n    |\n LL |         MyTrait::foo(&self)\n-   |         ------------ -^^^^\n-   |         |            |\n-   |         |            the trait `MyTrait` is not implemented for `&dyn MyTrait`\n-   |         |            help: consider removing the leading `&`-reference\n+   |         ------------ ^^^^^ the trait `MyTrait` is not implemented for `&dyn MyTrait`\n+   |         |\n    |         required by a bound introduced by this call\n+   |\n+help: consider removing the leading `&`-reference\n+   |\n+LL -         MyTrait::foo(&self)\n+LL +         MyTrait::foo(self)\n+   |\n \n error[E0277]: the trait bound `&dyn MyTrait: MyTrait` is not satisfied\n   --> $DIR/issue-102140.rs:23:9"}, {"sha": "23b266bef1d91d373d4519178c27330f2a559602", "filename": "tests/ui/issues/issue-15381.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fissues%2Fissue-15381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fissues%2Fissue-15381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-15381.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,7 +2,8 @@ fn main() {\n     let values: Vec<u8> = vec![1,2,3,4,5,6,7,8];\n \n     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n-        //~^ ERROR refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]` and 1 more not\n+        //~^ ERROR refutable pattern in `for` loop binding\n+        //~| patterns `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n         println!(\"y={}\", y);\n     }\n }"}, {"sha": "085958411ccb963ce490835fcaf5cc08e0077887", "filename": "tests/ui/issues/issue-15381.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fissues%2Fissue-15381.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fissues%2Fissue-15381.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-15381.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n+error[E0005]: refutable pattern in `for` loop binding\n   --> $DIR/issue-15381.rs:4:9\n    |\n LL |     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {"}, {"sha": "d600e934bd5775d2d543935f26df470c4e31caa6", "filename": "tests/ui/issues/issue-35241.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fissues%2Fissue-35241.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fissues%2Fissue-35241.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-35241.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,15 +2,15 @@ error[E0308]: mismatched types\n   --> $DIR/issue-35241.rs:3:20\n    |\n LL | struct Foo(u32);\n-   | ---------- fn(u32) -> Foo {Foo} defined here\n+   | ---------- `Foo` defines a struct constructor here, which should be called\n LL |\n LL | fn test() -> Foo { Foo }\n-   |              ---   ^^^ expected struct `Foo`, found fn item\n+   |              ---   ^^^ expected struct `Foo`, found struct constructor\n    |              |\n    |              expected `Foo` because of return type\n    |\n-   = note: expected struct `Foo`\n-             found fn item `fn(u32) -> Foo {Foo}`\n+   = note:          expected struct `Foo`\n+           found struct constructor `fn(u32) -> Foo {Foo}`\n help: use parentheses to construct this tuple struct\n    |\n LL | fn test() -> Foo { Foo(/* u32 */) }"}, {"sha": "aee2aa98a60c20a5e75257313d5e2e35e67089e1", "filename": "tests/ui/kindck/kindck-copy.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fkindck%2Fkindck-copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fkindck%2Fkindck-copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fkindck%2Fkindck-copy.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -4,25 +4,33 @@ error[E0277]: the trait bound `&'static mut isize: Copy` is not satisfied\n LL |     assert_copy::<&'static mut isize>();\n    |                   ^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `&'static mut isize`\n    |\n-   = help: the trait `Copy` is implemented for `isize`\n note: required by a bound in `assert_copy`\n   --> $DIR/kindck-copy.rs:5:18\n    |\n LL | fn assert_copy<T:Copy>() { }\n    |                  ^^^^ required by this bound in `assert_copy`\n+help: consider removing the leading `&`-reference\n+   |\n+LL -     assert_copy::<&'static mut isize>();\n+LL +     assert_copy::<isize>();\n+   |\n \n error[E0277]: the trait bound `&'a mut isize: Copy` is not satisfied\n   --> $DIR/kindck-copy.rs:28:19\n    |\n LL |     assert_copy::<&'a mut isize>();\n    |                   ^^^^^^^^^^^^^ the trait `Copy` is not implemented for `&'a mut isize`\n    |\n-   = help: the trait `Copy` is implemented for `isize`\n note: required by a bound in `assert_copy`\n   --> $DIR/kindck-copy.rs:5:18\n    |\n LL | fn assert_copy<T:Copy>() { }\n    |                  ^^^^ required by this bound in `assert_copy`\n+help: consider removing the leading `&`-reference\n+   |\n+LL -     assert_copy::<&'a mut isize>();\n+LL +     assert_copy::<isize>();\n+   |\n \n error[E0277]: the trait bound `Box<isize>: Copy` is not satisfied\n   --> $DIR/kindck-copy.rs:31:19"}, {"sha": "40c7c1d1067ffad535a6dc11dc2895325357f6e7", "filename": "tests/ui/never_type/exhaustive_patterns.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Either::B(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/exhaustive_patterns.rs:20:9\n    |\n LL |     let Either::A(()) = foo();\n@@ -7,13 +7,13 @@ LL |     let Either::A(()) = foo();\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Either<(), !>` defined here\n-  --> $DIR/exhaustive_patterns.rs:12:5\n+  --> $DIR/exhaustive_patterns.rs:10:6\n    |\n LL | enum Either<A, B> {\n-   |      ------\n+   |      ^^^^^^\n LL |     A(A),\n LL |     B(inner::Wrapper<B>),\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `Either<(), !>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "9428c125651ec2f718e315ee34965df117a27707", "filename": "tests/ui/not-panic/not-panic-safe-4.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fnot-panic%2Fnot-panic-safe-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fnot-panic%2Fnot-panic-safe-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnot-panic%2Fnot-panic-safe-4.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -12,6 +12,11 @@ note: required by a bound in `assert`\n    |\n LL | fn assert<T: UnwindSafe + ?Sized>() {}\n    |              ^^^^^^^^^^ required by this bound in `assert`\n+help: consider removing the leading `&`-reference\n+   |\n+LL -     assert::<&RefCell<i32>>();\n+LL +     assert::<RefCell<i32>>();\n+   |\n \n error[E0277]: the type `UnsafeCell<isize>` may contain interior mutability and a reference may not be safely transferrable across a catch_unwind boundary\n   --> $DIR/not-panic-safe-4.rs:9:14\n@@ -28,6 +33,11 @@ note: required by a bound in `assert`\n    |\n LL | fn assert<T: UnwindSafe + ?Sized>() {}\n    |              ^^^^^^^^^^ required by this bound in `assert`\n+help: consider removing the leading `&`-reference\n+   |\n+LL -     assert::<&RefCell<i32>>();\n+LL +     assert::<RefCell<i32>>();\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1b3c6482ce94fab0607258c3e24d96aa8caf48dc", "filename": "tests/ui/not-panic/not-panic-safe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fnot-panic%2Fnot-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fnot-panic%2Fnot-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnot-panic%2Fnot-panic-safe.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -5,6 +5,6 @@ use std::panic::UnwindSafe;\n fn assert<T: UnwindSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<&mut i32>();\n-    //~^ ERROR the type `&mut i32` may not be safely transferred across an unwind boundary\n+    assert::<&mut &mut &i32>();\n+    //~^ ERROR the type `&mut &mut &i32` may not be safely transferred across an unwind boundary\n }"}, {"sha": "37a6aee390669c70536d0791887bf53921bc4f55", "filename": "tests/ui/not-panic/not-panic-safe.stderr", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fnot-panic%2Fnot-panic-safe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fnot-panic%2Fnot-panic-safe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnot-panic%2Fnot-panic-safe.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,19 +1,21 @@\n-error[E0277]: the type `&mut i32` may not be safely transferred across an unwind boundary\n+error[E0277]: the type `&mut &mut &i32` may not be safely transferred across an unwind boundary\n   --> $DIR/not-panic-safe.rs:8:14\n    |\n-LL |     assert::<&mut i32>();\n-   |              -^^^^^^^\n-   |              |\n-   |              `&mut i32` may not be safely transferred across an unwind boundary\n-   |              help: consider removing the leading `&`-reference\n+LL |     assert::<&mut &mut &i32>();\n+   |              ^^^^^^^^^^^^^^ `&mut &mut &i32` may not be safely transferred across an unwind boundary\n    |\n-   = help: the trait `UnwindSafe` is not implemented for `&mut i32`\n-   = note: `UnwindSafe` is implemented for `&i32`, but not for `&mut i32`\n+   = help: the trait `UnwindSafe` is not implemented for `&mut &mut &i32`\n+   = note: `UnwindSafe` is implemented for `&&mut &i32`, but not for `&mut &mut &i32`\n note: required by a bound in `assert`\n   --> $DIR/not-panic-safe.rs:5:14\n    |\n LL | fn assert<T: UnwindSafe + ?Sized>() {}\n    |              ^^^^^^^^^^ required by this bound in `assert`\n+help: consider removing 2 leading `&`-references\n+   |\n+LL -     assert::<&mut &mut &i32>();\n+LL +     assert::<&i32>();\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "4adcf4feee90d6dfbe705a71497b30f27d5090ae", "filename": "tests/ui/or-patterns/issue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:2:10\n    |\n LL |     let (0 | (1 | 2)) = 0;"}, {"sha": "82414f0418bb21e0dc8795f8e70fa570d024a2ce", "filename": "tests/ui/pattern/usefulness/issue-31561.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -6,5 +6,6 @@ enum Thing {\n \n fn main() {\n     let Thing::Foo(y) = Thing::Foo(1);\n-    //~^ ERROR refutable pattern in local binding: `Thing::Bar` and `Thing::Baz` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `Thing::Bar` and `Thing::Baz` not covered\n }"}, {"sha": "5367de5e513c739a42a2f2ea98f30c658565be39", "filename": "tests/ui/pattern/usefulness/issue-31561.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Thing::Bar` and `Thing::Baz` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/issue-31561.rs:8:9\n    |\n LL |     let Thing::Foo(y) = Thing::Foo(1);\n@@ -7,21 +7,17 @@ LL |     let Thing::Foo(y) = Thing::Foo(1);\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Thing` defined here\n-  --> $DIR/issue-31561.rs:3:5\n+  --> $DIR/issue-31561.rs:1:6\n    |\n LL | enum Thing {\n-   |      -----\n+   |      ^^^^^\n LL |     Foo(u8),\n LL |     Bar,\n-   |     ^^^ not covered\n+   |     --- not covered\n LL |     Baz\n-   |     ^^^ not covered\n+   |     --- not covered\n    = note: the matched value is of type `Thing`\n-help: you might want to use `if let` to ignore the variants that aren't matched\n-   |\n-LL |     let y = if let Thing::Foo(y) = Thing::Foo(1) { y } else { todo!() };\n-   |     ++++++++++                                   ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variants that aren't matched\n+help: you might want to use `let else` to handle the variants that aren't matched\n    |\n LL |     let Thing::Foo(y) = Thing::Foo(1) else { todo!() };\n    |                                       ++++++++++++++++"}, {"sha": "5145f769075d9b86403e3cf1f340e9888e156466", "filename": "tests/ui/pattern/usefulness/non-exhaustive-defined-here.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -15,9 +15,6 @@ enum E {\n     //~^ NOTE `E` defined here\n     //~| NOTE `E` defined here\n     //~| NOTE `E` defined here\n-    //~| NOTE `E` defined here\n-    //~| NOTE `E` defined here\n-    //~| NOTE `E` defined here\n     //~| NOTE  not covered\n     //~| NOTE  not covered\n     //~| NOTE  not covered\n@@ -41,37 +38,41 @@ fn by_val(e: E) {\n         E::A => {}\n     }\n \n-    let E::A = e; //~ ERROR refutable pattern in local binding: `E::B` and `E::C` not covered\n-    //~^ NOTE patterns `E::B` and `E::C` not covered\n+    let E::A = e;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `E::B` and `E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `E`\n }\n \n fn by_ref_once(e: &E) {\n-    match e { //~ ERROR non-exhaustive patterns: `&E::B` and `&E::C` not covered\n-    //~^ NOTE patterns `&E::B` and `&E::C` not covered\n+    match e {\n+    //~^ ERROR non-exhaustive patterns\n+    //~| patterns `&E::B` and `&E::C` not covered\n     //~| NOTE the matched value is of type `&E`\n         E::A => {}\n     }\n \n-    let E::A = e; //~ ERROR refutable pattern in local binding: `&E::B` and `&E::C` not covered\n-    //~^ NOTE patterns `&E::B` and `&E::C` not covered\n+    let E::A = e;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `&E::B` and `&E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `&E`\n }\n \n fn by_ref_thrice(e: & &mut &E) {\n-    match e { //~ ERROR non-exhaustive patterns: `&&mut &E::B` and `&&mut &E::C` not covered\n-    //~^ NOTE patterns `&&mut &E::B` and `&&mut &E::C` not covered\n+    match e {\n+    //~^ ERROR non-exhaustive patterns\n+    //~| patterns `&&mut &E::B` and `&&mut &E::C` not covered\n     //~| NOTE the matched value is of type `&&mut &E`\n         E::A => {}\n     }\n \n     let E::A = e;\n-    //~^ ERROR refutable pattern in local binding: `&&mut &E::B` and `&&mut &E::C` not covered\n-    //~| NOTE patterns `&&mut &E::B` and `&&mut &E::C` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `&&mut &E::B` and `&&mut &E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `&&mut &E`\n@@ -83,20 +84,21 @@ enum Opt {\n     Some(u8),\n     None,\n     //~^ NOTE `Opt` defined here\n-    //~| NOTE `Opt` defined here\n     //~| NOTE not covered\n     //~| NOTE not covered\n }\n \n fn ref_pat(e: Opt) {\n-    match e {//~ ERROR non-exhaustive patterns: `Opt::None` not covered\n-        //~^ NOTE pattern `Opt::None` not covered\n+    match e {\n+        //~^ ERROR non-exhaustive patterns\n+        //~| pattern `Opt::None` not covered\n         //~| NOTE the matched value is of type `Opt`\n         Opt::Some(ref _x) => {}\n     }\n \n-    let Opt::Some(ref _x) = e; //~ ERROR refutable pattern in local binding: `Opt::None` not covered\n-    //~^ NOTE the matched value is of type `Opt`\n+    let Opt::Some(ref _x) = e;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| NOTE the matched value is of type `Opt`\n     //~| NOTE pattern `Opt::None` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "769d4070fb587fb56d31f2c2a74f775584bae7a0", "filename": "tests/ui/pattern/usefulness/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,5 +1,5 @@\n error[E0004]: non-exhaustive patterns: `E::B` and `E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:38:11\n+  --> $DIR/non-exhaustive-defined-here.rs:35:11\n    |\n LL |     match e1 {\n    |           ^^ patterns `E::B` and `E::C` not covered\n@@ -22,33 +22,33 @@ LL ~         E::A => {}\n LL +         E::B | E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `E::B` and `E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:44:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:41:9\n    |\n LL |     let E::A = e;\n    |         ^^^^ patterns `E::B` and `E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `E` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+  --> $DIR/non-exhaustive-defined-here.rs:6:6\n    |\n LL | enum E {\n-   |      -\n+   |      ^\n ...\n LL |     B,\n-   |     ^ not covered\n+   |     - not covered\n ...\n LL |     C\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n LL |     if let E::A = e { todo!() }\n    |     ++              ~~~~~~~~~~~\n \n error[E0004]: non-exhaustive patterns: `&E::B` and `&E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:52:11\n+  --> $DIR/non-exhaustive-defined-here.rs:50:11\n    |\n LL |     match e {\n    |           ^ patterns `&E::B` and `&E::C` not covered\n@@ -71,25 +71,25 @@ LL ~         E::A => {}\n LL +         &E::B | &E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `&E::B` and `&E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:58:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:57:9\n    |\n LL |     let E::A = e;\n    |         ^^^^ patterns `&E::B` and `&E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `E` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+  --> $DIR/non-exhaustive-defined-here.rs:6:6\n    |\n LL | enum E {\n-   |      -\n+   |      ^\n ...\n LL |     B,\n-   |     ^ not covered\n+   |     - not covered\n ...\n LL |     C\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `&E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n@@ -120,25 +120,25 @@ LL ~         E::A => {}\n LL +         &&mut &E::B | &&mut &E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `&&mut &E::B` and `&&mut &E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:72:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:73:9\n    |\n LL |     let E::A = e;\n    |         ^^^^ patterns `&&mut &E::B` and `&&mut &E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `E` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+  --> $DIR/non-exhaustive-defined-here.rs:6:6\n    |\n LL | enum E {\n-   |      -\n+   |      ^\n ...\n LL |     B,\n-   |     ^ not covered\n+   |     - not covered\n ...\n LL |     C\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `&&mut &E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n@@ -152,7 +152,7 @@ LL |     match e {\n    |           ^ pattern `Opt::None` not covered\n    |\n note: `Opt` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:84:5\n+  --> $DIR/non-exhaustive-defined-here.rs:85:5\n    |\n LL | enum Opt {\n    |      ---\n@@ -166,28 +166,24 @@ LL ~         Opt::Some(ref _x) => {}\n LL +         Opt::None => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `Opt::None` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:98:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:99:9\n    |\n LL |     let Opt::Some(ref _x) = e;\n    |         ^^^^^^^^^^^^^^^^^ pattern `Opt::None` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Opt` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:84:5\n+  --> $DIR/non-exhaustive-defined-here.rs:81:6\n    |\n LL | enum Opt {\n-   |      ---\n+   |      ^^^\n ...\n LL |     None,\n-   |     ^^^^ not covered\n+   |     ---- not covered\n    = note: the matched value is of type `Opt`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let _x = if let Opt::Some(ref _x) = e { _x } else { todo!() };\n-   |     +++++++++++                           +++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Opt::Some(ref _x) = e else { todo!() };\n    |                               ++++++++++++++++"}, {"sha": "7a3e991d59317d3e6fcc3f8d5e93c96cff67441f", "filename": "tests/ui/pattern/usefulness/refutable-pattern-errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,7 +1,9 @@\n fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n-//~^ ERROR refutable pattern in function argument: `(_, _)` not covered\n+//~^ ERROR refutable pattern in function argument\n+//~| `(_, _)` not covered\n \n fn main() {\n     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-    //~^ ERROR refutable pattern in local binding: `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered\n }"}, {"sha": "c518de47740dd89d5c9c30fdf2ce02c02fe0170f", "filename": "tests/ui/pattern/usefulness/refutable-pattern-errors.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,13 +1,13 @@\n-error[E0005]: refutable pattern in function argument: `(_, _)` not covered\n+error[E0005]: refutable pattern in function argument\n   --> $DIR/refutable-pattern-errors.rs:1:9\n    |\n LL | fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n    |         ^^^^^^^^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n    |\n    = note: the matched value is of type `(isize, (Option<isize>, isize))`\n \n-error[E0005]: refutable pattern in local binding: `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered\n-  --> $DIR/refutable-pattern-errors.rs:5:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/refutable-pattern-errors.rs:6:9\n    |\n LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n    |         ^^^^^^^^^^^^^^^^^^^^^ patterns `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered"}, {"sha": "17dc38ab25d92ff229b805d6e19e73ce074f6203", "filename": "tests/ui/pattern/usefulness/refutable-pattern-in-fn-arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,5 +1,6 @@\n fn main() {\n     let f = |3: isize| println!(\"hello\");\n-    //~^ ERROR refutable pattern in function argument: `_` not covered\n+    //~^ ERROR refutable pattern in function argument\n+    //~| `_` not covered\n     f(4);\n }"}, {"sha": "55f0b2319fb7fc4ce6eec9d5883efbd69de8d0b1", "filename": "tests/ui/pattern/usefulness/refutable-pattern-in-fn-arg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in function argument: `_` not covered\n+error[E0005]: refutable pattern in function argument\n   --> $DIR/refutable-pattern-in-fn-arg.rs:2:14\n    |\n LL |     let f = |3: isize| println!(\"hello\");"}, {"sha": "5826a18b5718b781c7bc364676aa96f9de4a7515", "filename": "tests/ui/pin-macro/cant_access_internals.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpin-macro%2Fcant_access_internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpin-macro%2Fcant_access_internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpin-macro%2Fcant_access_internals.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,5 +1,4 @@\n // edition:2018\n-#![feature(pin_macro)]\n \n use core::{\n     marker::PhantomPinned,"}, {"sha": "d43027657f0462031f43fad7c652113179787f10", "filename": "tests/ui/pin-macro/cant_access_internals.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpin-macro%2Fcant_access_internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpin-macro%2Fcant_access_internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpin-macro%2Fcant_access_internals.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: use of unstable library feature 'unsafe_pin_internals'\n-  --> $DIR/cant_access_internals.rs:12:15\n+  --> $DIR/cant_access_internals.rs:11:15\n    |\n LL |     mem::take(phantom_pinned.pointer);\n    |               ^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "59774bc753dc9e6e8e8b9da13168d3aba728b91c", "filename": "tests/ui/pin-macro/lifetime_errors_on_promotion_misusage.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,5 +1,4 @@\n // edition:2018\n-#![feature(pin_macro)]\n \n use core::{\n     convert::identity,"}, {"sha": "4ecc6370d3caad2a64cca22f979853187c39c7e1", "filename": "tests/ui/pin-macro/lifetime_errors_on_promotion_misusage.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,5 +1,5 @@\n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/lifetime_errors_on_promotion_misusage.rs:12:35\n+  --> $DIR/lifetime_errors_on_promotion_misusage.rs:11:35\n    |\n LL |     let phantom_pinned = identity(pin!(PhantomPinned));\n    |                                   ^^^^^^^^^^^^^^^^^^^ - temporary value is freed at the end of this statement\n@@ -13,7 +13,7 @@ LL |     stuff(phantom_pinned)\n    = note: this error originates in the macro `pin` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/lifetime_errors_on_promotion_misusage.rs:19:30\n+  --> $DIR/lifetime_errors_on_promotion_misusage.rs:18:30\n    |\n LL |     let phantom_pinned = {\n    |         -------------- borrow later stored here"}, {"sha": "1b4d80d90571c31ac7b30f341799b060f1db71b1", "filename": "tests/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,22 +1,13 @@\n-error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/recursive-types-are-not-uninhabited.rs:6:9\n    |\n LL |     let Ok(x) = res;\n    |         ^^^^^ pattern `Err(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Result<u32, &R<'_>>` defined here\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Result<u32, &R<'_>>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let x = if let Ok(x) = res { x } else { todo!() };\n-   |     ++++++++++                 ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(x) = res else { todo!() };\n    |                     ++++++++++++++++"}, {"sha": "a24fe4d23ea2547e63c99936b3408afeb0db1a53", "filename": "tests/ui/resolve/privacy-enum-ctor.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -264,15 +264,15 @@ error[E0308]: mismatched types\n   --> $DIR/privacy-enum-ctor.rs:27:20\n    |\n LL |             Fn(u8),\n-   |             -- fn(u8) -> Z {Z::Fn} defined here\n+   |             -- `Fn` defines an enum variant constructor here, which should be called\n ...\n LL |         let _: Z = Z::Fn;\n-   |                -   ^^^^^ expected enum `Z`, found fn item\n+   |                -   ^^^^^ expected enum `Z`, found enum constructor\n    |                |\n    |                expected due to this\n    |\n-   = note: expected enum `Z`\n-           found fn item `fn(u8) -> Z {Z::Fn}`\n+   = note:          expected enum `Z`\n+           found enum constructor `fn(u8) -> Z {Z::Fn}`\n help: use parentheses to construct this tuple variant\n    |\n LL |         let _: Z = Z::Fn(/* u8 */);\n@@ -305,15 +305,15 @@ error[E0308]: mismatched types\n   --> $DIR/privacy-enum-ctor.rs:43:16\n    |\n LL |         Fn(u8),\n-   |         -- fn(u8) -> E {E::Fn} defined here\n+   |         -- `Fn` defines an enum variant constructor here, which should be called\n ...\n LL |     let _: E = m::E::Fn;\n-   |            -   ^^^^^^^^ expected enum `E`, found fn item\n+   |            -   ^^^^^^^^ expected enum `E`, found enum constructor\n    |            |\n    |            expected due to this\n    |\n-   = note: expected enum `E`\n-           found fn item `fn(u8) -> E {E::Fn}`\n+   = note:          expected enum `E`\n+           found enum constructor `fn(u8) -> E {E::Fn}`\n help: use parentheses to construct this tuple variant\n    |\n LL |     let _: E = m::E::Fn(/* u8 */);\n@@ -346,15 +346,15 @@ error[E0308]: mismatched types\n   --> $DIR/privacy-enum-ctor.rs:51:16\n    |\n LL |         Fn(u8),\n-   |         -- fn(u8) -> E {E::Fn} defined here\n+   |         -- `Fn` defines an enum variant constructor here, which should be called\n ...\n LL |     let _: E = E::Fn;\n-   |            -   ^^^^^ expected enum `E`, found fn item\n+   |            -   ^^^^^ expected enum `E`, found enum constructor\n    |            |\n    |            expected due to this\n    |\n-   = note: expected enum `E`\n-           found fn item `fn(u8) -> E {E::Fn}`\n+   = note:          expected enum `E`\n+           found enum constructor `fn(u8) -> E {E::Fn}`\n help: use parentheses to construct this tuple variant\n    |\n LL |     let _: E = E::Fn(/* u8 */);"}, {"sha": "15f08486f0f0ebe2c921ea9333d62d486b7807c2", "filename": "tests/ui/suggestions/const-pat-non-exaustive-let-new-var.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,7 +1,8 @@\n fn main() {\n     let A = 3;\n-    //~^ ERROR refutable pattern in local binding: `i32::MIN..=1_i32` and\n-    //~| interpreted as a constant pattern, not a new variable\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `i32::MIN..=1_i32` and `3_i32..=i32::MAX` not covered\n+    //~| missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n     //~| HELP introduce a variable instead\n     //~| SUGGESTION a_var\n "}, {"sha": "1c1cab25fbfaf83250add6707af512d0952b0a51", "filename": "tests/ui/suggestions/const-pat-non-exaustive-let-new-var.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,10 +1,11 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=1_i32` and `3_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-pat-non-exaustive-let-new-var.rs:2:9\n    |\n LL |     let A = 3;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `i32::MIN..=1_i32` and `3_i32..=i32::MAX` not covered\n+   |         missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `a_var`\n ...\n LL |     const A: i32 = 2;"}, {"sha": "4cbcd31fa5ec1f6e062f15791dedcc4e2fd3916b", "filename": "tests/ui/suggestions/fn-or-tuple-struct-without-args.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:29:20\n    |\n LL | fn foo(a: usize, b: usize) -> usize { a }\n-   | ----------------------------------- fn(usize, usize) -> usize {foo} defined here\n+   | ----------------------------------- function `foo` defined here\n ...\n LL |     let _: usize = foo;\n    |            -----   ^^^ expected `usize`, found fn item\n@@ -20,15 +20,15 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:30:16\n    |\n LL | struct S(usize, usize);\n-   | -------- fn(usize, usize) -> S {S} defined here\n+   | -------- `S` defines a struct constructor here, which should be called\n ...\n LL |     let _: S = S;\n-   |            -   ^ expected struct `S`, found fn item\n+   |            -   ^ expected struct `S`, found struct constructor\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `S`\n-             found fn item `fn(usize, usize) -> S {S}`\n+   = note:          expected struct `S`\n+           found struct constructor `fn(usize, usize) -> S {S}`\n help: use parentheses to construct this tuple struct\n    |\n LL |     let _: S = S(/* usize */, /* usize */);\n@@ -38,7 +38,7 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:31:20\n    |\n LL | fn bar() -> usize { 42 }\n-   | ----------------- fn() -> usize {bar} defined here\n+   | ----------------- function `bar` defined here\n ...\n LL |     let _: usize = bar;\n    |            -----   ^^^ expected `usize`, found fn item\n@@ -56,15 +56,15 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:32:16\n    |\n LL | struct V();\n-   | -------- fn() -> V {V} defined here\n+   | -------- `V` defines a struct constructor here, which should be called\n ...\n LL |     let _: V = V;\n-   |            -   ^ expected struct `V`, found fn item\n+   |            -   ^ expected struct `V`, found struct constructor\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `V`\n-             found fn item `fn() -> V {V}`\n+   = note:          expected struct `V`\n+           found struct constructor `fn() -> V {V}`\n help: use parentheses to construct this tuple struct\n    |\n LL |     let _: V = V();\n@@ -74,7 +74,7 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:33:20\n    |\n LL |     fn baz(x: usize, y: usize) -> usize { x }\n-   |     ----------------------------------- fn(usize, usize) -> usize {<_ as T>::baz} defined here\n+   |     ----------------------------------- associated function `baz` defined here\n ...\n LL |     let _: usize = T::baz;\n    |            -----   ^^^^^^ expected `usize`, found fn item\n@@ -92,7 +92,7 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:34:20\n    |\n LL |     fn bat(x: usize) -> usize { 42 }\n-   |     ------------------------- fn(usize) -> usize {<_ as T>::bat} defined here\n+   |     ------------------------- associated function `bat` defined here\n ...\n LL |     let _: usize = T::bat;\n    |            -----   ^^^^^^ expected `usize`, found fn item\n@@ -110,15 +110,15 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:35:16\n    |\n LL |     A(usize),\n-   |     - fn(usize) -> E {E::A} defined here\n+   |     - `A` defines an enum variant constructor here, which should be called\n ...\n LL |     let _: E = E::A;\n-   |            -   ^^^^ expected enum `E`, found fn item\n+   |            -   ^^^^ expected enum `E`, found enum constructor\n    |            |\n    |            expected due to this\n    |\n-   = note: expected enum `E`\n-           found fn item `fn(usize) -> E {E::A}`\n+   = note:          expected enum `E`\n+           found enum constructor `fn(usize) -> E {E::A}`\n help: use parentheses to construct this tuple variant\n    |\n LL |     let _: E = E::A(/* usize */);\n@@ -134,7 +134,7 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:37:20\n    |\n LL |     fn baz(x: usize, y: usize) -> usize { x }\n-   |     ----------------------------------- fn(usize, usize) -> usize {<X as T>::baz} defined here\n+   |     ----------------------------------- associated function `baz` defined here\n ...\n LL |     let _: usize = X::baz;\n    |            -----   ^^^^^^ expected `usize`, found fn item\n@@ -152,7 +152,7 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:38:20\n    |\n LL |     fn bat(x: usize) -> usize { 42 }\n-   |     ------------------------- fn(usize) -> usize {<X as T>::bat} defined here\n+   |     ------------------------- associated function `bat` defined here\n ...\n LL |     let _: usize = X::bat;\n    |            -----   ^^^^^^ expected `usize`, found fn item\n@@ -170,7 +170,7 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:39:20\n    |\n LL |     fn bax(x: usize) -> usize { 42 }\n-   |     ------------------------- fn(usize) -> usize {<X as T>::bax} defined here\n+   |     ------------------------- associated function `bax` defined here\n ...\n LL |     let _: usize = X::bax;\n    |            -----   ^^^^^^ expected `usize`, found fn item\n@@ -188,7 +188,7 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:40:20\n    |\n LL |     fn bach(x: usize) -> usize;\n-   |     --------------------------- fn(usize) -> usize {<X as T>::bach} defined here\n+   |     --------------------------- associated function `bach` defined here\n ...\n LL |     let _: usize = X::bach;\n    |            -----   ^^^^^^^ expected `usize`, found fn item\n@@ -206,7 +206,7 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:41:20\n    |\n LL |     fn ban(&self) -> usize { 42 }\n-   |     ---------------------- for<'a> fn(&'a X) -> usize {<X as T>::ban} defined here\n+   |     ---------------------- associated function `ban` defined here\n ...\n LL |     let _: usize = X::ban;\n    |            -----   ^^^^^^ expected `usize`, found fn item\n@@ -224,7 +224,7 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:42:20\n    |\n LL |     fn bal(&self) -> usize;\n-   |     ----------------------- for<'a> fn(&'a X) -> usize {<X as T>::bal} defined here\n+   |     ----------------------- associated function `bal` defined here\n ...\n LL |     let _: usize = X::bal;\n    |            -----   ^^^^^^ expected `usize`, found fn item"}, {"sha": "387770535f689b8a7f3c7481cf6779f046fcac96", "filename": "tests/ui/suggestions/suggest-remove-refs-1.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-1.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,13 +2,15 @@ error[E0277]: `&Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator\n   --> $DIR/suggest-remove-refs-1.rs:6:19\n    |\n LL |     for (i, _) in &v.iter().enumerate() {\n-   |                   -^^^^^^^^^^^^^^^^^^^^\n-   |                   |\n-   |                   `&Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator\n-   |                   help: consider removing the leading `&`-reference\n+   |                   ^^^^^^^^^^^^^^^^^^^^^ `&Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&Enumerate<std::slice::Iter<'_, {integer}>>`\n    = note: required for `&Enumerate<std::slice::Iter<'_, {integer}>>` to implement `IntoIterator`\n+help: consider removing the leading `&`-reference\n+   |\n+LL -     for (i, _) in &v.iter().enumerate() {\n+LL +     for (i, _) in v.iter().enumerate() {\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "1632b2abb2f87fb76f8f2c5fa6e63e63304401b4", "filename": "tests/ui/suggestions/suggest-remove-refs-2.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-2.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,13 +2,15 @@ error[E0277]: `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterat\n   --> $DIR/suggest-remove-refs-2.rs:6:19\n    |\n LL |     for (i, _) in & & & & &v.iter().enumerate() {\n-   |                   ---------^^^^^^^^^^^^^^^^^^^^\n-   |                   |\n-   |                   `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator\n-   |                   help: consider removing 5 leading `&`-references\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>`\n    = note: required for `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>` to implement `IntoIterator`\n+help: consider removing 5 leading `&`-references\n+   |\n+LL -     for (i, _) in & & & & &v.iter().enumerate() {\n+LL +     for (i, _) in v.iter().enumerate() {\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "7bf421a7729dfb88253c61ffa0271ad04599a987", "filename": "tests/ui/suggestions/suggest-remove-refs-3.stderr", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-3.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,18 +1,20 @@\n error[E0277]: `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator\n   --> $DIR/suggest-remove-refs-3.rs:6:19\n    |\n-LL |        for (i, _) in & & &\n-   |  ____________________^\n-   | | ___________________|\n-   | ||\n-LL | ||         & &v\n-   | ||___________- help: consider removing 5 leading `&`-references\n-LL | |          .iter()\n-LL | |          .enumerate() {\n-   | |_____________________^ `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator\n+LL |       for (i, _) in & & &\n+   |  ___________________^\n+LL | |         & &v\n+LL | |         .iter()\n+LL | |         .enumerate() {\n+   | |____________________^ `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>`\n    = note: required for `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>` to implement `IntoIterator`\n+help: consider removing 5 leading `&`-references\n+   |\n+LL -     for (i, _) in & & &\n+LL +     for (i, _) in v\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "dd63d215972432be8942ee181822d03864902062", "filename": "tests/ui/suggestions/suggest-remove-refs-4.fixed", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-4.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-4.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-4.fixed?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -0,0 +1,5 @@\n+// run-rustfix\n+fn main() {\n+    let foo = [1,2,3].iter();\n+    for _i in foo {} //~ ERROR E0277\n+}"}, {"sha": "3c3d9b1b3f981811151e07af3c111ed85a437229", "filename": "tests/ui/suggestions/suggest-remove-refs-4.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-4.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -0,0 +1,5 @@\n+// run-rustfix\n+fn main() {\n+    let foo = &[1,2,3].iter();\n+    for _i in &foo {} //~ ERROR E0277\n+}"}, {"sha": "e4ad17e06716f64dd703377ab0e99f07a7db8da5", "filename": "tests/ui/suggestions/suggest-remove-refs-4.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-4.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: `&&std::slice::Iter<'_, {integer}>` is not an iterator\n+  --> $DIR/suggest-remove-refs-4.rs:4:15\n+   |\n+LL |     for _i in &foo {}\n+   |               ^^^^ `&&std::slice::Iter<'_, {integer}>` is not an iterator\n+   |\n+   = help: the trait `Iterator` is not implemented for `&&std::slice::Iter<'_, {integer}>`\n+   = note: required for `&&std::slice::Iter<'_, {integer}>` to implement `IntoIterator`\n+help: consider removing 2 leading `&`-references\n+   |\n+LL ~     let foo = [1,2,3].iter();\n+LL ~     for _i in foo {}\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9f59f9c199a331b8a8a212dcf16fe6669f3d5a7c", "filename": "tests/ui/suggestions/suggest-remove-refs-5.fixed", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-5.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-5.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-5.fixed?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+fn main() {\n+    let v = &mut Vec::<i32>::new();\n+    for _ in v {} //~ ERROR E0277\n+\n+    let v = &mut [1u8];\n+    for _ in v {} //~ ERROR E0277\n+}"}, {"sha": "d56aa0c9ca47965601cdd0e6eb727e98aad02e18", "filename": "tests/ui/suggestions/suggest-remove-refs-5.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-5.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+fn main() {\n+    let v = &mut &mut Vec::<i32>::new();\n+    for _ in &mut &mut v {} //~ ERROR E0277\n+\n+    let v = &mut &mut [1u8];\n+    for _ in &mut v {} //~ ERROR E0277\n+}"}, {"sha": "7de84d6122b58f094ec2f72e8744ce7d4f6192b3", "filename": "tests/ui/suggestions/suggest-remove-refs-5.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-refs-5.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -0,0 +1,37 @@\n+error[E0277]: `Vec<i32>` is not an iterator\n+  --> $DIR/suggest-remove-refs-5.rs:4:14\n+   |\n+LL |     for _ in &mut &mut v {}\n+   |              ^^^^^^^^^^^ `Vec<i32>` is not an iterator; try calling `.into_iter()` or `.iter()`\n+   |\n+   = help: the trait `Iterator` is not implemented for `Vec<i32>`\n+   = note: required for `&mut Vec<i32>` to implement `Iterator`\n+   = note: 3 redundant requirements hidden\n+   = note: required for `&mut &mut &mut &mut Vec<i32>` to implement `Iterator`\n+   = note: required for `&mut &mut &mut &mut Vec<i32>` to implement `IntoIterator`\n+help: consider removing 3 leading `&`-references\n+   |\n+LL ~     let v = &mut Vec::<i32>::new();\n+LL ~     for _ in v {}\n+   |\n+\n+error[E0277]: `[u8; 1]` is not an iterator\n+  --> $DIR/suggest-remove-refs-5.rs:7:14\n+   |\n+LL |     for _ in &mut v {}\n+   |              ^^^^^^ `[u8; 1]` is not an iterator; try calling `.into_iter()` or `.iter()`\n+   |\n+   = help: the trait `Iterator` is not implemented for `[u8; 1]`\n+   = note: required for `&mut [u8; 1]` to implement `Iterator`\n+   = note: 2 redundant requirements hidden\n+   = note: required for `&mut &mut &mut [u8; 1]` to implement `Iterator`\n+   = note: required for `&mut &mut &mut [u8; 1]` to implement `IntoIterator`\n+help: consider removing 2 leading `&`-references\n+   |\n+LL ~     let v = &mut [1u8];\n+LL ~     for _ in v {}\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a631dbb39fb8fa59ebfb9cf13e120d8f7b463bb0", "filename": "tests/ui/typeck/issue-57404.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-57404.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-57404.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-57404.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -2,14 +2,17 @@ error[E0277]: `&mut ()` is not a tuple\n   --> $DIR/issue-57404.rs:6:41\n    |\n LL |     handlers.unwrap().as_mut().call_mut(&mut ());\n-   |                                -------- -^^^^^^\n-   |                                |        |\n-   |                                |        the trait `Tuple` is not implemented for `&mut ()`\n-   |                                |        help: consider removing the leading `&`-reference\n+   |                                -------- ^^^^^^^ the trait `Tuple` is not implemented for `&mut ()`\n+   |                                |\n    |                                required by a bound introduced by this call\n    |\n note: required by a bound in `call_mut`\n   --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n+help: consider removing the leading `&`-reference\n+   |\n+LL -     handlers.unwrap().as_mut().call_mut(&mut ());\n+LL +     handlers.unwrap().as_mut().call_mut(());\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "96b3f8dab8da798350fc309543350bd5107bb50b", "filename": "tests/ui/typeck/issue-87181/empty-tuple-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -10,5 +10,5 @@ impl Foo {\n fn main() {\n     let thing = Bar { bar: Foo };\n     thing.bar.foo();\n-    //~^ ERROR no method named `foo` found for fn item `fn() -> Foo {Foo}` in the current scope [E0599]\n+    //~^ ERROR no method named `foo` found for struct constructor `fn() -> Foo {Foo}` in the current scope [E0599]\n }"}, {"sha": "f0ca49e6d1e3ec4cd185099a15a4e493ca536973", "filename": "tests/ui/typeck/issue-87181/empty-tuple-method.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: no method named `foo` found for fn item `fn() -> Foo {Foo}` in the current scope\n+error[E0599]: no method named `foo` found for struct constructor `fn() -> Foo {Foo}` in the current scope\n   --> $DIR/empty-tuple-method.rs:12:15\n    |\n LL |     thing.bar.foo();"}, {"sha": "ed01656ce72a319ee3c7a66efaff150538deb795", "filename": "tests/ui/typeck/issue-87181/enum-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -12,5 +12,5 @@ impl Foo {\n fn main() {\n     let thing = Bar { bar: Foo::Tup };\n     thing.bar.foo();\n-    //~^ ERROR no method named `foo` found for fn item `fn() -> Foo {Foo::Tup}` in the current scope [E0599]\n+    //~^ ERROR no method named `foo` found for enum constructor `fn() -> Foo {Foo::Tup}` in the current scope [E0599]\n }"}, {"sha": "d313a887abd986245ec22abe1830d5f8a6632396", "filename": "tests/ui/typeck/issue-87181/enum-variant.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: no method named `foo` found for fn item `fn() -> Foo {Foo::Tup}` in the current scope\n+error[E0599]: no method named `foo` found for enum constructor `fn() -> Foo {Foo::Tup}` in the current scope\n   --> $DIR/enum-variant.rs:14:15\n    |\n LL |     thing.bar.foo();"}, {"sha": "6310984438c695227f840cce130ae899a34fcc11", "filename": "tests/ui/typeck/issue-87181/tuple-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -10,5 +10,5 @@ impl Foo {\n fn main() {\n     let thing = Bar { bar: Foo };\n     thing.bar.foo();\n-    //~^ ERROR no method named `foo` found for fn item `fn(u8, i32) -> Foo {Foo}` in the current scope [E0599]\n+    //~^ ERROR no method named `foo` found for struct constructor `fn(u8, i32) -> Foo {Foo}` in the current scope [E0599]\n }"}, {"sha": "de3dc15a54b12449e2f2226dae020d3bc3926184", "filename": "tests/ui/typeck/issue-87181/tuple-method.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: no method named `foo` found for fn item `fn(u8, i32) -> Foo {Foo}` in the current scope\n+error[E0599]: no method named `foo` found for struct constructor `fn(u8, i32) -> Foo {Foo}` in the current scope\n   --> $DIR/tuple-method.rs:12:15\n    |\n LL |     thing.bar.foo();"}, {"sha": "547cffffa2ee331e03c3afc475db691f6f6ec5d2", "filename": "tests/ui/typeck/issue-96738.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-96738.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Ftypeck%2Fissue-96738.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-96738.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: no method named `nonexistent_method` found for fn item `fn(_) -> Option<_> {Option::<_>::Some}` in the current scope\n+error[E0599]: no method named `nonexistent_method` found for enum constructor `fn(_) -> Option<_> {Option::<_>::Some}` in the current scope\n   --> $DIR/issue-96738.rs:2:10\n    |\n LL |     Some.nonexistent_method();"}, {"sha": "4b001aca2d1c7c4c7832514f9ca8fd2524db96fb", "filename": "tests/ui/uninhabited/uninhabited-irrefutable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -24,5 +24,7 @@ enum Foo {\n \n fn main() {\n     let x: Foo = Foo::D(123, 456);\n-    let Foo::D(_y, _z) = x; //~ ERROR refutable pattern in local binding: `Foo::A(_)` not covered\n+    let Foo::D(_y, _z) = x;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `Foo::A(_)` not covered\n }"}, {"sha": "8cafea555c172490dd1c0c9ddb3c7ed5e1549ad0", "filename": "tests/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Foo::A(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/uninhabited-irrefutable.rs:27:9\n    |\n LL |     let Foo::D(_y, _z) = x;\n@@ -7,18 +7,14 @@ LL |     let Foo::D(_y, _z) = x;\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Foo` defined here\n-  --> $DIR/uninhabited-irrefutable.rs:19:5\n+  --> $DIR/uninhabited-irrefutable.rs:18:6\n    |\n LL | enum Foo {\n-   |      ---\n+   |      ^^^\n LL |     A(foo::SecretlyEmpty),\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `Foo`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let (_y, _z) = if let Foo::D(_y, _z) = x { (_y, _z) } else { todo!() };\n-   |     +++++++++++++++++                        +++++++++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Foo::D(_y, _z) = x else { todo!() };\n    |                            ++++++++++++++++"}, {"sha": "466d7f2eadb92c1fea2fa453567dd943b99188e4", "filename": "tests/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606c3907251397a42e23d3e60de31be9d32525d5/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=606c3907251397a42e23d3e60de31be9d32525d5", "patch": "@@ -95,25 +95,16 @@ LL ~         Ok(x) => x,\n LL ~         Err(_) => todo!(),\n    |\n \n-error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/uninhabited-matches-feature-gated.rs:37:9\n    |\n LL |     let Ok(x) = x;\n    |         ^^^^^ pattern `Err(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Result<u32, Void>` defined here\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Result<u32, Void>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let x = if let Ok(x) = x { x } else { todo!() };\n-   |     ++++++++++               ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(x) = x else { todo!() };\n    |                   ++++++++++++++++"}]}