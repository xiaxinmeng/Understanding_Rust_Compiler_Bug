{"sha": "7fbd55c3291175229fb86ffd8a31c1e5fb544e27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYmQ1NWMzMjkxMTc1MjI5ZmI4NmZmZDhhMzFjMWU1ZmI1NDRlMjc=", "commit": {"author": {"name": "Unknown", "email": "dobbybabee@gmail.com", "date": "2019-01-13T21:26:03Z"}, "committer": {"name": "unknown", "email": "unknown@example.com", "date": "2019-02-01T18:21:19Z"}, "message": "Reworking function logic, and adding doc example.\n\nThis should fix line count logic issues that the previous code had, with assumptions it would make.", "tree": {"sha": "e828ab46e03699b13f6acf20151661533e090663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e828ab46e03699b13f6acf20151661533e090663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fbd55c3291175229fb86ffd8a31c1e5fb544e27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fbd55c3291175229fb86ffd8a31c1e5fb544e27", "html_url": "https://github.com/rust-lang/rust/commit/7fbd55c3291175229fb86ffd8a31c1e5fb544e27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fbd55c3291175229fb86ffd8a31c1e5fb544e27/comments", "author": null, "committer": null, "parents": [{"sha": "93bf74a15885c100dc830958d457c1704640de43", "url": "https://api.github.com/repos/rust-lang/rust/commits/93bf74a15885c100dc830958d457c1704640de43", "html_url": "https://github.com/rust-lang/rust/commit/93bf74a15885c100dc830958d457c1704640de43"}], "stats": {"total": 78, "additions": 48, "deletions": 30}, "files": [{"sha": "a5dbbeb3e515196e0a32afb2425d4efee63aaad3", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7fbd55c3291175229fb86ffd8a31c1e5fb544e27/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbd55c3291175229fb86ffd8a31c1e5fb544e27/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=7fbd55c3291175229fb86ffd8a31c1e5fb544e27", "patch": "@@ -40,6 +40,13 @@ declare_clippy_lint! {\n ///\n /// **Known problems:** None.\n ///\n+/// **Example:**\n+/// ``` rust\n+/// fn im_too_long() {\n+/// println!(\"\");\n+/// // ... 100 more LoC\n+/// println!(\"\");\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub TOO_MANY_LINES,\n@@ -174,46 +181,57 @@ impl<'a, 'tcx> Functions {\n         }\n     }\n \n-    fn check_line_number(self, cx: &LateContext, span: Span) {\n+    fn check_line_number(self, cx: &LateContext<'_, '_>, span: Span) {\n         let code_snippet = snippet(cx, span, \"..\");\n-        let mut line_count = 0;\n+        let mut line_count: u64 = 0;\n         let mut in_comment = false;\n-        for mut line in code_snippet.lines() {\n-            if in_comment {\n-                let end_comment_loc = match line.find(\"*/\") {\n-                    Some(i) => i,\n-                    None => continue\n-                };\n-                in_comment = false;\n-                line = &line[end_comment_loc..];\n-            }\n-            line = line.trim_left();\n-            if line.is_empty() || line.starts_with(\"//\") { continue; }\n-            if line.contains(\"/*\") {\n-                let mut count_line: bool = !line.starts_with(\"/*\");\n-                let close_counts = line.match_indices(\"*/\").count();\n-                let open_counts = line.match_indices(\"/*\").count();\n+        let mut code_in_line;\n \n-                if close_counts > 1 || open_counts > 1 {\n-                    line_count += 1;\n-                } else if close_counts == 1 {\n+        // Skip the surrounding function decl.\n+        let start_brace_idx = match code_snippet.find(\"{\") {\n+            Some(i) => i + 1,\n+            None => 0\n+        };\n+        let end_brace_idx = match code_snippet.find(\"}\") {\n+            Some(i) => i,\n+            None => code_snippet.len()\n+        };\n+        let function_lines = code_snippet[start_brace_idx..end_brace_idx].lines();\n+\n+        for mut line in function_lines {\n+            code_in_line = false;\n+            loop {\n+                line = line.trim_start();\n+                if line.is_empty() { break; }\n+                if in_comment {\n                     match line.find(\"*/\") {\n                         Some(i) => {\n-                            line = line[i..].trim_left();\n-                            if !line.is_empty() && !line.starts_with(\"//\") {\n-                                count_line = true;\n-                            }\n+                            line = &line[i + 2..];\n+                            in_comment = false;\n+                            continue;\n                         },\n-                        None => continue\n+                        None => break\n                     }\n                 } else {\n-                    in_comment = true;\n+                    let multi_idx = match line.find(\"/*\") {\n+                        Some(i) => i,\n+                        None => line.len()\n+                    };\n+                    let single_idx = match line.find(\"//\") {\n+                        Some(i) => i,\n+                        None => line.len()\n+                    };\n+                    code_in_line |= multi_idx > 0 && single_idx > 0;\n+                    // Implies multi_idx is below line.len()\n+                    if multi_idx < single_idx {\n+                        line = &line[multi_idx + 2..];\n+                        in_comment = true;\n+                        continue;\n+                    }\n+                    break;\n                 }\n-                if count_line { line_count += 1; }\n-            } else {\n-                // No multipart comment, no single comment, non-empty string.\n-                line_count += 1;\n             }\n+            if code_in_line { line_count += 1; }\n         }\n \n         if line_count > self.max_lines {"}]}