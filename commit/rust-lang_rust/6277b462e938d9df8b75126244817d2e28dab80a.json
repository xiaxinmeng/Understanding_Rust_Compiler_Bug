{"sha": "6277b462e938d9df8b75126244817d2e28dab80a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNzdiNDYyZTkzOGQ5ZGY4Yjc1MTI2MjQ0ODE3ZDJlMjhkYWI4MGE=", "commit": {"author": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-08-04T01:43:57Z"}, "committer": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-08-04T01:43:57Z"}, "message": "More stdlib hashmap work.  Add a simple test and XFAIL it due to a valgrind-spotted UMR.", "tree": {"sha": "3c749931de346aabaeaeafc86a2620da6f799fc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c749931de346aabaeaeafc86a2620da6f799fc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6277b462e938d9df8b75126244817d2e28dab80a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6277b462e938d9df8b75126244817d2e28dab80a", "html_url": "https://github.com/rust-lang/rust/commit/6277b462e938d9df8b75126244817d2e28dab80a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6277b462e938d9df8b75126244817d2e28dab80a/comments", "author": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b2451c2318499310a0183ff518ffb7d308aafa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b2451c2318499310a0183ff518ffb7d308aafa2", "html_url": "https://github.com/rust-lang/rust/commit/5b2451c2318499310a0183ff518ffb7d308aafa2"}], "stats": {"total": 68, "additions": 47, "deletions": 21}, "files": [{"sha": "699c3b3da0d0d176f51e61dee97e03a33a21f74e", "filename": "src/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6277b462e938d9df8b75126244817d2e28dab80a/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6277b462e938d9df8b75126244817d2e28dab80a/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=6277b462e938d9df8b75126244817d2e28dab80a", "patch": "@@ -395,6 +395,7 @@ TEST_XFAILS_X86 :=  $(TASK_XFAILS) \\\n                     test/run-pass/generic-recursive-tag.rs \\\n                     test/run-pass/iter-ret.rs \\\n                     test/run-pass/lib-deque.rs \\\n+                    test/run-pass/lib-map.rs \\\n                     test/run-pass/mlist-cycle.rs \\\n                     test/run-pass/obj-as.rs \\\n                     test/run-pass/task-comm.rs \\\n@@ -468,6 +469,7 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       lazy-init.rs \\\n                       lazychan.rs \\\n                       lib-deque.rs \\\n+                      lib-map.rs \\\n                       lib-rand.rs \\\n                       linear-for-loop.rs \\\n                       list.rs \\"}, {"sha": "c00ee75de12c61b2115ee008965a2bc5cc6488a5", "filename": "src/lib/map.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6277b462e938d9df8b75126244817d2e28dab80a/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6277b462e938d9df8b75126244817d2e28dab80a/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=6277b462e938d9df8b75126244817d2e28dab80a", "patch": "@@ -10,7 +10,7 @@ import std._vec;\n \n \n type hashfn[K] = fn(&K) -> uint;\n-type eqfn[K] = fn(&K) -> bool;\n+type eqfn[K] = fn(&K, &K) -> bool;\n \n type hashmap[K, V] = obj {\n   fn insert(&K key, &V val);\n@@ -46,49 +46,55 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n   // is always a power of 2), so that all buckets are probed for a\n   // fixed key.\n \n-  fn hashl[K](hashfn[K] hasher, uint nbkts, &K key) -> uint {\n+  fn hashl[K](&hashfn[K] hasher, uint nbkts, &K key) -> uint {\n     ret (hasher(key) >>> (sys.rustrt.size_of[uint]() * 8u / 2u))\n       % nbkts;\n   }\n \n-  fn hashr[K](hashfn[K] hasher, uint nbkts, &K key) -> uint {\n+  fn hashr[K](&hashfn[K] hasher, uint nbkts, &K key) -> uint {\n     ret ((((~ 0u) >>> (sys.rustrt.size_of[uint]() * 8u / 2u))\n           & hasher(key)) * 2u + 1u)\n       % nbkts;\n   }\n \n-  fn hash[K](hashfn[K] hasher, uint nbkts, &K key, uint i) -> uint {\n+  fn hash[K](&hashfn[K] hasher, uint nbkts, &K key, uint i) -> uint {\n     ret hashl[K](hasher, nbkts, key) + i * hashr[K](hasher, nbkts, key);\n   }\n \n   /**\n    * We attempt to never call this with a full table.  If we do, it\n    * will fail.\n    */\n-  fn insert_common[K, V](hashfn[K] hasher,\n+  fn insert_common[K, V](&hashfn[K] hasher,\n+                         &eqfn[K] eqer,\n                          vec[mutable bucket[K, V]] bkts,\n                          uint nbkts,\n                          &K key,\n                          &V val)\n+    -> bool\n   {\n     let uint i = 0u;\n     while (i < nbkts) {\n       // FIXME (issue #94): as in find_common()\n       let int j = (hash[K](hasher, nbkts, key, i)) as int;\n       alt (bkts.(j)) {\n-        case (some[K, V](_, _)) {\n+        case (some[K, V](k, _)) {\n+          if (eqer(key, k)) {\n+            ret false;\n+          }\n           i += 1u;\n         }\n         case (_) {\n           bkts.(j) = some[K, V](key, val);\n-          ret;\n+          ret true;\n         }\n       }\n     }\n     fail; // full table\n   }\n \n-  fn find_common[K, V](hashfn[K] hasher,\n+  fn find_common[K, V](&hashfn[K] hasher,\n+                       &eqfn[K] eqer,\n                        vec[mutable bucket[K, V]] bkts,\n                        uint nbkts,\n                        &K key)\n@@ -99,29 +105,31 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n       // FIXME (issue #94):  Pending bugfix, remove uint coercion.\n       let int j = (hash[K](hasher, nbkts, key, i)) as int;\n       alt (bkts.(j)) {\n-        case (some[K, V](_, val)) {\n-          ret util.some[V](val);\n+        case (some[K, V](k, v)) {\n+          if (eqer(key, k)) {\n+            ret util.some[V](v);\n+          }\n         }\n         case (nil[K, V]()) {\n           ret util.none[V]();\n         }\n-        case (deleted[K, V]()) {\n-          i += 1u;\n-        }\n+        case (deleted[K, V]()) { }\n       }\n+      i += 1u;\n     }\n     ret util.none[V]();\n   }\n \n \n-  fn rehash[K, V](hashfn[K] hasher,\n+  fn rehash[K, V](&hashfn[K] hasher,\n+                  &eqfn[K] eqer,\n                   vec[mutable bucket[K, V]] oldbkts, uint noldbkts,\n                   vec[mutable bucket[K, V]] newbkts, uint nnewbkts)\n   {\n     for (bucket[K, V] b in oldbkts) {\n       alt (b) {\n         case (some[K, V](k, v)) {\n-          insert_common[K, V](hasher, newbkts, nnewbkts, k, v);\n+          insert_common[K, V](hasher, eqer, newbkts, nnewbkts, k, v);\n         }\n         case (_) { }\n       }\n@@ -144,28 +152,28 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n         check ((nnewbkts as int) > 0);\n \n         let vec[mutable bucket[K, V]] newbkts = make_buckets[K, V](nnewbkts);\n-        rehash[K, V](hasher, bkts, nbkts, newbkts, nnewbkts);\n+        rehash[K, V](hasher, eqer, bkts, nbkts, newbkts, nnewbkts);\n       }\n-      insert_common[K, V](hasher, bkts, nbkts, key, val);\n+      insert_common[K, V](hasher, eqer, bkts, nbkts, key, val);\n       nelts += 1u;\n     }\n \n     fn contains_key(&K key) -> bool {\n-      alt (find_common[K, V](hasher, bkts, nbkts, key)) {\n+      alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n         case (util.some[V](_)) { ret true; }\n         case (_) { ret false; }\n       }\n     }\n \n     fn get(&K key) -> V {\n-      alt (find_common[K, V](hasher, bkts, nbkts, key)) {\n+      alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n         case (util.some[V](val)) { ret val; }\n         case (_) { fail; }\n       }\n     }\n \n     fn find(&K key) -> util.option[V] {\n-      be find_common[K, V](hasher, bkts, nbkts, key);\n+      be find_common[K, V](hasher, eqer, bkts, nbkts, key);\n     }\n \n     fn remove(&K key) -> util.option[V] {\n@@ -191,7 +199,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n \n     fn rehash() {\n       let vec[mutable bucket[K, V]] newbkts = make_buckets[K, V](nbkts);\n-      rehash[K, V](hasher, bkts, nbkts, newbkts, nbkts);\n+      rehash[K, V](hasher, eqer, bkts, nbkts, newbkts, nbkts);\n       bkts = newbkts;\n     }\n   }"}, {"sha": "11101c849b8c10e3e652dc84963b9193972e74ca", "filename": "src/test/run-pass/lib-map.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6277b462e938d9df8b75126244817d2e28dab80a/src%2Ftest%2Frun-pass%2Flib-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6277b462e938d9df8b75126244817d2e28dab80a/src%2Ftest%2Frun-pass%2Flib-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-map.rs?ref=6277b462e938d9df8b75126244817d2e28dab80a", "patch": "@@ -0,0 +1,16 @@\n+// -*- rust -*-\n+\n+use std;\n+import std.map;\n+\n+fn test_simple() {\n+  fn eq(&uint x, &uint y) -> bool { ret x == y; }\n+\n+  let map.hashfn[uint] hasher = std.util.id[uint];\n+  let map.eqfn[uint] eqer = eq;\n+  let map.hashmap[uint, uint] hm = map.mk_hashmap[uint, uint](hasher, eqer);\n+}\n+\n+fn main() {\n+  test_simple();\n+}\n\\ No newline at end of file"}]}