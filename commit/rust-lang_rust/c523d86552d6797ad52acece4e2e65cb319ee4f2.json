{"sha": "c523d86552d6797ad52acece4e2e65cb319ee4f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MjNkODY1NTJkNjc5N2FkNTJhY2VjZTRlMmU2NWNiMzE5ZWU0ZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-16T02:11:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-16T02:11:14Z"}, "message": "auto merge of #15585 : bgamari/rust/subst-bug, r=pnkfelix\n\nThis branch has a fix for #15557 (a2bcef9) as well as a variety of patches I found useful while debugging this issue. These include adding `Show` impls to a variety of types, including the majority of `syntax::ast` and some of `middle::ty`.", "tree": {"sha": "2fc16da524e27fcdbe9434b300bf535ad775155c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fc16da524e27fcdbe9434b300bf535ad775155c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c523d86552d6797ad52acece4e2e65cb319ee4f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c523d86552d6797ad52acece4e2e65cb319ee4f2", "html_url": "https://github.com/rust-lang/rust/commit/c523d86552d6797ad52acece4e2e65cb319ee4f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c523d86552d6797ad52acece4e2e65cb319ee4f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afbcbbc77ffc6b10053bc543daf7d2e05d68cc01", "url": "https://api.github.com/repos/rust-lang/rust/commits/afbcbbc77ffc6b10053bc543daf7d2e05d68cc01", "html_url": "https://github.com/rust-lang/rust/commit/afbcbbc77ffc6b10053bc543daf7d2e05d68cc01"}, {"sha": "446f9373c05900125f30f244441c5833ce64e146", "url": "https://api.github.com/repos/rust-lang/rust/commits/446f9373c05900125f30f244441c5833ce64e146", "html_url": "https://github.com/rust-lang/rust/commit/446f9373c05900125f30f244441c5833ce64e146"}], "stats": {"total": 289, "additions": 181, "deletions": 108}, "files": [{"sha": "914cf451ebe29380878c029370b34a4f2547e5ae", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=c523d86552d6797ad52acece4e2e65cb319ee4f2", "patch": "@@ -14,7 +14,7 @@ use syntax::ast_util::local_def;\n \n use std::gc::Gc;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Def {\n     DefFn(ast::DefId, ast::FnStyle),\n     DefStaticMethod(/* method */ ast::DefId, MethodProvenance, ast::FnStyle),\n@@ -51,7 +51,7 @@ pub enum Def {\n     DefMethod(ast::DefId /* method */, Option<ast::DefId> /* trait */),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum MethodProvenance {\n     FromTrait(ast::DefId),\n     FromImpl(ast::DefId),"}, {"sha": "4f7cb742d8f86dca5cb3d2081459cf93d7f9fdf8", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=c523d86552d6797ad52acece4e2e65cb319ee4f2", "patch": "@@ -87,7 +87,8 @@ fn check_struct_safe_for_destructor(cx: &mut Context,\n                                     span: Span,\n                                     struct_did: DefId) {\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n-    if !struct_tpt.generics.has_type_params(subst::TypeSpace) {\n+    if !struct_tpt.generics.has_type_params(subst::TypeSpace)\n+      && !struct_tpt.generics.has_region_params(subst::TypeSpace) {\n         let struct_ty = ty::mk_struct(cx.tcx, struct_did,\n                                       subst::Substs::empty());\n         if !ty::type_is_sendable(cx.tcx, struct_ty) {\n@@ -121,7 +122,7 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n \n     // If this trait has builtin-kind supertraits, meet them.\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n-    debug!(\"checking impl with self type {:?}\", ty::get(self_ty).sty);\n+    debug!(\"checking impl with self type {}\", ty::get(self_ty).sty);\n     check_builtin_bounds(cx, self_ty, trait_def.bounds, |missing| {\n         cx.tcx.sess.span_err(self_type.span,\n             format!(\"the type `{}', which does not fulfill `{}`, cannot implement this \\"}, {"sha": "5c2a70a46fdc8c95e8c712182cb5e07997f97526", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=c523d86552d6797ad52acece4e2e65cb319ee4f2", "patch": "@@ -15,6 +15,7 @@ use middle::ty_fold;\n use middle::ty_fold::{TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n+use std::fmt;\n use std::mem;\n use std::raw;\n use std::slice::{Items, MutItems};\n@@ -83,7 +84,7 @@ impl<T> HomogeneousTuple3<T> for (T, T, T) {\n  * space* (which indices where the parameter is defined; see\n  * `ParamSpace`).\n  */\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct Substs {\n     pub types: VecPerParamSpace<ty::t>,\n     pub regions: RegionSubsts,\n@@ -93,7 +94,7 @@ pub struct Substs {\n  * Represents the values to use when substituting lifetime parameters.\n  * If the value is `ErasedRegions`, then this subst is occurring during\n  * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum RegionSubsts {\n     ErasedRegions,\n     NonerasedRegions(VecPerParamSpace<ty::Region>)\n@@ -275,6 +276,17 @@ pub struct VecPerParamSpace<T> {\n     content: Vec<T>,\n }\n \n+impl<T:fmt::Show> fmt::Show for VecPerParamSpace<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(fmt, \"VecPerParamSpace {{\"));\n+        for space in ParamSpace::all().iter() {\n+            try!(write!(fmt, \"{}: {}, \", *space, self.get_slice(*space)));\n+        }\n+        try!(write!(fmt, \"}}\"));\n+        Ok(())\n+    }\n+}\n+\n impl<T:Clone> VecPerParamSpace<T> {\n     pub fn push_all(&mut self, space: ParamSpace, values: &[T]) {\n         // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n@@ -558,10 +570,22 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n         // the specialized routine\n         // `middle::typeck::check::regionmanip::replace_late_regions_in_fn_sig()`.\n         match r {\n-            ty::ReEarlyBound(_, space, i, _) => {\n+            ty::ReEarlyBound(_, space, i, region_name) => {\n                 match self.substs.regions {\n                     ErasedRegions => ty::ReStatic,\n-                    NonerasedRegions(ref regions) => *regions.get(space, i),\n+                    NonerasedRegions(ref regions) =>\n+                        match regions.opt_get(space, i) {\n+                            Some(t) => *t,\n+                            None => {\n+                                let span = self.span.unwrap_or(DUMMY_SP);\n+                                self.tcx().sess.span_bug(\n+                                    span,\n+                                    format!(\"Type parameter out of range \\\n+                                     when substituting in region {} (root type={})\",\n+                                    region_name.as_str(),\n+                                    self.root_ty.repr(self.tcx())).as_slice());\n+                            }\n+                        }\n                 }\n             }\n             _ => r"}, {"sha": "dc69e3fd6399d3ca908321078e7bca9233e5671d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c523d86552d6797ad52acece4e2e65cb319ee4f2", "patch": "@@ -124,7 +124,7 @@ impl Method {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct mt {\n     pub ty: t,\n     pub mutbl: ast::Mutability,\n@@ -138,7 +138,7 @@ pub enum TraitStore {\n     RegionTraitStore(Region, ast::Mutability),\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct field_ty {\n     pub name: Name,\n     pub id: DefId,\n@@ -394,6 +394,7 @@ pub enum tbox_flag {\n \n pub type t_box = &'static t_box_;\n \n+#[deriving(Show)]\n pub struct t_box_ {\n     pub sty: sty,\n     pub id: uint,\n@@ -436,14 +437,14 @@ pub fn type_needs_infer(t: t) -> bool {\n }\n pub fn type_id(t: t) -> uint { get(t).id }\n \n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct BareFnTy {\n     pub fn_style: ast::FnStyle,\n     pub abi: abi::Abi,\n     pub sig: FnSig,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct ClosureTy {\n     pub fn_style: ast::FnStyle,\n     pub onceness: ast::Onceness,\n@@ -472,7 +473,7 @@ pub struct FnSig {\n     pub variadic: bool\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n     pub idx: uint,\n@@ -712,7 +713,7 @@ mod primitives {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum sty {\n     ty_nil,\n     ty_bot,\n@@ -741,14 +742,14 @@ pub enum sty {\n             // on non-useful type error messages)\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TyTrait {\n     pub def_id: DefId,\n     pub substs: Substs,\n     pub bounds: BuiltinBounds\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n pub struct TraitRef {\n     pub def_id: DefId,\n     pub substs: Substs,\n@@ -808,7 +809,7 @@ pub enum type_err {\n     terr_variadic_mismatch(expected_found<bool>)\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n pub struct ParamBounds {\n     pub builtin_bounds: BuiltinBounds,\n     pub trait_bounds: Vec<Rc<TraitRef>>\n@@ -948,7 +949,7 @@ impl fmt::Show for IntVarValue {\n     }\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct TypeParameterDef {\n     pub ident: ast::Ident,\n     pub def_id: ast::DefId,\n@@ -958,7 +959,7 @@ pub struct TypeParameterDef {\n     pub default: Option<ty::t>\n }\n \n-#[deriving(Encodable, Decodable, Clone)]\n+#[deriving(Encodable, Decodable, Clone, Show)]\n pub struct RegionParameterDef {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n@@ -968,7 +969,7 @@ pub struct RegionParameterDef {\n \n /// Information about the type/lifetime parameters associated with an\n /// item or method. Analogous to ast::Generics.\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct Generics {\n     pub types: VecPerParamSpace<TypeParameterDef>,\n     pub regions: VecPerParamSpace<RegionParameterDef>,\n@@ -983,6 +984,10 @@ impl Generics {\n     pub fn has_type_params(&self, space: subst::ParamSpace) -> bool {\n         !self.types.is_empty_in(space)\n     }\n+\n+    pub fn has_region_params(&self, space: subst::ParamSpace) -> bool {\n+        !self.regions.is_empty_in(space)\n+    }\n }\n \n /// When type checking, we use the `ParameterEnvironment` to track\n@@ -1014,7 +1019,7 @@ pub struct ParameterEnvironment {\n /// - `generics`: the set of type parameters and their bounds\n /// - `ty`: the base types, which may reference the parameters defined\n ///   in `generics`\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct Polytype {\n     pub generics: Generics,\n     pub ty: t"}, {"sha": "5ed92b305be0d1c4da438ea9fc1e247b4941f6f2", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=c523d86552d6797ad52acece4e2e65cb319ee4f2", "patch": "@@ -141,7 +141,7 @@ pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n         }\n     };\n \n-    debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {}\",\n+    debug!(\"opt_ast_region_to_region(opt_lifetime={}) yields {}\",\n             opt_lifetime.as_ref().map(|e| lifetime_to_string(e)),\n             r.repr(this.tcx()));\n \n@@ -504,6 +504,7 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n     }\n }\n \n+#[deriving(Show)]\n enum PointerTy {\n     Box,\n     RPtr(ty::Region),\n@@ -565,7 +566,7 @@ fn mk_pointer<AC:AstConv,\n               constr: |ty::t| -> ty::t)\n               -> ty::t {\n     let tcx = this.tcx();\n-    debug!(\"mk_pointer(ptr_ty={:?})\", ptr_ty);\n+    debug!(\"mk_pointer(ptr_ty={})\", ptr_ty);\n \n     match a_seq_ty.ty.node {\n         ast::TyVec(ref ty) => {"}, {"sha": "be01643e22a583e6a547a267d6e0451077f3a033", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=c523d86552d6797ad52acece4e2e65cb319ee4f2", "patch": "@@ -507,14 +507,20 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             ty::ty_struct(cid, ref substs) => {\n                 // Verify that the pattern named the right structure.\n                 let item_did = tcx.def_map.borrow().get(&pat.id).def_id();\n-                let struct_did =\n-                    ty::ty_to_def_id(\n-                        ty::lookup_item_type(tcx, item_did).ty).unwrap();\n-                if struct_did != cid {\n-                    span_err!(tcx.sess, pat.span, E0032,\n-                        \"`{}` does not name the structure `{}`\",\n-                        pprust::path_to_string(path),\n-                        fcx.infcx().ty_to_string(expected));\n+                match ty::ty_to_def_id(ty::lookup_item_type(tcx, item_did).ty) {\n+                    Some(struct_did) if struct_did != cid => {\n+                        span_err!(tcx.sess, path.span, E0032,\n+                                  \"`{}` does not name the structure `{}`\",\n+                                  pprust::path_to_string(path),\n+                                  fcx.infcx().ty_to_string(expected));\n+                    },\n+                    Some(_) => {},\n+                    None => {\n+                        tcx.sess.span_bug(\n+                            path.span,\n+                            format!(\"This shouldn't happen: failed to lookup structure. \\\n+                                item_did = {}\", item_did).as_slice())\n+                    },\n                 }\n \n                 check_struct_pat(pcx, pat.id, pat.span, expected, path,"}, {"sha": "7a39dd5b5ab82f1b28bd8afb0e04f77cc5340192", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=c523d86552d6797ad52acece4e2e65cb319ee4f2", "patch": "@@ -1018,16 +1018,17 @@ fn ty_generics(ccx: &CrateCtxt,\n     let mut result = base_generics;\n \n     for (i, l) in lifetimes.iter().enumerate() {\n-        result.regions.push(space,\n-                            ty::RegionParameterDef { name: l.name,\n-                                                     space: space,\n-                                                     index: i,\n-                                                     def_id: local_def(l.id) });\n+        let def = ty::RegionParameterDef { name: l.name,\n+                                           space: space,\n+                                           index: i,\n+                                           def_id: local_def(l.id) };\n+        debug!(\"ty_generics: def for region param: {}\", def);\n+        result.regions.push(space, def);\n     }\n \n     for (i, param) in types.iter().enumerate() {\n         let def = get_or_create_type_parameter_def(ccx, space, param, i);\n-        debug!(\"def for param: {}\", def.repr(ccx.tcx));\n+        debug!(\"ty_generics: def for type param: {}\", def.repr(ccx.tcx));\n         result.types.push(space, def);\n     }\n "}, {"sha": "28240686dc358f2fdb7e8d3dc288e60a0f540c67", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=c523d86552d6797ad52acece4e2e65cb319ee4f2", "patch": "@@ -246,7 +246,7 @@ impl<'a> RegionVarBindings<'a> {\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n-        debug!(\"created new region variable {:?} with origin {:?}\",\n+        debug!(\"created new region variable {} with origin {}\",\n                vid, origin.repr(self.tcx));\n         return vid;\n     }"}, {"sha": "857cb4c0162ce530d930950aa3699ca722db97ca", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c523d86552d6797ad52acece4e2e65cb319ee4f2", "patch": "@@ -152,7 +152,7 @@ impl<D:Decoder<E>, E> Decodable<D, E> for Ident {\n /// Function name (not all functions have names)\n pub type FnIdent = Option<Ident>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n@@ -162,7 +162,7 @@ pub struct Lifetime {\n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n /// std::cmp::PartialEq  .  It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Path {\n     pub span: Span,\n     /// A `::foo` path, is relative to the crate root rather than current\n@@ -174,7 +174,7 @@ pub struct Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub identifier: Ident,\n@@ -208,15 +208,15 @@ pub static DUMMY_NODE_ID: NodeId = -1;\n /// typeck::collect::compute_bounds matches these against\n /// the \"special\" built-in traits (see middle::lang_items) and\n /// detects Copy, Send and Share.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TyParamBound {\n     TraitTyParamBound(TraitRef),\n     StaticRegionTyParamBound,\n     UnboxedFnTyParamBound(UnboxedFnTy),\n     OtherRegionTyParamBound(Span) // FIXME -- just here until work for #5723 lands\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct TyParam {\n     pub ident: Ident,\n     pub id: NodeId,\n@@ -228,7 +228,7 @@ pub struct TyParam {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Generics {\n     pub lifetimes: Vec<Lifetime>,\n     pub ty_params: OwnedSlice<TyParam>,\n@@ -250,7 +250,7 @@ impl Generics {\n /// used to drive conditional compilation\n pub type CrateConfig = Vec<Gc<MetaItem>> ;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n@@ -261,7 +261,7 @@ pub struct Crate {\n \n pub type MetaItem = Spanned<MetaItem_>;\n \n-#[deriving(Clone, Encodable, Decodable, Eq, Hash)]\n+#[deriving(Clone, Encodable, Decodable, Eq, Hash, Show)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n     MetaList(InternedString, Vec<Gc<MetaItem>>),\n@@ -293,7 +293,7 @@ impl PartialEq for MetaItem_ {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Block {\n     pub view_items: Vec<ViewItem>,\n     pub stmts: Vec<Gc<Stmt>>,\n@@ -303,26 +303,26 @@ pub struct Block {\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Pat {\n     pub id: NodeId,\n     pub node: Pat_,\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct FieldPat {\n     pub ident: Ident,\n     pub pat: Gc<Pat>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum BindingMode {\n     BindByRef(Mutability),\n     BindByValue(Mutability),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Pat_ {\n     PatWild,\n     PatWildMulti,\n@@ -354,7 +354,7 @@ pub enum Mutability {\n     MutImmutable,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ExprVstore {\n     /// ~[1, 2, 3, 4]\n     ExprVstoreUniq,\n@@ -364,7 +364,7 @@ pub enum ExprVstore {\n     ExprVstoreMutSlice,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum BinOp {\n     BiAdd,\n     BiSub,\n@@ -386,7 +386,7 @@ pub enum BinOp {\n     BiGt,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum UnOp {\n     UnBox,\n     UnUniq,\n@@ -397,7 +397,7 @@ pub enum UnOp {\n \n pub type Stmt = Spanned<Stmt_>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Stmt_ {\n     /// Could be an item or a local (let) binding:\n     StmtDecl(Gc<Decl>, NodeId),\n@@ -414,7 +414,7 @@ pub enum Stmt_ {\n \n /// Where a local declaration came from: either a true `let ... =\n /// ...;`, or one desugared from the pattern of a for loop.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum LocalSource {\n     LocalLet,\n     LocalFor,\n@@ -423,7 +423,7 @@ pub enum LocalSource {\n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Local {\n     pub ty: P<Ty>,\n     pub pat: Gc<Pat>,\n@@ -435,7 +435,7 @@ pub struct Local {\n \n pub type Decl = Spanned<Decl_>;\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Decl_ {\n     /// A local (let) binding:\n     DeclLocal(Gc<Local>),\n@@ -444,15 +444,15 @@ pub enum Decl_ {\n }\n \n /// represents one arm of a 'match'\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n     pub pats: Vec<Gc<Pat>>,\n     pub guard: Option<Gc<Expr>>,\n     pub body: Gc<Expr>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Field {\n     pub ident: SpannedIdent,\n     pub expr: Gc<Expr>,\n@@ -461,26 +461,26 @@ pub struct Field {\n \n pub type SpannedIdent = Spanned<Ident>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Expr_ {\n     ExprVstore(Gc<Expr>, ExprVstore),\n     /// First expr is the place; second expr is the value.\n@@ -547,7 +547,7 @@ pub enum Expr_ {\n /// makes any real sense. You could write them elsewhere but nothing\n /// else knows what to do with them, so you'll probably get a syntax\n /// error.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n     /// A single token\n@@ -621,7 +621,7 @@ pub enum TokenTree {\n // macro system. Congratulations.\n pub type Matcher = Spanned<Matcher_>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Matcher_ {\n     /// Match one token\n     MatchTok(::parse::token::Token),\n@@ -638,7 +638,7 @@ pub type Mac = Spanned<Mac_>;\n /// is being invoked, and the vector of token-trees contains the source\n /// of the macro invocation.\n /// There's only one flavor, now, so this could presumably be simplified.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Mac_ {\n     // NB: the additional ident for a macro_rules-style macro is actually\n     // stored in the enclosing item. Oog.\n@@ -670,13 +670,13 @@ pub enum Lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct TypeField {\n     pub ident: Ident,\n     pub mt: MutTy,\n@@ -685,7 +685,7 @@ pub struct TypeField {\n \n /// Represents a required method in a trait declaration,\n /// one without a default implementation\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct TypeMethod {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -702,7 +702,7 @@ pub struct TypeMethod {\n /// a default implementation A trait method is either required (meaning it\n /// doesn't have an implementation, just a signature) or provided (meaning it\n /// has a default implementation).\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TraitMethod {\n     Required(TypeMethod),\n     Provided(Gc<Method>),\n@@ -779,15 +779,15 @@ impl FloatTy {\n }\n \n // NB PartialEq method appears below.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Ty {\n     pub id: NodeId,\n     pub node: Ty_,\n     pub span: Span,\n }\n \n /// Not represented directly in the AST, referred to by name through a ty_path.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum PrimTy {\n     TyInt(IntTy),\n     TyUint(UintTy),\n@@ -813,7 +813,7 @@ impl fmt::Show for Onceness {\n }\n \n /// Represents the type of a closure\n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ClosureTy {\n     pub lifetimes: Vec<Lifetime>,\n     pub fn_style: FnStyle,\n@@ -826,20 +826,20 @@ pub struct ClosureTy {\n     pub bounds: Option<OwnedSlice<TyParamBound>>,\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct BareFnTy {\n     pub fn_style: FnStyle,\n     pub abi: Abi,\n     pub lifetimes: Vec<Lifetime>,\n     pub decl: P<FnDecl>\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct UnboxedFnTy {\n     pub decl: P<FnDecl>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Ty_ {\n     TyNil,\n     TyBot, /* bottom type */\n@@ -863,13 +863,13 @@ pub enum Ty_ {\n     TyInfer,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum AsmDialect {\n     AsmAtt,\n     AsmIntel\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n@@ -882,7 +882,7 @@ pub struct InlineAsm {\n }\n \n /// represents an argument in a function header\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Arg {\n     pub ty: P<Ty>,\n     pub pat: Gc<Pat>,\n@@ -910,7 +910,7 @@ impl Arg {\n }\n \n /// represents the header (not the body) of a function declaration\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n     pub output: P<Ty>,\n@@ -935,7 +935,7 @@ impl fmt::Show for FnStyle {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum RetStyle {\n     /// Functions with return type ! that always\n     /// raise an error or exit (i.e. never return to the caller)\n@@ -945,7 +945,7 @@ pub enum RetStyle {\n }\n \n /// Represents the kind of 'self' associated with a method\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ExplicitSelf_ {\n     /// No self\n     SelfStatic,\n@@ -959,23 +959,23 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Method {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n     pub node: Method_\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Method_ {\n     /// Represents a method declaration\n     MethDecl(Ident, Generics, ExplicitSelf, FnStyle, P<FnDecl>, P<Block>, Visibility),\n     /// Represents a macro in method position\n     MethMac(Mac),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -985,31 +985,31 @@ pub struct Mod {\n     pub items: Vec<Gc<Item>>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub view_items: Vec<ViewItem>,\n     pub items: Vec<Gc<ForeignItem>>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct VariantArg {\n     pub ty: P<Ty>,\n     pub id: NodeId,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum VariantKind {\n     TupleVariantKind(Vec<VariantArg>),\n     StructVariantKind(Gc<StructDef>),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct EnumDef {\n     pub variants: Vec<P<Variant>>,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Variant_ {\n     pub name: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1021,7 +1021,7 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct PathListIdent_ {\n     pub name: Ident,\n     pub id: NodeId,\n@@ -1031,7 +1031,7 @@ pub type PathListIdent = Spanned<PathListIdent_>;\n \n pub type ViewPath = Spanned<ViewPath_>;\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ViewPath_ {\n \n     /// `quux = foo::bar::baz`\n@@ -1048,15 +1048,15 @@ pub enum ViewPath_ {\n     ViewPathList(Path, Vec<PathListIdent> , NodeId)\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ViewItem {\n     pub node: ViewItem_,\n     pub attrs: Vec<Attribute>,\n     pub vis: Visibility,\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ViewItem_ {\n     /// Ident: name used to refer to this crate in the code\n     /// optional (InternedString,StrStyle): if present, this is a location\n@@ -1072,17 +1072,17 @@ pub type Attribute = Spanned<Attribute_>;\n /// Distinguishes between Attributes that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n /// distinguished for pretty-printing.\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum AttrStyle {\n     AttrOuter,\n     AttrInner,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct AttrId(pub uint);\n \n /// Doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Attribute_ {\n     pub id: AttrId,\n     pub style: AttrStyle,\n@@ -1096,13 +1096,13 @@ pub struct Attribute_ {\n /// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n /// If this impl is an ItemImpl, the impl_id is redundant (it could be the\n /// same as the impl's node id).\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash,   Show)]\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Visibility {\n     Public,\n     Inherited,\n@@ -1117,7 +1117,7 @@ impl Visibility {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct StructField_ {\n     pub kind: StructFieldKind,\n     pub id: NodeId,\n@@ -1136,7 +1136,7 @@ impl StructField_ {\n \n pub type StructField = Spanned<StructField_>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum StructFieldKind {\n     NamedField(Ident, Visibility),\n     /// Element of a tuple-like struct\n@@ -1152,7 +1152,7 @@ impl StructFieldKind {\n     }\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct StructDef {\n     /// Fields, not including ctor\n     pub fields: Vec<StructField>,\n@@ -1169,7 +1169,7 @@ pub struct StructDef {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Item {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1179,7 +1179,7 @@ pub struct Item {\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Item_ {\n     ItemStatic(P<Ty>, Mutability, Gc<Expr>),\n     ItemFn(P<FnDecl>, FnStyle, Abi, Generics, P<Block>),\n@@ -1202,7 +1202,7 @@ pub enum Item_ {\n     ItemMac(Mac),\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ForeignItem {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1212,7 +1212,7 @@ pub struct ForeignItem {\n     pub vis: Visibility,\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ForeignItem_ {\n     ForeignItemFn(P<FnDecl>, Generics),\n     ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n@@ -1221,7 +1221,7 @@ pub enum ForeignItem_ {\n /// The data we save and restore about an inlined item or method.  This is not\n /// part of the AST that we parse from a file, but it becomes part of the tree\n /// that we trans.\n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum InlinedItem {\n     IIItem(Gc<Item>),\n     IIMethod(DefId /* impl id */, bool /* is provided */, Gc<Method>),"}, {"sha": "7eb6709919aaf082198e5a3d1778d75b0eb9ea89", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=c523d86552d6797ad52acece4e2e65cb319ee4f2", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::fmt;\n use std::default::Default;\n use std::hash;\n use std::{mem, raw, ptr, slice};\n@@ -22,6 +23,17 @@ pub struct OwnedSlice<T> {\n     len: uint,\n }\n \n+impl<T:fmt::Show> fmt::Show for OwnedSlice<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        try!(\"OwnedSlice {{\".fmt(fmt));\n+        for i in self.iter() {\n+            try!(i.fmt(fmt));\n+        }\n+        try!(\"}}\".fmt(fmt));\n+        Ok(())\n+    }\n+}\n+\n #[unsafe_destructor]\n impl<T> Drop for OwnedSlice<T> {\n     fn drop(&mut self) {"}, {"sha": "af675587728be9301dd3705e4cc9cede78bd3822", "filename": "src/test/compile-fail/unsafe-destructor-check-crash.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Ftest%2Fcompile-fail%2Funsafe-destructor-check-crash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c523d86552d6797ad52acece4e2e65cb319ee4f2/src%2Ftest%2Fcompile-fail%2Funsafe-destructor-check-crash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-destructor-check-crash.rs?ref=c523d86552d6797ad52acece4e2e65cb319ee4f2", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+\n+// Regression test for issue #15557\n+\n+#![allow(dead_code)]\n+struct AReg1<'a>(&'a u32);\n+\n+impl<'a> Drop for AReg1<'a> {\n+//~^ ERROR: cannot implement a destructor on a structure with type parameters\n+  fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}]}