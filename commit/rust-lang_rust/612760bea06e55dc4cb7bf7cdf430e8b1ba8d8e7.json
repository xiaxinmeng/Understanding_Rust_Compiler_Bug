{"sha": "612760bea06e55dc4cb7bf7cdf430e8b1ba8d8e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMjc2MGJlYTA2ZTU1ZGM0Y2I3YmY3Y2RmNDMwZThiMWJhOGQ4ZTc=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-06T14:43:08Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-06T15:07:00Z"}, "message": "fix dropck overflow error message\n\nPerf numbers:\n\nBefore this patchset:\n572.70user 5.52system 7:33.21elapsed 127%CPU (0avgtext+0avgdata 1173368maxresident)k\nllvm-time: 385.858\n\nAfter this patch:\n557.84user 5.73system 7:22.10elapsed 127%CPU (0avgtext+0avgdata 1142848maxresident)k\nllvm-time: 385.834\n\nnice 2.5% perf improvement", "tree": {"sha": "42cd717da2fb302a685c7f80a1e1786f36696c05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42cd717da2fb302a685c7f80a1e1786f36696c05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/612760bea06e55dc4cb7bf7cdf430e8b1ba8d8e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/612760bea06e55dc4cb7bf7cdf430e8b1ba8d8e7", "html_url": "https://github.com/rust-lang/rust/commit/612760bea06e55dc4cb7bf7cdf430e8b1ba8d8e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/612760bea06e55dc4cb7bf7cdf430e8b1ba8d8e7/comments", "author": null, "committer": null, "parents": [{"sha": "c533f963d9f7f6c665c4d6e9c8c02c5a2d62c9e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c533f963d9f7f6c665c4d6e9c8c02c5a2d62c9e6", "html_url": "https://github.com/rust-lang/rust/commit/c533f963d9f7f6c665c4d6e9c8c02c5a2d62c9e6"}], "stats": {"total": 40, "additions": 20, "deletions": 20}, "files": [{"sha": "4ae65a15c26b22594b3676f4aeafe5db61b638c9", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/612760bea06e55dc4cb7bf7cdf430e8b1ba8d8e7/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612760bea06e55dc4cb7bf7cdf430e8b1ba8d8e7/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=612760bea06e55dc4cb7bf7cdf430e8b1ba8d8e7", "patch": "@@ -18,6 +18,7 @@ use util::nodemap::FnvHashSet;\n \n use syntax::ast;\n use syntax::codemap::{self, Span};\n+use syntax::parse::token::special_idents;\n \n /// check_drop_impl confirms that the Drop implementation identfied by\n /// `drop_impl_did` is not any more specialized than the type it is\n@@ -286,27 +287,26 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                     // was somehow on the root.\n                 }\n                 TypeContext::ADT { def_id, variant, field, field_index } => {\n-                    // FIXME (pnkfelix): eventually lookup arg_name\n-                    // for the given index on struct variants.\n-                    // TODO: be saner\n-                    if let ty::ADTKind::Enum = tcx.lookup_adt_def(def_id).adt_kind() {\n-                        span_note!(\n-                            rcx.tcx().sess,\n-                            span,\n-                            \"overflowed on enum {} variant {} argument {} type: {}\",\n-                            tcx.item_path_str(def_id),\n-                            variant,\n-                            field_index,\n-                            detected_on_typ);\n+                    let adt = tcx.lookup_adt_def(def_id);\n+                    let variant_name = match adt.adt_kind() {\n+                        ty::ADTKind::Enum => format!(\"enum {} variant {}\",\n+                                                     tcx.item_path_str(def_id),\n+                                                     variant),\n+                        ty::ADTKind::Struct => format!(\"struct {}\",\n+                                                       tcx.item_path_str(def_id))\n+                    };\n+                    let field_name = if field == special_idents::unnamed_field.name {\n+                        format!(\"#{}\", field_index)\n                     } else {\n-                        span_note!(\n-                            rcx.tcx().sess,\n-                            span,\n-                            \"overflowed on struct {} field {} type: {}\",\n-                            tcx.item_path_str(def_id),\n-                            field,\n-                            detected_on_typ);\n-                    }\n+                        format!(\"`{}`\", field)\n+                    };\n+                    span_note!(\n+                        rcx.tcx().sess,\n+                        span,\n+                        \"overflowed on {} field {} type: {}\",\n+                        variant_name,\n+                        field_name,\n+                        detected_on_typ);\n                 }\n             }\n         }"}]}