{"sha": "b285f1e6c90332188bb720bf320c507fc4156fdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyODVmMWU2YzkwMzMyMTg4YmI3MjBiZjMyMGM1MDdmYzQxNTZmZGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-11T21:17:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-11T21:17:09Z"}, "message": "auto merge of #8455 : nikomatsakis/rust/issue-5762-objects-dralston-d, r=graydon\n\nFix #5762 and various other aspects of object invocation.\r\n\r\nr? @graydon", "tree": {"sha": "b1b5657b028f7a1c5253ae3bc8d87b806e464a6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1b5657b028f7a1c5253ae3bc8d87b806e464a6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b285f1e6c90332188bb720bf320c507fc4156fdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b285f1e6c90332188bb720bf320c507fc4156fdc", "html_url": "https://github.com/rust-lang/rust/commit/b285f1e6c90332188bb720bf320c507fc4156fdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b285f1e6c90332188bb720bf320c507fc4156fdc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63c62bea3ac2782ae421d5bd211f2e7393bad7a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/63c62bea3ac2782ae421d5bd211f2e7393bad7a2", "html_url": "https://github.com/rust-lang/rust/commit/63c62bea3ac2782ae421d5bd211f2e7393bad7a2"}, {"sha": "7343478d67ba3eb0c62dcc37db65d82d12b8e140", "url": "https://api.github.com/repos/rust-lang/rust/commits/7343478d67ba3eb0c62dcc37db65d82d12b8e140", "html_url": "https://github.com/rust-lang/rust/commit/7343478d67ba3eb0c62dcc37db65d82d12b8e140"}], "stats": {"total": 1715, "additions": 1155, "deletions": 560}, "files": [{"sha": "dae0ceed22d9dcc14b3d7045df97f2d0cbe33b9a", "filename": "src/librustc/back/abi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fabi.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -46,7 +46,8 @@ pub static tydesc_field_take_glue: uint = 2u;\n pub static tydesc_field_drop_glue: uint = 3u;\n pub static tydesc_field_free_glue: uint = 4u;\n pub static tydesc_field_visit_glue: uint = 5u;\n-pub static n_tydesc_fields: uint = 6u;\n+pub static tydesc_field_borrow_offset: uint = 6u;\n+pub static n_tydesc_fields: uint = 7u;\n \n // The two halves of a closure: code and environment.\n pub static fn_field_code: uint = 0u;"}, {"sha": "0e7dc3b2fcd914cd2da363cb745e7cef291e04b9", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -785,7 +785,7 @@ pub fn build_session(sopts: @session::options,\n pub fn build_session_(sopts: @session::options,\n                       cm: @codemap::CodeMap,\n                       demitter: diagnostic::Emitter,\n-                      span_diagnostic_handler: @diagnostic::span_handler)\n+                      span_diagnostic_handler: @mut diagnostic::span_handler)\n                    -> Session {\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,"}, {"sha": "cf62e35488b1fb37959877743f7df59f64e71609", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -192,7 +192,7 @@ pub struct Session_ {\n     // For a library crate, this is always none\n     entry_fn: @mut Option<(NodeId, codemap::span)>,\n     entry_type: @mut Option<EntryFnType>,\n-    span_diagnostic: @diagnostic::span_handler,\n+    span_diagnostic: @mut diagnostic::span_handler,\n     filesearch: @filesearch::FileSearch,\n     building_library: @mut bool,\n     working_dir: Path,\n@@ -261,7 +261,7 @@ impl Session_ {\n     pub fn next_node_id(@self) -> ast::NodeId {\n         return syntax::parse::next_node_id(self.parse_sess);\n     }\n-    pub fn diagnostic(@self) -> @diagnostic::span_handler {\n+    pub fn diagnostic(@self) -> @mut diagnostic::span_handler {\n         self.span_diagnostic\n     }\n     pub fn debugging_opt(@self, opt: uint) -> bool {"}, {"sha": "eaf01241c8165d0b9eebc00a591edccb5d233b3e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -29,7 +29,7 @@ use syntax::oldvisit;\n \n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n-pub fn read_crates(diag: @span_handler,\n+pub fn read_crates(diag: @mut span_handler,\n                    crate: &ast::Crate,\n                    cstore: @mut cstore::CStore,\n                    filesearch: @FileSearch,\n@@ -74,7 +74,7 @@ fn dump_crates(crate_cache: &[cache_entry]) {\n }\n \n fn warn_if_multiple_versions(e: @mut Env,\n-                             diag: @span_handler,\n+                             diag: @mut span_handler,\n                              crate_cache: &[cache_entry]) {\n     use std::either::*;\n \n@@ -113,7 +113,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n }\n \n struct Env {\n-    diag: @span_handler,\n+    diag: @mut span_handler,\n     filesearch: @FileSearch,\n     cstore: @mut cstore::CStore,\n     os: loader::os,"}, {"sha": "9366d757dd476befc73bda2253cb9311e929aaa0", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -55,7 +55,7 @@ pub type encode_inlined_item<'self> = &'self fn(ecx: &EncodeContext,\n                                    ii: ast::inlined_item);\n \n pub struct EncodeParams<'self> {\n-    diag: @span_handler,\n+    diag: @mut span_handler,\n     tcx: ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'self HashMap<ast::NodeId, ~str>,\n@@ -82,7 +82,7 @@ struct Stats {\n }\n \n pub struct EncodeContext<'self> {\n-    diag: @span_handler,\n+    diag: @mut span_handler,\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n     reexports2: middle::resolve::ExportMap2,"}, {"sha": "554cdf4b2b4feb13a9055357ec18cd10316e375f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -43,7 +43,7 @@ pub enum os {\n }\n \n pub struct Context {\n-    diag: @span_handler,\n+    diag: @mut span_handler,\n     filesearch: @FileSearch,\n     span: span,\n     ident: @str,\n@@ -163,7 +163,7 @@ pub fn package_id_from_metas(metas: &[@ast::MetaItem]) -> Option<@str> {\n }\n \n pub fn note_linkage_attrs(intr: @ident_interner,\n-                          diag: @span_handler,\n+                          diag: @mut span_handler,\n                           attrs: ~[ast::Attribute]) {\n     let r = attr::find_linkage_metas(attrs);\n     for mi in r.iter() {"}, {"sha": "915729d254f94a7c602421e3055a9ceda56a94e4", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -25,7 +25,7 @@ use syntax::diagnostic::span_handler;\n use syntax::print::pprust::*;\n \n pub struct ctxt {\n-    diag: @span_handler,\n+    diag: @mut span_handler,\n     // Def -> str Callback:\n     ds: @fn(def_id) -> ~str,\n     // The type context."}, {"sha": "d6342c582f0525dc21e9cbd5f5d30eb4b3218bf3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -586,8 +586,8 @@ impl tr for method_origin {\n                 }\n             )\n           }\n-          typeck::method_trait(did, m, vstore) => {\n-              typeck::method_trait(did.tr(xcx), m, vstore)\n+          typeck::method_trait(did, m) => {\n+              typeck::method_trait(did.tr(xcx), m)\n           }\n         }\n     }"}, {"sha": "620a1e9efe33f8095f1f795ed6e4c67a41c92d34", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -362,7 +362,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                     }\n \n                     mc::cat_discr(b, _) |\n-                    mc::cat_deref(b, _, mc::uniq_ptr(*)) => {\n+                    mc::cat_deref(b, _, mc::uniq_ptr) => {\n                         assert_eq!(cmt.mutbl, mc::McInherited);\n                         cmt = b;\n                     }"}, {"sha": "24a6e5b6e0b2b230cf4c5348c24466fa3e2606a7", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -173,7 +173,7 @@ fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n             }\n         }\n \n-        mc::cat_deref(b, _, mc::uniq_ptr(*)) |\n+        mc::cat_deref(b, _, mc::uniq_ptr) |\n         mc::cat_discr(b, _) => {\n             check_is_legal_to_move_from(bccx, cmt0, b)\n         }"}, {"sha": "b315a7a2e72908a677671cd90f6492f79cc1f295", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -74,7 +74,7 @@ impl GuaranteeLifetimeContext {\n             mc::cat_arg(*) |                           // L-Local\n             mc::cat_self(*) |                          // L-Local\n             mc::cat_deref(_, _, mc::region_ptr(*)) |   // L-Deref-Borrowed\n-            mc::cat_deref(_, _, mc::unsafe_ptr) => {\n+            mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n                 let scope = self.scope(cmt);\n                 self.check_scope(scope)\n             }\n@@ -108,7 +108,7 @@ impl GuaranteeLifetimeContext {\n             }\n \n             mc::cat_downcast(base) |\n-            mc::cat_deref(base, _, mc::uniq_ptr(*)) |  // L-Deref-Send\n+            mc::cat_deref(base, _, mc::uniq_ptr) |     // L-Deref-Send\n             mc::cat_interior(base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }\n@@ -347,7 +347,7 @@ impl GuaranteeLifetimeContext {\n                 r\n             }\n             mc::cat_downcast(cmt) |\n-            mc::cat_deref(cmt, _, mc::uniq_ptr(*)) |\n+            mc::cat_deref(cmt, _, mc::uniq_ptr) |\n             mc::cat_deref(cmt, _, mc::gc_ptr(*)) |\n             mc::cat_interior(cmt, _) |\n             mc::cat_stack_upvar(cmt) |"}, {"sha": "6ebc4b49b3779558199d300fe47e302d4534d273", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -352,13 +352,21 @@ impl GatherLoanCtxt {\n                                              r)\n                     }\n                     ty::AutoBorrowFn(r) => {\n-                        let cmt_deref = mcx.cat_deref_fn(expr, cmt, 0);\n+                        let cmt_deref = mcx.cat_deref_fn_or_obj(expr, cmt, 0);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_deref,\n                                              m_imm,\n                                              r)\n                     }\n+                    ty::AutoBorrowObj(r, m) => {\n+                        let cmt_deref = mcx.cat_deref_fn_or_obj(expr, cmt, 0);\n+                        self.guarantee_valid(expr.id,\n+                                             expr.span,\n+                                             cmt_deref,\n+                                             m,\n+                                             r)\n+                    }\n                     ty::AutoUnsafe(_) => {}\n                 }\n             }"}, {"sha": "46bb23e400ee59df4759812ca9fa233d29c40cba", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -101,7 +101,7 @@ impl RestrictionsContext {\n                 self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n             }\n \n-            mc::cat_deref(cmt_base, _, mc::uniq_ptr(*)) => {\n+            mc::cat_deref(cmt_base, _, mc::uniq_ptr) => {\n                 // R-Deref-Send-Pointer\n                 //\n                 // When we borrow the interior of an owned pointer, we\n@@ -194,7 +194,7 @@ impl RestrictionsContext {\n                 }\n             }\n \n-            mc::cat_deref(_, _, mc::unsafe_ptr) => {\n+            mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n                 // We are very trusting when working with unsafe pointers.\n                 Safe\n             }"}, {"sha": "76532b5cd22d6c6c835c71464b8cfff089ee2e1d", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -301,7 +301,7 @@ enum AnyVisitor {\n     // recursive call can use the original visitor's method, although the\n     // recursing visitor supplied to the method is the item stopping visitor.\n     OldVisitor(oldvisit::vt<@mut Context>, oldvisit::vt<@mut Context>),\n-    NewVisitor(@visit::Visitor<()>),\n+    NewVisitor(@mut visit::Visitor<()>),\n }\n \n struct Context {\n@@ -465,7 +465,7 @@ impl Context {\n         self.visitors.push(OldVisitor(v, item_stopping_visitor(v)));\n     }\n \n-    fn add_lint(&mut self, v: @visit::Visitor<()>) {\n+    fn add_lint(&mut self, v: @mut visit::Visitor<()>) {\n         self.visitors.push(NewVisitor(v));\n     }\n \n@@ -989,7 +989,7 @@ fn lint_unused_mut() -> oldvisit::vt<@mut Context> {\n     })\n }\n \n-fn lint_session(cx: @mut Context) -> @visit::Visitor<()> {\n+fn lint_session(cx: @mut Context) -> @mut visit::Visitor<()> {\n     ast_util::id_visitor(|id| {\n         match cx.tcx.sess.lints.pop(&id) {\n             None => {},"}, {"sha": "283724447f831fab8fadc2b5adfca1fb0ae96cbf", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -84,10 +84,10 @@ pub struct CopiedUpvar {\n // different kinds of pointers:\n #[deriving(Eq)]\n pub enum ptr_kind {\n-    uniq_ptr(ast::mutability),\n+    uniq_ptr,\n     gc_ptr(ast::mutability),\n     region_ptr(ast::mutability, ty::Region),\n-    unsafe_ptr\n+    unsafe_ptr(ast::mutability)\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n@@ -156,39 +156,45 @@ pub enum deref_kind {\n // pointer adjustment).\n pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n-        ty::ty_uniq(mt) => {\n-            Some(deref_ptr(uniq_ptr(mt.mutbl)))\n-        }\n-\n+        ty::ty_uniq(_) |\n+        ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n         ty::ty_evec(_, ty::vstore_uniq) |\n         ty::ty_estr(ty::vstore_uniq) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n-            Some(deref_ptr(uniq_ptr(m_imm)))\n+            Some(deref_ptr(uniq_ptr))\n         }\n \n         ty::ty_rptr(r, mt) |\n         ty::ty_evec(mt, ty::vstore_slice(r)) => {\n             Some(deref_ptr(region_ptr(mt.mutbl, r)))\n         }\n \n+        ty::ty_trait(_, _, ty::RegionTraitStore(r), m, _) => {\n+            Some(deref_ptr(region_ptr(m, r)))\n+        }\n+\n         ty::ty_estr(ty::vstore_slice(r)) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n                                       region: r, _}) => {\n             Some(deref_ptr(region_ptr(ast::m_imm, r)))\n         }\n \n-        ty::ty_box(mt) |\n-        ty::ty_evec(mt, ty::vstore_box) => {\n+        ty::ty_box(ref mt) |\n+        ty::ty_evec(ref mt, ty::vstore_box) => {\n             Some(deref_ptr(gc_ptr(mt.mutbl)))\n         }\n \n+        ty::ty_trait(_, _, ty::BoxTraitStore, m, _) => {\n+            Some(deref_ptr(gc_ptr(m)))\n+        }\n+\n         ty::ty_estr(ty::vstore_box) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::ManagedSigil, _}) => {\n             Some(deref_ptr(gc_ptr(ast::m_imm)))\n         }\n \n-        ty::ty_ptr(*) => {\n-            Some(deref_ptr(unsafe_ptr))\n+        ty::ty_ptr(ref mt) => {\n+            Some(deref_ptr(unsafe_ptr(mt.mutbl)))\n         }\n \n         ty::ty_enum(*) |\n@@ -631,20 +637,19 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_deref_fn<N:ast_node>(&self,\n-                                    node: N,\n-                                    base_cmt: cmt,\n-                                    deref_cnt: uint)\n-                                    -> cmt {\n+    pub fn cat_deref_fn_or_obj<N:ast_node>(&self,\n+                                           node: N,\n+                                           base_cmt: cmt,\n+                                           deref_cnt: uint)\n+                                           -> cmt {\n         // Bit of a hack: the \"dereference\" of a function pointer like\n         // `@fn()` is a mere logical concept. We interpret it as\n         // dereferencing the environment pointer; of course, we don't\n         // know what type lies at the other end, so we just call it\n         // `()` (the empty tuple).\n \n-        let mt = ty::mt {ty: ty::mk_tup(self.tcx, ~[]),\n-                         mutbl: m_imm};\n-        return self.cat_deref_common(node, base_cmt, deref_cnt, mt);\n+        let opaque_ty = ty::mk_tup(self.tcx, ~[]);\n+        return self.cat_deref_common(node, base_cmt, deref_cnt, opaque_ty);\n     }\n \n     pub fn cat_deref<N:ast_node>(&self,\n@@ -662,25 +667,25 @@ impl mem_categorization_ctxt {\n             }\n         };\n \n-        return self.cat_deref_common(node, base_cmt, deref_cnt, mt);\n+        return self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty);\n     }\n \n     pub fn cat_deref_common<N:ast_node>(&self,\n                                         node: N,\n                                         base_cmt: cmt,\n                                         deref_cnt: uint,\n-                                        mt: ty::mt)\n+                                        deref_ty: ty::t)\n                                         -> cmt {\n         match deref_kind(self.tcx, base_cmt.ty) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n                 let m = match ptr {\n-                    uniq_ptr(*) => {\n-                        self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n+                    uniq_ptr => {\n+                        base_cmt.mutbl.inherit()\n                     }\n-                    gc_ptr(*) | region_ptr(_, _) | unsafe_ptr => {\n-                        MutabilityCategory::from_mutbl(mt.mutbl)\n+                    gc_ptr(m) | region_ptr(m, _) | unsafe_ptr(m) => {\n+                        MutabilityCategory::from_mutbl(m)\n                     }\n                 };\n \n@@ -689,18 +694,18 @@ impl mem_categorization_ctxt {\n                     span:node.span(),\n                     cat:cat_deref(base_cmt, deref_cnt, ptr),\n                     mutbl:m,\n-                    ty:mt.ty\n+                    ty:deref_ty\n                 }\n             }\n \n             deref_interior(interior) => {\n-                let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n+                let m = base_cmt.mutbl.inherit();\n                 @cmt_ {\n                     id:node.id(),\n                     span:node.span(),\n                     cat:cat_interior(base_cmt, interior),\n                     mutbl:m,\n-                    ty:mt.ty\n+                    ty:deref_ty\n                 }\n             }\n         }\n@@ -742,8 +747,8 @@ impl mem_categorization_ctxt {\n         //! - `derefs`: the deref number to be used for\n         //!   the implicit index deref, if any (see above)\n \n-        let mt = match ty::index(base_cmt.ty) {\n-          Some(mt) => mt,\n+        let element_ty = match ty::index(base_cmt.ty) {\n+          Some(ref mt) => mt.ty,\n           None => {\n             self.tcx.sess.span_bug(\n                 elt.span(),\n@@ -757,11 +762,11 @@ impl mem_categorization_ctxt {\n             // for unique ptrs, we inherit mutability from the\n             // owning reference.\n             let m = match ptr {\n-              uniq_ptr(*) => {\n-                self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n+              uniq_ptr => {\n+                base_cmt.mutbl.inherit()\n               }\n-              gc_ptr(_) | region_ptr(_, _) | unsafe_ptr => {\n-                MutabilityCategory::from_mutbl(mt.mutbl)\n+              gc_ptr(m) | region_ptr(m, _) | unsafe_ptr(m) => {\n+                MutabilityCategory::from_mutbl(m)\n               }\n             };\n \n@@ -771,31 +776,31 @@ impl mem_categorization_ctxt {\n                 span:elt.span(),\n                 cat:cat_deref(base_cmt, derefs, ptr),\n                 mutbl:m,\n-                ty:mt.ty\n+                ty:element_ty\n             };\n \n-            interior(elt, deref_cmt, base_cmt.ty, m, mt)\n+            interior(elt, deref_cmt, base_cmt.ty, m, element_ty)\n           }\n \n           deref_interior(_) => {\n             // fixed-length vectors have no deref\n-            let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n-            interior(elt, base_cmt, base_cmt.ty, m, mt)\n+            let m = base_cmt.mutbl.inherit();\n+            interior(elt, base_cmt, base_cmt.ty, m, element_ty)\n           }\n         };\n \n         fn interior<N: ast_node>(elt: N,\n                                  of_cmt: cmt,\n                                  vec_ty: ty::t,\n                                  mutbl: MutabilityCategory,\n-                                 mt: ty::mt) -> cmt\n+                                 element_ty: ty::t) -> cmt\n         {\n             @cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n                 cat:cat_interior(of_cmt, InteriorElement(element_kind(vec_ty))),\n                 mutbl:mutbl,\n-                ty:mt.ty\n+                ty:element_ty\n             }\n         }\n     }\n@@ -1130,7 +1135,7 @@ impl cmt_ {\n             cat_stack_upvar(b) |\n             cat_discr(b, _) |\n             cat_interior(b, _) |\n-            cat_deref(b, _, uniq_ptr(*)) => {\n+            cat_deref(b, _, uniq_ptr) => {\n                 b.guarantor()\n             }\n         }\n@@ -1177,7 +1182,7 @@ impl cmt_ {\n \n             cat_downcast(b) |\n             cat_stack_upvar(b) |\n-            cat_deref(b, _, uniq_ptr(*)) |\n+            cat_deref(b, _, uniq_ptr) |\n             cat_interior(b, _) |\n             cat_discr(b, _) => {\n                 b.freely_aliasable()\n@@ -1230,10 +1235,10 @@ impl Repr for categorization {\n \n pub fn ptr_sigil(ptr: ptr_kind) -> ~str {\n     match ptr {\n-        uniq_ptr(_) => ~\"~\",\n+        uniq_ptr => ~\"~\",\n         gc_ptr(_) => ~\"@\",\n         region_ptr(_, _) => ~\"&\",\n-        unsafe_ptr => ~\"*\"\n+        unsafe_ptr(_) => ~\"*\"\n     }\n }\n "}, {"sha": "aa7b2e55cdc63b423f0b3a06d4b20ba6ace48ece", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -290,7 +290,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                  method_num: method_num,\n                  _\n             }) |\n-            method_trait(trait_id, method_num, _) => {\n+            method_trait(trait_id, method_num) => {\n                 if trait_id.crate == LOCAL_CRATE {\n                     match tcx.items.find(&trait_id.node) {\n                         Some(&node_item(item, _)) => {"}, {"sha": "1291a586682abc7438d35cc48b0223fb7b6041f7", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -2405,12 +2405,7 @@ pub fn fill_fn_pair(bcx: @mut Block, pair: ValueRef, llfn: ValueRef,\n }\n \n pub fn item_path(ccx: &CrateContext, id: &ast::NodeId) -> path {\n-    match ccx.tcx.items.get_copy(id) {\n-        ast_map::node_item(i, p) =>\n-            vec::append((*p).clone(), [path_name(i.ident)]),\n-        // separate map for paths?\n-        _ => fail!(\"item_path\")\n-    }\n+    ty::item_path(ccx.tcx, ast_util::local_def(*id))\n }\n \n fn exported_name(ccx: @mut CrateContext, path: path, ty: ty::t, attrs: &[ast::Attribute]) -> ~str {"}, {"sha": "4caaf384873511c1dc8865f2bdcd895e7338781e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -60,7 +60,6 @@ pub struct MethodData {\n     llfn: ValueRef,\n     llself: ValueRef,\n     temp_cleanup: Option<ValueRef>,\n-    self_ty: ty::t,\n     self_mode: ty::SelfMode,\n }\n "}, {"sha": "3253e24ae8898a6045131d8c7e98727c960da635", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -54,6 +54,7 @@ pub struct tydesc_info {\n     tydesc: ValueRef,\n     size: ValueRef,\n     align: ValueRef,\n+    borrow_offset: ValueRef,\n     take_glue: Option<ValueRef>,\n     drop_glue: Option<ValueRef>,\n     free_glue: Option<ValueRef>,\n@@ -686,7 +687,6 @@ pub fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n                          t]);\n }\n \n-\n // LLVM constant constructors.\n pub fn C_null(t: Type) -> ValueRef {\n     unsafe {"}, {"sha": "187c121bbd33799b642c70304244213272a7f5f0", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -13,7 +13,7 @@ use back::{upcall};\n use driver::session;\n use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n use lib::llvm::{llvm, TargetData, TypeNames};\n-use lib::llvm::{mk_target_data};\n+use lib::llvm::{mk_target_data, False};\n use metadata::common::LinkMeta;\n use middle::astencode;\n use middle::resolve;\n@@ -22,6 +22,7 @@ use middle::trans::base;\n use middle::trans::builder::Builder;\n use middle::trans::debuginfo;\n use middle::trans::type_use;\n+use middle::trans::common::{C_i32, C_null};\n use middle::ty;\n \n use middle::trans::type_::Type;\n@@ -30,6 +31,8 @@ use std::c_str::ToCStr;\n use std::hash;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n+use std::vec;\n+use std::libc::c_uint;\n use syntax::ast;\n \n use middle::trans::common::{mono_id,ExternMap,tydesc_info,BuilderRef_res,Stats};\n@@ -236,6 +239,36 @@ impl CrateContext {\n     pub fn builder(@mut self) -> Builder {\n         Builder::new(self)\n     }\n+\n+    pub fn const_inbounds_gepi(&self,\n+                               pointer: ValueRef,\n+                               indices: &[uint]) -> ValueRef {\n+        debug!(\"const_inbounds_gepi: pointer=%s indices=%?\",\n+               self.tn.val_to_str(pointer), indices);\n+        let v: ~[ValueRef] =\n+            indices.iter().map(|i| C_i32(*i as i32)).collect();\n+        unsafe {\n+            llvm::LLVMConstInBoundsGEP(pointer,\n+                                       vec::raw::to_ptr(v),\n+                                       indices.len() as c_uint)\n+        }\n+    }\n+\n+    pub fn offsetof_gep(&self,\n+                        llptr_ty: Type,\n+                        indices: &[uint]) -> ValueRef {\n+        /*!\n+         * Returns the offset of applying the given GEP indices\n+         * to an instance of `llptr_ty`. Similar to `offsetof` in C,\n+         * except that `llptr_ty` must be a pointer type.\n+         */\n+\n+        unsafe {\n+            let null = C_null(llptr_ty);\n+            llvm::LLVMConstPtrToInt(self.const_inbounds_gepi(null, indices),\n+                                    self.int_type.to_ref())\n+        }\n+    }\n }\n \n #[unsafe_destructor]"}, {"sha": "cb4a7f364dac6c39c11a21cb704161abaea696ea", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 98, "deletions": 3, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -137,9 +137,8 @@ use middle::trans::meth;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty::struct_fields;\n-use middle::ty::{AutoDerefRef, AutoAddEnv};\n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn,\n-                 AutoUnsafe};\n+use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoUnsafe};\n+use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::Repr;\n@@ -223,6 +222,10 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n                                                     datum.ty, Some(adjustment));\n                     unpack_datum!(bcx, auto_borrow_fn(bcx, adjusted_ty, datum))\n                 }\n+                Some(AutoBorrowObj(*)) => {\n+                    unpack_datum!(bcx, auto_borrow_obj(\n+                        bcx, adj.autoderefs, expr, datum))\n+                }\n             };\n         }\n     }\n@@ -298,6 +301,98 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n         let DatumBlock { bcx, datum } = auto_slice(bcx, autoderefs, expr, datum);\n         auto_ref(bcx, datum)\n     }\n+\n+    fn auto_borrow_obj(mut bcx: @mut Block,\n+                       autoderefs: uint,\n+                       expr: @ast::expr,\n+                       source_datum: Datum) -> DatumBlock {\n+        let tcx = bcx.tcx();\n+        let target_obj_ty = expr_ty_adjusted(bcx, expr);\n+        debug!(\"auto_borrow_obj(target=%s)\",\n+               target_obj_ty.repr(tcx));\n+        let scratch = scratch_datum(bcx, target_obj_ty,\n+                                    \"__auto_borrow_obj\", false);\n+\n+        // Convert a @Object, ~Object, or &Object pair into an &Object pair.\n+\n+        // Get a pointer to the source object, which is represented as\n+        // a (vtable, data) pair.\n+        let source_llval = source_datum.to_ref_llval(bcx);\n+\n+        // Set the vtable field of the new pair\n+        let vtable_ptr = GEPi(bcx, source_llval, [0u, abi::trt_field_vtable]);\n+        let vtable = Load(bcx, vtable_ptr);\n+        Store(bcx, vtable, GEPi(bcx, scratch.val, [0u, abi::trt_field_vtable]));\n+\n+        // Load the data for the source, which is either an @T,\n+        // ~T, or &T, depending on source_obj_ty.\n+        let source_data_ptr = GEPi(bcx, source_llval, [0u, abi::trt_field_box]);\n+        let source_data = Load(bcx, source_data_ptr); // always a ptr\n+        let (source_store, source_mutbl) = match ty::get(source_datum.ty).sty {\n+            ty::ty_trait(_, _, s, m, _) => (s, m),\n+            _ => {\n+                bcx.sess().span_bug(\n+                    expr.span,\n+                    fmt!(\"auto_borrow_trait_obj expected a trait, found %s\",\n+                         source_datum.ty.repr(bcx.tcx())));\n+            }\n+        };\n+        let target_data = match source_store {\n+            ty::BoxTraitStore(*) => {\n+                // For deref of @T or @mut T, create a dummy datum and\n+                // use the datum's deref method. This is more work\n+                // than just calling GEPi ourselves, but it ensures\n+                // that any write guards will be appropriate\n+                // processed.  Note that we don't know the type T, so\n+                // just substitute `i8`-- it doesn't really matter for\n+                // our purposes right now.\n+                let source_ty =\n+                    ty::mk_box(tcx,\n+                               ty::mt {\n+                                   ty: ty::mk_i8(),\n+                                   mutbl: source_mutbl});\n+                let source_datum =\n+                    Datum {val: source_data,\n+                           ty: source_ty,\n+                           mode: ByValue};\n+                let derefd_datum =\n+                    unpack_datum!(bcx,\n+                                  source_datum.deref(bcx,\n+                                                     expr,\n+                                                     autoderefs));\n+                derefd_datum.to_rptr(bcx).to_value_llval(bcx)\n+            }\n+            ty::UniqTraitStore(*) => {\n+                // For a ~T box, there may or may not be a header,\n+                // depending on whether the type T references managed\n+                // boxes. However, since we do not *know* the type T\n+                // for objects, this presents a hurdle. Our solution is\n+                // to load the \"borrow offset\" from the type descriptor;\n+                // this value will either be 0 or sizeof(BoxHeader), depending\n+                // on the type T.\n+                let llopaque =\n+                    PointerCast(bcx, source_data, Type::opaque().ptr_to());\n+                let lltydesc_ptr_ptr =\n+                    PointerCast(bcx, vtable,\n+                                bcx.ccx().tydesc_type.ptr_to().ptr_to());\n+                let lltydesc_ptr =\n+                    Load(bcx, lltydesc_ptr_ptr);\n+                let borrow_offset_ptr =\n+                    GEPi(bcx, lltydesc_ptr,\n+                         [0, abi::tydesc_field_borrow_offset]);\n+                let borrow_offset =\n+                    Load(bcx, borrow_offset_ptr);\n+                InBoundsGEP(bcx, llopaque, [borrow_offset])\n+            }\n+            ty::RegionTraitStore(*) => {\n+                source_data\n+            }\n+        };\n+        Store(bcx, target_data,\n+              GEPi(bcx, scratch.val, [0u, abi::trt_field_box]));\n+\n+        DatumBlock { bcx: bcx, datum: scratch }\n+    }\n }\n \n pub fn trans_into(bcx: @mut Block, expr: @ast::expr, dest: Dest) -> @mut Block {"}, {"sha": "7694f690286b77c7c83edb15f3c56fbcc9144b0b", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -857,8 +857,6 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         \"visit_tydesc\" => {\n             let td = get_param(decl, first_real_arg);\n             let visitor = get_param(decl, first_real_arg + 1u);\n-            //let llvisitorptr = alloca(bcx, val_ty(visitor));\n-            //Store(bcx, visitor, llvisitorptr);\n             let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n             glue::call_tydesc_glue_full(bcx, visitor, td,\n                                         abi::tydesc_field_visit_glue, None);"}, {"sha": "4f894deb1a1c19eed3d692569ea876997395a246", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -348,7 +348,8 @@ pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     let _icx = push_ctxt(\"make_visit_glue\");\n     do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n         let mut bcx = bcx;\n-        let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx()){\n+        let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx(),\n+                                                                     ty::re_static) {\n             Ok(pair) => pair,\n             Err(s) => {\n                 bcx.tcx().sess.fatal(s);\n@@ -655,6 +656,18 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n                   ppaux::ty_to_str(ccx.tcx, t));\n     }\n \n+    let has_header = match ty::get(t).sty {\n+        ty::ty_box(*) => true,\n+        ty::ty_uniq(*) => ty::type_contents(ccx.tcx, t).contains_managed(),\n+        _ => false\n+    };\n+\n+    let borrow_offset = if has_header {\n+        ccx.offsetof_gep(llty, [0u, abi::box_field_body])\n+    } else {\n+        C_uint(ccx, 0)\n+    };\n+\n     let llsize = llsize_of(ccx, llty);\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n@@ -670,6 +683,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n         tydesc: gvar,\n         size: llsize,\n         align: llalign,\n+        borrow_offset: borrow_offset,\n         take_glue: None,\n         drop_glue: None,\n         free_glue: None,\n@@ -785,13 +799,17 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               }\n             };\n \n+        debug!(\"ti.borrow_offset: %s\",\n+               ccx.tn.val_to_str(ti.borrow_offset));\n+\n         let tydesc = C_named_struct(ccx.tydesc_type,\n                                     [ti.size, // size\n-                                    ti.align, // align\n-                                    take_glue, // take_glue\n-                                    drop_glue, // drop_glue\n-                                    free_glue, // free_glue\n-                                    visit_glue]); // visit_glue\n+                                     ti.align, // align\n+                                     take_glue, // take_glue\n+                                     drop_glue, // drop_glue\n+                                     free_glue, // free_glue\n+                                     visit_glue, // visit_glue\n+                                     ti.borrow_offset]); // borrow_offset\n \n         unsafe {\n             let gvar = ti.tydesc;"}, {"sha": "f5b2ff755966e6cf3f29ff2f7b2cb2fe26202d19", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 39, "deletions": 107, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -164,7 +164,6 @@ pub fn trans_method_callee(bcx: @mut Block,\n                     llfn: callee_fn.llfn,\n                     llself: val,\n                     temp_cleanup: temp_cleanups.head_opt().map_move(|v| *v),\n-                    self_ty: node_id_type(bcx, this.id),\n                     self_mode: mentry.self_mode,\n                 })\n             }\n@@ -187,13 +186,11 @@ pub fn trans_method_callee(bcx: @mut Block,\n             }\n         }\n \n-        typeck::method_trait(_, off, store) => {\n+        typeck::method_trait(_, off) => {\n             trans_trait_callee(bcx,\n                                callee_id,\n                                off,\n-                               this,\n-                               store,\n-                               mentry.explicit_self)\n+                               this)\n         }\n     }\n }\n@@ -341,7 +338,6 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n                   llfn: llfn_val,\n                   llself: llself_val,\n                   temp_cleanup: temp_cleanups.head_opt().map_move(|v| *v),\n-                  self_ty: node_id_type(bcx, base.id),\n                   self_mode: mentry.self_mode,\n               })\n           }\n@@ -406,142 +402,78 @@ pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n pub fn trans_trait_callee(bcx: @mut Block,\n                           callee_id: ast::NodeId,\n                           n_method: uint,\n-                          self_expr: @ast::expr,\n-                          store: ty::TraitStore,\n-                          explicit_self: ast::explicit_self_)\n+                          self_expr: @ast::expr)\n                           -> Callee {\n-    //!\n-    //\n-    // Create a method callee where the method is coming from a trait\n-    // instance (e.g., @Trait type).  In this case, we must pull the\n-    // fn pointer out of the vtable that is packaged up with the\n-    // @/~/&Trait instance.  @/~/&Traits are represented as a pair, so we\n-    // first evaluate the self expression (expected a by-ref result) and then\n-    // extract the self data and vtable out of the pair.\n+    /*!\n+     * Create a method callee where the method is coming from a trait\n+     * object (e.g., @Trait type).  In this case, we must pull the fn\n+     * pointer out of the vtable that is packaged up with the object.\n+     * Objects are represented as a pair, so we first evaluate the self\n+     * expression and then extract the self data and vtable out of the\n+     * pair.\n+     */\n \n     let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let mut bcx = bcx;\n-    let self_datum = unpack_datum!(bcx,\n-        expr::trans_to_datum(bcx, self_expr));\n-    let llpair = self_datum.to_ref_llval(bcx);\n-\n-    let llpair = match explicit_self {\n-        ast::sty_region(*) => Load(bcx, llpair),\n-        ast::sty_static | ast::sty_value |\n-        ast::sty_box(_) | ast::sty_uniq => llpair\n-    };\n+\n+    let self_ty = expr_ty_adjusted(bcx, self_expr);\n+    let self_scratch = scratch_datum(bcx, self_ty, \"__trait_callee\", false);\n+    bcx = expr::trans_into(bcx, self_expr, expr::SaveIn(self_scratch.val));\n+\n+    // Arrange a temporary cleanup for the object in case something\n+    // should go wrong before the method is actually *invoked*.\n+    self_scratch.add_clean(bcx);\n \n     let callee_ty = node_id_type(bcx, callee_id);\n     trans_trait_callee_from_llval(bcx,\n                                   callee_ty,\n                                   n_method,\n-                                  llpair,\n-                                  store,\n-                                  explicit_self)\n+                                  self_scratch.val,\n+                                  Some(self_scratch.val))\n }\n \n pub fn trans_trait_callee_from_llval(bcx: @mut Block,\n                                      callee_ty: ty::t,\n                                      n_method: uint,\n                                      llpair: ValueRef,\n-                                     store: ty::TraitStore,\n-                                     explicit_self: ast::explicit_self_)\n+                                     temp_cleanup: Option<ValueRef>)\n                                   -> Callee {\n-    //!\n-    //\n-    // Same as `trans_trait_callee()` above, except that it is given\n-    // a by-ref pointer to the @Trait pair.\n+    /*!\n+     * Same as `trans_trait_callee()` above, except that it is given\n+     * a by-ref pointer to the object pair.\n+     */\n \n     let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n \n-    // Load the vtable from the @Trait pair\n-    debug!(\"(translating trait callee) loading vtable from pair %s\",\n-           bcx.val_to_str(llpair));\n-    let llvtable = Load(bcx,\n-                      PointerCast(bcx,\n-                                  GEPi(bcx, llpair,\n-                                       [0u, abi::trt_field_vtable]),\n-                                  Type::vtable().ptr_to().ptr_to()));\n-\n-    // Load the box from the @Trait pair and GEP over the box header if\n-    // necessary:\n-    let mut llself;\n+    // Load the data pointer from the object.\n     debug!(\"(translating trait callee) loading second index from pair\");\n     let llboxptr = GEPi(bcx, llpair, [0u, abi::trt_field_box]);\n     let llbox = Load(bcx, llboxptr);\n-\n-    // Munge `llself` appropriately for the type of `self` in the method.\n-    match explicit_self {\n-        ast::sty_static => {\n-            bcx.tcx().sess.bug(\"shouldn't see static method here\");\n-        }\n-        ast::sty_value => {\n-            bcx.tcx().sess.bug(\"methods with by-value self should not be \\\n-                                called on objects\");\n-        }\n-        ast::sty_region(*) => {\n-            match store {\n-                ty::UniqTraitStore\n-                    if !ty::type_contents(bcx.tcx(), callee_ty).contains_managed() => {\n-                    llself = llbox;\n-                }\n-                ty::BoxTraitStore |\n-                ty::UniqTraitStore => {\n-                    llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n-                }\n-                ty::RegionTraitStore(_) => {\n-                    llself = llbox;\n-                }\n-            }\n-        }\n-        ast::sty_box(_) => {\n-            // Bump the reference count on the box.\n-            debug!(\"(translating trait callee) callee type is `%s`\",\n-                   bcx.ty_to_str(callee_ty));\n-            glue::incr_refcnt_of_boxed(bcx, llbox);\n-\n-            // Pass a pointer to the box.\n-            match store {\n-                ty::BoxTraitStore => llself = llbox,\n-                _ => bcx.tcx().sess.bug(\"@self receiver with non-@Trait\")\n-            }\n-        }\n-        ast::sty_uniq => {\n-            // Pass the unique pointer.\n-            match store {\n-                ty::UniqTraitStore => llself = llbox,\n-                _ => bcx.tcx().sess.bug(\"~self receiver with non-~Trait\")\n-            }\n-\n-            zero_mem(bcx, llboxptr, ty::mk_opaque_box(bcx.tcx()));\n-        }\n-    }\n-\n-    llself = PointerCast(bcx, llself, Type::opaque_box(ccx).ptr_to());\n-    let scratch = scratch_datum(bcx, ty::mk_opaque_box(bcx.tcx()),\n-                                \"__trait_callee\", false);\n-    Store(bcx, llself, scratch.val);\n-    scratch.add_clean(bcx);\n+    let llself = PointerCast(bcx, llbox, Type::opaque_box(ccx).ptr_to());\n \n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n     let llcallee_ty = type_of_fn_from_ty(ccx, callee_ty);\n-\n-    // Plus one in order to skip past the type descriptor.\n+    let llvtable = Load(bcx,\n+                        PointerCast(bcx,\n+                                    GEPi(bcx, llpair,\n+                                         [0u, abi::trt_field_vtable]),\n+                                    Type::vtable().ptr_to().ptr_to()));\n     let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method + 1]));\n-\n     let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n     return Callee {\n         bcx: bcx,\n         data: Method(MethodData {\n             llfn: mptr,\n-            llself: scratch.to_value_llval(bcx),\n-            temp_cleanup: Some(scratch.val),\n-            self_ty: scratch.ty,\n+            llself: llself,\n+            temp_cleanup: temp_cleanup,\n+\n+                // We know that the func declaration is &self, ~self,\n+                // or @self, and such functions are always by-copy\n+                // (right now, at least).\n             self_mode: ty::ByCopy,\n-            /* XXX: Some(llbox) */\n         })\n     };\n }"}, {"sha": "fe5f8cd70ef19ba1d7f366c9373067b183634024", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -100,17 +100,13 @@ impl Reflector {\n             debug!(\"arg %u: %s\", i, bcx.val_to_str(*a));\n         }\n         let bool_ty = ty::mk_bool();\n-        // XXX: Should not be BoxTraitStore!\n         let result = unpack_result!(bcx, callee::trans_call_inner(\n             self.bcx, None, mth_ty, bool_ty,\n             |bcx| meth::trans_trait_callee_from_llval(bcx,\n                                                       mth_ty,\n                                                       mth_idx,\n                                                       v,\n-                                                      ty::BoxTraitStore,\n-                                                      ast::sty_region(\n-                                                        None,\n-                                                        ast::m_imm)),\n+                                                      None),\n             ArgVals(args), None, DontAutorefArg));\n         let result = bool_to_i1(bcx, result);\n         let next_bcx = sub_block(bcx, \"next\");"}, {"sha": "8d94a0d10d6fae3c71e2b5754b157886cd3fb334", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -205,10 +205,18 @@ impl Type {\n \n         let int_ty = Type::int(arch);\n \n-        let elems = [\n-            int_ty, int_ty,\n-            glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty\n-        ];\n+        // Must mirror:\n+        //\n+        // std::unstable::intrinsics::TyDesc\n+        // type_desc in rt\n+\n+        let elems = [int_ty,     // size\n+                     int_ty,     // align\n+                     glue_fn_ty, // take\n+                     glue_fn_ty, // drop\n+                     glue_fn_ty, // free\n+                     glue_fn_ty, // visit\n+                     int_ty];    // borrow_offset\n \n         tydesc.set_struct_body(elems, false);\n \n@@ -249,8 +257,12 @@ impl Type {\n         Type::struct_(Type::box_header_fields(ctx) + &[*ty], false)\n     }\n \n+    pub fn opaque() -> Type {\n+        Type::i8()\n+    }\n+\n     pub fn opaque_box(ctx: &CrateContext) -> Type {\n-        Type::box(ctx, &Type::i8())\n+        Type::box(ctx, &Type::opaque())\n     }\n \n     pub fn unique(ctx: &CrateContext, ty: &Type) -> Type {"}, {"sha": "2ba6930d9c5ea5193cd41e6071703708fc47984c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -226,13 +226,16 @@ pub enum AutoRef {\n     AutoBorrowFn(Region),\n \n     /// Convert from T to *T\n-    AutoUnsafe(ast::mutability)\n+    AutoUnsafe(ast::mutability),\n+\n+    /// Convert from @Trait/~Trait/&Trait to &Trait\n+    AutoBorrowObj(Region, ast::mutability),\n }\n \n pub type ctxt = @ctxt_;\n \n struct ctxt_ {\n-    diag: @syntax::diagnostic::span_handler,\n+    diag: @mut syntax::diagnostic::span_handler,\n     interner: @mut HashMap<intern_key, ~t_box_>,\n     next_id: @mut uint,\n     cstore: @mut metadata::cstore::CStore,\n@@ -1004,7 +1007,13 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n       &ty_self(_) => flags |= has_self as uint,\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) |\n       &ty_trait(_, ref substs, _, _, _) => {\n-        flags |= sflags(substs);\n+          flags |= sflags(substs);\n+          match st {\n+              ty_trait(_, _, RegionTraitStore(r), _, _) => {\n+                    flags |= rflags(r);\n+                }\n+              _ => {}\n+          }\n       }\n       &ty_box(ref m) | &ty_uniq(ref m) | &ty_evec(ref m, _) |\n       &ty_ptr(ref m) | &ty_unboxed_vec(ref m) => {\n@@ -3009,6 +3018,10 @@ pub fn adjust_ty(cx: ctxt,\n                         AutoUnsafe(m) => {\n                             mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n                         }\n+\n+                        AutoBorrowObj(r, m) => {\n+                            borrow_obj(cx, span, r, m, adjusted_ty)\n+                        }\n                     }\n                 }\n             }\n@@ -3054,6 +3067,22 @@ pub fn adjust_ty(cx: ctxt,\n             }\n         }\n     }\n+\n+    fn borrow_obj(cx: ctxt, span: span, r: Region,\n+                  m: ast::mutability, ty: ty::t) -> ty::t {\n+        match get(ty).sty {\n+            ty_trait(trt_did, ref trt_substs, _, _, b) => {\n+                ty::mk_trait(cx, trt_did, trt_substs.clone(),\n+                             RegionTraitStore(r), m, b)\n+            }\n+            ref s => {\n+                cx.sess.span_bug(\n+                    span,\n+                    fmt!(\"borrow-trait-obj associated with bad sty: %?\",\n+                         s));\n+            }\n+        }\n+    }\n }\n \n impl AutoRef {\n@@ -3064,6 +3093,7 @@ impl AutoRef {\n             ty::AutoBorrowVecRef(r, m) => ty::AutoBorrowVecRef(f(r), m),\n             ty::AutoBorrowFn(r) => ty::AutoBorrowFn(f(r)),\n             ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n+            ty::AutoBorrowObj(r, m) => ty::AutoBorrowObj(f(r), m),\n         }\n     }\n }\n@@ -3101,7 +3131,7 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n           typeck::method_param(typeck::method_param {\n               trait_id: trt_id,\n               method_num: n_mth, _}) |\n-          typeck::method_trait(trt_id, n_mth, _) => {\n+          typeck::method_trait(trt_id, n_mth) => {\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n@@ -4457,7 +4487,8 @@ pub fn get_opaque_ty(tcx: ctxt) -> Result<t, ~str> {\n     }\n }\n \n-pub fn visitor_object_ty(tcx: ctxt) -> Result<(@TraitRef, t), ~str> {\n+pub fn visitor_object_ty(tcx: ctxt,\n+                         region: ty::Region) -> Result<(@TraitRef, t), ~str> {\n     let trait_lang_item = match tcx.lang_items.require(TyVisitorTraitLangItem) {\n         Ok(id) => id,\n         Err(s) => { return Err(s); }\n@@ -4468,13 +4499,11 @@ pub fn visitor_object_ty(tcx: ctxt) -> Result<(@TraitRef, t), ~str> {\n         tps: ~[]\n     };\n     let trait_ref = @TraitRef { def_id: trait_lang_item, substs: substs };\n-    let mut static_trait_bound = EmptyBuiltinBounds();\n-    static_trait_bound.add(BoundStatic);\n     Ok((trait_ref,\n         mk_trait(tcx,\n                  trait_ref.def_id,\n                  trait_ref.substs.clone(),\n-                 BoxTraitStore,\n+                 RegionTraitStore(region),\n                  ast::m_imm,\n-                 static_trait_bound)))\n+                 EmptyBuiltinBounds())))\n }"}, {"sha": "352836d81e45926e4d2a4e1bcbc5672cc6ae8135", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 298, "deletions": 158, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -94,6 +94,7 @@ use middle::typeck::{method_static, method_trait};\n use middle::typeck::{param_numbered, param_self, param_index};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use util::common::indenter;\n+use util::ppaux::Repr;\n \n use std::hashmap::HashSet;\n use std::result;\n@@ -147,9 +148,24 @@ pub fn lookup(\n         check_traits: check_traits,\n         autoderef_receiver: autoderef_receiver,\n     };\n-    let mme = lcx.do_lookup(self_ty);\n-    debug!(\"method lookup for %s yielded %?\", expr.repr(fcx.tcx()), mme);\n-    return mme;\n+\n+    let self_ty = structurally_resolved_type(fcx, self_expr.span, self_ty);\n+    debug!(\"method lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n+           self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n+           self_expr.repr(fcx.tcx()));\n+\n+    debug!(\"searching inherent candidates\");\n+    lcx.push_inherent_candidates(self_ty);\n+    let mme = lcx.search(self_ty);\n+    if mme.is_some() {\n+        return mme;\n+    }\n+\n+    debug!(\"searching extension candidates\");\n+    lcx.reset_candidates();\n+    lcx.push_bound_candidates(self_ty);\n+    lcx.push_extension_candidates();\n+    return lcx.search(self_ty);\n }\n \n pub struct LookupContext<'self> {\n@@ -173,27 +189,28 @@ pub struct LookupContext<'self> {\n  */\n #[deriving(Clone)]\n pub struct Candidate {\n-    rcvr_ty: ty::t,\n+    rcvr_match_condition: RcvrMatchCondition,\n     rcvr_substs: ty::substs,\n     method_ty: @ty::Method,\n     origin: method_origin,\n }\n \n-impl<'self> LookupContext<'self> {\n-    pub fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n-        let self_ty = structurally_resolved_type(self.fcx,\n-                                                     self.self_expr.span,\n-                                                     self_ty);\n-\n-        debug!(\"do_lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n-               self.ty_to_str(self_ty),\n-               self.expr.repr(self.tcx()),\n-               self.self_expr.repr(self.tcx()));\n-\n-        // Prepare the list of candidates\n-        self.push_inherent_candidates(self_ty);\n-        self.push_extension_candidates();\n+/// This type represents the conditions under which the receiver is\n+/// considered to \"match\" a given method candidate. Typically the test\n+/// is whether the receiver is of a particular type. However, this\n+/// type is the type of the receiver *after accounting for the\n+/// method's self type* (e.g., if the method is an `@self` method, we\n+/// have *already verified* that the receiver is of some type `@T` and\n+/// now we must check that the type `T` is correct).  Unfortunately,\n+/// because traits are not types, this is a pain to do.\n+#[deriving(Clone)]\n+enum RcvrMatchCondition {\n+    RcvrMatchesIfObject(ast::def_id),\n+    RcvrMatchesIfSubtype(ty::t)\n+}\n \n+impl<'self> LookupContext<'self> {\n+    fn search(&self, self_ty: ty::t) -> Option<method_map_entry> {\n         let mut self_ty = self_ty;\n         let mut autoderefs = 0;\n         loop {\n@@ -247,7 +264,7 @@ impl<'self> LookupContext<'self> {\n         self.search_for_autosliced_method(self_ty, autoderefs)\n     }\n \n-    pub fn deref(&self, ty: ty::t)\n+    fn deref(&self, ty: ty::t)\n                  -> Option<ty::t> {\n         match ty::deref(self.tcx(), ty, false) {\n             None => None,\n@@ -262,7 +279,12 @@ impl<'self> LookupContext<'self> {\n     // ______________________________________________________________________\n     // Candidate collection (see comment at start of file)\n \n-    pub fn push_inherent_candidates(&self, self_ty: ty::t) {\n+    fn reset_candidates(&self) {\n+        *self.inherent_candidates = ~[];\n+        *self.extension_candidates = ~[];\n+    }\n+\n+    fn push_inherent_candidates(&self, self_ty: ty::t) {\n         /*!\n          * Collect all inherent candidates into\n          * `self.inherent_candidates`.  See comment at the start of\n@@ -275,20 +297,10 @@ impl<'self> LookupContext<'self> {\n         let mut self_ty = self_ty;\n         loop {\n             match get(self_ty).sty {\n-                ty_param(p) => {\n-                    self.push_inherent_candidates_from_param(self_ty, p);\n-                }\n-                ty_trait(did, ref substs, store, _, _) => {\n-                    self.push_inherent_candidates_from_trait(\n-                        self_ty, did, substs, store);\n+                ty_trait(did, ref substs, _, _, _) => {\n+                    self.push_inherent_candidates_from_trait(did, substs);\n                     self.push_inherent_impl_candidates_for_type(did);\n                 }\n-                ty_self(self_did) => {\n-                    // Call is of the form \"self.foo()\" and appears in one\n-                    // of a trait's default method implementations.\n-                    self.push_inherent_candidates_from_self(\n-                        self_ty, self_did);\n-                }\n                 ty_enum(did, _) | ty_struct(did, _) => {\n                     if self.check_traits == CheckTraitsAndInherentMethods {\n                         self.push_inherent_impl_candidates_for_type(did);\n@@ -307,7 +319,30 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn push_extension_candidates(&self) {\n+    fn push_bound_candidates(&self, self_ty: ty::t) {\n+        let mut self_ty = self_ty;\n+        loop {\n+            match get(self_ty).sty {\n+                ty_param(p) => {\n+                    self.push_inherent_candidates_from_param(self_ty, p);\n+                }\n+                ty_self(self_did) => {\n+                    // Call is of the form \"self.foo()\" and appears in one\n+                    // of a trait's default method implementations.\n+                    self.push_inherent_candidates_from_self(\n+                        self_ty, self_did);\n+                }\n+                _ => { /* No bound methods in these types */ }\n+            }\n+\n+            self_ty = match self.deref(self_ty) {\n+                None => { return; }\n+                Some(ty) => { ty }\n+            }\n+        }\n+    }\n+\n+    fn push_extension_candidates(&self) {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n@@ -328,11 +363,9 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn push_inherent_candidates_from_trait(&self,\n-                                               self_ty: ty::t,\n+    fn push_inherent_candidates_from_trait(&self,\n                                                did: def_id,\n-                                               substs: &ty::substs,\n-                                               store: ty::TraitStore) {\n+                                               substs: &ty::substs) {\n         debug!(\"push_inherent_candidates_from_trait(did=%s, substs=%s)\",\n                self.did_to_str(did),\n                substs_to_str(self.tcx(), substs));\n@@ -346,41 +379,35 @@ impl<'self> LookupContext<'self> {\n         };\n         let method = ms[index];\n \n-        /* FIXME(#5762) we should transform the vstore in accordance\n-           with the self type\n-\n-        match method.self_type {\n-            ast::sty_region(_) => {\n-                return; // inapplicable\n+        match method.explicit_self {\n+            ast::sty_static => {\n+                return; // not a method we can call with dot notation\n             }\n-            ast::sty_region(_) => vstore_slice(r)\n-            ast::sty_box(_) => vstore_box, // NDM mutability, as per #5762\n-            ast::sty_uniq(_) => vstore_uniq\n+            _ => {}\n         }\n-        */\n \n         // It is illegal to invoke a method on a trait instance that\n-        // refers to the `self` type.  Nonetheless, we substitute\n-        // `trait_ty` for `self` here, because it allows the compiler\n-        // to soldier on.  An error will be reported should this\n-        // candidate be selected if the method refers to `self`.\n+        // refers to the `self` type. An error will be reported by\n+        // `enforce_object_limitations()` if the method refers\n+        // to the `Self` type. Substituting ty_err here allows\n+        // compiler to soldier on.\n         //\n-        // NB: `confirm_candidate()` also relies upon this substitution\n-        // for Self.\n+        // NOTE: `confirm_candidate()` also relies upon this substitution\n+        // for Self. (fix)\n         let rcvr_substs = substs {\n-            self_ty: Some(self_ty),\n+            self_ty: Some(ty::mk_err()),\n             ..(*substs).clone()\n         };\n \n         self.inherent_candidates.push(Candidate {\n-            rcvr_ty: self_ty,\n+            rcvr_match_condition: RcvrMatchesIfObject(did),\n             rcvr_substs: rcvr_substs,\n             method_ty: method,\n-            origin: method_trait(did, index, store)\n+            origin: method_trait(did, index)\n         });\n     }\n \n-    pub fn push_inherent_candidates_from_param(&self,\n+    fn push_inherent_candidates_from_param(&self,\n                                                rcvr_ty: ty::t,\n                                                param_ty: param_ty) {\n         debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n@@ -403,7 +430,7 @@ impl<'self> LookupContext<'self> {\n     }\n \n \n-    pub fn push_inherent_candidates_from_self(&self,\n+    fn push_inherent_candidates_from_self(&self,\n                                               self_ty: ty::t,\n                                               did: def_id) {\n         let tcx = self.tcx();\n@@ -413,7 +440,7 @@ impl<'self> LookupContext<'self> {\n             self_ty, &[trait_ref], param_self);\n     }\n \n-    pub fn push_inherent_candidates_from_bounds(&self,\n+    fn push_inherent_candidates_from_bounds(&self,\n                                                 self_ty: ty::t,\n                                                 bounds: &[@TraitRef],\n                                                 param: param_index) {\n@@ -433,11 +460,11 @@ impl<'self> LookupContext<'self> {\n                     let method = trait_methods[pos];\n \n                     let cand = Candidate {\n-                        rcvr_ty: self_ty,\n+                        rcvr_match_condition: RcvrMatchesIfSubtype(self_ty),\n                         rcvr_substs: bound_trait_ref.substs.clone(),\n                         method_ty: method,\n                         origin: method_param(\n-                            method_param {\n+                                             method_param {\n                                 trait_id: bound_trait_ref.def_id,\n                                 method_num: pos,\n                                 param_num: param,\n@@ -459,7 +486,7 @@ impl<'self> LookupContext<'self> {\n     }\n \n \n-    pub fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n+    fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n         let opt_impl_infos = self.tcx().inherent_impls.find(&did);\n         for impl_infos in opt_impl_infos.iter() {\n             for impl_info in impl_infos.iter() {\n@@ -469,7 +496,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn push_candidates_from_impl(&self,\n+    fn push_candidates_from_impl(&self,\n                                      candidates: &mut ~[Candidate],\n                                      impl_info: &ty::Impl) {\n         if !self.impl_dups.insert(impl_info.did) {\n@@ -502,7 +529,7 @@ impl<'self> LookupContext<'self> {\n         } = impl_self_ty(&vcx, location_info, impl_info.did);\n \n         candidates.push(Candidate {\n-            rcvr_ty: impl_ty,\n+            rcvr_match_condition: RcvrMatchesIfSubtype(impl_ty),\n             rcvr_substs: impl_substs,\n             method_ty: method,\n             origin: method_static(method.def_id)\n@@ -512,7 +539,7 @@ impl<'self> LookupContext<'self> {\n     // ______________________________________________________________________\n     // Candidate selection (see comment at start of file)\n \n-    pub fn search_for_autoderefd_method(&self,\n+    fn search_for_autoderefd_method(&self,\n                                         self_ty: ty::t,\n                                         autoderefs: uint)\n                                         -> Option<method_map_entry> {\n@@ -531,12 +558,11 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn consider_reborrow(&self,\n+    fn consider_reborrow(&self,\n                              self_ty: ty::t,\n                              autoderefs: uint)\n                              -> (ty::t, ty::AutoAdjustment) {\n         /*!\n-         *\n          * In the event that we are invoking a method with a receiver\n          * of a borrowed type like `&T`, `&mut T`, or `&mut [T]`,\n          * we will \"reborrow\" the receiver implicitly.  For example, if\n@@ -579,6 +605,17 @@ impl<'self> LookupContext<'self> {\n                      autoderefs: autoderefs,\n                      autoref: Some(ty::AutoBorrowVec(region, self_mt.mutbl))}))\n             }\n+            ty_trait(did, ref substs, ty::RegionTraitStore(_), mutbl, bounds) => {\n+                let region =\n+                    self.infcx().next_region_var(\n+                        infer::Autoref(self.expr.span));\n+                (ty::mk_trait(tcx, did, substs.clone(),\n+                              ty::RegionTraitStore(region),\n+                              mutbl, bounds),\n+                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                     autoderefs: autoderefs,\n+                     autoref: Some(ty::AutoBorrowObj(region, mutbl))}))\n+            }\n             _ => {\n                 (self_ty,\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n@@ -598,7 +635,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn search_for_autosliced_method(&self,\n+    fn search_for_autosliced_method(&self,\n                                         self_ty: ty::t,\n                                         autoderefs: uint)\n                                         -> Option<method_map_entry> {\n@@ -608,7 +645,8 @@ impl<'self> LookupContext<'self> {\n          * `~[]` to `&[]`. */\n \n         let tcx = self.tcx();\n-        match ty::get(self_ty).sty {\n+        let sty = ty::get(self_ty).sty.clone();\n+        match sty {\n             ty_evec(mt, vstore_box) |\n             ty_evec(mt, vstore_uniq) |\n             ty_evec(mt, vstore_slice(_)) | // NDM(#3148)\n@@ -655,16 +693,28 @@ impl<'self> LookupContext<'self> {\n                     })\n             }\n \n-            ty_trait(*) | ty_closure(*) => {\n-                // NDM---eventually these should be some variant of autoref\n+            ty_trait(trt_did, trt_substs, _, _, b) => {\n+                // Coerce ~/@/&Trait instances to &Trait.\n+\n+                self.search_for_some_kind_of_autorefd_method(\n+                    AutoBorrowObj, autoderefs, [m_const, m_imm, m_mutbl],\n+                    |trt_mut, reg| {\n+                        ty::mk_trait(tcx, trt_did, trt_substs.clone(),\n+                                     RegionTraitStore(reg), trt_mut, b)\n+                    })\n+            }\n+\n+            ty_closure(*) => {\n+                // This case should probably be handled similarly to\n+                // Trait instances.\n                 None\n             }\n \n             _ => None\n         }\n     }\n \n-    pub fn search_for_autoptrd_method(&self, self_ty: ty::t, autoderefs: uint)\n+    fn search_for_autoptrd_method(&self, self_ty: ty::t, autoderefs: uint)\n                                       -> Option<method_map_entry> {\n         /*!\n          *\n@@ -696,7 +746,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn search_for_some_kind_of_autorefd_method(\n+    fn search_for_some_kind_of_autorefd_method(\n         &self,\n         kind: &fn(Region, ast::mutability) -> ty::AutoRef,\n         autoderefs: uint,\n@@ -725,7 +775,7 @@ impl<'self> LookupContext<'self> {\n         return None;\n     }\n \n-    pub fn search_for_method(&self, rcvr_ty: ty::t)\n+    fn search_for_method(&self, rcvr_ty: ty::t)\n                              -> Option<method_map_entry> {\n         debug!(\"search_for_method(rcvr_ty=%s)\", self.ty_to_str(rcvr_ty));\n         let _indenter = indenter();\n@@ -753,7 +803,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn consider_candidates(&self,\n+    fn consider_candidates(&self,\n                                rcvr_ty: ty::t,\n                                candidates: &mut ~[Candidate])\n                                -> Option<method_map_entry> {\n@@ -780,7 +830,7 @@ impl<'self> LookupContext<'self> {\n         Some(self.confirm_candidate(rcvr_ty, &relevant_candidates[0]))\n     }\n \n-    pub fn merge_candidates(&self, candidates: &[Candidate]) -> ~[Candidate] {\n+    fn merge_candidates(&self, candidates: &[Candidate]) -> ~[Candidate] {\n         let mut merged = ~[];\n         let mut i = 0;\n         while i < candidates.len() {\n@@ -826,7 +876,7 @@ impl<'self> LookupContext<'self> {\n         return merged;\n     }\n \n-    pub fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n+    fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n                              -> method_map_entry {\n         let tcx = self.tcx();\n         let fty = self.fn_ty_from_origin(&candidate.origin);\n@@ -836,31 +886,16 @@ impl<'self> LookupContext<'self> {\n                self.cand_to_str(candidate),\n                self.ty_to_str(fty));\n \n-        self.enforce_trait_instance_limitations(fty, candidate);\n+        self.enforce_object_limitations(fty, candidate);\n         self.enforce_drop_trait_limitations(candidate);\n \n         // static methods should never have gotten this far:\n         assert!(candidate.method_ty.explicit_self != sty_static);\n \n         let transformed_self_ty = match candidate.origin {\n-            method_trait(*) => {\n-                match candidate.method_ty.explicit_self {\n-                    sty_region(*) => {\n-                        // FIXME(#5762) again, preserving existing\n-                        // behavior here which (for &self) desires\n-                        // &@Trait where @Trait is the type of the\n-                        // receiver.  Here we fetch the method's\n-                        // transformed_self_ty which will be something\n-                        // like &'a Self.  We then perform a\n-                        // substitution which will replace Self with\n-                        // @Trait.\n-                        let t = candidate.method_ty.transformed_self_ty.unwrap();\n-                        ty::subst(tcx, &candidate.rcvr_substs, t)\n-                    }\n-                    _ => {\n-                        candidate.rcvr_ty\n-                    }\n-                }\n+            method_trait(trait_def_id, _) => {\n+                self.construct_transformed_self_ty_for_object(\n+                    trait_def_id, candidate)\n             }\n             _ => {\n                 let t = candidate.method_ty.transformed_self_ty.unwrap();\n@@ -950,23 +985,88 @@ impl<'self> LookupContext<'self> {\n         self.fcx.write_ty(self.callee_id, fty);\n         self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n-            self_ty: rcvr_ty,\n+            self_ty: transformed_self_ty,\n             self_mode: self_mode,\n             explicit_self: candidate.method_ty.explicit_self,\n             origin: candidate.origin,\n         }\n     }\n \n-    pub fn enforce_trait_instance_limitations(&self,\n-                                              method_fty: ty::t,\n-                                              candidate: &Candidate) {\n+    fn construct_transformed_self_ty_for_object(&self,\n+                                                trait_def_id: ast::def_id,\n+                                                candidate: &Candidate) -> ty::t\n+    {\n         /*!\n+         * This is a bit tricky. We have a match against a trait method\n+         * being invoked on an object, and we want to generate the\n+         * self-type. As an example, consider a trait\n+         *\n+         *     trait Foo {\n+         *         fn r_method<'a>(&'a self);\n+         *         fn m_method(@mut self);\n+         *     }\n          *\n-         * There are some limitations to calling functions through a\n-         * trait instance, because (a) the self type is not known\n+         * Now, assuming that `r_method` is being called, we want the\n+         * result to be `&'a Foo`. Assuming that `m_method` is being\n+         * called, we want the result to be `@mut Foo`. Of course,\n+         * this transformation has already been done as part of\n+         * `candidate.method_ty.transformed_self_ty`, but there the\n+         * type is expressed in terms of `Self` (i.e., `&'a Self`, `@mut Self`).\n+         * Because objects are not standalone types, we can't just substitute\n+         * `s/Self/Foo/`, so we must instead perform this kind of hokey\n+         * match below.\n+         */\n+\n+        let substs = ty::substs {regions: candidate.rcvr_substs.regions.clone(),\n+                                 self_ty: None,\n+                                 tps: candidate.rcvr_substs.tps.clone()};\n+        match candidate.method_ty.explicit_self {\n+            ast::sty_static => {\n+                self.bug(~\"static method for object type receiver\");\n+            }\n+            ast::sty_value => {\n+                ty::mk_err() // error reported in `enforce_object_limitations()`\n+            }\n+            ast::sty_region(*) | ast::sty_box(*) | ast::sty_uniq(*) => {\n+                let transformed_self_ty =\n+                    candidate.method_ty.transformed_self_ty.clone().unwrap();\n+                match ty::get(transformed_self_ty).sty {\n+                    ty::ty_rptr(r, mt) => { // must be sty_region\n+                        ty::mk_trait(self.tcx(), trait_def_id,\n+                                     substs, RegionTraitStore(r), mt.mutbl,\n+                                     ty::EmptyBuiltinBounds())\n+                    }\n+                    ty::ty_box(mt) => { // must be sty_box\n+                        ty::mk_trait(self.tcx(), trait_def_id,\n+                                     substs, BoxTraitStore, mt.mutbl,\n+                                     ty::EmptyBuiltinBounds())\n+                    }\n+                    ty::ty_uniq(mt) => { // must be sty_uniq\n+                        ty::mk_trait(self.tcx(), trait_def_id,\n+                                     substs, UniqTraitStore, mt.mutbl,\n+                                     ty::EmptyBuiltinBounds())\n+                    }\n+                    _ => {\n+                        self.bug(\n+                            fmt!(\"'impossible' transformed_self_ty: %s\",\n+                                 transformed_self_ty.repr(self.tcx())));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn enforce_object_limitations(&self,\n+                                  method_fty: ty::t,\n+                                  candidate: &Candidate)\n+    {\n+        /*!\n+         * There are some limitations to calling functions through an\n+         * object, because (a) the self type is not known\n          * (that's the whole point of a trait instance, after all, to\n          * obscure the self type) and (b) the call must go through a\n-         * vtable and hence cannot be monomorphized. */\n+         * vtable and hence cannot be monomorphized.\n+         */\n \n         match candidate.origin {\n             method_static(*) | method_param(*) => {\n@@ -975,21 +1075,39 @@ impl<'self> LookupContext<'self> {\n             method_trait(*) => {}\n         }\n \n-        if ty::type_has_self(method_fty) {\n+        match candidate.method_ty.explicit_self {\n+            ast::sty_static => { // reason (a) above\n+                self.tcx().sess.span_err(\n+                    self.expr.span,\n+                    \"cannot call a method without a receiver \\\n+                     through an object\");\n+            }\n+\n+            ast::sty_value => { // reason (a) above\n+                self.tcx().sess.span_err(\n+                    self.expr.span,\n+                    \"cannot call a method with a by-value receiver \\\n+                     through an object\");\n+            }\n+\n+            ast::sty_region(*) | ast::sty_box(*) | ast::sty_uniq(*) => {}\n+        }\n+\n+        if ty::type_has_self(method_fty) { // reason (a) above\n             self.tcx().sess.span_err(\n                 self.expr.span,\n                 \"cannot call a method whose type contains a \\\n-                 self-type through a boxed trait\");\n+                 self-type through an object\");\n         }\n \n-        if candidate.method_ty.generics.has_type_params() {\n+        if candidate.method_ty.generics.has_type_params() { // reason (b) above\n             self.tcx().sess.span_err(\n                 self.expr.span,\n-                \"cannot call a generic method through a boxed trait\");\n+                \"cannot call a generic method through an object\");\n         }\n     }\n \n-    pub fn enforce_drop_trait_limitations(&self, candidate: &Candidate) {\n+    fn enforce_drop_trait_limitations(&self, candidate: &Candidate) {\n         // No code can call the finalize method explicitly.\n         let bad;\n         match candidate.origin {\n@@ -999,7 +1117,7 @@ impl<'self> LookupContext<'self> {\n             // XXX: does this properly enforce this on everything now\n             // that self has been merged in? -sully\n             method_param(method_param { trait_id: trait_id, _ }) |\n-            method_trait(trait_id, _, _) => {\n+            method_trait(trait_id, _) => {\n                 bad = self.tcx().destructor_for_type.contains_key(&trait_id);\n             }\n         }\n@@ -1012,51 +1130,31 @@ impl<'self> LookupContext<'self> {\n \n     // `rcvr_ty` is the type of the expression. It may be a subtype of a\n     // candidate method's `self_ty`.\n-    pub fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n+    fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n         debug!(\"is_relevant(rcvr_ty=%s, candidate=%s)\",\n                self.ty_to_str(rcvr_ty), self.cand_to_str(candidate));\n \n-        // Check for calls to object methods.  We resolve these differently.\n-        //\n-        // FIXME(#5762)---we don't check that an @self method is only called\n-        // on an @Trait object here and so forth\n-        match candidate.origin {\n-            method_trait(*) => {\n-                match candidate.method_ty.explicit_self {\n-                    sty_static | sty_value => {\n-                        return false;\n-                    }\n-                    sty_region(*) => {\n-                        // just echoing current behavior here, which treats\n-                        // an &self method on an @Trait object as requiring\n-                        // an &@Trait receiver (wacky)\n-                    }\n-                    sty_box(*) | sty_uniq(*) => {\n-                        return self.fcx.can_mk_subty(rcvr_ty,\n-                                                     candidate.rcvr_ty).is_ok();\n-                    }\n-                };\n-            }\n-            _ => {}\n-        }\n-\n-        let result = match candidate.method_ty.explicit_self {\n+        return match candidate.method_ty.explicit_self {\n             sty_static => {\n                 debug!(\"(is relevant?) explicit self is static\");\n                 false\n             }\n \n             sty_value => {\n-                debug!(\"(is relevant?) explicit self is by-value\");\n-                self.fcx.can_mk_subty(rcvr_ty, candidate.rcvr_ty).is_ok()\n+                rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n             }\n \n             sty_region(_, m) => {\n                 debug!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n-                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                        rcvr_matches_ty(self.fcx, mt.ty, candidate)\n+                    }\n+\n+                    ty::ty_trait(self_did, _, RegionTraitStore(_), self_m, _) => {\n+                        mutability_matches(self_m, m) &&\n+                        rcvr_matches_object(self_did, candidate)\n                     }\n \n                     _ => false\n@@ -1068,7 +1166,12 @@ impl<'self> LookupContext<'self> {\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_box(mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n-                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                        rcvr_matches_ty(self.fcx, mt.ty, candidate)\n+                    }\n+\n+                    ty::ty_trait(self_did, _, BoxTraitStore, self_m, _) => {\n+                        mutability_matches(self_m, m) &&\n+                        rcvr_matches_object(self_did, candidate)\n                     }\n \n                     _ => false\n@@ -1079,18 +1182,42 @@ impl<'self> LookupContext<'self> {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(mt) => {\n-                        mutability_matches(mt.mutbl, ast::m_imm) &&\n-                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                        rcvr_matches_ty(self.fcx, mt.ty, candidate)\n+                    }\n+\n+                    ty::ty_trait(self_did, _, UniqTraitStore, _, _) => {\n+                        rcvr_matches_object(self_did, candidate)\n                     }\n \n                     _ => false\n                 }\n             }\n         };\n \n-        debug!(\"(is relevant?) %s\", if result { \"yes\" } else { \"no\" });\n+        fn rcvr_matches_object(self_did: ast::def_id,\n+                               candidate: &Candidate) -> bool {\n+            match candidate.rcvr_match_condition {\n+                RcvrMatchesIfObject(desired_did) => {\n+                    self_did == desired_did\n+                }\n+                RcvrMatchesIfSubtype(_) => {\n+                    false\n+                }\n+            }\n+        }\n \n-        return result;\n+        fn rcvr_matches_ty(fcx: @mut FnCtxt,\n+                           rcvr_ty: ty::t,\n+                           candidate: &Candidate) -> bool {\n+            match candidate.rcvr_match_condition {\n+                RcvrMatchesIfObject(_) => {\n+                    false\n+                }\n+                RcvrMatchesIfSubtype(of_type) => {\n+                    fcx.can_mk_subty(rcvr_ty, of_type).is_ok()\n+                }\n+            }\n+        }\n \n         fn mutability_matches(self_mutbl: ast::mutability,\n                               candidate_mutbl: ast::mutability) -> bool {\n@@ -1108,15 +1235,15 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn fn_ty_from_origin(&self, origin: &method_origin) -> ty::t {\n+    fn fn_ty_from_origin(&self, origin: &method_origin) -> ty::t {\n         return match *origin {\n             method_static(did) => {\n                 ty::lookup_item_type(self.tcx(), did).ty\n             }\n             method_param(ref mp) => {\n                 type_of_trait_method(self.tcx(), mp.trait_id, mp.method_num)\n             }\n-            method_trait(did, idx, _) => {\n+            method_trait(did, idx) => {\n                 type_of_trait_method(self.tcx(), did, idx)\n             }\n         };\n@@ -1129,21 +1256,21 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn report_candidate(&self, idx: uint, origin: &method_origin) {\n+    fn report_candidate(&self, idx: uint, origin: &method_origin) {\n         match *origin {\n             method_static(impl_did) => {\n                 self.report_static_candidate(idx, impl_did)\n             }\n             method_param(ref mp) => {\n                 self.report_param_candidate(idx, (*mp).trait_id)\n             }\n-            method_trait(trait_did, _, _) => {\n+            method_trait(trait_did, _) => {\n                 self.report_trait_candidate(idx, trait_did)\n             }\n         }\n     }\n \n-    pub fn report_static_candidate(&self, idx: uint, did: def_id) {\n+    fn report_static_candidate(&self, idx: uint, did: def_id) {\n         let span = if did.crate == ast::LOCAL_CRATE {\n             match self.tcx().items.find(&did.node) {\n               Some(&ast_map::node_method(m, _, _)) => m.span,\n@@ -1159,15 +1286,15 @@ impl<'self> LookupContext<'self> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    pub fn report_param_candidate(&self, idx: uint, did: def_id) {\n+    fn report_param_candidate(&self, idx: uint, did: def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             fmt!(\"candidate #%u derives from the bound `%s`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    pub fn report_trait_candidate(&self, idx: uint, did: def_id) {\n+    fn report_trait_candidate(&self, idx: uint, did: def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             fmt!(\"candidate #%u derives from the type of the receiver, \\\n@@ -1176,31 +1303,31 @@ impl<'self> LookupContext<'self> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    pub fn infcx(&self) -> @mut infer::InferCtxt {\n+    fn infcx(&self) -> @mut infer::InferCtxt {\n         self.fcx.inh.infcx\n     }\n \n-    pub fn tcx(&self) -> ty::ctxt {\n+    fn tcx(&self) -> ty::ctxt {\n         self.fcx.tcx()\n     }\n \n-    pub fn ty_to_str(&self, t: ty::t) -> ~str {\n+    fn ty_to_str(&self, t: ty::t) -> ~str {\n         self.fcx.infcx().ty_to_str(t)\n     }\n \n-    pub fn cand_to_str(&self, cand: &Candidate) -> ~str {\n+    fn cand_to_str(&self, cand: &Candidate) -> ~str {\n         fmt!(\"Candidate(rcvr_ty=%s, rcvr_substs=%s, origin=%?)\",\n-             self.ty_to_str(cand.rcvr_ty),\n+             cand.rcvr_match_condition.repr(self.tcx()),\n              ty::substs_to_str(self.tcx(), &cand.rcvr_substs),\n              cand.origin)\n     }\n \n-    pub fn did_to_str(&self, did: def_id) -> ~str {\n+    fn did_to_str(&self, did: def_id) -> ~str {\n         ty::item_path_str(self.tcx(), did)\n     }\n \n-    pub fn bug(&self, s: ~str) -> ! {\n-        self.tcx().sess.bug(s)\n+    fn bug(&self, s: ~str) -> ! {\n+        self.tcx().sess.span_bug(self.self_expr.span, s)\n     }\n }\n \n@@ -1210,3 +1337,16 @@ pub fn get_mode_from_explicit_self(explicit_self: ast::explicit_self_) -> SelfMo\n         _ => ty::ByCopy,\n     }\n }\n+\n+impl Repr for RcvrMatchCondition {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            RcvrMatchesIfObject(d) => {\n+                fmt!(\"RcvrMatchesIfObject(%s)\", d.repr(tcx))\n+            }\n+            RcvrMatchesIfSubtype(t) => {\n+                fmt!(\"RcvrMatchesIfSubtype(%s)\", t.repr(tcx))\n+            }\n+        }\n+    }\n+}"}, {"sha": "e7ef30c4576c4868803cd7bfbcbf7ed2ce37de70", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -3437,7 +3437,8 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                   Ok(t) => t,\n                   Err(s) => { tcx.sess.span_fatal(it.span, s); }\n               };\n-              let visitor_object_ty = match ty::visitor_object_ty(tcx) {\n+              let region = ty::re_bound(ty::br_anon(0));\n+              let visitor_object_ty = match ty::visitor_object_ty(tcx, region) {\n                   Ok((_, vot)) => vot,\n                   Err(s) => { tcx.sess.span_fatal(it.span, s); }\n               };"}, {"sha": "d034277d44af82526360f62b0b392d739f105d3c", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -863,7 +863,8 @@ pub mod guarantor {\n \n             ty::AutoBorrowVec(r, _) |\n             ty::AutoBorrowVecRef(r, _) |\n-            ty::AutoBorrowFn(r) => {\n+            ty::AutoBorrowFn(r) |\n+            ty::AutoBorrowObj(r, _) => {\n                 // In each of these cases, what is being borrowed is\n                 // not the (autoderef'd) expr itself but rather the\n                 // contents of the autoderef'd expression (i.e., what\n@@ -1072,7 +1073,8 @@ pub mod guarantor {\n                     Some(ty::AutoPtr(r, _)) |\n                     Some(ty::AutoBorrowVec(r, _)) |\n                     Some(ty::AutoBorrowVecRef(r, _)) |\n-                    Some(ty::AutoBorrowFn(r)) => {\n+                    Some(ty::AutoBorrowFn(r)) |\n+                    Some(ty::AutoBorrowObj(r, _)) => {\n                         // If there is an autoref, then the result of this\n                         // expression will be some sort of borrowed pointer.\n                         expr_ct.cat.guarantor = None;"}, {"sha": "f2bde146ea79cf338f7660b06cce266470982131", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -65,7 +65,7 @@ we may want to adjust precisely when coercions occur.\n */\n \n \n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn};\n+use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn, AutoBorrowObj};\n use middle::ty::{AutoDerefRef};\n use middle::ty::{vstore_slice, vstore_box, vstore_uniq};\n use middle::ty::{mt};\n@@ -121,6 +121,12 @@ impl Coerce {\n                 };\n             }\n \n+            ty::ty_trait(_, _, ty::RegionTraitStore(*), _, _) => {\n+                return do self.unpack_actual_value(a) |sty_a| {\n+                    self.coerce_borrowed_object(a, sty_a, b)\n+                };\n+            }\n+\n             ty::ty_ptr(mt_b) => {\n                 return do self.unpack_actual_value(a) |sty_a| {\n                     self.coerce_unsafe_ptr(a, sty_a, b, mt_b)\n@@ -265,6 +271,40 @@ impl Coerce {\n         })))\n     }\n \n+    fn coerce_borrowed_object(&self,\n+                              a: ty::t,\n+                              sty_a: &ty::sty,\n+                              b: ty::t) -> CoerceResult\n+    {\n+        debug!(\"coerce_borrowed_object(a=%s, sty_a=%?, b=%s)\",\n+               a.inf_str(self.infcx), sty_a,\n+               b.inf_str(self.infcx));\n+\n+        let tcx = self.infcx.tcx;\n+        let r_a = self.infcx.next_region_var(Coercion(self.trace));\n+        let trt_mut;\n+\n+        let a_borrowed = match *sty_a {\n+            ty::ty_trait(_, _, ty::RegionTraitStore(_), _, _) => {\n+                return self.subtype(a, b);\n+            }\n+            ty::ty_trait(did, ref substs, _, m, b) => {\n+                trt_mut = m;\n+                ty::mk_trait(tcx, did, substs.clone(),\n+                             ty::RegionTraitStore(r_a), m, b)\n+            }\n+            _ => {\n+                return self.subtype(a, b);\n+            }\n+        };\n+\n+        if_ok!(self.tys(a_borrowed, b));\n+        Ok(Some(@AutoDerefRef(AutoDerefRef {\n+            autoderefs: 0,\n+            autoref: Some(AutoBorrowObj(r_a, trt_mut))\n+        })))\n+    }\n+\n     pub fn coerce_borrowed_fn(&self,\n                               a: ty::t,\n                               sty_a: &ty::sty,"}, {"sha": "53ae80f19facc3354325fcdd3c873c24724162bd", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -88,7 +88,7 @@ pub enum method_origin {\n     method_param(method_param),\n \n     // method invoked on a trait instance\n-    method_trait(ast::def_id, uint, ty::TraitStore),\n+    method_trait(ast::def_id, uint),\n \n }\n "}, {"sha": "3bc0a7167e9bdd8a2ce7f59c3e466f59293c5ab0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -747,9 +747,8 @@ impl Repr for typeck::method_origin {\n             &typeck::method_param(ref p) => {\n                 p.repr(tcx)\n             }\n-            &typeck::method_trait(def_id, n, st) => {\n-                fmt!(\"method_trait(%s, %?, %s)\", def_id.repr(tcx), n,\n-                     st.repr(tcx))\n+            &typeck::method_trait(def_id, n) => {\n+                fmt!(\"method_trait(%s, %?)\", def_id.repr(tcx), n)\n             }\n         }\n     }"}, {"sha": "d0970f1b6b7ad038a65db944f11417a8e9ccf5b1", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -158,6 +158,7 @@ impl ReprVisitor {\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     pub fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n         unsafe {\n             let u = ReprVisitor(ptr, self.writer);\n@@ -167,6 +168,17 @@ impl ReprVisitor {\n         }\n     }\n \n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n+        unsafe {\n+            let u = ReprVisitor(ptr, self.writer);\n+            let v = reflect::MovePtrAdaptor(u);\n+            visit_tydesc(inner, &v as &TyVisitor);\n+            true\n+        }\n+    }\n+\n     #[inline]\n     pub fn write<T:Repr>(&self) -> bool {\n         do self.get |v:&T| {\n@@ -556,6 +568,7 @@ impl TyVisitor for ReprVisitor {\n     fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n }\n \n+#[cfg(stage0)]\n pub fn write_repr<T>(writer: @Writer, object: &T) {\n     unsafe {\n         let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n@@ -566,6 +579,17 @@ pub fn write_repr<T>(writer: @Writer, object: &T) {\n     }\n }\n \n+#[cfg(not(stage0))]\n+pub fn write_repr<T>(writer: @Writer, object: &T) {\n+    unsafe {\n+        let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n+        let tydesc = get_tydesc::<T>();\n+        let u = ReprVisitor(ptr, writer);\n+        let v = reflect::MovePtrAdaptor(u);\n+        visit_tydesc(tydesc, &v as &TyVisitor)\n+    }\n+}\n+\n #[cfg(test)]\n struct P {a: int, b: float}\n "}, {"sha": "92725fda70598c8f13a3d5d1871e4554d49fc48d", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -38,16 +38,34 @@ pub use realstd::unstable::intrinsics::{TyDesc, Opaque, TyVisitor};\n \n pub type GlueFn = extern \"Rust\" fn(*i8);\n \n-// NB: this has to be kept in sync with the Rust ABI.\n+// NB: this has to be kept in sync with `type_desc` in `rt`\n #[lang=\"ty_desc\"]\n #[cfg(not(test))]\n pub struct TyDesc {\n+    // sizeof(T)\n     size: uint,\n+\n+    // alignof(T)\n     align: uint,\n+\n+    // Called on a copy of a value of type `T` *after* memcpy\n     take_glue: GlueFn,\n+\n+    // Called when a value of type `T` is no longer needed\n     drop_glue: GlueFn,\n+\n+    // Called by drop glue when a value of type `T` can be freed\n     free_glue: GlueFn,\n+\n+    // Called by reflection visitor to visit a value of type `T`\n     visit_glue: GlueFn,\n+\n+    // If T represents a box pointer (`@U` or `~U`), then\n+    // `borrow_offset` is the amount that the pointer must be adjusted\n+    // to find the payload.  This is always derivable from the type\n+    // `U`, but in the case of `@Trait` or `~Trait` objects, the type\n+    // `U` is unknown.\n+    borrow_offset: uint,\n }\n \n #[lang=\"opaque\"]\n@@ -310,8 +328,12 @@ extern \"rust-intrinsic\" {\n     /// Returns `true` if a type is managed (will be allocated on the local heap)\n     pub fn contains_managed<T>() -> bool;\n \n+    #[cfg(stage0)]\n     pub fn visit_tydesc(td: *TyDesc, tv: @TyVisitor);\n \n+    #[cfg(not(stage0))]\n+    pub fn visit_tydesc(td: *TyDesc, tv: &TyVisitor);\n+\n     pub fn frame_address(f: &once fn(*u8));\n \n     /// Get the address of the `__morestack` stack growth function."}, {"sha": "1fea0c2e6f92db4a1e099ede69a4df1863c8f7ad", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -85,7 +85,7 @@ pub type map = @mut HashMap<NodeId, ast_node>;\n pub struct Ctx {\n     map: map,\n     path: path,\n-    diag: @span_handler,\n+    diag: @mut span_handler,\n }\n \n impl Ctx {\n@@ -141,7 +141,7 @@ impl Ctx {\n             }\n         }\n \n-        visit::visit_expr(self as @Visitor<()>, ex, ());\n+        visit::visit_expr(self as @mut Visitor<()>, ex, ());\n     }\n \n     fn map_fn(@mut self,\n@@ -153,18 +153,18 @@ impl Ctx {\n         for a in decl.inputs.iter() {\n             self.map.insert(a.id, node_arg);\n         }\n-        visit::visit_fn(self as @Visitor<()>, fk, decl, body, sp, id, ());\n+        visit::visit_fn(self as @mut Visitor<()>, fk, decl, body, sp, id, ());\n     }\n \n     fn map_stmt(@mut self, stmt: @stmt) {\n         self.map.insert(stmt_id(stmt), node_stmt(stmt));\n-        visit::visit_stmt(self as @Visitor<()>, stmt, ());\n+        visit::visit_stmt(self as @mut Visitor<()>, stmt, ());\n     }\n \n     fn map_block(@mut self, b: &Block) {\n         // clone is FIXME #2543\n         self.map.insert(b.id, node_block((*b).clone()));\n-        visit::visit_block(self as @Visitor<()>, b, ());\n+        visit::visit_block(self as @mut Visitor<()>, b, ());\n     }\n \n     fn map_pat(@mut self, pat: @pat) {\n@@ -177,7 +177,7 @@ impl Ctx {\n             _ => ()\n         }\n \n-        visit::visit_pat(self as @Visitor<()>, pat, ());\n+        visit::visit_pat(self as @mut Visitor<()>, pat, ());\n     }\n }\n \n@@ -254,13 +254,13 @@ impl Visitor<()> for Ctx {\n             }\n             _ => self.path.push(path_name(i.ident))\n         }\n-        visit::visit_item(self as @Visitor<()>, i, ());\n+        visit::visit_item(self as @mut Visitor<()>, i, ());\n         self.path.pop();\n     }\n \n     fn visit_pat(@mut self, pat: @pat, _: ()) {\n         self.map_pat(pat);\n-        visit::visit_pat(self as @Visitor<()>, pat, ())\n+        visit::visit_pat(self as @mut Visitor<()>, pat, ())\n     }\n \n     fn visit_expr(@mut self, expr: @expr, _: ()) {\n@@ -288,39 +288,39 @@ impl Visitor<()> for Ctx {\n     // XXX: Methods below can become default methods.\n \n     fn visit_mod(@mut self, module: &_mod, _: span, _: NodeId, _: ()) {\n-        visit::visit_mod(self as @Visitor<()>, module, ())\n+        visit::visit_mod(self as @mut Visitor<()>, module, ())\n     }\n \n     fn visit_view_item(@mut self, view_item: &view_item, _: ()) {\n-        visit::visit_view_item(self as @Visitor<()>, view_item, ())\n+        visit::visit_view_item(self as @mut Visitor<()>, view_item, ())\n     }\n \n     fn visit_foreign_item(@mut self, foreign_item: @foreign_item, _: ()) {\n-        visit::visit_foreign_item(self as @Visitor<()>, foreign_item, ())\n+        visit::visit_foreign_item(self as @mut Visitor<()>, foreign_item, ())\n     }\n \n     fn visit_local(@mut self, local: @Local, _: ()) {\n-        visit::visit_local(self as @Visitor<()>, local, ())\n+        visit::visit_local(self as @mut Visitor<()>, local, ())\n     }\n \n     fn visit_arm(@mut self, arm: &arm, _: ()) {\n-        visit::visit_arm(self as @Visitor<()>, arm, ())\n+        visit::visit_arm(self as @mut Visitor<()>, arm, ())\n     }\n \n     fn visit_decl(@mut self, decl: @decl, _: ()) {\n-        visit::visit_decl(self as @Visitor<()>, decl, ())\n+        visit::visit_decl(self as @mut Visitor<()>, decl, ())\n     }\n \n     fn visit_expr_post(@mut self, _: @expr, _: ()) {\n         // Empty!\n     }\n \n     fn visit_ty(@mut self, typ: &Ty, _: ()) {\n-        visit::visit_ty(self as @Visitor<()>, typ, ())\n+        visit::visit_ty(self as @mut Visitor<()>, typ, ())\n     }\n \n     fn visit_generics(@mut self, generics: &Generics, _: ()) {\n-        visit::visit_generics(self as @Visitor<()>, generics, ())\n+        visit::visit_generics(self as @mut Visitor<()>, generics, ())\n     }\n \n     fn visit_fn(@mut self,\n@@ -330,7 +330,7 @@ impl Visitor<()> for Ctx {\n                 span: span,\n                 node_id: NodeId,\n                 _: ()) {\n-        visit::visit_fn(self as @Visitor<()>,\n+        visit::visit_fn(self as @mut Visitor<()>,\n                         function_kind,\n                         function_declaration,\n                         block,\n@@ -340,11 +340,11 @@ impl Visitor<()> for Ctx {\n     }\n \n     fn visit_ty_method(@mut self, ty_method: &TypeMethod, _: ()) {\n-        visit::visit_ty_method(self as @Visitor<()>, ty_method, ())\n+        visit::visit_ty_method(self as @mut Visitor<()>, ty_method, ())\n     }\n \n     fn visit_trait_method(@mut self, trait_method: &trait_method, _: ()) {\n-        visit::visit_trait_method(self as @Visitor<()>, trait_method, ())\n+        visit::visit_trait_method(self as @mut Visitor<()>, trait_method, ())\n     }\n \n     fn visit_struct_def(@mut self,\n@@ -353,7 +353,7 @@ impl Visitor<()> for Ctx {\n                         generics: &Generics,\n                         node_id: NodeId,\n                         _: ()) {\n-        visit::visit_struct_def(self as @Visitor<()>,\n+        visit::visit_struct_def(self as @mut Visitor<()>,\n                                 struct_def,\n                                 ident,\n                                 generics,\n@@ -362,24 +362,24 @@ impl Visitor<()> for Ctx {\n     }\n \n     fn visit_struct_field(@mut self, struct_field: @struct_field, _: ()) {\n-        visit::visit_struct_field(self as @Visitor<()>, struct_field, ())\n+        visit::visit_struct_field(self as @mut Visitor<()>, struct_field, ())\n     }\n }\n \n-pub fn map_crate(diag: @span_handler, c: &Crate) -> map {\n+pub fn map_crate(diag: @mut span_handler, c: &Crate) -> map {\n     let cx = @mut Ctx {\n         map: @mut HashMap::new(),\n         path: ~[],\n         diag: diag,\n     };\n-    visit::visit_crate(cx as @Visitor<()>, c, ());\n+    visit::visit_crate(cx as @mut Visitor<()>, c, ());\n     cx.map\n }\n \n // Used for items loaded from external crate that are being inlined into this\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n-pub fn map_decoded_item(diag: @span_handler,\n+pub fn map_decoded_item(diag: @mut span_handler,\n                         map: map,\n                         path: path,\n                         ii: &inlined_item) {\n@@ -409,7 +409,7 @@ pub fn map_decoded_item(diag: @span_handler,\n     }\n \n     // visit the item / method contents and add those to the map:\n-    ii.accept((), cx as @Visitor<()>);\n+    ii.accept((), cx as @mut Visitor<()>);\n }\n \n pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {"}, {"sha": "d99f8cab4937fad51167888fa80d1660e84e4bc8", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -298,7 +298,7 @@ pub fn struct_field_visibility(field: ast::struct_field) -> visibility {\n pub trait inlined_item_utils {\n     fn ident(&self) -> ident;\n     fn id(&self) -> ast::NodeId;\n-    fn accept<E: Clone>(&self, e: E, v: @Visitor<E>);\n+    fn accept<E: Clone>(&self, e: E, v: @mut Visitor<E>);\n }\n \n impl inlined_item_utils for inlined_item {\n@@ -318,7 +318,7 @@ impl inlined_item_utils for inlined_item {\n         }\n     }\n \n-    fn accept<E: Clone>(&self, e: E, v: @Visitor<E>) {\n+    fn accept<E: Clone>(&self, e: E, v: @mut Visitor<E>) {\n         match *self {\n             ii_item(i) => v.visit_item(i, e),\n             ii_foreign(i) => v.visit_foreign_item(i, e),\n@@ -414,7 +414,7 @@ impl Visitor<()> for IdVisitor {\n                  node_id: NodeId,\n                  env: ()) {\n         (self.visit_callback)(node_id);\n-        visit::visit_mod(self as @Visitor<()>, module, env)\n+        visit::visit_mod(self as @mut Visitor<()>, module, env)\n     }\n \n     fn visit_view_item(@mut self, view_item: &view_item, env: ()) {\n@@ -439,12 +439,12 @@ impl Visitor<()> for IdVisitor {\n                 }\n             }\n         }\n-        visit::visit_view_item(self as @Visitor<()>, view_item, env)\n+        visit::visit_view_item(self as @mut Visitor<()>, view_item, env)\n     }\n \n     fn visit_foreign_item(@mut self, foreign_item: @foreign_item, env: ()) {\n         (self.visit_callback)(foreign_item.id);\n-        visit::visit_foreign_item(self as @Visitor<()>, foreign_item, env)\n+        visit::visit_foreign_item(self as @mut Visitor<()>, foreign_item, env)\n     }\n \n     fn visit_item(@mut self, item: @item, env: ()) {\n@@ -466,39 +466,39 @@ impl Visitor<()> for IdVisitor {\n             _ => {}\n         }\n \n-        visit::visit_item(self as @Visitor<()>, item, env);\n+        visit::visit_item(self as @mut Visitor<()>, item, env);\n \n         self.visited_outermost = false\n     }\n \n     fn visit_local(@mut self, local: @Local, env: ()) {\n         (self.visit_callback)(local.id);\n-        visit::visit_local(self as @Visitor<()>, local, env)\n+        visit::visit_local(self as @mut Visitor<()>, local, env)\n     }\n \n     fn visit_block(@mut self, block: &Block, env: ()) {\n         (self.visit_callback)(block.id);\n-        visit::visit_block(self as @Visitor<()>, block, env)\n+        visit::visit_block(self as @mut Visitor<()>, block, env)\n     }\n \n     fn visit_stmt(@mut self, statement: @stmt, env: ()) {\n         (self.visit_callback)(ast_util::stmt_id(statement));\n-        visit::visit_stmt(self as @Visitor<()>, statement, env)\n+        visit::visit_stmt(self as @mut Visitor<()>, statement, env)\n     }\n \n     // XXX: Default\n     fn visit_arm(@mut self, arm: &arm, env: ()) {\n-        visit::visit_arm(self as @Visitor<()>, arm, env)\n+        visit::visit_arm(self as @mut Visitor<()>, arm, env)\n     }\n \n     fn visit_pat(@mut self, pattern: @pat, env: ()) {\n         (self.visit_callback)(pattern.id);\n-        visit::visit_pat(self as @Visitor<()>, pattern, env)\n+        visit::visit_pat(self as @mut Visitor<()>, pattern, env)\n     }\n \n     // XXX: Default\n     fn visit_decl(@mut self, declaration: @decl, env: ()) {\n-        visit::visit_decl(self as @Visitor<()>, declaration, env)\n+        visit::visit_decl(self as @mut Visitor<()>, declaration, env)\n     }\n \n     fn visit_expr(@mut self, expression: @expr, env: ()) {\n@@ -509,7 +509,7 @@ impl Visitor<()> for IdVisitor {\n             }\n         }\n         (self.visit_callback)(expression.id);\n-        visit::visit_expr(self as @Visitor<()>, expression, env)\n+        visit::visit_expr(self as @mut Visitor<()>, expression, env)\n     }\n \n     // XXX: Default\n@@ -523,12 +523,12 @@ impl Visitor<()> for IdVisitor {\n             ty_path(_, _, id) => (self.visit_callback)(id),\n             _ => {}\n         }\n-        visit::visit_ty(self as @Visitor<()>, typ, env)\n+        visit::visit_ty(self as @mut Visitor<()>, typ, env)\n     }\n \n     fn visit_generics(@mut self, generics: &Generics, env: ()) {\n         self.visit_generics_helper(generics);\n-        visit::visit_generics(self as @Visitor<()>, generics, env)\n+        visit::visit_generics(self as @mut Visitor<()>, generics, env)\n     }\n \n     fn visit_fn(@mut self,\n@@ -563,7 +563,7 @@ impl Visitor<()> for IdVisitor {\n             (self.visit_callback)(argument.id)\n         }\n \n-        visit::visit_fn(self as @Visitor<()>,\n+        visit::visit_fn(self as @mut Visitor<()>,\n                         function_kind,\n                         function_declaration,\n                         block,\n@@ -581,12 +581,12 @@ impl Visitor<()> for IdVisitor {\n \n     // XXX: Default\n     fn visit_ty_method(@mut self, type_method: &TypeMethod, env: ()) {\n-        visit::visit_ty_method(self as @Visitor<()>, type_method, env)\n+        visit::visit_ty_method(self as @mut Visitor<()>, type_method, env)\n     }\n \n     // XXX: Default\n     fn visit_trait_method(@mut self, trait_method: &trait_method, env: ()) {\n-        visit::visit_trait_method(self as @Visitor<()>, trait_method, env)\n+        visit::visit_trait_method(self as @mut Visitor<()>, trait_method, env)\n     }\n \n     // XXX: Default\n@@ -596,7 +596,7 @@ impl Visitor<()> for IdVisitor {\n                         generics: &Generics,\n                         node_id: NodeId,\n                         env: ()) {\n-        visit::visit_struct_def(self as @Visitor<()>,\n+        visit::visit_struct_def(self as @mut Visitor<()>,\n                                 struct_definition,\n                                 identifier,\n                                 generics,\n@@ -606,18 +606,18 @@ impl Visitor<()> for IdVisitor {\n \n     fn visit_struct_field(@mut self, struct_field: @struct_field, env: ()) {\n         (self.visit_callback)(struct_field.node.id);\n-        visit::visit_struct_field(self as @Visitor<()>, struct_field, env)\n+        visit::visit_struct_field(self as @mut Visitor<()>, struct_field, env)\n     }\n }\n \n pub fn id_visitor(vfn: @fn(NodeId), pass_through_items: bool)\n-                  -> @Visitor<()> {\n-    let visitor = @IdVisitor {\n+                  -> @mut Visitor<()> {\n+    let visitor = @mut IdVisitor {\n         visit_callback: vfn,\n         pass_through_items: pass_through_items,\n         visited_outermost: false,\n     };\n-    visitor as @Visitor<()>\n+    visitor as @mut Visitor<()>\n }\n \n pub fn visit_ids_for_inlined_item(item: &inlined_item, vfn: @fn(NodeId)) {\n@@ -757,9 +757,9 @@ impl EachViewItem for ast::Crate {\n             callback: f,\n         };\n         let visitor = @mut SimpleVisitorVisitor {\n-            simple_visitor: data as @SimpleVisitor,\n+            simple_visitor: data as @mut SimpleVisitor,\n         };\n-        visit::visit_crate(visitor as @Visitor<()>, self, ());\n+        visit::visit_crate(visitor as @mut Visitor<()>, self, ());\n         true\n     }\n }"}, {"sha": "47d8ebecca06a313fb68f3c49b07d6c7c116bbc6", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -313,7 +313,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n     no_cfgs || some_cfg_matches\n }\n \n-pub fn require_unique_names(diagnostic: @span_handler,\n+pub fn require_unique_names(diagnostic: @mut span_handler,\n                             metas: &[@MetaItem]) {\n     let mut set = HashSet::new();\n     for meta in metas.iter() {"}, {"sha": "5cdfe8e0f110b5298879198d58fe7d2d8d11a63d", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -50,7 +50,7 @@ pub trait span_handler {\n     fn span_note(@mut self, sp: span, msg: &str);\n     fn span_bug(@mut self, sp: span, msg: &str) -> !;\n     fn span_unimpl(@mut self, sp: span, msg: &str) -> !;\n-    fn handler(@mut self) -> @handler;\n+    fn handler(@mut self) -> @mut handler;\n }\n \n struct HandlerT {\n@@ -59,7 +59,7 @@ struct HandlerT {\n }\n \n struct CodemapT {\n-    handler: @handler,\n+    handler: @mut handler,\n     cm: @codemap::CodeMap,\n }\n \n@@ -84,7 +84,7 @@ impl span_handler for CodemapT {\n     fn span_unimpl(@mut self, sp: span, msg: &str) -> ! {\n         self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n-    fn handler(@mut self) -> @handler {\n+    fn handler(@mut self) -> @mut handler {\n         self.handler\n     }\n }\n@@ -143,12 +143,12 @@ pub fn ice_msg(msg: &str) -> ~str {\n     fmt!(\"internal compiler error: %s\", msg)\n }\n \n-pub fn mk_span_handler(handler: @handler, cm: @codemap::CodeMap)\n-                    -> @span_handler {\n-    @mut CodemapT { handler: handler, cm: cm } as @span_handler\n+pub fn mk_span_handler(handler: @mut handler, cm: @codemap::CodeMap)\n+                    -> @mut span_handler {\n+    @mut CodemapT { handler: handler, cm: cm } as @mut span_handler\n }\n \n-pub fn mk_handler(emitter: Option<Emitter>) -> @handler {\n+pub fn mk_handler(emitter: Option<Emitter>) -> @mut handler {\n     let emit: Emitter = match emitter {\n         Some(e) => e,\n         None => {\n@@ -157,7 +157,7 @@ pub fn mk_handler(emitter: Option<Emitter>) -> @handler {\n         }\n     };\n \n-    @mut HandlerT { err_count: 0, emit: emit } as @handler\n+    @mut HandlerT { err_count: 0, emit: emit } as @mut handler\n }\n \n #[deriving(Eq)]\n@@ -341,7 +341,7 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n     }\n }\n \n-pub fn expect<T:Clone>(diag: @span_handler,\n+pub fn expect<T:Clone>(diag: @mut span_handler,\n                        opt: Option<T>,\n                        msg: &fn() -> ~str) -> T {\n     match opt {"}, {"sha": "1547446957ed4a194da272b0d5c1a30ded60f57b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -548,64 +548,64 @@ impl Visitor<()> for NewNameFinderContext {\n                 }\n             }\n             // use the default traversal for non-pat_idents\n-            _ => visit::visit_pat(self as @Visitor<()>, pattern, ())\n+            _ => visit::visit_pat(self as @mut Visitor<()>, pattern, ())\n         }\n     }\n \n     // XXX: Methods below can become default methods.\n \n     fn visit_mod(@mut self, module: &ast::_mod, _: span, _: NodeId, _: ()) {\n-        visit::visit_mod(self as @Visitor<()>, module, ())\n+        visit::visit_mod(self as @mut Visitor<()>, module, ())\n     }\n \n     fn visit_view_item(@mut self, view_item: &ast::view_item, _: ()) {\n-        visit::visit_view_item(self as @Visitor<()>, view_item, ())\n+        visit::visit_view_item(self as @mut Visitor<()>, view_item, ())\n     }\n \n     fn visit_item(@mut self, item: @ast::item, _: ()) {\n-        visit::visit_item(self as @Visitor<()>, item, ())\n+        visit::visit_item(self as @mut Visitor<()>, item, ())\n     }\n \n     fn visit_foreign_item(@mut self,\n                           foreign_item: @ast::foreign_item,\n                           _: ()) {\n-        visit::visit_foreign_item(self as @Visitor<()>, foreign_item, ())\n+        visit::visit_foreign_item(self as @mut Visitor<()>, foreign_item, ())\n     }\n \n     fn visit_local(@mut self, local: @ast::Local, _: ()) {\n-        visit::visit_local(self as @Visitor<()>, local, ())\n+        visit::visit_local(self as @mut Visitor<()>, local, ())\n     }\n \n     fn visit_block(@mut self, block: &ast::Block, _: ()) {\n-        visit::visit_block(self as @Visitor<()>, block, ())\n+        visit::visit_block(self as @mut Visitor<()>, block, ())\n     }\n \n     fn visit_stmt(@mut self, stmt: @ast::stmt, _: ()) {\n-        visit::visit_stmt(self as @Visitor<()>, stmt, ())\n+        visit::visit_stmt(self as @mut Visitor<()>, stmt, ())\n     }\n \n     fn visit_arm(@mut self, arm: &ast::arm, _: ()) {\n-        visit::visit_arm(self as @Visitor<()>, arm, ())\n+        visit::visit_arm(self as @mut Visitor<()>, arm, ())\n     }\n \n     fn visit_decl(@mut self, decl: @ast::decl, _: ()) {\n-        visit::visit_decl(self as @Visitor<()>, decl, ())\n+        visit::visit_decl(self as @mut Visitor<()>, decl, ())\n     }\n \n     fn visit_expr(@mut self, expr: @ast::expr, _: ()) {\n-        visit::visit_expr(self as @Visitor<()>, expr, ())\n+        visit::visit_expr(self as @mut Visitor<()>, expr, ())\n     }\n \n     fn visit_expr_post(@mut self, _: @ast::expr, _: ()) {\n         // Empty!\n     }\n \n     fn visit_ty(@mut self, typ: &ast::Ty, _: ()) {\n-        visit::visit_ty(self as @Visitor<()>, typ, ())\n+        visit::visit_ty(self as @mut Visitor<()>, typ, ())\n     }\n \n     fn visit_generics(@mut self, generics: &ast::Generics, _: ()) {\n-        visit::visit_generics(self as @Visitor<()>, generics, ())\n+        visit::visit_generics(self as @mut Visitor<()>, generics, ())\n     }\n \n     fn visit_fn(@mut self,\n@@ -615,7 +615,7 @@ impl Visitor<()> for NewNameFinderContext {\n                 span: span,\n                 node_id: NodeId,\n                 _: ()) {\n-        visit::visit_fn(self as @Visitor<()>,\n+        visit::visit_fn(self as @mut Visitor<()>,\n                         function_kind,\n                         function_declaration,\n                         block,\n@@ -625,13 +625,13 @@ impl Visitor<()> for NewNameFinderContext {\n     }\n \n     fn visit_ty_method(@mut self, ty_method: &ast::TypeMethod, _: ()) {\n-        visit::visit_ty_method(self as @Visitor<()>, ty_method, ())\n+        visit::visit_ty_method(self as @mut Visitor<()>, ty_method, ())\n     }\n \n     fn visit_trait_method(@mut self,\n                           trait_method: &ast::trait_method,\n                           _: ()) {\n-        visit::visit_trait_method(self as @Visitor<()>, trait_method, ())\n+        visit::visit_trait_method(self as @mut Visitor<()>, trait_method, ())\n     }\n \n     fn visit_struct_def(@mut self,\n@@ -640,7 +640,7 @@ impl Visitor<()> for NewNameFinderContext {\n                         generics: &ast::Generics,\n                         node_id: NodeId,\n                         _: ()) {\n-        visit::visit_struct_def(self as @Visitor<()>,\n+        visit::visit_struct_def(self as @mut Visitor<()>,\n                                 struct_def,\n                                 ident,\n                                 generics,\n@@ -651,18 +651,18 @@ impl Visitor<()> for NewNameFinderContext {\n     fn visit_struct_field(@mut self,\n                           struct_field: @ast::struct_field,\n                           _: ()) {\n-        visit::visit_struct_field(self as @Visitor<()>, struct_field, ())\n+        visit::visit_struct_field(self as @mut Visitor<()>, struct_field, ())\n     }\n }\n \n // return a visitor that extracts the pat_ident paths\n // from a given pattern and puts them in a mutable\n // array (passed in to the traversal)\n-pub fn new_name_finder(idents: @mut ~[ast::ident]) -> @Visitor<()> {\n+pub fn new_name_finder(idents: @mut ~[ast::ident]) -> @mut Visitor<()> {\n     let context = @mut NewNameFinderContext {\n         ident_accumulator: idents,\n     };\n-    context as @Visitor<()>\n+    context as @mut Visitor<()>\n }\n \n pub fn expand_block(extsbox: @mut SyntaxEnv,"}, {"sha": "f3e7613d96a34547605a0624032e089e515fbfe4", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -25,7 +25,7 @@ pub fn expand_trace_macros(cx: @ExtCtxt,\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                None,\n                                tt.to_owned());\n-    let rdr = tt_rdr as @reader;\n+    let rdr = tt_rdr as @mut reader;\n     let rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n     if rust_parser.is_keyword(keywords::True) {"}, {"sha": "c208a7f7e3e403b77ab9fa6144027158527fe32d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -224,7 +224,7 @@ pub enum parse_result {\n pub fn parse_or_else(\n     sess: @mut ParseSess,\n     cfg: ast::CrateConfig,\n-    rdr: @reader,\n+    rdr: @mut reader,\n     ms: ~[matcher]\n ) -> HashMap<ident, @named_match> {\n     match parse(sess, cfg, rdr, ms) {\n@@ -237,7 +237,7 @@ pub fn parse_or_else(\n pub fn parse(\n     sess: @mut ParseSess,\n     cfg: ast::CrateConfig,\n-    rdr: @reader,\n+    rdr: @mut reader,\n     ms: &[matcher]\n ) -> parse_result {\n     let mut cur_eis = ~[];"}, {"sha": "54ac1f1e48f44a698a6510a021cc7b5cbfb2b4d6", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -59,7 +59,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n                                    arg.clone());\n     let argument_map = parse_or_else(cx.parse_sess(),\n                                      cx.cfg(),\n-                                     arg_reader as @reader,\n+                                     arg_reader as @mut reader,\n                                      argument_gram);\n \n     // Extract the arguments:\n@@ -101,7 +101,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n                     s_d,\n                     None,\n                     arg.to_owned()\n-                ) as @reader;\n+                ) as @mut reader;\n                 match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n                   success(named_matches) => {\n                     let rhs = match rhses[i] {\n@@ -123,7 +123,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n                                                rhs);\n                     let p = @Parser(cx.parse_sess(),\n                                     cx.cfg(),\n-                                    trncbr as @reader);\n+                                    trncbr as @mut reader);\n \n                     // Let the context choose how to interpret the result.\n                     // Weird, but useful for X-macros."}, {"sha": "13bad252243090552db2549b7189d654242d5a57", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -30,7 +30,7 @@ struct TtFrame {\n }\n \n pub struct TtReader {\n-    sp_diag: @span_handler,\n+    sp_diag: @mut span_handler,\n     // the unzipped tree:\n     stack: @mut TtFrame,\n     /* for MBE-style macro transcription */\n@@ -45,7 +45,7 @@ pub struct TtReader {\n /** This can do Macro-By-Example transcription. On the other hand, if\n  *  `src` contains no `tt_seq`s and `tt_nonterminal`s, `interp` can (and\n  *  should) be none. */\n-pub fn new_tt_reader(sp_diag: @span_handler,\n+pub fn new_tt_reader(sp_diag: @mut span_handler,\n                      interp: Option<HashMap<ident,@named_match>>,\n                      src: ~[ast::token_tree])\n                   -> @mut TtReader {"}, {"sha": "9a9164f510210376cc2a9fcfe0497e213e49c41a", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -267,7 +267,7 @@ fn read_block_comment(rdr: @mut StringReader,\n         while level > 0 {\n             debug!(\"=== block comment level %d\", level);\n             if is_eof(rdr) {\n-                (rdr as @reader).fatal(~\"unterminated block comment\");\n+                (rdr as @mut reader).fatal(~\"unterminated block comment\");\n             }\n             if rdr.curr == '\\n' {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line,\n@@ -334,7 +334,7 @@ pub struct lit {\n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic:\n-                                    @diagnostic::span_handler,\n+                                    @mut diagnostic::span_handler,\n                                     path: @str,\n                                     srdr: @io::Reader)\n                                  -> (~[cmnt], ~[lit]) {"}, {"sha": "d0041021f7cc77158a8e1fa130a1c8bf4a361e75", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -28,9 +28,9 @@ pub trait reader {\n     fn is_eof(@mut self) -> bool;\n     fn next_token(@mut self) -> TokenAndSpan;\n     fn fatal(@mut self, ~str) -> !;\n-    fn span_diag(@mut self) -> @span_handler;\n+    fn span_diag(@mut self) -> @mut span_handler;\n     fn peek(@mut self) -> TokenAndSpan;\n-    fn dup(@mut self) -> @reader;\n+    fn dup(@mut self) -> @mut reader;\n }\n \n #[deriving(Clone, Eq)]\n@@ -40,7 +40,7 @@ pub struct TokenAndSpan {\n }\n \n pub struct StringReader {\n-    span_diagnostic: @span_handler,\n+    span_diagnostic: @mut span_handler,\n     src: @str,\n     // The absolute offset within the codemap of the next character to read\n     pos: BytePos,\n@@ -56,7 +56,7 @@ pub struct StringReader {\n     peek_span: span\n }\n \n-pub fn new_string_reader(span_diagnostic: @span_handler,\n+pub fn new_string_reader(span_diagnostic: @mut span_handler,\n                          filemap: @codemap::FileMap)\n                       -> @mut StringReader {\n     let r = new_low_level_string_reader(span_diagnostic, filemap);\n@@ -65,13 +65,14 @@ pub fn new_string_reader(span_diagnostic: @span_handler,\n }\n \n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n-pub fn new_low_level_string_reader(span_diagnostic: @span_handler,\n+pub fn new_low_level_string_reader(span_diagnostic: @mut span_handler,\n                                    filemap: @codemap::FileMap)\n                                 -> @mut StringReader {\n     // Force the initial reader bump to start on a fresh line\n     let initial_char = '\\n';\n     let r = @mut StringReader {\n-        span_diagnostic: span_diagnostic, src: filemap.src,\n+        span_diagnostic: span_diagnostic,\n+        src: filemap.src,\n         pos: filemap.start_pos,\n         last_pos: filemap.start_pos,\n         col: CharPos(0),\n@@ -116,15 +117,15 @@ impl reader for StringReader {\n     fn fatal(@mut self, m: ~str) -> ! {\n         self.span_diagnostic.span_fatal(self.peek_span, m)\n     }\n-    fn span_diag(@mut self) -> @span_handler { self.span_diagnostic }\n+    fn span_diag(@mut self) -> @mut span_handler { self.span_diagnostic }\n     fn peek(@mut self) -> TokenAndSpan {\n         // XXX(pcwalton): Bad copy!\n         TokenAndSpan {\n             tok: self.peek_tok.clone(),\n             sp: self.peek_span,\n         }\n     }\n-    fn dup(@mut self) -> @reader { dup_string_reader(self) as @reader }\n+    fn dup(@mut self) -> @mut reader { dup_string_reader(self) as @mut reader }\n }\n \n impl reader for TtReader {\n@@ -137,14 +138,14 @@ impl reader for TtReader {\n     fn fatal(@mut self, m: ~str) -> ! {\n         self.sp_diag.span_fatal(self.cur_span, m);\n     }\n-    fn span_diag(@mut self) -> @span_handler { self.sp_diag }\n+    fn span_diag(@mut self) -> @mut span_handler { self.sp_diag }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: self.cur_tok.clone(),\n             sp: self.cur_span,\n         }\n     }\n-    fn dup(@mut self) -> @reader { dup_tt_reader(self) as @reader }\n+    fn dup(@mut self) -> @mut reader { dup_tt_reader(self) as @mut reader }\n }\n \n // EFFECT: advance peek_tok and peek_span to refer to the next token."}, {"sha": "23c6a8b97208b014aa3f782fa96d2a7ec61a6980", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -43,7 +43,7 @@ pub mod obsolete;\n pub struct ParseSess {\n     cm: @codemap::CodeMap, // better be the same as the one in the reader!\n     next_id: NodeId,\n-    span_diagnostic: @span_handler, // better be the same as the one in the reader!\n+    span_diagnostic: @mut span_handler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: ~[Path],\n }\n@@ -58,7 +58,7 @@ pub fn new_parse_sess(demitter: Option<Emitter>) -> @mut ParseSess {\n     }\n }\n \n-pub fn new_parse_sess_special_handler(sh: @span_handler,\n+pub fn new_parse_sess_special_handler(sh: @mut span_handler,\n                                       cm: @codemap::CodeMap)\n                                    -> @mut ParseSess {\n     @mut ParseSess {\n@@ -306,7 +306,7 @@ pub fn filemap_to_tts(sess: @mut ParseSess, filemap: @FileMap)\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = ~[];\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap);\n-    let p1 = Parser(sess, cfg, srdr as @reader);\n+    let p1 = Parser(sess, cfg, srdr as @mut reader);\n     p1.parse_all_token_trees()\n }\n \n@@ -315,7 +315,7 @@ pub fn tts_to_parser(sess: @mut ParseSess,\n                      tts: ~[ast::token_tree],\n                      cfg: ast::CrateConfig) -> Parser {\n     let trdr = lexer::new_tt_reader(sess.span_diagnostic, None, tts);\n-    Parser(sess, cfg, trdr as @reader)\n+    Parser(sess, cfg, trdr as @mut reader)\n }\n \n // abort if necessary"}, {"sha": "27e339f000c297ac1002bd472e0c98afa0182199", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -265,7 +265,7 @@ struct ParsedItemsAndViewItems {\n \n pub fn Parser(sess: @mut ParseSess,\n               cfg: ast::CrateConfig,\n-              rdr: @reader)\n+              rdr: @mut reader)\n            -> Parser {\n     let tok0 = rdr.next_token();\n     let interner = get_ident_interner();\n@@ -315,7 +315,7 @@ pub struct Parser {\n     tokens_consumed: @mut uint,\n     restriction: @mut restriction,\n     quote_depth: @mut uint, // not (yet) related to the quasiquoter\n-    reader: @reader,\n+    reader: @mut reader,\n     interner: @token::ident_interner,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice"}, {"sha": "6a3d829aca0b037d8231ef90cc04e2dac0066220", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -104,7 +104,7 @@ pub static default_columns: uint = 78u;\n // copy forward.\n pub fn print_crate(cm: @CodeMap,\n                    intr: @ident_interner,\n-                   span_diagnostic: @diagnostic::span_handler,\n+                   span_diagnostic: @mut diagnostic::span_handler,\n                    crate: &ast::Crate,\n                    filename: @str,\n                    input: @io::Reader,"}, {"sha": "c3a5ba7116d9197cd9a207aded1c286829e045cd", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -88,11 +88,11 @@ pub trait Visitor<E> {\n     fn visit_struct_field(@mut self, @struct_field, E);\n }\n \n-pub fn visit_crate<E:Clone>(visitor: @Visitor<E>, crate: &Crate, env: E) {\n+pub fn visit_crate<E:Clone>(visitor: @mut Visitor<E>, crate: &Crate, env: E) {\n     visitor.visit_mod(&crate.module, crate.span, CRATE_NODE_ID, env)\n }\n \n-pub fn visit_mod<E:Clone>(visitor: @Visitor<E>, module: &_mod, env: E) {\n+pub fn visit_mod<E:Clone>(visitor: @mut Visitor<E>, module: &_mod, env: E) {\n     for view_item in module.view_items.iter() {\n         visitor.visit_view_item(view_item, env.clone())\n     }\n@@ -101,11 +101,11 @@ pub fn visit_mod<E:Clone>(visitor: @Visitor<E>, module: &_mod, env: E) {\n     }\n }\n \n-pub fn visit_view_item<E:Clone>(_: @Visitor<E>, _: &view_item, _: E) {\n+pub fn visit_view_item<E:Clone>(_: @mut Visitor<E>, _: &view_item, _: E) {\n     // Empty!\n }\n \n-pub fn visit_local<E:Clone>(visitor: @Visitor<E>, local: &Local, env: E) {\n+pub fn visit_local<E:Clone>(visitor: @mut Visitor<E>, local: &Local, env: E) {\n     visitor.visit_pat(local.pat, env.clone());\n     visitor.visit_ty(&local.ty, env.clone());\n     match local.init {\n@@ -114,13 +114,13 @@ pub fn visit_local<E:Clone>(visitor: @Visitor<E>, local: &Local, env: E) {\n     }\n }\n \n-fn visit_trait_ref<E:Clone>(visitor: @Visitor<E>,\n+fn visit_trait_ref<E:Clone>(visitor: @mut Visitor<E>,\n                             trait_ref: &ast::trait_ref,\n                             env: E) {\n     visit_path(visitor, &trait_ref.path, env)\n }\n \n-pub fn visit_item<E:Clone>(visitor: @Visitor<E>, item: &item, env: E) {\n+pub fn visit_item<E:Clone>(visitor: @mut Visitor<E>, item: &item, env: E) {\n     match item.node {\n         item_static(ref typ, _, expr) => {\n             visitor.visit_ty(typ, env.clone());\n@@ -187,7 +187,7 @@ pub fn visit_item<E:Clone>(visitor: @Visitor<E>, item: &item, env: E) {\n     }\n }\n \n-pub fn visit_enum_def<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_enum_def<E:Clone>(visitor: @mut Visitor<E>,\n                                enum_definition: &ast::enum_def,\n                                generics: &Generics,\n                                env: E) {\n@@ -209,11 +209,11 @@ pub fn visit_enum_def<E:Clone>(visitor: @Visitor<E>,\n     }\n }\n \n-pub fn skip_ty<E>(_: @Visitor<E>, _: &Ty, _: E) {\n+pub fn skip_ty<E>(_: @mut Visitor<E>, _: &Ty, _: E) {\n     // Empty!\n }\n \n-pub fn visit_ty<E:Clone>(visitor: @Visitor<E>, typ: &Ty, env: E) {\n+pub fn visit_ty<E:Clone>(visitor: @mut Visitor<E>, typ: &Ty, env: E) {\n     match typ.node {\n         ty_box(ref mutable_type) | ty_uniq(ref mutable_type) |\n         ty_vec(ref mutable_type) | ty_ptr(ref mutable_type) |\n@@ -254,13 +254,13 @@ pub fn visit_ty<E:Clone>(visitor: @Visitor<E>, typ: &Ty, env: E) {\n     }\n }\n \n-pub fn visit_path<E:Clone>(visitor: @Visitor<E>, path: &Path, env: E) {\n+pub fn visit_path<E:Clone>(visitor: @mut Visitor<E>, path: &Path, env: E) {\n     for typ in path.types.iter() {\n         visitor.visit_ty(typ, env.clone())\n     }\n }\n \n-pub fn visit_pat<E:Clone>(visitor: @Visitor<E>, pattern: &pat, env: E) {\n+pub fn visit_pat<E:Clone>(visitor: @mut Visitor<E>, pattern: &pat, env: E) {\n     match pattern.node {\n         pat_enum(ref path, ref children) => {\n             visit_path(visitor, path, env.clone());\n@@ -313,7 +313,7 @@ pub fn visit_pat<E:Clone>(visitor: @Visitor<E>, pattern: &pat, env: E) {\n     }\n }\n \n-pub fn visit_foreign_item<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_foreign_item<E:Clone>(visitor: @mut Visitor<E>,\n                                    foreign_item: &foreign_item,\n                                    env: E) {\n     match foreign_item.node {\n@@ -325,7 +325,7 @@ pub fn visit_foreign_item<E:Clone>(visitor: @Visitor<E>,\n     }\n }\n \n-pub fn visit_ty_param_bounds<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_ty_param_bounds<E:Clone>(visitor: @mut Visitor<E>,\n                                       bounds: &OptVec<TyParamBound>,\n                                       env: E) {\n     for bound in bounds.iter() {\n@@ -338,15 +338,15 @@ pub fn visit_ty_param_bounds<E:Clone>(visitor: @Visitor<E>,\n     }\n }\n \n-pub fn visit_generics<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_generics<E:Clone>(visitor: @mut Visitor<E>,\n                                generics: &Generics,\n                                env: E) {\n     for type_parameter in generics.ty_params.iter() {\n         visit_ty_param_bounds(visitor, &type_parameter.bounds, env.clone())\n     }\n }\n \n-pub fn visit_fn_decl<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_fn_decl<E:Clone>(visitor: @mut Visitor<E>,\n                               function_declaration: &fn_decl,\n                               env: E) {\n     for argument in function_declaration.inputs.iter() {\n@@ -360,7 +360,7 @@ pub fn visit_fn_decl<E:Clone>(visitor: @Visitor<E>,\n // visit_fn() and check for fk_method().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n-pub fn visit_method_helper<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_method_helper<E:Clone>(visitor: @mut Visitor<E>,\n                                     method: &method,\n                                     env: E) {\n     visitor.visit_fn(&fk_method(method.ident, &method.generics, method),\n@@ -371,7 +371,7 @@ pub fn visit_method_helper<E:Clone>(visitor: @Visitor<E>,\n                      env)\n }\n \n-pub fn visit_fn<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_fn<E:Clone>(visitor: @mut Visitor<E>,\n                          function_kind: &fn_kind,\n                          function_declaration: &fn_decl,\n                          function_body: &Block,\n@@ -384,7 +384,7 @@ pub fn visit_fn<E:Clone>(visitor: @Visitor<E>,\n     visitor.visit_block(function_body, env)\n }\n \n-pub fn visit_ty_method<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_ty_method<E:Clone>(visitor: @mut Visitor<E>,\n                                 method_type: &TypeMethod,\n                                 env: E) {\n     for argument_type in method_type.decl.inputs.iter() {\n@@ -394,7 +394,7 @@ pub fn visit_ty_method<E:Clone>(visitor: @Visitor<E>,\n     visitor.visit_ty(&method_type.decl.output, env.clone())\n }\n \n-pub fn visit_trait_method<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_trait_method<E:Clone>(visitor: @mut Visitor<E>,\n                                    trait_method: &trait_method,\n                                    env: E) {\n     match *trait_method {\n@@ -405,7 +405,7 @@ pub fn visit_trait_method<E:Clone>(visitor: @Visitor<E>,\n     }\n }\n \n-pub fn visit_struct_def<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_struct_def<E:Clone>(visitor: @mut Visitor<E>,\n                                  struct_definition: @struct_def,\n                                  _: ast::ident,\n                                  _: &Generics,\n@@ -416,13 +416,13 @@ pub fn visit_struct_def<E:Clone>(visitor: @Visitor<E>,\n     }\n }\n \n-pub fn visit_struct_field<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_struct_field<E:Clone>(visitor: @mut Visitor<E>,\n                                    struct_field: &struct_field,\n                                    env: E) {\n     visitor.visit_ty(&struct_field.node.ty, env)\n }\n \n-pub fn visit_block<E:Clone>(visitor: @Visitor<E>, block: &Block, env: E) {\n+pub fn visit_block<E:Clone>(visitor: @mut Visitor<E>, block: &Block, env: E) {\n     for view_item in block.view_items.iter() {\n         visitor.visit_view_item(view_item, env.clone())\n     }\n@@ -432,7 +432,7 @@ pub fn visit_block<E:Clone>(visitor: @Visitor<E>, block: &Block, env: E) {\n     visit_expr_opt(visitor, block.expr, env)\n }\n \n-pub fn visit_stmt<E>(visitor: @Visitor<E>, statement: &stmt, env: E) {\n+pub fn visit_stmt<E>(visitor: @mut Visitor<E>, statement: &stmt, env: E) {\n     match statement.node {\n         stmt_decl(declaration, _) => visitor.visit_decl(declaration, env),\n         stmt_expr(expression, _) | stmt_semi(expression, _) => {\n@@ -442,14 +442,14 @@ pub fn visit_stmt<E>(visitor: @Visitor<E>, statement: &stmt, env: E) {\n     }\n }\n \n-pub fn visit_decl<E:Clone>(visitor: @Visitor<E>, declaration: &decl, env: E) {\n+pub fn visit_decl<E:Clone>(visitor: @mut Visitor<E>, declaration: &decl, env: E) {\n     match declaration.node {\n         decl_local(ref local) => visitor.visit_local(*local, env),\n         decl_item(item) => visitor.visit_item(item, env),\n     }\n }\n \n-pub fn visit_expr_opt<E>(visitor: @Visitor<E>,\n+pub fn visit_expr_opt<E>(visitor: @mut Visitor<E>,\n                          optional_expression: Option<@expr>,\n                          env: E) {\n     match optional_expression {\n@@ -458,19 +458,19 @@ pub fn visit_expr_opt<E>(visitor: @Visitor<E>,\n     }\n }\n \n-pub fn visit_exprs<E:Clone>(visitor: @Visitor<E>,\n+pub fn visit_exprs<E:Clone>(visitor: @mut Visitor<E>,\n                             expressions: &[@expr],\n                             env: E) {\n     for expression in expressions.iter() {\n         visitor.visit_expr(*expression, env.clone())\n     }\n }\n \n-pub fn visit_mac<E>(_: @Visitor<E>, _: &mac, _: E) {\n+pub fn visit_mac<E>(_: @mut Visitor<E>, _: &mac, _: E) {\n     // Empty!\n }\n \n-pub fn visit_expr<E:Clone>(visitor: @Visitor<E>, expression: @expr, env: E) {\n+pub fn visit_expr<E:Clone>(visitor: @mut Visitor<E>, expression: @expr, env: E) {\n     match expression.node {\n         expr_vstore(subexpression, _) => {\n             visitor.visit_expr(subexpression, env.clone())\n@@ -595,7 +595,7 @@ pub fn visit_expr<E:Clone>(visitor: @Visitor<E>, expression: @expr, env: E) {\n     visitor.visit_expr_post(expression, env.clone())\n }\n \n-pub fn visit_arm<E:Clone>(visitor: @Visitor<E>, arm: &arm, env: E) {\n+pub fn visit_arm<E:Clone>(visitor: @mut Visitor<E>, arm: &arm, env: E) {\n     for pattern in arm.pats.iter() {\n         visitor.visit_pat(*pattern, env.clone())\n     }\n@@ -630,7 +630,7 @@ pub trait SimpleVisitor {\n }\n \n pub struct SimpleVisitorVisitor {\n-    simple_visitor: @SimpleVisitor,\n+    simple_visitor: @mut SimpleVisitor,\n }\n \n impl Visitor<()> for SimpleVisitorVisitor {\n@@ -640,58 +640,58 @@ impl Visitor<()> for SimpleVisitorVisitor {\n                  node_id: NodeId,\n                  env: ()) {\n         self.simple_visitor.visit_mod(module, span, node_id);\n-        visit_mod(self as @Visitor<()>, module, env)\n+        visit_mod(self as @mut Visitor<()>, module, env)\n     }\n     fn visit_view_item(@mut self, view_item: &view_item, env: ()) {\n         self.simple_visitor.visit_view_item(view_item);\n-        visit_view_item(self as @Visitor<()>, view_item, env)\n+        visit_view_item(self as @mut Visitor<()>, view_item, env)\n     }\n     fn visit_foreign_item(@mut self, foreign_item: @foreign_item, env: ()) {\n         self.simple_visitor.visit_foreign_item(foreign_item);\n-        visit_foreign_item(self as @Visitor<()>, foreign_item, env)\n+        visit_foreign_item(self as @mut Visitor<()>, foreign_item, env)\n     }\n     fn visit_item(@mut self, item: @item, env: ()) {\n         self.simple_visitor.visit_item(item);\n-        visit_item(self as @Visitor<()>, item, env)\n+        visit_item(self as @mut Visitor<()>, item, env)\n     }\n     fn visit_local(@mut self, local: @Local, env: ()) {\n         self.simple_visitor.visit_local(local);\n-        visit_local(self as @Visitor<()>, local, env)\n+        visit_local(self as @mut Visitor<()>, local, env)\n     }\n     fn visit_block(@mut self, block: &Block, env: ()) {\n         self.simple_visitor.visit_block(block);\n-        visit_block(self as @Visitor<()>, block, env)\n+        visit_block(self as @mut Visitor<()>, block, env)\n     }\n     fn visit_stmt(@mut self, statement: @stmt, env: ()) {\n         self.simple_visitor.visit_stmt(statement);\n-        visit_stmt(self as @Visitor<()>, statement, env)\n+        visit_stmt(self as @mut Visitor<()>, statement, env)\n     }\n     fn visit_arm(@mut self, arm: &arm, env: ()) {\n         self.simple_visitor.visit_arm(arm);\n-        visit_arm(self as @Visitor<()>, arm, env)\n+        visit_arm(self as @mut Visitor<()>, arm, env)\n     }\n     fn visit_pat(@mut self, pattern: @pat, env: ()) {\n         self.simple_visitor.visit_pat(pattern);\n-        visit_pat(self as @Visitor<()>, pattern, env)\n+        visit_pat(self as @mut Visitor<()>, pattern, env)\n     }\n     fn visit_decl(@mut self, declaration: @decl, env: ()) {\n         self.simple_visitor.visit_decl(declaration);\n-        visit_decl(self as @Visitor<()>, declaration, env)\n+        visit_decl(self as @mut Visitor<()>, declaration, env)\n     }\n     fn visit_expr(@mut self, expression: @expr, env: ()) {\n         self.simple_visitor.visit_expr(expression);\n-        visit_expr(self as @Visitor<()>, expression, env)\n+        visit_expr(self as @mut Visitor<()>, expression, env)\n     }\n     fn visit_expr_post(@mut self, expression: @expr, _: ()) {\n         self.simple_visitor.visit_expr_post(expression)\n     }\n     fn visit_ty(@mut self, typ: &Ty, env: ()) {\n         self.simple_visitor.visit_ty(typ);\n-        visit_ty(self as @Visitor<()>, typ, env)\n+        visit_ty(self as @mut Visitor<()>, typ, env)\n     }\n     fn visit_generics(@mut self, generics: &Generics, env: ()) {\n         self.simple_visitor.visit_generics(generics);\n-        visit_generics(self as @Visitor<()>, generics, env)\n+        visit_generics(self as @mut Visitor<()>, generics, env)\n     }\n     fn visit_fn(@mut self,\n                 function_kind: &fn_kind,\n@@ -705,7 +705,7 @@ impl Visitor<()> for SimpleVisitorVisitor {\n                                      block,\n                                      span,\n                                      node_id);\n-        visit_fn(self as @Visitor<()>,\n+        visit_fn(self as @mut Visitor<()>,\n                  function_kind,\n                  function_declaration,\n                  block,\n@@ -715,11 +715,11 @@ impl Visitor<()> for SimpleVisitorVisitor {\n     }\n     fn visit_ty_method(@mut self, method_type: &TypeMethod, env: ()) {\n         self.simple_visitor.visit_ty_method(method_type);\n-        visit_ty_method(self as @Visitor<()>, method_type, env)\n+        visit_ty_method(self as @mut Visitor<()>, method_type, env)\n     }\n     fn visit_trait_method(@mut self, trait_method: &trait_method, env: ()) {\n         self.simple_visitor.visit_trait_method(trait_method);\n-        visit_trait_method(self as @Visitor<()>, trait_method, env)\n+        visit_trait_method(self as @mut Visitor<()>, trait_method, env)\n     }\n     fn visit_struct_def(@mut self,\n                         struct_definition: @struct_def,\n@@ -731,7 +731,7 @@ impl Visitor<()> for SimpleVisitorVisitor {\n                                              identifier,\n                                              generics,\n                                              node_id);\n-        visit_struct_def(self as @Visitor<()>,\n+        visit_struct_def(self as @mut Visitor<()>,\n                          struct_definition,\n                          identifier,\n                          generics,\n@@ -740,7 +740,7 @@ impl Visitor<()> for SimpleVisitorVisitor {\n     }\n     fn visit_struct_field(@mut self, struct_field: @struct_field, env: ()) {\n         self.simple_visitor.visit_struct_field(struct_field);\n-        visit_struct_field(self as @Visitor<()>, struct_field, env)\n+        visit_struct_field(self as @mut Visitor<()>, struct_field, env)\n     }\n }\n "}, {"sha": "57538f1ec75dbf03c8e99c54b1f0bf02eaffce93", "filename": "src/rt/rust_type.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Frt%2Frust_type.h", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Frt%2Frust_type.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_type.h?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -58,6 +58,7 @@ struct type_desc {\n     glue_fn *drop_glue;\n     glue_fn *free_glue;\n     glue_fn *visit_glue;\n+    size_t borrow_offset;\n };\n \n extern \"C\" type_desc *rust_clone_type_desc(type_desc*);"}, {"sha": "28c69af427a32c54f75b8c0056b4b187f3b3444d", "filename": "src/rt/rust_util.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Frt%2Frust_util.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Frt%2Frust_util.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.cpp?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -21,6 +21,7 @@ struct type_desc str_body_tydesc = {\n     NULL, // drop_glue\n     NULL, // free_glue\n     NULL, // visit_glue\n+    0, // borrow_offset\n };\n \n //"}, {"sha": "502d7e017b5b10b132886e43576e73654eed9e3e", "filename": "src/test/compile-fail/borrowck-borrow-mut-object-twice.rs", "status": "renamed", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-object-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-object-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-object-twice.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -8,22 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {\n-    fn f(&self) -> int;\n-}\n+// Check that `&mut` objects cannot be borrowed twice, just like\n+// other `&mut` pointers.\n \n-struct Bar {\n-    x: int\n+trait Foo {\n+    fn f1<'a>(&'a mut self) -> &'a ();\n+    fn f2(&mut self);\n }\n \n-impl Foo for Bar {\n-    fn f(&self) -> int {\n-        self.x\n-    }\n+fn test(x: &mut Foo) {\n+    let _y = x.f1();\n+    x.f2(); //~ ERROR cannot borrow `*x` as mutable more than once at a time\n }\n \n-pub fn main() {\n-    let x = ~Bar { x: 10 };\n-    let y = x as ~Foo;\n-    assert_eq!(y.f(), 10);\n-}\n+fn main() {}", "previous_filename": "src/test/run-pass/unique-object.rs"}, {"sha": "25d5be7ed55d38e416224ec6ec00ff57fd77df4e", "filename": "src/test/compile-fail/borrowck-object-lifetime.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    fn borrowed<'a>(&'a self) -> &'a ();\n+}\n+\n+fn borrowed_receiver<'a>(x: &'a Foo) -> &'a () {\n+    x.borrowed()\n+}\n+\n+fn managed_receiver(x: @Foo) -> &() {\n+    x.borrowed() //~ ERROR cannot root managed value long enough\n+}\n+\n+fn managed_receiver_1(x: @Foo) {\n+    *x.borrowed()\n+}\n+\n+fn owned_receiver(x: ~Foo) -> &() {\n+    x.borrowed() //~ ERROR borrowed value does not live long enough\n+}\n+\n+fn mut_owned_receiver(mut x: ~Foo) {\n+    let _y = x.borrowed();\n+    let _z = &mut x; //~ ERROR cannot borrow\n+}\n+\n+fn imm_owned_receiver(mut x: ~Foo) {\n+    let _y = x.borrowed();\n+    let _z = &x;\n+}\n+\n+fn main() {}\n+"}, {"sha": "1ea9e3c8815a89d172fa52380d0dca060d12fc07", "filename": "src/test/compile-fail/borrowck-object-mutability.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    fn borrowed(&self);\n+    fn borrowed_mut(&mut self);\n+}\n+\n+fn borrowed_receiver(x: &Foo) {\n+    x.borrowed();\n+    x.borrowed_mut(); //~ ERROR cannot borrow\n+}\n+\n+fn borrowed_mut_receiver(x: &mut Foo) {\n+    x.borrowed();\n+    x.borrowed_mut();\n+}\n+\n+fn managed_receiver(x: @Foo) {\n+    x.borrowed();\n+    x.borrowed_mut(); //~ ERROR cannot borrow\n+}\n+\n+fn managed_mut_receiver(x: @mut Foo) {\n+    x.borrowed();\n+    x.borrowed_mut();\n+}\n+\n+fn owned_receiver(x: ~Foo) {\n+    x.borrowed();\n+    x.borrowed_mut(); //~ ERROR cannot borrow\n+}\n+\n+fn mut_owned_receiver(mut x: ~Foo) {\n+    x.borrowed();\n+    x.borrowed_mut();\n+}\n+\n+fn main() {}\n+"}, {"sha": "cf047674cd6c8d5007f70a1a24933e1af3f20d10", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -31,5 +31,4 @@ fn main() {\n     //~^ ERROR dereference of reference outside its lifetime\n     //~^^ ERROR automatically borrowed pointer is not valid at the time of borrow\n     //~^^^ ERROR lifetime of return value does not outlive the function call\n-    //~^^^^ ERROR cannot infer an appropriate lifetime\n }"}, {"sha": "b7d320fbab0ca9a139c03908c84dd442ea8c45fd", "filename": "src/test/compile-fail/object-pointer-types.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    fn borrowed(&self);\n+    fn borrowed_mut(&mut self);\n+\n+    fn managed(@self);\n+    fn managed_mut(@mut self);\n+\n+    fn owned(~self);\n+}\n+\n+fn borrowed_receiver(x: &Foo) {\n+    x.borrowed();\n+    x.borrowed_mut(); // See [1]\n+    x.managed(); //~ ERROR does not implement any method\n+    x.managed_mut(); //~ ERROR does not implement any method\n+    x.owned(); //~ ERROR does not implement any method\n+}\n+\n+fn borrowed_mut_receiver(x: &mut Foo) {\n+    x.borrowed();\n+    x.borrowed_mut();\n+    x.managed(); //~ ERROR does not implement any method\n+    x.managed_mut(); //~ ERROR does not implement any method\n+    x.owned(); //~ ERROR does not implement any method\n+}\n+\n+fn managed_receiver(x: @Foo) {\n+    x.borrowed();\n+    x.borrowed_mut(); // See [1]\n+    x.managed();\n+    x.managed_mut();  //~ ERROR does not implement any method\n+    x.owned(); //~ ERROR does not implement any method\n+}\n+\n+fn managed_mut_receiver(x: @mut Foo) {\n+    x.borrowed();\n+    x.borrowed_mut();\n+    x.managed();  //~ ERROR does not implement any method\n+    x.managed_mut();\n+    x.owned(); //~ ERROR does not implement any method\n+}\n+\n+fn owned_receiver(x: ~Foo) {\n+    x.borrowed();\n+    x.borrowed_mut(); // See [1]\n+    x.managed();  //~ ERROR does not implement any method\n+    x.managed_mut();  //~ ERROR does not implement any method\n+    x.owned();\n+}\n+\n+fn main() {}\n+\n+// [1]: These cases are illegal, but the error is not detected\n+// until borrowck, so see the test borrowck-object-mutability.rs"}, {"sha": "b5484b786a022e549127031ef7c7a7a7f05ed605", "filename": "src/test/compile-fail/selftype-traittype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -13,7 +13,7 @@ trait add {\n }\n \n fn do_add(x: @add, y: @add) -> @add {\n-    x.plus(y) //~ ERROR cannot call a method whose type contains a self-type through a boxed trait\n+    x.plus(y) //~ ERROR cannot call a method whose type contains a self-type through an object\n }\n \n fn main() {}"}, {"sha": "73f2cf095522849cdcb49769ae54f2fe4f7d1309", "filename": "src/test/run-fail/borrowck-wg-fail-object.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-fail-object.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -0,0 +1,21 @@\n+// error-pattern:borrowed\n+\n+trait Foo {\n+    fn foo(&self, @mut int);\n+}\n+\n+impl Foo for int {\n+    fn foo(&self, x: @mut int) {\n+        *x += *self;\n+    }\n+}\n+\n+fn main() {\n+    let x = @mut 3_i;\n+    let y = x as @mut Foo;\n+\n+    // The call to `y.foo(...)` should freeze `y` (and thus also `x`,\n+    // since `x === y`). It is thus an error when `foo` tries to\n+    // mutate `x`.\n+    y.foo(x);\n+}"}, {"sha": "737253a956fc02f9fc19e53961d60754ae35970f", "filename": "src/test/run-pass/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -56,6 +56,6 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n \n \n pub fn main() {\n-  let mut nyan: @noisy = @cat(0u, 2, ~\"nyan\") as @noisy;\n+  let nyan: @mut noisy = @mut cat(0u, 2, ~\"nyan\") as @mut noisy;\n   nyan.speak();\n }"}, {"sha": "23c271f53cac8866e2dede7ff7388345dd01f4f7", "filename": "src/test/run-pass/objects-owned-object-borrowed-method-header.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test invoked `&self` methods on owned objects where the values\n+// closed over contain managed values. This implies that the ~ boxes\n+// will have headers that must be skipped over.\n+\n+trait FooTrait {\n+    fn foo(&self) -> uint;\n+}\n+\n+struct BarStruct {\n+    x: @uint\n+}\n+\n+impl FooTrait for BarStruct {\n+    fn foo(&self) -> uint {\n+        *self.x\n+    }\n+}\n+\n+pub fn main() {\n+    let foos: ~[ ~FooTrait: ] = ~[\n+        ~BarStruct{ x: @0 } as ~FooTrait:,\n+        ~BarStruct{ x: @1 } as ~FooTrait:,\n+        ~BarStruct{ x: @2 } as ~FooTrait:\n+    ];\n+\n+    for i in range(0u, foos.len()) {\n+        assert_eq!(i, foos[i].foo());\n+    }\n+}"}, {"sha": "72ae7cf9bb9932c029344c01a9ee4c5c1671fa11", "filename": "src/test/run-pass/objects-owned-object-borrowed-method-headerless.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test invoked `&self` methods on owned objects where the values\n+// closed over do not contain managed values, and thus the ~ boxes do\n+// not have headers.\n+\n trait FooTrait {\n     fn foo(&self) -> uint;\n }", "previous_filename": "src/test/run-pass/owned-trait-objects.rs"}, {"sha": "0d675c16d1aad119c6731ee717c338e9e0b610f2", "filename": "src/test/run-pass/objects-owned-object-owned-method.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Fobjects-owned-object-owned-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Fobjects-owned-object-owned-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-owned-object-owned-method.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test invoked `&self` methods on owned objects where the values\n+// closed over contain managed values. This implies that the ~ boxes\n+// will have headers that must be skipped over.\n+\n+trait FooTrait {\n+    fn foo(~self) -> uint;\n+}\n+\n+struct BarStruct {\n+    x: uint\n+}\n+\n+impl FooTrait for BarStruct {\n+    fn foo(~self) -> uint {\n+        self.x\n+    }\n+}\n+\n+pub fn main() {\n+    let foo = ~BarStruct{ x: 22 } as ~FooTrait;\n+    assert_eq!(22, foo.foo());\n+}"}, {"sha": "8ab1bef286c0ca10dc8f0fcf29ec05af34d656ef", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -502,7 +502,7 @@ impl my_visitor {\n         unsafe {\n             let u = my_visitor(**self);\n             let v = ptr_visit_adaptor::<my_visitor>(Inner {inner: u});\n-            visit_tydesc(inner, @v as @TyVisitor);\n+            visit_tydesc(inner, &v as &TyVisitor);\n             true\n         }\n     }\n@@ -662,7 +662,7 @@ pub fn main() {\n         let td = get_tydesc_for(r);\n         error!(\"tydesc sz: %u, align: %u\",\n                (*td).size, (*td).align);\n-        let v = @v as @TyVisitor;\n+        let v = &v as &TyVisitor;\n         visit_tydesc(td, v);\n \n         let r = u.vals.clone();"}, {"sha": "544f42eb69f5eeffe5d0ba83add01ed21b7ae0dd", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b285f1e6c90332188bb720bf320c507fc4156fdc/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=b285f1e6c90332188bb720bf320c507fc4156fdc", "patch": "@@ -79,15 +79,15 @@ impl TyVisitor for MyVisitor {\n     fn visit_evec_uniq(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.types.push(~\"[\");\n         unsafe {\n-            visit_tydesc(inner, (@*self) as @TyVisitor);\n+            visit_tydesc(inner, (&*self) as &TyVisitor);\n         }\n         self.types.push(~\"]\");\n         true\n     }\n     fn visit_evec_uniq_managed(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.types.push(~\"[\");\n         unsafe {\n-            visit_tydesc(inner, (@*self) as @TyVisitor);\n+            visit_tydesc(inner, (&*self) as &TyVisitor);\n         }\n         self.types.push(~\"]\");\n         true\n@@ -154,7 +154,7 @@ impl TyVisitor for MyVisitor {\n     fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n }\n \n-fn visit_ty<T>(v: @TyVisitor) {\n+fn visit_ty<T>(v: &TyVisitor) {\n     unsafe {\n         visit_tydesc(get_tydesc::<T>(), v);\n     }"}]}