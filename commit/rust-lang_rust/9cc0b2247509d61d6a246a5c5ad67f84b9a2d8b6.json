{"sha": "9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYzBiMjI0NzUwOWQ2MWQ2YTI0NmE1YzVhZDY3Zjg0YjlhMmQ4YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-18T19:14:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-18T19:14:52Z"}, "message": "Auto merge of #26192 - alexcrichton:features-clean, r=aturon\n\nThis commit shards the all-encompassing `core`, `std_misc`, `collections`, and `alloc` features into finer-grained components that are much more easily opted into and tracked. This reflects the effort to push forward current unstable APIs to either stabilization or removal. Keeping track of unstable features on a much more fine-grained basis will enable the library subteam to quickly analyze a feature and help prioritize internally about what APIs should be stabilized.\r\n\r\nA few assorted APIs were deprecated along the way, but otherwise this change is just changing the feature name associated with each API. Soon we will have a dashboard for keeping track of all the unstable APIs in the standard library, and I'll also start making issues for each unstable API after performing a first-pass for stabilization.", "tree": {"sha": "c9c5e9d32ccf0c44d331dc9fe139b8d82d912b15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9c5e9d32ccf0c44d331dc9fe139b8d82d912b15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "html_url": "https://github.com/rust-lang/rust/commit/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4518127636e6bffab0599ab4dad785a873c5bd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4518127636e6bffab0599ab4dad785a873c5bd8", "html_url": "https://github.com/rust-lang/rust/commit/f4518127636e6bffab0599ab4dad785a873c5bd8"}, {"sha": "ec333380e03eb1fb94c4938db888d5bed40b8fd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec333380e03eb1fb94c4938db888d5bed40b8fd6", "html_url": "https://github.com/rust-lang/rust/commit/ec333380e03eb1fb94c4938db888d5bed40b8fd6"}], "stats": {"total": 2478, "additions": 1386, "deletions": 1092}, "files": [{"sha": "92a94d23f0842afe1412f48626b7f3f4da18e642", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -11,13 +11,14 @@\n #![crate_type = \"bin\"]\n \n #![feature(box_syntax)]\n-#![feature(collections)]\n-#![feature(rustc_private)]\n-#![feature(std_misc)]\n-#![feature(test)]\n+#![feature(dynamic_lib)]\n+#![feature(libc)]\n #![feature(path_ext)]\n+#![feature(rustc_private)]\n+#![feature(slice_extras)]\n #![feature(str_char)]\n-#![feature(libc)]\n+#![feature(test)]\n+#![feature(vec_push_all)]\n \n #![deny(warnings)]\n "}, {"sha": "7bfeaec36d7295298299cb886740ee0251a0ad1e", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -134,7 +134,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n /// used to break cycles between `Arc` pointers.\n #[unsafe_no_drop_flag]\n-#[unstable(feature = \"alloc\",\n+#[unstable(feature = \"arc_weak\",\n            reason = \"Weak pointers may not belong in this module.\")]\n pub struct Weak<T: ?Sized> {\n     // FIXME #12808: strange name to try to avoid interfering with\n@@ -191,23 +191,35 @@ impl<T: ?Sized> Arc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(arc_weak)]\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[unstable(feature = \"alloc\",\n+    #[unstable(feature = \"arc_weak\",\n                reason = \"Weak pointers may not belong in this module.\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n         self.inner().weak.fetch_add(1, Relaxed);\n         Weak { _ptr: self._ptr }\n     }\n-}\n \n-impl<T: ?Sized> Arc<T> {\n+    /// Get the number of weak references to this value.\n+    #[inline]\n+    #[unstable(feature = \"arc_counts\")]\n+    pub fn weak_count(this: &Arc<T>) -> usize {\n+        this.inner().weak.load(SeqCst) - 1\n+    }\n+\n+    /// Get the number of strong references to this value.\n+    #[inline]\n+    #[unstable(feature = \"arc_counts\")]\n+    pub fn strong_count(this: &Arc<T>) -> usize {\n+        this.inner().strong.load(SeqCst)\n+    }\n+\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // This unsafety is ok because while this arc is alive we're guaranteed\n@@ -236,13 +248,15 @@ impl<T: ?Sized> Arc<T> {\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn weak_count<T: ?Sized>(this: &Arc<T>) -> usize { this.inner().weak.load(SeqCst) - 1 }\n+#[unstable(feature = \"arc_counts\")]\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Arc::weak_count\")]\n+pub fn weak_count<T: ?Sized>(this: &Arc<T>) -> usize { Arc::weak_count(this) }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst) }\n+#[unstable(feature = \"arc_counts\")]\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Arc::strong_count\")]\n+pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { Arc::strong_count(this) }\n \n \n /// Returns a mutable reference to the contained value if the `Arc<T>` is unique.\n@@ -255,7 +269,7 @@ pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { this.inner().strong.loa\n /// # Examples\n ///\n /// ```\n-/// # #![feature(alloc)]\n+/// # #![feature(arc_unique, alloc)]\n /// extern crate alloc;\n /// # fn main() {\n /// use alloc::arc::{Arc, get_mut};\n@@ -271,10 +285,12 @@ pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { this.inner().strong.loa\n /// # }\n /// ```\n #[inline]\n-#[unstable(feature = \"alloc\")]\n+#[unstable(feature = \"arc_unique\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"this function is unsafe with weak pointers\")]\n pub unsafe fn get_mut<T: ?Sized>(this: &mut Arc<T>) -> Option<&mut T> {\n     // FIXME(#24880) potential race with upgraded weak pointers here\n-    if strong_count(this) == 1 && weak_count(this) == 0 {\n+    if Arc::strong_count(this) == 1 && Arc::weak_count(this) == 0 {\n         // This unsafety is ok because we're guaranteed that the pointer\n         // returned is the *only* pointer that will ever be returned to T. Our\n         // reference count is guaranteed to be 1 at this point, and we required\n@@ -342,7 +358,7 @@ impl<T: Clone> Arc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(arc_unique)]\n     /// use std::sync::Arc;\n     ///\n     /// # unsafe {\n@@ -352,7 +368,9 @@ impl<T: Clone> Arc<T> {\n     /// # }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"alloc\")]\n+    #[unstable(feature = \"arc_unique\")]\n+    #[deprecated(since = \"1.2.0\",\n+                 reason = \"this function is unsafe with weak pointers\")]\n     pub unsafe fn make_unique(&mut self) -> &mut T {\n         // FIXME(#24880) potential race with upgraded weak pointers here\n         //\n@@ -438,7 +456,7 @@ impl<T: ?Sized> Drop for Arc<T> {\n     }\n }\n \n-#[unstable(feature = \"alloc\",\n+#[unstable(feature = \"arc_weak\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T: ?Sized> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n@@ -451,7 +469,7 @@ impl<T: ?Sized> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(arc_weak)]\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n@@ -479,7 +497,7 @@ impl<T: ?Sized> Weak<T> {\n     }\n }\n \n-#[unstable(feature = \"alloc\",\n+#[unstable(feature = \"arc_weak\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T: ?Sized> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`.\n@@ -489,7 +507,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(arc_weak)]\n     /// use std::sync::Arc;\n     ///\n     /// let weak_five = Arc::new(5).downgrade();\n@@ -513,7 +531,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(arc_weak)]\n     /// use std::sync::Arc;\n     ///\n     /// {"}, {"sha": "1039756363e9fa1aa6a05ed1a9f7f30720a19488", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,9 +10,9 @@\n \n //! A pointer type for heap allocation.\n //!\n-//! `Box<T>`, casually referred to as a 'box', provides the simplest form of heap allocation in\n-//! Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of\n-//! scope.\n+//! `Box<T>`, casually referred to as a 'box', provides the simplest form of\n+//! heap allocation in Rust. Boxes provide ownership for this allocation, and\n+//! drop their contents when they go out of scope.\n //!\n //! # Examples\n //!\n@@ -39,15 +39,17 @@\n //!\n //! This will print `Cons(1, Cons(2, Nil))`.\n //!\n-//! Recursive structures must be boxed, because if the definition of `Cons` looked like this:\n+//! Recursive structures must be boxed, because if the definition of `Cons`\n+//! looked like this:\n //!\n //! ```rust,ignore\n //! Cons(T, List<T>),\n //! ```\n //!\n-//! It wouldn't work. This is because the size of a `List` depends on how many elements are in the\n-//! list, and so we don't know how much memory to allocate for a `Cons`. By introducing a `Box`,\n-//! which has a defined size, we know how big `Cons` needs to be.\n+//! It wouldn't work. This is because the size of a `List` depends on how many\n+//! elements are in the list, and so we don't know how much memory to allocate\n+//! for a `Cons`. By introducing a `Box`, which has a defined size, we know how\n+//! big `Cons` needs to be.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -69,7 +71,7 @@ use core::raw::{TraitObject};\n /// The following two examples are equivalent:\n ///\n /// ```\n-/// # #![feature(alloc)]\n+/// # #![feature(box_heap)]\n /// #![feature(box_syntax)]\n /// use std::boxed::HEAP;\n ///\n@@ -79,7 +81,7 @@ use core::raw::{TraitObject};\n /// }\n /// ```\n #[lang = \"exchange_heap\"]\n-#[unstable(feature = \"alloc\",\n+#[unstable(feature = \"box_heap\",\n            reason = \"may be renamed; uncertain about custom allocator design\")]\n pub const HEAP: () = ();\n \n@@ -119,12 +121,37 @@ impl<T : ?Sized> Box<T> {\n     /// Function is unsafe, because improper use of this function may\n     /// lead to memory problems like double-free, for example if the\n     /// function is called twice on the same raw pointer.\n-    #[unstable(feature = \"alloc\",\n+    #[unstable(feature = \"box_raw\",\n                reason = \"may be renamed or moved out of Box scope\")]\n     #[inline]\n+    // NB: may want to be called from_ptr, see comments on CStr::from_ptr\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n         mem::transmute(raw)\n     }\n+\n+    /// Consumes the `Box`, returning the wrapped raw pointer.\n+    ///\n+    /// After call to this function, caller is responsible for the memory\n+    /// previously managed by `Box`, in particular caller should properly\n+    /// destroy `T` and release memory. The proper way to do it is to\n+    /// convert pointer back to `Box` with `Box::from_raw` function, because\n+    /// `Box` does not specify, how memory is allocated.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(box_raw)]\n+    /// use std::boxed;\n+    ///\n+    /// let seventeen = Box::new(17u32);\n+    /// let raw = boxed::into_raw(seventeen);\n+    /// let boxed_again = unsafe { Box::from_raw(raw) };\n+    /// ```\n+    #[unstable(feature = \"box_raw\", reason = \"may be renamed\")]\n+    #[inline]\n+    // NB: may want to be called into_ptr, see comments on CStr::from_ptr\n+    pub fn into_raw(b: Box<T>) -> *mut T {\n+        unsafe { mem::transmute(b) }\n+    }\n }\n \n /// Consumes the `Box`, returning the wrapped raw pointer.\n@@ -137,18 +164,18 @@ impl<T : ?Sized> Box<T> {\n ///\n /// # Examples\n /// ```\n-/// # #![feature(alloc)]\n+/// # #![feature(box_raw)]\n /// use std::boxed;\n ///\n /// let seventeen = Box::new(17u32);\n /// let raw = boxed::into_raw(seventeen);\n /// let boxed_again = unsafe { Box::from_raw(raw) };\n /// ```\n-#[unstable(feature = \"alloc\",\n-           reason = \"may be renamed\")]\n+#[unstable(feature = \"box_raw\", reason = \"may be renamed\")]\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Box::into_raw\")]\n #[inline]\n pub fn into_raw<T : ?Sized>(b: Box<T>) -> *mut T {\n-    unsafe { mem::transmute(b) }\n+    Box::into_raw(b)\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -181,7 +208,7 @@ impl<T: Clone> Clone for Box<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc, core)]\n+    /// # #![feature(box_raw)]\n     /// let x = Box::new(5);\n     /// let mut y = Box::new(10);\n     ///\n@@ -242,7 +269,7 @@ impl Box<Any> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n-                let raw = into_raw(self);\n+                let raw = Box::into_raw(self);\n                 let to: TraitObject =\n                     mem::transmute::<*mut Any, TraitObject>(raw);\n \n@@ -334,7 +361,7 @@ impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {}\n /// -> i32>`.\n ///\n /// ```\n-/// #![feature(core)]\n+/// #![feature(fnbox)]\n ///\n /// use std::boxed::FnBox;\n /// use std::collections::HashMap;\n@@ -355,7 +382,7 @@ impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {}\n /// }\n /// ```\n #[rustc_paren_sugar]\n-#[unstable(feature = \"core\", reason = \"Newly introduced\")]\n+#[unstable(feature = \"fnbox\", reason = \"Newly introduced\")]\n pub trait FnBox<A> {\n     type Output;\n "}, {"sha": "14797d7f4b54d20cee3bd5a164162dae18806513", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,6 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(feature = \"heap_api\",\n+            reason = \"the precise API and guarantees it provides may be tweaked \\\n+                      slightly, especially to possibly take into account the \\\n+                      types being stored to make room for a future \\\n+                      tracing garbage collector\")]\n+\n use core::{isize, usize};\n \n #[inline(always)]\n@@ -94,7 +100,6 @@ pub fn usable_size(size: usize, align: usize) -> usize {\n ///\n /// These statistics may be inconsistent if other threads use the allocator\n /// during the call.\n-#[unstable(feature = \"alloc\")]\n pub fn stats_print() {\n     imp::stats_print();\n }"}, {"sha": "7dcf7a76da083ba3dc5143a78200add26ebaae10", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -59,32 +59,40 @@\n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"alloc\"]\n-#![unstable(feature = \"alloc\")]\n-#![feature(staged_api)]\n-#![staged_api]\n #![crate_type = \"rlib\"]\n+#![staged_api]\n+#![unstable(feature = \"alloc\",\n+            reason = \"this library is unlikely to be stabilized in its current \\\n+                      form or name\")]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![doc(test(no_crate_inject))]\n-\n-#![feature(no_std)]\n+       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n+       test(no_crate_inject))]\n #![no_std]\n+\n #![feature(allocator)]\n+#![feature(box_syntax)]\n+#![feature(coerce_unsized)]\n+#![feature(core)]\n+#![feature(core_intrinsics)]\n+#![feature(core_prelude)]\n #![feature(custom_attribute)]\n #![feature(fundamental)]\n #![feature(lang_items)]\n-#![feature(box_syntax)]\n+#![feature(no_std)]\n+#![feature(nonzero)]\n #![feature(optin_builtin_traits)]\n+#![feature(raw)]\n+#![feature(staged_api)]\n #![feature(unboxed_closures)]\n-#![feature(unsafe_no_drop_flag, filling_drop)]\n-#![feature(core)]\n #![feature(unique)]\n-#![cfg_attr(test, feature(test, alloc, rustc_private))]\n+#![feature(unsafe_no_drop_flag, filling_drop)]\n+#![feature(unsize)]\n+\n+#![cfg_attr(test, feature(test, alloc, rustc_private, box_raw))]\n #![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n             feature(libc))]\n \n-\n #[macro_use]\n extern crate core;\n \n@@ -118,6 +126,7 @@ pub mod rc;\n /// Common out-of-memory routine\n #[cold]\n #[inline(never)]\n+#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\")]\n pub fn oom() -> ! {\n     // FIXME(#14674): This really needs to do something other than just abort\n     //                here, but any printing done must be *guaranteed* to not\n@@ -138,4 +147,5 @@ pub fn oom() -> ! {\n //                to get linked in to libstd successfully (the linker won't\n //                optimize it out).\n #[doc(hidden)]\n+#[unstable(feature = \"issue_14344_fixme\")]\n pub fn fixme_14344_be_sure_to_link_to_collections() {}"}, {"sha": "d5b6c86ef359a2f4fb7605350ddbbd544f96f9ea", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 134, "deletions": 63, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -32,7 +32,6 @@\n //! and have the `Owner` remain allocated as long as any `Gadget` points at it.\n //!\n //! ```rust\n-//! # #![feature(alloc)]\n //! use std::rc::Rc;\n //!\n //! struct Owner {\n@@ -92,7 +91,7 @@\n //! documentation for more details on interior mutability.\n //!\n //! ```rust\n-//! # #![feature(alloc)]\n+//! # #![feature(rc_weak)]\n //! use std::rc::Rc;\n //! use std::rc::Weak;\n //! use std::cell::RefCell;\n@@ -149,26 +148,24 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use core::prelude::*;\n+\n #[cfg(not(test))]\n-use boxed;\n+use boxed::Box;\n #[cfg(test)]\n-use std::boxed;\n+use std::boxed::Box;\n+\n use core::cell::Cell;\n-use core::clone::Clone;\n-use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n-use core::default::Default;\n+use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::intrinsics::{assume, drop_in_place};\n-use core::marker::{self, Sized, Unsize};\n+use core::marker::{self, Unsize};\n use core::mem::{self, min_align_of, size_of, min_align_of_val, size_of_val, forget};\n use core::nonzero::NonZero;\n-use core::ops::{CoerceUnsized, Deref, Drop};\n-use core::option::Option;\n-use core::option::Option::{Some, None};\n+use core::ops::{CoerceUnsized, Deref};\n use core::ptr;\n-use core::result::Result;\n-use core::result::Result::{Ok, Err};\n \n use heap::deallocate;\n \n@@ -213,14 +210,50 @@ impl<T> Rc<T> {\n                 // pointers, which ensures that the weak destructor never frees\n                 // the allocation while the strong destructor is running, even\n                 // if the weak pointer is stored inside the strong one.\n-                _ptr: NonZero::new(boxed::into_raw(box RcBox {\n+                _ptr: NonZero::new(Box::into_raw(box RcBox {\n                     strong: Cell::new(1),\n                     weak: Cell::new(1),\n                     value: value\n                 })),\n             }\n         }\n     }\n+\n+    /// Unwraps the contained value if the `Rc<T>` is unique.\n+    ///\n+    /// If the `Rc<T>` is not unique, an `Err` is returned with the same\n+    /// `Rc<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(rc_unique)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x = Rc::new(3);\n+    /// assert_eq!(Rc::try_unwrap(x), Ok(3));\n+    ///\n+    /// let x = Rc::new(4);\n+    /// let _y = x.clone();\n+    /// assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"rc_unique\")]\n+    pub fn try_unwrap(rc: Rc<T>) -> Result<T, Rc<T>> {\n+        if Rc::is_unique(&rc) {\n+            unsafe {\n+                let val = ptr::read(&*rc); // copy the contained object\n+                // destruct the box and skip our Drop\n+                // we can ignore the refcounts because we know we're unique\n+                deallocate(*rc._ptr as *mut u8, size_of::<RcBox<T>>(),\n+                            min_align_of::<RcBox<T>>());\n+                forget(rc);\n+                Ok(val)\n+            }\n+        } else {\n+            Err(rc)\n+        }\n+    }\n }\n \n impl<T: ?Sized> Rc<T> {\n@@ -229,38 +262,98 @@ impl<T: ?Sized> Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(rc_weak)]\n     /// use std::rc::Rc;\n     ///\n     /// let five = Rc::new(5);\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[unstable(feature = \"alloc\",\n+    #[unstable(feature = \"rc_weak\",\n                reason = \"Weak pointers may not belong in this module\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak { _ptr: self._ptr }\n     }\n+\n+    /// Get the number of weak references to this value.\n+    #[inline]\n+    #[unstable(feature = \"rc_counts\")]\n+    pub fn weak_count(this: &Rc<T>) -> usize { this.weak() - 1 }\n+\n+    /// Get the number of strong references to this value.\n+    #[inline]\n+    #[unstable(feature = \"rc_counts\")]\n+    pub fn strong_count(this: &Rc<T>) -> usize { this.strong() }\n+\n+    /// Returns true if there are no other `Rc` or `Weak<T>` values that share\n+    /// the same inner value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(rc_unique)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    ///\n+    /// assert!(Rc::is_unique(&five));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"rc_unique\")]\n+    pub fn is_unique(rc: &Rc<T>) -> bool {\n+        Rc::weak_count(rc) == 0 && Rc::strong_count(rc) == 1\n+    }\n+\n+    /// Returns a mutable reference to the contained value if the `Rc<T>` is\n+    /// unique.\n+    ///\n+    /// Returns `None` if the `Rc<T>` is not unique.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(rc_unique)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut x = Rc::new(3);\n+    /// *Rc::get_mut(&mut x).unwrap() = 4;\n+    /// assert_eq!(*x, 4);\n+    ///\n+    /// let _y = x.clone();\n+    /// assert!(Rc::get_mut(&mut x).is_none());\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"rc_unique\")]\n+    pub fn get_mut(rc: &mut Rc<T>) -> Option<&mut T> {\n+        if Rc::is_unique(rc) {\n+            let inner = unsafe { &mut **rc._ptr };\n+            Some(&mut inner.value)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn weak_count<T: ?Sized>(this: &Rc<T>) -> usize { this.weak() - 1 }\n+#[unstable(feature = \"rc_counts\")]\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::weak_count\")]\n+pub fn weak_count<T: ?Sized>(this: &Rc<T>) -> usize { Rc::weak_count(this) }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { this.strong() }\n+#[unstable(feature = \"rc_counts\")]\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::strong_count\")]\n+pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { Rc::strong_count(this) }\n \n /// Returns true if there are no other `Rc` or `Weak<T>` values that share the\n /// same inner value.\n ///\n /// # Examples\n ///\n /// ```\n-/// # #![feature(alloc)]\n+/// # #![feature(rc_unique)]\n /// use std::rc;\n /// use std::rc::Rc;\n ///\n@@ -269,10 +362,9 @@ pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { this.strong() }\n /// rc::is_unique(&five);\n /// ```\n #[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n-    weak_count(rc) == 0 && strong_count(rc) == 1\n-}\n+#[unstable(feature = \"rc_unique\")]\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::is_unique\")]\n+pub fn is_unique<T>(rc: &Rc<T>) -> bool { Rc::is_unique(rc) }\n \n /// Unwraps the contained value if the `Rc<T>` is unique.\n ///\n@@ -281,7 +373,7 @@ pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n /// # Examples\n ///\n /// ```\n-/// # #![feature(alloc)]\n+/// # #![feature(rc_unique)]\n /// use std::rc::{self, Rc};\n ///\n /// let x = Rc::new(3);\n@@ -292,22 +384,9 @@ pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n /// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4)));\n /// ```\n #[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n-    if is_unique(&rc) {\n-        unsafe {\n-            let val = ptr::read(&*rc); // copy the contained object\n-            // destruct the box and skip our Drop\n-            // we can ignore the refcounts because we know we're unique\n-            deallocate(*rc._ptr as *mut u8, size_of::<RcBox<T>>(),\n-                        min_align_of::<RcBox<T>>());\n-            forget(rc);\n-            Ok(val)\n-        }\n-    } else {\n-        Err(rc)\n-    }\n-}\n+#[unstable(feature = \"rc_unique\")]\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::try_unwrap\")]\n+pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> { Rc::try_unwrap(rc) }\n \n /// Returns a mutable reference to the contained value if the `Rc<T>` is unique.\n ///\n@@ -316,7 +395,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n /// # Examples\n ///\n /// ```\n-/// # #![feature(alloc)]\n+/// # #![feature(rc_unique)]\n /// use std::rc::{self, Rc};\n ///\n /// let mut x = Rc::new(3);\n@@ -327,15 +406,9 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n /// assert!(rc::get_mut(&mut x).is_none());\n /// ```\n #[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn get_mut<T>(rc: &mut Rc<T>) -> Option<&mut T> {\n-    if is_unique(rc) {\n-        let inner = unsafe { &mut **rc._ptr };\n-        Some(&mut inner.value)\n-    } else {\n-        None\n-    }\n-}\n+#[unstable(feature = \"rc_unique\")]\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::get_mut\")]\n+pub fn get_mut<T>(rc: &mut Rc<T>) -> Option<&mut T> { Rc::get_mut(rc) }\n \n impl<T: Clone> Rc<T> {\n     /// Make a mutable reference from the given `Rc<T>`.\n@@ -346,17 +419,17 @@ impl<T: Clone> Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(rc_unique)]\n     /// use std::rc::Rc;\n     ///\n     /// let mut five = Rc::new(5);\n     ///\n     /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"alloc\")]\n+    #[unstable(feature = \"rc_unique\")]\n     pub fn make_unique(&mut self) -> &mut T {\n-        if !is_unique(self) {\n+        if !Rc::is_unique(self) {\n             *self = Rc::new((**self).clone())\n         }\n         // This unsafety is ok because we're guaranteed that the pointer\n@@ -390,7 +463,6 @@ impl<T: ?Sized> Drop for Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n     /// use std::rc::Rc;\n     ///\n     /// {\n@@ -443,7 +515,6 @@ impl<T: ?Sized> Clone for Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n     /// use std::rc::Rc;\n     ///\n     /// let five = Rc::new(5);\n@@ -652,7 +723,7 @@ impl<T> fmt::Pointer for Rc<T> {\n ///\n /// See the [module level documentation](./index.html) for more.\n #[unsafe_no_drop_flag]\n-#[unstable(feature = \"alloc\",\n+#[unstable(feature = \"rc_weak\",\n            reason = \"Weak pointers may not belong in this module.\")]\n pub struct Weak<T: ?Sized> {\n     // FIXME #12808: strange names to try to avoid interfering with\n@@ -663,7 +734,7 @@ pub struct Weak<T: ?Sized> {\n impl<T: ?Sized> !marker::Send for Weak<T> {}\n impl<T: ?Sized> !marker::Sync for Weak<T> {}\n \n-#[unstable(feature = \"alloc\",\n+#[unstable(feature = \"rc_weak\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T: ?Sized> Weak<T> {\n \n@@ -677,7 +748,7 @@ impl<T: ?Sized> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(rc_weak)]\n     /// use std::rc::Rc;\n     ///\n     /// let five = Rc::new(5);\n@@ -705,7 +776,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(rc_weak)]\n     /// use std::rc::Rc;\n     ///\n     /// {\n@@ -741,7 +812,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     }\n }\n \n-#[unstable(feature = \"alloc\",\n+#[unstable(feature = \"rc_weak\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T: ?Sized> Clone for Weak<T> {\n \n@@ -752,7 +823,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(rc_weak)]\n     /// use std::rc::Rc;\n     ///\n     /// let weak_five = Rc::new(5).downgrade();"}, {"sha": "109ad8a942c8467a33fdc24694f2e1abec877eb6", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -32,9 +32,12 @@\n \n #![feature(alloc)]\n #![feature(box_syntax)]\n-#![feature(core)]\n+#![feature(core_intrinsics)]\n+#![feature(heap_api)]\n+#![feature(oom)]\n+#![feature(ptr_as_ref)]\n+#![feature(raw)]\n #![feature(staged_api)]\n-#![feature(unboxed_closures)]\n #![cfg_attr(test, feature(test))]\n \n extern crate alloc;"}, {"sha": "f6204173ed7a57c6ff59f9fdfa3a3d97636b55a8", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,10 +10,11 @@\n \n //! A priority queue implemented with a binary heap.\n //!\n-//! Insertion and popping the largest element have `O(log n)` time complexity. Checking the largest\n-//! element is `O(1)`. Converting a vector to a binary heap can be done in-place, and has `O(n)`\n-//! complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to\n-//! be used for an `O(n log n)` in-place heapsort.\n+//! Insertion and popping the largest element have `O(log n)` time complexity.\n+//! Checking the largest element is `O(1)`. Converting a vector to a binary heap\n+//! can be done in-place, and has `O(n)` complexity. A binary heap can also be\n+//! converted to a sorted vector in-place, allowing it to be used for an `O(n\n+//! log n)` in-place heapsort.\n //!\n //! # Examples\n //!\n@@ -539,8 +540,9 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// The elements are removed in arbitrary order.\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n+    #[unstable(feature = \"drain\",\n+               reason = \"matches collection reform specification, \\\n+                         waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain { iter: self.data.drain(..) }\n     }\n@@ -678,7 +680,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n-#[unstable(feature = \"collections\", reason = \"recent addition\")]\n+#[unstable(feature = \"drain\", reason = \"recent addition\")]\n pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }"}, {"sha": "51914900fdd9978fb1e95555ac6b459d7f5a82b9", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 84, "deletions": 79, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -38,7 +38,7 @@\n //! [sieve]: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n //!\n //! ```\n-//! # #![feature(collections, core, step_by)]\n+//! # #![feature(bitset, bitvec, range_inclusive, step_by)]\n //! use std::collections::{BitSet, BitVec};\n //! use std::iter;\n //!\n@@ -86,6 +86,7 @@ use core::cmp::Ordering;\n use core::cmp;\n use core::fmt;\n use core::hash;\n+#[allow(deprecated)]\n use core::iter::RandomAccessIterator;\n use core::iter::{Chain, Enumerate, Repeat, Skip, Take, repeat, Cloned};\n use core::iter::{self, FromIterator};\n@@ -133,7 +134,7 @@ const FALSE: &'static bool = &false;\n /// # Examples\n ///\n /// ```\n-/// # #![feature(collections)]\n+/// # #![feature(bitvec)]\n /// use std::collections::BitVec;\n ///\n /// let mut bv = BitVec::from_elem(10, false);\n@@ -156,8 +157,7 @@ const FALSE: &'static bool = &false;\n /// println!(\"{:?}\", bv);\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n-#[unstable(feature = \"collections\",\n-           reason = \"RFC 509\")]\n+#[unstable(feature = \"bitvec\", reason = \"RFC 509\")]\n pub struct BitVec {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n@@ -181,14 +181,16 @@ impl Index<usize> for BitVec {\n \n /// Computes how many blocks are needed to store that many bits\n fn blocks_for_bits(bits: usize) -> usize {\n-    // If we want 17 bits, dividing by 32 will produce 0. So we add 1 to make sure we\n-    // reserve enough. But if we want exactly a multiple of 32, this will actually allocate\n-    // one too many. So we need to check if that's the case. We can do that by computing if\n-    // bitwise AND by `32 - 1` is 0. But LLVM should be able to optimize the semantically\n-    // superior modulo operator on a power of two to this.\n+    // If we want 17 bits, dividing by 32 will produce 0. So we add 1 to make\n+    // sure we reserve enough. But if we want exactly a multiple of 32, this\n+    // will actually allocate one too many. So we need to check if that's the\n+    // case. We can do that by computing if bitwise AND by `32 - 1` is 0. But\n+    // LLVM should be able to optimize the semantically superior modulo operator\n+    // on a power of two to this.\n     //\n     // Note that we can technically avoid this branch with the expression\n-    // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost usize::MAX this will overflow.\n+    // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost usize::MAX\n+    // this will overflow.\n     if bits % u32::BITS == 0 {\n         bits / u32::BITS\n     } else {\n@@ -202,6 +204,7 @@ fn mask_for_bits(bits: usize) -> u32 {\n     !0 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n }\n \n+#[unstable(feature = \"bitvec\", reason = \"RFC 509\")]\n impl BitVec {\n     /// Applies the given operation to the blocks of self and other, and sets\n     /// self to be the result. This relies on the caller not to corrupt the\n@@ -248,7 +251,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     /// let mut bv = BitVec::new();\n     /// ```\n@@ -263,7 +266,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let bv = BitVec::from_elem(10, false);\n@@ -304,7 +307,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let bv = BitVec::from_bytes(&[0b10100000, 0b00010010]);\n@@ -347,7 +350,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let bv = BitVec::from_fn(5, |i| { i % 2 == 0 });\n@@ -366,7 +369,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let bv = BitVec::from_bytes(&[0b01100000]);\n@@ -399,16 +402,14 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(5, false);\n     /// bv.set(3, true);\n     /// assert_eq!(bv[3], true);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"panic semantics are likely to change in the future\")]\n     pub fn set(&mut self, i: usize, x: bool) {\n         assert!(i < self.nbits);\n         let w = i / u32::BITS;\n@@ -424,7 +425,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let before = 0b01100000;\n@@ -445,7 +446,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let before = 0b01100000;\n@@ -474,7 +475,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n@@ -505,7 +506,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n@@ -536,7 +537,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n@@ -566,7 +567,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(5, true);\n@@ -591,7 +592,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let bv = BitVec::from_bytes(&[0b01110100, 0b10010010]);\n@@ -608,7 +609,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections, bit_vec_append_split_off)]\n+    /// # #![feature(bitvec, append)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut a = BitVec::from_bytes(&[0b10000000]);\n@@ -621,7 +622,7 @@ impl BitVec {\n     /// assert!(a.eq_vec(&[true, false, false, false, false, false, false, false,\n     ///                    false, true, true, false, false, false, false, true]));\n     /// ```\n-    #[unstable(feature = \"bit_vec_append_split_off\",\n+    #[unstable(feature = \"append\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn append(&mut self, other: &mut Self) {\n         let b = self.len() % u32::BITS;\n@@ -651,7 +652,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections, bit_vec_append_split_off)]\n+    /// # #![feature(bitvec, split_off)]\n     /// use std::collections::BitVec;\n     /// let mut a = BitVec::new();\n     /// a.push(true);\n@@ -666,7 +667,7 @@ impl BitVec {\n     /// assert!(a.eq_vec(&[true, false]));\n     /// assert!(b.eq_vec(&[false, true]));\n     /// ```\n-    #[unstable(feature = \"bit_vec_append_split_off\",\n+    #[unstable(feature = \"split_off\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         assert!(at <= self.len(), \"`at` out of bounds\");\n@@ -712,7 +713,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(10, false);\n@@ -730,7 +731,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(10, false);\n@@ -752,7 +753,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(3, true);\n@@ -800,7 +801,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let bv = BitVec::from_bytes(&[0b10100000]);\n@@ -821,7 +822,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n@@ -848,7 +849,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(3, false);\n@@ -879,7 +880,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(3, false);\n@@ -902,7 +903,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::new();\n@@ -924,7 +925,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n@@ -975,7 +976,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_bytes(&[0b01001001]);\n@@ -1006,7 +1007,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitvec)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::new();\n@@ -1188,6 +1189,7 @@ impl<'a> DoubleEndedIterator for Iter<'a> {\n impl<'a> ExactSizeIterator for Iter<'a> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl<'a> RandomAccessIterator for Iter<'a> {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -1224,7 +1226,7 @@ impl<'a> IntoIterator for &'a BitVec {\n /// # Examples\n ///\n /// ```\n-/// # #![feature(collections)]\n+/// # #![feature(bitvec, bitset)]\n /// use std::collections::{BitSet, BitVec};\n ///\n /// // It's a regular set\n@@ -1254,8 +1256,7 @@ impl<'a> IntoIterator for &'a BitVec {\n /// assert!(bv[3]);\n /// ```\n #[derive(Clone)]\n-#[unstable(feature = \"collections\",\n-           reason = \"RFC 509\")]\n+#[unstable(feature = \"bitset\", reason = \"RFC 509\")]\n pub struct BitSet {\n     bit_vec: BitVec,\n }\n@@ -1322,13 +1323,14 @@ impl cmp::PartialEq for BitSet {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Eq for BitSet {}\n \n+#[unstable(feature = \"bitset\", reason = \"RFC 509\")]\n impl BitSet {\n     /// Creates a new empty `BitSet`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1345,7 +1347,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::with_capacity(100);\n@@ -1363,7 +1365,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset, bitvec)]\n     /// use std::collections::{BitVec, BitSet};\n     ///\n     /// let bv = BitVec::from_bytes(&[0b01100000]);\n@@ -1385,7 +1387,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::with_capacity(100);\n@@ -1397,17 +1399,17 @@ impl BitSet {\n         self.bit_vec.capacity()\n     }\n \n-    /// Reserves capacity for the given `BitSet` to contain `len` distinct elements. In the case\n-    /// of `BitSet` this means reallocations will not occur as long as all inserted elements\n-    /// are less than `len`.\n+    /// Reserves capacity for the given `BitSet` to contain `len` distinct\n+    /// elements. In the case of `BitSet` this means reallocations will not\n+    /// occur as long as all inserted elements are less than `len`.\n     ///\n     /// The collection may reserve more space to avoid frequent reallocations.\n     ///\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1422,19 +1424,19 @@ impl BitSet {\n         }\n     }\n \n-    /// Reserves the minimum capacity for the given `BitSet` to contain `len` distinct elements.\n-    /// In the case of `BitSet` this means reallocations will not occur as long as all inserted\n-    /// elements are less than `len`.\n+    /// Reserves the minimum capacity for the given `BitSet` to contain `len`\n+    /// distinct elements.  In the case of `BitSet` this means reallocations\n+    /// will not occur as long as all inserted elements are less than `len`.\n     ///\n-    /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve_len` if future\n-    /// insertions are expected.\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve_len` if future insertions are expected.\n     ///\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1455,7 +1457,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1476,7 +1478,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1523,7 +1525,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1556,7 +1558,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset, bitvec)]\n     /// use std::collections::{BitVec, BitSet};\n     ///\n     /// let s = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01001010]));\n@@ -1578,7 +1580,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset, bitvec)]\n     /// use std::collections::{BitVec, BitSet};\n     ///\n     /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n@@ -1602,12 +1604,13 @@ impl BitSet {\n     }\n \n     /// Iterator over each usize stored in `self` intersect `other`.\n-    /// See [intersect_with](#method.intersect_with) for an efficient in-place version.\n+    /// See [intersect_with](#method.intersect_with) for an efficient in-place\n+    /// version.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset, bitvec)]\n     /// use std::collections::{BitVec, BitSet};\n     ///\n     /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n@@ -1632,12 +1635,13 @@ impl BitSet {\n     }\n \n     /// Iterator over each usize stored in the `self` setminus `other`.\n-    /// See [difference_with](#method.difference_with) for an efficient in-place version.\n+    /// See [difference_with](#method.difference_with) for an efficient in-place\n+    /// version.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset, bitvec)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n@@ -1667,14 +1671,15 @@ impl BitSet {\n         }))\n     }\n \n-    /// Iterator over each usize stored in the symmetric difference of `self` and `other`.\n-    /// See [symmetric_difference_with](#method.symmetric_difference_with) for\n-    /// an efficient in-place version.\n+    /// Iterator over each usize stored in the symmetric difference of `self`\n+    /// and `other`.  See\n+    /// [symmetric_difference_with](#method.symmetric_difference_with) for an\n+    /// efficient in-place version.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset, bitvec)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n@@ -1702,7 +1707,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset, bitvec)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n@@ -1726,7 +1731,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset, bitvec)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n@@ -1751,7 +1756,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset, bitvec)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n@@ -1784,7 +1789,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(bitset, bitvec)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n@@ -1808,7 +1813,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections, bit_set_append_split_off)]\n+    /// # #![feature(bitset, bitvec, append)]\n     /// use std::collections::{BitVec, BitSet};\n     ///\n     /// let mut a = BitSet::new();\n@@ -1826,7 +1831,7 @@ impl BitSet {\n     /// assert_eq!(b.len(), 0);\n     /// assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b01110010])));\n     /// ```\n-    #[unstable(feature = \"bit_set_append_split_off\",\n+    #[unstable(feature = \"append\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn append(&mut self, other: &mut Self) {\n         self.union_with(other);\n@@ -1839,7 +1844,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections, bit_set_append_split_off)]\n+    /// # #![feature(bitset, bitvec, split_off)]\n     /// use std::collections::{BitSet, BitVec};\n     /// let mut a = BitSet::new();\n     /// a.insert(2);\n@@ -1854,7 +1859,7 @@ impl BitSet {\n     /// assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100000])));\n     /// assert_eq!(b, BitSet::from_bit_vec(BitVec::from_bytes(&[0b00010010])));\n     /// ```\n-    #[unstable(feature = \"bit_set_append_split_off\",\n+    #[unstable(feature = \"split_off\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         let mut other = BitSet::new();"}, {"sha": "27b10213ecd7cacad8c6344072f149f715fd2dc8", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -685,10 +685,7 @@ mod stack {\n         /// tied to the original tree.\n         pub fn into_top(mut self) -> &'a mut V {\n             unsafe {\n-                mem::copy_mut_lifetime(\n-                    self.map,\n-                    self.top.from_raw_mut().val_mut()\n-                )\n+                &mut *(self.top.from_raw_mut().val_mut() as *mut V)\n             }\n         }\n     }\n@@ -1151,7 +1148,7 @@ impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"entry\",\n                reason = \"will soon be replaced by or_insert\")]\n     #[deprecated(since = \"1.0\",\n                 reason = \"replaced with more ergonomic `or_insert` and `or_insert_with`\")]\n@@ -1507,7 +1504,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(btree_range, collections_bound)]\n     /// use std::collections::BTreeMap;\n     /// use std::collections::Bound::{Included, Unbounded};\n     ///\n@@ -1520,7 +1517,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// }\n     /// assert_eq!(Some((&5, &\"b\")), map.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&K>, max: Bound<&K>) -> Range<'a, K, V> {\n         range_impl!(&self.root, min, max, as_slices_internal, iter, Range, edges, [])\n@@ -1534,7 +1531,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(btree_range, collections_bound)]\n     /// use std::collections::BTreeMap;\n     /// use std::collections::Bound::{Included, Excluded};\n     ///\n@@ -1548,7 +1545,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///     println!(\"{} => {}\", name, balance);\n     /// }\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range_mut<'a>(&'a mut self, min: Bound<&K>, max: Bound<&K>) -> RangeMut<'a, K, V> {\n         range_impl!(&mut self.root, min, max, as_slices_internal_mut, iter_mut, RangeMut,"}, {"sha": "7c4cda305adf2f50281c49f71f0a752363eb1116", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -102,7 +102,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// Makes a new BTreeSet with the given B.\n     ///\n     /// B cannot be less than 2.\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"btree_b\",\n                reason = \"probably want this to be on the type, eventually\")]\n     pub fn with_b(b: usize) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n@@ -141,7 +141,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(btree_range, collections_bound)]\n     /// use std::collections::BTreeSet;\n     /// use std::collections::Bound::{Included, Unbounded};\n     ///\n@@ -154,7 +154,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// }\n     /// assert_eq!(Some(&5), set.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&T>, max: Bound<&T>) -> Range<'a, T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }"}, {"sha": "e90e6c065a2c282f19a80b0220a5e0552c4d07fd", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -13,21 +13,26 @@\n //! This module defines a container which uses an efficient bit mask\n //! representation to hold C-like enum variants.\n \n+#![unstable(feature = \"enumset\",\n+            reason = \"matches collection reform specification, \\\n+                      waiting for dust to settle\")]\n+\n use core::prelude::*;\n use core::marker;\n use core::fmt;\n use core::iter::{FromIterator};\n use core::ops::{Sub, BitOr, BitAnd, BitXor};\n \n-// FIXME(contentions): implement union family of methods? (general design may be wrong here)\n+// FIXME(contentions): implement union family of methods? (general design may be\n+// wrong here)\n \n-#[derive(PartialEq, Eq, PartialOrd, Ord, Hash)]\n /// A specialized set implementation to use enum types.\n ///\n-/// It is a logic error for an item to be modified in such a way that the transformation of the\n-/// item to or from a `usize`, as determined by the `CLike` trait, changes while the item is in the\n-/// set. This is normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe\n-/// code.\n+/// It is a logic error for an item to be modified in such a way that the\n+/// transformation of the item to or from a `usize`, as determined by the\n+/// `CLike` trait, changes while the item is in the set. This is normally only\n+/// possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists\n@@ -93,22 +98,16 @@ fn bit<E:CLike>(e: &E) -> usize {\n \n impl<E:CLike> EnumSet<E> {\n     /// Returns an empty `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn new() -> EnumSet<E> {\n         EnumSet {bits: 0, marker: marker::PhantomData}\n     }\n \n     /// Returns the number of elements in the given `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn len(&self) -> usize {\n         self.bits.count_ones() as usize\n     }\n \n     /// Returns true if the `EnumSet` is empty.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }\n@@ -118,22 +117,16 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == 0\n     }\n \n     /// Returns `true` if a given `EnumSet` is included in this `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_superset(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == other.bits\n     }\n \n     /// Returns `true` if this `EnumSet` is included in the given `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_subset(&self, other: &EnumSet<E>) -> bool {\n         other.is_superset(self)\n     }\n@@ -151,33 +144,25 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn insert(&mut self, e: E) -> bool {\n         let result = !self.contains(&e);\n         self.bits |= bit(&e);\n         result\n     }\n \n     /// Removes an enum from the EnumSet\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn remove(&mut self, e: &E) -> bool {\n         let result = self.contains(e);\n         self.bits &= !bit(e);\n         result\n     }\n \n     /// Returns `true` if an `EnumSet` contains a given enum.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn contains(&self, e: &E) -> bool {\n         (self.bits & bit(e)) != 0\n     }\n \n     /// Returns an iterator over an `EnumSet`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn iter(&self) -> Iter<E> {\n         Iter::new(self.bits)\n     }"}, {"sha": "72d0ca85357a4274ab9bda81b8823ae41fcae20f", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -172,9 +172,8 @@\n //! like:\n //!\n //! ```\n-//! # #![feature(core, std_misc)]\n+//! # #![feature(fmt_flags)]\n //! use std::fmt;\n-//! use std::f64;\n //!\n //! #[derive(Debug)]\n //! struct Vector2D {"}, {"sha": "8d0f57de4c59585b70c79697c84c4fa4f661e692", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,37 +10,58 @@\n \n //! Collection types.\n //!\n-//! See [std::collections](../std/collections) for a detailed discussion of collections in Rust.\n+//! See [std::collections](../std/collections) for a detailed discussion of\n+//! collections in Rust.\n \n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"collections\"]\n-#![unstable(feature = \"collections\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n+#![unstable(feature = \"collections\",\n+            reason = \"library is unlikely to be stabilized with the current \\\n+                      layout and name, use std::collections instead\")]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![doc(test(no_crate_inject))]\n+       html_playground_url = \"http://play.rust-lang.org/\",\n+       test(no_crate_inject))]\n \n #![allow(trivial_casts)]\n+#![cfg_attr(test, allow(deprecated))] // rand\n+\n #![feature(alloc)]\n-#![feature(box_syntax)]\n #![feature(box_patterns)]\n+#![feature(box_raw)]\n+#![feature(box_syntax)]\n #![feature(core)]\n+#![feature(core_intrinsics)]\n+#![feature(core_prelude)]\n+#![feature(core_slice_ext)]\n+#![feature(core_str_ext)]\n+#![feature(heap_api)]\n+#![feature(iter_cmp)]\n+#![feature(iter_idx)]\n+#![feature(iter_order)]\n+#![feature(iter_arith)]\n+#![feature(iter_arith)]\n #![feature(lang_items)]\n+#![feature(num_bits_bytes)]\n+#![feature(oom)]\n+#![feature(pattern)]\n+#![feature(ptr_as_ref)]\n+#![feature(raw)]\n+#![feature(slice_patterns)]\n #![feature(staged_api)]\n+#![feature(step_by)]\n+#![feature(str_char)]\n+#![feature(str_match_indices)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n-#![feature(step_by)]\n-#![feature(str_char)]\n-#![feature(slice_patterns)]\n #![feature(utf8_error)]\n #![cfg_attr(test, feature(rand, test))]\n-#![cfg_attr(test, allow(deprecated))] // rand\n #![cfg_attr(not(test), feature(str_words))]\n \n #![feature(no_std)]\n@@ -88,14 +109,12 @@ pub mod vec;\n pub mod vec_deque;\n pub mod vec_map;\n \n-#[unstable(feature = \"collections\",\n-           reason = \"RFC 509\")]\n+#[unstable(feature = \"bitvec\", reason = \"RFC 509\")]\n pub mod bit_vec {\n     pub use bit::{BitVec, Iter};\n }\n \n-#[unstable(feature = \"collections\",\n-           reason = \"RFC 509\")]\n+#[unstable(feature = \"bitset\", reason = \"RFC 509\")]\n pub mod bit_set {\n     pub use bit::{BitSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n@@ -114,6 +133,7 @@ pub mod btree_set {\n \n // FIXME(#14344) this shouldn't be necessary\n #[doc(hidden)]\n+#[unstable(feature = \"issue_14344_fixme\")]\n pub fn fixme_14344_be_sure_to_link_to_collections() {}\n \n #[cfg(not(test))]\n@@ -122,6 +142,7 @@ mod std {\n }\n \n /// An endpoint of a range of keys.\n+#[unstable(feature = \"collections_bound\")]\n #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n pub enum Bound<T> {\n     /// An inclusive bound."}, {"sha": "a02cb44896ad3d6406334b60d2c204d144200960", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -784,7 +784,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(linked_list_extras)]\n     /// use std::collections::LinkedList;\n     ///\n     /// let mut list: LinkedList<_> = vec![1, 3, 4].into_iter().collect();\n@@ -801,7 +801,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"linked_list_extras\",\n                reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n@@ -812,7 +812,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(linked_list_extras)]\n     /// use std::collections::LinkedList;\n     ///\n     /// let mut list: LinkedList<_> = vec![1, 2, 3].into_iter().collect();\n@@ -824,7 +824,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"linked_list_extras\",\n                reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {"}, {"sha": "f37c4aede6a1af8a24252868fa507166f7ef952c", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n #![unstable(feature = \"collections_range\", reason = \"was just added\")]\n \n //! Range syntax."}, {"sha": "d49463911e66e3c057cc9c81921be78d40d9e730", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 47, "deletions": 28, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -11,7 +11,8 @@\n //! Utilities for slice manipulation\n //!\n //! The `slice` module contains useful code to help work with slice values.\n-//! Slices are a view into a block of memory represented as a pointer and a length.\n+//! Slices are a view into a block of memory represented as a pointer and a\n+//! length.\n //!\n //! ```\n //! // slicing a Vec\n@@ -69,8 +70,9 @@\n //! }\n //! ```\n //!\n-//! This iterator yields mutable references to the slice's elements, so while the element\n-//! type of the slice is `i32`, the element type of the iterator is `&mut i32`.\n+//! This iterator yields mutable references to the slice's elements, so while\n+//! the element type of the slice is `i32`, the element type of the iterator is\n+//! `&mut i32`.\n //!\n //! * `.iter()` and `.iter_mut()` are the explicit methods to return the default\n //!   iterators.\n@@ -149,6 +151,7 @@ mod hack {\n         }\n     }\n \n+    #[allow(deprecated)]\n     pub fn permutations<T>(s: &[T]) -> Permutations<T> where T: Clone {\n         Permutations{\n             swaps: ElementSwaps::new(s.len()),\n@@ -278,29 +281,29 @@ impl<T> [T] {\n     }\n \n     /// Returns all but the first element of a slice.\n-    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n+    #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed\")]\n     #[inline]\n     pub fn tail(&self) -> &[T] {\n         core_slice::SliceExt::tail(self)\n     }\n \n     /// Returns all but the first element of a mutable slice\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"slice_extras\",\n                reason = \"likely to be renamed or removed\")]\n     #[inline]\n     pub fn tail_mut(&mut self) -> &mut [T] {\n         core_slice::SliceExt::tail_mut(self)\n     }\n \n     /// Returns all but the last element of a slice.\n-    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n+    #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed\")]\n     #[inline]\n     pub fn init(&self) -> &[T] {\n         core_slice::SliceExt::init(self)\n     }\n \n     /// Returns all but the last element of a mutable slice\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"slice_extras\",\n                reason = \"likely to be renamed or removed\")]\n     #[inline]\n     pub fn init_mut(&mut self) -> &mut [T] {\n@@ -727,13 +730,13 @@ impl<T> [T] {\n     }\n \n     /// Find the first index containing a matching value.\n-    #[unstable(feature = \"collections\")]\n+    #[unstable(feature = \"slice_position_elem\")]\n     pub fn position_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n         core_slice::SliceExt::position_elem(self, t)\n     }\n \n     /// Find the last index containing a matching value.\n-    #[unstable(feature = \"collections\")]\n+    #[unstable(feature = \"slice_position_elem\")]\n     pub fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n         core_slice::SliceExt::rposition_elem(self, t)\n     }\n@@ -849,7 +852,7 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// # #![feature(collections)]\n+    /// # #![feature(permutations)]\n     /// let v = [1, 2, 3];\n     /// let mut perms = v.permutations();\n     ///\n@@ -861,15 +864,17 @@ impl<T> [T] {\n     /// Iterating through permutations one by one.\n     ///\n     /// ```rust\n-    /// # #![feature(collections)]\n+    /// # #![feature(permutations)]\n     /// let v = [1, 2, 3];\n     /// let mut perms = v.permutations();\n     ///\n     /// assert_eq!(Some(vec![1, 2, 3]), perms.next());\n     /// assert_eq!(Some(vec![1, 3, 2]), perms.next());\n     /// assert_eq!(Some(vec![3, 1, 2]), perms.next());\n     /// ```\n-    #[unstable(feature = \"collections\")]\n+    #[allow(deprecated)]\n+    #[unstable(feature = \"permutations\")]\n+    #[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n     #[inline]\n     pub fn permutations(&self) -> Permutations<T> where T: Clone {\n         // NB see hack module in this file\n@@ -884,7 +889,7 @@ impl<T> [T] {\n     /// # Example\n     ///\n     /// ```rust\n-    /// # #![feature(collections)]\n+    /// # #![feature(permutations)]\n     /// let v: &mut [_] = &mut [0, 1, 2];\n     /// v.next_permutation();\n     /// let b: &mut [_] = &mut [0, 2, 1];\n@@ -893,8 +898,10 @@ impl<T> [T] {\n     /// let b: &mut [_] = &mut [1, 0, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[allow(deprecated)]\n+    #[unstable(feature = \"permutations\",\n                reason = \"uncertain if this merits inclusion in std\")]\n+    #[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n     pub fn next_permutation(&mut self) -> bool where T: Ord {\n         core_slice::SliceExt::next_permutation(self)\n     }\n@@ -907,7 +914,7 @@ impl<T> [T] {\n     /// # Example\n     ///\n     /// ```rust\n-    /// # #![feature(collections)]\n+    /// # #![feature(permutations)]\n     /// let v: &mut [_] = &mut [1, 0, 2];\n     /// v.prev_permutation();\n     /// let b: &mut [_] = &mut [0, 2, 1];\n@@ -916,8 +923,10 @@ impl<T> [T] {\n     /// let b: &mut [_] = &mut [0, 1, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[allow(deprecated)]\n+    #[unstable(feature = \"permutations\",\n                reason = \"uncertain if this merits inclusion in std\")]\n+    #[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n     pub fn prev_permutation(&mut self) -> bool where T: Ord {\n         core_slice::SliceExt::prev_permutation(self)\n     }\n@@ -929,7 +938,7 @@ impl<T> [T] {\n     /// # Example\n     ///\n     /// ```rust\n-    /// # #![feature(collections)]\n+    /// # #![feature(clone_from_slice)]\n     /// let mut dst = [0, 0, 0];\n     /// let src = [1, 2];\n     ///\n@@ -940,7 +949,7 @@ impl<T> [T] {\n     /// assert!(dst.clone_from_slice(&src2) == 3);\n     /// assert!(dst == [3, 4, 5]);\n     /// ```\n-    #[unstable(feature = \"collections\")]\n+    #[unstable(feature = \"clone_from_slice\")]\n     pub fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n         core_slice::SliceExt::clone_from_slice(self, src)\n     }\n@@ -960,14 +969,14 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// # #![feature(collections)]\n+    /// # #![feature(move_from)]\n     /// let mut a = [1, 2, 3, 4, 5];\n     /// let b = vec![6, 7, 8];\n     /// let num_moved = a.move_from(b, 0, 3);\n     /// assert_eq!(num_moved, 3);\n     /// assert!(a == [6, 7, 8, 4, 5]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"move_from\",\n                reason = \"uncertain about this API approach\")]\n     #[inline]\n     pub fn move_from(&mut self, mut src: Vec<T>, start: usize, end: usize) -> usize {\n@@ -997,10 +1006,12 @@ impl<T> [T] {\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n-#[unstable(feature = \"collections\", reason = \"recently changed\")]\n+#[unstable(feature = \"slice_concat_ext\",\n+           reason = \"trait should not have to exist\")]\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<T: ?Sized> {\n-    #[unstable(feature = \"collections\", reason = \"recently changed\")]\n+    #[unstable(feature = \"slice_concat_ext\",\n+               reason = \"trait should not have to exist\")]\n     /// The resulting type after concatenation\n     type Output;\n \n@@ -1014,8 +1025,8 @@ pub trait SliceConcatExt<T: ?Sized> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn concat(&self) -> Self::Output;\n \n-    /// Flattens a slice of `T` into a single value `Self::Output`, placing a given separator\n-    /// between each.\n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n+    /// given separator between each.\n     ///\n     /// # Examples\n     ///\n@@ -1060,8 +1071,10 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n ///\n /// The last generated swap is always (0, 1), and it returns the\n /// sequence to its initial order.\n-#[unstable(feature = \"collections\")]\n+#[allow(deprecated)]\n+#[unstable(feature = \"permutations\")]\n #[derive(Clone)]\n+#[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n pub struct ElementSwaps {\n     sdir: Vec<SizeDirection>,\n     /// If `true`, emit the last swap that returns the sequence to initial\n@@ -1070,9 +1083,11 @@ pub struct ElementSwaps {\n     swaps_made : usize,\n }\n \n+#[allow(deprecated)]\n impl ElementSwaps {\n     /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n-    #[unstable(feature = \"collections\")]\n+    #[unstable(feature = \"permutations\")]\n+    #[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n     pub fn new(length: usize) -> ElementSwaps {\n         // Initialize `sdir` with a direction that position should move in\n         // (all negative at the beginning) and the `size` of the\n@@ -1128,6 +1143,7 @@ struct SizeDirection {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl Iterator for ElementSwaps {\n     type Item = (usize, usize);\n \n@@ -1194,13 +1210,16 @@ impl Iterator for ElementSwaps {\n /// swap applied.\n ///\n /// Generates even and odd permutations alternately.\n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"permutations\")]\n+#[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n+#[allow(deprecated)]\n pub struct Permutations<T> {\n     swaps: ElementSwaps,\n     v: Vec<T>,\n }\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n+#[unstable(feature = \"permutations\", reason = \"trait is unstable\")]\n+#[allow(deprecated)]\n impl<T: Clone> Iterator for Permutations<T> {\n     type Item = Vec<T>;\n "}, {"sha": "5e8a9bca342b0680c695ac803d84f1c2e007edcb", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -366,7 +366,7 @@ impl<'a> Iterator for Recompositions<'a> {\n ///\n /// For use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"str_utf16\")]\n pub struct Utf16Units<'a> {\n     encoder: Utf16Encoder<Chars<'a>>\n }\n@@ -585,13 +585,13 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(slice_chars)]\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n     /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"slice_chars\",\n                reason = \"may have yet to prove its worth\")]\n     pub fn slice_chars(&self, begin: usize, end: usize) -> &str {\n         core_str::StrExt::slice_chars(self, begin, end)\n@@ -1068,7 +1068,7 @@ impl str {\n     }\n \n     /// Returns an iterator of `u16` over the string encoded as UTF-16.\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_utf16\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     pub fn utf16_units(&self) -> Utf16Units {\n         Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n@@ -1520,15 +1520,13 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n     /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n     /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n     ///\n     /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n     /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"method got recently added\")]\n+    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n     pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n         core_str::StrExt::matches(self, pat)\n     }\n@@ -1553,15 +1551,13 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n     /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n     /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n     ///\n     /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n     /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"method got recently added\")]\n+    #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n     pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n@@ -1595,7 +1591,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(str_match_indices)]\n     /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n     /// assert_eq!(v, [(0, 3), (6, 9), (12, 15)]);\n     ///\n@@ -1605,7 +1601,7 @@ impl str {\n     /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, [(0, 3)]); // only the first `aba`\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_match_indices\",\n                reason = \"might have its iterator type changed\")]\n     // NB: Right now MatchIndices yields `(usize, usize)`, but it would\n     // be more consistent with `matches` and `char_indices` to return `(usize, &str)`\n@@ -1639,7 +1635,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(str_match_indices)]\n     /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n     /// assert_eq!(v, [(12, 15), (6, 9), (0, 3)]);\n     ///\n@@ -1649,7 +1645,7 @@ impl str {\n     /// let v: Vec<(usize, usize)> = \"ababa\".rmatch_indices(\"aba\").collect();\n     /// assert_eq!(v, [(2, 5)]); // only the last `aba`\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_match_indices\",\n                reason = \"might have its iterator type changed\")]\n     // NB: Right now RMatchIndices yields `(usize, usize)`, but it would\n     // be more consistent with `rmatches` and `char_indices` to return `(usize, &str)`\n@@ -1669,15 +1665,15 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(subslice_offset)]\n     /// let string = \"a\\nb\\nc\";\n     /// let lines: Vec<&str> = string.lines().collect();\n     ///\n     /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n     /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"subslice_offset\",\n                reason = \"awaiting convention about comparability of arbitrary slices\")]\n     pub fn subslice_offset(&self, inner: &str) -> usize {\n         core_str::StrExt::subslice_offset(self, inner)\n@@ -1863,7 +1859,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(collections)]\n+    /// #![feature(str_casing)]\n     ///\n     /// let s = \"HELLO\";\n     /// assert_eq!(s.to_lowercase(), \"hello\");\n@@ -1909,7 +1905,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(collections)]\n+    /// #![feature(str_casing)]\n     ///\n     /// let s = \"hello\";\n     /// assert_eq!(s.to_uppercase(), \"HELLO\");\n@@ -1922,14 +1918,14 @@ impl str {\n     }\n \n     /// Escapes each char in `s` with `char::escape_default`.\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_escape\",\n                reason = \"return type may change to be an iterator\")]\n     pub fn escape_default(&self) -> String {\n         self.chars().flat_map(|c| c.escape_default()).collect()\n     }\n \n     /// Escapes each char in `s` with `char::escape_unicode`.\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"str_escape\",\n                reason = \"return type may change to be an iterator\")]\n     pub fn escape_unicode(&self) -> String {\n         self.chars().flat_map(|c| c.escape_unicode()).collect()"}, {"sha": "6e37a5731b384b82a60c78d4d1a8ce294cc37ca1", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -696,7 +696,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections_drain)]\n+    /// # #![feature(drain)]\n     ///\n     /// let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n     /// let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n@@ -710,7 +710,7 @@ impl String {\n     /// s.drain(..);\n     /// assert_eq!(s, \"\");\n     /// ```\n-    #[unstable(feature = \"collections_drain\",\n+    #[unstable(feature = \"drain\",\n                reason = \"recently added, matches RFC\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain where R: RangeArgument<usize> {\n         // Memory safety\n@@ -975,10 +975,14 @@ impl ops::Deref for String {\n \n /// Wrapper type providing a `&String` reference via `Deref`.\n #[unstable(feature = \"collections\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n+#[allow(deprecated)]\n pub struct DerefString<'a> {\n     x: DerefVec<'a, u8>\n }\n \n+#[allow(deprecated)]\n impl<'a> Deref for DerefString<'a> {\n     type Target = String;\n \n@@ -1005,6 +1009,9 @@ impl<'a> Deref for DerefString<'a> {\n /// string_consumer(&as_string(\"foo\"));\n /// ```\n #[unstable(feature = \"collections\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n+#[allow(deprecated)]\n pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }\n@@ -1134,7 +1141,7 @@ impl fmt::Write for String {\n }\n \n /// A draining iterator for `String`.\n-#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\")]\n pub struct Drain<'a> {\n     /// Will be used as &'a mut String in the destructor\n     string: *mut String,\n@@ -1149,7 +1156,7 @@ pub struct Drain<'a> {\n unsafe impl<'a> Sync for Drain<'a> {}\n unsafe impl<'a> Send for Drain<'a> {}\n \n-#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\")]\n impl<'a> Drop for Drain<'a> {\n     fn drop(&mut self) {\n         unsafe {\n@@ -1163,7 +1170,7 @@ impl<'a> Drop for Drain<'a> {\n     }\n }\n \n-#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\")]\n impl<'a> Iterator for Drain<'a> {\n     type Item = char;\n \n@@ -1177,7 +1184,7 @@ impl<'a> Iterator for Drain<'a> {\n     }\n }\n \n-#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\")]\n impl<'a> DoubleEndedIterator for Drain<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {"}, {"sha": "54528c50f1d1e007419d8b206a685ef501744258", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -276,8 +276,10 @@ impl<T> Vec<T> {\n     /// the buffer are copied into the vector without cloning, as if\n     /// `ptr::read()` were called on them.\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"vec_from_raw_buf\",\n                reason = \"may be better expressed via composition\")]\n+    #[deprecated(since = \"1.2.0\",\n+                 reason = \"use slice::from_raw_parts + .to_vec() instead\")]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: usize) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n@@ -696,15 +698,15 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(append)]\n     /// let mut vec = vec![1, 2, 3];\n     /// let mut vec2 = vec![4, 5, 6];\n     /// vec.append(&mut vec2);\n     /// assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n     /// assert_eq!(vec2, []);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"append\",\n                reason = \"new API, waiting for dust to settle\")]\n     pub fn append(&mut self, other: &mut Self) {\n         if mem::size_of::<T>() == 0 {\n@@ -742,15 +744,15 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections_drain)]\n+    /// # #![feature(drain)]\n     ///\n     /// // Draining using `..` clears the whole vector.\n     /// let mut v = vec![1, 2, 3];\n     /// let u: Vec<_> = v.drain(..).collect();\n     /// assert_eq!(v, &[]);\n     /// assert_eq!(u, &[1, 2, 3]);\n     /// ```\n-    #[unstable(feature = \"collections_drain\",\n+    #[unstable(feature = \"drain\",\n                reason = \"recently added, matches RFC\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeArgument<usize> {\n         // Memory safety\n@@ -840,7 +842,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(map_in_place)]\n     /// let v = vec![0, 1, 2];\n     /// let w = v.map_in_place(|i| i + 3);\n     /// assert_eq!(&w[..], &[3, 4, 5]);\n@@ -851,7 +853,7 @@ impl<T> Vec<T> {\n     /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n     /// assert_eq!(&newtyped_bytes[..], &[Newtype(0x11), Newtype(0x22)]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"map_in_place\",\n                reason = \"API may change to provide stronger guarantees\")]\n     pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n         // FIXME: Assert statically that the types `T` and `U` have the same\n@@ -1043,14 +1045,14 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(split_off)]\n     /// let mut vec = vec![1,2,3];\n     /// let vec2 = vec.split_off(1);\n     /// assert_eq!(vec, [1]);\n     /// assert_eq!(vec2, [2, 3]);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"split_off\",\n                reason = \"new API, waiting for dust to settle\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         assert!(at <= self.len(), \"`at` out of bounds\");\n@@ -1082,7 +1084,7 @@ impl<T: Clone> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vec_resize)]\n     /// let mut vec = vec![\"hello\"];\n     /// vec.resize(3, \"world\");\n     /// assert_eq!(vec, [\"hello\", \"world\", \"world\"]);\n@@ -1091,7 +1093,7 @@ impl<T: Clone> Vec<T> {\n     /// vec.resize(2, 0);\n     /// assert_eq!(vec, [1, 2]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"vec_resize\",\n                reason = \"matches collection reform specification; waiting for dust to settle\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n@@ -1111,13 +1113,13 @@ impl<T: Clone> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vec_push_all)]\n     /// let mut vec = vec![1];\n     /// vec.push_all(&[2, 3, 4]);\n     /// assert_eq!(vec, [1, 2, 3, 4]);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"vec_push_all\",\n                reason = \"likely to be replaced by a more optimized extend\")]\n     pub fn push_all(&mut self, other: &[T]) {\n         self.reserve(other.len());\n@@ -1707,12 +1709,14 @@ impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n     }\n }\n \n+#[allow(deprecated)]\n impl<'a, T: 'a> IntoCow<'a, [T]> for Vec<T> where T: Clone {\n     fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Owned(self)\n     }\n }\n \n+#[allow(deprecated)]\n impl<'a, T> IntoCow<'a, [T]> for &'a [T] where T: Clone {\n     fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Borrowed(self)\n@@ -1738,7 +1742,7 @@ unsafe impl<T: Sync> Sync for IntoIter<T> { }\n impl<T> IntoIter<T> {\n     #[inline]\n     /// Drops all items that have not yet been moved and returns the empty vector.\n-    #[unstable(feature = \"collections\")]\n+    #[unstable(feature = \"iter_to_vec\")]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self.by_ref() { }\n@@ -1832,7 +1836,7 @@ impl<T> Drop for IntoIter<T> {\n }\n \n /// A draining iterator for `Vec<T>`.\n-#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\")]\n pub struct Drain<'a, T: 'a> {\n     /// Index of tail to preserve\n     tail_start: usize,\n@@ -1907,12 +1911,17 @@ impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n #[unstable(feature = \"collections\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n pub struct DerefVec<'a, T:'a> {\n     x: Vec<T>,\n     l: PhantomData<&'a T>,\n }\n \n #[unstable(feature = \"collections\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n+#[allow(deprecated)]\n impl<'a, T> Deref for DerefVec<'a, T> {\n     type Target = Vec<T>;\n \n@@ -1923,6 +1932,9 @@ impl<'a, T> Deref for DerefVec<'a, T> {\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n+#[allow(deprecated)]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n         self.x.len = 0;\n@@ -1948,6 +1960,9 @@ impl<'a, T> Drop for DerefVec<'a, T> {\n /// vec_consumer(&as_vec(&values));\n /// ```\n #[unstable(feature = \"collections\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"replaced with deref coercions or Borrow\")]\n+#[allow(deprecated)]\n pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {\n         DerefVec {"}, {"sha": "edcd1008747fdc271184fd046bc13a4f5544a0d9", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -480,7 +480,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(deque_extras)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -491,7 +491,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf.len(), 1);\n     /// assert_eq!(Some(&5), buf.get(0));\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn truncate(&mut self, len: usize) {\n         for _ in len..self.len() {\n@@ -552,7 +552,7 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n         unsafe {\n@@ -572,7 +572,7 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -629,7 +629,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(drain)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut v = VecDeque::new();\n@@ -638,7 +638,7 @@ impl<T> VecDeque<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"drain\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain {\n@@ -868,7 +868,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(deque_extras)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -880,7 +880,7 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(10);\n     /// assert_eq!(buf.swap_back_remove(1), Some(99));\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"the naming of this function may be altered\")]\n     pub fn swap_back_remove(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n@@ -892,8 +892,8 @@ impl<T> VecDeque<T> {\n         self.pop_back()\n     }\n \n-    /// Removes an element from anywhere in the ringbuf and returns it, replacing it with the first\n-    /// element.\n+    /// Removes an element from anywhere in the ringbuf and returns it,\n+    /// replacing it with the first element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n@@ -902,7 +902,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(deque_extras)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -914,7 +914,7 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(20);\n     /// assert_eq!(buf.swap_front_remove(3), Some(99));\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"the naming of this function may be altered\")]\n     pub fn swap_front_remove(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n@@ -1310,7 +1310,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(split_off)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<_> = vec![1,2,3].into_iter().collect();\n@@ -1320,7 +1320,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf2.len(), 2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"split_off\",\n                reason = \"new API, waiting for dust to settle\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         let len = self.len();\n@@ -1373,7 +1373,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(append)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n@@ -1383,7 +1383,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf2.len(), 0);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"append\",\n                reason = \"new API, waiting for dust to settle\")]\n     pub fn append(&mut self, other: &mut Self) {\n         // naive impl\n@@ -1434,7 +1434,7 @@ impl<T: Clone> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(deque_extras)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -1447,7 +1447,7 @@ impl<T: Clone> VecDeque<T> {\n     ///     assert_eq!(a, b);\n     /// }\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"deque_extras\",\n                reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n@@ -1530,6 +1530,7 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -1635,7 +1636,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// A draining VecDeque iterator\n-#[unstable(feature = \"collections\",\n+#[unstable(feature = \"drain\",\n            reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, T: 'a> {\n     inner: &'a mut VecDeque<T>,"}, {"sha": "685bb5dc4b4f397140f4914fd370d1bcb9a1e900", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -12,6 +12,8 @@\n //! are O(highest integer key).\n \n #![allow(missing_docs)]\n+#![unstable(feature = \"vecmap\",\n+            reason = \"may not be stabilized in the standard library\")]\n \n use self::Entry::*;\n \n@@ -33,7 +35,7 @@ use vec::Vec;\n /// # Examples\n ///\n /// ```\n-/// # #![feature(collections)]\n+/// # #![feature(vecmap)]\n /// use std::collections::VecMap;\n ///\n /// let mut months = VecMap::new();\n@@ -133,7 +135,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n@@ -146,7 +148,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n@@ -161,7 +163,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     /// let map: VecMap<String> = VecMap::with_capacity(10);\n     /// assert!(map.capacity() >= 10);\n@@ -181,7 +183,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// map.reserve_len(10);\n@@ -206,7 +208,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// map.reserve_len_exact(10);\n@@ -246,7 +248,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -275,7 +277,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -305,7 +307,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap, append)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut a = VecMap::new();\n@@ -325,7 +327,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(a[3], \"c\");\n     /// assert_eq!(a[4], \"d\");\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"append\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn append(&mut self, other: &mut Self) {\n         self.extend(other.drain());\n@@ -341,7 +343,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap, split_off)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut a = VecMap::new();\n@@ -358,7 +360,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(b[3], \"c\");\n     /// assert_eq!(b[4], \"d\");\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"split_off\",\n                reason = \"recently added as part of collections reform 2\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         let mut other = VecMap::new();\n@@ -398,7 +400,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap, drain)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -410,7 +412,7 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"drain\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, V> {\n         fn filter<A>((i, v): (usize, Option<A>)) -> Option<(usize, A)> {\n@@ -426,7 +428,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut a = VecMap::new();\n@@ -444,7 +446,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut a = VecMap::new();\n@@ -462,7 +464,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut a = VecMap::new();\n@@ -478,7 +480,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -503,7 +505,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -522,7 +524,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -550,7 +552,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -576,7 +578,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -598,7 +600,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap, entry)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut count: VecMap<u32> = VecMap::new();\n@@ -632,7 +634,7 @@ impl<V> VecMap<V> {\n \n \n impl<'a, V> Entry<'a, V> {\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"entry\",\n                reason = \"will soon be replaced by or_insert\")]\n     #[deprecated(since = \"1.0\",\n                 reason = \"replaced with more ergonomic `or_insert` and `or_insert_with`\")]\n@@ -644,21 +646,20 @@ impl<'a, V> Entry<'a, V> {\n         }\n     }\n \n-    #[unstable(feature = \"collections\",\n-               reason = \"matches entry v3 specification, waiting for dust to settle\")]\n-    /// Ensures a value is in the entry by inserting the default if empty, and returns\n-    /// a mutable reference to the value in the entry.\n+    #[stable(feature = \"vecmap_entry\", since = \"1.2.0\")]\n+    /// Ensures a value is in the entry by inserting the default if empty, and\n+    /// returns a mutable reference to the value in the entry.\n     pub fn or_insert(self, default: V) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n             Vacant(entry) => entry.insert(default),\n         }\n     }\n \n-    #[unstable(feature = \"collections\",\n-               reason = \"matches entry v3 specification, waiting for dust to settle\")]\n-    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n-    /// and returns a mutable reference to the value in the entry.\n+    #[stable(feature = \"vecmap_entry\", since = \"1.2.0\")]\n+    /// Ensures a value is in the entry by inserting the result of the default\n+    /// function if empty, and returns a mutable reference to the value in the\n+    /// entry.\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n@@ -777,7 +778,7 @@ impl<T> IntoIterator for VecMap<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(vecmap)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -1003,22 +1004,22 @@ pub struct IntoIter<V> {\n     fn((usize, Option<V>)) -> Option<(usize, V)>>\n }\n \n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"drain\")]\n pub struct Drain<'a, V:'a> {\n     iter: FilterMap<\n     Enumerate<vec::Drain<'a, Option<V>>>,\n     fn((usize, Option<V>)) -> Option<(usize, V)>>\n }\n \n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"drain\")]\n impl<'a, V> Iterator for Drain<'a, V> {\n     type Item = (usize, V);\n \n     fn next(&mut self) -> Option<(usize, V)> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"drain\")]\n impl<'a, V> DoubleEndedIterator for Drain<'a, V> {\n     fn next_back(&mut self) -> Option<(usize, V)> { self.iter.next_back() }\n }"}, {"sha": "20a3625fe5add309152016c88fe1884042edfcc2", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,23 +8,52 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(bit_set_append_split_off)]\n+#![feature(append)]\n #![feature(bit_vec_append_split_off)]\n+#![feature(bitset)]\n+#![feature(bitvec)]\n #![feature(box_syntax)]\n+#![feature(btree_range)]\n #![feature(collections)]\n-#![feature(collections_drain)]\n-#![feature(core)]\n+#![feature(collections_bound)]\n #![feature(const_fn)]\n-#![feature(hash)]\n+#![feature(core)]\n+#![feature(deque_extras)]\n+#![feature(drain)]\n+#![feature(enumset)]\n+#![feature(hash_default)]\n+#![feature(into_cow)]\n+#![feature(iter_idx)]\n+#![feature(iter_order)]\n+#![feature(iter_arith)]\n+#![feature(iter_to_vec)]\n+#![feature(map_in_place)]\n+#![feature(move_from)]\n+#![feature(num_bits_bytes)]\n+#![feature(pattern)]\n+#![feature(permutations)]\n #![feature(rand)]\n+#![feature(range_inclusive)]\n #![feature(rustc_private)]\n+#![feature(slice_bytes)]\n+#![feature(slice_chars)]\n+#![feature(slice_extras)]\n+#![feature(slice_position_elem)]\n+#![feature(split_off)]\n+#![feature(step_by)]\n+#![feature(str_char)]\n+#![feature(str_escape)]\n+#![feature(str_match_indices)]\n+#![feature(str_utf16)]\n+#![feature(subslice_offset)]\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![feature(into_cow)]\n-#![feature(step_by)]\n-#![cfg_attr(test, feature(str_char))]\n-#![cfg_attr(test, feature(vec_deque_retain))]\n+#![feature(vec_deque_retain)]\n+#![feature(vec_from_raw_buf)]\n+#![feature(vec_push_all)]\n+#![feature(vec_split_off)]\n+#![feature(vecmap)]\n \n #[macro_use] extern crate log;\n "}, {"sha": "3f32136bc263974c62a1dfd6dea73f9879d88183", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::cmp::Ordering::{Equal, Greater, Less};\n-use std::str::{Utf8Error, from_utf8};\n+use std::str::from_utf8;\n \n #[test]\n fn test_le() {\n@@ -1753,6 +1753,7 @@ mod pattern {\n \n     macro_rules! make_test {\n         ($name:ident, $p:expr, $h:expr, [$($e:expr,)*]) => {\n+            #[allow(unused_imports)]\n             mod $name {\n                 use std::str::pattern::SearchStep::{Match, Reject};\n                 use super::{cmp_search_to_vec};"}, {"sha": "257caca4016df28e8cef0f826544a4d16649bceb", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,12 +10,13 @@\n \n use std::borrow::{IntoCow, Cow};\n use std::iter::repeat;\n-use std::str::Utf8Error;\n+#[allow(deprecated)]\n use std::string::as_string;\n \n use test::Bencher;\n \n #[test]\n+#[allow(deprecated)]\n fn test_as_string() {\n     let x = \"foo\";\n     assert_eq!(x, &**as_string(x));"}, {"sha": "df63fbc62fcf4f04169e054e823f7f6bc5e69a20", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,6 +10,7 @@\n \n use std::iter::{FromIterator, repeat};\n use std::mem::size_of;\n+#[allow(deprecated)]\n use std::vec::as_vec;\n \n use test::Bencher;\n@@ -25,12 +26,14 @@ impl<'a> Drop for DropCounter<'a> {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_as_vec() {\n     let xs = [1u8, 2u8, 3u8];\n     assert_eq!(&**as_vec(&xs), xs);\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_as_vec_dtor() {\n     let (mut count_x, mut count_y) = (0, 0);\n     {"}, {"sha": "95368de3bf3d91bf2630c433204f69a6d08d0896", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -537,8 +537,6 @@ fn test_drain() {\n \n #[test]\n fn test_from_iter() {\n-    use std::iter;\n-\n     let v = vec!(1,2,3,4,5,6,7);\n     let deq: VecDeque<_> = v.iter().cloned().collect();\n     let u: Vec<_> = deq.iter().cloned().collect();"}, {"sha": "f0c77ae866d599dcf374caf103c793893baa3c89", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -92,7 +92,7 @@ use marker::{Reflect, Sized};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Any: Reflect + 'static {\n     /// Gets the `TypeId` of `self`.\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"get_type_id\",\n                reason = \"this method will likely be replaced by an associated static\")]\n     fn get_type_id(&self) -> TypeId;\n }"}, {"sha": "a9b240de30befe0175d12aa17d967ce0f2f25107", "filename": "src/libcore/array.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -12,9 +12,10 @@\n //! up to a certain length. Eventually we should able to generalize\n //! to all lengths.\n \n-#![unstable(feature = \"core\")] // not yet reviewed\n-\n #![doc(primitive = \"array\")]\n+#![unstable(feature = \"fixed_size_array\",\n+            reason = \"traits and impls are better expressed through generic \\\n+                      integer constants\")]\n \n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n@@ -30,7 +31,6 @@ use slice::{Iter, IterMut, SliceExt};\n ///\n /// This trait can be used to implement other traits on fixed-size arrays\n /// without causing much metadata bloat.\n-#[unstable(feature = \"core\")]\n pub trait FixedSizeArray<T> {\n     /// Converts the array to immutable slice\n     fn as_slice(&self) -> &[T];\n@@ -42,7 +42,6 @@ pub trait FixedSizeArray<T> {\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n-            #[unstable(feature = \"core\")]\n             impl<T> FixedSizeArray<T> for [T; $N] {\n                 #[inline]\n                 fn as_slice(&self) -> &[T] {\n@@ -54,17 +53,13 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"array_as_ref\",\n-                       reason = \"should ideally be implemented for all fixed-sized arrays\")]\n             impl<T> AsRef<[T]> for [T; $N] {\n                 #[inline]\n                 fn as_ref(&self) -> &[T] {\n                     &self[..]\n                 }\n             }\n \n-            #[unstable(feature = \"array_as_ref\",\n-                       reason = \"should ideally be implemented for all fixed-sized arrays\")]\n             impl<T> AsMut<[T]> for [T; $N] {\n                 #[inline]\n                 fn as_mut(&mut self) -> &mut [T] {"}, {"sha": "37f37654c1fee8f903598fc8a5a410167c8b432c", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -221,15 +221,15 @@ impl<T:Copy> Cell<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n+    /// # #![feature(as_unsafe_cell)]\n     /// use std::cell::Cell;\n     ///\n     /// let c = Cell::new(5);\n     ///\n     /// let uc = unsafe { c.as_unsafe_cell() };\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"as_unsafe_cell\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n@@ -277,7 +277,7 @@ pub struct RefCell<T: ?Sized> {\n \n /// An enumeration of values returned from the `state` method on a `RefCell<T>`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-#[unstable(feature = \"std_misc\")]\n+#[unstable(feature = \"borrow_state\")]\n pub enum BorrowState {\n     /// The cell is currently being read, there is at least one active `borrow`.\n     Reading,\n@@ -339,7 +339,7 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// The returned value can be dispatched on to determine if a call to\n     /// `borrow` or `borrow_mut` would succeed.\n-    #[unstable(feature = \"std_misc\")]\n+    #[unstable(feature = \"borrow_state\")]\n     #[inline]\n     pub fn borrow_state(&self) -> BorrowState {\n         match self.borrow.get() {\n@@ -448,7 +448,7 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n     #[inline]\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"as_unsafe_cell\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n@@ -564,9 +564,10 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n-    /// This is an associated function that needs to be used as `Ref::clone(...)`.\n-    /// A `Clone` implementation or a method would interfere with the widespread\n-    /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n+    /// This is an associated function that needs to be used as\n+    /// `Ref::clone(...)`.  A `Clone` implementation or a method would interfere\n+    /// with the widespread use of `r.borrow().clone()` to clone the contents of\n+    /// a `RefCell`.\n     #[unstable(feature = \"cell_extras\",\n                reason = \"likely to be moved to a method, pending language changes\")]\n     #[inline]\n@@ -582,8 +583,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n     /// This is an associated function that needs to be used as `Ref::map(...)`.\n-    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n-    /// used through `Deref`.\n+    /// A method would interfere with methods of the same name on the contents\n+    /// of a `RefCell` used through `Deref`.\n     ///\n     /// # Example\n     ///\n@@ -607,13 +608,14 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         }\n     }\n \n-    /// Make a new `Ref` for a optional component of the borrowed data, e.g. an enum variant.\n+    /// Make a new `Ref` for a optional component of the borrowed data, e.g. an\n+    /// enum variant.\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n-    /// This is an associated function that needs to be used as `Ref::filter_map(...)`.\n-    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n-    /// used through `Deref`.\n+    /// This is an associated function that needs to be used as\n+    /// `Ref::filter_map(...)`.  A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n     ///\n     /// # Example\n     ///\n@@ -639,13 +641,14 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n }\n \n impl<'b, T: ?Sized> RefMut<'b, T> {\n-    /// Make a new `RefMut` for a component of the borrowed data, e.g. an enum variant.\n+    /// Make a new `RefMut` for a component of the borrowed data, e.g. an enum\n+    /// variant.\n     ///\n     /// The `RefCell` is already mutably borrowed, so this cannot fail.\n     ///\n-    /// This is an associated function that needs to be used as `RefMut::map(...)`.\n-    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n-    /// used through `Deref`.\n+    /// This is an associated function that needs to be used as\n+    /// `RefMut::map(...)`.  A method would interfere with methods of the same\n+    /// name on the contents of a `RefCell` used through `Deref`.\n     ///\n     /// # Example\n     ///\n@@ -673,13 +676,14 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         }\n     }\n \n-    /// Make a new `RefMut` for a optional component of the borrowed data, e.g. an enum variant.\n+    /// Make a new `RefMut` for a optional component of the borrowed data, e.g.\n+    /// an enum variant.\n     ///\n     /// The `RefCell` is already mutably borrowed, so this cannot fail.\n     ///\n-    /// This is an associated function that needs to be used as `RefMut::filter_map(...)`.\n-    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n-    /// used through `Deref`.\n+    /// This is an associated function that needs to be used as\n+    /// `RefMut::filter_map(...)`.  A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n     ///\n     /// # Example\n     ///\n@@ -690,7 +694,9 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     /// let c = RefCell::new(Ok(5));\n     /// {\n     ///     let b1: RefMut<Result<u32, ()>> = c.borrow_mut();\n-    ///     let mut b2: RefMut<u32> = RefMut::filter_map(b1, |o| o.as_mut().ok()).unwrap();\n+    ///     let mut b2: RefMut<u32> = RefMut::filter_map(b1, |o| {\n+    ///         o.as_mut().ok()\n+    ///     }).unwrap();\n     ///     assert_eq!(*b2, 5);\n     ///     *b2 = 42;\n     /// }"}, {"sha": "12aa06667a1dd3fb740203cebdaad306e0867bd5", "filename": "src/libcore/char.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -14,6 +14,7 @@\n \n #![allow(non_snake_case)]\n #![doc(primitive = \"char\")]\n+#![stable(feature = \"core_char\", since = \"1.2.0\")]\n \n use iter::Iterator;\n use mem::transmute;\n@@ -131,6 +132,8 @@ pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n // unicode/char.rs, not here\n #[allow(missing_docs)] // docs in libunicode/u_char.rs\n #[doc(hidden)]\n+#[unstable(feature = \"core_char_ext\",\n+           reason = \"the stable interface is `impl char` in later crate\")]\n pub trait CharExt {\n     fn is_digit(self, radix: u32) -> bool;\n     fn to_digit(self, radix: u32) -> Option<u32>;\n@@ -220,6 +223,9 @@ impl CharExt for char {\n /// If the buffer is not large enough, nothing will be written into it\n /// and a `None` will be returned.\n #[inline]\n+#[unstable(feature = \"char_internals\",\n+           reason = \"this function should not be exposed publicly\")]\n+#[doc(hidden)]\n pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if code < MAX_ONE_B && !dst.is_empty() {\n@@ -251,6 +257,9 @@ pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n /// If the buffer is not large enough, nothing will be written into it\n /// and a `None` will be returned.\n #[inline]\n+#[unstable(feature = \"char_internals\",\n+           reason = \"this function should not be exposed publicly\")]\n+#[doc(hidden)]\n pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if (ch & 0xFFFF) == ch && !dst.is_empty() {"}, {"sha": "a13160b3a19ee48d93582d57e548aef1f3411583", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -89,29 +89,28 @@ clone_impl! { char }\n \n macro_rules! extern_fn_clone {\n     ($($A:ident),*) => (\n-        #[unstable(feature = \"core\",\n-                   reason = \"this may not be sufficient for fns with region parameters\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($A,)* ReturnType> Clone for extern \"Rust\" fn($($A),*) -> ReturnType {\n             /// Returns a copy of a function pointer.\n             #[inline]\n             fn clone(&self) -> extern \"Rust\" fn($($A),*) -> ReturnType { *self }\n         }\n \n-        #[unstable(feature = \"core\", reason = \"brand new\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($A,)* ReturnType> Clone for extern \"C\" fn($($A),*) -> ReturnType {\n             /// Returns a copy of a function pointer.\n             #[inline]\n             fn clone(&self) -> extern \"C\" fn($($A),*) -> ReturnType { *self }\n         }\n \n-        #[unstable(feature = \"core\", reason = \"brand new\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($A,)* ReturnType> Clone for unsafe extern \"Rust\" fn($($A),*) -> ReturnType {\n             /// Returns a copy of a function pointer.\n             #[inline]\n             fn clone(&self) -> unsafe extern \"Rust\" fn($($A),*) -> ReturnType { *self }\n         }\n \n-        #[unstable(feature = \"core\", reason = \"brand new\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($A,)* ReturnType> Clone for unsafe extern \"C\" fn($($A),*) -> ReturnType {\n             /// Returns a copy of a function pointer.\n             #[inline]"}, {"sha": "0269499ad5414ffd681b673d21dc1c515f1e004d", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,10 +10,10 @@\n \n //! Functionality for ordering and comparison.\n //!\n-//! This module defines both `PartialOrd` and `PartialEq` traits which are used by the compiler to\n-//! implement comparison operators. Rust programs may implement `PartialOrd` to overload the `<`,\n-//! `<=`, `>`, and `>=` operators, and may implement `PartialEq` to overload the `==` and `!=`\n-//! operators.\n+//! This module defines both `PartialOrd` and `PartialEq` traits which are used\n+//! by the compiler to implement comparison operators. Rust programs may\n+//! implement `PartialOrd` to overload the `<`, `<=`, `>`, and `>=` operators,\n+//! and may implement `PartialEq` to overload the `==` and `!=` operators.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -22,29 +22,31 @@ use self::Ordering::*;\n use marker::Sized;\n use option::Option::{self, Some, None};\n \n-/// Trait for equality comparisons which are [partial equivalence relations](\n-/// http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n+/// Trait for equality comparisons which are [partial equivalence\n+/// relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n-/// This trait allows for partial equality, for types that do not have a full equivalence relation.\n-/// For example, in floating point numbers `NaN != NaN`, so floating point types implement\n-/// `PartialEq` but not `Eq`.\n+/// This trait allows for partial equality, for types that do not have a full\n+/// equivalence relation.  For example, in floating point numbers `NaN != NaN`,\n+/// so floating point types implement `PartialEq` but not `Eq`.\n ///\n /// Formally, the equality must be (for all `a`, `b` and `c`):\n ///\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n ///\n-/// Note that these requirements mean that the trait itself must be implemented symmetrically and\n-/// transitively: if `T: PartialEq<U>` and `U: PartialEq<V>` then `U: PartialEq<T>` and `T:\n-/// PartialEq<V>`.\n+/// Note that these requirements mean that the trait itself must be implemented\n+/// symmetrically and transitively: if `T: PartialEq<U>` and `U: PartialEq<V>`\n+/// then `U: PartialEq<T>` and `T: PartialEq<V>`.\n ///\n-/// PartialEq only requires the `eq` method to be implemented; `ne` is defined in terms of it by\n-/// default. Any manual implementation of `ne` *must* respect the rule that `eq` is a strict\n-/// inverse of `ne`; that is, `!(a == b)` if and only if `a != b`.\n+/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n+/// in terms of it by default. Any manual implementation of `ne` *must* respect\n+/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n+/// only if `a != b`.\n #[lang = \"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n-    /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n+    /// This method tests for `self` and `other` values to be equal, and is used\n+    /// by `==`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq(&self, other: &Rhs) -> bool;\n \n@@ -379,7 +381,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n /// # Examples\n ///\n /// ```\n-/// # #![feature(core)]\n+/// # #![feature(cmp_partial)]\n /// use std::cmp;\n ///\n /// assert_eq!(Some(1), cmp::partial_min(1, 2));\n@@ -389,14 +391,14 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n /// When comparison is impossible:\n ///\n /// ```\n-/// # #![feature(core)]\n+/// # #![feature(cmp_partial)]\n /// use std::cmp;\n ///\n /// let result = cmp::partial_min(std::f64::NAN, 1.0);\n /// assert_eq!(result, None);\n /// ```\n #[inline]\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"cmp_partial\")]\n pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) | Some(Equal) => Some(v1),\n@@ -412,7 +414,7 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n /// # Examples\n ///\n /// ```\n-/// # #![feature(core)]\n+/// # #![feature(cmp_partial)]\n /// use std::cmp;\n ///\n /// assert_eq!(Some(2), cmp::partial_max(1, 2));\n@@ -422,14 +424,14 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n /// When comparison is impossible:\n ///\n /// ```\n-/// # #![feature(core)]\n+/// # #![feature(cmp_partial)]\n /// use std::cmp;\n ///\n /// let result = cmp::partial_max(std::f64::NAN, 1.0);\n /// assert_eq!(result, None);\n /// ```\n #[inline]\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"cmp_partial\")]\n pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Equal) | Some(Less) => Some(v2),"}, {"sha": "70868805299f3a910a7a5858f33a508606acb1cb", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,11 +10,12 @@\n \n //! Traits for conversions between types.\n //!\n-//! The traits in this module provide a general way to talk about conversions from one type to\n-//! another. They follow the standard Rust conventions of `as`/`into`/`from`.\n+//! The traits in this module provide a general way to talk about conversions\n+//! from one type to another. They follow the standard Rust conventions of\n+//! `as`/`into`/`from`.\n //!\n-//! Like many traits, these are often used as bounds for generic functions, to support arguments of\n-//! multiple types.\n+//! Like many traits, these are often used as bounds for generic functions, to\n+//! support arguments of multiple types.\n //!\n //! See each trait for usage examples.\n "}, {"sha": "cbbb186af7609fc7cc431e12d9e0c83065d9a1ad", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -33,7 +33,7 @@ pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap}\n mod num;\n mod builders;\n \n-#[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n #[doc(hidden)]\n pub mod rt {\n     pub mod v1;\n@@ -146,7 +146,7 @@ enum Void {}\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n #[derive(Copy)]\n-#[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n #[doc(hidden)]\n pub struct ArgumentV1<'a> {\n     value: &'a Void,\n@@ -166,7 +166,7 @@ impl<'a> ArgumentV1<'a> {\n     }\n \n     #[doc(hidden)]\n-    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n     pub fn new<'b, T>(x: &'b T,\n                       f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {\n         unsafe {\n@@ -178,7 +178,7 @@ impl<'a> ArgumentV1<'a> {\n     }\n \n     #[doc(hidden)]\n-    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n     pub fn from_usize(x: &usize) -> ArgumentV1 {\n         ArgumentV1::new(x, ArgumentV1::show_usize)\n     }\n@@ -201,7 +201,7 @@ impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n     pub fn new_v1(pieces: &'a [&'a str],\n                   args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n         Arguments {\n@@ -218,7 +218,7 @@ impl<'a> Arguments<'a> {\n     /// created with `argumentusize`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n     pub fn new_v1_formatted(pieces: &'a [&'a str],\n                             args: &'a [ArgumentV1<'a>],\n                             fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n@@ -742,19 +742,19 @@ impl<'a> Formatter<'a> {\n     pub fn flags(&self) -> u32 { self.flags }\n \n     /// Character used as 'fill' whenever there is alignment\n-    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[unstable(feature = \"fmt_flags\", reason = \"method was just created\")]\n     pub fn fill(&self) -> char { self.fill }\n \n     /// Flag indicating what form of alignment was requested\n-    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[unstable(feature = \"fmt_flags\", reason = \"method was just created\")]\n     pub fn align(&self) -> Alignment { self.align }\n \n     /// Optionally specified integer width that the output should be\n-    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[unstable(feature = \"fmt_flags\", reason = \"method was just created\")]\n     pub fn width(&self) -> Option<usize> { self.width }\n \n     /// Optionally specified precision for numeric types\n-    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[unstable(feature = \"fmt_flags\", reason = \"method was just created\")]\n     pub fn precision(&self) -> Option<usize> { self.precision }\n \n     /// Creates a `DebugStruct` builder designed to assist with creation of"}, {"sha": "fc49f87d107699c2defce051f06df1100f6c37ce", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -127,7 +127,7 @@ radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n \n /// A radix with in the range of `2..36`.\n #[derive(Clone, Copy, PartialEq)]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"fmt_radix\",\n            reason = \"may be renamed or move to a different module\")]\n pub struct Radix {\n     base: u8,\n@@ -152,7 +152,7 @@ impl GenericRadix for Radix {\n }\n \n /// A helper type for formatting radixes.\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"fmt_radix\",\n            reason = \"may be renamed or move to a different module\")]\n #[derive(Copy, Clone)]\n pub struct RadixFmt<T, R>(T, R);\n@@ -162,11 +162,11 @@ pub struct RadixFmt<T, R>(T, R);\n /// # Examples\n ///\n /// ```\n-/// # #![feature(core)]\n+/// # #![feature(fmt_radix)]\n /// use std::fmt::radix;\n /// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_string());\n /// ```\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"fmt_radix\",\n            reason = \"may be renamed or move to a different module\")]\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))"}, {"sha": "033834dd5aaaa59dc7941eb5a82f06271782a599", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -14,8 +14,6 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-#![unstable(feature = \"core\", reason = \"internal to format_args!\")]\n-\n #[derive(Copy, Clone)]\n pub struct Argument {\n     pub position: Position,"}, {"sha": "abf9e55a1f2fbaa1e10a18cbde5fcbd5151b3a40", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -16,7 +16,7 @@\n //! # Examples\n //!\n //! ```rust\n-//! # #![feature(hash)]\n+//! # #![feature(hash_default)]\n //! use std::hash::{hash, Hash, SipHasher};\n //!\n //! #[derive(Hash)]\n@@ -36,7 +36,7 @@\n //! the trait `Hash`:\n //!\n //! ```rust\n-//! # #![feature(hash)]\n+//! # #![feature(hash_default)]\n //! use std::hash::{hash, Hash, Hasher, SipHasher};\n //!\n //! struct Person {\n@@ -89,7 +89,8 @@ pub trait Hash {\n     fn hash<H: Hasher>(&self, state: &mut H);\n \n     /// Feeds a slice of this type into the state provided.\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hash_slice\",\n+               reason = \"module was recently redesigned\")]\n     fn hash_slice<H: Hasher>(data: &[Self], state: &mut H) where Self: Sized {\n         for piece in data {\n             piece.hash(state);\n@@ -110,29 +111,29 @@ pub trait Hasher {\n \n     /// Write a single `u8` into this hasher\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_u8(&mut self, i: u8) { self.write(&[i]) }\n     /// Write a single `u16` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_u16(&mut self, i: u16) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i) })\n     }\n     /// Write a single `u32` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_u32(&mut self, i: u32) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i) })\n     }\n     /// Write a single `u64` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_u64(&mut self, i: u64) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n     }\n     /// Write a single `usize` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_usize(&mut self, i: usize) {\n         if cfg!(target_pointer_width = \"32\") {\n             self.write_u32(i as u32)\n@@ -143,31 +144,33 @@ pub trait Hasher {\n \n     /// Write a single `i8` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_i8(&mut self, i: i8) { self.write_u8(i as u8) }\n     /// Write a single `i16` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_i16(&mut self, i: i16) { self.write_u16(i as u16) }\n     /// Write a single `i32` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_i32(&mut self, i: i32) { self.write_u32(i as u32) }\n     /// Write a single `i64` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_i64(&mut self, i: i64) { self.write_u64(i as u64) }\n     /// Write a single `isize` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_isize(&mut self, i: isize) { self.write_usize(i as usize) }\n }\n \n /// Hash a value with the default SipHasher algorithm (two initial keys of 0).\n ///\n /// The specified value will be hashed with this hasher and then the resulting\n /// hash will be returned.\n-#[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+#[unstable(feature = \"hash_default\",\n+           reason = \"not the most ergonomic interface unless `H` is defaulted \\\n+                     to SipHasher, but perhaps not ready to commit to that\")]\n pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> u64 {\n     let mut h: H = Default::default();\n     value.hash(&mut h);"}, {"sha": "455928077da462f1d17279d52353e3e617eda326", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -39,7 +39,10 @@\n //!   guaranteed to happen in order. This is the standard mode for working\n //!   with atomic types and is equivalent to Java's `volatile`.\n \n-#![unstable(feature = \"core\")]\n+#![unstable(feature = \"core_intrinsics\",\n+            reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n+                      they should be used through stabilized interfaces \\\n+                      in the rest of the standard library\")]\n #![allow(missing_docs)]\n \n use marker::Sized;\n@@ -141,10 +144,10 @@ extern \"rust-intrinsic\" {\n \n     /// A compiler-only memory barrier.\n     ///\n-    /// Memory accesses will never be reordered across this barrier by the compiler,\n-    /// but no instructions will be emitted for it. This is appropriate for operations\n-    /// on the same thread that may be preempted, such as when interacting with signal\n-    /// handlers.\n+    /// Memory accesses will never be reordered across this barrier by the\n+    /// compiler, but no instructions will be emitted for it. This is\n+    /// appropriate for operations on the same thread that may be preempted,\n+    /// such as when interacting with signal handlers.\n     pub fn atomic_singlethreadfence();\n     pub fn atomic_singlethreadfence_acq();\n     pub fn atomic_singlethreadfence_rel();"}, {"sha": "3026f91e853eee34f69833a1615d05da56be928a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 94, "deletions": 55, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -51,8 +51,8 @@\n //! }\n //! ```\n //!\n-//! Because `Iterator`s implement `IntoIterator`, this `for` loop syntax can be applied to any\n-//! iterator over any type.\n+//! Because `Iterator`s implement `IntoIterator`, this `for` loop syntax can be\n+//! applied to any iterator over any type.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -822,7 +822,7 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n+    /// # #![feature(iter_min_max)]\n     /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n     ///\n     /// let a: [i32; 0] = [];\n@@ -837,7 +837,9 @@ pub trait Iterator {\n     /// let a = [1, 1, 1, 1];\n     /// assert_eq!(a.iter().min_max(), MinMax(&1, &1));\n     /// ```\n-    #[unstable(feature = \"core\", reason = \"return type may change\")]\n+    #[unstable(feature = \"iter_min_max\",\n+               reason = \"return type may change or may wish to have a closure \\\n+                         based version as well\")]\n     fn min_max(mut self) -> MinMaxResult<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n         let (mut min, mut max) = match self.next() {\n@@ -892,12 +894,12 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n+    /// # #![feature(iter_cmp)]\n     /// let a = [-3_i32, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"iter_cmp\",\n                reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn max_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where\n         Self: Sized,\n@@ -920,12 +922,12 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n+    /// # #![feature(iter_cmp)]\n     /// let a = [-3_i32, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"iter_cmp\",\n                reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn min_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where\n         Self: Sized,\n@@ -1041,6 +1043,8 @@ pub trait Iterator {\n     /// Use an iterator to reverse a container in place.\n     #[unstable(feature = \"core\",\n                reason = \"uncertain about placement or widespread use\")]\n+    #[deprecated(since = \"1.2.0\",\n+                 reason = \"not performant enough to justify inclusion\")]\n     fn reverse_in_place<'a, T: 'a>(&mut self) where\n         Self: Sized + Iterator<Item=&'a mut T> + DoubleEndedIterator\n     {\n@@ -1057,12 +1061,12 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n+    /// # #![feature(iter_arith)]\n     /// let a = [1, 2, 3, 4, 5];\n     /// let it = a.iter();\n     /// assert_eq!(it.sum::<i32>(), 15);\n     /// ```\n-    #[unstable(feature=\"core\")]\n+    #[unstable(feature=\"iter_arith\", reason = \"bounds recently changed\")]\n     fn sum<S=<Self as Iterator>::Item>(self) -> S where\n         S: Add<Self::Item, Output=S> + Zero,\n         Self: Sized,\n@@ -1075,15 +1079,15 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n+    /// # #![feature(iter_arith)]\n     /// fn factorial(n: u32) -> u32 {\n     ///     (1..).take_while(|&i| i <= n).product()\n     /// }\n     /// assert_eq!(factorial(0), 1);\n     /// assert_eq!(factorial(1), 1);\n     /// assert_eq!(factorial(5), 120);\n     /// ```\n-    #[unstable(feature=\"core\")]\n+    #[unstable(feature=\"iter_arith\", reason = \"bounds recently changed\")]\n     fn product<P=<Self as Iterator>::Item>(self) -> P where\n         P: Mul<Self::Item, Output=P> + One,\n         Self: Sized,\n@@ -1223,9 +1227,14 @@ impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n /// `DoubleEndedIterator`.  Calling `next()` or `next_back()` on a\n /// `RandomAccessIterator` reduces the indexable range accordingly. That is,\n /// `it.idx(1)` will become `it.idx(0)` after `it.next()` is called.\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"iter_idx\",\n            reason = \"not widely used, may be better decomposed into Index \\\n                      and ExactSizeIterator\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"trait has not proven itself as a widely useful \\\n+                       abstraction for iterators, and more time may be needed \\\n+                       for iteration on the design\")]\n+#[allow(deprecated)]\n pub trait RandomAccessIterator: Iterator {\n     /// Returns the number of indexable elements. At most `std::usize::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n@@ -1304,7 +1313,8 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<I> RandomAccessIterator for Rev<I>\n     where I: DoubleEndedIterator + RandomAccessIterator\n {\n@@ -1324,7 +1334,7 @@ impl<I> RandomAccessIterator for Rev<I>\n /// `MinMaxResult` is an enum returned by `min_max`. See `Iterator::min_max` for\n /// more detail.\n #[derive(Clone, PartialEq, Debug)]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"iter_min_max\",\n            reason = \"unclear whether such a fine-grained result is widely useful\")]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n@@ -1338,6 +1348,7 @@ pub enum MinMaxResult<T> {\n     MinMax(T, T)\n }\n \n+#[unstable(feature = \"iter_min_max\", reason = \"type is unstable\")]\n impl<T: Clone> MinMaxResult<T> {\n     /// `into_option` creates an `Option` of type `(T,T)`. The returned `Option`\n     /// has variant `None` if and only if the `MinMaxResult` has variant\n@@ -1348,7 +1359,7 @@ impl<T: Clone> MinMaxResult<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n+    /// # #![feature(iter_min_max)]\n     /// use std::iter::MinMaxResult::{self, NoElements, OneElement, MinMax};\n     ///\n     /// let r: MinMaxResult<i32> = NoElements;\n@@ -1360,7 +1371,6 @@ impl<T: Clone> MinMaxResult<T> {\n     /// let r = MinMax(1, 2);\n     /// assert_eq!(r.into_option(), Some((1, 2)));\n     /// ```\n-    #[unstable(feature = \"core\", reason = \"type is unstable\")]\n     pub fn into_option(self) -> Option<(T,T)> {\n         match self {\n             NoElements => None,\n@@ -1407,7 +1417,8 @@ impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n     where I: ExactSizeIterator<Item=&'a T>, T: Clone\n {}\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<'a, I, T: 'a> RandomAccessIterator for Cloned<I>\n     where I: RandomAccessIterator<Item=&'a T>, T: Clone\n {\n@@ -1454,7 +1465,8 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<I> RandomAccessIterator for Cycle<I> where\n     I: Clone + RandomAccessIterator,\n {\n@@ -1568,7 +1580,8 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<A, B> RandomAccessIterator for Chain<A, B> where\n     A: RandomAccessIterator,\n     B: RandomAccessIterator<Item = A::Item>,\n@@ -1656,7 +1669,8 @@ impl<A, B> DoubleEndedIterator for Zip<A, B> where\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<A, B> RandomAccessIterator for Zip<A, B> where\n     A: RandomAccessIterator,\n     B: RandomAccessIterator\n@@ -1710,7 +1724,8 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<B, I: RandomAccessIterator, F> RandomAccessIterator for Map<I, F> where\n     F: FnMut(I::Item) -> B,\n {\n@@ -1884,7 +1899,8 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2134,7 +2150,8 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2206,7 +2223,8 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2236,7 +2254,8 @@ pub struct Scan<I, St, F> {\n     f: F,\n \n     /// The current internal state to be passed to the closure next.\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"scan_state\",\n+               reason = \"public fields are otherwise rare in the stdlib\")]\n     pub state: St,\n }\n \n@@ -2406,7 +2425,8 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n }\n \n // Allow RandomAccessIterators to be fused without affecting random-access behavior\n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2427,7 +2447,7 @@ impl<I> Fuse<I> {\n     /// `.next_back()` will call the underlying iterator again even if it\n     /// previously returned `None`.\n     #[inline]\n-    #[unstable(feature = \"core\", reason = \"seems marginal\")]\n+    #[unstable(feature = \"iter_reset_fuse\", reason = \"seems marginal\")]\n     pub fn reset_fuse(&mut self) {\n         self.done = false\n     }\n@@ -2481,7 +2501,8 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n     where F: FnMut(&I::Item),\n {\n@@ -2504,7 +2525,7 @@ impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n /// An iterator that yields sequential Fibonacci numbers, and stops on overflow.\n ///\n /// ```\n-/// #![feature(core)]\n+/// #![feature(iter_unfold)]\n /// use std::iter::Unfold;\n ///\n /// // This iterator will yield up to the last Fibonacci number before the max\n@@ -2531,16 +2552,24 @@ impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n ///     println!(\"{}\", i);\n /// }\n /// ```\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"iter_unfold\")]\n #[derive(Clone)]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"has gained enough traction to retain its position \\\n+                       in the standard library\")]\n+#[allow(deprecated)]\n pub struct Unfold<St, F> {\n     f: F,\n     /// Internal state that will be passed to the closure on the next iteration\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"iter_unfold\")]\n     pub state: St,\n }\n \n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"iter_unfold\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"has gained enough traction to retain its position \\\n+                       in the standard library\")]\n+#[allow(deprecated)]\n impl<A, St, F> Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the closure\n@@ -2554,6 +2583,7 @@ impl<A, St, F> Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl<A, St, F> Iterator for Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n     type Item = A;\n \n@@ -2767,7 +2797,7 @@ impl<A> Iterator for StepBy<A, RangeFrom<A>> where\n \n /// An iterator over the range [start, stop]\n #[derive(Clone)]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"range_inclusive\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeInclusive<A> {\n     range: ops::Range<A>,\n@@ -2776,7 +2806,7 @@ pub struct RangeInclusive<A> {\n \n /// Returns an iterator over the range [start, stop].\n #[inline]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"range_inclusive\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_inclusive<A>(start: A, stop: A) -> RangeInclusive<A>\n     where A: Step + One + Clone\n@@ -2787,7 +2817,7 @@ pub fn range_inclusive<A>(start: A, stop: A) -> RangeInclusive<A>\n     }\n }\n \n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"range_inclusive\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n impl<A> Iterator for RangeInclusive<A> where\n     A: PartialEq + Step + One + Clone,\n@@ -2820,7 +2850,7 @@ impl<A> Iterator for RangeInclusive<A> where\n     }\n }\n \n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"range_inclusive\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n impl<A> DoubleEndedIterator for RangeInclusive<A> where\n     A: PartialEq + Step + One + Clone,\n@@ -2962,18 +2992,19 @@ impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { self.idx(0) }\n+    fn next(&mut self) -> Option<A> { Some(self.element.clone()) }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.idx(0) }\n+    fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<A: Clone> RandomAccessIterator for Repeat<A> {\n     #[inline]\n     fn indexable(&self) -> usize { usize::MAX }\n@@ -2985,12 +3016,20 @@ type IterateState<T, F> = (F, Option<T>, bool);\n \n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"iter_iterate\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"has gained enough traction to retain its position \\\n+                       in the standard library\")]\n+#[allow(deprecated)]\n pub type Iterate<T, F> = Unfold<IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n /// Creates a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"iter_iterate\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"has gained enough traction to retain its position \\\n+                       in the standard library\")]\n+#[allow(deprecated)]\n pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n     T: Clone,\n     F: FnMut(T) -> T,\n@@ -3022,10 +3061,10 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n }\n \n /// An iterator that yields nothing.\n-#[unstable(feature=\"iter_empty\", reason = \"new addition\")]\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n pub struct Empty<T>(marker::PhantomData<T>);\n \n-#[unstable(feature=\"iter_empty\", reason = \"new addition\")]\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n impl<T> Iterator for Empty<T> {\n     type Item = T;\n \n@@ -3038,14 +3077,14 @@ impl<T> Iterator for Empty<T> {\n     }\n }\n \n-#[unstable(feature=\"iter_empty\", reason = \"new addition\")]\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n impl<T> DoubleEndedIterator for Empty<T> {\n     fn next_back(&mut self) -> Option<T> {\n         None\n     }\n }\n \n-#[unstable(feature=\"iter_empty\", reason = \"new addition\")]\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n impl<T> ExactSizeIterator for Empty<T> {\n     fn len(&self) -> usize {\n         0\n@@ -3054,7 +3093,7 @@ impl<T> ExactSizeIterator for Empty<T> {\n \n // not #[derive] because that adds a Clone bound on T,\n // which isn't necessary.\n-#[unstable(feature=\"iter_empty\", reason = \"new addition\")]\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n impl<T> Clone for Empty<T> {\n     fn clone(&self) -> Empty<T> {\n         Empty(marker::PhantomData)\n@@ -3063,27 +3102,27 @@ impl<T> Clone for Empty<T> {\n \n // not #[derive] because that adds a Default bound on T,\n // which isn't necessary.\n-#[unstable(feature=\"iter_empty\", reason = \"new addition\")]\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n impl<T> Default for Empty<T> {\n     fn default() -> Empty<T> {\n         Empty(marker::PhantomData)\n     }\n }\n \n /// Creates an iterator that yields nothing.\n-#[unstable(feature=\"iter_empty\", reason = \"new addition\")]\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n pub fn empty<T>() -> Empty<T> {\n     Empty(marker::PhantomData)\n }\n \n /// An iterator that yields an element exactly once.\n #[derive(Clone)]\n-#[unstable(feature=\"iter_once\", reason = \"new addition\")]\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub struct Once<T> {\n     inner: ::option::IntoIter<T>\n }\n \n-#[unstable(feature=\"iter_once\", reason = \"new addition\")]\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n impl<T> Iterator for Once<T> {\n     type Item = T;\n \n@@ -3096,22 +3135,22 @@ impl<T> Iterator for Once<T> {\n     }\n }\n \n-#[unstable(feature=\"iter_once\", reason = \"new addition\")]\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n impl<T> DoubleEndedIterator for Once<T> {\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.next_back()\n     }\n }\n \n-#[unstable(feature=\"iter_once\", reason = \"new addition\")]\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n impl<T> ExactSizeIterator for Once<T> {\n     fn len(&self) -> usize {\n         self.inner.len()\n     }\n }\n \n /// Creates an iterator that yields an element exactly once.\n-#[unstable(feature=\"iter_once\", reason = \"new addition\")]\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub fn once<T>(value: T) -> Once<T> {\n     Once { inner: Some(value).into_iter() }\n }\n@@ -3123,7 +3162,7 @@ pub fn once<T>(value: T) -> Once<T> {\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n-#[unstable(feature = \"core\", reason = \"needs review and revision\")]\n+#[unstable(feature = \"iter_order\", reason = \"needs review and revision\")]\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};"}, {"sha": "030d2a33f8f65625449894f4af05f7778b777bb6", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -49,7 +49,9 @@\n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"core\"]\n-#![unstable(feature = \"core\")]\n+#![unstable(feature = \"core\",\n+            reason = \"the libcore library has not yet been scrutinized for \\\n+                      stabilization in terms of structure and naming\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -63,7 +65,8 @@\n #![allow(raw_pointer_derive)]\n #![deny(missing_docs)]\n \n-#![feature(intrinsics, lang_items)]\n+#![feature(intrinsics)]\n+#![feature(lang_items)]\n #![feature(on_unimplemented)]\n #![feature(simd)]\n #![feature(staged_api)]\n@@ -75,6 +78,7 @@\n #![feature(reflect)]\n #![feature(custom_attribute)]\n #![feature(const_fn)]\n+#![feature(allow_internal_unstable)]\n \n #[macro_use]\n mod macros;"}, {"sha": "14bb82dff7d6eacfaae85a68032266ea37fb6ab0", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,6 +10,7 @@\n \n /// Entry point of thread panic, for details, see std::macros\n #[macro_export]\n+#[allow_internal_unstable]\n macro_rules! panic {\n     () => (\n         panic!(\"explicit panic\")"}, {"sha": "dd60164a114db0f547ff61718a22f2d5222ad738", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -54,7 +54,7 @@ pub trait Sized {\n }\n \n /// Types that can be \"unsized\" to a dynamically sized type.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"unsize\")]\n #[lang=\"unsize\"]\n pub trait Unsize<T> {\n     // Empty.\n@@ -223,7 +223,10 @@ impl<T> !Sync for *mut T { }\n /// ensure that they are never copied, even if they lack a destructor.\n #[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"structs are by default not copyable\")]\n #[lang = \"no_copy_bound\"]\n+#[allow(deprecated)]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub struct NoCopy;\n \n@@ -385,7 +388,7 @@ mod impls {\n /// that function. Here is an example:\n ///\n /// ```\n-/// #![feature(core)]\n+/// #![feature(reflect_marker)]\n /// use std::marker::Reflect;\n /// use std::any::Any;\n /// fn foo<T:Reflect+'static>(x: &T) {\n@@ -410,7 +413,8 @@ mod impls {\n ///\n /// [1]: http://en.wikipedia.org/wiki/Parametricity\n #[rustc_reflect_like]\n-#[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n+#[unstable(feature = \"reflect_marker\",\n+           reason = \"requires RFC and more experience\")]\n #[allow(deprecated)]\n #[rustc_on_unimplemented = \"`{Self}` does not implement `Any`; \\\n                             ensure all type parameters are bounded by `Any`\"]"}, {"sha": "15e7cdbde408d04ffe9b1e826994ac13875edefb", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -459,19 +459,27 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n \n /// Transforms lifetime of the second pointer to match the first.\n #[inline]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"copy_lifetime\",\n            reason = \"this function may be removed in the future due to its \\\n                      questionable utility\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"unclear that this function buys more safety and \\\n+                       lifetimes are generally not handled as such in unsafe \\\n+                       code today\")]\n pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n                                                         ptr: &T) -> &'a T {\n     transmute(ptr)\n }\n \n /// Transforms lifetime of the second mutable pointer to match the first.\n #[inline]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"copy_lifetime\",\n            reason = \"this function may be removed in the future due to its \\\n                      questionable utility\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"unclear that this function buys more safety and \\\n+                       lifetimes are generally not handled as such in unsafe \\\n+                       code today\")]\n pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n                                                                ptr: &mut T)\n                                                               -> &'a mut T"}, {"sha": "1b5fa4e0e950b9ba113e16c143f6103452812d0d", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n //! Exposes the NonZero lang item which provides optimization hints.\n+#![unstable(feature = \"nonzero\",\n+            reason = \"needs an RFC to flesh out the design\")]\n \n use marker::Sized;\n use ops::{CoerceUnsized, Deref};\n@@ -33,7 +35,6 @@ unsafe impl Zeroable for u64 {}\n /// NULL or 0 that might allow certain optimizations.\n #[lang = \"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\n-#[unstable(feature = \"core\")]\n pub struct NonZero<T: Zeroable>(T);\n \n impl<T: Zeroable> NonZero<T> {"}, {"sha": "aade9061657b7f4ecc9e250abdb8e42f20e1e84d", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -71,7 +71,9 @@ pub mod consts {\n     pub const PI: f32 = 3.14159265358979323846264338327950288_f32;\n \n     /// pi * 2.0\n-    #[unstable(feature = \"core\", reason = \"unclear naming convention/usefulness\")]\n+    #[unstable(feature = \"float_consts\",\n+               reason = \"unclear naming convention/usefulness\")]\n+    #[deprecated(since = \"1.2.0\", reason = \"unclear on usefulness\")]\n     pub const PI_2: f32 = 6.28318530717958647692528676655900576_f32;\n \n     /// pi/2.0\n@@ -135,7 +137,6 @@ pub mod consts {\n     pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is unstable\")]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { NAN }"}, {"sha": "7c9e846af9b10219c1d2ae02bf255b95fb6c244c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -71,7 +71,9 @@ pub mod consts {\n     pub const PI: f64 = 3.14159265358979323846264338327950288_f64;\n \n     /// pi * 2.0\n-    #[unstable(feature = \"core\", reason = \"unclear naming convention/usefulness\")]\n+    #[unstable(feature = \"float_consts\",\n+               reason = \"unclear naming convention/usefulness\")]\n+    #[deprecated(since = \"1.2.0\", reason = \"unclear on usefulness\")]\n     pub const PI_2: f64 = 6.28318530717958647692528676655900576_f64;\n \n     /// pi/2.0\n@@ -135,7 +137,6 @@ pub mod consts {\n     pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is unstable\")]\n impl Float for f64 {\n     #[inline]\n     fn nan() -> f64 { NAN }"}, {"sha": "f3a7e8f09a9eb77c3dec1d9938f352ff43c75600", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -126,6 +126,8 @@ functions.\n // while this is extensively documented, this is in principle private which is\n // only made public for testing. do not expose us.\n #![doc(hidden)]\n+#![unstable(feature = \"flt2dec\",\n+            reason = \"internal routines only exposed for testing\")]\n \n use prelude::*;\n use i16;"}, {"sha": "efc91238809784650f60a6657e1d4c38b38fb871", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -14,11 +14,13 @@ macro_rules! int_module { ($T:ty, $bits:expr) => (\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"num_bits_bytes\",\n+           reason = \"may want to be an associated function\")]\n pub const BITS : usize = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"num_bits_bytes\",\n+           reason = \"may want to be an associated function\")]\n pub const BYTES : usize = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of"}, {"sha": "c1297d3c19c1afc76d102fb07b0db596f78a410f", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -41,10 +41,7 @@ use str::{FromStr, StrExt};\n #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug)]\n pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n-#[unstable(feature = \"core\", reason = \"may be removed or relocated\")]\n pub mod wrapping;\n-\n-#[unstable(feature = \"core\", reason = \"internal routines only exposed for testing\")]\n pub mod flt2dec;\n \n /// Types that have a \"zero\" value.\n@@ -471,7 +468,7 @@ macro_rules! int_impl {\n         /// to `-MIN`, a positive value that is too large to represent\n         /// in the type. In such a case, this function returns `MIN`\n         /// itself..\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_div(self, rhs: Self) -> Self {\n             self.overflowing_div(rhs).0\n@@ -484,7 +481,7 @@ macro_rules! int_impl {\n         /// implementation artifacts make `x % y` illegal for `MIN /\n         /// -1` on a signed type illegal (where `MIN` is the negative\n         /// minimal value). In such a case, this function returns `0`.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_rem(self, rhs: Self) -> Self {\n             self.overflowing_rem(rhs).0\n@@ -498,7 +495,7 @@ macro_rules! int_impl {\n         /// negative minimal value for the type); this is a positive\n         /// value that is too large to represent in the type. In such\n         /// a case, this function returns `MIN` itself.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_neg(self) -> Self {\n             self.overflowing_neg().0\n@@ -507,7 +504,7 @@ macro_rules! int_impl {\n         /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n@@ -516,7 +513,7 @@ macro_rules! int_impl {\n         /// Panic-free bitwise shift-left; yields `self >> mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n@@ -1041,7 +1038,7 @@ macro_rules! uint_impl {\n         /// to `-MIN`, a positive value that is too large to represent\n         /// in the type. In such a case, this function returns `MIN`\n         /// itself..\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_div(self, rhs: Self) -> Self {\n             self.overflowing_div(rhs).0\n@@ -1054,7 +1051,7 @@ macro_rules! uint_impl {\n         /// implementation artifacts make `x % y` illegal for `MIN /\n         /// -1` on a signed type illegal (where `MIN` is the negative\n         /// minimal value). In such a case, this function returns `0`.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_rem(self, rhs: Self) -> Self {\n             self.overflowing_rem(rhs).0\n@@ -1068,7 +1065,7 @@ macro_rules! uint_impl {\n         /// negative minimal value for the type); this is a positive\n         /// value that is too large to represent in the type. In such\n         /// a case, this function returns `MIN` itself.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_neg(self) -> Self {\n             self.overflowing_neg().0\n@@ -1077,7 +1074,7 @@ macro_rules! uint_impl {\n         /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n@@ -1086,7 +1083,7 @@ macro_rules! uint_impl {\n         /// Panic-free bitwise shift-left; yields `self >> mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n@@ -1262,6 +1259,8 @@ pub enum FpCategory {\n \n /// A built-in floating point number.\n #[doc(hidden)]\n+#[unstable(feature = \"core_float\",\n+           reason = \"stable interface is via `impl f{32,64}` in later crates\")]\n pub trait Float {\n     /// Returns the NaN value.\n     fn nan() -> Self;\n@@ -1512,8 +1511,11 @@ enum IntErrorKind {\n }\n \n impl ParseIntError {\n-    #[unstable(feature = \"core\", reason = \"available through Error trait\")]\n-    pub fn description(&self) -> &str {\n+    #[unstable(feature = \"int_error_internals\",\n+               reason = \"available through Error trait and this method should \\\n+                         not be exposed publicly\")]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n         match self.kind {\n             IntErrorKind::Empty => \"cannot parse integer from empty string\",\n             IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n@@ -1526,7 +1528,7 @@ impl ParseIntError {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for ParseIntError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.description().fmt(f)\n+        self.__description().fmt(f)\n     }\n }\n \n@@ -1535,10 +1537,15 @@ impl fmt::Display for ParseIntError {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseFloatError {\n     #[doc(hidden)]\n+    #[unstable(feature = \"float_error_internals\",\n+               reason = \"should not be exposed publicly\")]\n     pub __kind: FloatErrorKind\n }\n \n #[derive(Debug, Clone, PartialEq)]\n+#[unstable(feature = \"float_error_internals\",\n+           reason = \"should not be exposed publicly\")]\n+#[doc(hidden)]\n pub enum FloatErrorKind {\n     Empty,\n     Invalid,"}, {"sha": "0719d7c17cc4e44fbf2a6b99ca74ba8b1fa52410", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -12,9 +12,11 @@\n \n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"num_bits_bytes\",\n+           reason = \"may want to be an associated function\")]\n pub const BITS : usize = $bits;\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"num_bits_bytes\",\n+           reason = \"may want to be an associated function\")]\n pub const BYTES : usize = ($bits / 8);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "748ed29e3a30682e0c39d0863f166d46acda2c91", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,6 +10,7 @@\n \n #![allow(missing_docs)]\n #![allow(deprecated)]\n+#![unstable(feature = \"wrapping\", reason = \"may be removed or relocated\")]\n \n use super::Wrapping;\n \n@@ -30,7 +31,6 @@ use intrinsics::{i64_mul_with_overflow, u64_mul_with_overflow};\n \n use ::{i8,i16,i32,i64};\n \n-#[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n pub trait OverflowingOps {\n     fn overflowing_add(self, rhs: Self) -> (Self, bool);\n     fn overflowing_sub(self, rhs: Self) -> (Self, bool);"}, {"sha": "48b1cbeef4fddd95d401d652b114caa233b54617", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -29,8 +29,8 @@\n //!\n //! # Examples\n //!\n-//! This example creates a `Point` struct that implements `Add` and `Sub`, and then\n-//! demonstrates adding and subtracting two `Point`s.\n+//! This example creates a `Point` struct that implements `Add` and `Sub`, and\n+//! then demonstrates adding and subtracting two `Point`s.\n //!\n //! ```rust\n //! use std::ops::{Add, Sub};\n@@ -62,21 +62,21 @@\n //! }\n //! ```\n //!\n-//! See the documentation for each trait for a minimum implementation that prints\n-//! something to the screen.\n+//! See the documentation for each trait for a minimum implementation that\n+//! prints something to the screen.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::{Sized, Unsize};\n use fmt;\n \n-/// The `Drop` trait is used to run some code when a value goes out of scope. This\n-/// is sometimes called a 'destructor'.\n+/// The `Drop` trait is used to run some code when a value goes out of scope.\n+/// This is sometimes called a 'destructor'.\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `Drop`. The `drop` method is called when `_x` goes\n-/// out of scope, and therefore `main` prints `Dropping!`.\n+/// A trivial implementation of `Drop`. The `drop` method is called when `_x`\n+/// goes out of scope, and therefore `main` prints `Dropping!`.\n ///\n /// ```\n /// struct HasDrop;\n@@ -103,8 +103,7 @@ pub trait Drop {\n // based on \"op T\" where T is expected to be `Copy`able\n macro_rules! forward_ref_unop {\n     (impl $imp:ident, $method:ident for $t:ty) => {\n-        #[unstable(feature = \"core\",\n-                   reason = \"recently added, waiting for dust to settle\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> $imp for &'a $t {\n             type Output = <$t as $imp>::Output;\n \n@@ -120,8 +119,7 @@ macro_rules! forward_ref_unop {\n // based on \"T op U\" where T and U are expected to be `Copy`able\n macro_rules! forward_ref_binop {\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        #[unstable(feature = \"core\",\n-                   reason = \"recently added, waiting for dust to settle\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> $imp<$u> for &'a $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -131,8 +129,7 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable(feature = \"core\",\n-                   reason = \"recently added, waiting for dust to settle\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> $imp<&'a $u> for $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -142,8 +139,7 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable(feature = \"core\",\n-                   reason = \"recently added, waiting for dust to settle\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, 'b> $imp<&'a $u> for &'b $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -1210,7 +1206,7 @@ mod impls {\n \n /// Trait that indicates that this is a pointer or a wrapper for one,\n /// where unsizing can be performed on the pointee.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"coerce_unsized\")]\n #[lang=\"coerce_unsized\"]\n pub trait CoerceUnsized<T> {\n     // Empty."}, {"sha": "c5203c5111b64ab5e3ab7fa306eca86b12062ccd", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -274,7 +274,7 @@ impl<T> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n+    /// # #![feature(as_slice)]\n     /// let mut x = Some(\"Diamonds\");\n     /// {\n     ///     let v = x.as_mut_slice();\n@@ -285,7 +285,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(\"Dirt\"));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"as_slice\",\n                reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n         match *self {"}, {"sha": "8133db097dfcf9c8b8ded1d4011cb6c525fa82cd", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -29,6 +29,9 @@\n //! library, but the location of this may change over time.\n \n #![allow(dead_code, missing_docs)]\n+#![unstable(feature = \"core_panic\",\n+            reason = \"internal details of the implementation of the `panic!` \\\n+                      and related macros\")]\n \n use fmt;\n "}, {"sha": "ac153d64ab28ffbbeb0a37a843ab3a6d1d76b36f", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -24,6 +24,10 @@\n //! use core::prelude::*;\n //! ```\n \n+#![unstable(feature = \"core_prelude\",\n+            reason = \"the libcore prelude has not been scrutinized and \\\n+                      stabilized yet\")]\n+\n // Reexported core operators\n pub use marker::{Copy, Send, Sized, Sync};\n pub use ops::{Drop, Fn, FnMut, FnOnce};\n@@ -32,7 +36,6 @@ pub use ops::{Drop, Fn, FnMut, FnOnce};\n pub use mem::drop;\n \n // Reexported types and traits\n-\n pub use char::CharExt;\n pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};"}, {"sha": "31cdb6093c8d917a5c5a55739706d3b11153f91b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -49,7 +49,7 @@\n //! the raw pointer. It doesn't destroy `T` or deallocate any memory.\n //!\n //! ```\n-//! # #![feature(alloc)]\n+//! # #![feature(box_raw)]\n //! use std::boxed;\n //!\n //! unsafe {\n@@ -204,7 +204,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// This is unsafe for the same reasons that `read` is unsafe.\n #[inline(always)]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"read_and_zero\",\n            reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n@@ -219,7 +219,7 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n /// Variant of read_and_zero that writes the specific drop-flag byte\n /// (which may be more appropriate than zero).\n #[inline(always)]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"filling_drop\",\n            reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn read_and_drop<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n@@ -267,9 +267,10 @@ impl<T: ?Sized> *const T {\n     /// null-safety, it is important to note that this is still an unsafe\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n-    #[unstable(feature = \"core\",\n-               reason = \"Option is not clearly the right return type, and we may want \\\n-                         to tie the return lifetime to a borrow of the raw pointer\")]\n+    #[unstable(feature = \"ptr_as_ref\",\n+               reason = \"Option is not clearly the right return type, and we \\\n+                         may want to tie the return lifetime to a borrow of \\\n+                         the raw pointer\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> where T: Sized {\n         if self.is_null() {\n@@ -314,9 +315,10 @@ impl<T: ?Sized> *mut T {\n     /// null-safety, it is important to note that this is still an unsafe\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n-    #[unstable(feature = \"core\",\n-               reason = \"Option is not clearly the right return type, and we may want \\\n-                         to tie the return lifetime to a borrow of the raw pointer\")]\n+    #[unstable(feature = \"ptr_as_ref\",\n+               reason = \"Option is not clearly the right return type, and we \\\n+                         may want to tie the return lifetime to a borrow of \\\n+                         the raw pointer\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> where T: Sized {\n         if self.is_null() {\n@@ -347,7 +349,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// As with `as_ref`, this is unsafe because it cannot verify the validity\n     /// of the returned pointer.\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"ptr_as_ref\",\n                reason = \"return value does not necessarily convey all possible \\\n                          information\")]\n     #[inline]\n@@ -507,7 +509,7 @@ impl<T: ?Sized> PartialOrd for *mut T {\n /// modified without a unique path to the `Unique` reference. Useful\n /// for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n-#[unstable(feature = \"unique\")]\n+#[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\")]\n pub struct Unique<T: ?Sized> {\n     pointer: NonZero<*const T>,\n     _marker: PhantomData<T>,\n@@ -527,21 +529,19 @@ unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n #[unstable(feature = \"unique\")]\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n+#[unstable(feature = \"unique\")]\n impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique`.\n-    #[unstable(feature = \"unique\")]\n     pub unsafe fn new(ptr: *mut T) -> Unique<T> {\n         Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n \n     /// Dereferences the content.\n-    #[unstable(feature = \"unique\")]\n     pub unsafe fn get(&self) -> &T {\n         &**self.pointer\n     }\n \n     /// Mutably dereferences the content.\n-    #[unstable(feature = \"unique\")]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut ***self\n     }"}, {"sha": "43535ddd1d5c5f7ff9b27d7bb8d91919e805e4b5", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n-#![unstable(feature = \"core\")]\n+#![unstable(feature = \"raw\")]\n \n //! Contains struct definitions for the layout of compiler built-in types.\n //!\n@@ -49,7 +49,7 @@ use mem;\n /// # Examples\n ///\n /// ```\n-/// # #![feature(core)]\n+/// # #![feature(raw)]\n /// use std::raw::{self, Repr};\n ///\n /// let slice: &[u16] = &[1, 2, 3, 4];\n@@ -98,7 +98,7 @@ impl<T> Clone for Slice<T> {\n /// # Examples\n ///\n /// ```\n-/// # #![feature(core)]\n+/// # #![feature(raw)]\n /// use std::mem;\n /// use std::raw;\n ///"}, {"sha": "d87c1020dcc2f99e58e9ec0d4de3649e2a7744bf", "filename": "src/libcore/result.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -420,7 +420,7 @@ impl<T, E> Result<T, E> {\n     /// Converts from `Result<T, E>` to `&mut [T]` (without copying)\n     ///\n     /// ```\n-    /// # #![feature(core)]\n+    /// # #![feature(as_slice)]\n     /// let mut x: Result<&str, u32> = Ok(\"Gold\");\n     /// {\n     ///     let v = x.as_mut_slice();\n@@ -434,7 +434,7 @@ impl<T, E> Result<T, E> {\n     /// assert!(x.as_mut_slice().is_empty());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"as_slice\",\n                reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         match *self {\n@@ -966,7 +966,11 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned.\n #[inline]\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"result_fold\",\n+           reason = \"unclear if this function should exist\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"has not seen enough usage to justify its position in \\\n+                       the standard library\")]\n pub fn fold<T,\n             V,\n             E,"}, {"sha": "7ecd08bea3574fc192b3d9d2811b39e2922d264a", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -19,7 +19,7 @@\n //! provided beyond this module.\n //!\n //! ```rust\n-//! # #![feature(core)]\n+//! # #![feature(core_simd)]\n //! fn main() {\n //!     use std::simd::f32x4;\n //!     let a = f32x4(40.0, 41.0, 42.0, 43.0);\n@@ -33,10 +33,12 @@\n //! These are all experimental. The interface may change entirely, without\n //! warning.\n \n+#![unstable(feature = \"core_simd\",\n+            reason = \"needs an RFC to flesh out the design\")]\n+\n #![allow(non_camel_case_types)]\n #![allow(missing_docs)]\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n@@ -45,26 +47,22 @@ pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n@@ -73,32 +71,27 @@ pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]"}, {"sha": "a8c995f37cce44cb84bcb5bf86bfeff447d159cc", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -64,6 +64,8 @@ use raw::Slice as RawSlice;\n /// Extension methods for slices.\n #[allow(missing_docs)] // docs in libcollections\n #[doc(hidden)]\n+#[unstable(feature = \"core_slice_ext\",\n+           reason = \"stable interface provided by `impl [T]` in later crates\")]\n pub trait SliceExt {\n     type Item;\n \n@@ -148,7 +150,6 @@ macro_rules! slice_ref {\n     }};\n }\n \n-#[unstable(feature = \"core\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -256,7 +257,6 @@ impl<T> SliceExt for [T] {\n         self.repr().data\n     }\n \n-    #[unstable(feature = \"core\")]\n     fn binary_search_by<F>(&self, mut f: F) -> Result<usize, usize> where\n         F: FnMut(&T) -> Ordering\n     {\n@@ -437,12 +437,10 @@ impl<T> SliceExt for [T] {\n         m >= n && needle == &self[m-n..]\n     }\n \n-    #[unstable(feature = \"core\")]\n     fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n-    #[unstable(feature = \"core\")]\n     fn next_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -473,7 +471,6 @@ impl<T> SliceExt for [T] {\n         true\n     }\n \n-    #[unstable(feature = \"core\")]\n     fn prev_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -774,7 +771,7 @@ impl<'a, T> Iter<'a, T> {\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"iter_to_slice\")]\n     pub fn as_slice(&self) -> &'a [T] {\n         make_slice!(self.ptr, self.end)\n     }\n@@ -804,7 +801,8 @@ impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -842,7 +840,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// to consume the iterator. Consider using the `Slice` and\n     /// `SliceMut` implementations for obtaining slices with more\n     /// restricted lifetimes that do not consume the iterator.\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"iter_to_slice\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n         make_mut_slice!(self.ptr, self.end)\n     }\n@@ -1176,7 +1174,8 @@ impl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<'a, T> RandomAccessIterator for Windows<'a, T> {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -1263,7 +1262,8 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -1349,15 +1349,15 @@ impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n //\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"ref_slice\")]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n         from_raw_parts(s, 1)\n     }\n }\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"ref_slice\")]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n         from_raw_parts_mut(s, 1)\n@@ -1415,7 +1415,7 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n //\n \n /// Operations on `[u8]`.\n-#[unstable(feature = \"core\", reason = \"needs review\")]\n+#[unstable(feature = \"slice_bytes\", reason = \"needs review\")]\n pub mod bytes {\n     use ptr;\n     use slice::SliceExt;\n@@ -1503,7 +1503,11 @@ impl<T: PartialOrd> PartialOrd for [T] {\n }\n \n /// Extension methods for slices containing integers.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"int_slice\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"has not seen much usage and may want to live in the \\\n+                       standard library now that most slice methods are \\\n+                       on an inherent implementation block\")]\n pub trait IntSliceExt<U, S> {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n     fn as_unsigned<'a>(&'a self) -> &'a [U];\n@@ -1518,7 +1522,8 @@ pub trait IntSliceExt<U, S> {\n \n macro_rules! impl_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n-        #[unstable(feature = \"core\")]\n+        #[unstable(feature = \"int_slice\")]\n+        #[allow(deprecated)]\n         impl IntSliceExt<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }"}, {"sha": "5a621176c4a812b45976d9744964f2ea31eeab62", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -13,6 +13,7 @@\n //! For more details, see std::str\n \n #![doc(primitive = \"str\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::OldSearcher::{TwoWay, TwoWayLong};\n use self::pattern::Pattern;\n@@ -191,7 +192,7 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n \n /// Reads the next code point out of a byte iterator (assuming a\n /// UTF-8-like encoding).\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"str_internals\")]\n #[inline]\n pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Decode UTF-8\n@@ -226,9 +227,8 @@ pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n \n /// Reads the last code point out of a byte iterator (assuming a\n /// UTF-8-like encoding).\n-#[unstable(feature = \"core\")]\n #[inline]\n-pub fn next_code_point_reverse(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n+fn next_code_point_reverse(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Decode UTF-8\n     let w = match bytes.next_back() {\n         None => return None,\n@@ -738,7 +738,7 @@ generate_pattern_iterators! {\n         #[doc=\"Created with the method `.rmatch_indices()`.\"]\n         struct RMatchIndices;\n     stability:\n-        #[unstable(feature = \"core\",\n+        #[unstable(feature = \"str_match_indices\",\n                    reason = \"type may be removed or have its iterator impl changed\")]\n     internal:\n         MatchIndicesInternal yielding ((usize, usize));\n@@ -779,7 +779,7 @@ generate_pattern_iterators! {\n         #[doc=\"Created with the method `.rmatches()`.\"]\n         struct RMatches;\n     stability:\n-        #[unstable(feature = \"core\", reason = \"type got recently added\")]\n+        #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n     internal:\n         MatchesInternal yielding (&'a str);\n     delegate double ended;\n@@ -1470,6 +1470,8 @@ mod traits {\n /// Methods for string slices\n #[allow(missing_docs)]\n #[doc(hidden)]\n+#[unstable(feature = \"core_str_ext\",\n+           reason = \"stable interface provided by `impl str` in later crates\")]\n pub trait StrExt {\n     // NB there are no docs here are they're all located on the StrExt trait in\n     // libcollections, not here.\n@@ -1870,8 +1872,7 @@ impl AsRef<[u8]> for str {\n /// Pluck a code point out of a UTF-8-like byte slice and return the\n /// index of the next code point.\n #[inline]\n-#[unstable(feature = \"core\")]\n-pub fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n+fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n     if bytes[i] < 128 {\n         return (bytes[i] as u32, i + 1);\n     }"}, {"sha": "8bdbab55211d8cce2dc735d1d3fd670450098d15", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -13,6 +13,9 @@\n //! For more details, see the traits `Pattern`, `Searcher`,\n //! `ReverseSearcher` and `DoubleEndedSearcher`.\n \n+#![unstable(feature = \"pattern\",\n+            reason = \"API not fully fleshed out and ready to be stabilized\")]\n+\n use prelude::*;\n \n // Pattern"}, {"sha": "35c1cb09281f41cc035500f52014afca66f60754", "filename": "src/libcore/ty.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f4518127636e6bffab0599ab4dad785a873c5bd8/src%2Flibcore%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4518127636e6bffab0599ab4dad785a873c5bd8/src%2Flibcore%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fty.rs?ref=f4518127636e6bffab0599ab4dad785a873c5bd8", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Types dealing with unsafe actions.\n-\n-use marker;"}, {"sha": "08536e63204753e4e90372b0223afece3987d12b", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,27 +8,45 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n-#![cfg_attr(stage0, feature(custom_attribute))]\n-\n+#![feature(as_unsafe_cell)]\n+#![feature(borrow_state)]\n #![feature(box_syntax)]\n-#![feature(unboxed_closures)]\n-#![feature(core)]\n+#![feature(cell_extras)]\n+#![feature(cmp_partial)]\n #![feature(const_fn)]\n-#![feature(test)]\n-#![feature(rand)]\n-#![feature(unicode)]\n-#![feature(std_misc)]\n-#![feature(libc)]\n-#![feature(hash)]\n-#![feature(unique)]\n-#![feature(step_by)]\n-#![feature(slice_patterns)]\n+#![feature(core)]\n+#![feature(core_float)]\n+#![feature(float_extras)]\n #![feature(float_from_str_radix)]\n-#![feature(cell_extras)]\n+#![feature(flt2dec)]\n+#![feature(fmt_radix)]\n+#![feature(hash_default)]\n+#![feature(hasher_write)]\n+#![feature(iter_arith)]\n+#![feature(iter_arith)]\n+#![feature(iter_cmp)]\n #![feature(iter_empty)]\n+#![feature(iter_idx)]\n+#![feature(iter_iterate)]\n+#![feature(iter_min_max)]\n #![feature(iter_once)]\n+#![feature(iter_order)]\n+#![feature(iter_unfold)]\n+#![feature(libc)]\n+#![feature(nonzero)]\n+#![feature(num_bits_bytes)]\n+#![feature(ptr_as_ref)]\n+#![feature(rand)]\n+#![feature(range_inclusive)]\n+#![feature(raw)]\n #![feature(result_expect)]\n+#![feature(slice_bytes)]\n+#![feature(slice_patterns)]\n+#![feature(step_by)]\n+#![feature(test)]\n+#![feature(unboxed_closures)]\n+#![feature(unicode)]\n+#![feature(unique)]\n \n extern crate core;\n extern crate test;"}, {"sha": "04271ed5dd1a174de5c2e3770c6e85b44e07f1bd", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use core::option::*;\n-use core::marker;\n use core::mem;\n use core::clone::Clone;\n \n@@ -81,7 +80,8 @@ fn test_option_dance() {\n \n #[test] #[should_panic]\n fn test_option_too_much_dance() {\n-    let mut y = Some(marker::NoCopy);\n+    struct A;\n+    let mut y = Some(A);\n     let _y2 = y.take().unwrap();\n     let _y3 = y.take().unwrap();\n }"}, {"sha": "58cdf1133ec6a83b5ff11b1faf82274e39e4115b", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -28,7 +28,7 @@\n #![feature(libc)]\n #![feature(staged_api)]\n #![feature(unique)]\n-#![cfg_attr(test, feature(rustc_private, rand, collections))]\n+#![cfg_attr(test, feature(rustc_private, rand, vec_push_all))]\n \n #[cfg(test)] #[macro_use] extern crate log;\n "}, {"sha": "f8d80035d97fb62f645924142a72f9a7b7b76933", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -281,8 +281,9 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(collections)]\n+\n #![feature(into_cow)]\n+#![feature(str_escape)]\n \n use self::LabelText::*;\n "}, {"sha": "7bafd9382f059e8f715507212ec11085855f18d8", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -169,14 +169,14 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![deny(missing_docs)]\n \n-#![feature(alloc)]\n-#![feature(staged_api)]\n+#![feature(box_raw)]\n #![feature(box_syntax)]\n-#![feature(core)]\n #![feature(const_fn)]\n-#![feature(std_misc)]\n+#![feature(iter_cmp)]\n+#![feature(rt)]\n+#![feature(staged_api)]\n+#![feature(static_mutex)]\n \n-use std::boxed;\n use std::cell::RefCell;\n use std::fmt;\n use std::io::{self, Stderr};\n@@ -435,12 +435,12 @@ fn init() {\n \n         assert!(FILTER.is_null());\n         match filter {\n-            Some(f) => FILTER = boxed::into_raw(box f),\n+            Some(f) => FILTER = Box::into_raw(box f),\n             None => {}\n         }\n \n         assert!(DIRECTIVES.is_null());\n-        DIRECTIVES = boxed::into_raw(box directives);\n+        DIRECTIVES = Box::into_raw(box directives);\n \n         // Schedule the cleanup for the globals for when the runtime exits.\n         let _ = rt::at_exit(move || {"}, {"sha": "ec510b4a5bdfb4367792dc6194e7b1884af558ef", "filename": "src/librand/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -29,11 +29,15 @@\n #![unstable(feature = \"rand\",\n             reason = \"use `rand` from crates.io\")]\n #![feature(core)]\n+#![feature(core_float)]\n+#![feature(core_prelude)]\n+#![feature(core_slice_ext)]\n #![feature(no_std)]\n+#![feature(num_bits_bytes)]\n #![feature(staged_api)]\n #![feature(step_by)]\n \n-#![cfg_attr(test, feature(test, rand, rustc_private))]\n+#![cfg_attr(test, feature(test, rand, rustc_private, iter_order))]\n \n #![allow(deprecated)]\n "}, {"sha": "18b1d39ea82d80e59f068b35c215e2ccd228d897", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -123,9 +123,9 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(core)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(slice_bytes)]\n \n #![cfg_attr(test, feature(test))]\n "}, {"sha": "240aaae0e55afabe568b2647336afe04cf9f22e6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -25,26 +25,41 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![feature(append)]\n #![feature(associated_consts)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(clone_from_slice)]\n #![feature(collections)]\n #![feature(const_fn)]\n-#![feature(core)]\n #![feature(duration)]\n #![feature(duration_span)]\n+#![feature(dynamic_lib)]\n+#![feature(enumset)]\n #![feature(fs_canonicalize)]\n-#![feature(hash)]\n+#![feature(hash_default)]\n+#![feature(hashmap_hasher)]\n #![feature(into_cow)]\n+#![feature(iter_cmp)]\n+#![feature(iter_arith)]\n #![feature(libc)]\n+#![feature(map_in_place)]\n+#![feature(num_bits_bytes)]\n #![feature(path_ext)]\n #![feature(quote)]\n+#![feature(range_inclusive)]\n+#![feature(ref_slice)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slice_bytes)]\n+#![feature(slice_extras)]\n #![feature(slice_patterns)]\n+#![feature(slice_position_elem)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n #![feature(str_char)]\n+#![feature(str_match_indices)]\n+#![feature(vec_push_all)]\n+#![feature(wrapping)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(trivial_casts)]"}, {"sha": "297041a99079072577940109fe7e01c2dded21d3", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -33,15 +33,15 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(box_syntax)]\n-#![feature(collections)]\n-#![feature(core)]\n+#![feature(fs_canonicalize)]\n+#![feature(libc)]\n+#![feature(path_ext)]\n+#![feature(rand)]\n #![feature(rustc_private)]\n+#![feature(slice_bytes)]\n #![feature(staged_api)]\n-#![feature(rand)]\n-#![feature(path_ext)]\n #![feature(step_by)]\n-#![feature(libc)]\n-#![feature(fs_canonicalize)]\n+#![feature(vec_push_all)]\n #![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;"}, {"sha": "b59c24cf12bdb5e4e717443c0b55b8737cb84f8a", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -19,7 +19,7 @@\n #![feature(no_std)]\n #![no_std]\n #![unstable(feature = \"rustc_private\")]\n-#![cfg_attr(test, feature(hash))]\n+#![cfg_attr(test, feature(hash_default))]\n \n //! A typesafe bitmask flag generator.\n "}, {"sha": "fe3ffe97981515698d074febe9d322ca959e3f3c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -26,14 +26,13 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(box_syntax)]\n-#![feature(collections)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(staged_api)]\n-#![feature(exit_status)]\n #![feature(set_stdio)]\n+#![feature(staged_api)]\n+#![feature(vec_push_all)]\n \n extern crate arena;\n extern crate flate;\n@@ -73,6 +72,7 @@ use std::env;\n use std::io::{self, Read, Write};\n use std::iter::repeat;\n use std::path::PathBuf;\n+use std::process;\n use std::str;\n use std::sync::{Arc, Mutex};\n use std::thread;\n@@ -861,5 +861,5 @@ pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n \n pub fn main() {\n     let result = run(env::args().collect());\n-    std::env::set_exit_status(result as i32);\n+    process::exit(result as i32);\n }"}, {"sha": "c680906dd135bc741703dd7f4a7392cf03864417", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -30,16 +30,16 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![cfg_attr(test, feature(test))]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![cfg_attr(stage0, feature(collections))]\n-#![feature(core)]\n+#![feature(num_bits_bytes)]\n #![feature(quote)]\n+#![feature(ref_slice)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(str_char)]\n-#![cfg_attr(test, feature(test))]\n \n extern crate syntax;\n #[macro_use]"}, {"sha": "6d36e457b3d43189138b4858232a83126eaafe48", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -27,10 +27,10 @@\n \n #![feature(associated_consts)]\n #![feature(box_syntax)]\n-#![feature(collections)]\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(staged_api)]\n+#![feature(vec_push_all)]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;"}, {"sha": "787f914718d4b60922ea662119cf4e682544ecfe", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -19,11 +19,11 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(alloc)]\n #![feature(associated_consts)]\n-#![feature(collections)]\n+#![feature(rc_weak)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slice_extras)]\n #![feature(staged_api)]\n \n #[macro_use] extern crate log;"}, {"sha": "267f0b6d95329dbfb9d80ffbc628d40988b28caf", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -25,7 +25,6 @@ use syntax::diagnostic::{Emitter, Handler, Level};\n \n use std::ffi::{CStr, CString};\n use std::fs;\n-use std::iter::Unfold;\n use std::mem;\n use std::path::Path;\n use std::process::{Command, Stdio};\n@@ -913,11 +912,10 @@ fn run_work_singlethreaded(sess: &Session,\n                            reachable: &[String],\n                            work_items: Vec<WorkItem>) {\n     let cgcx = CodegenContext::new_with_session(sess, reachable);\n-    let mut work_items = work_items;\n \n     // Since we're running single-threaded, we can pass the session to\n     // the proc, allowing `optimize_and_codegen` to perform LTO.\n-    for work in Unfold::new((), |_| work_items.pop()) {\n+    for work in work_items.into_iter().rev() {\n         execute_work_item(&cgcx, work);\n     }\n }"}, {"sha": "bb7e95cd4ae44d7eb4db5f05c0c62d4953a35286", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -25,21 +25,24 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(alloc)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(collections)]\n-#![feature(core)]\n #![feature(const_fn)]\n+#![feature(iter_cmp)]\n+#![feature(iter_arith)]\n #![feature(libc)]\n+#![feature(path_ext)]\n+#![feature(path_ext)]\n+#![feature(path_relative_from)]\n+#![feature(path_relative_from)]\n #![feature(quote)]\n+#![feature(rc_weak)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(unicode)]\n-#![feature(path_ext)]\n-#![feature(path_relative_from)]\n-#![feature(std_misc)]\n+#![feature(unicode)]\n+#![feature(vec_push_all)]\n \n #![allow(trivial_casts)]\n "}, {"sha": "7519cd05195695fe2f2799c8919d112b0608d6cb", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -75,14 +75,19 @@ This API is completely unstable and subject to change.\n \n #![allow(non_camel_case_types)]\n \n+#![feature(append)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(collections, collections_drain)]\n-#![feature(core)]\n+#![feature(drain)]\n+#![feature(iter_cmp)]\n+#![feature(iter_arith)]\n #![feature(quote)]\n+#![feature(ref_slice)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slice_extras)]\n #![feature(staged_api)]\n+#![feature(vec_push_all)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "0ad5141c5bee69ff555e84018a32cede5656afd7", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -310,7 +310,9 @@ impl char {\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     #[inline]\n-    pub fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> { C::encode_utf8(self, dst) }\n+    pub fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> {\n+        C::encode_utf8(self, dst)\n+    }\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer, and\n     /// then returns the number of `u16`s written.\n@@ -345,7 +347,9 @@ impl char {\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     #[inline]\n-    pub fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> { C::encode_utf16(self, dst) }\n+    pub fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> {\n+        C::encode_utf16(self, dst)\n+    }\n \n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n@@ -541,5 +545,7 @@ impl char {\n     #[unstable(feature = \"unicode\",\n                reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n     #[inline]\n-    pub fn width(self, is_cjk: bool) -> Option<usize> { charwidth::width(self, is_cjk) }\n+    pub fn width(self, is_cjk: bool) -> Option<usize> {\n+        charwidth::width(self, is_cjk)\n+    }\n }"}, {"sha": "b420444d1f5c813b440e6ebcfbaa0ba624a7d3d4", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -24,18 +24,24 @@\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"rustc_unicode\"]\n #![unstable(feature = \"unicode\")]\n-#![feature(lang_items)]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(no_std)]\n+       html_playground_url = \"http://play.rust-lang.org/\",\n+       test(no_crate_inject))]\n #![no_std]\n+\n #![feature(core)]\n-#![doc(test(no_crate_inject))]\n+#![feature(core_char_ext)]\n+#![feature(core_prelude)]\n+#![feature(core_slice_ext)]\n+#![feature(core_str_ext)]\n+#![feature(iter_arith)]\n+#![feature(lang_items)]\n+#![feature(no_std)]\n+#![feature(staged_api)]\n \n extern crate core;\n "}, {"sha": "17d912dd4cb333936e16e21a0b0a0305414466e6", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -22,18 +22,20 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(collections)]\n-#![feature(exit_status)]\n-#![feature(set_stdio)]\n+#![feature(dynamic_lib)]\n #![feature(libc)]\n+#![feature(owned_ascii_ext)]\n+#![feature(path_ext)]\n+#![feature(path_relative_from)]\n #![feature(rustc_private)]\n+#![feature(set_stdio)]\n+#![feature(slice_extras)]\n+#![feature(slice_patterns)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n+#![feature(subslice_offset)]\n #![feature(test)]\n #![feature(unicode)]\n-#![feature(path_ext)]\n-#![feature(path_relative_from)]\n-#![feature(slice_patterns)]\n+#![feature(vec_push_all)]\n \n extern crate arena;\n extern crate getopts;\n@@ -58,6 +60,7 @@ use std::env;\n use std::fs::File;\n use std::io::{self, Read, Write};\n use std::path::PathBuf;\n+use std::process;\n use std::rc::Rc;\n use std::sync::mpsc::channel;\n \n@@ -131,7 +134,7 @@ pub fn main() {\n         let s = env::args().collect::<Vec<_>>();\n         main_args(&s)\n     }).unwrap().join().unwrap();\n-    env::set_exit_status(res as i32);\n+    process::exit(res as i32);\n }\n \n pub fn opts() -> Vec<getopts::OptGroup> {"}, {"sha": "e7d9751cf4bc6d85718d8f975155fa8cf5c261dd", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -29,12 +29,14 @@ Core encoding and decoding interfaces.\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(core)]\n+#![feature(enumset)]\n+#![feature(hashmap_hasher)]\n+#![feature(num_bits_bytes)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n-#![feature(unicode)]\n #![feature(str_char)]\n+#![feature(unicode)]\n+#![feature(vecmap)]\n #![cfg_attr(test, feature(test))]\n \n // test harness access"}, {"sha": "9b94b7f7003ed62f521e37eae944b7848cf61f66", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -18,7 +18,7 @@ use ops::Range;\n use mem;\n \n /// Extension methods for ASCII-subset only operations on owned strings\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"owned_ascii_ext\",\n            reason = \"would prefer to do this in a more general way\")]\n pub trait OwnedAsciiExt {\n     /// Converts the string to ASCII upper case:\n@@ -189,8 +189,6 @@ impl AsciiExt for str {\n     }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for String {\n     #[inline]\n     fn into_ascii_uppercase(self) -> String {\n@@ -244,8 +242,6 @@ impl AsciiExt for [u8] {\n     }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_uppercase(mut self) -> Vec<u8> {"}, {"sha": "1dca3b77f3880ed9497a3560cbfa223f9bbda264", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -43,8 +43,7 @@ use super::table::BucketState::{\n use super::state::HashState;\n \n const INITIAL_LOG2_CAP: usize = 5;\n-#[unstable(feature = \"std_misc\")]\n-pub const INITIAL_CAPACITY: usize = 1 << INITIAL_LOG2_CAP; // 2^5\n+const INITIAL_CAPACITY: usize = 1 << INITIAL_LOG2_CAP; // 2^5\n \n /// The default behavior of HashMap implements a load factor of 90.9%.\n /// This behavior is characterized by the following condition:\n@@ -544,7 +543,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(hashmap_hasher)]\n     /// use std::collections::HashMap;\n     /// use std::collections::hash_map::RandomState;\n     ///\n@@ -553,7 +552,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// map.insert(1, 2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n+    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\")]\n     pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n         HashMap {\n             hash_state:    hash_state,\n@@ -573,7 +572,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(hashmap_hasher)]\n     /// use std::collections::HashMap;\n     /// use std::collections::hash_map::RandomState;\n     ///\n@@ -582,7 +581,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// map.insert(1, 2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n+    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\")]\n     pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n                                         -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n@@ -980,7 +979,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(drain)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut a = HashMap::new();\n@@ -995,7 +994,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// assert!(a.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"drain\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n@@ -1308,7 +1307,7 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n }\n \n /// HashMap drain iterator.\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"drain\",\n            reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n     inner: iter::Map<table::Drain<'a, K, V>, fn((SafeHash, K, V)) -> (K, V)>\n@@ -1480,7 +1479,7 @@ impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n }\n \n impl<'a, K, V> Entry<'a, K, V> {\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"entry\",\n                reason = \"will soon be replaced by or_insert\")]\n     #[deprecated(since = \"1.0\",\n                 reason = \"replaced with more ergonomic `or_insert` and `or_insert_with`\")]\n@@ -1596,14 +1595,14 @@ impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\n /// `Hasher`, but the hashers created by two different `RandomState`\n /// instances are unlikely to produce the same result for the same values.\n #[derive(Clone)]\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"hashmap_hasher\",\n            reason = \"hashing an hash maps may be altered\")]\n pub struct RandomState {\n     k0: u64,\n     k1: u64,\n }\n \n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"hashmap_hasher\",\n            reason = \"hashing an hash maps may be altered\")]\n impl RandomState {\n     /// Constructs a new `RandomState` that is initialized with random keys.\n@@ -1615,7 +1614,7 @@ impl RandomState {\n     }\n }\n \n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"hashmap_hasher\",\n            reason = \"hashing an hash maps may be altered\")]\n impl HashState for RandomState {\n     type Hasher = SipHasher;"}, {"sha": "ba50b156ab230a3f52b001e30cde2dbaf33bcacb", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -20,9 +20,11 @@ use iter::{Iterator, IntoIterator, ExactSizeIterator, FromIterator, Map, Chain,\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n \n-use super::map::{self, HashMap, Keys, INITIAL_CAPACITY, RandomState};\n+use super::map::{self, HashMap, Keys, RandomState};\n use super::state::HashState;\n \n+const INITIAL_CAPACITY: usize = 32;\n+\n // Future Optimization (FIXME!)\n // =============================\n //\n@@ -152,7 +154,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(hashmap_hasher)]\n     /// use std::collections::HashSet;\n     /// use std::collections::hash_map::RandomState;\n     ///\n@@ -161,7 +163,7 @@ impl<T, S> HashSet<T, S>\n     /// set.insert(2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n+    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\")]\n     pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n         HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n     }\n@@ -177,7 +179,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(hashmap_hasher)]\n     /// use std::collections::HashSet;\n     /// use std::collections::hash_map::RandomState;\n     ///\n@@ -186,7 +188,7 @@ impl<T, S> HashSet<T, S>\n     /// set.insert(1);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n+    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\")]\n     pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n                                         -> HashSet<T, S> {\n         HashSet {\n@@ -406,7 +408,7 @@ impl<T, S> HashSet<T, S>\n \n     /// Clears the set, returning all elements in an iterator.\n     #[inline]\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"drain\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }"}, {"sha": "365e6268b3b0de25e3d1c6d2c136dcf1baf60985", "filename": "src/libstd/collections/hash/state.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\")]\n+\n use clone::Clone;\n use default::Default;\n use hash;\n@@ -25,7 +27,6 @@ use marker;\n /// algorithm can implement the `Default` trait and create hash maps with the\n /// `DefaultState` structure. This state is 0-sized and will simply delegate\n /// to `Default` when asked to create a hasher.\n-#[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n pub trait HashState {\n     /// Type of the hasher that will be created.\n     type Hasher: hash::Hasher;\n@@ -38,7 +39,6 @@ pub trait HashState {\n /// default trait.\n ///\n /// This struct has is 0-sized and does not need construction.\n-#[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n pub struct DefaultState<H>(marker::PhantomData<H>);\n \n impl<H: Default + hash::Hasher> HashState for DefaultState<H> {"}, {"sha": "c91ebc91ef38766b1ec6c94d5dd2645910d8967e", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -410,7 +410,7 @@ pub mod hash_set {\n \n /// Experimental support for providing custom hash algorithms to a HashMap and\n /// HashSet.\n-#[unstable(feature = \"std_misc\", reason = \"module was recently added\")]\n+#[unstable(feature = \"hashmap_hasher\", reason = \"module was recently added\")]\n pub mod hash_state {\n     pub use super::hash::state::*;\n }"}, {"sha": "ddafe416305e11efc7fa44527c25cc7dcabb5961", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -12,7 +12,9 @@\n //!\n //! A simple wrapper over the platform's dynamic library facilities\n \n-#![unstable(feature = \"std_misc\")]\n+#![unstable(feature = \"dynamic_lib\",\n+            reason = \"API has not been scrutinized and is highly likely to \\\n+                      either disappear or change\")]\n #![allow(missing_docs)]\n \n use prelude::v1::*;"}, {"sha": "2e00e126e2378f8b7f9d385e4d184ad35b9d4411", "filename": "src/libstd/env.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -486,13 +486,15 @@ static EXIT_STATUS: AtomicIsize = AtomicIsize::new(0);\n ///\n /// Note that this is not synchronized against modifications of other threads.\n #[unstable(feature = \"exit_status\", reason = \"managing the exit status may change\")]\n+#[deprecated(since = \"1.2.0\", reason = \"use process::exit instead\")]\n pub fn set_exit_status(code: i32) {\n     EXIT_STATUS.store(code as isize, Ordering::SeqCst)\n }\n \n /// Fetches the process's current exit code. This defaults to 0 and can change\n /// by calling `set_exit_status`.\n #[unstable(feature = \"exit_status\", reason = \"managing the exit status may change\")]\n+#[deprecated(since = \"1.2.0\", reason = \"use process::exit instead\")]\n pub fn get_exit_status() -> i32 {\n     EXIT_STATUS.load(Ordering::SeqCst) as i32\n }"}, {"sha": "b21b2edf2ecd81fe58209160d134a869f08dcf27", "filename": "src/libstd/error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -48,7 +48,7 @@\n // reconsider what crate these items belong in.\n \n use any::TypeId;\n-use boxed::{self, Box};\n+use boxed::Box;\n use convert::From;\n use fmt::{self, Debug, Display};\n use marker::{Send, Sync, Reflect};\n@@ -77,7 +77,7 @@ pub trait Error: Debug + Display + Reflect {\n \n     /// Get the `TypeId` of `self`\n     #[doc(hidden)]\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"error_type_id\",\n                reason = \"unclear whether to commit to this public implementation detail\")]\n     fn type_id(&self) -> TypeId where Self: 'static {\n         TypeId::of::<Self>()\n@@ -140,7 +140,7 @@ impl Error for str::Utf8Error {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for num::ParseIntError {\n     fn description(&self) -> &str {\n-        self.description()\n+        self.__description()\n     }\n }\n \n@@ -249,7 +249,7 @@ impl Error {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n-                let raw = boxed::into_raw(self);\n+                let raw = Box::into_raw(self);\n                 let to: TraitObject =\n                     transmute::<*mut Error, TraitObject>(raw);\n "}, {"sha": "ffc204ada60fb92a0468654690c95afa0e51b6b3", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"std_misc\")]\n-\n use borrow::{Cow, ToOwned};\n-use boxed::{self, Box};\n+use boxed::Box;\n use clone::Clone;\n use convert::{Into, From};\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n@@ -208,6 +206,9 @@ impl CString {\n     /// `into_ptr`. The length of the string will be recalculated\n     /// using the pointer.\n     #[unstable(feature = \"cstr_memory\", reason = \"recently added\")]\n+    // NB: may want to be called from_raw, needs to consider CStr::from_ptr,\n+    //     Box::from_raw (or whatever it's currently called), and\n+    //     slice::from_raw_parts\n     pub unsafe fn from_ptr(ptr: *const libc::c_char) -> CString {\n         let len = libc::strlen(ptr) + 1; // Including the NUL byte\n         let slice = slice::from_raw_parts(ptr, len as usize);\n@@ -223,11 +224,12 @@ impl CString {\n     ///\n     /// Failure to call `from_ptr` will lead to a memory leak.\n     #[unstable(feature = \"cstr_memory\", reason = \"recently added\")]\n+    // NB: may want to be called into_raw, see comments on from_ptr\n     pub fn into_ptr(self) -> *const libc::c_char {\n         // It is important that the bytes be sized to fit - we need\n         // the capacity to be determinable from the string length, and\n         // shrinking to fit is the only way to be sure.\n-        boxed::into_raw(self.inner) as *const libc::c_char\n+        Box::into_raw(self.inner) as *const libc::c_char\n     }\n \n     /// Returns the contents of this `CString` as a slice of bytes."}, {"sha": "1d0152e275117801482c1805699de2cace64784e", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -454,13 +454,18 @@ impl<W: Read + Write> Read for InternalBufWriter<W> {\n #[unstable(feature = \"buf_stream\",\n            reason = \"unsure about semantics of buffering two directions, \\\n                      leading to issues like #17136\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"use the crates.io `bufstream` crate instead\")]\n pub struct BufStream<S: Write> {\n     inner: BufReader<InternalBufWriter<S>>\n }\n \n #[unstable(feature = \"buf_stream\",\n            reason = \"unsure about semantics of buffering two directions, \\\n                      leading to issues like #17136\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"use the crates.io `bufstream` crate instead\")]\n+#[allow(deprecated)]\n impl<S: Read + Write> BufStream<S> {\n     /// Creates a new buffered stream with explicitly listed capacities for the\n     /// reader/writer buffer.\n@@ -512,6 +517,7 @@ impl<S: Read + Write> BufStream<S> {\n #[unstable(feature = \"buf_stream\",\n            reason = \"unsure about semantics of buffering two directions, \\\n                      leading to issues like #17136\")]\n+#[allow(deprecated)]\n impl<S: Read + Write> BufRead for BufStream<S> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n     fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n@@ -520,6 +526,7 @@ impl<S: Read + Write> BufRead for BufStream<S> {\n #[unstable(feature = \"buf_stream\",\n            reason = \"unsure about semantics of buffering two directions, \\\n                      leading to issues like #17136\")]\n+#[allow(deprecated)]\n impl<S: Read + Write> Read for BufStream<S> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n@@ -529,6 +536,7 @@ impl<S: Read + Write> Read for BufStream<S> {\n #[unstable(feature = \"buf_stream\",\n            reason = \"unsure about semantics of buffering two directions, \\\n                      leading to issues like #17136\")]\n+#[allow(deprecated)]\n impl<S: Read + Write> Write for BufStream<S> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.inner.get_mut().write(buf)\n@@ -541,6 +549,7 @@ impl<S: Read + Write> Write for BufStream<S> {\n #[unstable(feature = \"buf_stream\",\n            reason = \"unsure about semantics of buffering two directions, \\\n                      leading to issues like #17136\")]\n+#[allow(deprecated)]\n impl<S: Write> fmt::Debug for BufStream<S> where S: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let reader = &self.inner;"}, {"sha": "b43ac0daf5127d800736df7f89d61839fff55dd5", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -123,7 +123,7 @@ pub enum ErrorKind {\n     Other,\n \n     /// Any I/O error not part of this list.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"io_error_internals\",\n                reason = \"better expressed through extensible enums that this \\\n                          enum cannot be exhaustively matched against\")]\n     #[doc(hidden)]"}, {"sha": "c3e309d182b9587ca34775723343fd75d3d54633", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,6 @@\n \n use prelude::v1::*;\n \n-use boxed;\n use cell::Cell;\n use rt;\n use sync::{StaticMutex, Arc};\n@@ -60,7 +59,7 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n         });\n         let ret = (self.init)();\n         if registered.is_ok() {\n-            self.ptr.set(boxed::into_raw(Box::new(ret.clone())));\n+            self.ptr.set(Box::into_raw(Box::new(ret.clone())));\n         }\n         return ret\n     }"}, {"sha": "e5242c5bf861ad03f7d63ad49b3360280fe6afa1", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -99,38 +99,62 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![doc(test(no_crate_inject, attr(deny(warnings))))]\n-#![doc(test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n+       html_playground_url = \"http://play.rust-lang.org/\",\n+       test(no_crate_inject, attr(deny(warnings))),\n+       test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n #![feature(alloc)]\n #![feature(allow_internal_unstable)]\n #![feature(associated_consts)]\n+#![feature(borrow_state)]\n+#![feature(box_raw)]\n #![feature(box_syntax)]\n+#![feature(char_internals)]\n+#![feature(clone_from_slice)]\n #![feature(collections)]\n-#![feature(core)]\n+#![feature(collections_bound)]\n #![feature(const_fn)]\n+#![feature(core)]\n+#![feature(core_float)]\n+#![feature(core_intrinsics)]\n+#![feature(core_prelude)]\n+#![feature(core_simd)]\n+#![feature(fnbox)]\n+#![feature(heap_api)]\n+#![feature(int_error_internals)]\n #![feature(into_cow)]\n+#![feature(iter_order)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(linkage, thread_local, asm)]\n #![feature(macro_reexport)]\n+#![feature(slice_concat_ext)]\n+#![feature(slice_position_elem)]\n+#![feature(no_std)]\n+#![feature(oom)]\n #![feature(optin_builtin_traits)]\n #![feature(rand)]\n+#![feature(raw)]\n+#![feature(reflect_marker)]\n+#![feature(slice_bytes)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n #![feature(str_char)]\n+#![feature(str_internals)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n+#![feature(vec_push_all)]\n+#![feature(wrapping)]\n #![feature(zero_one)]\n-#![cfg_attr(test, feature(float_from_str_radix))]\n-#![cfg_attr(test, feature(test, rustc_private, std_misc))]\n+#![cfg_attr(all(unix, not(target_os = \"macos\"), not(target_os = \"ios\")),\n+            feature(num_bits_bytes))]\n+#![cfg_attr(windows, feature(str_utf16))]\n+#![cfg_attr(test, feature(float_from_str_radix, range_inclusive, float_extras))]\n+#![cfg_attr(test, feature(test, rustc_private, float_consts))]\n \n // Don't link to std. We are std.\n-#![feature(no_std)]\n #![no_std]\n \n #![allow(trivial_casts)]"}, {"sha": "749974c7afab0f30c039a719809b6e806b18f65e", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -14,8 +14,6 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n-#![unstable(feature = \"std_misc\")]\n-\n /// The entry point for panic of Rust threads.\n ///\n /// This macro is used to inject panic into a Rust thread, causing the thread to\n@@ -165,7 +163,7 @@ macro_rules! try {\n /// # Examples\n ///\n /// ```\n-/// # #![feature(std_misc)]\n+/// # #![feature(mpsc_select)]\n /// use std::thread;\n /// use std::sync::mpsc;\n ///\n@@ -191,7 +189,7 @@ macro_rules! try {\n ///\n /// For more information about select, see the `std::sync::mpsc::Select` structure.\n #[macro_export]\n-#[unstable(feature = \"std_misc\")]\n+#[unstable(feature = \"mpsc_select\")]\n macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+"}, {"sha": "0c40f6c1fc8a8fb73a39b6ac769b66ecf1d2d103", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -194,7 +194,7 @@ impl f32 {\n     /// The floating point encoding is documented in the [Reference][floating-point].\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(float_extras)]\n     /// use std::f32;\n     ///\n     /// let num = 2.0f32;\n@@ -211,9 +211,11 @@ impl f32 {\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     /// [floating-point]: ../../../../../reference.html#machine-types\n-    #[unstable(feature = \"std_misc\", reason = \"signature is undecided\")]\n+    #[unstable(feature = \"float_extras\", reason = \"signature is undecided\")]\n     #[inline]\n-    pub fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n+    pub fn integer_decode(self) -> (u64, i16, i8) {\n+        num::Float::integer_decode(self)\n+    }\n \n     /// Returns the largest integer less than or equal to a number.\n     ///\n@@ -555,7 +557,7 @@ impl f32 {\n     /// Converts radians to degrees.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(float_extras)]\n     /// use std::f32::{self, consts};\n     ///\n     /// let angle = consts::PI;\n@@ -564,14 +566,14 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n+    #[unstable(feature = \"float_extras\", reason = \"desirability is unclear\")]\n     #[inline]\n     pub fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }\n \n     /// Converts degrees to radians.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(float_extras)]\n     /// use std::f32::{self, consts};\n     ///\n     /// let angle = 180.0f32;\n@@ -580,21 +582,21 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n+    #[unstable(feature = \"float_extras\", reason = \"desirability is unclear\")]\n     #[inline]\n     pub fn to_radians(self) -> f32 { num::Float::to_radians(self) }\n \n     /// Constructs a floating point number of `x*2^exp`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(float_extras)]\n     /// use std::f32;\n     /// // 3*2^2 - 12 == 0\n     /// let abs_difference = (f32::ldexp(3.0, 2) - 12.0).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n     pub fn ldexp(x: f32, exp: isize) -> f32 {\n@@ -608,7 +610,7 @@ impl f32 {\n     ///  * `0.5 <= abs(x) < 1.0`\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(float_extras)]\n     /// use std::f32;\n     ///\n     /// let x = 4.0f32;\n@@ -621,7 +623,7 @@ impl f32 {\n     /// assert!(abs_difference_0 <= f32::EPSILON);\n     /// assert!(abs_difference_1 <= f32::EPSILON);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n     pub fn frexp(self) -> (f32, isize) {\n@@ -636,7 +638,7 @@ impl f32 {\n     /// `other`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(float_extras)]\n     /// use std::f32;\n     ///\n     /// let x = 1.0f32;\n@@ -645,7 +647,7 @@ impl f32 {\n     ///\n     /// assert!(abs_diff <= f32::EPSILON);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"float_extras\",\n                reason = \"unsure about its place in the world\")]\n     #[inline]\n     pub fn next_after(self, other: f32) -> f32 {"}, {"sha": "41c0fcb9797a651a2fd957fd44c3a46d7f95a0ca", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -190,7 +190,7 @@ impl f64 {\n     /// The floating point encoding is documented in the [Reference][floating-point].\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(float_extras)]\n     /// let num = 2.0f64;\n     ///\n     /// // (8388608, -22, 1)\n@@ -205,7 +205,7 @@ impl f64 {\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n     /// [floating-point]: ../../../../../reference.html#machine-types\n-    #[unstable(feature = \"std_misc\", reason = \"signature is undecided\")]\n+    #[unstable(feature = \"float_extras\", reason = \"signature is undecided\")]\n     #[inline]\n     pub fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n \n@@ -567,13 +567,13 @@ impl f64 {\n     /// Constructs a floating point number of `x*2^exp`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(float_extras)]\n     /// // 3*2^2 - 12 == 0\n     /// let abs_difference = (f64::ldexp(3.0, 2) - 12.0).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n     pub fn ldexp(x: f64, exp: isize) -> f64 {\n@@ -587,7 +587,7 @@ impl f64 {\n     ///  * `0.5 <= abs(x) < 1.0`\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(float_extras)]\n     /// let x = 4.0_f64;\n     ///\n     /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n@@ -598,7 +598,7 @@ impl f64 {\n     /// assert!(abs_difference_0 < 1e-10);\n     /// assert!(abs_difference_1 < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n     pub fn frexp(self) -> (f64, isize) {\n@@ -613,15 +613,15 @@ impl f64 {\n     /// `other`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(float_extras)]\n     ///\n     /// let x = 1.0f32;\n     ///\n     /// let abs_diff = (x.next_after(2.0) - 1.00000011920928955078125_f32).abs();\n     ///\n     /// assert!(abs_diff < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"float_extras\",\n                reason = \"unsure about its place in the world\")]\n     #[inline]\n     pub fn next_after(self, other: f64) -> f64 {"}, {"sha": "16ad21a07d700acb842a19973f9ff4d3b98cb3fd", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"std_misc\")]\n #![doc(hidden)]\n \n macro_rules! assert_approx_eq {"}, {"sha": "178fad09f9881a4d4c84a0c005f4d8141b44a96e", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"std_misc\")]\n #![doc(hidden)]\n \n macro_rules! int_module { ($T:ty) => ("}, {"sha": "555a5cc3e20e9d747006a0963c6bd99944cf5679", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"std_misc\")]\n #![doc(hidden)]\n #![allow(unsigned_negation)]\n "}, {"sha": "b584658fb07e7bb9bbddcfe2dce991b4900e9b0f", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"std_misc\")]\n-\n use prelude::v1::*;\n use io::prelude::*;\n "}, {"sha": "17d2940a6f10c4ab8c2818c8b4f20d37e3b1e21e", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -16,13 +16,12 @@\n // segfaults (the queue's memory is mysteriously gone), so\n // instead the cleanup is tied to the `std::rt` entry point.\n \n-use boxed;\n+use alloc::boxed::FnBox;\n use boxed::Box;\n-use vec::Vec;\n-use thunk::Thunk;\n use sys_common::mutex::Mutex;\n+use vec::Vec;\n \n-type Queue = Vec<Thunk<'static>>;\n+type Queue = Vec<Box<FnBox()>>;\n \n // NB these are specifically not types from `std::sync` as they currently rely\n // on poisoning and this module needs to operate at a lower level than requiring\n@@ -40,7 +39,7 @@ const ITERS: usize = 10;\n unsafe fn init() -> bool {\n     if QUEUE.is_null() {\n         let state: Box<Queue> = box Vec::new();\n-        QUEUE = boxed::into_raw(state);\n+        QUEUE = Box::into_raw(state);\n     } else if QUEUE as usize == 1 {\n         // can't re-init after a cleanup\n         return false\n@@ -71,7 +70,7 @@ pub fn cleanup() {\n     }\n }\n \n-pub fn push(f: Thunk<'static>) -> bool {\n+pub fn push(f: Box<FnBox()>) -> bool {\n     let mut ret = true;\n     unsafe {\n         LOCK.lock();"}, {"sha": "1729d20da205c686d5763195b8988432f38a65ee", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -16,7 +16,9 @@\n //! and should be considered as private implementation details for the\n //! time being.\n \n-#![unstable(feature = \"std_misc\")]\n+#![unstable(feature = \"rt\",\n+            reason = \"this public module should not exist and is highly likely \\\n+                      to disappear\")]\n #![allow(missing_docs)]\n \n use prelude::v1::*;\n@@ -137,7 +139,9 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n     if failed {\n         rt::DEFAULT_ERROR_CODE\n     } else {\n-        env::get_exit_status() as isize\n+        #[allow(deprecated)]\n+        fn exit_status() -> isize { env::get_exit_status() as isize }\n+        exit_status()\n     }\n }\n "}, {"sha": "84c6d6864a9e5d592aee14b45adf29d46daa331c", "filename": "src/libstd/rt/unwind/gcc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -11,7 +11,6 @@\n use prelude::v1::*;\n \n use any::Any;\n-use boxed;\n use libc::c_void;\n use rt::libunwind as uw;\n \n@@ -29,7 +28,7 @@ pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n         },\n         cause: Some(data),\n     };\n-    let exception_param = boxed::into_raw(exception) as *mut uw::_Unwind_Exception;\n+    let exception_param = Box::into_raw(exception) as *mut uw::_Unwind_Exception;\n     let error = uw::_Unwind_RaiseException(exception_param);\n     rtabort!(\"Could not unwind stack, error = {}\", error as isize);\n "}, {"sha": "be674c83e221351903a0168741077c488cfbf946", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -12,8 +12,6 @@\n //! the standard library This varies per-platform, but these libraries are\n //! necessary for running libstd.\n \n-#![unstable(feature = \"std_misc\")]\n-\n // All platforms need to link to rustrt\n #[cfg(not(test))]\n #[link(name = \"rust_builtin\", kind = \"static\")]"}, {"sha": "28dc124f0334fca39c5cec7e1a9e6582a7a49d25", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -14,7 +14,7 @@\n //! # Examples\n //!\n //! ```\n-//! # #![feature(std_misc)]\n+//! # #![feature(future)]\n //! use std::sync::Future;\n //!\n //! // a fake, for now\n@@ -28,10 +28,15 @@\n //! ```\n \n #![allow(missing_docs)]\n-#![unstable(feature = \"std_misc\",\n+#![unstable(feature = \"future\",\n             reason = \"futures as-is have yet to be deeply reevaluated with recent \\\n                       core changes to Rust's synchronization story, and will likely \\\n                       become stable in the future but are unstable until that time\")]\n+#![deprecated(since = \"1.2.0\",\n+              reason = \"implementation does not match the quality of the \\\n+                        standard library and this will likely be prototyped \\\n+                        outside in crates.io first\")]\n+#![allow(deprecated)]\n \n use core::prelude::*;\n use core::mem::replace;"}, {"sha": "ab8d4587cfd3d7ce6174120a12a04b93c293d758", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -30,6 +30,7 @@ pub use self::rwlock::{RwLockReadGuard, RwLockWriteGuard};\n pub use self::rwlock::{RwLock, StaticRwLock, RW_LOCK_INIT};\n pub use self::semaphore::{Semaphore, SemaphoreGuard};\n \n+#[allow(deprecated)]\n pub use self::future::Future;\n \n pub mod mpsc;"}, {"sha": "d6d173e5e7e7e2ee345465a16d9e148e1e8fe166", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -35,16 +35,13 @@\n //! method, and see the method for more information about it. Due to this\n //! caveat, this queue may not be appropriate for all use-cases.\n \n-#![unstable(feature = \"std_misc\")]\n-\n // http://www.1024cores.net/home/lock-free-algorithms\n //                         /queues/non-intrusive-mpsc-node-based-queue\n \n pub use self::PopResult::*;\n \n use core::prelude::*;\n \n-use alloc::boxed;\n use alloc::boxed::Box;\n use core::ptr;\n use core::cell::UnsafeCell;\n@@ -82,7 +79,7 @@ unsafe impl<T: Send> Sync for Queue<T> { }\n \n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n-        boxed::into_raw(box Node {\n+        Box::into_raw(box Node {\n             next: AtomicPtr::new(ptr::null_mut()),\n             value: v,\n         })"}, {"sha": "a67138742aeeb9cbf6e7badb4cd106b57faeba27", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -27,7 +27,7 @@\n //! # Examples\n //!\n //! ```rust\n-//! # #![feature(std_misc)]\n+//! # #![feature(mpsc_select)]\n //! use std::sync::mpsc::channel;\n //!\n //! let (tx1, rx1) = channel();\n@@ -47,7 +47,7 @@\n //! ```\n \n #![allow(dead_code)]\n-#![unstable(feature = \"std_misc\",\n+#![unstable(feature = \"mpsc_select\",\n             reason = \"This implementation, while likely sufficient, is unsafe and \\\n                       likely to be error prone. At some point in the future this \\\n                       module will likely be replaced, and it is currently \\\n@@ -124,7 +124,7 @@ impl Select {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n+    /// # #![feature(mpsc_select)]\n     /// use std::sync::mpsc::Select;\n     ///\n     /// let select = Select::new();"}, {"sha": "3cf75de5a46ddf7e6964bb07b9da5e40b1194752", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -33,11 +33,8 @@\n //! concurrently between two threads. This data structure is safe to use and\n //! enforces the semantics that there is one pusher and one popper.\n \n-#![unstable(feature = \"std_misc\")]\n-\n use core::prelude::*;\n \n-use alloc::boxed;\n use alloc::boxed::Box;\n use core::ptr;\n use core::cell::UnsafeCell;\n@@ -80,7 +77,7 @@ unsafe impl<T: Send> Sync for Queue<T> { }\n \n impl<T> Node<T> {\n     fn new() -> *mut Node<T> {\n-        boxed::into_raw(box Node {\n+        Box::into_raw(box Node {\n             value: None,\n             next: AtomicPtr::new(ptr::null_mut::<Node<T>>()),\n         })"}, {"sha": "41cd11e4c6900ea88790abca9c4ba8b44d49562f", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -85,7 +85,6 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n /// To recover from a poisoned mutex:\n ///\n /// ```\n-/// # #![feature(std_misc)]\n /// use std::sync::{Arc, Mutex};\n /// use std::thread;\n ///\n@@ -139,7 +138,7 @@ unsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }\n /// # Examples\n ///\n /// ```\n-/// # #![feature(std_misc)]\n+/// # #![feature(static_mutex)]\n /// use std::sync::{StaticMutex, MUTEX_INIT};\n ///\n /// static LOCK: StaticMutex = MUTEX_INIT;\n@@ -150,7 +149,7 @@ unsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }\n /// }\n /// // lock is unlocked here.\n /// ```\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"static_mutex\",\n            reason = \"may be merged with Mutex in the future\")]\n pub struct StaticMutex {\n     lock: sys::Mutex,\n@@ -176,7 +175,7 @@ impl<'a, T: ?Sized> !marker::Send for MutexGuard<'a, T> {}\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"static_mutex\",\n            reason = \"may be merged with Mutex in the future\")]\n pub const MUTEX_INIT: StaticMutex = StaticMutex::new();\n \n@@ -237,7 +236,7 @@ impl<T: ?Sized> Mutex<T> {\n     /// time.  You should not trust a `false` value for program correctness\n     /// without additional synchronization.\n     #[inline]\n-    #[unstable(feature = \"std_misc\")]\n+    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n         self.inner.poison.get()\n     }\n@@ -270,10 +269,10 @@ struct Dummy(UnsafeCell<()>);\n unsafe impl Sync for Dummy {}\n static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n \n+#[unstable(feature = \"static_mutex\",\n+           reason = \"may be merged with Mutex in the future\")]\n impl StaticMutex {\n     /// Creates a new mutex in an unlocked state ready for use.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may be merged with Mutex in the future\")]\n     pub const fn new() -> StaticMutex {\n         StaticMutex {\n             lock: sys::Mutex::new(),\n@@ -283,17 +282,13 @@ impl StaticMutex {\n \n     /// Acquires this lock, see `Mutex::lock`\n     #[inline]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may be merged with Mutex in the future\")]\n     pub fn lock(&'static self) -> LockResult<MutexGuard<()>> {\n         unsafe { self.lock.lock() }\n         MutexGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempts to grab this lock, see `Mutex::try_lock`\n     #[inline]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may be merged with Mutex in the future\")]\n     pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n         if unsafe { self.lock.try_lock() } {\n             Ok(try!(MutexGuard::new(self, &DUMMY.0)))\n@@ -312,8 +307,6 @@ impl StaticMutex {\n     /// *all* platforms. It may be the case that some platforms do not leak\n     /// memory if this method is not called, but this is not guaranteed to be\n     /// true on all platforms.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may be merged with Mutex in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }"}, {"sha": "0bda6a975a2445a95ea64ced9254297812f166b0", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -48,7 +48,7 @@ pub const ONCE_INIT: Once = Once::new();\n \n impl Once {\n     /// Creates a new `Once` value.\n-    #[unstable(feature = \"std_misc\")]\n+    #[stable(feature = \"once_new\", since = \"1.2.0\")]\n     pub const fn new() -> Once {\n         Once {\n             mutex: StaticMutex::new(),"}, {"sha": "4ca2e282f707dc1d7429ef32e5a254c1708d5950", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -81,7 +81,7 @@ unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n /// # Examples\n ///\n /// ```\n-/// # #![feature(std_misc)]\n+/// # #![feature(static_rwlock)]\n /// use std::sync::{StaticRwLock, RW_LOCK_INIT};\n ///\n /// static LOCK: StaticRwLock = RW_LOCK_INIT;\n@@ -96,15 +96,15 @@ unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n /// }\n /// unsafe { LOCK.destroy() } // free all resources\n /// ```\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"static_rwlock\",\n            reason = \"may be merged with RwLock in the future\")]\n pub struct StaticRwLock {\n     lock: sys::RWLock,\n     poison: poison::Flag,\n }\n \n /// Constant initialization for a statically-initialized rwlock.\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"static_rwlock\",\n            reason = \"may be merged with RwLock in the future\")]\n pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock::new();\n \n@@ -253,7 +253,7 @@ impl<T: ?Sized> RwLock<T> {\n     /// time.  You should not trust a `false` value for program correctness\n     /// without additional synchronization.\n     #[inline]\n-    #[unstable(feature = \"std_misc\")]\n+    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n         self.inner.poison.get()\n     }\n@@ -283,10 +283,10 @@ struct Dummy(UnsafeCell<()>);\n unsafe impl Sync for Dummy {}\n static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n \n+#[unstable(feature = \"static_rwlock\",\n+           reason = \"may be merged with RwLock in the future\")]\n impl StaticRwLock {\n     /// Creates a new rwlock.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may be merged with RwLock in the future\")]\n     pub const fn new() -> StaticRwLock {\n         StaticRwLock {\n             lock: sys::RWLock::new(),\n@@ -299,8 +299,6 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::read`.\n     #[inline]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may be merged with RwLock in the future\")]\n     pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> {\n         unsafe { self.lock.read() }\n         RwLockReadGuard::new(self, &DUMMY.0)\n@@ -310,8 +308,6 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::try_read`.\n     #[inline]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may be merged with RwLock in the future\")]\n     pub fn try_read(&'static self)\n                     -> TryLockResult<RwLockReadGuard<'static, ()>> {\n         if unsafe { self.lock.try_read() } {\n@@ -326,8 +322,6 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::write`.\n     #[inline]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may be merged with RwLock in the future\")]\n     pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> {\n         unsafe { self.lock.write() }\n         RwLockWriteGuard::new(self, &DUMMY.0)\n@@ -337,8 +331,6 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::try_write`.\n     #[inline]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may be merged with RwLock in the future\")]\n     pub fn try_write(&'static self)\n                      -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n         if unsafe { self.lock.try_write() } {\n@@ -354,8 +346,6 @@ impl StaticRwLock {\n     /// active users of the lock, and this also doesn't prevent any future users\n     /// of this lock. This method is required to be called to not leak memory on\n     /// all platforms.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may be merged with RwLock in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }"}, {"sha": "dc9e467a8b1352524e06dac7fc3bb2589e5d55bf", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"std_misc\",\n+#![unstable(feature = \"semaphore\",\n             reason = \"the interaction between semaphores and the acquisition/release \\\n                       of resources is currently unclear\")]\n \n@@ -25,7 +25,7 @@ use sync::{Mutex, Condvar};\n /// # Examples\n ///\n /// ```\n-/// # #![feature(std_misc)]\n+/// # #![feature(semaphore)]\n /// use std::sync::Semaphore;\n ///\n /// // Create a semaphore that represents 5 resources"}, {"sha": "065b1d6c9acfc1b40bdd382a20e5eee214c10cfc", "filename": "src/libstd/sys/common/poison.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -120,24 +120,24 @@ impl<T: Send + Reflect> Error for PoisonError<T> {\n \n impl<T> PoisonError<T> {\n     /// Creates a `PoisonError`.\n-    #[unstable(feature = \"std_misc\")]\n+    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn new(guard: T) -> PoisonError<T> {\n         PoisonError { guard: guard }\n     }\n \n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n-    #[unstable(feature = \"std_misc\")]\n+    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn into_inner(self) -> T { self.guard }\n \n     /// Reaches into this error indicating that a lock is poisoned, returning a\n     /// reference to the underlying guard to allow access regardless.\n-    #[unstable(feature = \"std_misc\")]\n+    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn get_ref(&self) -> &T { &self.guard }\n \n     /// Reaches into this error indicating that a lock is poisoned, returning a\n     /// mutable reference to the underlying guard to allow access regardless.\n-    #[unstable(feature = \"std_misc\")]\n+    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn get_mut(&mut self) -> &mut T { &mut self.guard }\n }\n "}, {"sha": "8ea673d2162d13322777c8556e66405b698cf8ed", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -28,7 +28,7 @@\n use core::prelude::*;\n \n use core::char::{encode_utf8_raw, encode_utf16_raw};\n-use core::str::{char_range_at_raw, next_code_point};\n+use core::str::next_code_point;\n \n use ascii::*;\n use borrow::Cow;\n@@ -480,31 +480,6 @@ impl Wtf8 {\n         }\n     }\n \n-    /// Returns the code point at `position`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `position` is not at a code point boundary,\n-    /// or is beyond the end of the string.\n-    #[inline]\n-    pub fn code_point_at(&self, position: usize) -> CodePoint {\n-        let (code_point, _) = self.code_point_range_at(position);\n-        code_point\n-    }\n-\n-    /// Returns the code point at `position`\n-    /// and the position of the next code point.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `position` is not at a code point boundary,\n-    /// or is beyond the end of the string.\n-    #[inline]\n-    pub fn code_point_range_at(&self, position: usize) -> (CodePoint, usize) {\n-        let (c, n) = char_range_at_raw(&self.bytes, position);\n-        (CodePoint { value: c }, n)\n-    }\n-\n     /// Returns an iterator for the string\u2019s code points.\n     #[inline]\n     pub fn code_points(&self) -> Wtf8CodePoints {\n@@ -1173,30 +1148,6 @@ mod tests {\n         assert_eq!(slice.ascii_byte_at(4), b'\\xFF');\n     }\n \n-    #[test]\n-    fn wtf8_code_point_at() {\n-        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n-        string.push(CodePoint::from_u32(0xD83D).unwrap());\n-        string.push_char('\ud83d\udca9');\n-        assert_eq!(string.code_point_at(0), CodePoint::from_char('a'));\n-        assert_eq!(string.code_point_at(1), CodePoint::from_char('\u00e9'));\n-        assert_eq!(string.code_point_at(3), CodePoint::from_char(' '));\n-        assert_eq!(string.code_point_at(4), CodePoint::from_u32(0xD83D).unwrap());\n-        assert_eq!(string.code_point_at(7), CodePoint::from_char('\ud83d\udca9'));\n-    }\n-\n-    #[test]\n-    fn wtf8_code_point_range_at() {\n-        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n-        string.push(CodePoint::from_u32(0xD83D).unwrap());\n-        string.push_char('\ud83d\udca9');\n-        assert_eq!(string.code_point_range_at(0), (CodePoint::from_char('a'), 1));\n-        assert_eq!(string.code_point_range_at(1), (CodePoint::from_char('\u00e9'), 3));\n-        assert_eq!(string.code_point_range_at(3), (CodePoint::from_char(' '), 4));\n-        assert_eq!(string.code_point_range_at(4), (CodePoint::from_u32(0xD83D).unwrap(), 7));\n-        assert_eq!(string.code_point_range_at(7), (CodePoint::from_char('\ud83d\udca9'), 11));\n-    }\n-\n     #[test]\n     fn wtf8_code_points() {\n         fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }"}, {"sha": "5002de559884d0f52773fd9fa75f914e9a2b0e76", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -12,7 +12,6 @@ use prelude::v1::*;\n \n use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n \n-use boxed;\n use ptr;\n use rt;\n use sys_common::mutex::Mutex;\n@@ -143,7 +142,7 @@ unsafe fn init_dtors() {\n         DTOR_LOCK.unlock();\n     });\n     if res.is_ok() {\n-        DTORS = boxed::into_raw(dtors);\n+        DTORS = Box::into_raw(dtors);\n     } else {\n         DTORS = 1 as *mut _;\n     }"}, {"sha": "60563340d10210c372210ad6fae89836648b9ce4", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -154,7 +154,7 @@ macro_rules! __thread_local_inner {\n }\n \n /// Indicator of the state of a thread local storage key.\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"thread_local_state\",\n            reason = \"state querying was recently added\")]\n #[derive(Eq, PartialEq, Copy, Clone)]\n pub enum LocalKeyState {\n@@ -249,7 +249,7 @@ impl<T: 'static> LocalKey<T> {\n     /// initialization does not panic. Keys in the `Valid` state are guaranteed\n     /// to be able to be accessed. Keys in the `Destroyed` state will panic on\n     /// any call to `with`.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"thread_local_state\",\n                reason = \"state querying was recently added\")]\n     pub fn state(&'static self) -> LocalKeyState {\n         unsafe {\n@@ -326,7 +326,6 @@ mod imp {\n     // Due to rust-lang/rust#18804, make sure this is not generic!\n     #[cfg(target_os = \"linux\")]\n     unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        use boxed;\n         use mem;\n         use ptr;\n         use libc;\n@@ -360,7 +359,7 @@ mod imp {\n         type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n         if DTORS.get().is_null() {\n             let v: Box<List> = box Vec::new();\n-            DTORS.set(boxed::into_raw(v) as *mut u8);\n+            DTORS.set(Box::into_raw(v) as *mut u8);\n         }\n         let list: &mut List = &mut *(DTORS.get() as *mut List);\n         list.push((t, dtor));\n@@ -406,7 +405,6 @@ mod imp {\n mod imp {\n     use prelude::v1::*;\n \n-    use alloc::boxed;\n     use cell::{Cell, UnsafeCell};\n     use marker;\n     use ptr;\n@@ -448,7 +446,7 @@ mod imp {\n                 key: self,\n                 value: UnsafeCell::new(None),\n             };\n-            let ptr = boxed::into_raw(ptr);\n+            let ptr = Box::into_raw(ptr);\n             self.os.set(ptr as *mut u8);\n             Some(&(*ptr).value)\n         }"}, {"sha": "dbb7d3233bc39a95086ee4f5048461123af725d1", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -297,6 +297,9 @@ impl Builder {\n     /// the OS level.\n     #[unstable(feature = \"scoped\",\n                reason = \"memory unsafe if destructor is avoided, see #24292\")]\n+    #[deprecated(since = \"1.2.0\",\n+                 reason = \"this unsafe API is unlikely to ever be stabilized \\\n+                           in this form\")]\n     pub fn scoped<'a, T, F>(self, f: F) -> io::Result<JoinGuard<'a, T>> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n@@ -398,6 +401,10 @@ pub fn spawn<F, T>(f: F) -> JoinHandle<T> where\n /// to recover from such errors.\n #[unstable(feature = \"scoped\",\n            reason = \"memory unsafe if destructor is avoided, see #24292\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"this unsafe API is unlikely to ever be stabilized \\\n+                       in this form\")]\n+#[allow(deprecated)]\n pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n     T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n {"}, {"sha": "f1dc91f135fe5a60060faeaa116504c2100ec58a", "filename": "src/libstd/thunk.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,8 @@\n \n // Because this module is temporary...\n #![allow(missing_docs)]\n-#![unstable(feature = \"std_misc\")]\n+#![unstable(feature = \"thunk\")]\n+#![deprecated(since = \"1.2.0\", reason = \"use FnBox instead\")]\n \n use alloc::boxed::{Box, FnBox};\n use core::marker::Send;"}, {"sha": "7333265bdd41246bc0ea2afbe2385814d2e081a2", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -26,14 +26,17 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(associated_consts)]\n-#![feature(collections)]\n-#![feature(collections_drain)]\n-#![feature(core)]\n+#![feature(bitset)]\n+#![feature(drain)]\n+#![feature(filling_drop)]\n #![feature(libc)]\n+#![feature(ref_slice)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(str_char)]\n+#![feature(str_escape)]\n #![feature(unicode)]\n+#![feature(vec_push_all)]\n \n extern crate fmt_macros;\n extern crate serialize;"}, {"sha": "5131e0b34e380ebf84e378ab443333a397f4ae82", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -56,12 +56,12 @@\n #![deny(missing_docs)]\n \n #![feature(box_syntax)]\n-#![feature(collections)]\n+#![feature(owned_ascii_ext)]\n+#![feature(path_ext)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n #![feature(str_char)]\n-#![feature(path_ext)]\n+#![feature(vec_push_all)]\n #![cfg_attr(windows, feature(libc))]\n \n #[macro_use] extern crate log;"}, {"sha": "0a3c350086cdd125e3271d7edf77a132afdcbb9d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -36,15 +36,16 @@\n \n #![feature(asm)]\n #![feature(box_syntax)]\n-#![feature(collections)]\n-#![feature(core)]\n-#![feature(rustc_private)]\n-#![feature(staged_api)]\n-#![feature(std_misc)]\n-#![feature(libc)]\n-#![feature(set_stdio)]\n #![feature(duration)]\n #![feature(duration_span)]\n+#![feature(fnbox)]\n+#![feature(iter_cmp)]\n+#![feature(libc)]\n+#![feature(rt)]\n+#![feature(rustc_private)]\n+#![feature(set_stdio)]\n+#![feature(slice_extras)]\n+#![feature(staged_api)]\n \n extern crate getopts;\n extern crate serialize;\n@@ -80,7 +81,6 @@ use std::path::PathBuf;\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n use std::thread;\n-use std::thunk::Thunk;\n use std::time::Duration;\n \n // to be used by rustc to compile tests in libtest\n@@ -153,7 +153,7 @@ pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut Bencher)),\n     StaticMetricFn(fn(&mut MetricMap)),\n-    DynTestFn(Thunk<'static>),\n+    DynTestFn(Box<FnBox() + Send>),\n     DynMetricFn(Box<FnBox(&mut MetricMap)+Send>),\n     DynBenchFn(Box<TDynBenchFn+'static>)\n }\n@@ -959,7 +959,7 @@ pub fn run_test(opts: &TestOpts,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: Sender<MonitorMsg>,\n                       nocapture: bool,\n-                      testfn: Thunk<'static>) {\n+                      testfn: Box<FnBox() + Send>) {\n         struct Sink(Arc<Mutex<Vec<u8>>>);\n         impl Write for Sink {\n             fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n@@ -1227,7 +1227,6 @@ mod tests {\n                TestDesc, TestDescAndFn, TestOpts, run_test,\n                MetricMap,\n                StaticTestName, DynTestName, DynTestFn, ShouldPanic};\n-    use std::thunk::Thunk;\n     use std::sync::mpsc::channel;\n \n     #[test]"}, {"sha": "acb1c5cbd90baabdc08ee46381cbd771719e57d5", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,17 +10,18 @@\n \n #![deny(warnings)]\n \n-#![feature(core)]\n-#![feature(exit_status)]\n-#![feature(rustdoc)]\n-#![feature(rustc_private)]\n+#![feature(iter_arith)]\n #![feature(path_relative_from)]\n+#![feature(rustc_private)]\n+#![feature(rustdoc)]\n \n extern crate rustdoc;\n extern crate rustc_back;\n \n use std::env;\n use std::error::Error;\n+use std::process;\n+use std::sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n use subcommand::Subcommand;\n use term::Term;\n \n@@ -37,6 +38,8 @@ mod test;\n mod css;\n mod javascript;\n \n+static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n+\n #[cfg(not(test))] // thanks #12327\n fn main() {\n     let mut term = Term::new();\n@@ -70,4 +73,5 @@ fn main() {\n             }\n         }\n     }\n+    process::exit(EXIT_STATUS.load(Ordering::SeqCst) as i32);\n }"}, {"sha": "cdd25e67c8ff13274da1928c75296862c8c958af", "filename": "src/rustbook/term.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Frustbook%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Frustbook%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fterm.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -11,9 +11,9 @@\n //! An abstraction of the terminal. Eventually, provide color and\n //! verbosity support. For now, just a wrapper around stdout/stderr.\n \n-use std::env;\n use std::io;\n use std::io::prelude::*;\n+use std::sync::atomic::Ordering;\n \n pub struct Term {\n     err: Box<Write + 'static>\n@@ -29,6 +29,6 @@ impl Term {\n     pub fn err(&mut self, msg: &str) {\n         // swallow any errors\n         let _ = writeln!(&mut self.err, \"{}\", msg);\n-        env::set_exit_status(101);\n+        ::EXIT_STATUS.store(101, Ordering::SeqCst);\n     }\n }"}, {"sha": "ce3360787136a099ed5a38adcb0544323bf8ffc8", "filename": "src/test/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_misc)]\n+#![feature(dynamic_lib)]\n \n // We're testing linkage visibility; the compiler warns us, but we want to\n // do the runtime check that these functions aren't exported."}, {"sha": "d2537e09901cb90c876b7bef9610435a30f4c566", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -11,6 +11,7 @@\n // ignore-pretty very bad with line comments\n \n #![feature(unboxed_closures, rand, std_misc, collections, duration, duration_span)]\n+#![feature(bitset)]\n \n extern crate collections;\n extern crate rand;"}, {"sha": "3cc03f5218cebeaf237ff92b4fc18de2bdb07ce1", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,7 @@\n \n // Microbenchmarks for various functions in std and extra\n \n-#![feature(rand, collections, std_misc, duration, duration_span)]\n+#![feature(rand, vec_push_all, duration, duration_span)]\n \n use std::iter::repeat;\n use std::mem::swap;"}, {"sha": "24ecaf4b0247145e121df407af89471fb685e543", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -17,7 +17,7 @@\n \n // no-pretty-expanded FIXME #15189\n \n-#![feature(duration, duration_span, std_misc)]\n+#![feature(duration, duration_span, future)]\n \n use std::env;\n use std::sync::{Arc, Future, Mutex, Condvar};"}, {"sha": "8ae07558c168fb34aa172d1d92a2418b72c42cf3", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -40,7 +40,7 @@\n \n // ignore-android: FIXME(#10393) hangs without output\n \n-#![feature(box_syntax, std_misc, collections)]\n+#![feature(box_syntax, owned_ascii_ext, vec_push_all)]\n \n use std::ascii::OwnedAsciiExt;\n use std::env;"}, {"sha": "232d6b414f580cb4b973388793e13a5551ee94da", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -38,7 +38,7 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(simd, core)]\n+#![feature(core_simd, core)]\n \n // ignore-pretty very bad with line comments\n "}, {"sha": "aa40f6f868c305b37f2b96e94dd58b78e7129449", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -40,7 +40,7 @@\n \n // no-pretty-expanded FIXME #15189\n \n-#![feature(core)]\n+#![feature(iter_cmp)]\n \n use std::iter::repeat;\n use std::sync::Arc;"}, {"sha": "1598b20922338bb07a0f36da9c1e0e6ea319101b", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -41,14 +41,11 @@\n // no-pretty-expanded FIXME #15189\n \n #![allow(non_snake_case)]\n-#![feature(unboxed_closures, core, os, scoped)]\n+#![feature(unboxed_closures, iter_arith, core_simd, scoped)]\n \n use std::iter::repeat;\n use std::thread;\n-use std::mem;\n-use std::os;\n use std::env;\n-use std::raw::Repr;\n use std::simd::f64x2;\n \n fn main() {"}, {"sha": "6a39a6db0c7284769937e2e07c19db7d8600d916", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,7 @@\n \n // Microbenchmark for the smallintmap library\n \n-#![feature(collections, duration, duration_span)]\n+#![feature(vecmap, duration, duration_span)]\n \n use std::collections::VecMap;\n use std::env;"}, {"sha": "3bd7b7812511200a53275609ea23cdfe92ada2bb", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax, duration, duration_span, collections)]\n+#![feature(box_syntax, duration, duration_span, vec_push_all)]\n \n use std::env;\n use std::thread;"}, {"sha": "32c50b1b8c159b732b56ef4c5472d2785c5686e2", "filename": "src/test/compile-fail/feature-gate-simd-ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(simd, core)]\n+#![feature(simd, core_simd)]\n #![allow(dead_code)]\n \n use std::simd::f32x4;"}, {"sha": "529113ace4ef9f7933b882c45a5b155843a2541d", "filename": "src/test/compile-fail/lint-dead-code-4.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -11,15 +11,10 @@\n #![allow(unused_variables)]\n #![allow(non_camel_case_types)]\n #![deny(dead_code)]\n-#![feature(libc)]\n-#![feature(core)]\n-\n-extern crate libc;\n \n struct Foo {\n     x: usize,\n     b: bool, //~ ERROR: struct field is never used\n-    marker: std::marker::NoCopy\n }\n \n fn field_read(f: Foo) -> usize {\n@@ -50,7 +45,7 @@ struct Bar {\n \n #[repr(C)]\n struct Baz {\n-    x: libc::c_uint\n+    x: u32,\n }\n \n fn field_match_in_let(f: Bar) -> bool {\n@@ -59,7 +54,7 @@ fn field_match_in_let(f: Bar) -> bool {\n }\n \n fn main() {\n-    field_read(Foo { x: 1, b: false, marker: std::marker::NoCopy });\n+    field_read(Foo { x: 1, b: false });\n     field_match_in_patterns(XYZ::Z);\n     field_match_in_let(Bar { x: 42, b: true, _guard: () });\n     let _ = Baz { x: 0 };"}, {"sha": "5867bc2f09deb273967b0c986178d108acfb0bf2", "filename": "src/test/compile-fail/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -12,7 +12,7 @@\n #![deny(exceeding_bitshifts)]\n #![allow(unused_variables)]\n #![allow(dead_code)]\n-#![feature(core, negate_unsigned)]\n+#![feature(num_bits_bytes, negate_unsigned)]\n \n fn main() {\n       let n = 1u8 << 7;"}, {"sha": "ec5a6fa3d3f16e0dc0e6e9d04ac84e14faa5fb0f", "filename": "src/test/debuginfo/constant-debug-locs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -14,8 +14,8 @@\n \n #![allow(dead_code, unused_variables)]\n #![omit_gdb_pretty_printer_section]\n-#![feature(std_misc, core)]\n #![feature(const_fn)]\n+#![feature(static_mutex)]\n \n // This test makes sure that the compiler doesn't crash when trying to assign\n // debug locations to const-expressions."}, {"sha": "6bc8892a83a6939cc497505522f720a978106f3b", "filename": "src/test/debuginfo/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimd.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -42,7 +42,7 @@\n \n #![allow(unused_variables)]\n #![omit_gdb_pretty_printer_section]\n-#![feature(core)]\n+#![feature(core_simd)]\n \n use std::simd::{i8x16, i16x8,i32x4,i64x2,u8x16,u16x8,u32x4,u64x2,f32x4,f64x2};\n "}, {"sha": "b53a870e2001cb0129151fa59b4c6a07209fd608", "filename": "src/test/run-make/extern-fn-reachable/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_misc)]\n+#![feature(dynamic_lib)]\n \n use std::dynamic_lib::DynamicLibrary;\n use std::path::Path;"}, {"sha": "f58d2cd8f91d8d84d2d0ab95f65c87caa6380835", "filename": "src/test/run-make/intrinsic-unreachable/exit-unreachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-make%2Fintrinsic-unreachable%2Fexit-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-make%2Fintrinsic-unreachable%2Fexit-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fintrinsic-unreachable%2Fexit-unreachable.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(asm, core)]\n+#![feature(asm, core_intrinsics)]\n #![crate_type=\"lib\"]\n \n use std::intrinsics;"}, {"sha": "6c6afdc13030ca19dfe596927992ae3cac2d7975", "filename": "src/test/run-make/volatile-intrinsics/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-make%2Fvolatile-intrinsics%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-make%2Fvolatile-intrinsics%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fvolatile-intrinsics%2Fmain.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n+#![feature(core_intrinsics)]\n \n use std::intrinsics::{volatile_load, volatile_store};\n "}, {"sha": "61a7fab130928493054a016d8c3414206ed8fa14", "filename": "src/test/run-pass/binary-heap-panic-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_misc, collections, catch_panic, rand)]\n+#![feature(std_misc, collections, catch_panic, rand, sync_poison)]\n \n use std::__rand::{thread_rng, Rng};\n use std::thread;"}, {"sha": "3ab154356c4b6c23e5c6b52f3ca2a4b2120cb8e4", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,16 +10,14 @@\n \n // pretty-expanded FIXME #23616\n \n-#![allow(unknown_features)]\n-#![feature(box_syntax, collections)]\n+#![feature(bitvec)]\n \n-extern crate collections;\n use std::collections::BitVec;\n \n fn bitv_test() {\n-    let mut v1: Box<_> = box BitVec::from_elem(31, false);\n-    let v2: Box<_> = box BitVec::from_elem(31, true);\n-    v1.union(&*v2);\n+    let mut v1 = BitVec::from_elem(31, false);\n+    let v2 = BitVec::from_elem(31, true);\n+    v1.union(&v2);\n }\n \n pub fn main() {"}, {"sha": "ba1d8228863ad6562a682ad5efbb902b1184622a", "filename": "src/test/run-pass/deriving-hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-hash.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-#![feature(hash)]\n+#![feature(hash_default)]\n \n use std::hash::{Hash, SipHasher};\n "}, {"sha": "13257529ed9f860eaaae4d975ef1b7f552f492f2", "filename": "src/test/run-pass/discriminant_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fdiscriminant_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fdiscriminant_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiscriminant_value.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n+#![feature(core, core_intrinsics)]\n \n extern crate core;\n use core::intrinsics::discriminant_value;"}, {"sha": "6eb01e879df5735ec133e763a04e7b0c3c20f3af", "filename": "src/test/run-pass/dst-coerce-custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fdst-coerce-custom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fdst-coerce-custom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-coerce-custom.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,7 @@\n \n // Test a very simple custom DST coercion.\n \n-#![feature(core)]\n+#![feature(unsize, coerce_unsized)]\n \n use std::ops::CoerceUnsized;\n use std::marker::Unsize;"}, {"sha": "dd88dc11ea70e47a11dd25b8c11970f4716cac23", "filename": "src/test/run-pass/enum-null-pointer-opt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(core)]\n+#![feature(nonzero, core)]\n \n extern crate core;\n "}, {"sha": "58296c3f95ef923be7397c58f13bdc35b91e4172", "filename": "src/test/run-pass/fat-ptr-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n+#![feature(raw)]\n \n use std::mem;\n use std::raw;"}, {"sha": "a1bd77a74f725593f790465714c52d9f81765341", "filename": "src/test/run-pass/for-loop-no-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Ffor-loop-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Ffor-loop-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-no-std.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(lang_items, start, no_std, core, collections)]\n+#![feature(lang_items, start, no_std, core_slice_ext, core, collections)]\n #![no_std]\n \n extern crate std as other;"}, {"sha": "1452cefbd5c2ba18e70435025232ac4417504df5", "filename": "src/test/run-pass/format-no-std.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fformat-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fformat-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fformat-no-std.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![feature(lang_items, start, no_std, core, collections)]\n #![no_std]\n "}, {"sha": "7ec18ef127690645382d8983f062ec8a6bf6c171", "filename": "src/test/run-pass/into-iterator-type-inference-shift.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Finto-iterator-type-inference-shift.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Finto-iterator-type-inference-shift.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finto-iterator-type-inference-shift.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -15,10 +15,6 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-use std::u8;\n-\n trait IntoIterator {\n     type Iter: Iterator;\n \n@@ -35,7 +31,7 @@ impl<I> IntoIterator for I where I: Iterator {\n \n fn desugared_for_loop_bad(byte: u8) -> u8 {\n     let mut result = 0;\n-    let mut x = IntoIterator::into_iter(0..u8::BITS);\n+    let mut x = IntoIterator::into_iter(0..8);\n     let mut y = Iterator::next(&mut x);\n     let mut z = y.unwrap();\n     byte >> z;"}, {"sha": "41ef62b0ced3d7e24285e50513ca44ce0bf06b26", "filename": "src/test/run-pass/intrinsic-assume.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fintrinsic-assume.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fintrinsic-assume.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-assume.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(core)]\n+#![feature(core_intrinsics)]\n \n use std::intrinsics::assume;\n "}, {"sha": "9fd4f2133b70d36287f9b7cd02010fbb2ad0beca", "filename": "src/test/run-pass/intrinsic-move-val-cleanups.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fintrinsic-move-val-cleanups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fintrinsic-move-val-cleanups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val-cleanups.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -18,7 +18,7 @@\n // introduce temporaries that require cleanup, and SOURCE panics, then\n // make sure the cleanups still occur.\n \n-#![feature(core, std_misc)]\n+#![feature(core_intrinsics, sync_poison)]\n \n use std::cell::RefCell;\n use std::intrinsics;"}, {"sha": "0ce446e445c73d9565c000f90a6013739e3630ea", "filename": "src/test/run-pass/intrinsic-unreachable.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fintrinsic-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fintrinsic-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-unreachable.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(core)]\n+#![feature(core_intrinsics)]\n \n use std::intrinsics;\n "}, {"sha": "3eaa5632395b72ea8c32ef59d89c153ba94433f6", "filename": "src/test/run-pass/issue-11709.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-11709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-11709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11709.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -15,7 +15,7 @@\n // when this bug was opened. The cases where the compiler\n // panics before the fix have a comment.\n \n-#![feature(std_misc)]\n+#![feature(thunk)]\n \n use std::thunk::Thunk;\n "}, {"sha": "9b30305a1969de924c287b97475e94bdbb32f616", "filename": "src/test/run-pass/issue-11736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11736.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(collections)]\n+#![feature(bitvec)]\n \n use std::collections::BitVec;\n "}, {"sha": "05de69cb966ad6590962c723b26db607b0ee6f77", "filename": "src/test/run-pass/issue-11958.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-11958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-11958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11958.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,19 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![forbid(warnings)]\n-#![feature(std_misc)]\n-\n-// Pretty printing tests complain about `use std::predule::*`\n-#![allow(unused_imports)]\n \n // We shouldn't need to rebind a moved upvar as mut if it's already\n // marked as mut\n \n-use std::thunk::Thunk;\n-\n pub fn main() {\n     let mut x = 1;\n     let _thunk = Box::new(move|| { x = 2; });"}, {"sha": "2e03a9a7244202b118f00158df8a5dc464e6e06d", "filename": "src/test/run-pass/issue-13259-windows-tcb-trash.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![feature(libc, std_misc)]\n \n extern crate libc;"}, {"sha": "e94368925abee2b261c0d6d0ac9cc104e59cb54b", "filename": "src/test/run-pass/issue-13494.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13494.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -11,9 +11,7 @@\n // This test may not always fail, but it can be flaky if the race it used to\n // expose is still present.\n \n-// pretty-expanded FIXME #23616\n-\n-#![feature(std_misc)]\n+#![feature(mpsc_select)]\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::thread;"}, {"sha": "0ea38596335d8c8f0deb9e85011a23ea4a1b2d52", "filename": "src/test/run-pass/issue-13763.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13763.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n+#![feature(num_bits_bytes)]\n \n use std::u8;\n "}, {"sha": "ff9a17323e43322aa2e2875e5d07fb8a1979d227", "filename": "src/test/run-pass/issue-15673.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-15673.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-15673.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15673.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(core)]\n+#![feature(iter_arith)]\n \n fn main() {\n     let x: [u64; 3] = [1, 2, 3];"}, {"sha": "1f96f071e9d111ea3ce2389296503ddd1ea18c6a", "filename": "src/test/run-pass/issue-16530.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-16530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-16530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16530.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(hash)]\n+#![feature(hash_default)]\n \n use std::hash::{SipHasher, hash};\n "}, {"sha": "227c81e2766fdccc6e3347a591c2a387c90ef444", "filename": "src/test/run-pass/issue-17897.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-17897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-17897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17897.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures, std_misc)]\n+#![feature(thunk)]\n \n use std::thunk::Thunk;\n "}, {"sha": "5bcb052282c19b8257ea47fc37adccd387a589e4", "filename": "src/test/run-pass/issue-18188.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-18188.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-18188.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18188.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(unboxed_closures, std_misc)]\n+#![feature(thunk)]\n \n use std::thunk::Thunk;\n "}, {"sha": "9e8bfc884c984ecd9582eb92b3338e318c2ff8c5", "filename": "src/test/run-pass/issue-21058.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21058.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(core)]\n+#![feature(core_intrinsics)]\n \n struct NT(str);\n struct DST { a: u32, b: str }"}, {"sha": "eeca4498328d36bbba7c6df54eec275dc999afa8", "filename": "src/test/run-pass/issue-2190-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(std_misc)]\n+#![feature(thunk)]\n \n use std::thread::Builder;\n use std::thunk::Thunk;"}, {"sha": "a8abbda32bdfc23a24915783aa2088c6212a04c7", "filename": "src/test/run-pass/issue-23037.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-23037.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-23037.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23037.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n+#![feature(core_simd)]\n \n use std::simd::i32x4;\n fn main() {"}, {"sha": "4b6d593f592d970b812bc0ca043e17ebd50849f4", "filename": "src/test/run-pass/issue-23550.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-23550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-23550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23550.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n+#![feature(core_intrinsics)]\n #![allow(warnings)]\n \n use std::intrinsics;"}, {"sha": "8ea0804af18bf5499cf3bb4c11df8dbddb3c8c65", "filename": "src/test/run-pass/issue-6898.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-6898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fissue-6898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6898.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,9 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-use std::intrinsics;\n+use std::mem;\n \n /// Returns the size of a type\n pub fn size_of<T>() -> usize {\n@@ -32,7 +30,7 @@ pub trait TypeInfo {\n impl<T> TypeInfo for T {\n     /// The size of the type in bytes.\n     fn size_of(_lame_type_hint: Option<T>) -> usize {\n-        unsafe { intrinsics::size_of::<T>() }\n+        mem::size_of::<T>()\n     }\n \n     /// Returns the size of the type of `self` in bytes."}, {"sha": "e3351bda3354d93bc124bb2d423d20d920adccc8", "filename": "src/test/run-pass/iter-cloned-type-inference.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fiter-cloned-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fiter-cloned-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-cloned-type-inference.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -11,8 +11,7 @@\n // Test to see that the element type of .cloned() can be inferred\n // properly. Previously this would fail to deduce the type of `sum`.\n \n-\n-#![feature(core)]\n+#![feature(iter_arith)]\n \n fn square_sum(v: &[i64]) -> i64 {\n     let sum: i64 = v.iter().cloned().sum();"}, {"sha": "e6eaefb0490806e7c4c653cc5472c8f5ac10ef8d", "filename": "src/test/run-pass/linkage-visibility.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -13,8 +13,6 @@\n // ignore-windows: std::dynamic_lib does not work on Windows well\n // ignore-musl\n \n-#![feature(std_misc)]\n-\n extern crate linkage_visibility as foo;\n \n pub fn main() {"}, {"sha": "405a3549cf18c762522cc1638a1f188888f61fbd", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -13,7 +13,7 @@\n // temporary. Issue #19147.\n \n \n-#![feature(core)]\n+#![feature(slice_bytes)]\n \n use std::slice;\n "}, {"sha": "62bde45cd3dc0c8675c6577d7c23d24ab8110970", "filename": "src/test/run-pass/minmax-stability-issue-23687.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n+#![feature(iter_min_max, cmp_partial, iter_cmp)]\n+\n use std::fmt::Debug;\n use std::cmp::{self, PartialOrd, Ordering};\n use std::iter::MinMaxResult::MinMax;"}, {"sha": "b5a54a90ae758ef778d7ebbbdb372b45819f21b5", "filename": "src/test/run-pass/new-box-syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -13,8 +13,8 @@\n /* Any copyright is dedicated to the Public Domain.\n  * http://creativecommons.org/publicdomain/zero/1.0/ */\n \n-#![allow(unknown_features)]\n-#![feature(box_syntax, alloc)]\n+#![allow(warnings)]\n+#![feature(box_syntax, box_heap)]\n \n // Tests that the new `box` syntax works with unique pointers.\n "}, {"sha": "a9bd967ca765a61a335c012f26d223432cb7af1d", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -13,7 +13,7 @@\n // Ideally this would be revised to use no_std, but for now it serves\n // well enough to reproduce (and illustrate) the bug from #16687.\n \n-#![feature(alloc)]\n+#![feature(heap_api, alloc, oom)]\n \n extern crate alloc;\n "}, {"sha": "2b2dcb6efb5d46af99a7c659d87b69e2e2085f56", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(start, std_misc)]\n+#![feature(catch_panic, start)]\n \n use std::ffi::CStr;\n use std::process::{Command, Output};\n-use std::rt::unwind::try;\n+use std::thread;\n use std::str;\n \n #[start]\n@@ -22,8 +22,8 @@ fn start(argc: isize, argv: *const *const u8) -> isize {\n             match **argv.offset(1) as char {\n                 '1' => {}\n                 '2' => println!(\"foo\"),\n-                '3' => assert!(try(|| {}).is_ok()),\n-                '4' => assert!(try(|| panic!()).is_err()),\n+                '3' => assert!(thread::catch_panic(|| {}).is_ok()),\n+                '4' => assert!(thread::catch_panic(|| panic!()).is_err()),\n                 '5' => assert!(Command::new(\"test\").spawn().is_err()),\n                 _ => panic!()\n             }"}, {"sha": "e40f4d30eb9785e080894856ba48670a10059e86", "filename": "src/test/run-pass/send-is-not-static-par-for.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![feature(core, std_misc, scoped)]\n use std::thread;\n use std::sync::Mutex;"}, {"sha": "4f5119f6a84e928e9a4b4a43aa2f95e3a1fbb0e3", "filename": "src/test/run-pass/simd-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-binop.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-#![feature(core)]\n+#![feature(core_simd)]\n \n use std::simd::{i32x4, f32x4, u32x4};\n "}, {"sha": "c3eef0f9c3217a0e01fee6f2d7b921560a69eca4", "filename": "src/test/run-pass/simd-issue-10604.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fsimd-issue-10604.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fsimd-issue-10604.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-issue-10604.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,8 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-#![feature(simd)]\n+#![feature(core_simd)]\n \n pub fn main() {\n     let _o = None::<std::simd::i32x4>;"}, {"sha": "ab22b820503af156b603fd5d619dc43ab4d6d717", "filename": "src/test/run-pass/slice-of-zero-size-elements.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -C debug-assertions\n \n-#![feature(core)]\n+#![feature(iter_to_slice)]\n \n use std::slice;\n "}, {"sha": "b8e05c06c83b77387d4dfab97822ff6a2fff9f4d", "filename": "src/test/run-pass/std-sync-right-kind-impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,7 +10,8 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(std_misc, alloc, static_condvar)]\n+#![feature(static_mutex, static_rwlock, static_condvar)]\n+#![feature(arc_weak, semaphore)]\n \n use std::sync;\n "}, {"sha": "0ee04c4463b0fec858c485aaf82392b1a60d6b9a", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,9 +10,9 @@\n \n // pretty-expanded FIXME #23616\n \n-#![allow(unused_mut)]\n+#![allow(warnings)]\n #![feature(collections)]\n-#![feature(collections_drain)]\n+#![feature(drain, enumset, collections_bound, btree_range, vecmap)]\n \n extern crate collections;\n "}, {"sha": "d76bf89d0539680f8178922e5f04ecaa8ab7e024", "filename": "src/test/run-pass/sync-send-iterators-in-libcore.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -10,12 +10,13 @@\n \n // pretty-expanded FIXME #23616\n \n-#![allow(unused_mut)]\n-#![feature(core)]\n-#![feature(collections)]\n-#![feature(step_by)]\n+#![allow(warnings)]\n #![feature(iter_empty)]\n #![feature(iter_once)]\n+#![feature(iter_unfold)]\n+#![feature(range_inclusive)]\n+#![feature(step_by)]\n+#![feature(str_escape)]\n \n use std::iter::{empty, once, range_inclusive, repeat, Unfold};\n "}, {"sha": "4a169c0a384aa2bcf8bebe4f476447ef956544c4", "filename": "src/test/run-pass/tydesc-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftydesc-name.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-#![feature(core)]\n+#![feature(core_intrinsics)]\n \n use std::intrinsics::type_name;\n "}, {"sha": "feb43dfb9ade22891fba2771945bf4692915672d", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -12,7 +12,7 @@\n // aux-build:typeid-intrinsic2.rs\n \n \n-#![feature(hash, core)]\n+#![feature(hash_default, core_intrinsics)]\n \n extern crate typeid_intrinsic as other1;\n extern crate typeid_intrinsic2 as other2;"}, {"sha": "27f11d0411c47f11f194b4a1d765d13a196318ba", "filename": "src/test/run-pass/ufcs-polymorphic-paths.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n \n-#![feature(collections, rand, into_cow)]\n+#![feature(collections, rand, into_cow, map_in_place, bitvec)]\n+#![allow(warnings)]\n \n use std::borrow::{Cow, IntoCow};\n use std::collections::BitVec;"}, {"sha": "9d5383fe0603fd70d59ee842f4f2640ac7a3233d", "filename": "src/test/run-pass/unfold-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n+#![feature(iter_unfold)]\n \n use std::iter::Unfold;\n "}, {"sha": "6d378cb294e328d46ff684fd865012207c838d76", "filename": "src/test/run-pass/unsized3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized3.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -11,8 +11,8 @@\n // Test structs with always-unsized fields.\n \n \n-#![allow(unknown_features)]\n-#![feature(box_syntax, core)]\n+#![allow(warnings)]\n+#![feature(box_syntax, unsize, raw)]\n \n use std::mem;\n use std::raw;"}, {"sha": "25c1cfe1f4d427678fd2595e6dac9f8e5e87496f", "filename": "src/test/run-pass/vec-concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-concat.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(collections)]\n+#![feature(vec_push_all)]\n \n use std::vec;\n "}, {"sha": "cf3a8796d32c96e4480259c1fb08cb1bf5dd7037", "filename": "src/test/run-pass/vec-macro-no-std.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fvec-macro-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fvec-macro-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-macro-no-std.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n-#![feature(lang_items, start, no_std, core, libc, collections)]\n+#![feature(lang_items, start, no_std, core, core_slice_ext, libc, collections)]\n #![no_std]\n \n extern crate std as other;"}, {"sha": "42b05aeea2910a73de32b8872c3a9c0cd2b0120b", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-#![feature(rand, core)]\n+#![feature(rand, num_bits_bytes)]\n #![feature(const_fn)]\n \n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "48eea1206230ec5349a3254655de3a705034ec29", "filename": "src/test/run-pass/wrapping-int-api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fwrapping-int-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fwrapping-int-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwrapping-int-api.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n+#![feature(num_wrapping)]\n \n // Test inherent wrapping_* methods for {i,u}{size,8,16,32,64}.\n "}, {"sha": "c9742b0645e1da9e3a65479df800f32004cacdb6", "filename": "src/test/run-pass/x86stdcall2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs?ref=9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![feature(std_misc)]\n \n pub type HANDLE = u32;"}]}