{"sha": "5b5927996f9c78e16d75235d5953d072757c8bae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNTkyNzk5NmY5Yzc4ZTE2ZDc1MjM1ZDU5NTNkMDcyNzU3YzhiYWU=", "commit": {"author": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2015-08-01T13:02:59Z"}, "committer": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2015-08-02T11:33:01Z"}, "message": "Kill ChangeSet and replace remaining part by FileMap\n\nAlso fix style issues\nCargo update to get fixes of strings.rs (was cause of a misformatted\nfunction call).", "tree": {"sha": "422ffdf012273224934644578bc611c01b0cf33b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/422ffdf012273224934644578bc611c01b0cf33b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b5927996f9c78e16d75235d5953d072757c8bae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b5927996f9c78e16d75235d5953d072757c8bae", "html_url": "https://github.com/rust-lang/rust/commit/5b5927996f9c78e16d75235d5953d072757c8bae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b5927996f9c78e16d75235d5953d072757c8bae/comments", "author": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0eab4bf4307914368e6c79d09bbbed0e2a7fcc58", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eab4bf4307914368e6c79d09bbbed0e2a7fcc58", "html_url": "https://github.com/rust-lang/rust/commit/0eab4bf4307914368e6c79d09bbbed0e2a7fcc58"}], "stats": {"total": 345, "additions": 144, "deletions": 201}, "files": [{"sha": "82dbafd47d62189e52fcd5c70c2bb7ee4a3f392f", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b5927996f9c78e16d75235d5953d072757c8bae/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5b5927996f9c78e16d75235d5953d072757c8bae/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5b5927996f9c78e16d75235d5953d072757c8bae", "patch": "@@ -2,24 +2,24 @@\n name = \"rustfmt\"\n version = \"0.0.1\"\n dependencies = [\n- \"diff 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"diff 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strings 0.0.1 (git+https://github.com/nrc/strings.rs.git)\",\n- \"toml 0.1.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"aho-corasick\"\n-version = \"0.2.1\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"memchr 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"diff\"\n-version = \"0.1.3\"\n+version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -37,17 +37,17 @@ dependencies = [\n \n [[package]]\n name = \"regex\"\n-version = \"0.1.38\"\n+version = \"0.1.41\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"aho-corasick 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"aho-corasick 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.1.2\"\n+version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -58,11 +58,11 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"strings\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/nrc/strings.rs.git#b7f37c4545b7dba24fb28161cd9c405fae978be4\"\n+source = \"git+https://github.com/nrc/strings.rs.git#6d748148fbe3bf2d9e5ac2ede65ac503d7491a4f\"\n \n [[package]]\n name = \"toml\"\n-version = \"0.1.20\"\n+version = \"0.1.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-serialize 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "ab758f71d95f78b9ef97db941e16ec1cbff2f4ae", "filename": "src/changes.rs", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/0eab4bf4307914368e6c79d09bbbed0e2a7fcc58/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eab4bf4307914368e6c79d09bbbed0e2a7fcc58/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=0eab4bf4307914368e6c79d09bbbed0e2a7fcc58", "patch": "@@ -1,170 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// TODO\n-// print to files\n-// tests\n-\n-use strings::string_buffer::StringBuffer;\n-use std::collections::HashMap;\n-use std::fmt;\n-use std::fs::File;\n-use std::io::{Write, stdout};\n-use WriteMode;\n-use NewlineStyle;\n-use config::Config;\n-\n-// This is basically a wrapper around a bunch of Ropes which makes it convenient\n-// to work with libsyntax. It is badly named.\n-pub struct ChangeSet {\n-    pub file_map: HashMap<String, StringBuffer>,\n-}\n-\n-impl ChangeSet {\n-    // Create a new ChangeSet for a given libsyntax CodeMap.\n-    pub fn new() -> ChangeSet {\n-        ChangeSet { file_map: HashMap::new() }\n-    }\n-\n-    // Fetch a mutable reference to the output buffer for the given file name.\n-    // Panics on unknown files.\n-    pub fn get_mut(&mut self, file_name: &str) -> &mut StringBuffer {\n-        self.file_map.get_mut(file_name).unwrap()\n-    }\n-\n-    // Return an iterator over the entire changed text.\n-    pub fn text<'c>(&'c self) -> FileIterator<'c> {\n-        FileIterator { change_set: self, keys: self.file_map.keys().collect(), cur_key: 0 }\n-    }\n-\n-    // Append a newline to the end of each file.\n-    pub fn append_newlines(&mut self) {\n-        for (_, s) in self.file_map.iter_mut() {\n-            s.push_str(\"\\n\");\n-        }\n-    }\n-\n-    pub fn write_all_files(&self,\n-                           mode: WriteMode,\n-                           config: &Config)\n-                           -> Result<(HashMap<String, String>), ::std::io::Error> {\n-        let mut result = HashMap::new();\n-        for filename in self.file_map.keys() {\n-            let one_result = try!(self.write_file(filename, mode, config));\n-            if let Some(r) = one_result {\n-                result.insert(filename.clone(), r);\n-            }\n-        }\n-\n-        Ok(result)\n-    }\n-\n-    pub fn write_file(&self,\n-                      filename: &str,\n-                      mode: WriteMode,\n-                      config: &Config)\n-                      -> Result<Option<String>, ::std::io::Error> {\n-        let text = &self.file_map[filename];\n-\n-        // prints all newlines either as `\\n` or as `\\r\\n`\n-        fn write_system_newlines<T>(mut writer: T,\n-                                    text: &StringBuffer,\n-                                    config: &Config)\n-                                    -> Result<(), ::std::io::Error>\n-            where T: Write\n-        {\n-            match config.newline_style {\n-                NewlineStyle::Unix => write!(writer, \"{}\", text),\n-                NewlineStyle::Windows => {\n-                    for (c, _) in text.chars() {\n-                        match c {\n-                            '\\n' => try!(write!(writer, \"\\r\\n\")),\n-                            '\\r' => continue,\n-                            c => try!(write!(writer, \"{}\", c)),\n-                        }\n-                    }\n-                    Ok(())\n-                },\n-            }\n-        }\n-\n-        match mode {\n-            WriteMode::Overwrite => {\n-                // Do a little dance to make writing safer - write to a temp file\n-                // rename the original to a .bk, then rename the temp file to the\n-                // original.\n-                let tmp_name = filename.to_owned() + \".tmp\";\n-                let bk_name = filename.to_owned() + \".bk\";\n-                {\n-                    // Write text to temp file\n-                    let tmp_file = try!(File::create(&tmp_name));\n-                    try!(write_system_newlines(tmp_file, text, config));\n-                }\n-\n-                try!(::std::fs::rename(filename, bk_name));\n-                try!(::std::fs::rename(tmp_name, filename));\n-            }\n-            WriteMode::NewFile(extn) => {\n-                let filename = filename.to_owned() + \".\" + extn;\n-                let file = try!(File::create(&filename));\n-                try!(write_system_newlines(file, text, config));\n-            }\n-            WriteMode::Display => {\n-                println!(\"{}:\\n\", filename);\n-                let stdout = stdout();\n-                let stdout_lock = stdout.lock();\n-                try!(write_system_newlines(stdout_lock, text, config));\n-            }\n-            WriteMode::Return(_) => {\n-                // io::Write is not implemented for String, working around with Vec<u8>\n-                let mut v = Vec::new();\n-                try!(write_system_newlines(&mut v, text, config));\n-                // won't panic, we are writing correct utf8\n-                return Ok(Some(String::from_utf8(v).unwrap()));\n-            }\n-        }\n-\n-        Ok(None)\n-    }\n-}\n-\n-// Iterates over each file in the ChangSet. Yields the filename and the changed\n-// text for that file.\n-pub struct FileIterator<'c> {\n-    change_set: &'c ChangeSet,\n-    keys: Vec<&'c String>,\n-    cur_key: usize,\n-}\n-\n-impl<'c> Iterator for FileIterator<'c> {\n-    type Item = (&'c str, &'c StringBuffer);\n-\n-    fn next(&mut self) -> Option<(&'c str, &'c StringBuffer)> {\n-        if self.cur_key >= self.keys.len() {\n-            return None;\n-        }\n-\n-        let key = self.keys[self.cur_key];\n-        self.cur_key += 1;\n-        return Some((&key, &self.change_set.file_map[&*key]))\n-    }\n-}\n-\n-impl fmt::Display for ChangeSet {\n-    // Prints the entire changed text.\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        for (f, r) in self.text() {\n-            try!(write!(fmt, \"{}:\\n\", f));\n-            try!(write!(fmt, \"{}\\n\\n\", r));\n-        }\n-        Ok(())\n-    }\n-}"}, {"sha": "750bea9b862fcbaace874d716679b22f765370c6", "filename": "src/filemap.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/5b5927996f9c78e16d75235d5953d072757c8bae/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b5927996f9c78e16d75235d5953d072757c8bae/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=5b5927996f9c78e16d75235d5953d072757c8bae", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// TODO tests\n+\n+use strings::string_buffer::StringBuffer;\n+use std::collections::HashMap;\n+use std::fs::File;\n+use std::io::{Write, stdout};\n+use WriteMode;\n+use NewlineStyle;\n+use config::Config;\n+\n+// A map of the files of a crate, with their new content\n+pub type FileMap = HashMap<String, StringBuffer>;\n+\n+// Append a newline to the end of each file.\n+pub fn append_newlines(file_map: &mut FileMap) {\n+    for (_, s) in file_map.iter_mut() {\n+        s.push_str(\"\\n\");\n+    }\n+}\n+\n+pub fn write_all_files(file_map: &FileMap,\n+                       mode: WriteMode,\n+                       config: &Config)\n+                       -> Result<(HashMap<String, String>), ::std::io::Error> {\n+    let mut result = HashMap::new();\n+    for filename in file_map.keys() {\n+        let one_result = try!(write_file(file_map, filename, mode, config));\n+        if let Some(r) = one_result {\n+            result.insert(filename.clone(), r);\n+        }\n+    }\n+\n+    Ok(result)\n+}\n+\n+fn write_file(file_map: &FileMap,\n+              filename: &str,\n+              mode: WriteMode,\n+              config: &Config)\n+              -> Result<Option<String>, ::std::io::Error> {\n+    let text = &file_map[filename];\n+\n+        // prints all newlines either as `\\n` or as `\\r\\n`\n+    fn write_system_newlines<T>(mut writer: T,\n+                                text: &StringBuffer,\n+                                config: &Config)\n+                                -> Result<(), ::std::io::Error>\n+        where T: Write\n+    {\n+        match config.newline_style {\n+                NewlineStyle::Unix => write!(writer, \"{}\", text),\n+                NewlineStyle::Windows => {\n+                    for (c, _) in text.chars() {\n+                        match c {\n+                            '\\n' => try!(write!(writer, \"\\r\\n\")),\n+                            '\\r' => continue,\n+                            c => try!(write!(writer, \"{}\", c)),\n+                        }\n+                    }\n+                    Ok(())\n+                },\n+            }\n+    }\n+\n+    match mode {\n+            WriteMode::Overwrite => {\n+                // Do a little dance to make writing safer - write to a temp file\n+                // rename the original to a .bk, then rename the temp file to the\n+                // original.\n+                let tmp_name = filename.to_owned() + \".tmp\";\n+                let bk_name = filename.to_owned() + \".bk\";\n+                {\n+                    // Write text to temp file\n+                    let tmp_file = try!(File::create(&tmp_name));\n+                    try!(write_system_newlines(tmp_file, text, config));\n+                }\n+\n+                try!(::std::fs::rename(filename, bk_name));\n+                try!(::std::fs::rename(tmp_name, filename));\n+            }\n+            WriteMode::NewFile(extn) => {\n+                let filename = filename.to_owned() + \".\" + extn;\n+                let file = try!(File::create(&filename));\n+                try!(write_system_newlines(file, text, config));\n+            }\n+            WriteMode::Display => {\n+                println!(\"{}:\\n\", filename);\n+                let stdout = stdout();\n+                let stdout_lock = stdout.lock();\n+                try!(write_system_newlines(stdout_lock, text, config));\n+            }\n+            WriteMode::Return(_) => {\n+                // io::Write is not implemented for String, working around with Vec<u8>\n+                let mut v = Vec::new();\n+                try!(write_system_newlines(&mut v, text, config));\n+                // won't panic, we are writing correct utf8\n+                return Ok(Some(String::from_utf8(v).unwrap()));\n+            }\n+        }\n+\n+    Ok(None)\n+}"}, {"sha": "c0aff9a05b3f2ea72c127ecb63e893098a42688b", "filename": "src/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5b5927996f9c78e16d75235d5953d072757c8bae/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b5927996f9c78e16d75235d5953d072757c8bae/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5b5927996f9c78e16d75235d5953d072757c8bae", "patch": "@@ -44,14 +44,14 @@ use std::fmt;\n use std::mem::swap;\n \n use issues::{BadIssueSeeker, Issue};\n-use changes::ChangeSet;\n+use filemap::FileMap;\n use visitor::FmtVisitor;\n use config::Config;\n \n #[macro_use]\n mod utils;\n pub mod config;\n-mod changes;\n+mod filemap;\n mod visitor;\n mod items;\n mod missed_spans;\n@@ -196,26 +196,26 @@ impl fmt::Display for FormatReport {\n }\n \n // Formatting which depends on the AST.\n-fn fmt_ast(krate: &ast::Crate, codemap: &CodeMap, config: &Config) -> ChangeSet {\n-    let mut changes = ChangeSet::new();\n-    for (path, module) in modules::list_modules(krate, codemap) {\n+fn fmt_ast(krate: &ast::Crate, codemap: &CodeMap, config: &Config) -> FileMap {\n+    let mut file_map = FileMap::new();\n+    for (path, module) in modules::list_files(krate, codemap) {\n         let path = path.to_str().unwrap();\n         let mut visitor = FmtVisitor::from_codemap(codemap, config);\n         visitor.format_separate_mod(module, path);\n-        changes.file_map.insert(path.to_owned(), visitor.buffer);\n+        file_map.insert(path.to_owned(), visitor.buffer);\n     }\n-    changes\n+    file_map\n }\n \n // Formatting done on a char by char or line by line basis.\n // TODO warn on bad license\n // TODO other stuff for parity with make tidy\n-fn fmt_lines(changes: &mut ChangeSet, config: &Config) -> FormatReport {\n+fn fmt_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n     let mut truncate_todo = Vec::new();\n     let mut report = FormatReport { file_error_map: HashMap::new() };\n \n-    // Iterate over the chars in the change set.\n-    for (f, text) in changes.text() {\n+    // Iterate over the chars in the file map.\n+    for (f, text) in file_map.iter() {\n         let mut trims = vec![];\n         let mut last_wspace: Option<usize> = None;\n         let mut line_len = 0;\n@@ -283,7 +283,7 @@ fn fmt_lines(changes: &mut ChangeSet, config: &Config) -> FormatReport {\n     }\n \n     for (f, l) in truncate_todo {\n-        changes.get_mut(&f).truncate(l);\n+        file_map.get_mut(&f).unwrap().truncate(l);\n     }\n \n     report\n@@ -317,13 +317,13 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n         control.after_parse.callback = Box::new(move |state| {\n             let krate = state.krate.unwrap();\n             let codemap = state.session.codemap();\n-            let mut changes = fmt_ast(krate, codemap, &*config);\n+            let mut file_map = fmt_ast(krate, codemap, &*config);\n             // For some reason, the codemap does not include terminating newlines\n             // so we must add one on for each file. This is sad.\n-            changes.append_newlines();\n-            println!(\"{}\", fmt_lines(&mut changes, &*config));\n+            filemap::append_newlines(&mut file_map);\n+            println!(\"{}\", fmt_lines(&mut file_map, &*config));\n \n-            let result = changes.write_all_files(write_mode, &*config);\n+            let result = filemap::write_all_files(&file_map, write_mode, &*config);\n \n             match result {\n                 Err(msg) => println!(\"Error writing files: {}\", msg),"}, {"sha": "64025550410de61157250f26c61c9f2c4097ecd3", "filename": "src/missed_spans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b5927996f9c78e16d75235d5953d072757c8bae/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b5927996f9c78e16d75235d5953d072757c8bae/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=5b5927996f9c78e16d75235d5953d072757c8bae", "patch": "@@ -57,8 +57,8 @@ impl<'a> FmtVisitor<'a> {\n         let snippet = self.snippet(span);\n \n         self.write_snippet(&snippet,\n-                               true,\n-                               &process_last_snippet);\n+                           true,\n+                           &process_last_snippet);\n     }\n \n     fn write_snippet<F: Fn(&mut FmtVisitor, &str, &str)>(&mut self,"}, {"sha": "2f40fd33a55821314039e3dc398782ef6f03506a", "filename": "src/modules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b5927996f9c78e16d75235d5953d072757c8bae/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b5927996f9c78e16d75235d5953d072757c8bae/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=5b5927996f9c78e16d75235d5953d072757c8bae", "patch": "@@ -20,9 +20,9 @@ use syntax::parse::parser;\n \n /// List all the files containing modules of a crate.\n /// If a file is used twice in a crate, it appears only once.\n-pub fn list_modules<'a>(krate: &'a ast::Crate,\n-                        codemap: &codemap::CodeMap)\n-                        -> HashMap<PathBuf, &'a ast::Mod> {\n+pub fn list_files<'a>(krate: &'a ast::Crate,\n+                      codemap: &codemap::CodeMap)\n+                      -> HashMap<PathBuf, &'a ast::Mod> {\n     let mut result = HashMap::new();\n     let root_filename: PathBuf = codemap.span_to_filename(krate.span).into();\n     list_submodules(&krate.module, root_filename.parent().unwrap(), codemap, &mut result);"}]}