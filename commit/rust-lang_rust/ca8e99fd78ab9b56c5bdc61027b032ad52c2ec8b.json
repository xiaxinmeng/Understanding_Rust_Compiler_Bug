{"sha": "ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhOGU5OWZkNzhhYjliNTZjNWJkYzYxMDI3YjAzMmFkNTJjMmVjOGI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-05T18:55:43Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-19T18:53:34Z"}, "message": "rt: Fix scalability problem with big stacks on 32 bit", "tree": {"sha": "e3fef1f74bbfaa9ee6846c67941b9f2d8dab0b78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3fef1f74bbfaa9ee6846c67941b9f2d8dab0b78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b", "html_url": "https://github.com/rust-lang/rust/commit/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dbe20a5610c3244feab0db5ab20ff062dc91085", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dbe20a5610c3244feab0db5ab20ff062dc91085", "html_url": "https://github.com/rust-lang/rust/commit/2dbe20a5610c3244feab0db5ab20ff062dc91085"}], "stats": {"total": 137, "additions": 131, "deletions": 6}, "files": [{"sha": "dbcbd7b83cf23aef493896df02a1ffbce7bf8362", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b", "patch": "@@ -29,6 +29,8 @@ rust_sched_loop::rust_sched_loop(rust_scheduler *sched, int id, bool killed) :\n     should_exit(false),\n     cached_c_stack(NULL),\n     extra_c_stack(NULL),\n+    cached_big_stack(NULL),\n+    extra_big_stack(NULL),\n     dead_task(NULL),\n     killed(killed),\n     pump_signal(NULL),\n@@ -263,6 +265,11 @@ rust_sched_loop::run_single_turn() {\n             destroy_exchange_stack(kernel->region(), cached_c_stack);\n             cached_c_stack = NULL;\n         }\n+        assert(!extra_big_stack);\n+        if (cached_big_stack) {\n+            destroy_exchange_stack(kernel->region(), cached_big_stack);\n+            cached_big_stack = NULL;\n+        }\n \n         sched->release_task_thread();\n         return sched_loop_state_exit;\n@@ -392,6 +399,13 @@ rust_sched_loop::prepare_c_stack(rust_task *task) {\n         cached_c_stack = create_exchange_stack(kernel->region(),\n                                                C_STACK_SIZE);\n     }\n+    assert(!extra_big_stack);\n+    if (!cached_big_stack) {\n+        cached_big_stack = create_exchange_stack(kernel->region(),\n+                                                 C_STACK_SIZE +\n+                                                 (C_STACK_SIZE * 2));\n+        cached_big_stack->is_big = 1;\n+    }\n }\n \n void\n@@ -400,6 +414,10 @@ rust_sched_loop::unprepare_c_stack() {\n         destroy_exchange_stack(kernel->region(), extra_c_stack);\n         extra_c_stack = NULL;\n     }\n+    if (extra_big_stack) {\n+        destroy_exchange_stack(kernel->region(), extra_big_stack);\n+        extra_big_stack = NULL;\n+    }\n }\n \n //"}, {"sha": "a099c5e0c74955c82409dd79c121521db4dfed0b", "filename": "src/rt/rust_sched_loop.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b", "patch": "@@ -67,6 +67,8 @@ struct rust_sched_loop\n \n     stk_seg *cached_c_stack;\n     stk_seg *extra_c_stack;\n+    stk_seg *cached_big_stack;\n+    stk_seg *extra_big_stack;\n \n     rust_task_list running_tasks;\n     rust_task_list blocked_tasks;\n@@ -147,6 +149,10 @@ struct rust_sched_loop\n     stk_seg *borrow_c_stack();\n     void return_c_stack(stk_seg *stack);\n \n+    // Called by tasks when they need a big stack\n+    stk_seg *borrow_big_stack();\n+    void return_big_stack(stk_seg *stack);\n+\n     int get_id() { return this->id; }\n };\n \n@@ -202,6 +208,32 @@ rust_sched_loop::return_c_stack(stk_seg *stack) {\n     }\n }\n \n+// NB: Runs on the Rust stack. Might return NULL!\n+inline stk_seg *\n+rust_sched_loop::borrow_big_stack() {\n+    assert(cached_big_stack);\n+    stk_seg *your_stack;\n+    if (extra_big_stack) {\n+        your_stack = extra_big_stack;\n+        extra_big_stack = NULL;\n+    } else {\n+        your_stack = cached_big_stack;\n+        cached_big_stack = NULL;\n+    }\n+    return your_stack;\n+}\n+\n+// NB: Runs on the Rust stack\n+inline void\n+rust_sched_loop::return_big_stack(stk_seg *stack) {\n+    assert(!extra_big_stack);\n+    assert(stack);\n+    if (!cached_big_stack)\n+        cached_big_stack = stack;\n+    else\n+        extra_big_stack = stack;\n+}\n+\n // this is needed to appease the circular dependency gods\n #include \"rust_task.h\"\n "}, {"sha": "f07690a955ea2c7e1a38998e04a7fe300aaecc19", "filename": "src/rt/rust_stack.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_stack.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_stack.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_stack.cpp?ref=ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b", "patch": "@@ -13,6 +13,8 @@\n #include \"vg/valgrind.h\"\n #include \"vg/memcheck.h\"\n \n+#include <cstdio>\n+\n #ifdef _LP64\n const uintptr_t canary_value = 0xABCDABCDABCDABCD;\n #else\n@@ -61,6 +63,7 @@ create_stack(memory_region *region, size_t sz) {\n     stk_seg *stk = (stk_seg *)region->malloc(total_sz, \"stack\");\n     memset(stk, 0, sizeof(stk_seg));\n     stk->end = (uintptr_t) &stk->data[sz];\n+    stk->is_big = 0;\n     add_stack_canary(stk);\n     register_valgrind_stack(stk);\n     return stk;\n@@ -78,6 +81,7 @@ create_exchange_stack(rust_exchange_alloc *exchange, size_t sz) {\n     stk_seg *stk = (stk_seg *)exchange->malloc(total_sz);\n     memset(stk, 0, sizeof(stk_seg));\n     stk->end = (uintptr_t) &stk->data[sz];\n+    stk->is_big = 0;\n     add_stack_canary(stk);\n     register_valgrind_stack(stk);\n     return stk;"}, {"sha": "3b34b91e309cf55ba27c7c760de7a75a87e4cd83", "filename": "src/rt/rust_stack.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_stack.h", "raw_url": "https://github.com/rust-lang/rust/raw/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_stack.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_stack.h?ref=ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b", "patch": "@@ -22,9 +22,7 @@ struct stk_seg {\n     stk_seg *next;\n     uintptr_t end;\n     unsigned int valgrind_id;\n-#ifndef _LP64\n-    uint32_t pad;\n-#endif\n+    uint8_t is_big;\n \n     rust_task *task;\n     uintptr_t canary;"}, {"sha": "6db138b418e512a6915a7526e734e829caa8c972", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b", "patch": "@@ -53,7 +53,8 @@ rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n     disallow_yield(0),\n     c_stack(NULL),\n     next_c_sp(0),\n-    next_rust_sp(0)\n+    next_rust_sp(0),\n+    big_stack(NULL)\n {\n     LOGPTR(sched_loop, \"new task\", (uintptr_t)this);\n     DLOG(sched_loop, task, \"sizeof(task) = %d (0x%x)\",\n@@ -556,13 +557,64 @@ rust_task::cleanup_after_turn() {\n     // Delete any spare stack segments that were left\n     // behind by calls to prev_stack\n     assert(stk);\n+\n     while (stk->next) {\n         stk_seg *new_next = stk->next->next;\n-        free_stack(stk->next);\n+\n+        if (stk->next->is_big) {\n+            assert (big_stack == stk->next);\n+            sched_loop->return_big_stack(big_stack);\n+            big_stack = NULL;\n+        } else {\n+            free_stack(stk->next);\n+        }\n+\n         stk->next = new_next;\n     }\n }\n \n+// NB: Runs on the Rust stack. Returns true if we successfully allocated the big\n+// stack and false otherwise.\n+bool\n+rust_task::new_big_stack() {\n+    // If we have a cached big stack segment, use it.\n+    if (big_stack) {\n+        // Check to see if we're already on the big stack.\n+        stk_seg *ss = stk;\n+        while (ss != NULL) {\n+            if (ss == big_stack)\n+                return false;\n+            ss = ss->prev;\n+        }\n+\n+        // Unlink the big stack.\n+        if (big_stack->next)\n+            big_stack->next->prev = big_stack->prev;\n+        if (big_stack->prev)\n+            big_stack->prev->next = big_stack->next;\n+    } else {\n+        stk_seg *borrowed_big_stack = sched_loop->borrow_big_stack();\n+        if (!borrowed_big_stack) {\n+            dump_stacks();\n+            abort();\n+        } else {\n+            big_stack = borrowed_big_stack;\n+        }\n+    }\n+\n+    big_stack->task = this;\n+    big_stack->next = stk->next;\n+    if (big_stack->next)\n+        big_stack->next->prev = big_stack;\n+    big_stack->prev = stk;\n+    if (stk)\n+        stk->next = big_stack;\n+\n+    stk = big_stack;\n+\n+    return true;\n+}\n+\n static bool\n sp_in_stk_seg(uintptr_t sp, stk_seg *stk) {\n     // Not positive these bounds for sp are correct.  I think that the first\n@@ -602,9 +654,16 @@ rust_task::delete_all_stacks() {\n     assert(stk->next == NULL);\n     while (stk != NULL) {\n         stk_seg *prev = stk->prev;\n-        free_stack(stk);\n+\n+        if (stk->is_big)\n+            sched_loop->return_big_stack(stk);\n+        else\n+            free_stack(stk);\n+\n         stk = prev;\n     }\n+\n+    big_stack = NULL;\n }\n \n /*"}, {"sha": "e8b3ef44ac09e8d28f571045fbf74991494d3d2e", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=ca8e99fd78ab9b56c5bdc61027b032ad52c2ec8b", "patch": "@@ -133,6 +133,9 @@\n #define RZ_BSD_32   (1024*20)\n #define RZ_BSD_64   (1024*20)\n \n+// The threshold beyond which we switch to the C stack.\n+#define STACK_THRESHOLD (1024 * 1024)\n+\n #ifdef __linux__\n #ifdef __i386__\n #define RED_ZONE_SIZE RZ_LINUX_32\n@@ -263,9 +266,13 @@ rust_task : public kernel_owned<rust_task>\n     uintptr_t next_c_sp;\n     uintptr_t next_rust_sp;\n \n+    // The big stack.\n+    stk_seg *big_stack;\n+\n     // Called when the atomic refcount reaches zero\n     void delete_this();\n \n+    bool new_big_stack();\n     void new_stack_fast(size_t requested_sz);\n     void new_stack(size_t requested_sz);\n     void free_stack(stk_seg *stk);\n@@ -284,6 +291,8 @@ rust_task : public kernel_owned<rust_task>\n                        char const *file,\n                        size_t line);\n \n+    void dump_stacks();\n+\n     friend void task_start_wrapper(spawn_args *a);\n     friend void cleanup_task(cleanup_args *a);\n     friend void reset_stack_limit_on_c_stack(reset_args *a);\n@@ -568,6 +577,11 @@ rust_task::new_stack_fast(size_t requested_sz) {\n     // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n     size_t min_sz = sched_loop->min_stack_size;\n \n+    if (requested_sz > STACK_THRESHOLD) {\n+        if (new_big_stack())\n+            return;\n+    }\n+\n     // Try to reuse an existing stack segment\n     if (stk != NULL && stk->next != NULL) {\n         size_t next_sz = user_stack_size(stk->next);"}]}