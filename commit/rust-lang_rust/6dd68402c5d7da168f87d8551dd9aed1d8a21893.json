{"sha": "6dd68402c5d7da168f87d8551dd9aed1d8a21893", "node_id": "C_kwDOAAsO6NoAKDZkZDY4NDAyYzVkN2RhMTY4Zjg3ZDg1NTFkZDlhZWQxZDhhMjE4OTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-11T18:34:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-11T18:34:14Z"}, "message": "Auto merge of #96220 - RalfJung:scalar-no-padding, r=oli-obk\n\ntighten sanity checks around Scalar and ScalarPair\n\nWhile investigating https://github.com/rust-lang/rust/issues/96185 I noticed codegen has tighter sanity checks here than Miri does, so I added some more assertions. Strangely, some of them fail, so I also needed to add a HACK... that is probably worth looking into.\n\nThis does not fix that issue, but it changes the ICE messages, making it quite clear that we have a scalar whose size is not the same as that of the surrounding layout.\n\nr? `@oli-obk`", "tree": {"sha": "134754bcdac863ca1a669424dd76f2225cb176e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/134754bcdac863ca1a669424dd76f2225cb176e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dd68402c5d7da168f87d8551dd9aed1d8a21893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dd68402c5d7da168f87d8551dd9aed1d8a21893", "html_url": "https://github.com/rust-lang/rust/commit/6dd68402c5d7da168f87d8551dd9aed1d8a21893", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dd68402c5d7da168f87d8551dd9aed1d8a21893/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08b4f1be33607fc4f18ce19cfd475ac9f43213fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/08b4f1be33607fc4f18ce19cfd475ac9f43213fc", "html_url": "https://github.com/rust-lang/rust/commit/08b4f1be33607fc4f18ce19cfd475ac9f43213fc"}, {"sha": "14f6daf9359c920da3da6ccce41fa910dc2074a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/14f6daf9359c920da3da6ccce41fa910dc2074a3", "html_url": "https://github.com/rust-lang/rust/commit/14f6daf9359c920da3da6ccce41fa910dc2074a3"}], "stats": {"total": 106, "additions": 53, "deletions": 53}, "files": [{"sha": "d627ddb39d00c685f953b67d9d2b7d4031c78697", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6dd68402c5d7da168f87d8551dd9aed1d8a21893/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd68402c5d7da168f87d8551dd9aed1d8a21893/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=6dd68402c5d7da168f87d8551dd9aed1d8a21893", "patch": "@@ -284,8 +284,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Abi::Scalar(s) if force => Some(s.primitive()),\n             _ => None,\n         };\n-        if let Some(_) = scalar_layout {\n-            let scalar = alloc.read_scalar(alloc_range(Size::ZERO, mplace.layout.size))?;\n+        if let Some(_s) = scalar_layout {\n+            //FIXME(#96185): let size = s.size(self);\n+            //FIXME(#96185): assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n+            let size = mplace.layout.size; //FIXME(#96185): remove this line\n+            let scalar = alloc.read_scalar(alloc_range(Size::ZERO, size))?;\n             return Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }));\n         }\n         let scalar_pair_layout = match mplace.layout.abi {\n@@ -302,7 +305,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n             let (a_size, b_size) = (a.size(self), b.size(self));\n             let b_offset = a_size.align_to(b.align(self).abi);\n-            assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n+            assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n             let a_val = alloc.read_scalar(alloc_range(Size::ZERO, a_size))?;\n             let b_val = alloc.read_scalar(alloc_range(b_offset, b_size))?;\n             return Ok(Some(ImmTy {\n@@ -394,28 +397,44 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Err(value) => value,\n         };\n \n-        let field_layout = op.layout.field(self, field);\n-        if field_layout.is_zst() {\n-            let immediate = Scalar::ZST.into();\n-            return Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout });\n-        }\n-        let offset = op.layout.fields.offset(field);\n-        let immediate = match *base {\n+        let field_layout = base.layout.field(self, field);\n+        let offset = base.layout.fields.offset(field);\n+        // This makes several assumptions about what layouts we will encounter; we match what\n+        // codegen does as good as we can (see `extract_field` in `rustc_codegen_ssa/src/mir/operand.rs`).\n+        let field_val: Immediate<_> = match (*base, base.layout.abi) {\n+            // the field contains no information\n+            _ if field_layout.is_zst() => Scalar::ZST.into(),\n             // the field covers the entire type\n-            _ if offset.bytes() == 0 && field_layout.size == op.layout.size => *base,\n+            _ if field_layout.size == base.layout.size => {\n+                assert!(match (base.layout.abi, field_layout.abi) {\n+                    (Abi::Scalar(..), Abi::Scalar(..)) => true,\n+                    (Abi::ScalarPair(..), Abi::ScalarPair(..)) => true,\n+                    _ => false,\n+                });\n+                assert!(offset.bytes() == 0);\n+                *base\n+            }\n             // extract fields from types with `ScalarPair` ABI\n-            Immediate::ScalarPair(a, b) => {\n-                let val = if offset.bytes() == 0 { a } else { b };\n-                Immediate::from(val)\n+            (Immediate::ScalarPair(a_val, b_val), Abi::ScalarPair(a, b)) => {\n+                assert!(matches!(field_layout.abi, Abi::Scalar(..)));\n+                Immediate::from(if offset.bytes() == 0 {\n+                    debug_assert_eq!(field_layout.size, a.size(self));\n+                    a_val\n+                } else {\n+                    debug_assert_eq!(offset, a.size(self).align_to(b.align(self).abi));\n+                    debug_assert_eq!(field_layout.size, b.size(self));\n+                    b_val\n+                })\n             }\n-            Immediate::Scalar(val) => span_bug!(\n+            _ => span_bug!(\n                 self.cur_span(),\n-                \"field access on non aggregate {:#?}, {:#?}\",\n-                val,\n-                op.layout\n+                \"invalid field access on immediate {}, layout {:#?}\",\n+                base,\n+                base.layout\n             ),\n         };\n-        Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout })\n+\n+        Ok(OpTy { op: Operand::Immediate(field_val), layout: field_layout })\n     }\n \n     pub fn operand_index("}, {"sha": "95d6f431391fce86045b7b18eac1c645140a66c8", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6dd68402c5d7da168f87d8551dd9aed1d8a21893/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd68402c5d7da168f87d8551dd9aed1d8a21893/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=6dd68402c5d7da168f87d8551dd9aed1d8a21893", "patch": "@@ -16,7 +16,7 @@ use rustc_target::abi::{HasDataLayout, Size, VariantIdx, Variants};\n use super::{\n     alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n     ConstAlloc, ImmTy, Immediate, InterpCx, InterpResult, LocalValue, Machine, MemoryKind, OpTy,\n-    Operand, Pointer, PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit,\n+    Operand, Pointer, Provenance, Scalar, ScalarMaybeUninit,\n };\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n@@ -700,24 +700,7 @@ where\n         src: Immediate<M::PointerTag>,\n         dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if cfg!(debug_assertions) {\n-            // This is a very common path, avoid some checks in release mode\n-            assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n-            match src {\n-                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Ptr(..))) => assert_eq!(\n-                    self.pointer_size(),\n-                    dest.layout.size,\n-                    \"Size mismatch when writing pointer\"\n-                ),\n-                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Int(int))) => {\n-                    assert_eq!(int.size(), dest.layout.size, \"Size mismatch when writing bits\")\n-                }\n-                Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // uninit can have any size\n-                Immediate::ScalarPair(_, _) => {\n-                    // FIXME: Can we check anything here?\n-                }\n-            }\n-        }\n+        assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n         trace!(\"write_immediate: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n         // See if we can avoid an allocation. This is the counterpart to `read_immediate_raw`,\n@@ -753,31 +736,27 @@ where\n         dest: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // Note that it is really important that the type here is the right one, and matches the\n-        // type things are read at. In case `src_val` is a `ScalarPair`, we don't do any magic here\n+        // type things are read at. In case `value` is a `ScalarPair`, we don't do any magic here\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n \n-        // Invalid places are a thing: the return place of a diverging function\n         let tcx = *self.tcx;\n         let Some(mut alloc) = self.get_place_alloc_mut(dest)? else {\n             // zero-sized access\n             return Ok(());\n         };\n \n-        // FIXME: We should check that there are dest.layout.size many bytes available in\n-        // memory.  The code below is not sufficient, with enough padding it might not\n-        // cover all the bytes!\n         match value {\n             Immediate::Scalar(scalar) => {\n-                match dest.layout.abi {\n-                    Abi::Scalar(_) => {} // fine\n-                    _ => span_bug!(\n+                let Abi::Scalar(s) = dest.layout.abi else { span_bug!(\n                         self.cur_span(),\n                         \"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n                         dest.layout\n-                    ),\n-                }\n-                alloc.write_scalar(alloc_range(Size::ZERO, dest.layout.size), scalar)\n+                    )\n+                };\n+                let size = s.size(&tcx);\n+                //FIXME(#96185): assert_eq!(dest.layout.size, size, \"abi::Scalar size does not match layout size\");\n+                alloc.write_scalar(alloc_range(Size::ZERO, size), scalar)\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n                 // We checked `ptr_align` above, so all fields will have the alignment they need.\n@@ -791,6 +770,7 @@ where\n                 };\n                 let (a_size, b_size) = (a.size(&tcx), b.size(&tcx));\n                 let b_offset = a_size.align_to(b.align(&tcx).abi);\n+                assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n \n                 // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n                 // but that does not work: We could be a newtype around a pair, then the"}, {"sha": "2dab9ff89868f9114399dad2088594c8f1c90fd5", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6dd68402c5d7da168f87d8551dd9aed1d8a21893/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dd68402c5d7da168f87d8551dd9aed1d8a21893/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=6dd68402c5d7da168f87d8551dd9aed1d8a21893", "patch": "@@ -645,17 +645,18 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         // i.e. that we go over the `check_init` below.\n         let size = scalar_layout.size(self.ecx);\n         let is_full_range = match scalar_layout {\n-            ScalarAbi::Initialized { valid_range, .. } => {\n+            ScalarAbi::Initialized { .. } => {\n                 if M::enforce_number_validity(self.ecx) {\n                     false // not \"full\" since uninit is not accepted\n                 } else {\n-                    valid_range.is_full_for(size)\n+                    scalar_layout.is_always_valid(self.ecx)\n                 }\n             }\n             ScalarAbi::Union { .. } => true,\n         };\n         if is_full_range {\n-            // Nothing to check\n+            // Nothing to check. Cruciall we don't even `read_scalar` until here, since that would\n+            // fail for `Union` scalars!\n             return Ok(());\n         }\n         // We have something to check: it must at least be initialized.\n@@ -688,7 +689,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     } else {\n                         return Ok(());\n                     }\n-                } else if scalar_layout.valid_range(self.ecx).is_full_for(size) {\n+                } else if scalar_layout.is_always_valid(self.ecx) {\n                     // Easy. (This is reachable if `enforce_number_validity` is set.)\n                     return Ok(());\n                 } else {"}]}