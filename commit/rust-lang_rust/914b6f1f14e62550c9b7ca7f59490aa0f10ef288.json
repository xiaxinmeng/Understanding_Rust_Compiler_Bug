{"sha": "914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNGI2ZjFmMTRlNjI1NTBjOWI3Y2E3ZjU5NDkwYWEwZjEwZWYyODg=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-17T17:26:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-17T17:26:19Z"}, "message": "Rollup merge of #41012 - durka:vis-matcher, r=petrochenkov\n\n:vis matcher for macro_rules\n\nResurrection of @DanielKeep's implementation posted with [RFC 1575](https://github.com/rust-lang/rfcs/pull/1575).\n\n@jseyfried was of the opinion that this doesn't need an RFC.\n\nNeeded before merge:\n\n- [x] sign-off from @DanielKeep since I stole his code\n- [x] feature gate\n- [x] docs", "tree": {"sha": "21874704c9dba7f4aaf4cbff189927c179a5cd58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21874704c9dba7f4aaf4cbff189927c179a5cd58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "html_url": "https://github.com/rust-lang/rust/commit/914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5997806a6a4f1e57491bd9f24c7ac07619bf38d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5997806a6a4f1e57491bd9f24c7ac07619bf38d2", "html_url": "https://github.com/rust-lang/rust/commit/5997806a6a4f1e57491bd9f24c7ac07619bf38d2"}, {"sha": "cfa51f226f8190f74bcd3f8275ae05b9d76d59c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfa51f226f8190f74bcd3f8275ae05b9d76d59c4", "html_url": "https://github.com/rust-lang/rust/commit/cfa51f226f8190f74bcd3f8275ae05b9d76d59c4"}], "stats": {"total": 269, "additions": 237, "deletions": 32}, "files": [{"sha": "42af79b8bb07fe112e1b8ad385c276eedd4e918e", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -114,6 +114,7 @@\n - [lookup_host](lookup-host.md)\n - [loop_break_value](loop-break-value.md)\n - [macro_reexport](macro-reexport.md)\n+- [macro_vis_matcher](macro-vis-matcher.md)\n - [main](main.md)\n - [manually_drop](manually-drop.md)\n - [map_entry_recover_keys](map-entry-recover-keys.md)"}, {"sha": "7918a356843298d34cc458ed40d1b9e5fc075478", "filename": "src/doc/unstable-book/src/macro-vis-matcher.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Fdoc%2Funstable-book%2Fsrc%2Fmacro-vis-matcher.md", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Fdoc%2Funstable-book%2Fsrc%2Fmacro-vis-matcher.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fmacro-vis-matcher.md?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -0,0 +1,14 @@\n+# `macro_vis_matcher`\n+\n+The tracking issue for this feature is: [#41022]\n+\n+With this feature gate enabled, the [list of fragment specifiers][frags] gains one more entry:\n+\n+* `vis`: a visibility qualifier. Examples: nothing (default visibility); `pub`; `pub(crate)`.\n+\n+A `vis` variable may be followed by a comma, ident, type, or path.\n+\n+[#41022]: https://github.com/rust-lang/rust/issues/41022\n+[frags]: ../book/first-edition/macros.html#syntactic-requirements\n+\n+------------------------"}, {"sha": "c797c151de67c602f2a71a1cd302a8e3d5da6933", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -521,7 +521,9 @@ impl<'a> Resolver<'a> {\n             LoadedMacro::ProcMacro(ext) => return ext,\n         };\n \n-        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &macro_def));\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess,\n+                                               &self.session.features,\n+                                               &macro_def));\n         self.macro_map.insert(def_id, ext.clone());\n         ext\n     }"}, {"sha": "030e3936de994fb24c436b5bb389e209855afd75", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -671,7 +671,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         let def_id = self.definitions.local_def_id(item.id);\n-        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, item));\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess,\n+                                               &self.session.features,\n+                                               item));\n         self.macro_map.insert(def_id, ext);\n         *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n             parent: Cell::new(*legacy_scope), name: ident.name, def_id: def_id, span: item.span,"}, {"sha": "eb0b7c29f8d9ad8d74aa15a283c7b12f5ea1c608", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -529,6 +529,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n             token::NtPath(panictry!(p.parse_path(PathStyle::Type)))\n         },\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n+        \"vis\" => token::NtVis(panictry!(p.parse_visibility(true))),\n         // this is not supposed to happen, since it has been checked\n         // when compiling the macro.\n         _ => p.span_bug(sp, \"invalid fragment specifier\")"}, {"sha": "be979960725a91cfe6c7786ee0eb1d9150b9c2fb", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 58, "deletions": 21, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -18,13 +18,15 @@ use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n use ext::tt::quoted;\n use ext::tt::transcribe::transcribe;\n+use feature_gate::{self, emit_feature_err, Features, GateIssue};\n use parse::{Directory, ParseSess};\n use parse::parser::Parser;\n use parse::token::{self, NtTT};\n use parse::token::Token::*;\n use symbol::Symbol;\n use tokenstream::{TokenStream, TokenTree};\n \n+use std::cell::RefCell;\n use std::collections::{HashMap};\n use std::collections::hash_map::{Entry};\n use std::rc::Rc;\n@@ -154,7 +156,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n // Holy self-referential!\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n+pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item) -> SyntaxExtension {\n     let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n     let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n@@ -208,7 +210,7 @@ pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n                 if let MatchedNonterminal(ref nt) = **m {\n                     if let NtTT(ref tt) = **nt {\n                         let tt = quoted::parse(tt.clone().into(), true, sess).pop().unwrap();\n-                        valid &= check_lhs_nt_follows(sess, &tt);\n+                        valid &= check_lhs_nt_follows(sess, features, &tt);\n                         return tt;\n                     }\n                 }\n@@ -251,11 +253,13 @@ pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n     NormalTT(exp, Some(def.span), attr::contains_name(&def.attrs, \"allow_internal_unstable\"))\n }\n \n-fn check_lhs_nt_follows(sess: &ParseSess, lhs: &quoted::TokenTree) -> bool {\n+fn check_lhs_nt_follows(sess: &ParseSess,\n+                        features: &RefCell<Features>,\n+                        lhs: &quoted::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     match lhs {\n-        &quoted::TokenTree::Delimited(_, ref tts) => check_matcher(sess, &tts.tts),\n+        &quoted::TokenTree::Delimited(_, ref tts) => check_matcher(sess, features, &tts.tts),\n         _ => {\n             let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n             sess.span_diagnostic.span_err(lhs.span(), msg);\n@@ -307,11 +311,13 @@ fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool {\n     false\n }\n \n-fn check_matcher(sess: &ParseSess, matcher: &[quoted::TokenTree]) -> bool {\n+fn check_matcher(sess: &ParseSess,\n+                 features: &RefCell<Features>,\n+                 matcher: &[quoted::TokenTree]) -> bool {\n     let first_sets = FirstSets::new(matcher);\n     let empty_suffix = TokenSet::empty();\n     let err = sess.span_diagnostic.err_count();\n-    check_matcher_core(sess, &first_sets, matcher, &empty_suffix);\n+    check_matcher_core(sess, features, &first_sets, matcher, &empty_suffix);\n     err == sess.span_diagnostic.err_count()\n }\n \n@@ -553,6 +559,7 @@ impl TokenSet {\n // Requires that `first_sets` is pre-computed for `matcher`;\n // see `FirstSets::new`.\n fn check_matcher_core(sess: &ParseSess,\n+                      features: &RefCell<Features>,\n                       first_sets: &FirstSets,\n                       matcher: &[quoted::TokenTree],\n                       follow: &TokenSet) -> TokenSet {\n@@ -583,12 +590,11 @@ fn check_matcher_core(sess: &ParseSess,\n         match *token {\n             TokenTree::Token(..) | TokenTree::MetaVarDecl(..) => {\n                 let can_be_followed_by_any;\n-                if let Err(bad_frag) = has_legal_fragment_specifier(token) {\n+                if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, token) {\n                     let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n                     sess.span_diagnostic.struct_span_err(token.span(), &msg)\n-                        .help(\"valid fragment specifiers are `ident`, `block`, \\\n-                               `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n-                               and `item`\")\n+                        .help(\"valid fragment specifiers are `ident`, `block`, `stmt`, `expr`, \\\n+                              `pat`, `ty`, `path`, `meta`, `tt`, `item` and `vis`\")\n                         .emit();\n                     // (This eliminates false positives and duplicates\n                     // from error messages.)\n@@ -610,7 +616,7 @@ fn check_matcher_core(sess: &ParseSess,\n             }\n             TokenTree::Delimited(span, ref d) => {\n                 let my_suffix = TokenSet::singleton(d.close_tt(span));\n-                check_matcher_core(sess, first_sets, &d.tts, &my_suffix);\n+                check_matcher_core(sess, features, first_sets, &d.tts, &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n \n@@ -642,7 +648,7 @@ fn check_matcher_core(sess: &ParseSess,\n                 // At this point, `suffix_first` is built, and\n                 // `my_suffix` is some TokenSet that we can use\n                 // for checking the interior of `seq_rep`.\n-                let next = check_matcher_core(sess, first_sets, &seq_rep.tts, my_suffix);\n+                let next = check_matcher_core(sess, features, first_sets, &seq_rep.tts, my_suffix);\n                 if next.maybe_empty {\n                     last.add_all(&next);\n                 } else {\n@@ -790,30 +796,61 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n                 // harmless\n                 Ok(true)\n             },\n+            \"vis\" => {\n+                // Explicitly disallow `priv`, on the off chance it comes back.\n+                match *tok {\n+                    TokenTree::Token(_, ref tok) => match *tok {\n+                        Comma => Ok(true),\n+                        Ident(i) if i.name != \"priv\" => Ok(true),\n+                        ref tok => Ok(tok.can_begin_type())\n+                    },\n+                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == \"ident\"\n+                                                       || frag.name == \"ty\"\n+                                                       || frag.name == \"path\" => Ok(true),\n+                    _ => Ok(false)\n+                }\n+            },\n             \"\" => Ok(true), // keywords::Invalid\n             _ => Err((format!(\"invalid fragment specifier `{}`\", frag),\n                      \"valid fragment specifiers are `ident`, `block`, \\\n-                      `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n-                      and `item`\"))\n+                      `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt`, \\\n+                      `item` and `vis`\"))\n         }\n     }\n }\n \n-fn has_legal_fragment_specifier(tok: &quoted::TokenTree) -> Result<(), String> {\n+fn has_legal_fragment_specifier(sess: &ParseSess,\n+                                features: &RefCell<Features>,\n+                                tok: &quoted::TokenTree) -> Result<(), String> {\n     debug!(\"has_legal_fragment_specifier({:?})\", tok);\n-    if let quoted::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n-        let s = &frag_spec.name.as_str();\n-        if !is_legal_fragment_specifier(s) {\n-            return Err(s.to_string());\n+    if let quoted::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n+        let frag_name = frag_spec.name.as_str();\n+        let frag_span = tok.span();\n+        if !is_legal_fragment_specifier(sess, features, &frag_name, frag_span) {\n+            return Err(frag_name.to_string());\n         }\n     }\n     Ok(())\n }\n \n-fn is_legal_fragment_specifier(frag: &str) -> bool {\n-    match frag {\n+fn is_legal_fragment_specifier(sess: &ParseSess,\n+                               features: &RefCell<Features>,\n+                               frag_name: &str,\n+                               frag_span: Span) -> bool {\n+    match frag_name {\n         \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" |\n         \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"\" => true,\n+        \"vis\" => {\n+            if !features.borrow().macro_vis_matcher {\n+                let explain = feature_gate::EXPLAIN_VIS_MATCHER;\n+                emit_feature_err(sess,\n+                                 \"macro_vis_matcher\",\n+                                 frag_span,\n+                                 GateIssue::Language,\n+                                 explain);\n+            }\n+            true\n+        },\n         _ => false,\n     }\n }"}, {"sha": "129674b74769c154d9b4f11a568f5e9acce7fa00", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -352,6 +352,9 @@ declare_features! (\n \n     // Allows overlapping impls of marker traits\n     (active, overlapping_marker_traits, \"1.18.0\", Some(29864)),\n+\n+    // Allows use of the :vis macro fragment specifier\n+    (active, macro_vis_matcher, \"1.18.0\", Some(41022)),\n );\n \n declare_features! (\n@@ -1012,6 +1015,9 @@ pub const EXPLAIN_DEPR_CUSTOM_DERIVE: &'static str =\n pub const EXPLAIN_DERIVE_UNDERSCORE: &'static str =\n     \"attributes of the form `#[derive_*]` are reserved for the compiler\";\n \n+pub const EXPLAIN_VIS_MATCHER: &'static str =\n+    \":vis fragment specifier is experimental and subject to change\";\n+\n pub const EXPLAIN_PLACEMENT_IN: &'static str =\n     \"placement-in expression syntax is experimental and subject to change.\";\n "}, {"sha": "f39399a62e856c366fb62d73361cc8c68b3b6121", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -636,6 +636,7 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtWhereClause(where_clause) =>\n             token::NtWhereClause(fld.fold_where_clause(where_clause)),\n         token::NtArg(arg) => token::NtArg(fld.fold_arg(arg)),\n+        token::NtVis(vis) => token::NtVis(fld.fold_vis(vis)),\n     }\n }\n "}, {"sha": "31669e1bbe3a7d3ea83e07e78f0350bf601f3c03", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -5056,7 +5056,9 @@ impl<'a> Parser<'a> {\n     /// and `pub(super)` for `pub(in super)`.  If the following element can't be a tuple (i.e. it's\n     /// a function definition, it's not a tuple struct field) and the contents within the parens\n     /// isn't valid, emit a proper diagnostic.\n-    fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> {\n+    pub fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> {\n+        maybe_whole!(self, NtVis, |x| x);\n+\n         if !self.eat_keyword(keywords::Pub) {\n             return Ok(Visibility::Inherited)\n         }"}, {"sha": "25cabef70c15b5765b89a916db34a457a62a6e95", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -363,6 +363,7 @@ pub enum Nonterminal {\n     /// Stuff inside brackets for attributes\n     NtMeta(ast::MetaItem),\n     NtPath(ast::Path),\n+    NtVis(ast::Visibility),\n     NtTT(TokenTree),\n     // These are not exposed to macros, but are used by quasiquote.\n     NtArm(ast::Arm),\n@@ -392,6 +393,7 @@ impl fmt::Debug for Nonterminal {\n             NtGenerics(..) => f.pad(\"NtGenerics(..)\"),\n             NtWhereClause(..) => f.pad(\"NtWhereClause(..)\"),\n             NtArg(..) => f.pad(\"NtArg(..)\"),\n+            NtVis(..) => f.pad(\"NtVis(..)\"),\n         }\n     }\n }"}, {"sha": "be1d26f8fe4872c5f82346707883d50141ee3c2c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -293,6 +293,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtGenerics(ref e)    => generics_to_string(&e),\n             token::NtWhereClause(ref e) => where_clause_to_string(&e),\n             token::NtArg(ref e)         => arg_to_string(&e),\n+            token::NtVis(ref e)         => vis_to_string(&e),\n         }\n     }\n }\n@@ -373,6 +374,10 @@ pub fn ident_to_string(id: ast::Ident) -> String {\n     to_string(|s| s.print_ident(id))\n }\n \n+pub fn vis_to_string(v: &ast::Visibility) -> String {\n+    to_string(|s| s.print_visibility(v))\n+}\n+\n pub fn fun_to_string(decl: &ast::FnDecl,\n                      unsafety: ast::Unsafety,\n                      constness: ast::Constness,\n@@ -427,13 +432,7 @@ pub fn mac_to_string(arg: &ast::Mac) -> String {\n }\n \n pub fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n-    match *vis {\n-        ast::Visibility::Public => format!(\"pub {}\", s),\n-        ast::Visibility::Crate(_) => format!(\"pub(crate) {}\", s),\n-        ast::Visibility::Restricted { ref path, .. } =>\n-            format!(\"pub({}) {}\", to_string(|s| s.print_path(path, false, 0, true)), s),\n-        ast::Visibility::Inherited => s.to_string()\n-    }\n+    format!(\"{}{}\", to_string(|s| s.print_visibility(vis)), s)\n }\n \n fn needs_parentheses(expr: &ast::Expr) -> bool {\n@@ -1468,7 +1467,11 @@ impl<'a> State<'a> {\n             ast::Visibility::Crate(_) => self.word_nbsp(\"pub(crate)\"),\n             ast::Visibility::Restricted { ref path, .. } => {\n                 let path = to_string(|s| s.print_path(path, false, 0, true));\n-                self.word_nbsp(&format!(\"pub({})\", path))\n+                if path == \"self\" || path == \"super\" {\n+                    self.word_nbsp(&format!(\"pub({})\", path))\n+                } else {\n+                    self.word_nbsp(&format!(\"pub(in {})\", path))\n+                }\n             }\n             ast::Visibility::Inherited => Ok(())\n         }"}, {"sha": "5d6f2acea83cea7c31da88f4f36a91de4b8988f1", "filename": "src/test/compile-fail/feature-gate-macro-vis-matcher.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Ftest%2Fcompile-fail%2Ffeature-gate-macro-vis-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Ftest%2Fcompile-fail%2Ffeature-gate-macro-vis-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-macro-vis-matcher.rs?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the MSP430 interrupt ABI cannot be used when msp430_interrupt\n+// feature gate is not used.\n+\n+macro_rules! m { ($v:vis) => {} }\n+//~^ ERROR :vis fragment specifier is experimental and subject to change\n+\n+fn main() {\n+    m!(pub);\n+}"}, {"sha": "d79f4b65b69e1579da65ccfd8379da143eae648c", "filename": "src/test/run-pass/macro-pub-matcher.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914b6f1f14e62550c9b7ca7f59490aa0f10ef288/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs?ref=914b6f1f14e62550c9b7ca7f59490aa0f10ef288", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code, unused_imports)]\n+#![feature(macro_vis_matcher)]\n+\n+/**\n+Ensure that `:vis` matches can be captured in existing positions, and passed\n+through without the need for reparse tricks.\n+*/\n+macro_rules! vis_passthru {\n+    ($vis:vis const $name:ident: $ty:ty = $e:expr;) => { $vis const $name: $ty = $e; };\n+    ($vis:vis enum $name:ident {}) => { $vis struct $name {} };\n+    ($vis:vis extern \"C\" fn $name:ident() {}) => { $vis extern \"C\" fn $name() {} };\n+    ($vis:vis fn $name:ident() {}) => { $vis fn $name() {} };\n+    ($vis:vis mod $name:ident {}) => { $vis mod $name {} };\n+    ($vis:vis static $name:ident: $ty:ty = $e:expr;) => { $vis static $name: $ty = $e; };\n+    ($vis:vis struct $name:ident;) => { $vis struct $name; };\n+    ($vis:vis trait $name:ident {}) => { $vis trait $name {} };\n+    ($vis:vis type $name:ident = $ty:ty;) => { $vis type $name = $ty; };\n+    ($vis:vis use $path:ident as $name:ident;) => { $vis use self::$path as $name; };\n+}\n+\n+mod with_pub {\n+    vis_passthru! { pub const A: i32 = 0; }\n+    vis_passthru! { pub enum B {} }\n+    vis_passthru! { pub extern \"C\" fn c() {} }\n+    vis_passthru! { pub mod d {} }\n+    vis_passthru! { pub static E: i32 = 0; }\n+    vis_passthru! { pub struct F; }\n+    vis_passthru! { pub trait G {} }\n+    vis_passthru! { pub type H = i32; }\n+    vis_passthru! { pub use A as I; }\n+}\n+\n+mod without_pub {\n+    vis_passthru! { const A: i32 = 0; }\n+    vis_passthru! { enum B {} }\n+    vis_passthru! { extern \"C\" fn c() {} }\n+    vis_passthru! { mod d {} }\n+    vis_passthru! { static E: i32 = 0; }\n+    vis_passthru! { struct F; }\n+    vis_passthru! { trait G {} }\n+    vis_passthru! { type H = i32; }\n+    vis_passthru! { use A as I; }\n+}\n+\n+mod with_pub_restricted {\n+    vis_passthru! { pub(crate) const A: i32 = 0; }\n+    vis_passthru! { pub(crate) enum B {} }\n+    vis_passthru! { pub(crate) extern \"C\" fn c() {} }\n+    vis_passthru! { pub(crate) mod d {} }\n+    vis_passthru! { pub(crate) static E: i32 = 0; }\n+    vis_passthru! { pub(crate) struct F; }\n+    vis_passthru! { pub(crate) trait G {} }\n+    vis_passthru! { pub(crate) type H = i32; }\n+    vis_passthru! { pub(crate) use A as I; }\n+}\n+\n+mod garden {\n+    mod with_pub_restricted_path {\n+        vis_passthru! { pub(in garden) const A: i32 = 0; }\n+        vis_passthru! { pub(in garden) enum B {} }\n+        vis_passthru! { pub(in garden) extern \"C\" fn c() {} }\n+        vis_passthru! { pub(in garden) mod d {} }\n+        vis_passthru! { pub(in garden) static E: i32 = 0; }\n+        vis_passthru! { pub(in garden) struct F; }\n+        vis_passthru! { pub(in garden) trait G {} }\n+        vis_passthru! { pub(in garden) type H = i32; }\n+        vis_passthru! { pub(in garden) use A as I; }\n+    }\n+}\n+\n+/*\n+Ensure that the `:vis` matcher works in a more complex situation: parsing a\n+struct definition.\n+*/\n+macro_rules! vis_parse_struct {\n+    ($(#[$($attrs:tt)*])* $vis:vis struct $name:ident {$($body:tt)*}) => {\n+        vis_parse_struct! { @parse_fields $(#[$($attrs)*])*, $vis, $name, $($body)* }\n+    };\n+\n+    ($(#[$($attrs:tt)*])* $vis:vis struct $name:ident ($($body:tt)*);) => {\n+        vis_parse_struct! { @parse_tuple $(#[$($attrs)*])*, $vis, $name, $($body)* }\n+    };\n+\n+    (@parse_fields\n+     $(#[$attrs:meta])*, $vis:vis, $name:ident, $($fvis:vis $fname:ident: $fty:ty),* $(,)*) => {\n+        $(#[$attrs])* $vis struct $name { $($fvis $fname: $fty,)* }\n+    };\n+\n+    (@parse_tuple\n+     $(#[$attrs:meta])*, $vis:vis, $name:ident, $($fvis:vis $fty:ty),* $(,)*) => {\n+        $(#[$attrs])* $vis struct $name ( $($fvis $fty,)* );\n+    };\n+}\n+\n+mod test_struct {\n+    vis_parse_struct! { pub(crate) struct A { pub a: i32, b: i32, pub(crate) c: i32 } }\n+    vis_parse_struct! { pub struct B { a: i32, pub(crate) b: i32, pub c: i32 } }\n+    vis_parse_struct! { struct C { pub(crate) a: i32, pub b: i32, c: i32 } }\n+\n+    vis_parse_struct! { pub(crate) struct D (pub i32, i32, pub(crate) i32); }\n+    vis_parse_struct! { pub struct E (i32, pub(crate) i32, pub i32); }\n+    vis_parse_struct! { struct F (pub(crate) i32, pub i32, i32); }\n+}\n+\n+fn main() {}"}]}