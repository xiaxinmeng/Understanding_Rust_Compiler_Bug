{"sha": "d28a6c36e1d5ae1d83fa03b28a4861d6ac7786ff", "node_id": "C_kwDOAAsO6NoAKGQyOGE2YzM2ZTFkNWFlMWQ4M2ZhMDNiMjhhNDg2MWQ2YWM3Nzg2ZmY", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-10T16:13:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-10T16:13:05Z"}, "message": "minor: align code to code style\n\n(mutually recursive) data type definitions shall be at the start of the\nfile.", "tree": {"sha": "6db5de9a11a10f9855d83832b606e50ff657d0c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6db5de9a11a10f9855d83832b606e50ff657d0c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d28a6c36e1d5ae1d83fa03b28a4861d6ac7786ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d28a6c36e1d5ae1d83fa03b28a4861d6ac7786ff", "html_url": "https://github.com/rust-lang/rust/commit/d28a6c36e1d5ae1d83fa03b28a4861d6ac7786ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d28a6c36e1d5ae1d83fa03b28a4861d6ac7786ff/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "079e9fe49645fab8cb20a8cfb2da81915f018b04", "url": "https://api.github.com/repos/rust-lang/rust/commits/079e9fe49645fab8cb20a8cfb2da81915f018b04", "html_url": "https://github.com/rust-lang/rust/commit/079e9fe49645fab8cb20a8cfb2da81915f018b04"}], "stats": {"total": 145, "additions": 71, "deletions": 74}, "files": [{"sha": "f227c7a7dd8f58a89b5d5fda731a1a786a1f6275", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 71, "deletions": 74, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/d28a6c36e1d5ae1d83fa03b28a4861d6ac7786ff/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d28a6c36e1d5ae1d83fa03b28a4861d6ac7786ff/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=d28a6c36e1d5ae1d83fa03b28a4861d6ac7786ff", "patch": "@@ -62,19 +62,88 @@ enum HirFileIdRepr {\n     FileId(FileId),\n     MacroFile(MacroFile),\n }\n-\n impl From<FileId> for HirFileId {\n     fn from(id: FileId) -> Self {\n         HirFileId(HirFileIdRepr::FileId(id))\n     }\n }\n-\n impl From<MacroFile> for HirFileId {\n     fn from(id: MacroFile) -> Self {\n         HirFileId(HirFileIdRepr::MacroFile(id))\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroFile {\n+    pub macro_call_id: MacroCallId,\n+}\n+\n+/// `MacroCallId` identifies a particular macro invocation, like\n+/// `println!(\"Hello, {}\", world)`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroCallId(salsa::InternId);\n+impl_intern_key!(MacroCallId);\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MacroCallLoc {\n+    pub def: MacroDefId,\n+    pub(crate) krate: CrateId,\n+    eager: Option<EagerCallInfo>,\n+    pub kind: MacroCallKind,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroDefId {\n+    pub krate: CrateId,\n+    pub kind: MacroDefKind,\n+    pub local_inner: bool,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum MacroDefKind {\n+    Declarative(AstId<ast::Macro>),\n+    BuiltIn(BuiltinFnLikeExpander, AstId<ast::Macro>),\n+    // FIXME: maybe just Builtin and rename BuiltinFnLikeExpander to BuiltinExpander\n+    BuiltInAttr(BuiltinAttrExpander, AstId<ast::Macro>),\n+    BuiltInDerive(BuiltinDeriveExpander, AstId<ast::Macro>),\n+    BuiltInEager(EagerExpander, AstId<ast::Macro>),\n+    ProcMacro(ProcMacroExpander, ProcMacroKind, AstId<ast::Fn>),\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+struct EagerCallInfo {\n+    /// NOTE: This can be *either* the expansion result, *or* the argument to the eager macro!\n+    arg_or_expansion: Arc<tt::Subtree>,\n+    included_file: Option<FileId>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum MacroCallKind {\n+    FnLike {\n+        ast_id: AstId<ast::MacroCall>,\n+        expand_to: ExpandTo,\n+    },\n+    Derive {\n+        ast_id: AstId<ast::Item>,\n+        derive_name: String,\n+        /// Syntactical index of the invoking `#[derive]` attribute.\n+        ///\n+        /// Outer attributes are counted first, then inner attributes. This does not support\n+        /// out-of-line modules, which may have attributes spread across 2 files!\n+        derive_attr_index: u32,\n+    },\n+    Attr {\n+        ast_id: AstId<ast::Item>,\n+        attr_name: String,\n+        attr_args: (tt::Subtree, mbe::TokenMap),\n+        /// Syntactical index of the invoking `#[attribute]`.\n+        ///\n+        /// Outer attributes are counted first, then inner attributes. This does not support\n+        /// out-of-line modules, which may have attributes spread across 2 files!\n+        invoc_attr_index: u32,\n+    },\n+}\n+\n impl HirFileId {\n     /// For macro-expansion files, returns the file original source file the\n     /// expansion originated from.\n@@ -215,25 +284,6 @@ impl HirFileId {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroFile {\n-    pub macro_call_id: MacroCallId,\n-}\n-\n-/// `MacroCallId` identifies a particular macro invocation, like\n-/// `println!(\"Hello, {}\", world)`.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroCallId(salsa::InternId);\n-impl_intern_key!(MacroCallId);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroDefId {\n-    pub krate: CrateId,\n-    pub kind: MacroDefKind,\n-\n-    pub local_inner: bool,\n-}\n-\n impl MacroDefId {\n     pub fn as_lazy_macro(\n         self,\n@@ -261,59 +311,6 @@ impl MacroDefId {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum MacroDefKind {\n-    Declarative(AstId<ast::Macro>),\n-    BuiltIn(BuiltinFnLikeExpander, AstId<ast::Macro>),\n-    // FIXME: maybe just Builtin and rename BuiltinFnLikeExpander to BuiltinExpander\n-    BuiltInAttr(BuiltinAttrExpander, AstId<ast::Macro>),\n-    BuiltInDerive(BuiltinDeriveExpander, AstId<ast::Macro>),\n-    BuiltInEager(EagerExpander, AstId<ast::Macro>),\n-    ProcMacro(ProcMacroExpander, ProcMacroKind, AstId<ast::Fn>),\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-struct EagerCallInfo {\n-    /// NOTE: This can be *either* the expansion result, *or* the argument to the eager macro!\n-    arg_or_expansion: Arc<tt::Subtree>,\n-    included_file: Option<FileId>,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MacroCallLoc {\n-    pub def: MacroDefId,\n-    pub(crate) krate: CrateId,\n-    eager: Option<EagerCallInfo>,\n-    pub kind: MacroCallKind,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum MacroCallKind {\n-    FnLike {\n-        ast_id: AstId<ast::MacroCall>,\n-        expand_to: ExpandTo,\n-    },\n-    Derive {\n-        ast_id: AstId<ast::Item>,\n-        derive_name: String,\n-        /// Syntactical index of the invoking `#[derive]` attribute.\n-        ///\n-        /// Outer attributes are counted first, then inner attributes. This does not support\n-        /// out-of-line modules, which may have attributes spread across 2 files!\n-        derive_attr_index: u32,\n-    },\n-    Attr {\n-        ast_id: AstId<ast::Item>,\n-        attr_name: String,\n-        attr_args: (tt::Subtree, mbe::TokenMap),\n-        /// Syntactical index of the invoking `#[attribute]`.\n-        ///\n-        /// Outer attributes are counted first, then inner attributes. This does not support\n-        /// out-of-line modules, which may have attributes spread across 2 files!\n-        invoc_attr_index: u32,\n-    },\n-}\n-\n // FIXME: attribute indices do not account for `cfg_attr`, which means that we'll strip the whole\n // `cfg_attr` instead of just one of the attributes it expands to\n "}]}