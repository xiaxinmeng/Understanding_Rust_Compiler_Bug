{"sha": "0bb6eb15266b8476138860352d049da786f890f5", "node_id": "C_kwDOAAsO6NoAKDBiYjZlYjE1MjY2Yjg0NzYxMzg4NjAzNTJkMDQ5ZGE3ODZmODkwZjU", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-10-17T05:24:44Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-10-17T06:43:35Z"}, "message": "Eliminate 280-byte memset from ReadDir iterator", "tree": {"sha": "2fe0bc69fda8e712b3bc0e0fce6c2831c1573ac1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fe0bc69fda8e712b3bc0e0fce6c2831c1573ac1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bb6eb15266b8476138860352d049da786f890f5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmNM+ZcACgkQ+boUO5X/\nbYKi5BAAh/6gmd1SrJIqGlB9uD9QLnVgkngH9qazHGOmv+zg18nh2jG7v6Z734JG\naJ6xfD8d82V4AuYjmVe5N+H6CwdXrjmMB+1b30JE978KuTwhiPLFAkKIYWg1nWzq\nvt1HD8bu3bze1t3FKNS6/y7OiNbnhQ8iuB5HkYMXEm2xQAszjSYcBVF8/DR42RWr\nEHSQ2e92n/JC92zSll2xW7NBZrajtHBJalyrH3odaRcTep4/doJvs+HgXsELB4yk\nwym9AN25vwxRN4v6FKGg2MvPI7LtYHTaj1ciofP9Giz5SaL85tzBxVUO3BcmGoR+\nyjXONlddnA3jTmk8RPjrmn4y0tz2B9HBl4XKSzxQSCM8g6Xbuu5CPgUbGqV9GC7d\nIuysmqwLyInIWijD962z6IJbwZZZvaHggcligBQNImlKrrkuaqewrgb2hBY+dMhI\nBPgxam2eJrRgdQgFlqw9HeRElL6Q9TWfP/FmhPe28+3NGO5cTO6JPn/a2A0omO0Y\nq6omudxd4bVWFf1D0I3v4zvXjBhUu83H7ANLVysCK/LmvO0ZvJnlLCKqrN2vcZD5\n8a6PK56Cn+Nwt0qvLpSkSkuFn045xMRMn7+g6AVNDiwKzHGGXDwkrPQi0x83g+f9\n/VOLpv51CTpb3+zGoJYz8v6LBI852JALHGTdug5y9LEJPJkusOs=\n=rchm\n-----END PGP SIGNATURE-----", "payload": "tree 2fe0bc69fda8e712b3bc0e0fce6c2831c1573ac1\nparent a501e6699ed979ef0540949211fc28256336a3f3\nauthor David Tolnay <dtolnay@gmail.com> 1665984284 -0700\ncommitter David Tolnay <dtolnay@gmail.com> 1665989015 -0700\n\nEliminate 280-byte memset from ReadDir iterator\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb6eb15266b8476138860352d049da786f890f5", "html_url": "https://github.com/rust-lang/rust/commit/0bb6eb15266b8476138860352d049da786f890f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bb6eb15266b8476138860352d049da786f890f5/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a501e6699ed979ef0540949211fc28256336a3f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a501e6699ed979ef0540949211fc28256336a3f3", "html_url": "https://github.com/rust-lang/rust/commit/a501e6699ed979ef0540949211fc28256336a3f3"}], "stats": {"total": 85, "additions": 65, "deletions": 20}, "files": [{"sha": "d023c87bd269b755d002480d606adf96c165105c", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 65, "deletions": 20, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6eb15266b8476138860352d049da786f890f5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6eb15266b8476138860352d049da786f890f5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=0bb6eb15266b8476138860352d049da786f890f5", "patch": "@@ -4,6 +4,15 @@ use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io::{self, BorrowedCursor, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"linux\",\n+    target_os = \"solaris\",\n+    target_os = \"fuchsia\",\n+    target_os = \"redox\",\n+    target_os = \"illumos\"\n+))]\n+use crate::mem::MaybeUninit;\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n@@ -584,33 +593,69 @@ impl Iterator for ReadDir {\n                     };\n                 }\n \n-                // Only d_reclen bytes of *entry_ptr are valid, so we can't just copy the\n-                // whole thing (#93384).  Instead, copy everything except the name.\n-                let mut copy: dirent64 = mem::zeroed();\n-                // Can't dereference entry_ptr, so use the local entry to get\n-                // offsetof(struct dirent, d_name)\n-                let copy_bytes = &mut copy as *mut _ as *mut u8;\n-                let copy_name = &mut copy.d_name as *mut _ as *mut u8;\n-                let name_offset = copy_name.offset_from(copy_bytes) as usize;\n-                let entry_bytes = entry_ptr as *const u8;\n-                let entry_name = entry_bytes.add(name_offset);\n-                ptr::copy_nonoverlapping(entry_bytes, copy_bytes, name_offset);\n+                // The dirent64 struct is a weird imaginary thing that isn't ever supposed\n+                // to be worked with by value. Its trailing d_name field is declared\n+                // variously as [c_char; 256] or [c_char; 1] on different systems but\n+                // either way that size is meaningless; only the offset of d_name is\n+                // meaningful. The dirent64 pointers that libc returns from readdir64 are\n+                // allowed to point to allocations smaller _or_ LARGER than implied by the\n+                // definition of the struct.\n+                //\n+                // As such, we need to be even more careful with dirent64 than if its\n+                // contents were \"simply\" partially initialized data.\n+                //\n+                // Like for uninitialized contents, converting entry_ptr to `&dirent64`\n+                // would not be legal. However, unique to dirent64 is that we don't even\n+                // get to use `addr_of!((*entry_ptr).d_name)` because that operation\n+                // requires the full extent of *entry_ptr to be in bounds of the same\n+                // allocation, which is not necessarily the case here.\n+                //\n+                // Absent any other way to obtain a pointer to `(*entry_ptr).d_name`\n+                // legally in Rust analogously to how it would be done in C, we instead\n+                // need to make our own non-libc allocation that conforms to the weird\n+                // imaginary definition of dirent64, and use that for a field offset\n+                // computation.\n+                macro_rules! offset_ptr {\n+                    ($entry_ptr:expr, $field:ident) => {{\n+                        const OFFSET: isize = {\n+                            let delusion = MaybeUninit::<dirent64>::uninit();\n+                            let entry_ptr = delusion.as_ptr();\n+                            unsafe {\n+                                ptr::addr_of!((*entry_ptr).$field)\n+                                    .cast::<u8>()\n+                                    .offset_from(entry_ptr.cast::<u8>())\n+                            }\n+                        };\n+                        if true {\n+                            // Cast to the same type determined by the else branch.\n+                            $entry_ptr.byte_offset(OFFSET).cast::<_>()\n+                        } else {\n+                            #[allow(deref_nullptr)]\n+                            {\n+                                ptr::addr_of!((*ptr::null::<dirent64>()).$field)\n+                            }\n+                        }\n+                    }};\n+                }\n+\n+                // d_name is guaranteed to be null-terminated.\n+                let name = CStr::from_ptr(offset_ptr!(entry_ptr, d_name).cast());\n+                let name_bytes = name.to_bytes();\n+                if name_bytes == b\".\" || name_bytes == b\"..\" {\n+                    continue;\n+                }\n \n                 let entry = dirent64_min {\n-                    d_ino: copy.d_ino as u64,\n+                    d_ino: *offset_ptr!(entry_ptr, d_ino) as u64,\n                     #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\")))]\n-                    d_type: copy.d_type as u8,\n+                    d_type: *offset_ptr!(entry_ptr, d_type) as u8,\n                 };\n \n-                let ret = DirEntry {\n+                return Some(Ok(DirEntry {\n                     entry,\n-                    // d_name is guaranteed to be null-terminated.\n-                    name: CStr::from_ptr(entry_name as *const _).to_owned(),\n+                    name: name.to_owned(),\n                     dir: Arc::clone(&self.inner),\n-                };\n-                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n-                    return Some(Ok(ret));\n-                }\n+                }));\n             }\n         }\n     }"}]}