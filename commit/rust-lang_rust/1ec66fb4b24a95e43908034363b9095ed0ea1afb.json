{"sha": "1ec66fb4b24a95e43908034363b9095ed0ea1afb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYzY2ZmI0YjI0YTk1ZTQzOTA4MDM0MzYzYjkwOTVlZDBlYTFhZmI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-30T14:26:48Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-30T14:26:48Z"}, "message": "apply comments", "tree": {"sha": "41f53ba961d5ab27720e00c101f2ceb8811617ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41f53ba961d5ab27720e00c101f2ceb8811617ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ec66fb4b24a95e43908034363b9095ed0ea1afb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec66fb4b24a95e43908034363b9095ed0ea1afb", "html_url": "https://github.com/rust-lang/rust/commit/1ec66fb4b24a95e43908034363b9095ed0ea1afb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ec66fb4b24a95e43908034363b9095ed0ea1afb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc63113f1fca416e88cafa10670f7743aaa82759", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc63113f1fca416e88cafa10670f7743aaa82759", "html_url": "https://github.com/rust-lang/rust/commit/fc63113f1fca416e88cafa10670f7743aaa82759"}], "stats": {"total": 41, "additions": 23, "deletions": 18}, "files": [{"sha": "bb4297e5493c965d65a12e079c1a55fc1da22df9", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ec66fb4b24a95e43908034363b9095ed0ea1afb/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec66fb4b24a95e43908034363b9095ed0ea1afb/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=1ec66fb4b24a95e43908034363b9095ed0ea1afb", "patch": "@@ -1024,10 +1024,9 @@ extern \"rust-intrinsic\" {\n     ///         // not alias, and two different vectors cannot own the same\n     ///         // memory.\n     ///         ptr::copy_nonoverlapping(src, dst, src_len);\n-    ///     }\n     ///\n-    ///     unsafe {\n-    ///         // Truncate `src` without dropping its contents.\n+    ///         // Truncate `src` without dropping its contents. This cannot panic,\n+    ///         // so double-drops cannot happen.\n     ///         src.set_len(0);\n     ///\n     ///         // Notify `dst` that it now holds the contents of `src`.\n@@ -1054,7 +1053,9 @@ extern \"rust-intrinsic\" {\n     /// If the source and destination will *never* overlap,\n     /// [`copy_nonoverlapping`] can be used instead.\n     ///\n-    /// `copy` is semantically equivalent to C's [`memmove`].\n+    /// `copy` is semantically equivalent to C's [`memmove`].  Copying takes place as\n+    /// if the bytes were copied from `src` to a temporary array and then copied from\n+    /// the array to `dst`-\n     ///\n     /// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n     /// [`memmove`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memmove\n@@ -1143,7 +1144,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Creating an invalid value:\n     ///\n-    /// ```no_run\n+    /// ```\n     /// use std::ptr;\n     ///\n     /// let mut v = Box::new(0i32);\n@@ -1155,7 +1156,10 @@ extern \"rust-intrinsic\" {\n     /// }\n     ///\n     /// // At this point, using or dropping `v` results in undefined behavior.\n-    /// // v = Box::new(0i32); // ERROR\n+    /// // drop(v); // ERROR\n+    ///\n+    /// // Leaking it does not invoke drop and is fine:\n+    /// mem::forget(v)\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);"}, {"sha": "2b51e321cbdab5138fece23c7e9c0eb807546ced", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1ec66fb4b24a95e43908034363b9095ed0ea1afb/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec66fb4b24a95e43908034363b9095ed0ea1afb/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=1ec66fb4b24a95e43908034363b9095ed0ea1afb", "patch": "@@ -274,7 +274,8 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n ///   size_of::<T>()` bytes must *not* overlap with the region of memory\n ///   beginning at `y` with the same size.\n ///\n-/// Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.\n+/// Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`,\n+/// the pointers must be non-NULL and properly aligned.\n ///\n /// [valid]: ../ptr/index.html#safety\n ///\n@@ -369,7 +370,7 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     }\n }\n \n-/// Moves `src` into the pointed `dest`, returning the previous `dest` value.\n+/// Moves `src` into the pointed `dst`, returning the previous `dst` value.\n ///\n /// Neither value is dropped.\n ///\n@@ -383,9 +384,9 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `dest` must be [valid] for writes.\n+/// * `dst` must be [valid] for writes.\n ///\n-/// * `dest` must be properly aligned.\n+/// * `dst` must be properly aligned.\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n@@ -409,8 +410,8 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n-    mem::swap(&mut *dest, &mut src); // cannot overlap\n+pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n+    mem::swap(&mut *dst, &mut src); // cannot overlap\n     src\n }\n \n@@ -447,8 +448,8 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///\n /// let mut s = String::from(\"foo\");\n /// unsafe {\n-///     // `s2` now points to the same underlying memory as `s1`.\n-///     let mut s2 = ptr::read(&s);\n+///     // `s2` now points to the same underlying memory as `s`.\n+///     let mut s2: String = ptr::read(&s);\n ///\n ///     assert_eq!(s2, \"foo\");\n ///\n@@ -558,7 +559,6 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// use std::ptr;\n ///\n /// #[repr(packed, C)]\n-/// #[derive(Default)]\n /// struct Packed {\n ///     _padding: u8,\n ///     unaligned: u32,\n@@ -570,10 +570,11 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// };\n ///\n /// let v = unsafe {\n-///     // Take a reference to a 32-bit integer which is not aligned.\n-///     let unaligned = &x.unaligned;\n+///     // Take the address of a 32-bit integer which is not aligned.\n+///     // This must be done as a raw pointer; unaligned references are invalid.\n+///     let unaligned = &x.unaligned as *const u32;\n ///\n-///     // Dereferencing normally will emit an unaligned load instruction,\n+///     // Dereferencing normally will emit an aligned load instruction,\n ///     // causing undefined behavior.\n ///     // let v = *unaligned; // ERROR\n ///"}]}