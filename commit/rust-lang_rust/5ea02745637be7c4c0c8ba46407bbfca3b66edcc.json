{"sha": "5ea02745637be7c4c0c8ba46407bbfca3b66edcc", "node_id": "C_kwDOAAsO6NoAKDVlYTAyNzQ1NjM3YmU3YzRjMGM4YmE0NjQwN2JiZmNhM2I2NmVkY2M", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-10-23T03:28:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-23T03:28:19Z"}, "message": "Rollup merge of #83233 - jethrogb:split_array, r=yaahc\n\nImplement split_array and split_array_mut\n\nThis implements `[T]::split_array::<const N>() -> (&[T; N], &[T])` and `[T; N]::split_array::<const M>() -> (&[T; M], &[T])` and their mutable equivalents. These are another few \u201cmissing\u201d array implementations now that const generics are a thing, similar to #74373, #75026, etc. Fixes #74674.\n\nThis implements `[T; N]::split_array` returning an array and a slice. Ultimately, this is probably not what we want, we would want the second return value to be an array of length N-M, which will likely be possible with future const generics enhancements. We need to implement the array method now though, to immediately shadow the slice method. This way, when the slice methods get stabilized, calling them on an array will not be automatic through coercion, so we won't have trouble stabilizing the array methods later (cf. into_iter debacle).\n\nAn unchecked version of `[T]::split_array` could also be added as in #76014. This would not be needed for `[T; N]::split_array` as that can be compile-time checked. Edit: actually, since split_at_unchecked is internal-only it could be changed to be split_array-only.", "tree": {"sha": "991afed0745bc8e2f1816060d8d820c819975f32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/991afed0745bc8e2f1816060d8d820c819975f32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ea02745637be7c4c0c8ba46407bbfca3b66edcc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhc4FTCRBK7hj4Ov3rIwAA06QIAE92PhNmeswjD3oQ7FnFExph\nmuWikmlXnWXXaULD8y58nyJs/bnmVboOySf249KX2y98DpvugZNBwOkZ098jRP3X\n1sB0XGj8cfR95kqm8rBrcDZvDw5mYksBdAonQmHlpC/VNNSyklNksQgpWfcyqGqO\nYKVDmpAIlRpsEvx4qraURJvTRR9Rsyf+iYAopFSDyW3TSJEx/eAk9FllvmM22l9d\nM3g1uHlbje4jlPxC5vN+UYhRsdB8OXovBTDjn4CAlrreGal/QevIhctwaK8ZmlmL\nNhnIe/GIUx2IAKX+7T8REgZ8bKR46+pkQlXUbI1j7PPsNJmVX3y4DeSUVGdN7ZI=\n=I269\n-----END PGP SIGNATURE-----\n", "payload": "tree 991afed0745bc8e2f1816060d8d820c819975f32\nparent 514b3877956dc594823106b66c164f8cdbc8b3da\nparent 4a439769ecd292106d62270d171568ac7aa0164b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1634959699 +0200\ncommitter GitHub <noreply@github.com> 1634959699 +0200\n\nRollup merge of #83233 - jethrogb:split_array, r=yaahc\n\nImplement split_array and split_array_mut\n\nThis implements `[T]::split_array::<const N>() -> (&[T; N], &[T])` and `[T; N]::split_array::<const M>() -> (&[T; M], &[T])` and their mutable equivalents. These are another few \u201cmissing\u201d array implementations now that const generics are a thing, similar to #74373, #75026, etc. Fixes #74674.\n\nThis implements `[T; N]::split_array` returning an array and a slice. Ultimately, this is probably not what we want, we would want the second return value to be an array of length N-M, which will likely be possible with future const generics enhancements. We need to implement the array method now though, to immediately shadow the slice method. This way, when the slice methods get stabilized, calling them on an array will not be automatic through coercion, so we won't have trouble stabilizing the array methods later (cf. into_iter debacle).\n\nAn unchecked version of `[T]::split_array` could also be added as in #76014. This would not be needed for `[T; N]::split_array` as that can be compile-time checked. Edit: actually, since split_at_unchecked is internal-only it could be changed to be split_array-only.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ea02745637be7c4c0c8ba46407bbfca3b66edcc", "html_url": "https://github.com/rust-lang/rust/commit/5ea02745637be7c4c0c8ba46407bbfca3b66edcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ea02745637be7c4c0c8ba46407bbfca3b66edcc/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "514b3877956dc594823106b66c164f8cdbc8b3da", "url": "https://api.github.com/repos/rust-lang/rust/commits/514b3877956dc594823106b66c164f8cdbc8b3da", "html_url": "https://github.com/rust-lang/rust/commit/514b3877956dc594823106b66c164f8cdbc8b3da"}, {"sha": "4a439769ecd292106d62270d171568ac7aa0164b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a439769ecd292106d62270d171568ac7aa0164b", "html_url": "https://github.com/rust-lang/rust/commit/4a439769ecd292106d62270d171568ac7aa0164b"}], "stats": {"total": 219, "additions": 219, "deletions": 0}, "files": [{"sha": "73340fda2cbccc26b2a387039dabdb757a484534", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5ea02745637be7c4c0c8ba46407bbfca3b66edcc/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea02745637be7c4c0c8ba46407bbfca3b66edcc/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=5ea02745637be7c4c0c8ba46407bbfca3b66edcc", "patch": "@@ -500,6 +500,84 @@ impl<T, const N: usize> [T; N] {\n         // items.\n         unsafe { collect_into_array_unchecked(&mut self.iter_mut()) }\n     }\n+\n+    /// Divides one array reference into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, M)` (excluding\n+    /// the index `M` itself) and the second will contain all\n+    /// indices from `[M, N)` (excluding the index `N` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `M > N`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_array)]\n+    ///\n+    /// let v = [1, 2, 3, 4, 5, 6];\n+    ///\n+    /// {\n+    ///    let (left, right) = v.split_array_ref::<0>();\n+    ///    assert_eq!(left, &[]);\n+    ///    assert_eq!(right, &[1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_array_ref::<2>();\n+    ///     assert_eq!(left, &[1, 2]);\n+    ///     assert_eq!(right, &[3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_array_ref::<6>();\n+    ///     assert_eq!(left, &[1, 2, 3, 4, 5, 6]);\n+    ///     assert_eq!(right, &[]);\n+    /// }\n+    /// ```\n+    #[unstable(\n+        feature = \"split_array\",\n+        reason = \"return type should have array as 2nd element\",\n+        issue = \"90091\"\n+    )]\n+    #[inline]\n+    pub fn split_array_ref<const M: usize>(&self) -> (&[T; M], &[T]) {\n+        (&self[..]).split_array_ref::<M>()\n+    }\n+\n+    /// Divides one mutable array reference into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, M)` (excluding\n+    /// the index `M` itself) and the second will contain all\n+    /// indices from `[M, N)` (excluding the index `N` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `M > N`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_array)]\n+    ///\n+    /// let mut v = [1, 0, 3, 0, 5, 6];\n+    /// let (left, right) = v.split_array_mut::<2>();\n+    /// assert_eq!(left, &mut [1, 0][..]);\n+    /// assert_eq!(right, &mut [3, 0, 5, 6]);\n+    /// left[1] = 2;\n+    /// right[1] = 4;\n+    /// assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n+    /// ```\n+    #[unstable(\n+        feature = \"split_array\",\n+        reason = \"return type should have array as 2nd element\",\n+        issue = \"90091\"\n+    )]\n+    #[inline]\n+    pub fn split_array_mut<const M: usize>(&mut self) -> (&mut [T; M], &mut [T]) {\n+        (&mut self[..]).split_array_mut::<M>()\n+    }\n }\n \n /// Pulls `N` items from `iter` and returns them as an array. If the iterator"}, {"sha": "aaa00653b99c274cc6fda272fe74402d3143bfaa", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5ea02745637be7c4c0c8ba46407bbfca3b66edcc/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea02745637be7c4c0c8ba46407bbfca3b66edcc/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=5ea02745637be7c4c0c8ba46407bbfca3b66edcc", "patch": "@@ -1665,6 +1665,80 @@ impl<T> [T] {\n         unsafe { (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid)) }\n     }\n \n+    /// Divides one slice into an array and a remainder slice at an index.\n+    ///\n+    /// The array will contain all indices from `[0, N)` (excluding\n+    /// the index `N` itself) and the slice will contain all\n+    /// indices from `[N, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `N > len`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_array)]\n+    ///\n+    /// let v = &[1, 2, 3, 4, 5, 6][..];\n+    ///\n+    /// {\n+    ///    let (left, right) = v.split_array_ref::<0>();\n+    ///    assert_eq!(left, &[]);\n+    ///    assert_eq!(right, [1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_array_ref::<2>();\n+    ///     assert_eq!(left, &[1, 2]);\n+    ///     assert_eq!(right, [3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_array_ref::<6>();\n+    ///     assert_eq!(left, &[1, 2, 3, 4, 5, 6]);\n+    ///     assert_eq!(right, []);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"split_array\", reason = \"new API\", issue = \"90091\")]\n+    #[inline]\n+    pub fn split_array_ref<const N: usize>(&self) -> (&[T; N], &[T]) {\n+        let (a, b) = self.split_at(N);\n+        // SAFETY: a points to [T; N]? Yes it's [T] of length N (checked by split_at)\n+        unsafe { (&*(a.as_ptr() as *const [T; N]), b) }\n+    }\n+\n+    /// Divides one mutable slice into an array and a remainder slice at an index.\n+    ///\n+    /// The array will contain all indices from `[0, N)` (excluding\n+    /// the index `N` itself) and the slice will contain all\n+    /// indices from `[N, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `N > len`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_array)]\n+    ///\n+    /// let mut v = &mut [1, 0, 3, 0, 5, 6][..];\n+    /// let (left, right) = v.split_array_mut::<2>();\n+    /// assert_eq!(left, &mut [1, 0]);\n+    /// assert_eq!(right, [3, 0, 5, 6]);\n+    /// left[1] = 2;\n+    /// right[1] = 4;\n+    /// assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n+    /// ```\n+    #[unstable(feature = \"split_array\", reason = \"new API\", issue = \"90091\")]\n+    #[inline]\n+    pub fn split_array_mut<const N: usize>(&mut self) -> (&mut [T; N], &mut [T]) {\n+        let (a, b) = self.split_at_mut(N);\n+        // SAFETY: a points to [T; N]? Yes it's [T] of length N (checked by split_at_mut)\n+        unsafe { (&mut *(a.as_mut_ptr() as *mut [T; N]), b) }\n+    }\n+\n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`. The matched element is not contained in the subslices.\n     ///"}, {"sha": "1d4307ca0fbda2bc54484822c0a2ce5ba9ad81d7", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5ea02745637be7c4c0c8ba46407bbfca3b66edcc/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea02745637be7c4c0c8ba46407bbfca3b66edcc/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=5ea02745637be7c4c0c8ba46407bbfca3b66edcc", "patch": "@@ -436,3 +436,36 @@ where\n     std::panic::set_hook(prev_hook);\n     result\n }\n+\n+#[test]\n+fn array_split_array_mut() {\n+    let mut v = [1, 2, 3, 4, 5, 6];\n+\n+    {\n+        let (left, right) = v.split_array_mut::<0>();\n+        assert_eq!(left, &mut []);\n+        assert_eq!(right, &mut [1, 2, 3, 4, 5, 6]);\n+    }\n+\n+    {\n+        let (left, right) = v.split_array_mut::<6>();\n+        assert_eq!(left, &mut [1, 2, 3, 4, 5, 6]);\n+        assert_eq!(right, &mut []);\n+    }\n+}\n+\n+#[should_panic]\n+#[test]\n+fn array_split_array_ref_out_of_bounds() {\n+    let v = [1, 2, 3, 4, 5, 6];\n+\n+    v.split_array_ref::<7>();\n+}\n+\n+#[should_panic]\n+#[test]\n+fn array_split_array_mut_out_of_bounds() {\n+    let mut v = [1, 2, 3, 4, 5, 6];\n+\n+    v.split_array_mut::<7>();\n+}"}, {"sha": "507a79c3de1c480b2f01bdb7b8d9727d93295baa", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ea02745637be7c4c0c8ba46407bbfca3b66edcc/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea02745637be7c4c0c8ba46407bbfca3b66edcc/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=5ea02745637be7c4c0c8ba46407bbfca3b66edcc", "patch": "@@ -70,6 +70,7 @@\n #![feature(integer_atomics)]\n #![feature(int_roundings)]\n #![feature(slice_group_by)]\n+#![feature(split_array)]\n #![feature(trusted_random_access)]\n #![feature(unsize)]\n #![feature(unzip_option)]"}, {"sha": "7a008345243c0d6265bd254adf3313fa6431188b", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5ea02745637be7c4c0c8ba46407bbfca3b66edcc/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea02745637be7c4c0c8ba46407bbfca3b66edcc/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=5ea02745637be7c4c0c8ba46407bbfca3b66edcc", "patch": "@@ -2191,3 +2191,36 @@ mod swap_panics {\n         x.swap(2, 5);\n     }\n }\n+\n+#[test]\n+fn slice_split_array_mut() {\n+    let v = &mut [1, 2, 3, 4, 5, 6][..];\n+\n+    {\n+        let (left, right) = v.split_array_mut::<0>();\n+        assert_eq!(left, &mut []);\n+        assert_eq!(right, [1, 2, 3, 4, 5, 6]);\n+    }\n+\n+    {\n+        let (left, right) = v.split_array_mut::<6>();\n+        assert_eq!(left, &mut [1, 2, 3, 4, 5, 6]);\n+        assert_eq!(right, []);\n+    }\n+}\n+\n+#[should_panic]\n+#[test]\n+fn slice_split_array_ref_out_of_bounds() {\n+    let v = &[1, 2, 3, 4, 5, 6][..];\n+\n+    v.split_array_ref::<7>();\n+}\n+\n+#[should_panic]\n+#[test]\n+fn slice_split_array_mut_out_of_bounds() {\n+    let v = &mut [1, 2, 3, 4, 5, 6][..];\n+\n+    v.split_array_mut::<7>();\n+}"}]}