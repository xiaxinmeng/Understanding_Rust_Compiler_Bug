{"sha": "8787a12334439d47e931be26fef53381ce337c3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ODdhMTIzMzQ0MzlkNDdlOTMxYmUyNmZlZjUzMzgxY2UzMzdjM2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-11T20:14:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-11T20:14:28Z"}, "message": "Auto merge of #35592 - jonathandturner:rollup, r=jonathandturner\n\nRollup of 23 pull requests\n\n- Successful merges: #35279, #35331, #35358, #35375, #35445, #35448, #35482, #35486, #35505, #35528, #35530, #35532, #35536, #35537, #35541, #35552, #35554, #35555, #35557, #35562, #35565, #35569, #35576\n- Failed merges: #35395, #35415, #35563", "tree": {"sha": "fddfaef8f238490b3801ccb14222c31c01944e3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fddfaef8f238490b3801ccb14222c31c01944e3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8787a12334439d47e931be26fef53381ce337c3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8787a12334439d47e931be26fef53381ce337c3a", "html_url": "https://github.com/rust-lang/rust/commit/8787a12334439d47e931be26fef53381ce337c3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8787a12334439d47e931be26fef53381ce337c3a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11f880588791930cb130071c2cb972fc3c3354ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/11f880588791930cb130071c2cb972fc3c3354ed", "html_url": "https://github.com/rust-lang/rust/commit/11f880588791930cb130071c2cb972fc3c3354ed"}, {"sha": "d3af9a38eda71e6440423a1627f216acc0cc45f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3af9a38eda71e6440423a1627f216acc0cc45f4", "html_url": "https://github.com/rust-lang/rust/commit/d3af9a38eda71e6440423a1627f216acc0cc45f4"}], "stats": {"total": 919, "additions": 543, "deletions": 376}, "files": [{"sha": "6de43f471d8860229cb72c236b260d9303de1553", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -57,6 +57,7 @@ __pycache__/\n .project\n .settings/\n .valgrindrc\n+.vscode/\n /*-*-*-*/\n /*-*-*/\n /Makefile"}, {"sha": "c06bde6222ac8410fe9ad6ebdd0c4464da9c2059", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -1180,7 +1180,7 @@ impl String {\n     #[inline]\n     #[unstable(feature = \"insert_str\",\n                reason = \"recent addition\",\n-               issue = \"0\")]\n+               issue = \"35553\")]\n     pub fn insert_str(&mut self, idx: usize, string: &str) {\n         let len = self.len();\n         assert!(idx <= len);"}, {"sha": "c916ad930ff105988b7be772c07b45a595f3aa25", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -229,14 +229,28 @@ macro_rules! try {\n     })\n }\n \n-/// Use the `format!` syntax to write data into a buffer.\n+/// Write formatted data into a buffer\n ///\n-/// This macro is typically used with a buffer of `&mut `[`Write`][write].\n+/// This macro accepts any value with `write_fmt` method as a writer, a format string, and a list\n+/// of arguments to format.\n+///\n+/// `write_fmt` method usually comes from an implementation of [`std::fmt::Write`][fmt_write] or\n+/// [`std::io::Write`][io_write] traits. These are sometimes called 'writers'.\n+///\n+/// Passed arguments will be formatted according to the specified format string and the resulting\n+/// string will be passed to the writer.\n ///\n /// See [`std::fmt`][fmt] for more information on format syntax.\n ///\n+/// Return value is completely dependent on the 'write_fmt' method.\n+///\n+/// Common return values are: [`Result`][enum_result], [`io::Result`][type_result]\n+///\n /// [fmt]: ../std/fmt/index.html\n-/// [write]: ../std/io/trait.Write.html\n+/// [fmt_write]: ../std/fmt/trait.Write.html\n+/// [io_write]: ../std/io/trait.Write.html\n+/// [enum_result]: ../std/result/enum.Result.html\n+/// [type_result]: ../std/io/type.Result.html\n ///\n /// # Examples\n ///\n@@ -255,16 +269,31 @@ macro_rules! write {\n     ($dst:expr, $($arg:tt)*) => ($dst.write_fmt(format_args!($($arg)*)))\n }\n \n-/// Use the `format!` syntax to write data into a buffer, appending a newline.\n-/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`)\n-/// alone (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n+/// Write formatted data into a buffer, with appending a newline.\n+///\n+/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n+/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n ///\n-/// This macro is typically used with a buffer of `&mut `[`Write`][write].\n+/// This macro accepts any value with `write_fmt` method as a writer, a format string, and a list\n+/// of arguments to format.\n+///\n+/// `write_fmt` method usually comes from an implementation of [`std::fmt::Write`][fmt_write] or\n+/// [`std::io::Write`][io_write] traits. These are sometimes called 'writers'.\n+///\n+/// Passed arguments will be formatted according to the specified format string and the resulting\n+/// string will be passed to the writer.\n ///\n /// See [`std::fmt`][fmt] for more information on format syntax.\n ///\n+/// Return value is completely dependent on the 'write_fmt' method.\n+///\n+/// Common return values are: [`Result`][enum_result], [`io::Result`][type_result]\n+///\n /// [fmt]: ../std/fmt/index.html\n-/// [write]: ../std/io/trait.Write.html\n+/// [fmt_write]: ../std/fmt/trait.Write.html\n+/// [io_write]: ../std/io/trait.Write.html\n+/// [enum_result]: ../std/result/enum.Result.html\n+/// [type_result]: ../std/io/type.Result.html\n ///\n /// # Examples\n ///"}, {"sha": "c7ca70fc1622d8ea2d811d5a81d2c54bd9104e5e", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -402,8 +402,8 @@ impl<T, E> Result<T, E> {\n     /// ```\n     /// fn mutate(r: &mut Result<i32, i32>) {\n     ///     match r.as_mut() {\n-    ///         Ok(&mut ref mut v) => *v = 42,\n-    ///         Err(&mut ref mut e) => *e = 0,\n+    ///         Ok(v) => *v = 42,\n+    ///         Err(e) => *e = 0,\n     ///     }\n     /// }\n     ///"}, {"sha": "3ca6cf039979705cc09477902e3912c270daf7d2", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -63,9 +63,11 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n         match self.unsafe_context.root {\n             SafeContext => {\n                 // Report an error.\n-                span_err!(self.tcx.sess, span, E0133,\n-                          \"{} requires unsafe function or block\",\n-                          description);\n+                struct_span_err!(\n+                    self.tcx.sess, span, E0133,\n+                    \"{} requires unsafe function or block\", description)\n+                    .span_label(span, &format!(\"unsafe call requires unsafe function or block\"))\n+                    .emit();\n             }\n             UnsafeBlock(block_id) => {\n                 // OK, but record this."}, {"sha": "aa74fb2e02fa0b77feb0243f86779a503e48d615", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -718,10 +718,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let lifetime_j = &lifetimes[j];\n \n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n-                    span_err!(self.sess, lifetime_j.lifetime.span, E0263,\n-                        \"lifetime name `{}` declared twice in \\\n-                                the same scope\",\n-                                lifetime_j.lifetime.name);\n+                    struct_span_err!(self.sess, lifetime_j.lifetime.span, E0263,\n+                                     \"lifetime name `{}` declared twice in the same scope\",\n+                                     lifetime_j.lifetime.name)\n+                        .span_label(lifetime_j.lifetime.span,\n+                                    &format!(\"declared twice\"))\n+                        .span_label(lifetime_i.lifetime.span,\n+                                   &format!(\"previous declaration here\"))\n+                        .emit();\n                 }\n             }\n "}, {"sha": "62a31133a5499b33a21ba1898a01e9d0cfde226d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -654,6 +654,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let mut err = struct_span_err!(self.sess, span, E0072,\n                                        \"recursive type `{}` has infinite size\",\n                                        self.item_path_str(type_def_id));\n+        err.span_label(span, &format!(\"recursive type has infinite size\"));\n         err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n                            at some point to make `{}` representable\",\n                           self.item_path_str(type_def_id)));\n@@ -670,10 +671,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let mut err = match warning_node_id {\n             Some(_) => None,\n             None => {\n-                Some(struct_span_err!(\n-                    self.sess, span, E0038,\n-                    \"the trait `{}` cannot be made into an object\",\n-                    self.item_path_str(trait_def_id)))\n+                let trait_str = self.item_path_str(trait_def_id);\n+                let mut db = struct_span_err!(\n+                            self.sess, span, E0038,\n+                            \"the trait `{}` cannot be made into an object\",\n+                            trait_str);\n+                db.span_label(span,\n+                              &format!(\"the trait `{}` cannot be made \\\n+                              into an object\", trait_str));\n+                Some(db)\n             }\n         };\n "}, {"sha": "e0cbd972bd37f9f3c62fc9d65e26b18bb47915af", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -760,12 +760,16 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                 lp: &LoanPath<'tcx>,\n                                                 assign:\n                                                 &move_data::Assignment) {\n-        struct_span_err!(\n+        let mut err = struct_span_err!(\n             self.tcx.sess, span, E0384,\n             \"re-assignment of immutable variable `{}`\",\n-            self.loan_path_to_string(lp))\n-            .span_note(assign.span, \"prior assignment occurs here\")\n-            .emit();\n+            self.loan_path_to_string(lp));\n+        err.span_label(span, &format!(\"re-assignment of immutable variable\"));\n+        if span != assign.span {\n+            err.span_label(assign.span, &format!(\"first assignment to `{}`\",\n+                                              self.loan_path_to_string(lp)));\n+        }\n+        err.emit();\n     }\n \n     pub fn span_err(&self, s: Span, m: &str) {"}, {"sha": "5fe4830c365ef4c55871f518553092e98a01f52b", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -235,12 +235,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 .flat_map(|arm| &arm.0)\n                 .map(|pat| vec![wrap_pat(cx, &pat)])\n                 .collect();\n-            let match_span = Span {\n-                lo: ex.span.lo,\n-                hi: scrut.span.hi,\n-                expn_id: ex.span.expn_id\n-            };\n-            check_exhaustive(cx, match_span, &matrix, source);\n+            check_exhaustive(cx, scrut.span, &matrix, source);\n         },\n         _ => ()\n     }\n@@ -1115,9 +1110,15 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n         if sub.map_or(false, |p| pat_contains_bindings(&p)) {\n-            span_err!(cx.tcx.sess, p.span, E0007, \"cannot bind by-move with sub-bindings\");\n+            struct_span_err!(cx.tcx.sess, p.span, E0007,\n+                             \"cannot bind by-move with sub-bindings\")\n+                .span_label(p.span, &format!(\"binds an already bound by-move value by moving it\"))\n+                .emit();\n         } else if has_guard {\n-            span_err!(cx.tcx.sess, p.span, E0008, \"cannot bind by-move into a pattern guard\");\n+            struct_span_err!(cx.tcx.sess, p.span, E0008,\n+                      \"cannot bind by-move into a pattern guard\")\n+                .span_label(p.span, &format!(\"moves value into pattern guard\"))\n+                .emit();\n         } else if by_ref_span.is_some() {\n             let mut err = struct_span_err!(cx.tcx.sess, p.span, E0009,\n                                            \"cannot bind by-move and by-ref in the same pattern\");"}, {"sha": "c061f2d5620b2343735cdabc391ef1c0708411a1", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -615,9 +615,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     if !allow {\n                         self.add(Qualif::NOT_CONST);\n                         if self.mode != Mode::Fn {\n-                            span_err!(self.tcx.sess, self.span, E0017,\n-                                      \"references in {}s may only refer \\\n-                                       to immutable values\", self.mode);\n+                            struct_span_err!(self.tcx.sess,  self.span, E0017,\n+                                             \"references in {}s may only refer \\\n+                                              to immutable values\", self.mode)\n+                                .span_label(self.span, &format!(\"{}s require immutable values\",\n+                                                                self.mode))\n+                                .emit();\n                         }\n                     }\n                 } else {"}, {"sha": "341c9d820e6519b060445ec621a56a3cc49faee4", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -183,6 +183,7 @@ impl<'a> Visitor for AstValidator<'a> {\n                                                    E0130,\n                                                    \"patterns aren't allowed in foreign function \\\n                                                     declarations\");\n+                    err.span_label(span, &format!(\"pattern not allowed in foreign function\"));\n                     if is_recent {\n                         err.span_note(span,\n                                       \"this is a recent error, see issue #35203 for more details\");"}, {"sha": "bdbdb294954883977837b68f3a3a91efacbd2374", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -412,7 +412,10 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             struct_span_err!(resolver.session, span, E0432, \"{}\", msg)\n         }\n         ResolutionError::FailedToResolve(msg) => {\n-            struct_span_err!(resolver.session, span, E0433, \"failed to resolve. {}\", msg)\n+            let mut err = struct_span_err!(resolver.session, span, E0433,\n+                                           \"failed to resolve. {}\", msg);\n+            err.span_label(span, &msg);\n+            err\n         }\n         ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n             struct_span_err!(resolver.session,"}, {"sha": "140fabce76b4d5401414e96da5a6755f385147e2", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -14,6 +14,8 @@ use rustc::ty;\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::error::ExpectedFound;\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n+use rustc::hir::map::Node;\n+use rustc::hir::{ImplItemKind, TraitItem_};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -461,7 +463,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // Compute skolemized form of impl and trait const tys.\n         let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n         let trait_ty = trait_c.ty.subst(tcx, &trait_to_skol_substs);\n-        let origin = TypeOrigin::Misc(impl_c_span);\n+        let mut origin = TypeOrigin::Misc(impl_c_span);\n \n         let err = infcx.commit_if_ok(|_| {\n             // There is no \"body\" here, so just pass dummy id.\n@@ -496,11 +498,31 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n                    impl_ty,\n                    trait_ty);\n+\n+            // Locate the Span containing just the type of the offending impl\n+            if let Some(impl_trait_node) = tcx.map.get_if_local(impl_c.def_id) {\n+                if let Node::NodeImplItem(impl_trait_item) = impl_trait_node {\n+                    if let ImplItemKind::Const(ref ty, _) = impl_trait_item.node {\n+                        origin = TypeOrigin::Misc(ty.span);\n+                    }\n+                }\n+            }\n+\n             let mut diag = struct_span_err!(\n                 tcx.sess, origin.span(), E0326,\n                 \"implemented const `{}` has an incompatible type for trait\",\n                 trait_c.name\n             );\n+\n+            // Add a label to the Span containing just the type of the item\n+            if let Some(orig_trait_node) = tcx.map.get_if_local(trait_c.def_id) {\n+                if let Node::NodeTraitItem(orig_trait_item) = orig_trait_node {\n+                    if let TraitItem_::ConstTraitItem(ref ty, _) = orig_trait_item.node {\n+                        diag.span_label(ty.span, &format!(\"original trait requirement\"));\n+                    }\n+                }\n+            }\n+\n             infcx.note_type_err(\n                 &mut diag, origin,\n                 Some(infer::ValuePairs::Types(ExpectedFound {"}, {"sha": "9051b1c8069bde3583af62b07cb215efd70b5f3f", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -97,8 +97,10 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                 (0, Vec::new(), tcx.mk_nil())\n             }\n             op => {\n-                span_err!(tcx.sess, it.span, E0092,\n-                    \"unrecognized atomic operation function: `{}`\", op);\n+                struct_span_err!(tcx.sess, it.span, E0092,\n+                      \"unrecognized atomic operation function: `{}`\", op)\n+                  .span_label(it.span, &format!(\"unrecognized atomic operation\"))\n+                  .emit();\n                 return;\n             }\n         };"}, {"sha": "36fdba3706109682a0f4998040f50e00cd53c906", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -1272,13 +1272,21 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n             // Check for duplicate discriminant values\n             if let Some(i) = disr_vals.iter().position(|&x| x == current_disr_val) {\n-                let mut err = struct_span_err!(ccx.tcx.sess, v.span, E0081,\n-                    \"discriminant value `{}` already exists\", disr_vals[i]);\n                 let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n-                err.span_label(ccx.tcx.map.span(variant_i_node_id),\n-                               &format!(\"first use of `{}`\", disr_vals[i]));\n-                err.span_label(v.span , &format!(\"enum already has `{}`\", disr_vals[i]));\n-                err.emit();\n+                let variant_i = ccx.tcx.map.expect_variant(variant_i_node_id);\n+                let i_span = match variant_i.node.disr_expr {\n+                    Some(ref expr) => expr.span,\n+                    None => ccx.tcx.map.span(variant_i_node_id)\n+                };\n+                let span = match v.node.disr_expr {\n+                    Some(ref expr) => expr.span,\n+                    None => v.span\n+                };\n+                struct_span_err!(ccx.tcx.sess, span, E0081,\n+                                 \"discriminant value `{}` already exists\", disr_vals[i])\n+                    .span_label(i_span, &format!(\"first use of `{}`\", disr_vals[i]))\n+                    .span_label(span , &format!(\"enum already has `{}`\", disr_vals[i]))\n+                    .emit();\n             }\n             disr_vals.push(current_disr_val);\n         }\n@@ -4640,9 +4648,11 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     for (i, b) in tps_used.iter().enumerate() {\n         if !*b {\n-            span_err!(ccx.tcx.sess, tps[i].span, E0091,\n+            struct_span_err!(ccx.tcx.sess, tps[i].span, E0091,\n                 \"type parameter `{}` is unused\",\n-                tps[i].name);\n+                tps[i].name)\n+                .span_label(tps[i].span, &format!(\"unused type parameter\"))\n+                .emit();\n         }\n     }\n }"}, {"sha": "f68d902ef36ab9c8fe80e1d3d058cb48be35277a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -1903,9 +1903,12 @@ fn convert_default_type_parameter<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     for leaf_ty in ty.walk() {\n         if let ty::TyParam(p) = leaf_ty.sty {\n             if p.space == space && p.idx >= index {\n-                span_err!(ccx.tcx.sess, path.span, E0128,\n-                          \"type parameters with a default cannot use \\\n-                           forward declared identifiers\");\n+                struct_span_err!(ccx.tcx.sess, path.span, E0128,\n+                                 \"type parameters with a default cannot use \\\n+                                 forward declared identifiers\")\n+                    .span_label(path.span, &format!(\"defaulted type parameters \\\n+                                                    cannot be forward declared\"))\n+                    .emit();\n \n                 return ccx.tcx.types.err\n             }"}, {"sha": "a31961a157b35666c30ee131a2558ab967372075", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -178,8 +178,10 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              abi: Abi,\n                              span: Span) {\n     if decl.variadic && abi != Abi::C {\n-        span_err!(tcx.sess, span, E0045,\n+        let mut err = struct_span_err!(tcx.sess, span, E0045,\n                   \"variadic function must have C calling convention\");\n+        err.span_label(span, &(\"variadics require C calling conventions\").to_string())\n+            .emit();\n     }\n }\n "}, {"sha": "77b90c0846bbe44f2349b7a674223d6f47ea59f9", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -99,11 +99,9 @@ pub struct CString {\n ///\n /// extern { fn my_string() -> *const c_char; }\n ///\n-/// fn main() {\n-///     unsafe {\n-///         let slice = CStr::from_ptr(my_string());\n-///         println!(\"string length: {}\", slice.to_bytes().len());\n-///     }\n+/// unsafe {\n+///     let slice = CStr::from_ptr(my_string());\n+///     println!(\"string length: {}\", slice.to_bytes().len());\n /// }\n /// ```\n ///\n@@ -119,10 +117,8 @@ pub struct CString {\n ///     unsafe { work_with(data.as_ptr()) }\n /// }\n ///\n-/// fn main() {\n-///     let s = CString::new(\"data data data data\").unwrap();\n-///     work(&s);\n-/// }\n+/// let s = CString::new(\"data data data data\").unwrap();\n+/// work(&s);\n /// ```\n ///\n /// Converting a foreign C string into a Rust `String`\n@@ -139,9 +135,7 @@ pub struct CString {\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     println!(\"string: {}\", my_string_safe());\n-/// }\n+/// println!(\"string: {}\", my_string_safe());\n /// ```\n #[derive(Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -188,11 +182,9 @@ impl CString {\n     ///\n     /// extern { fn puts(s: *const c_char); }\n     ///\n-    /// fn main() {\n-    ///     let to_print = CString::new(\"Hello!\").unwrap();\n-    ///     unsafe {\n-    ///         puts(to_print.as_ptr());\n-    ///     }\n+    /// let to_print = CString::new(\"Hello!\").unwrap();\n+    /// unsafe {\n+    ///     puts(to_print.as_ptr());\n     /// }\n     /// ```\n     ///"}, {"sha": "a4564b9543b3430cdd810b87ecf5c5bf65b434c2", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -110,7 +110,7 @@ impl SocketAddr {\n         })\n     }\n \n-    /// Returns true iff the address is unnamed.\n+    /// Returns true if and only if the address is unnamed.\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn is_unnamed(&self) -> bool {\n         if let AddressKind::Unnamed = self.address() {"}, {"sha": "4be115b8afdace66329a8d4c5a97b31f32eb3346", "filename": "src/test/compile-fail/E0007.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0007.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0007.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0007.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -11,8 +11,10 @@\n fn main() {\n     let x = Some(\"s\".to_string());\n     match x {\n-        op_string @ Some(s) => {}, //~ ERROR E0007\n-                                   //~| ERROR E0303\n+        op_string @ Some(s) => {},\n+        //~^ ERROR E0007\n+        //~| NOTE binds an already bound by-move value by moving it\n+        //~| ERROR E0303\n         None => {},\n     }\n }"}, {"sha": "20cc1cbd2232df233d3e92734901b112247bc1a5", "filename": "src/test/compile-fail/E0008.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0008.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0008.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0008.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -10,7 +10,9 @@\n \n fn main() {\n     match Some(\"hi\".to_string()) {\n-        Some(s) if s.len() == 0 => {}, //~ ERROR E0008\n+        Some(s) if s.len() == 0 => {},\n+        //~^ ERROR E0008\n+        //~| NOTE moves value into pattern guard\n         _ => {},\n     }\n }"}, {"sha": "1223a01cbcb6f29fc0d14d04215597b02c5cd58b", "filename": "src/test/compile-fail/E0017.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0017.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0017.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0017.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -12,11 +12,16 @@ static X: i32 = 1;\n const C: i32 = 2;\n \n const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n+                                     //~| NOTE constants require immutable values\n                                      //~| ERROR E0017\n+                                     //~| NOTE constants require immutable values\n static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n+                                              //~| NOTE statics require immutable values\n                                               //~| ERROR E0017\n+                                              //~| NOTE statics require immutable values\n                                               //~| ERROR E0388\n static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n+                                             //~| NOTE statics require immutable values\n                                              //~| ERROR E0017\n-\n+                                             //~| NOTE statics require immutable values\n fn main() {}"}, {"sha": "6cf3f1ebf19e4526d1c8b6b37fe6af2a9b4bd894", "filename": "src/test/compile-fail/E0038.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0038.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0038.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0038.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -12,7 +12,10 @@ trait Trait {\n     fn foo(&self) -> Self;\n }\n \n-fn call_foo(x: Box<Trait>) { //~ ERROR E0038\n+fn call_foo(x: Box<Trait>) {\n+    //~^ ERROR E0038\n+    //~| NOTE the trait `Trait` cannot be made into an object\n+    //~| NOTE method `foo` references the `Self` type in its arguments or return type\n     let y = x.foo();\n }\n "}, {"sha": "a3fea8e0db299b2a810f6b1790221e340d6b691d", "filename": "src/test/compile-fail/E0045.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0045.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0045.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0045.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern \"Rust\" { fn foo(x: u8, ...); } //~ ERROR E0045\n+extern \"Rust\" { fn foo(x: u8, ...); }   //~ ERROR E0045\n+                                        //~| NOTE variadics require C calling conventions\n \n fn main() {\n }"}, {"sha": "e6de7921b30363a648723d5aaf14c71db276c9ef", "filename": "src/test/compile-fail/E0072.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0072.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0072.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0072.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n struct ListNode { //~ ERROR E0072\n+                  //~| NOTE recursive type has infinite size\n     head: u8,\n     tail: Option<ListNode>,\n }"}, {"sha": "9911e093a898036d5fcae44fe656f6add46c2225", "filename": "src/test/compile-fail/E0081.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0081.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0081.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0081.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -9,8 +9,10 @@\n // except according to those terms.\n \n enum Enum {\n-    P = 3,\n-    X = 3, //~ ERROR E0081\n+    P = 3, //~ NOTE first use of `3isize`\n+    X = 3,\n+    //~^ ERROR discriminant value `3isize` already exists\n+    //~| NOTE enum already has `3isize`\n     Y = 5\n }\n "}, {"sha": "0d6c246de2a0e79f2c6e0f6d148165684820d556", "filename": "src/test/compile-fail/E0091.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0091.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0091.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0091.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n type Foo<T> = u32; //~ ERROR E0091\n+                   //~| NOTE unused type parameter\n type Foo2<A, B> = Box<A>; //~ ERROR E0091\n+                          //~| NOTE unused type parameter\n \n fn main() {\n }"}, {"sha": "c8bb31a7857ee1495ad17512b0af982cba14cac1", "filename": "src/test/compile-fail/E0092.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0092.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -11,7 +11,7 @@\n #![feature(intrinsics)]\n extern \"rust-intrinsic\" {\n     fn atomic_foo(); //~ ERROR E0092\n-}\n+}                    //~| NOTE unrecognized atomic operation\n \n fn main() {\n }"}, {"sha": "f5829b93859412c007daad508a71767652eb9140", "filename": "src/test/compile-fail/E0128.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0128.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n struct Foo<T=U, U=()> { //~ ERROR E0128\n+                        //~| NOTE defaulted type parameters cannot be forward declared\n     field1: T,\n     field2: U,\n }"}, {"sha": "e9e027fd1dc1972aea32aabfc7005274dd2c4f76", "filename": "src/test/compile-fail/E0130.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0130.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0130.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0130.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n extern {\n-    fn foo((a, b): (u32, u32)); //~ ERROR E0130\n+    fn foo((a, b): (u32, u32));\n+    //~^ ERROR E0130\n+    //~| NOTE pattern not allowed in foreign function\n }\n \n fn main() {"}, {"sha": "b8a4476fc59671b2b5e4f6b769ce5bad5ad9bfd9", "filename": "src/test/compile-fail/E0133.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0133.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0133.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0133.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -11,5 +11,7 @@\n unsafe fn f() { return; }\n \n fn main() {\n-    f(); //~ ERROR E0133\n+    f();\n+    //~^ ERROR E0133\n+    //~| NOTE unsafe call requires unsafe function or block\n }"}, {"sha": "11a8ff443a8459d452a2d53b89c633b0a4302e7b", "filename": "src/test/compile-fail/E0263.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0263.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2FE0263.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0263.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { } //~ ERROR E0263\n+fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) {\n+    //~^ ERROR E0263\n+    //~| NOTE declared twice\n+    //~| NOTE previous declaration here\n+}\n \n fn main() {}"}, {"sha": "0541faa021356f0a0719423833dde86ee85b24c3", "filename": "src/test/compile-fail/asm-out-assign-imm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -18,11 +18,12 @@ fn foo(x: isize) { println!(\"{}\", x); }\n           target_arch = \"aarch64\"))]\n pub fn main() {\n     let x: isize;\n-    x = 1; //~ NOTE prior assignment occurs here\n+    x = 1; //~ NOTE first assignment\n     foo(x);\n     unsafe {\n         asm!(\"mov $1, $0\" : \"=r\"(x) : \"r\"(5));\n         //~^ ERROR re-assignment of immutable variable `x`\n+        //~| NOTE re-assignment of immutable\n         //~| NOTE in this expansion of asm!\n     }\n     foo(x);"}, {"sha": "9a5d6289b589ecd3b5d556ffe3dff14b8d6b3f5c", "filename": "src/test/compile-fail/assign-imm-local-twice.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -10,9 +10,10 @@\n \n fn test() {\n     let v: isize;\n-    v = 1; //~ NOTE prior assignment occurs here\n+    v = 1; //~ NOTE first assignment\n     println!(\"v={}\", v);\n     v = 2; //~ ERROR re-assignment of immutable variable\n+           //~| NOTE re-assignment of immutable\n     println!(\"v={}\", v);\n }\n "}, {"sha": "b3776091682da18b3f149c01f8786e830657df6d", "filename": "src/test/compile-fail/associated-const-impl-wrong-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -11,15 +11,15 @@\n #![feature(associated_consts)]\n \n trait Foo {\n-    const BAR: u32;\n+    const BAR: u32; //~ NOTE original trait requirement\n }\n \n struct SignedBar;\n \n impl Foo for SignedBar {\n     const BAR: i32 = -1;\n     //~^ ERROR implemented const `BAR` has an incompatible type for trait [E0326]\n-    //~| expected u32, found i32\n+    //~| NOTE expected u32, found i32\n }\n \n fn main() {}"}, {"sha": "6a9d8db9654ac9d70e6ff0064f836daf732fcc78", "filename": "src/test/compile-fail/derived-errors/issue-31997-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997-1.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -29,6 +29,7 @@ fn main() {\n \n     let mut map = HashMap::new();\n     //~^ ERROR E0433\n+    //~| NOTE Use of undeclared type or module `HashMap`\n \n     for line in input.lines() {\n         let line = line.unwrap();"}, {"sha": "658a0c1546b9f337b27704fa31d060075e91bdfc", "filename": "src/test/compile-fail/issue-15524.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -12,17 +12,20 @@ const N: isize = 1;\n \n enum Foo {\n     A = 1,\n-    //~^ NOTE first use\n-    //~| NOTE first use\n-    //~| NOTE first use\n-    B = 1, //~ ERROR discriminant value\n-    //~^ NOTE enum already\n+    //~^ NOTE first use of `1isize`\n+    //~| NOTE first use of `1isize`\n+    //~| NOTE first use of `1isize`\n+    B = 1,\n+    //~^ ERROR discriminant value `1isize` already exists\n+    //~| NOTE enum already has `1isize`\n     C = 0,\n-    D, //~ ERROR discriminant value\n-    //~^ NOTE enum already\n+    D,\n+    //~^ ERROR discriminant value `1isize` already exists\n+    //~| NOTE enum already has `1isize`\n \n-    E = N, //~ ERROR discriminant value\n-    //~^ NOTE enum already\n+    E = N,\n+    //~^ ERROR discriminant value `1isize` already exists\n+    //~| NOTE enum already has `1isize`\n \n }\n "}, {"sha": "b3fc3aea148ee3b6cdaf70e4e75a4af0c862a78b", "filename": "src/test/compile-fail/issue-18183.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-18183.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-18183.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18183.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -9,5 +9,6 @@\n // except according to those terms.\n \n pub struct Foo<Bar=Bar>; //~ ERROR E0128\n+                         //~| NOTE defaulted type parameters cannot be forward declared\n pub struct Baz(Foo);\n fn main() {}"}, {"sha": "3e44053875552cbf8fbc194c2939969c89a65365", "filename": "src/test/compile-fail/issue-20692.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-20692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-20692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20692.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -15,10 +15,12 @@ fn f<T: Array>(x: &T) {\n     //~^ ERROR `Array` cannot be made into an object\n     //~| NOTE the trait cannot require that `Self : Sized`\n     //~| NOTE requirements on the impl of `std::ops::CoerceUnsized<&Array>`\n+    //~| NOTE the trait `Array` cannot be made into an object\n     as\n     &Array;\n     //~^ ERROR `Array` cannot be made into an object\n     //~| NOTE the trait cannot require that `Self : Sized`\n+    //~| NOTE the trait `Array` cannot be made into an object\n }\n \n fn main() {}"}, {"sha": "ded685152d49b63c83a0371c41e6cabcc301e369", "filename": "src/test/compile-fail/issue-26056.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-26056.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-26056.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26056.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -28,6 +28,7 @@ impl<K> Map for K {\n fn main() {\n     let _ = &()\n         as &Map<Key=u32,MapValue=u32>;\n-    //~^ ERROR the trait `Map` cannot be made into an object\n+    //~^ ERROR E0038\n     //~| NOTE the trait cannot use `Self` as a type parameter\n+    //~| NOTE the trait `Map` cannot be made into an object\n }"}, {"sha": "52b0eba96cbdf59631f784bc662fe72f14cfc001", "filename": "src/test/compile-fail/issue-28776.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-28776.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-28776.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28776.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -11,5 +11,7 @@\n use std::ptr;\n \n fn main() {\n-    (&ptr::write)(1 as *mut _, 42); //~ ERROR E0133\n+    (&ptr::write)(1 as *mut _, 42);\n+    //~^ ERROR E0133\n+    //~| NOTE unsafe call requires unsafe function or block\n }"}, {"sha": "38b5fcbb3db0ee36b98b190945e09af7b1b33be4", "filename": "src/test/compile-fail/issue-3008-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -13,6 +13,7 @@\n enum foo { foo_(bar) }\n struct bar { x: bar }\n //~^ ERROR E0072\n+//~| NOTE recursive type has infinite size\n \n fn main() {\n }"}, {"sha": "afffe2a2c8d03d057a95eb4296f5dea955e1598e", "filename": "src/test/compile-fail/issue-32326.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -13,6 +13,7 @@\n // too big.\n \n enum Expr { //~ ERROR E0072\n+            //~| NOTE recursive type has infinite size\n     Plus(Expr, Expr),\n     Literal(i64),\n }"}, {"sha": "71e9325ab75d135dfb7823e967f0f48d5b74466e", "filename": "src/test/compile-fail/issue-3779.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n struct S { //~ ERROR E0072\n+           //~| NOTE recursive type has infinite size\n     element: Option<S>\n }\n "}, {"sha": "9d246f8ea5e0e5bb08f01569508b805abee44ebc", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -12,7 +12,7 @@ fn test() {\n     let v: isize;\n     loop {\n         v = 1; //~ ERROR re-assignment of immutable variable\n-        //~^ NOTE prior assignment occurs here\n+        //~^ NOTE re-assignment of immutable variable\n         v.clone(); // just to prevent liveness warnings\n     }\n }"}, {"sha": "e1eb3246137d22a9d711d93d5dd518ff22b1dd37", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-op-eq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -10,8 +10,9 @@\n \n fn test() {\n     let v: isize;\n-    v = 2;  //~ NOTE prior assignment occurs here\n+    v = 2;  //~ NOTE first assignment\n     v += 1; //~ ERROR re-assignment of immutable variable\n+            //~| NOTE re-assignment of immutable\n     v.clone();\n }\n "}, {"sha": "2468c91f34bbd018a4c324eed5c3e924f4a28b5c", "filename": "src/test/compile-fail/liveness-assign-imm-local-with-init.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-with-init.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -9,9 +9,10 @@\n // except according to those terms.\n \n fn test() {\n-    let v: isize = 1; //~ NOTE prior assignment occurs here\n+    let v: isize = 1; //~ NOTE first assignment\n     v.clone();\n     v = 2; //~ ERROR re-assignment of immutable variable\n+           //~| NOTE re-assignment of immutable\n     v.clone();\n }\n "}, {"sha": "b0278476998dd54b42a96a1a9b6089bb1a9db957", "filename": "src/test/compile-fail/no-patterns-in-args.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -10,10 +10,13 @@\n \n extern {\n     fn f1(mut arg: u8); //~ ERROR patterns aren't allowed in foreign function declarations\n-                        //~^ NOTE this is a recent error\n+                        //~^ NOTE pattern not allowed in foreign function\n+                        //~| NOTE this is a recent error\n     fn f2(&arg: u8); //~ ERROR patterns aren't allowed in foreign function declarations\n+                     //~^ NOTE pattern not allowed in foreign function\n     fn f3(arg @ _: u8); //~ ERROR patterns aren't allowed in foreign function declarations\n-                        //~^ NOTE this is a recent error\n+                        //~^ NOTE pattern not allowed in foreign function\n+                        //~| NOTE this is a recent error\n     fn g1(arg: u8); // OK\n     fn g2(_: u8); // OK\n     // fn g3(u8); // Not yet"}, {"sha": "6174d45b898d6971e00405c141930ba98590622c", "filename": "src/test/compile-fail/object-safety-generics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -24,12 +24,14 @@ trait Quux {\n fn make_bar<T:Bar>(t: &T) -> &Bar {\n         //~^ ERROR E0038\n         //~| NOTE method `bar` has generic type parameters\n+        //~| NOTE the trait `Bar` cannot be made into an object\n     t\n }\n \n fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n     //~^ ERROR E0038\n-    //~^^ NOTE method `bar` has generic type parameters\n+    //~| NOTE method `bar` has generic type parameters\n+    //~| NOTE the trait `Bar` cannot be made into an object\n     t as &Bar\n }\n "}, {"sha": "d85614fa5b538845359fa196638ff58dea68f82e", "filename": "src/test/compile-fail/object-safety-mentions-Self.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -27,12 +27,14 @@ trait Quux {\n fn make_bar<T:Bar>(t: &T) -> &Bar {\n         //~^ ERROR E0038\n         //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+        //~| NOTE the trait `Bar` cannot be made into an object\n     loop { }\n }\n \n fn make_baz<T:Baz>(t: &T) -> &Baz {\n         //~^ ERROR E0038\n         //~| NOTE method `bar` references the `Self` type in its arguments or return type\n+        //~| NOTE the trait `Baz` cannot be made into an object\n     t\n }\n "}, {"sha": "accd7fa87ac29bf435af31c3f2307f7995625b61", "filename": "src/test/compile-fail/object-safety-sized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -18,6 +18,7 @@ trait Bar : Sized {\n fn make_bar<T:Bar>(t: &T) -> &Bar {\n         //~^ ERROR E0038\n         //~| NOTE the trait cannot require that `Self : Sized`\n+        //~| NOTE the trait `Bar` cannot be made into an object\n     t\n }\n "}, {"sha": "74d1ad62f14c3be3fb4d8c0d0c21bb4a77c652e7", "filename": "src/test/compile-fail/object-safety-supertrait-mentions-Self.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fobject-safety-supertrait-mentions-Self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Fobject-safety-supertrait-mentions-Self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-supertrait-mentions-Self.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -25,6 +25,7 @@ fn make_bar<T:Bar<u32>>(t: &T) -> &Bar<u32> {\n fn make_baz<T:Baz>(t: &T) -> &Baz {\n     //~^ ERROR E0038\n     //~| NOTE the trait cannot use `Self` as a type parameter in the supertrait listing\n+    //~| NOTE the trait `Baz` cannot be made into an object\n     t\n }\n "}, {"sha": "0df7ee8cabed21a4adb3db8a14e1d1962127f669", "filename": "src/test/compile-fail/trait-safety-fn-body.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Ftrait-safety-fn-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Ftrait-safety-fn-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-safety-fn-body.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -18,7 +18,9 @@ unsafe trait UnsafeTrait : Sized {\n unsafe impl UnsafeTrait for *mut isize {\n     fn foo(self) {\n         // Unsafe actions are not made legal by taking place in an unsafe trait:\n-        *self += 1; //~ ERROR E0133\n+        *self += 1;\n+        //~^ ERROR E0133\n+        //~| NOTE unsafe call requires unsafe function or block\n     }\n }\n "}, {"sha": "7b56c6c15ebb308b68b959338bacc1730a665cc5", "filename": "src/test/compile-fail/type-recursive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n struct t1 { //~ ERROR E0072\n+            //~| NOTE recursive type has infinite size\n     foo: isize,\n     foolish: t1\n }"}, {"sha": "174939b09009cbd3ef0bef677506f6a3191146c8", "filename": "src/test/compile-fail/unsafe-const-fn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Funsafe-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Fcompile-fail%2Funsafe-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-const-fn.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -16,7 +16,9 @@ const unsafe fn dummy(v: u32) -> u32 {\n     !v\n }\n \n-const VAL: u32 = dummy(0xFFFF); //~ ERROR E0133\n+const VAL: u32 = dummy(0xFFFF);\n+//~^ ERROR E0133\n+//~| NOTE unsafe call requires unsafe function or block\n \n fn main() {\n     assert_eq!(VAL, 0xFFFF0000);"}, {"sha": "72655071e4135b7adcd7989cca4eafc72a8c2845", "filename": "src/test/run-pass/issue-29053.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Frun-pass%2Fissue-29053.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftest%2Frun-pass%2Fissue-29053.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29053.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x: &'static str = \"x\";\n+\n+    {\n+        let y = \"y\".to_string();\n+        let ref mut x = &*x;\n+        *x = &*y;\n+    }\n+\n+    assert_eq!(x, \"x\");\n+}"}, {"sha": "6090cb4f52725784789fb5904c7ffc850e334ef1", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -36,45 +36,46 @@ impl FromStr for Mode {\n     type Err = ();\n     fn from_str(s: &str) -> Result<Mode, ()> {\n         match s {\n-          \"compile-fail\" => Ok(CompileFail),\n-          \"parse-fail\" => Ok(ParseFail),\n-          \"run-fail\" => Ok(RunFail),\n-          \"run-pass\" => Ok(RunPass),\n-          \"run-pass-valgrind\" => Ok(RunPassValgrind),\n-          \"pretty\" => Ok(Pretty),\n-          \"debuginfo-lldb\" => Ok(DebugInfoLldb),\n-          \"debuginfo-gdb\" => Ok(DebugInfoGdb),\n-          \"codegen\" => Ok(Codegen),\n-          \"rustdoc\" => Ok(Rustdoc),\n-          \"codegen-units\" => Ok(CodegenUnits),\n-          \"incremental\" => Ok(Incremental),\n-          \"run-make\" => Ok(RunMake),\n-          \"ui\" => Ok(Ui),\n-          \"mir-opt\" => Ok(MirOpt),\n-          _ => Err(()),\n+            \"compile-fail\" => Ok(CompileFail),\n+            \"parse-fail\" => Ok(ParseFail),\n+            \"run-fail\" => Ok(RunFail),\n+            \"run-pass\" => Ok(RunPass),\n+            \"run-pass-valgrind\" => Ok(RunPassValgrind),\n+            \"pretty\" => Ok(Pretty),\n+            \"debuginfo-lldb\" => Ok(DebugInfoLldb),\n+            \"debuginfo-gdb\" => Ok(DebugInfoGdb),\n+            \"codegen\" => Ok(Codegen),\n+            \"rustdoc\" => Ok(Rustdoc),\n+            \"codegen-units\" => Ok(CodegenUnits),\n+            \"incremental\" => Ok(Incremental),\n+            \"run-make\" => Ok(RunMake),\n+            \"ui\" => Ok(Ui),\n+            \"mir-opt\" => Ok(MirOpt),\n+            _ => Err(()),\n         }\n     }\n }\n \n impl fmt::Display for Mode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(match *self {\n-            CompileFail => \"compile-fail\",\n-            ParseFail => \"parse-fail\",\n-            RunFail => \"run-fail\",\n-            RunPass => \"run-pass\",\n-            RunPassValgrind => \"run-pass-valgrind\",\n-            Pretty => \"pretty\",\n-            DebugInfoGdb => \"debuginfo-gdb\",\n-            DebugInfoLldb => \"debuginfo-lldb\",\n-            Codegen => \"codegen\",\n-            Rustdoc => \"rustdoc\",\n-            CodegenUnits => \"codegen-units\",\n-            Incremental => \"incremental\",\n-            RunMake => \"run-make\",\n-            Ui => \"ui\",\n-            MirOpt => \"mir-opt\",\n-        }, f)\n+                              CompileFail => \"compile-fail\",\n+                              ParseFail => \"parse-fail\",\n+                              RunFail => \"run-fail\",\n+                              RunPass => \"run-pass\",\n+                              RunPassValgrind => \"run-pass-valgrind\",\n+                              Pretty => \"pretty\",\n+                              DebugInfoGdb => \"debuginfo-gdb\",\n+                              DebugInfoLldb => \"debuginfo-lldb\",\n+                              Codegen => \"codegen\",\n+                              Rustdoc => \"rustdoc\",\n+                              CodegenUnits => \"codegen-units\",\n+                              Incremental => \"incremental\",\n+                              RunMake => \"run-make\",\n+                              Ui => \"ui\",\n+                              MirOpt => \"mir-opt\",\n+                          },\n+                          f)\n     }\n }\n "}, {"sha": "29ca54fda8db9521eeb68b74686094bf84770a1b", "filename": "src/tools/compiletest/src/errors.rs", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -64,7 +64,11 @@ pub struct Error {\n }\n \n #[derive(PartialEq, Debug)]\n-enum WhichLine { ThisLine, FollowPrevious(usize), AdjustBackward(usize) }\n+enum WhichLine {\n+    ThisLine,\n+    FollowPrevious(usize),\n+    AdjustBackward(usize),\n+}\n \n /// Looks for either \"//~| KIND MESSAGE\" or \"//~^^... KIND MESSAGE\"\n /// The former is a \"follow\" that inherits its target from the preceding line;\n@@ -91,60 +95,59 @@ pub fn load_errors(testfile: &Path, cfg: Option<&str>) -> Vec<Error> {\n \n     let tag = match cfg {\n         Some(rev) => format!(\"//[{}]~\", rev),\n-        None => format!(\"//~\")\n+        None => format!(\"//~\"),\n     };\n \n     rdr.lines()\n-       .enumerate()\n-       .filter_map(|(line_num, line)| {\n-           parse_expected(last_nonfollow_error,\n-                          line_num + 1,\n-                          &line.unwrap(),\n-                          &tag)\n-               .map(|(which, error)| {\n-                   match which {\n-                       FollowPrevious(_) => {}\n-                       _ => last_nonfollow_error = Some(error.line_num),\n-                   }\n-                   error\n-               })\n-       })\n-       .collect()\n+        .enumerate()\n+        .filter_map(|(line_num, line)| {\n+            parse_expected(last_nonfollow_error, line_num + 1, &line.unwrap(), &tag)\n+                .map(|(which, error)| {\n+                    match which {\n+                        FollowPrevious(_) => {}\n+                        _ => last_nonfollow_error = Some(error.line_num),\n+                    }\n+                    error\n+                })\n+        })\n+        .collect()\n }\n \n fn parse_expected(last_nonfollow_error: Option<usize>,\n                   line_num: usize,\n                   line: &str,\n                   tag: &str)\n                   -> Option<(WhichLine, Error)> {\n-    let start = match line.find(tag) { Some(i) => i, None => return None };\n+    let start = match line.find(tag) {\n+        Some(i) => i,\n+        None => return None,\n+    };\n     let (follow, adjusts) = if line[start + tag.len()..].chars().next().unwrap() == '|' {\n         (true, 0)\n     } else {\n         (false, line[start + tag.len()..].chars().take_while(|c| *c == '^').count())\n     };\n     let kind_start = start + tag.len() + adjusts + (follow as usize);\n     let (kind, msg);\n-    match\n-        line[kind_start..].split_whitespace()\n-                          .next()\n-                          .expect(\"Encountered unexpected empty comment\")\n-                          .parse::<ErrorKind>()\n-    {\n+    match line[kind_start..]\n+        .split_whitespace()\n+        .next()\n+        .expect(\"Encountered unexpected empty comment\")\n+        .parse::<ErrorKind>() {\n         Ok(k) => {\n             // If we find `//~ ERROR foo` or something like that:\n             kind = Some(k);\n             let letters = line[kind_start..].chars();\n             msg = letters.skip_while(|c| c.is_whitespace())\n-                         .skip_while(|c| !c.is_whitespace())\n-                         .collect::<String>();\n+                .skip_while(|c| !c.is_whitespace())\n+                .collect::<String>();\n         }\n         Err(_) => {\n             // Otherwise we found `//~ foo`:\n             kind = None;\n             let letters = line[kind_start..].chars();\n             msg = letters.skip_while(|c| c.is_whitespace())\n-                         .collect::<String>();\n+                .collect::<String>();\n         }\n     }\n     let msg = msg.trim().to_owned();\n@@ -155,15 +158,25 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n                                                     preceding //~^ line.\");\n         (FollowPrevious(line_num), line_num)\n     } else {\n-        let which =\n-            if adjusts > 0 { AdjustBackward(adjusts) } else { ThisLine };\n+        let which = if adjusts > 0 {\n+            AdjustBackward(adjusts)\n+        } else {\n+            ThisLine\n+        };\n         let line_num = line_num - adjusts;\n         (which, line_num)\n     };\n \n     debug!(\"line={} tag={:?} which={:?} kind={:?} msg={:?}\",\n-           line_num, tag, which, kind, msg);\n-    Some((which, Error { line_num: line_num,\n-                         kind: kind,\n-                         msg: msg, }))\n+           line_num,\n+           tag,\n+           which,\n+           kind,\n+           msg);\n+    Some((which,\n+          Error {\n+        line_num: line_num,\n+        kind: kind,\n+        msg: msg,\n+    }))\n }"}, {"sha": "af33d76be1b0db0f430b4dcc5a4ee774a2c0d08d", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 52, "deletions": 62, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -32,24 +32,21 @@ impl EarlyProps {\n             should_fail: false,\n         };\n \n-        iter_header(testfile, None, &mut |ln| {\n+        iter_header(testfile,\n+                    None,\n+                    &mut |ln| {\n             props.ignore =\n-                props.ignore ||\n-                parse_name_directive(ln, \"ignore-test\") ||\n+                props.ignore || parse_name_directive(ln, \"ignore-test\") ||\n                 parse_name_directive(ln, &ignore_target(config)) ||\n                 parse_name_directive(ln, &ignore_architecture(config)) ||\n                 parse_name_directive(ln, &ignore_stage(config)) ||\n                 parse_name_directive(ln, &ignore_env(config)) ||\n-                (config.mode == common::Pretty &&\n-                 parse_name_directive(ln, \"ignore-pretty\")) ||\n+                (config.mode == common::Pretty && parse_name_directive(ln, \"ignore-pretty\")) ||\n                 (config.target != config.host &&\n                  parse_name_directive(ln, \"ignore-cross-compile\")) ||\n-                ignore_gdb(config, ln) ||\n-                ignore_lldb(config, ln);\n+                ignore_gdb(config, ln) || ignore_lldb(config, ln);\n \n-            props.should_fail =\n-                props.should_fail ||\n-                parse_name_directive(ln, \"should-fail\");\n+            props.should_fail = props.should_fail || parse_name_directive(ln, \"should-fail\");\n         });\n \n         return props;\n@@ -61,11 +58,11 @@ impl EarlyProps {\n             format!(\"ignore-{}\", util::get_arch(&config.target))\n         }\n         fn ignore_stage(config: &Config) -> String {\n-            format!(\"ignore-{}\",\n-                    config.stage_id.split('-').next().unwrap())\n+            format!(\"ignore-{}\", config.stage_id.split('-').next().unwrap())\n         }\n         fn ignore_env(config: &Config) -> String {\n-            format!(\"ignore-{}\", util::get_env(&config.target).unwrap_or(\"<unknown>\"))\n+            format!(\"ignore-{}\",\n+                    util::get_env(&config.target).unwrap_or(\"<unknown>\"))\n         }\n         fn ignore_gdb(config: &Config, line: &str) -> bool {\n             if config.mode != common::DebugInfoGdb {\n@@ -79,13 +76,12 @@ impl EarlyProps {\n             if let Some(ref actual_version) = config.gdb_version {\n                 if line.contains(\"min-gdb-version\") {\n                     let min_version = line.trim()\n-                                          .split(' ')\n-                                          .last()\n-                                          .expect(\"Malformed GDB version directive\");\n+                        .split(' ')\n+                        .last()\n+                        .expect(\"Malformed GDB version directive\");\n                     // Ignore if actual version is smaller the minimum required\n                     // version\n-                    gdb_version_to_int(actual_version) <\n-                        gdb_version_to_int(min_version)\n+                    gdb_version_to_int(actual_version) < gdb_version_to_int(min_version)\n                 } else {\n                     false\n                 }\n@@ -106,13 +102,12 @@ impl EarlyProps {\n             if let Some(ref actual_version) = config.lldb_version {\n                 if line.contains(\"min-lldb-version\") {\n                     let min_version = line.trim()\n-                                          .split(' ')\n-                                          .last()\n-                                          .expect(\"Malformed lldb version directive\");\n+                        .split(' ')\n+                        .last()\n+                        .expect(\"Malformed lldb version directive\");\n                     // Ignore if actual version is smaller the minimum required\n                     // version\n-                    lldb_version_to_int(actual_version) <\n-                        lldb_version_to_int(min_version)\n+                    lldb_version_to_int(actual_version) < lldb_version_to_int(min_version)\n                 } else {\n                     false\n                 }\n@@ -126,7 +121,7 @@ impl EarlyProps {\n #[derive(Clone, Debug)]\n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n-    pub error_patterns: Vec<String> ,\n+    pub error_patterns: Vec<String>,\n     // Extra flags to pass to the compiler\n     pub compile_flags: Vec<String>,\n     // Extra flags to pass when the compiled code is run (such as --bench)\n@@ -137,13 +132,13 @@ pub struct TestProps {\n     // Other crates that should be compiled (typically from the same\n     // directory as the test, but for backwards compatibility reasons\n     // we also check the auxiliary directory)\n-    pub aux_builds: Vec<String> ,\n+    pub aux_builds: Vec<String>,\n     // Environment settings to use for compiling\n-    pub rustc_env: Vec<(String,String)> ,\n+    pub rustc_env: Vec<(String, String)>,\n     // Environment settings to use during execution\n-    pub exec_env: Vec<(String,String)> ,\n+    pub exec_env: Vec<(String, String)>,\n     // Lines to check if they appear in the expected debugger output\n-    pub check_lines: Vec<String> ,\n+    pub check_lines: Vec<String>,\n     // Build documentation for all specified aux-builds as well\n     pub build_aux_docs: bool,\n     // Flag to force a crate to be built with the host architecture\n@@ -226,17 +221,17 @@ impl TestProps {\n     /// tied to a particular revision `foo` (indicated by writing\n     /// `//[foo]`), then the property is ignored unless `cfg` is\n     /// `Some(\"foo\")`.\n-    pub fn load_from(&mut self, testfile: &Path, cfg: Option<&str>)  {\n-        iter_header(testfile, cfg, &mut |ln| {\n+    pub fn load_from(&mut self, testfile: &Path, cfg: Option<&str>) {\n+        iter_header(testfile,\n+                    cfg,\n+                    &mut |ln| {\n             if let Some(ep) = parse_error_pattern(ln) {\n                 self.error_patterns.push(ep);\n             }\n \n             if let Some(flags) = parse_compile_flags(ln) {\n-                self.compile_flags.extend(\n-                    flags\n-                        .split_whitespace()\n-                        .map(|s| s.to_owned()));\n+                self.compile_flags.extend(flags.split_whitespace()\n+                    .map(|s| s.to_owned()));\n             }\n \n             if let Some(r) = parse_revisions(ln) {\n@@ -279,7 +274,7 @@ impl TestProps {\n                 self.pretty_compare_only = parse_pretty_compare_only(ln);\n             }\n \n-            if let  Some(ab) = parse_aux_build(ln) {\n+            if let Some(ab) = parse_aux_build(ln) {\n                 self.aux_builds.push(ab);\n             }\n \n@@ -291,7 +286,7 @@ impl TestProps {\n                 self.rustc_env.push(ee);\n             }\n \n-            if let Some(cl) =  parse_check_line(ln) {\n+            if let Some(cl) = parse_check_line(ln) {\n                 self.check_lines.push(cl);\n             }\n \n@@ -302,21 +297,20 @@ impl TestProps {\n \n         for key in vec![\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n             match env::var(key) {\n-                Ok(val) =>\n+                Ok(val) => {\n                     if self.exec_env.iter().find(|&&(ref x, _)| *x == key).is_none() {\n                         self.exec_env.push((key.to_owned(), val))\n-                    },\n+                    }\n+                }\n                 Err(..) => {}\n             }\n         }\n     }\n }\n \n-fn iter_header(testfile: &Path,\n-               cfg: Option<&str>,\n-               it: &mut FnMut(&str)) {\n+fn iter_header(testfile: &Path, cfg: Option<&str>, it: &mut FnMut(&str)) {\n     if testfile.is_dir() {\n-        return\n+        return;\n     }\n     let rdr = BufReader::new(File::open(testfile).unwrap());\n     for ln in rdr.lines() {\n@@ -336,7 +330,7 @@ fn iter_header(testfile: &Path,\n                     None => false,\n                 };\n                 if matches {\n-                    it(&ln[close_brace+1..]);\n+                    it(&ln[close_brace + 1..]);\n                 }\n             } else {\n                 panic!(\"malformed condition directive: expected `//[foo]`, found `{}`\",\n@@ -409,18 +403,17 @@ fn parse_pretty_compare_only(line: &str) -> bool {\n fn parse_env(line: &str, name: &str) -> Option<(String, String)> {\n     parse_name_value_directive(line, name).map(|nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs: Vec<String> = nv\n-                                      .splitn(2, '=')\n-                                      .map(str::to_owned)\n-                                      .collect();\n+        let mut strs: Vec<String> = nv.splitn(2, '=')\n+            .map(str::to_owned)\n+            .collect();\n \n         match strs.len() {\n-          1 => (strs.pop().unwrap(), \"\".to_owned()),\n-          2 => {\n-              let end = strs.pop().unwrap();\n-              (strs.pop().unwrap(), end)\n-          }\n-          n => panic!(\"Expected 1 or 2 strings, not {}\", n)\n+            1 => (strs.pop().unwrap(), \"\".to_owned()),\n+            2 => {\n+                let end = strs.pop().unwrap();\n+                (strs.pop().unwrap(), end)\n+            }\n+            n => panic!(\"Expected 1 or 2 strings, not {}\", n),\n         }\n     })\n }\n@@ -442,11 +435,10 @@ fn parse_name_directive(line: &str, directive: &str) -> bool {\n     line.contains(directive) && !line.contains(&(\"no-\".to_owned() + directive))\n }\n \n-pub fn parse_name_value_directive(line: &str, directive: &str)\n-                                  -> Option<String> {\n+pub fn parse_name_value_directive(line: &str, directive: &str) -> Option<String> {\n     let keycolon = format!(\"{}:\", directive);\n     if let Some(colon) = line.find(&keycolon) {\n-        let value = line[(colon + keycolon.len()) .. line.len()].to_owned();\n+        let value = line[(colon + keycolon.len())..line.len()].to_owned();\n         debug!(\"{}: {}\", directive, value);\n         Some(value)\n     } else {\n@@ -455,9 +447,8 @@ pub fn parse_name_value_directive(line: &str, directive: &str)\n }\n \n pub fn gdb_version_to_int(version_string: &str) -> isize {\n-    let error_string = format!(\n-        \"Encountered GDB version string with unexpected format: {}\",\n-        version_string);\n+    let error_string = format!(\"Encountered GDB version string with unexpected format: {}\",\n+                               version_string);\n     let error_string = error_string;\n \n     let components: Vec<&str> = version_string.trim().split('.').collect();\n@@ -473,9 +464,8 @@ pub fn gdb_version_to_int(version_string: &str) -> isize {\n }\n \n pub fn lldb_version_to_int(version_string: &str) -> isize {\n-    let error_string = format!(\n-        \"Encountered LLDB version string with unexpected format: {}\",\n-        version_string);\n+    let error_string = format!(\"Encountered LLDB version string with unexpected format: {}\",\n+                               version_string);\n     let error_string = error_string;\n     let major: isize = version_string.parse().ok().expect(&error_string);\n     return major;"}, {"sha": "d9da1bdc3485837d8024036f23ff5be81f5e7c71", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 40, "deletions": 50, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -12,7 +12,7 @@ use errors::{Error, ErrorKind};\n use rustc_serialize::json;\n use std::str::FromStr;\n use std::path::Path;\n-use runtest::{ProcRes};\n+use runtest::ProcRes;\n \n // These structs are a subset of the ones found in\n // `syntax::json`.\n@@ -58,8 +58,8 @@ struct DiagnosticCode {\n \n pub fn parse_output(file_name: &str, output: &str, proc_res: &ProcRes) -> Vec<Error> {\n     output.lines()\n-          .flat_map(|line| parse_line(file_name, line, output, proc_res))\n-          .collect()\n+        .flat_map(|line| parse_line(file_name, line, output, proc_res))\n+        .collect()\n }\n \n fn parse_line(file_name: &str, line: &str, output: &str, proc_res: &ProcRes) -> Vec<Error> {\n@@ -73,9 +73,11 @@ fn parse_line(file_name: &str, line: &str, output: &str, proc_res: &ProcRes) ->\n                 expected_errors\n             }\n             Err(error) => {\n-                proc_res.fatal(Some(&format!(\n-                    \"failed to decode compiler output as json: `{}`\\noutput: {}\\nline: {}\",\n-                    error, line, output)));\n+                proc_res.fatal(Some(&format!(\"failed to decode compiler output as json: \\\n+                                              `{}`\\noutput: {}\\nline: {}\",\n+                                             error,\n+                                             line,\n+                                             output)));\n             }\n         }\n     } else {\n@@ -87,16 +89,15 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n                         diagnostic: &Diagnostic,\n                         default_spans: &[&DiagnosticSpan],\n                         file_name: &str) {\n-    let spans_in_this_file: Vec<_> =\n-        diagnostic.spans.iter()\n-                        .filter(|span| Path::new(&span.file_name) == Path::new(&file_name))\n-                        .collect();\n-\n-    let primary_spans: Vec<_> =\n-        spans_in_this_file.iter()\n-                          .cloned()\n-                          .filter(|span| span.is_primary)\n-                          .collect();\n+    let spans_in_this_file: Vec<_> = diagnostic.spans\n+        .iter()\n+        .filter(|span| Path::new(&span.file_name) == Path::new(&file_name))\n+        .collect();\n+\n+    let primary_spans: Vec<_> = spans_in_this_file.iter()\n+        .cloned()\n+        .filter(|span| span.is_primary)\n+        .collect();\n     let primary_spans = if primary_spans.is_empty() {\n         // subdiagnostics often don't have a span of their own;\n         // inherit the span from the parent in that case\n@@ -144,24 +145,20 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n         for span in primary_spans {\n             let msg = with_code(span, first_line);\n             let kind = ErrorKind::from_str(&diagnostic.level).ok();\n-            expected_errors.push(\n-                Error {\n-                    line_num: span.line_start,\n-                    kind: kind,\n-                    msg: msg,\n-                }\n-            );\n+            expected_errors.push(Error {\n+                line_num: span.line_start,\n+                kind: kind,\n+                msg: msg,\n+            });\n         }\n     }\n     for next_line in message_lines {\n         for span in primary_spans {\n-            expected_errors.push(\n-                Error {\n-                    line_num: span.line_start,\n-                    kind: None,\n-                    msg: with_code(span, next_line),\n-                }\n-            );\n+            expected_errors.push(Error {\n+                line_num: span.line_start,\n+                kind: None,\n+                msg: with_code(span, next_line),\n+            });\n         }\n     }\n \n@@ -170,33 +167,28 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n         let start_line = primary_spans.iter().map(|s| s.line_start).min().expect(\"\\\n             every suggestion should have at least one span\");\n         for (index, line) in rendered.lines().enumerate() {\n-            expected_errors.push(\n-                Error {\n-                    line_num: start_line + index,\n-                    kind: Some(ErrorKind::Suggestion),\n-                    msg: line.to_string()\n-                }\n-            );\n+            expected_errors.push(Error {\n+                line_num: start_line + index,\n+                kind: Some(ErrorKind::Suggestion),\n+                msg: line.to_string(),\n+            });\n         }\n     }\n \n     // Add notes for the backtrace\n     for span in primary_spans {\n         for frame in &span.expansion {\n-            push_backtrace(expected_errors,\n-                           frame,\n-                           file_name);\n+            push_backtrace(expected_errors, frame, file_name);\n         }\n     }\n \n     // Add notes for any labels that appear in the message.\n     for span in spans_in_this_file.iter()\n-                                  .filter(|span| span.label.is_some())\n-    {\n+        .filter(|span| span.label.is_some()) {\n         expected_errors.push(Error {\n             line_num: span.line_start,\n             kind: Some(ErrorKind::Note),\n-            msg: span.label.clone().unwrap()\n+            msg: span.label.clone().unwrap(),\n         });\n     }\n \n@@ -210,13 +202,11 @@ fn push_backtrace(expected_errors: &mut Vec<Error>,\n                   expansion: &DiagnosticSpanMacroExpansion,\n                   file_name: &str) {\n     if Path::new(&expansion.span.file_name) == Path::new(&file_name) {\n-        expected_errors.push(\n-            Error {\n-                line_num: expansion.span.line_start,\n-                kind: Some(ErrorKind::Note),\n-                msg: format!(\"in this expansion of {}\", expansion.macro_decl_name),\n-            }\n-        );\n+        expected_errors.push(Error {\n+            line_num: expansion.span.line_start,\n+            kind: Some(ErrorKind::Note),\n+            msg: format!(\"in this expansion of {}\", expansion.macro_decl_name),\n+        });\n     }\n \n     for previous_expansion in &expansion.span.expansion {"}, {"sha": "ed690c08a1ed27e08dc0c6e3ae334d933012fe0b", "filename": "src/tools/compiletest/src/procsrv.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -12,7 +12,7 @@ use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n use std::path::PathBuf;\n-use std::process::{ExitStatus, Command, Child, Output, Stdio};\n+use std::process::{Child, Command, ExitStatus, Output, Stdio};\n \n pub fn dylib_env_var() -> &'static str {\n     if cfg!(windows) {\n@@ -29,7 +29,7 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     // search path for the child.\n     let var = dylib_env_var();\n     let mut path = env::split_paths(&env::var_os(var).unwrap_or(OsString::new()))\n-                       .collect::<Vec<_>>();\n+        .collect::<Vec<_>>();\n     if let Some(p) = aux_path {\n         path.insert(0, PathBuf::from(p))\n     }\n@@ -40,20 +40,25 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     cmd.env(var, newpath);\n }\n \n-pub struct Result {pub status: ExitStatus, pub out: String, pub err: String}\n+pub struct Result {\n+    pub status: ExitStatus,\n+    pub out: String,\n+    pub err: String,\n+}\n \n pub fn run(lib_path: &str,\n            prog: &str,\n            aux_path: Option<&str>,\n            args: &[String],\n-           env: Vec<(String, String)> ,\n-           input: Option<String>) -> Option<Result> {\n+           env: Vec<(String, String)>,\n+           input: Option<String>)\n+           -> Option<Result> {\n \n     let mut cmd = Command::new(prog);\n     cmd.args(args)\n-       .stdin(Stdio::piped())\n-       .stdout(Stdio::piped())\n-       .stderr(Stdio::piped());\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .stderr(Stdio::piped());\n     add_target_env(&mut cmd, lib_path, aux_path);\n     for (key, val) in env {\n         cmd.env(&key, &val);\n@@ -64,31 +69,31 @@ pub fn run(lib_path: &str,\n             if let Some(input) = input {\n                 process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n             }\n-            let Output { status, stdout, stderr } =\n-                process.wait_with_output().unwrap();\n+            let Output { status, stdout, stderr } = process.wait_with_output().unwrap();\n \n             Some(Result {\n                 status: status,\n                 out: String::from_utf8(stdout).unwrap(),\n-                err: String::from_utf8(stderr).unwrap()\n+                err: String::from_utf8(stderr).unwrap(),\n             })\n-        },\n-        Err(..) => None\n+        }\n+        Err(..) => None,\n     }\n }\n \n pub fn run_background(lib_path: &str,\n-           prog: &str,\n-           aux_path: Option<&str>,\n-           args: &[String],\n-           env: Vec<(String, String)> ,\n-           input: Option<String>) -> Option<Child> {\n+                      prog: &str,\n+                      aux_path: Option<&str>,\n+                      args: &[String],\n+                      env: Vec<(String, String)>,\n+                      input: Option<String>)\n+                      -> Option<Child> {\n \n     let mut cmd = Command::new(prog);\n     cmd.args(args)\n-       .stdin(Stdio::piped())\n-       .stdout(Stdio::piped())\n-       .stderr(Stdio::piped());\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .stderr(Stdio::piped());\n     add_target_env(&mut cmd, lib_path, aux_path);\n     for (key, val) in env {\n         cmd.env(&key, &val);\n@@ -101,7 +106,7 @@ pub fn run_background(lib_path: &str,\n             }\n \n             Some(process)\n-        },\n-        Err(..) => None\n+        }\n+        Err(..) => None,\n     }\n }"}, {"sha": "e2629ffd8f54a3e122b373462ed6b711cbb27661", "filename": "src/tools/compiletest/src/raise_fd_limit.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -34,14 +34,21 @@ pub unsafe fn raise_fd_limit() {\n     let mut mib: [libc::c_int; 2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n     let mut maxfiles: libc::c_int = 0;\n     let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n-    if libc::sysctl(&mut mib[0], 2, &mut maxfiles as *mut _ as *mut _, &mut size,\n-              null_mut(), 0) != 0 {\n+    if libc::sysctl(&mut mib[0],\n+                    2,\n+                    &mut maxfiles as *mut _ as *mut _,\n+                    &mut size,\n+                    null_mut(),\n+                    0) != 0 {\n         let err = io::Error::last_os_error();\n         panic!(\"raise_fd_limit: error calling sysctl: {}\", err);\n     }\n \n     // Fetch the current resource limits\n-    let mut rlim = libc::rlimit{rlim_cur: 0, rlim_max: 0};\n+    let mut rlim = libc::rlimit {\n+        rlim_cur: 0,\n+        rlim_max: 0,\n+    };\n     if libc::getrlimit(libc::RLIMIT_NOFILE, &mut rlim) != 0 {\n         let err = io::Error::last_os_error();\n         panic!(\"raise_fd_limit: error calling getrlimit: {}\", err);"}, {"sha": "fca01029c44652ba87d542ed43e478f5a2d6313a", "filename": "src/tools/compiletest/src/uidiff.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fuidiff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Fuidiff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fuidiff.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -13,38 +13,35 @@\n \n pub fn diff_lines(actual: &str, expected: &str) -> Vec<String> {\n     // mega simplistic diff algorithm that just prints the things added/removed\n-    zip_all(actual.lines(), expected.lines()).enumerate().filter_map(|(i, (a,e))| {\n-        match (a, e) {\n-            (Some(a), Some(e)) => {\n-                if lines_match(e, a) {\n-                    None\n-                } else {\n-                    Some(format!(\"{:3} - |{}|\\n    + |{}|\\n\", i, e, a))\n+    zip_all(actual.lines(), expected.lines())\n+        .enumerate()\n+        .filter_map(|(i, (a, e))| {\n+            match (a, e) {\n+                (Some(a), Some(e)) => {\n+                    if lines_match(e, a) {\n+                        None\n+                    } else {\n+                        Some(format!(\"{:3} - |{}|\\n    + |{}|\\n\", i, e, a))\n+                    }\n                 }\n-            },\n-            (Some(a), None) => {\n-                Some(format!(\"{:3} -\\n    + |{}|\\n\", i, a))\n-            },\n-            (None, Some(e)) => {\n-                Some(format!(\"{:3} - |{}|\\n    +\\n\", i, e))\n-            },\n-            (None, None) => panic!(\"Cannot get here\")\n-        }\n-    }).collect()\n+                (Some(a), None) => Some(format!(\"{:3} -\\n    + |{}|\\n\", i, a)),\n+                (None, Some(e)) => Some(format!(\"{:3} - |{}|\\n    +\\n\", i, e)),\n+                (None, None) => panic!(\"Cannot get here\"),\n+            }\n+        })\n+        .collect()\n }\n \n fn lines_match(expected: &str, mut actual: &str) -> bool {\n     for (i, part) in expected.split(\"[..]\").enumerate() {\n         match actual.find(part) {\n             Some(j) => {\n                 if i == 0 && j != 0 {\n-                    return false\n+                    return false;\n                 }\n                 actual = &actual[j + part.len()..];\n             }\n-            None => {\n-                return false\n-            }\n+            None => return false,\n         }\n     }\n     actual.is_empty() || expected.ends_with(\"[..]\")\n@@ -55,20 +52,20 @@ struct ZipAll<I1: Iterator, I2: Iterator> {\n     second: I2,\n }\n \n-impl<T, I1: Iterator<Item=T>, I2: Iterator<Item=T>> Iterator for ZipAll<I1, I2> {\n+impl<T, I1: Iterator<Item = T>, I2: Iterator<Item = T>> Iterator for ZipAll<I1, I2> {\n     type Item = (Option<T>, Option<T>);\n     fn next(&mut self) -> Option<(Option<T>, Option<T>)> {\n         let first = self.first.next();\n         let second = self.second.next();\n \n         match (first, second) {\n             (None, None) => None,\n-            (a, b) => Some((a, b))\n+            (a, b) => Some((a, b)),\n         }\n     }\n }\n \n-fn zip_all<T, I1: Iterator<Item=T>, I2: Iterator<Item=T>>(a: I1, b: I2) -> ZipAll<I1, I2> {\n+fn zip_all<T, I1: Iterator<Item = T>, I2: Iterator<Item = T>>(a: I1, b: I2) -> ZipAll<I1, I2> {\n     ZipAll {\n         first: a,\n         second: b,"}, {"sha": "d2872a0a2b7caa18ef6d42a7c879a4297fde8018", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787a12334439d47e931be26fef53381ce337c3a/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=8787a12334439d47e931be26fef53381ce337c3a", "patch": "@@ -12,54 +12,50 @@ use std::env;\n use common::Config;\n \n /// Conversion table from triple OS name to Rust SYSNAME\n-const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n-    (\"android\", \"android\"),\n-    (\"bitrig\", \"bitrig\"),\n-    (\"darwin\", \"macos\"),\n-    (\"dragonfly\", \"dragonfly\"),\n-    (\"freebsd\", \"freebsd\"),\n-    (\"ios\", \"ios\"),\n-    (\"linux\", \"linux\"),\n-    (\"mingw32\", \"windows\"),\n-    (\"netbsd\", \"netbsd\"),\n-    (\"openbsd\", \"openbsd\"),\n-    (\"win32\", \"windows\"),\n-    (\"windows\", \"windows\"),\n-    (\"solaris\", \"solaris\"),\n-    (\"emscripten\", \"emscripten\"),\n-];\n+const OS_TABLE: &'static [(&'static str, &'static str)] = &[(\"android\", \"android\"),\n+                                                            (\"bitrig\", \"bitrig\"),\n+                                                            (\"darwin\", \"macos\"),\n+                                                            (\"dragonfly\", \"dragonfly\"),\n+                                                            (\"freebsd\", \"freebsd\"),\n+                                                            (\"ios\", \"ios\"),\n+                                                            (\"linux\", \"linux\"),\n+                                                            (\"mingw32\", \"windows\"),\n+                                                            (\"netbsd\", \"netbsd\"),\n+                                                            (\"openbsd\", \"openbsd\"),\n+                                                            (\"win32\", \"windows\"),\n+                                                            (\"windows\", \"windows\"),\n+                                                            (\"solaris\", \"solaris\"),\n+                                                            (\"emscripten\", \"emscripten\")];\n \n-const ARCH_TABLE: &'static [(&'static str, &'static str)] = &[\n-    (\"aarch64\", \"aarch64\"),\n-    (\"amd64\", \"x86_64\"),\n-    (\"arm\", \"arm\"),\n-    (\"arm64\", \"aarch64\"),\n-    (\"hexagon\", \"hexagon\"),\n-    (\"i386\", \"x86\"),\n-    (\"i686\", \"x86\"),\n-    (\"mips\", \"mips\"),\n-    (\"msp430\", \"msp430\"),\n-    (\"powerpc\", \"powerpc\"),\n-    (\"powerpc64\", \"powerpc64\"),\n-    (\"s390x\", \"systemz\"),\n-    (\"sparc\", \"sparc\"),\n-    (\"x86_64\", \"x86_64\"),\n-    (\"xcore\", \"xcore\"),\n-    (\"asmjs\", \"asmjs\"),\n-];\n+const ARCH_TABLE: &'static [(&'static str, &'static str)] = &[(\"aarch64\", \"aarch64\"),\n+                                                              (\"amd64\", \"x86_64\"),\n+                                                              (\"arm\", \"arm\"),\n+                                                              (\"arm64\", \"aarch64\"),\n+                                                              (\"hexagon\", \"hexagon\"),\n+                                                              (\"i386\", \"x86\"),\n+                                                              (\"i686\", \"x86\"),\n+                                                              (\"mips\", \"mips\"),\n+                                                              (\"msp430\", \"msp430\"),\n+                                                              (\"powerpc\", \"powerpc\"),\n+                                                              (\"powerpc64\", \"powerpc64\"),\n+                                                              (\"s390x\", \"systemz\"),\n+                                                              (\"sparc\", \"sparc\"),\n+                                                              (\"x86_64\", \"x86_64\"),\n+                                                              (\"xcore\", \"xcore\"),\n+                                                              (\"asmjs\", \"asmjs\")];\n \n pub fn get_os(triple: &str) -> &'static str {\n     for &(triple_os, os) in OS_TABLE {\n         if triple.contains(triple_os) {\n-            return os\n+            return os;\n         }\n     }\n     panic!(\"Cannot determine OS from triple\");\n }\n pub fn get_arch(triple: &str) -> &'static str {\n     for &(triple_arch, arch) in ARCH_TABLE {\n         if triple.contains(triple_arch) {\n-            return arch\n+            return arch;\n         }\n     }\n     panic!(\"Cannot determine Architecture from triple\");\n@@ -74,17 +70,21 @@ pub fn make_new_path(path: &str) -> String {\n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n     match env::var(lib_path_env_var()) {\n-        Ok(curr) => {\n-            format!(\"{}{}{}\", path, path_div(), curr)\n-        }\n-        Err(..) => path.to_owned()\n+        Ok(curr) => format!(\"{}{}{}\", path, path_div(), curr),\n+        Err(..) => path.to_owned(),\n     }\n }\n \n-pub fn lib_path_env_var() -> &'static str { \"PATH\" }\n-fn path_div() -> &'static str { \";\" }\n+pub fn lib_path_env_var() -> &'static str {\n+    \"PATH\"\n+}\n+fn path_div() -> &'static str {\n+    \";\"\n+}\n \n pub fn logv(config: &Config, s: String) {\n     debug!(\"{}\", s);\n-    if config.verbose { println!(\"{}\", s); }\n+    if config.verbose {\n+        println!(\"{}\", s);\n+    }\n }"}]}