{"sha": "24fccdc45c170a6d64025bbebd44ae30bea52d32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZmNjZGM0NWMxNzBhNmQ2NDAyNWJiZWJkNDRhZTMwYmVhNTJkMzI=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-08-05T06:50:49Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-08-05T10:55:03Z"}, "message": "Factor out functions that extract comments around items", "tree": {"sha": "164d3958dc306e0e10e2d4954469803ecc13dd98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/164d3958dc306e0e10e2d4954469803ecc13dd98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24fccdc45c170a6d64025bbebd44ae30bea52d32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24fccdc45c170a6d64025bbebd44ae30bea52d32", "html_url": "https://github.com/rust-lang/rust/commit/24fccdc45c170a6d64025bbebd44ae30bea52d32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24fccdc45c170a6d64025bbebd44ae30bea52d32/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ec6de1de8ed9d4576d667893b3dd066704837a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ec6de1de8ed9d4576d667893b3dd066704837a8", "html_url": "https://github.com/rust-lang/rust/commit/3ec6de1de8ed9d4576d667893b3dd066704837a8"}], "stats": {"total": 260, "additions": 142, "deletions": 118}, "files": [{"sha": "9a21b720dc03c8e5bd91f598748850e160c236c1", "filename": "src/lists.rs", "status": "modified", "additions": 142, "deletions": 118, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/24fccdc45c170a6d64025bbebd44ae30bea52d32/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24fccdc45c170a6d64025bbebd44ae30bea52d32/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=24fccdc45c170a6d64025bbebd44ae30bea52d32", "patch": "@@ -515,6 +515,139 @@ where\n     leave_last: bool,\n }\n \n+pub fn extract_pre_comment(pre_snippet: &str) -> (Option<String>, ListItemCommentStyle) {\n+    let trimmed_pre_snippet = pre_snippet.trim();\n+    let has_single_line_comment = trimmed_pre_snippet.starts_with(\"//\");\n+    let has_block_comment = trimmed_pre_snippet.starts_with(\"/*\");\n+    if has_single_line_comment {\n+        (\n+            Some(trimmed_pre_snippet.to_owned()),\n+            ListItemCommentStyle::DifferentLine,\n+        )\n+    } else if has_block_comment {\n+        let comment_end = pre_snippet.chars().rev().position(|c| c == '/').unwrap();\n+        if pre_snippet\n+            .chars()\n+            .rev()\n+            .take(comment_end + 1)\n+            .any(|c| c == '\\n')\n+        {\n+            (\n+                Some(trimmed_pre_snippet.to_owned()),\n+                ListItemCommentStyle::DifferentLine,\n+            )\n+        } else {\n+            (\n+                Some(trimmed_pre_snippet.to_owned()),\n+                ListItemCommentStyle::SameLine,\n+            )\n+        }\n+    } else {\n+        (None, ListItemCommentStyle::None)\n+    }\n+}\n+\n+pub fn extract_post_comment(\n+    post_snippet: &str,\n+    comment_end: usize,\n+    separator: &str,\n+) -> Option<String> {\n+    let white_space: &[_] = &[' ', '\\t'];\n+\n+    // Cleanup post-comment: strip separators and whitespace.\n+    let post_snippet = post_snippet[..comment_end].trim();\n+    let post_snippet_trimmed = if post_snippet.starts_with(|c| c == ',' || c == ':') {\n+        post_snippet[1..].trim_matches(white_space)\n+    } else if post_snippet.starts_with(separator) {\n+        post_snippet[separator.len()..].trim_matches(white_space)\n+    } else if post_snippet.ends_with(',') {\n+        post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n+    } else {\n+        post_snippet\n+    };\n+\n+    if !post_snippet_trimmed.is_empty() {\n+        Some(post_snippet_trimmed.to_owned())\n+    } else {\n+        None\n+    }\n+}\n+\n+pub fn get_comment_end(\n+    post_snippet: &str,\n+    separator: &str,\n+    terminator: &str,\n+    is_last: bool,\n+) -> usize {\n+    if is_last {\n+        return post_snippet\n+            .find_uncommented(terminator)\n+            .unwrap_or_else(|| post_snippet.len());\n+    }\n+\n+    let mut block_open_index = post_snippet.find(\"/*\");\n+    // check if it really is a block comment (and not `//*` or a nested comment)\n+    if let Some(i) = block_open_index {\n+        match post_snippet.find('/') {\n+            Some(j) if j < i => block_open_index = None,\n+            _ if i > 0 && &post_snippet[i - 1..i] == \"/\" => block_open_index = None,\n+            _ => (),\n+        }\n+    }\n+    let newline_index = post_snippet.find('\\n');\n+    if let Some(separator_index) = post_snippet.find_uncommented(separator) {\n+        match (block_open_index, newline_index) {\n+            // Separator before comment, with the next item on same line.\n+            // Comment belongs to next item.\n+            (Some(i), None) if i > separator_index => separator_index + 1,\n+            // Block-style post-comment before the separator.\n+            (Some(i), None) => cmp::max(\n+                find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                separator_index + 1,\n+            ),\n+            // Block-style post-comment. Either before or after the separator.\n+            (Some(i), Some(j)) if i < j => cmp::max(\n+                find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                separator_index + 1,\n+            ),\n+            // Potential *single* line comment.\n+            (_, Some(j)) if j > separator_index => j + 1,\n+            _ => post_snippet.len(),\n+        }\n+    } else if let Some(newline_index) = newline_index {\n+        // Match arms may not have trailing comma. In any case, for match arms,\n+        // we will assume that the post comment belongs to the next arm if they\n+        // do not end with trailing comma.\n+        newline_index + 1\n+    } else {\n+        0\n+    }\n+}\n+\n+// Account for extra whitespace between items. This is fiddly\n+// because of the way we divide pre- and post- comments.\n+fn has_extra_newline(post_snippet: &str, comment_end: usize) -> bool {\n+    if post_snippet.is_empty() || comment_end == 0 {\n+        return false;\n+    }\n+\n+    // Everything from the separator to the next item.\n+    let test_snippet = &post_snippet[comment_end - 1..];\n+    let first_newline = test_snippet\n+        .find('\\n')\n+        .unwrap_or_else(|| test_snippet.len());\n+    // From the end of the first line of comments.\n+    let test_snippet = &test_snippet[first_newline..];\n+    let first = test_snippet\n+        .find(|c: char| !c.is_whitespace())\n+        .unwrap_or_else(|| test_snippet.len());\n+    // From the end of the first line of comments to the next non-whitespace char.\n+    let test_snippet = &test_snippet[..first];\n+\n+    // There were multiple line breaks which got trimmed to nothing.\n+    count_newlines(test_snippet) > 1\n+}\n+\n impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n where\n     I: Iterator<Item = T>,\n@@ -525,44 +658,13 @@ where\n     type Item = ListItem;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        let white_space: &[_] = &[' ', '\\t'];\n-\n         self.inner.next().map(|item| {\n-            let mut new_lines = false;\n             // Pre-comment\n             let pre_snippet = self\n                 .snippet_provider\n                 .span_to_snippet(mk_sp(self.prev_span_end, (self.get_lo)(&item)))\n                 .unwrap_or(\"\");\n-            let trimmed_pre_snippet = pre_snippet.trim();\n-            let has_single_line_comment = trimmed_pre_snippet.starts_with(\"//\");\n-            let has_block_comment = trimmed_pre_snippet.starts_with(\"/*\");\n-            let (pre_comment, pre_comment_style) = if has_single_line_comment {\n-                (\n-                    Some(trimmed_pre_snippet.to_owned()),\n-                    ListItemCommentStyle::DifferentLine,\n-                )\n-            } else if has_block_comment {\n-                let comment_end = pre_snippet.chars().rev().position(|c| c == '/').unwrap();\n-                if pre_snippet\n-                    .chars()\n-                    .rev()\n-                    .take(comment_end + 1)\n-                    .any(|c| c == '\\n')\n-                {\n-                    (\n-                        Some(trimmed_pre_snippet.to_owned()),\n-                        ListItemCommentStyle::DifferentLine,\n-                    )\n-                } else {\n-                    (\n-                        Some(trimmed_pre_snippet.to_owned()),\n-                        ListItemCommentStyle::SameLine,\n-                    )\n-                }\n-            } else {\n-                (None, ListItemCommentStyle::None)\n-            };\n+            let (pre_comment, pre_comment_style) = extract_pre_comment(pre_snippet);\n \n             // Post-comment\n             let next_start = match self.inner.peek() {\n@@ -573,94 +675,16 @@ where\n                 .snippet_provider\n                 .span_to_snippet(mk_sp((self.get_hi)(&item), next_start))\n                 .unwrap_or(\"\");\n+            let comment_end = get_comment_end(\n+                post_snippet,\n+                self.separator,\n+                self.terminator,\n+                self.inner.peek().is_none(),\n+            );\n+            let new_lines = has_extra_newline(post_snippet, comment_end);\n+            let post_comment = extract_post_comment(post_snippet, comment_end, self.separator);\n \n-            let comment_end = match self.inner.peek() {\n-                Some(..) => {\n-                    let mut block_open_index = post_snippet.find(\"/*\");\n-                    // check if it really is a block comment (and not `//*` or a nested comment)\n-                    if let Some(i) = block_open_index {\n-                        match post_snippet.find('/') {\n-                            Some(j) if j < i => block_open_index = None,\n-                            _ if i > 0 && &post_snippet[i - 1..i] == \"/\" => block_open_index = None,\n-                            _ => (),\n-                        }\n-                    }\n-                    let newline_index = post_snippet.find('\\n');\n-                    if let Some(separator_index) = post_snippet.find_uncommented(self.separator) {\n-                        match (block_open_index, newline_index) {\n-                            // Separator before comment, with the next item on same line.\n-                            // Comment belongs to next item.\n-                            (Some(i), None) if i > separator_index => separator_index + 1,\n-                            // Block-style post-comment before the separator.\n-                            (Some(i), None) => cmp::max(\n-                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                separator_index + 1,\n-                            ),\n-                            // Block-style post-comment. Either before or after the separator.\n-                            (Some(i), Some(j)) if i < j => cmp::max(\n-                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                separator_index + 1,\n-                            ),\n-                            // Potential *single* line comment.\n-                            (_, Some(j)) if j > separator_index => j + 1,\n-                            _ => post_snippet.len(),\n-                        }\n-                    } else if let Some(newline_index) = newline_index {\n-                        // Match arms may not have trailing comma. In any case, for match arms,\n-                        // we will assume that the post comment belongs to the next arm if they\n-                        // do not end with trailing comma.\n-                        newline_index + 1\n-                    } else {\n-                        0\n-                    }\n-                }\n-                None => post_snippet\n-                    .find_uncommented(self.terminator)\n-                    .unwrap_or_else(|| post_snippet.len()),\n-            };\n-\n-            if !post_snippet.is_empty() && comment_end > 0 {\n-                // Account for extra whitespace between items. This is fiddly\n-                // because of the way we divide pre- and post- comments.\n-\n-                // Everything from the separator to the next item.\n-                let test_snippet = &post_snippet[comment_end - 1..];\n-                let first_newline = test_snippet\n-                    .find('\\n')\n-                    .unwrap_or_else(|| test_snippet.len());\n-                // From the end of the first line of comments.\n-                let test_snippet = &test_snippet[first_newline..];\n-                let first = test_snippet\n-                    .find(|c: char| !c.is_whitespace())\n-                    .unwrap_or_else(|| test_snippet.len());\n-                // From the end of the first line of comments to the next non-whitespace char.\n-                let test_snippet = &test_snippet[..first];\n-\n-                if count_newlines(test_snippet) > 1 {\n-                    // There were multiple line breaks which got trimmed to nothing.\n-                    new_lines = true;\n-                }\n-            }\n-\n-            // Cleanup post-comment: strip separators and whitespace.\n             self.prev_span_end = (self.get_hi)(&item) + BytePos(comment_end as u32);\n-            let post_snippet = post_snippet[..comment_end].trim();\n-\n-            let post_snippet_trimmed = if post_snippet.starts_with(|c| c == ',' || c == ':') {\n-                post_snippet[1..].trim_matches(white_space)\n-            } else if post_snippet.starts_with(self.separator) {\n-                post_snippet[self.separator.len()..].trim_matches(white_space)\n-            } else if post_snippet.ends_with(',') {\n-                post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n-            } else {\n-                post_snippet\n-            };\n-\n-            let post_comment = if !post_snippet_trimmed.is_empty() {\n-                Some(post_snippet_trimmed.to_owned())\n-            } else {\n-                None\n-            };\n \n             ListItem {\n                 pre_comment,"}]}