{"sha": "84005fadbf8854df069a3caf02c9493866b550be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MDA1ZmFkYmY4ODU0ZGYwNjlhM2NhZjAyYzk0OTM4NjZiNTUwYmU=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-17T00:33:31Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-21T20:31:27Z"}, "message": "Some progress on support for extending objects with new fields (issue\ninto four separate issues (#538, #539, #540, #543) with corresponding\ntests.", "tree": {"sha": "f5607d1019f90c135f90f07904bc2405cdc272c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5607d1019f90c135f90f07904bc2405cdc272c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84005fadbf8854df069a3caf02c9493866b550be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84005fadbf8854df069a3caf02c9493866b550be", "html_url": "https://github.com/rust-lang/rust/commit/84005fadbf8854df069a3caf02c9493866b550be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84005fadbf8854df069a3caf02c9493866b550be/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "718ee98f43e7feecb38249a3519174054e3b7c79", "url": "https://api.github.com/repos/rust-lang/rust/commits/718ee98f43e7feecb38249a3519174054e3b7c79", "html_url": "https://github.com/rust-lang/rust/commit/718ee98f43e7feecb38249a3519174054e3b7c79"}], "stats": {"total": 373, "additions": 309, "deletions": 64}, "files": [{"sha": "6f59420be146cfef00482eadbab2a0a54566fa1e", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=84005fadbf8854df069a3caf02c9493866b550be", "patch": "@@ -409,14 +409,16 @@ type method_ = rec(ident ident, _fn meth, node_id id);\n type method = spanned[method_];\n \n type obj_field = rec(mutability mut, @ty ty, ident ident, node_id id);\n+type anon_obj_field = rec(mutability mut, @ty ty, @expr expr, ident ident,\n+                          node_id id);\n \n type _obj =\n     rec(vec[obj_field] fields, vec[@method] methods, option::t[@method] dtor);\n \n type anon_obj =\n     rec(\n         // New fields and methods, if they exist.\n-        option::t[vec[obj_field]] fields,\n+        option::t[vec[anon_obj_field]] fields,\n         vec[@method] methods,\n \n         // with_obj: the original object being extended, if it exists."}, {"sha": "aaf8533ba2bb6eab9b9a6c57d18033a470f233da", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=84005fadbf8854df069a3caf02c9493866b550be", "patch": "@@ -793,16 +793,15 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         // Anonymous object\n \n         // FIXME: Can anonymous objects have ty params?\n-\n         auto ty_params = parse_ty_params(p);\n-        // Only make people type () if they're actually adding new fields\n \n-        let option::t[vec[ast::obj_field]] fields = none;\n+        // Only make people type () if they're actually adding new fields\n+        let option::t[vec[ast::anon_obj_field]] fields = none;\n         if (p.peek() == token::LPAREN) {\n             p.bump();\n             fields =\n                 some(parse_seq_to_end(token::RPAREN, some(token::COMMA),\n-                                      parse_obj_field, p));\n+                                      parse_anon_obj_field, p));\n         }\n         let vec[@ast::method] meths = [];\n         let option::t[@ast::expr] with_obj = none;\n@@ -820,7 +819,6 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n \n         // We don't need to pull \".node\" out of fields because it's not a\n         // \"spanned\".\n-\n         let ast::anon_obj ob =\n             rec(fields=fields, methods=meths, with_obj=with_obj);\n         auto odid = rec(ty=p.get_id(), ctor=p.get_id());\n@@ -1730,6 +1728,16 @@ fn parse_obj_field(&parser p) -> ast::obj_field {\n     ret rec(mut=mut, ty=ty, ident=ident, id=p.get_id());\n }\n \n+fn parse_anon_obj_field(&parser p) -> ast::anon_obj_field {\n+    auto mut = parse_mutability(p);\n+    auto ty = parse_ty(p);\n+    auto ident = parse_value_ident(p);\n+    expect(p, token::EQ);\n+    auto expr = parse_expr(p);\n+    ret rec(mut=mut, ty=ty, expr=expr, ident=ident, id=p.next_def_id(), \n+            ann=p.get_ann());\n+}\n+\n fn parse_method(&parser p) -> @ast::method {\n     auto lo = p.get_lo_pos();\n     auto proto = parse_proto(p);"}, {"sha": "a3922dee6e2f3cc834ea713b156f7f602f6db715", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 175, "deletions": 40, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=84005fadbf8854df069a3caf02c9493866b550be", "patch": "@@ -69,6 +69,7 @@ import link::crate_meta_extras_hash;\n import pretty::ppaux::ty_to_str;\n import pretty::ppaux::ty_to_short_str;\n import pretty::pprust::expr_to_str;\n+import pretty::pprust::path_to_str;\n \n obj namegen(mutable int i) {\n     fn next(str prefix) -> str { i += 1; ret prefix + istr(i); }\n@@ -6500,23 +6501,38 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n \n     assert (vec::len(ty_params) == 0u);\n     auto ccx = bcx.fcx.lcx.ccx;\n+\n+    let vec[ast::anon_obj_field] additional_fields = [];\n+    let vec[result] additional_field_vals = [];\n+    let vec[ty::t] additional_field_tys = [];\n+    alt (anon_obj.fields) {\n+        case (none) { }\n+        case (some(?fields)) {\n+            additional_fields = fields;\n+            for (ast::anon_obj_field f in fields) {\n+                additional_field_tys += [node_ann_type(ccx, f.ann)];\n+                additional_field_vals += [trans_expr(bcx, f.expr)];\n+            }\n+        }\n+    }\n+\n     // If with_obj (the object being extended) exists, translate it, producing\n     // a result.\n-\n-    let option::t[result] with_obj_val = none[result];\n+    let option::t[result] with_obj_val = none;\n+    let ty::t with_obj_ty = ty::mk_type(ccx.tcx);\n     alt (anon_obj.with_obj) {\n         case (none) { }\n         case (some(?e)) {\n             // Translating with_obj returns a ValueRef (pointer to a 2-word\n-            // value) wrapped in a result.  We want to allocate space for this\n-            // value in our outer object, then copy it into the outer object.\n-\n-            with_obj_val = some[result](trans_expr(bcx, e));\n+            // value) wrapped in a result.\n+            with_obj_val  = some[result](trans_expr(bcx, e));\n+            with_obj_ty = node_ann_type(ccx, ty::expr_ann(e));\n         }\n     }\n-    // FIXME (part of issue #417): all of the following code is copypasta from\n-    // trans_obj for translating the anonymous wrapper object.  Eventually we\n-    // should abstract this code out of trans_anon_obj and trans_obj.\n+    // FIXME (part of issue #538): much of the following code is copypasta\n+    // from trans_obj for translating the anonymous wrapper object.\n+    // Eventually we might want to abstract this code out of trans_anon_obj\n+    // and trans_obj.\n \n     auto self_ty = ty::node_id_to_type(ccx.tcx, id);\n     auto llself_ty = type_of(ccx, sp, self_ty);\n@@ -6535,52 +6551,168 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     // Make a vtable for the outer object.  create_vtbl() wants an ast::_obj\n     // and all we have is an ast::anon_obj, so we need to roll our own.\n \n-    let vec[ast::obj_field] addtl_fields = [];\n-    alt (anon_obj.fields) {\n-        case (none) { }\n-        case (some(?fields)) { addtl_fields = fields; }\n-    }\n-    let ast::_obj wrapper_obj =\n-        rec(fields=addtl_fields,\n-            methods=anon_obj.methods,\n-            dtor=none[@ast::method]);\n-    auto vtbl =\n-        create_vtbl(bcx.fcx.lcx, llself_ty, self_ty, wrapper_obj, ty_params);\n+    fn anon_obj_field_to_obj_field(&ast::anon_obj_field f) -> ast::obj_field {\n+        ret rec(mut=f.mut, ty=f.ty, ident=f.ident, id=f.id, ann=f.ann);\n+    }\n+    let ast::_obj wrapper_obj = rec(\n+        fields = vec::map(anon_obj_field_to_obj_field, additional_fields),\n+        methods = anon_obj.methods,\n+        dtor = none[@ast::method]);\n+    auto vtbl = create_vtbl(bcx.fcx.lcx, llself_ty, self_ty, wrapper_obj, \n+                            ty_params);\n+\n     bcx.build.Store(vtbl, pair_vtbl);\n-    // FIXME (part of issue #417): This vtable needs to contain \"forwarding\n+    // FIXME (part of issue #538): Where do we fill in the field *values* from\n+    // the outer object?\n+\n+    // FIXME (part of issue #539): This vtable needs to contain \"forwarding\n     // slots\" for the methods that exist in the with_obj, as well.  How do we\n     // do that?\n \n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n-    // typarams, and fields.\n-\n-    // FIXME (part of issue #417): Because this is an anonymous object, we\n-    // also have to fill in the with_obj field of this tuple.\n+    // typarams, fields, and a pointer to our with_obj.\n \n     let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n-    alt (anon_obj.fields) {\n-        case (none) {\n-            // If the object we're translating has no fields or type\n-            // parameters, there's not much to do.\n \n-            // Store null into pair, if no args or typarams.\n+    if (vec::len[ast::ty_param](ty_params) == 0u &&\n+            vec::len[ast::anon_obj_field](additional_fields) == 0u) {\n+        // If the object we're translating has no fields or type parameters,\n+        // there's not much to do.\n+\n+        // Store null into pair, if no args or typarams.\n+        bcx.build.Store(C_null(llbox_ty), pair_box);\n+    } else {\n \n-            bcx.build.Store(C_null(llbox_ty), pair_box);\n+        // Synthesize a tuple type for fields: [field, ...]\n+        let ty::t fields_ty = ty::mk_imm_tup(ccx.tcx, additional_field_tys);\n+\n+        // Tydescs are run-time instantiations of typarams.  We're not\n+        // actually supporting typarams for anon objs yet, but let's\n+        // create space for them in case we ever want them.\n+        let ty::t tydesc_ty = ty::mk_type(ccx.tcx);\n+        let vec[ty::t] tps = [];\n+        for (ast::ty_param tp in ty_params) {\n+            vec::push[ty::t](tps, tydesc_ty);\n         }\n-        case (some(?fields)) {\n-            // For the moment let's pretend that there are no additional\n-            // fields.\n+        // Synthesize a tuple type for typarams: [typaram, ...]\n+        let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n+\n+        // Tuple type for body: \n+        // [tydesc_ty, [typaram, ...], [field, ...], with_obj]\n+        let ty::t body_ty =\n+            ty::mk_imm_tup(ccx.tcx, [tydesc_ty, typarams_ty, \n+                                     fields_ty, with_obj_ty]);\n+\n+        // Hand this type we've synthesized off to trans_malloc_boxed, which\n+        // allocates a box, including space for a refcount.\n+        auto box = trans_malloc_boxed(bcx, body_ty);\n+        bcx = box.bcx;\n+\n+        // mk_imm_box throws a refcount into the type we're synthesizing,\n+        // so that it looks like:\n+        // [rc, [tydesc_ty, [typaram, ...], [field, ...], with_obj]]\n+        let ty::t boxed_body_ty = ty::mk_imm_box(ccx.tcx, body_ty);\n+\n+        // Grab onto the refcount and body parts of the box we allocated.\n+        auto rc =\n+            GEP_tup_like(bcx, boxed_body_ty, box.val,\n+                         [0, abi::box_rc_field_refcnt]);\n+        bcx = rc.bcx;\n+        auto body =\n+            GEP_tup_like(bcx, boxed_body_ty, box.val,\n+                         [0, abi::box_rc_field_body]);\n+        bcx = body.bcx;\n+        bcx.build.Store(C_int(1), rc.val);\n \n-            bcx.fcx.lcx.ccx.sess.unimpl(\"anon objs don't support \" +\n-                                            \"adding fields yet\");\n-            // FIXME (issue #417): drop these fields into the newly created\n-            // object.\n+        // Put together a tydesc for the body, so that the object can later be\n+        // freed by calling through its tydesc.\n \n+        // Every object (not just those with type parameters) needs to have a\n+        // tydesc to describe its body, since all objects have unknown type to\n+        // the user of the object.  So the tydesc is needed to keep track of\n+        // the types of the object's fields, so that the fields can be freed\n+        // later.\n+\n+        auto body_tydesc =\n+            GEP_tup_like(bcx, body_ty, body.val,\n+                         [0, abi::obj_body_elt_tydesc]);\n+        bcx = body_tydesc.bcx;\n+        auto ti = none[@tydesc_info];\n+        auto body_td = get_tydesc(bcx, body_ty, true, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n+        bcx = body_td.bcx;\n+        bcx.build.Store(body_td.val, body_tydesc.val);\n+\n+        // Copy the object's type parameters and fields into the space we\n+        // allocated for the object body.  (This is something like saving the\n+        // lexical environment of a function in its closure: the \"captured\n+        // typarams\" are any type parameters that are passed to the object\n+        // constructor and are then available to the object's methods.\n+        // Likewise for the object's fields.)\n+\n+        // Copy typarams into captured typarams.\n+        auto body_typarams =\n+            GEP_tup_like(bcx, body_ty, body.val,\n+                         [0, abi::obj_body_elt_typarams]);\n+        bcx = body_typarams.bcx;\n+        let int i = 0;\n+        for (ast::ty_param tp in ty_params) {\n+            auto typaram = bcx.fcx.lltydescs.(i);\n+            auto capture =\n+                GEP_tup_like(bcx, typarams_ty, body_typarams.val, [0, i]);\n+            bcx = capture.bcx;\n+            bcx = copy_val(bcx, INIT, capture.val, typaram, \n+                           tydesc_ty).bcx;\n+            i += 1;\n+        }\n+\n+        // Copy additional fields into the object's body.\n+        auto body_fields =\n+            GEP_tup_like(bcx, body_ty, body.val,\n+                         [0, abi::obj_body_elt_fields]);\n+        bcx = body_fields.bcx;\n+        i = 0;\n+        for (ast::anon_obj_field f in additional_fields) {\n+            // FIXME (part of issue #538): make this work eventually, when we\n+            // have additional field exprs in the AST.\n+\n+            auto field_val = load_if_immediate(\n+                bcx,\n+                additional_field_vals.(i).val,\n+                additional_field_tys.(i));\n+\n+            // what was the type of arg_tys.(i)?  What's the type of\n+            // additional_field_tys.(i) ?\n+\n+            // arg_tys is a vector of ty::arg, so arg_tys.(i) is a ty::arg,\n+            // which is a record of mode and t.  Meanwhile,\n+            // additional_field_tys is a vec of ty::t.  So how about I just\n+            // don't index into it?\n+\n+            auto field =\n+                GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n+            bcx = field.bcx;\n+            bcx = copy_val(bcx, INIT, field.val,\n+                           additional_field_vals.(i).val, \n+                           additional_field_tys.(i)).bcx;\n+            i += 1;\n         }\n+\n+        // Copy a pointer to the with_obj into the object's body.  (TODO: Is\n+        // it necessary to use GEP_tup_like here?)\n+        auto body_with_obj =\n+            GEP_tup_like(bcx, body_ty, body.val,\n+                         [0, abi::obj_body_elt_with_obj]);\n+        bcx = body_with_obj.bcx;\n+\n+        // Store box ptr in outer pair.\n+        auto p = bcx.build.PointerCast(box.val, llbox_ty);\n+        bcx.build.Store(p, pair_box);\n     }\n-    // Return the object we built.\n \n+    // Return the object we built.\n     ret res(bcx, pair);\n }\n \n@@ -7306,7 +7438,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // typarams, and fields.\n \n     // FIXME: What about with_obj?  Do we have to think about it here?\n-    // (Pertains to issue #417.)\n+    // (Pertains to issues #538/#539/#540/#543.)\n \n     let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n     // FIXME: we should probably also allocate a box for empty objs that have\n@@ -7612,6 +7744,9 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path, str flav,\n     }\n }\n \n+// Create a closure: a pair containing (1) a ValueRef, pointing to where the\n+// fn's definition is in the executable we're creating, and (2) a pointer to\n+// space for the function's environment.\n fn create_fn_pair(&@crate_ctxt cx, str ps, TypeRef llfnty, ValueRef llfn,\n                   bool external) -> ValueRef {\n     auto gvar ="}, {"sha": "b6770839e2674b1e83258cde1298092eaf653904", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=84005fadbf8854df069a3caf02c9493866b550be", "patch": "@@ -2087,16 +2087,27 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n             // We're entering an object, so gather up the info we need.\n \n-            let vec[ast::obj_field] fields = [];\n+            let vec[ast::anon_obj_field] fields = [];\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?v)) { fields = v; }\n             }\n+\n+            // FIXME: this is duplicated between here and trans -- it should\n+            // appear in one place\n+            fn anon_obj_field_to_obj_field(&ast::anon_obj_field f) \n+                -> ast::obj_field {\n+                ret rec(mut=f.mut, ty=f.ty, ident=f.ident, id=f.id);\n+            }\n+\n             let ast::node_id di = obj_def_ids.ty;\n             vec::push[obj_info](fcx.ccx.obj_infos,\n-                                rec(obj_fields=fields, this_obj=di));\n-            // Typecheck 'with_obj', if it exists.\n+                                rec(obj_fields=\n+                                    vec::map(anon_obj_field_to_obj_field, \n+                                             fields),\n+                                    this_obj=di));\n \n+            // Typecheck 'with_obj', if it exists.\n             let option::t[@ast::expr] with_obj = none[@ast::expr];\n             alt (anon_obj.with_obj) {\n                 case (none) { }\n@@ -2108,9 +2119,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     check_expr(fcx, e);\n                 }\n             }\n+\n             // FIXME: These next three functions are largely ripped off from\n             // similar ones in collect::.  Is there a better way to do this?\n-\n             fn ty_of_arg(@crate_ctxt ccx, &ast::arg a) -> ty::arg {\n                 auto ty_mode = ast_mode_to_mode(a.mode);\n                 ret rec(mode=ty_mode, ty=ast_ty_to_ty_crate(ccx, a.ty));"}, {"sha": "8ac463796ab09fb2bef54112b92faad18b8d4c60", "filename": "src/comp/middle/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Fmiddle%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Fmiddle%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fvisit.rs?ref=84005fadbf8854df069a3caf02c9493866b550be", "patch": "@@ -372,8 +372,9 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?fields)) {\n-                    for (obj_field f in fields) {\n+                    for (anon_obj_field f in fields) {\n                         vt(v).visit_ty(f.ty, e, v);\n+                        vt(v).visit_expr(f.expr, e, v);\n                     }\n                 }\n             }"}, {"sha": "f1ae0b22554cc1a3614b8d534f2d09d4310ccbe5", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84005fadbf8854df069a3caf02c9493866b550be/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=84005fadbf8854df069a3caf02c9493866b550be", "patch": "@@ -379,12 +379,15 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n         case (ast::expr_anon_obj(?anon_obj, _, _)) {\n             // Fields\n \n-            let option::t[vec[ast::obj_field]] fields =\n-                none[vec[ast::obj_field]];\n+            let option::t[vec[ast::anon_obj_field]] fields =\n+                none[vec[ast::anon_obj_field]];\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?fields)) {\n-                    for (ast::obj_field f in fields) { walk_ty(v, f.ty); }\n+                    for (ast::anon_obj_field f in fields) { \n+                        walk_ty(v, f.ty);\n+                        walk_expr(v, f.expr);\n+                    }\n                 }\n             }\n             // with_obj"}, {"sha": "85d5bb3df52d8fb1e6b6bcff4578a755e7bf2679", "filename": "src/test/run-pass/anon-obj-degenerate.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/84005fadbf8854df069a3caf02c9493866b550be/src%2Ftest%2Frun-pass%2Fanon-obj-degenerate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84005fadbf8854df069a3caf02c9493866b550be/src%2Ftest%2Frun-pass%2Fanon-obj-degenerate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-obj-degenerate.rs?ref=84005fadbf8854df069a3caf02c9493866b550be", "patch": "@@ -0,0 +1,27 @@\n+//xfail-stage0\n+//xfail-stage1\n+use std;\n+\n+fn main() {\n+\n+    obj a() {\n+        fn foo() -> int {\n+            ret 2;\n+        }\n+        fn bar() -> int {\n+            ret self.foo();\n+        }\n+    }\n+\n+    auto my_a = a();\n+\n+    // Degenerate anonymous object: one that doesn't add any new\n+    // methods or fields.  Adding support for this is issue #539.\n+    // (Making this work will also ensure that calls to anonymous\n+    // objects \"fall through\" appropriately.)\n+    auto my_d = obj() { with my_a };\n+\n+    assert (my_d.foo() == 2);\n+    assert (my_d.bar() == 2);\n+\n+}"}, {"sha": "c362c1788f270e862807eea300ace80de05435dd", "filename": "src/test/run-pass/anon-obj-overloading.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/84005fadbf8854df069a3caf02c9493866b550be/src%2Ftest%2Frun-pass%2Fanon-obj-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84005fadbf8854df069a3caf02c9493866b550be/src%2Ftest%2Frun-pass%2Fanon-obj-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-obj-overloading.rs?ref=84005fadbf8854df069a3caf02c9493866b550be", "patch": "@@ -0,0 +1,34 @@\n+//xfail-stage0\n+//xfail-stage1\n+use std;\n+\n+fn main() {\n+\n+    obj a() {\n+        fn foo() -> int {\n+            ret 2;\n+        }\n+        fn bar() -> int {\n+            ret self.foo();\n+        }\n+    }\n+\n+    auto my_a = a();\n+\n+    // An anonymous object that overloads the 'foo' method.  Adding\n+    // support for this is issue #543 (making this work in the\n+    // presence of self-calls is the tricky part).\n+    auto my_b = obj() { \n+        fn foo() -> int {\n+            ret 3;\n+        }\n+\n+        with my_a \n+    };\n+\n+    assert (my_b.foo() == 3);\n+\n+    // The tricky part -- have to be sure to tie the knot in the right\n+    // place, so that bar() knows about the new foo().\n+    assert (my_b.bar() == 3);\n+}"}, {"sha": "fc3aa838ac58fdf11704bb3009b020b8516a3576", "filename": "src/test/run-pass/anon-obj-with-self-call.rs", "status": "renamed", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/84005fadbf8854df069a3caf02c9493866b550be/src%2Ftest%2Frun-pass%2Fanon-obj-with-self-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84005fadbf8854df069a3caf02c9493866b550be/src%2Ftest%2Frun-pass%2Fanon-obj-with-self-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-obj-with-self-call.rs?ref=84005fadbf8854df069a3caf02c9493866b550be", "patch": "@@ -1,7 +1,5 @@\n-\n-\n-// xfail-stage0\n-// xfail-stage1\n+//xfail-stage0\n+//xfail-stage1\n use std;\n \n fn main() {\n@@ -17,18 +15,15 @@ fn main() {\n \n     auto my_a = a();\n \n-    // Extending an object with a new method\n+    // Extending an object with a new method that contains a simple\n+    // self-call.  Adding support for this is issue #540.\n     auto my_b = obj { \n         fn baz() -> int { \n             ret self.foo(); \n         } \n         with my_a \n     };\n \n-    // Extending an object with a new field\n-    auto my_c = obj(int quux) { with my_a } ;\n+    assert (my_b.baz() == 2);\n \n-    // Should this be legal?\n-    auto my_d = obj() { with my_a } ;\n-    \n }", "previous_filename": "src/test/run-pass/anon-objs.rs"}, {"sha": "aa26415a4ff73ca0f5e392680e04684ddd63348a", "filename": "src/test/run-pass/anon-objs-with-fields.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/84005fadbf8854df069a3caf02c9493866b550be/src%2Ftest%2Frun-pass%2Fanon-objs-with-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84005fadbf8854df069a3caf02c9493866b550be/src%2Ftest%2Frun-pass%2Fanon-objs-with-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-objs-with-fields.rs?ref=84005fadbf8854df069a3caf02c9493866b550be", "patch": "@@ -0,0 +1,29 @@\n+//xfail-stage0\n+//xfail-stage1\n+use std;\n+\n+fn main() {\n+\n+    obj a() {\n+        fn foo() -> int {\n+            ret 2;\n+        }\n+        fn bar() -> int {\n+            ret self.foo();\n+        }\n+    }\n+\n+    auto my_a = a();\n+\n+    // Extending an object with a new field.  Adding support for this\n+    // is issue #538.\n+    auto my_c = obj(int quux = 3) {\n+        fn baz() -> int {\n+            ret quux + 4;\n+        }\n+        with my_a \n+    };\n+\n+    assert (my_c.baz() == 7);\n+\n+}"}]}