{"sha": "6e0fb70ff6effe7b7be2c5fe951e9161613e6707", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMGZiNzBmZjZlZmZlN2I3YmUyYzVmZTk1MWU5MTYxNjEzZTY3MDc=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-04-13T21:48:17Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-04-13T21:48:17Z"}, "message": "Generalize `spawn` beyond unit closures\n\n`thread::spawn` was previously restricted to closures that return `()`,\nwhich limited the utility of joining on a spawned thread. However, there\nis no reason for this restriction, and this commit allows arbitrary\nreturn types.\n\nSince it introduces a type parameter to `JoinHandle`, it's technically\na:\n\n[breaking-change]\n\nHowever, no code is actually expected to break.", "tree": {"sha": "21c4f6f8a87597e30384b86264701f4b30355562", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21c4f6f8a87597e30384b86264701f4b30355562"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e0fb70ff6effe7b7be2c5fe951e9161613e6707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e0fb70ff6effe7b7be2c5fe951e9161613e6707", "html_url": "https://github.com/rust-lang/rust/commit/6e0fb70ff6effe7b7be2c5fe951e9161613e6707", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e0fb70ff6effe7b7be2c5fe951e9161613e6707/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6399bb425b3a82111cd554737f194c95b8f6bad5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6399bb425b3a82111cd554737f194c95b8f6bad5", "html_url": "https://github.com/rust-lang/rust/commit/6399bb425b3a82111cd554737f194c95b8f6bad5"}], "stats": {"total": 42, "additions": 32, "deletions": 10}, "files": [{"sha": "29fcd1552834cfadd6f9234cd2cf039fae03ee6c", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6e0fb70ff6effe7b7be2c5fe951e9161613e6707/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e0fb70ff6effe7b7be2c5fe951e9161613e6707/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=6e0fb70ff6effe7b7be2c5fe951e9161613e6707", "patch": "@@ -67,11 +67,30 @@\n //! thread. This means that it can outlive its parent (the thread that spawned\n //! it), unless this parent is the main thread.\n //!\n+//! The parent thread can also wait on the completion of the child\n+//! thread; a call to `spawn` produces a `JoinHandle`, which provides\n+//! a `join` method for waiting:\n+//!\n+//! ```rust\n+//! use std::thread;\n+//!\n+//! let child = thread::spawn(move || {\n+//!     // some work here\n+//! });\n+//! // some work here\n+//! let res = child.join();\n+//! ```\n+//!\n+//! The `join` method returns a `Result` containing `Ok` of the final\n+//! value produced by the child thread, or `Err` of the value given to\n+//! a call to `panic!` if the child panicked.\n+//!\n //! ## Scoped threads\n //!\n-//! Often a parent thread uses a child thread to perform some particular task,\n-//! and at some point must wait for the child to complete before continuing.\n-//! For this scenario, use the `thread::scoped` function:\n+//! The `spawn` method does not allow the child and parent threads to\n+//! share any stack data, since that is not safe in general. However,\n+//! `scoped` makes it possible to share the parent's stack by forcing\n+//! a join before any relevant stack frames are popped:\n //!\n //! ```rust\n //! use std::thread;\n@@ -253,8 +272,8 @@ impl Builder {\n     /// `io::Result` to capture any failure to create the thread at\n     /// the OS level.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn spawn<F>(self, f: F) -> io::Result<JoinHandle> where\n-        F: FnOnce(), F: Send + 'static\n+    pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>> where\n+        F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n     {\n         self.spawn_inner(Box::new(f)).map(|i| JoinHandle(i))\n     }\n@@ -371,7 +390,9 @@ impl Builder {\n /// Panics if the OS fails to create a thread; use `Builder::spawn`\n /// to recover from such errors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn spawn<F>(f: F) -> JoinHandle where F: FnOnce(), F: Send + 'static {\n+pub fn spawn<F, T>(f: F) -> JoinHandle<T> where\n+    F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n+{\n     Builder::new().spawn(f).unwrap()\n }\n \n@@ -637,9 +658,9 @@ impl<T> JoinInner<T> {\n /// handle: the ability to join a child thread is a uniquely-owned\n /// permission.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct JoinHandle(JoinInner<()>);\n+pub struct JoinHandle<T>(JoinInner<T>);\n \n-impl JoinHandle {\n+impl<T> JoinHandle<T> {\n     /// Extract a handle to the underlying thread\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn thread(&self) -> &Thread {\n@@ -651,13 +672,14 @@ impl JoinHandle {\n     /// If the child thread panics, `Err` is returned with the parameter given\n     /// to `panic`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn join(mut self) -> Result<()> {\n+    pub fn join(mut self) -> Result<T> {\n         self.0.join()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Drop for JoinHandle {\n+#[unsafe_destructor]\n+impl<T> Drop for JoinHandle<T> {\n     fn drop(&mut self) {\n         if !self.0.joined {\n             unsafe { imp::detach(self.0.native) }"}]}