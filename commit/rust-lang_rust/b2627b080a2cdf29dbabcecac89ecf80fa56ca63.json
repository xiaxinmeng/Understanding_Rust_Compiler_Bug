{"sha": "b2627b080a2cdf29dbabcecac89ecf80fa56ca63", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNjI3YjA4MGEyY2RmMjlkYmFiY2VjYWM4OWVjZjgwZmE1NmNhNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-22T10:13:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-22T10:13:50Z"}, "message": "Auto merge of #36592 - nnethercote:TypedArena, r=bluss\n\nLazily allocate TypedArena's first chunk\n\nCurrently `TypedArena` allocates its first chunk, which is usually 4096\nbytes, as soon as it is created. If no allocations are ever made from\nthe arena then this allocation (and the corresponding deallocation) is\nwasted effort.\n\nThis commit changes `TypedArena` so it doesn't allocate the first chunk\nuntil the first allocation is made.\n\nThis change speeds up rustc by a non-trivial amount because rustc uses\n`TypedArena` heavily: compilation speed (producing debug builds) on\nseveral of the rustc-benchmarks increases by 1.02--1.06x. The change\nshould never cause a slow-down because the hot `alloc` function is\nunchanged. It does increase the size of `TypedArena` by one `usize`\nfield, however.\n\nThe commit also fixes some out-of-date comments.", "tree": {"sha": "a21e6e46361ea29a331f3faf779867a88a299716", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a21e6e46361ea29a331f3faf779867a88a299716"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2627b080a2cdf29dbabcecac89ecf80fa56ca63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2627b080a2cdf29dbabcecac89ecf80fa56ca63", "html_url": "https://github.com/rust-lang/rust/commit/b2627b080a2cdf29dbabcecac89ecf80fa56ca63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2627b080a2cdf29dbabcecac89ecf80fa56ca63/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ad10844db51b950306d49070932562246e06616", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad10844db51b950306d49070932562246e06616", "html_url": "https://github.com/rust-lang/rust/commit/6ad10844db51b950306d49070932562246e06616"}, {"sha": "80a44779f7a211e075da9ed0ff2763afa00f43dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/80a44779f7a211e075da9ed0ff2763afa00f43dc", "html_url": "https://github.com/rust-lang/rust/commit/80a44779f7a211e075da9ed0ff2763afa00f43dc"}], "stats": {"total": 93, "additions": 55, "deletions": 38}, "files": [{"sha": "556757ec84daf47df19ff444e523f34ba2534cf3", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 55, "deletions": 38, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b2627b080a2cdf29dbabcecac89ecf80fa56ca63/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2627b080a2cdf29dbabcecac89ecf80fa56ca63/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=b2627b080a2cdf29dbabcecac89ecf80fa56ca63", "patch": "@@ -15,9 +15,8 @@\n //! of individual objects while the arena itself is still alive. The benefit\n //! of an arena is very fast allocation; just a pointer bump.\n //!\n-//! This crate has two arenas implemented: `TypedArena`, which is a simpler\n-//! arena but can only hold objects of a single type, and `Arena`, which is a\n-//! more complex, slower arena which can hold objects of any type.\n+//! This crate implements `TypedArena`, a simple arena that can only hold\n+//! objects of a single type.\n \n #![crate_name = \"arena\"]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n@@ -51,16 +50,19 @@ use std::ptr;\n use alloc::heap;\n use alloc::raw_vec::RawVec;\n \n-/// A faster arena that can hold objects of only one type.\n+/// An arena that can hold objects of only one type.\n pub struct TypedArena<T> {\n+    /// The capacity of the first chunk (once it is allocated).\n+    first_chunk_capacity: usize,\n+\n     /// A pointer to the next object to be allocated.\n     ptr: Cell<*mut T>,\n \n     /// A pointer to the end of the allocated area. When this pointer is\n     /// reached, a new chunk is allocated.\n     end: Cell<*mut T>,\n \n-    /// A vector arena segments.\n+    /// A vector of arena chunks.\n     chunks: RefCell<Vec<TypedArenaChunk<T>>>,\n \n     /// Marker indicating that dropping the arena causes its owned\n@@ -69,7 +71,7 @@ pub struct TypedArena<T> {\n }\n \n struct TypedArenaChunk<T> {\n-    /// Pointer to the next arena segment.\n+    /// The raw storage for the arena chunk.\n     storage: RawVec<T>,\n }\n \n@@ -117,26 +119,26 @@ impl<T> TypedArenaChunk<T> {\n const PAGE: usize = 4096;\n \n impl<T> TypedArena<T> {\n-    /// Creates a new `TypedArena` with preallocated space for many objects.\n+    /// Creates a new `TypedArena`.\n     #[inline]\n     pub fn new() -> TypedArena<T> {\n         // Reserve at least one page.\n         let elem_size = cmp::max(1, mem::size_of::<T>());\n         TypedArena::with_capacity(PAGE / elem_size)\n     }\n \n-    /// Creates a new `TypedArena` with preallocated space for the given number of\n-    /// objects.\n+    /// Creates a new `TypedArena`. Each chunk used within the arena will have\n+    /// space for at least the given number of objects.\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> TypedArena<T> {\n-        unsafe {\n-            let chunk = TypedArenaChunk::<T>::new(cmp::max(1, capacity));\n-            TypedArena {\n-                ptr: Cell::new(chunk.start()),\n-                end: Cell::new(chunk.end()),\n-                chunks: RefCell::new(vec![chunk]),\n-                _own: PhantomData,\n-            }\n+        TypedArena {\n+            first_chunk_capacity: cmp::max(1, capacity),\n+            // We set both `ptr` and `end` to 0 so that the first call to\n+            // alloc() will trigger a grow().\n+            ptr: Cell::new(0 as *mut T),\n+            end: Cell::new(0 as *mut T),\n+            chunks: RefCell::new(vec![]),\n+            _own: PhantomData,\n         }\n     }\n \n@@ -171,29 +173,37 @@ impl<T> TypedArena<T> {\n     fn grow(&self) {\n         unsafe {\n             let mut chunks = self.chunks.borrow_mut();\n-            let prev_capacity = chunks.last().unwrap().storage.cap();\n-            let new_capacity = prev_capacity.checked_mul(2).unwrap();\n-            if chunks.last_mut().unwrap().storage.double_in_place() {\n-                self.end.set(chunks.last().unwrap().end());\n+            let (chunk, new_capacity);\n+            if let Some(last_chunk) = chunks.last_mut() {\n+                if last_chunk.storage.double_in_place() {\n+                    self.end.set(last_chunk.end());\n+                    return;\n+                } else {\n+                    let prev_capacity = last_chunk.storage.cap();\n+                    new_capacity = prev_capacity.checked_mul(2).unwrap();\n+                }\n             } else {\n-                let chunk = TypedArenaChunk::<T>::new(new_capacity);\n-                self.ptr.set(chunk.start());\n-                self.end.set(chunk.end());\n-                chunks.push(chunk);\n+                new_capacity = self.first_chunk_capacity;\n             }\n+            chunk = TypedArenaChunk::<T>::new(new_capacity);\n+            self.ptr.set(chunk.start());\n+            self.end.set(chunk.end());\n+            chunks.push(chunk);\n         }\n     }\n     /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n     pub fn clear(&mut self) {\n         unsafe {\n             // Clear the last chunk, which is partially filled.\n             let mut chunks_borrow = self.chunks.borrow_mut();\n-            let last_idx = chunks_borrow.len() - 1;\n-            self.clear_last_chunk(&mut chunks_borrow[last_idx]);\n-            // If `T` is ZST, code below has no effect.\n-            for mut chunk in chunks_borrow.drain(..last_idx) {\n-                let cap = chunk.storage.cap();\n-                chunk.destroy(cap);\n+            if let Some(mut last_chunk) = chunks_borrow.pop() {\n+                self.clear_last_chunk(&mut last_chunk);\n+                // If `T` is ZST, code below has no effect.\n+                for mut chunk in chunks_borrow.drain(..) {\n+                    let cap = chunk.storage.cap();\n+                    chunk.destroy(cap);\n+                }\n+                chunks_borrow.push(last_chunk);\n             }\n         }\n     }\n@@ -230,13 +240,14 @@ impl<T> Drop for TypedArena<T> {\n         unsafe {\n             // Determine how much was filled.\n             let mut chunks_borrow = self.chunks.borrow_mut();\n-            let mut last_chunk = chunks_borrow.pop().unwrap();\n-            // Drop the contents of the last chunk.\n-            self.clear_last_chunk(&mut last_chunk);\n-            // The last chunk will be dropped. Destroy all other chunks.\n-            for chunk in chunks_borrow.iter_mut() {\n-                let cap = chunk.storage.cap();\n-                chunk.destroy(cap);\n+            if let Some(mut last_chunk) = chunks_borrow.pop() {\n+                // Drop the contents of the last chunk.\n+                self.clear_last_chunk(&mut last_chunk);\n+                // The last chunk will be dropped. Destroy all other chunks.\n+                for chunk in chunks_borrow.iter_mut() {\n+                    let cap = chunk.storage.cap();\n+                    chunk.destroy(cap);\n+                }\n             }\n             // RawVec handles deallocation of `last_chunk` and `self.chunks`.\n         }\n@@ -260,6 +271,12 @@ mod tests {\n         z: i32,\n     }\n \n+    #[test]\n+    pub fn test_unused() {\n+        let arena: TypedArena<Point> = TypedArena::new();\n+        assert!(arena.chunks.borrow().is_empty());\n+    }\n+\n     #[test]\n     fn test_arena_alloc_nested() {\n         struct Inner {"}]}