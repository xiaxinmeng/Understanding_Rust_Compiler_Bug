{"sha": "ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNTVhMGE5MmYzY2I2NTcyZWY2N2Q5OWY0YWVmYmRlYjdiNmI4MDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-04T12:21:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-04T12:21:43Z"}, "message": "Auto merge of #75207 - dylni:add-slice-check-range, r=KodrAus\n\nAdd `slice::check_range`\n\nThis method is useful for [`RangeBounds`] parameters. It's even been [rewritten](https://github.com/rust-lang/rust/blob/22ee68dc586440f96b76b32fbd6087507c6afdb9/src/librustc_data_structures/sorted_map.rs#L214) [many](https://github.com/rust-lang/rust/blob/22ee68dc586440f96b76b32fbd6087507c6afdb9/library/alloc/src/vec.rs#L1299) [times](https://github.com/rust-lang/rust/blob/22ee68dc586440f96b76b32fbd6087507c6afdb9/library/core/src/slice/mod.rs#L2441) in the standard library, sometimes assuming that the bounds won't be [`usize::MAX`].\n\nFor example, [`Vec::drain`] creates an empty iterator when [`usize::MAX`] is used as an inclusive end bound:\n\n```rust\nassert!(vec![1].drain(..=usize::max_value()).eq(iter::empty()));\n```\n\nIf this PR is merged, I'll create another to use it for those methods.\n\n[`RangeBounds`]: https://doc.rust-lang.org/std/ops/trait.RangeBounds.html\n[`usize::MAX`]: https://doc.rust-lang.org/std/primitive.usize.html#associatedconstant.MAX\n[`Vec::drain`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.drain", "tree": {"sha": "f811be6020731d8ff158e0e4d6b0265c9662370d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f811be6020731d8ff158e0e4d6b0265c9662370d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804", "html_url": "https://github.com/rust-lang/rust/commit/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ffb5c5954a304daf47a567b34e74e421db86d98", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ffb5c5954a304daf47a567b34e74e421db86d98", "html_url": "https://github.com/rust-lang/rust/commit/4ffb5c5954a304daf47a567b34e74e421db86d98"}, {"sha": "d9e877fb98212a47dd425e145b8b3e4283e6b487", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9e877fb98212a47dd425e145b8b3e4283e6b487", "html_url": "https://github.com/rust-lang/rust/commit/d9e877fb98212a47dd425e145b8b3e4283e6b487"}], "stats": {"total": 205, "additions": 111, "deletions": 94}, "files": [{"sha": "cc2ef25a5a7d15fca6b7460f469a8424c04c70cb", "filename": "library/alloc/src/collections/vec_deque.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs?ref=ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804", "patch": "@@ -14,8 +14,7 @@ use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::iter::{once, repeat_with, FromIterator, FusedIterator};\n use core::mem::{self, replace, ManuallyDrop};\n-use core::ops::Bound::{Excluded, Included, Unbounded};\n-use core::ops::{Index, IndexMut, RangeBounds, Try};\n+use core::ops::{Index, IndexMut, Range, RangeBounds, Try};\n use core::ptr::{self, NonNull};\n use core::slice;\n \n@@ -1090,24 +1089,18 @@ impl<T> VecDeque<T> {\n         self.tail == self.head\n     }\n \n-    fn range_start_end<R>(&self, range: R) -> (usize, usize)\n+    fn range_tail_head<R>(&self, range: R) -> (usize, usize)\n     where\n         R: RangeBounds<usize>,\n     {\n-        let len = self.len();\n-        let start = match range.start_bound() {\n-            Included(&n) => n,\n-            Excluded(&n) => n + 1,\n-            Unbounded => 0,\n-        };\n-        let end = match range.end_bound() {\n-            Included(&n) => n + 1,\n-            Excluded(&n) => n,\n-            Unbounded => len,\n-        };\n-        assert!(start <= end, \"lower bound was too large\");\n-        assert!(end <= len, \"upper bound was too large\");\n-        (start, end)\n+        // SAFETY: This buffer is only used to check the range. It might be partially\n+        // uninitialized, but `check_range` needs a contiguous slice.\n+        // https://github.com/rust-lang/rust/pull/75207#discussion_r471193682\n+        let buffer = unsafe { slice::from_raw_parts(self.ptr(), self.len()) };\n+        let Range { start, end } = buffer.check_range(range);\n+        let tail = self.wrap_add(self.tail, start);\n+        let head = self.wrap_add(self.tail, end);\n+        (tail, head)\n     }\n \n     /// Creates an iterator that covers the specified range in the `VecDeque`.\n@@ -1138,9 +1131,7 @@ impl<T> VecDeque<T> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (start, end) = self.range_start_end(range);\n-        let tail = self.wrap_add(self.tail, start);\n-        let head = self.wrap_add(self.tail, end);\n+        let (tail, head) = self.range_tail_head(range);\n         Iter {\n             tail,\n             head,\n@@ -1181,9 +1172,7 @@ impl<T> VecDeque<T> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (start, end) = self.range_start_end(range);\n-        let tail = self.wrap_add(self.tail, start);\n-        let head = self.wrap_add(self.tail, end);\n+        let (tail, head) = self.range_tail_head(range);\n         IterMut {\n             tail,\n             head,\n@@ -1237,7 +1226,7 @@ impl<T> VecDeque<T> {\n         // When finished, the remaining data will be copied back to cover the hole,\n         // and the head/tail values will be restored correctly.\n         //\n-        let (start, end) = self.range_start_end(range);\n+        let (drain_tail, drain_head) = self.range_tail_head(range);\n \n         // The deque's elements are parted into three segments:\n         // * self.tail  -> drain_tail\n@@ -1255,8 +1244,6 @@ impl<T> VecDeque<T> {\n         //        T   t   h   H\n         // [. . . o o x x o o . . .]\n         //\n-        let drain_tail = self.wrap_add(self.tail, start);\n-        let drain_head = self.wrap_add(self.tail, end);\n         let head = self.head;\n \n         // \"forget\" about the values after the start of the drain until after"}, {"sha": "2ced10831e75cfa5354c33a6a1c99a8024101c4d", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804", "patch": "@@ -119,6 +119,7 @@\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n #![feature(min_specialization)]\n+#![feature(slice_check_range)]\n #![feature(slice_ptr_get)]\n #![feature(slice_ptr_len)]\n #![feature(staged_api)]"}, {"sha": "e1724bf3c9a90ce4c67f688784de874384ce1fff", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804", "patch": "@@ -47,7 +47,7 @@ use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n-use core::ops::{self, Add, AddAssign, Index, IndexMut, RangeBounds};\n+use core::ops::{self, Add, AddAssign, Index, IndexMut, Range, RangeBounds};\n use core::ptr;\n use core::str::{lossy, pattern::Pattern};\n \n@@ -1506,23 +1506,15 @@ impl String {\n         // of the vector version. The data is just plain bytes.\n         // Because the range removal happens in Drop, if the Drain iterator is leaked,\n         // the removal will not happen.\n-        let len = self.len();\n-        let start = match range.start_bound() {\n-            Included(&n) => n,\n-            Excluded(&n) => n + 1,\n-            Unbounded => 0,\n-        };\n-        let end = match range.end_bound() {\n-            Included(&n) => n + 1,\n-            Excluded(&n) => n,\n-            Unbounded => len,\n-        };\n+        let Range { start, end } = self.as_bytes().check_range(range);\n+        assert!(self.is_char_boundary(start));\n+        assert!(self.is_char_boundary(end));\n \n         // Take out two simultaneous borrows. The &mut String won't be accessed\n         // until iteration is over, in Drop.\n         let self_ptr = self as *mut _;\n-        // slicing does the appropriate bounds checks\n-        let chars_iter = self[start..end].chars();\n+        // SAFETY: `check_range` and `is_char_boundary` do the appropriate bounds checks.\n+        let chars_iter = unsafe { self.get_unchecked(start..end) }.chars();\n \n         Drain { start, end, iter: chars_iter, string: self_ptr }\n     }"}, {"sha": "6a4fc8e39624099241faf00317845feacb1cf865", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804", "patch": "@@ -63,8 +63,7 @@ use core::iter::{\n };\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n-use core::ops::Bound::{Excluded, Included, Unbounded};\n-use core::ops::{self, Index, IndexMut, RangeBounds};\n+use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice::{self, SliceIndex};\n \n@@ -1306,35 +1305,7 @@ impl<T> Vec<T> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let start = match range.start_bound() {\n-            Included(&n) => n,\n-            Excluded(&n) => n + 1,\n-            Unbounded => 0,\n-        };\n-        let end = match range.end_bound() {\n-            Included(&n) => n + 1,\n-            Excluded(&n) => n,\n-            Unbounded => len,\n-        };\n-\n-        #[cold]\n-        #[inline(never)]\n-        fn start_assert_failed(start: usize, end: usize) -> ! {\n-            panic!(\"start drain index (is {}) should be <= end drain index (is {})\", start, end);\n-        }\n-\n-        #[cold]\n-        #[inline(never)]\n-        fn end_assert_failed(end: usize, len: usize) -> ! {\n-            panic!(\"end drain index (is {}) should be <= len (is {})\", end, len);\n-        }\n-\n-        if start > end {\n-            start_assert_failed(start, end);\n-        }\n-        if end > len {\n-            end_assert_failed(end, len);\n-        }\n+        let Range { start, end } = self.check_range(range);\n \n         unsafe {\n             // set self.vec length's to start, to be safe in case Drain is leaked"}, {"sha": "68977a983aa37bc73b35daf4ac8f95887d68f046", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 86, "deletions": 21, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804", "patch": "@@ -29,7 +29,7 @@ use crate::intrinsics::{assume, exact_div, is_aligned_and_not_null, unchecked_su\n use crate::iter::*;\n use crate::marker::{self, Copy, Send, Sized, Sync};\n use crate::mem;\n-use crate::ops::{self, FnMut, Range};\n+use crate::ops::{self, Bound, FnMut, Range, RangeBounds};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n use crate::ptr::{self, NonNull};\n@@ -355,6 +355,79 @@ impl<T> [T] {\n         unsafe { &mut *index.get_unchecked_mut(self) }\n     }\n \n+    /// Converts a range over this slice to [`Range`].\n+    ///\n+    /// The returned range is safe to pass to [`get_unchecked`] and [`get_unchecked_mut`].\n+    ///\n+    /// [`get_unchecked`]: #method.get_unchecked\n+    /// [`get_unchecked_mut`]: #method.get_unchecked_mut\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the range is out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_check_range)]\n+    ///\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(1..2, v.check_range(1..2));\n+    /// assert_eq!(0..2, v.check_range(..2));\n+    /// assert_eq!(1..3, v.check_range(1..));\n+    /// ```\n+    ///\n+    /// Panics when [`Index::index`] would panic:\n+    ///\n+    /// ```should_panic\n+    /// #![feature(slice_check_range)]\n+    ///\n+    /// [10, 40, 30].check_range(2..1);\n+    /// ```\n+    ///\n+    /// ```should_panic\n+    /// #![feature(slice_check_range)]\n+    ///\n+    /// [10, 40, 30].check_range(1..4);\n+    /// ```\n+    ///\n+    /// ```should_panic\n+    /// #![feature(slice_check_range)]\n+    ///\n+    /// [10, 40, 30].check_range(1..=usize::MAX);\n+    /// ```\n+    ///\n+    /// [`Index::index`]: ops::Index::index\n+    #[track_caller]\n+    #[unstable(feature = \"slice_check_range\", issue = \"none\")]\n+    pub fn check_range<R: RangeBounds<usize>>(&self, range: R) -> Range<usize> {\n+        let start = match range.start_bound() {\n+            Bound::Included(&start) => start,\n+            Bound::Excluded(start) => {\n+                start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n+            }\n+            Bound::Unbounded => 0,\n+        };\n+\n+        let len = self.len();\n+        let end = match range.end_bound() {\n+            Bound::Included(end) => {\n+                end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n+            }\n+            Bound::Excluded(&end) => end,\n+            Bound::Unbounded => len,\n+        };\n+\n+        if start > end {\n+            slice_index_order_fail(start, end);\n+        }\n+        if end > len {\n+            slice_end_index_len_fail(end, len);\n+        }\n+\n+        Range { start, end }\n+    }\n+\n     /// Returns a raw pointer to the slice's buffer.\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n@@ -2651,26 +2724,11 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"copy_within\", since = \"1.37.0\")]\n     #[track_caller]\n-    pub fn copy_within<R: ops::RangeBounds<usize>>(&mut self, src: R, dest: usize)\n+    pub fn copy_within<R: RangeBounds<usize>>(&mut self, src: R, dest: usize)\n     where\n         T: Copy,\n     {\n-        let src_start = match src.start_bound() {\n-            ops::Bound::Included(&n) => n,\n-            ops::Bound::Excluded(&n) => {\n-                n.checked_add(1).unwrap_or_else(|| slice_index_overflow_fail())\n-            }\n-            ops::Bound::Unbounded => 0,\n-        };\n-        let src_end = match src.end_bound() {\n-            ops::Bound::Included(&n) => {\n-                n.checked_add(1).unwrap_or_else(|| slice_index_overflow_fail())\n-            }\n-            ops::Bound::Excluded(&n) => n,\n-            ops::Bound::Unbounded => self.len(),\n-        };\n-        assert!(src_start <= src_end, \"src end is before src start\");\n-        assert!(src_end <= self.len(), \"src is out of bounds\");\n+        let Range { start: src_start, end: src_end } = self.check_range(src);\n         let count = src_end - src_start;\n         assert!(dest <= self.len() - count, \"dest is out of bounds\");\n         // SAFETY: the conditions for `ptr::copy` have all been checked above,\n@@ -3259,7 +3317,14 @@ fn slice_index_order_fail(index: usize, end: usize) -> ! {\n #[inline(never)]\n #[cold]\n #[track_caller]\n-fn slice_index_overflow_fail() -> ! {\n+fn slice_start_index_overflow_fail() -> ! {\n+    panic!(\"attempted to index slice from after maximum usize\");\n+}\n+\n+#[inline(never)]\n+#[cold]\n+#[track_caller]\n+fn slice_end_index_overflow_fail() -> ! {\n     panic!(\"attempted to index slice up to maximum usize\");\n }\n \n@@ -3603,15 +3668,15 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n         if *self.end() == usize::MAX {\n-            slice_index_overflow_fail();\n+            slice_end_index_overflow_fail();\n         }\n         (*self.start()..self.end() + 1).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n         if *self.end() == usize::MAX {\n-            slice_index_overflow_fail();\n+            slice_end_index_overflow_fail();\n         }\n         (*self.start()..self.end() + 1).index_mut(slice)\n     }"}, {"sha": "743df68699c281516ce455034a66b0c508d9348d", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804", "patch": "@@ -1795,7 +1795,7 @@ fn test_copy_within() {\n }\n \n #[test]\n-#[should_panic(expected = \"src is out of bounds\")]\n+#[should_panic(expected = \"range end index 14 out of range for slice of length 13\")]\n fn test_copy_within_panics_src_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so 14 is out of bounds.\n@@ -1810,7 +1810,7 @@ fn test_copy_within_panics_dest_too_long() {\n     bytes.copy_within(0..4, 10);\n }\n #[test]\n-#[should_panic(expected = \"src end is before src start\")]\n+#[should_panic(expected = \"slice index starts at 2 but ends at 1\")]\n fn test_copy_within_panics_src_inverted() {\n     let mut bytes = *b\"Hello, World!\";\n     // 2 is greater than 1, so this range is invalid."}, {"sha": "7ec12116c2ca1f8c0358f04dd0ed6b19566e6278", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=ef55a0a92f3cb6572ef67d99f4aefbdeb7b6b804", "patch": "@@ -39,6 +39,7 @@ const LINKCHECK_EXCEPTIONS: &[(&str, &[&str])] = &[\n             \"#method.sort_by_key\",\n             \"#method.make_ascii_uppercase\",\n             \"#method.make_ascii_lowercase\",\n+            \"#method.get_unchecked_mut\",\n         ],\n     ),\n     // These try to link to std::collections, but are defined in alloc"}]}