{"sha": "62108124946582e7536d84adedc1507e5c35e8fd", "node_id": "C_kwDOAAsO6NoAKDYyMTA4MTI0OTQ2NTgyZTc1MzZkODRhZGVkYzE1MDdlNWMzNWU4ZmQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-23T19:38:22Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-26T05:38:43Z"}, "message": "Do not record unresolved const vars in generator interior", "tree": {"sha": "7173e75c1cbff2c47ad352cc2b0982c598f424d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7173e75c1cbff2c47ad352cc2b0982c598f424d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62108124946582e7536d84adedc1507e5c35e8fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62108124946582e7536d84adedc1507e5c35e8fd", "html_url": "https://github.com/rust-lang/rust/commit/62108124946582e7536d84adedc1507e5c35e8fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62108124946582e7536d84adedc1507e5c35e8fd/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aff003becd8b6bf803202e958623031274ad69c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/aff003becd8b6bf803202e958623031274ad69c9", "html_url": "https://github.com/rust-lang/rust/commit/aff003becd8b6bf803202e958623031274ad69c9"}], "stats": {"total": 216, "additions": 173, "deletions": 43}, "files": [{"sha": "50722c42a6c611ce7d96a8f64276468eb6932628", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/62108124946582e7536d84adedc1507e5c35e8fd/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62108124946582e7536d84adedc1507e5c35e8fd/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=62108124946582e7536d84adedc1507e5c35e8fd", "patch": "@@ -98,8 +98,8 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 expr, scope, ty, self.expr_count, yield_data.span\n             );\n \n-            if let Some((unresolved_type, unresolved_type_span)) =\n-                self.fcx.unresolved_type_vars(&ty)\n+            if let Some((unresolved_term, unresolved_type_span)) =\n+                self.fcx.first_unresolved_const_or_ty_var(&ty)\n             {\n                 // If unresolved type isn't a ty_var then unresolved_type_span is None\n                 let span = self\n@@ -108,21 +108,21 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n \n                 // If we encounter an int/float variable, then inference fallback didn't\n                 // finish due to some other error. Don't emit spurious additional errors.\n-                if let ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(_)) =\n-                    unresolved_type.kind()\n+                if let Some(unresolved_ty) = unresolved_term.ty()\n+                    && let ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(_)) = unresolved_ty.kind()\n                 {\n                     self.fcx\n                         .tcx\n                         .sess\n-                        .delay_span_bug(span, &format!(\"Encountered var {:?}\", unresolved_type));\n+                        .delay_span_bug(span, &format!(\"Encountered var {:?}\", unresolved_term));\n                 } else {\n                     let note = format!(\n                         \"the type is part of the {} because of this {}\",\n                         self.kind, yield_data.source\n                     );\n \n                     self.fcx\n-                        .need_type_info_err_in_generator(self.kind, span, unresolved_type)\n+                        .need_type_info_err_in_generator(self.kind, span, unresolved_term)\n                         .span_note(yield_data.span, &*note)\n                         .emit();\n                 }\n@@ -162,7 +162,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 expr.map(|e| e.span)\n             );\n             if let Some((unresolved_type, unresolved_type_span)) =\n-                self.fcx.unresolved_type_vars(&ty)\n+                self.fcx.first_unresolved_const_or_ty_var(&ty)\n             {\n                 debug!(\n                     \"remained unresolved_type = {:?}, unresolved_type_span: {:?}\","}, {"sha": "8c63f553141873ecec2b827cff27e4e9285fb02f", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62108124946582e7536d84adedc1507e5c35e8fd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62108124946582e7536d84adedc1507e5c35e8fd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=62108124946582e7536d84adedc1507e5c35e8fd", "patch": "@@ -571,7 +571,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         kind: hir::GeneratorKind,\n         span: Span,\n-        ty: Ty<'tcx>,\n+        ty: ty::Term<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ty = self.resolve_vars_if_possible(ty);\n         let data = self.extract_inference_diagnostics_data(ty.into(), None);"}, {"sha": "cda9299dcb6e795cdf0705f6a90ebe60c51976f7", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62108124946582e7536d84adedc1507e5c35e8fd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62108124946582e7536d84adedc1507e5c35e8fd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=62108124946582e7536d84adedc1507e5c35e8fd", "patch": "@@ -1421,16 +1421,15 @@ impl<'tcx> InferCtxt<'tcx> {\n         value.fold_with(&mut r)\n     }\n \n-    /// Returns the first unresolved variable contained in `T`. In the\n-    /// process of visiting `T`, this will resolve (where possible)\n-    /// type variables in `T`, but it never constructs the final,\n-    /// resolved type, so it's more efficient than\n-    /// `resolve_vars_if_possible()`.\n-    pub fn unresolved_type_vars<T>(&self, value: &T) -> Option<(Ty<'tcx>, Option<Span>)>\n+    /// Returns the first unresolved type or const variable contained in `T`.\n+    pub fn first_unresolved_const_or_ty_var<T>(\n+        &self,\n+        value: &T,\n+    ) -> Option<(ty::Term<'tcx>, Option<Span>)>\n     where\n         T: TypeVisitable<'tcx>,\n     {\n-        value.visit_with(&mut resolve::UnresolvedTypeFinder::new(self)).break_value()\n+        value.visit_with(&mut resolve::UnresolvedTypeOrConstFinder::new(self)).break_value()\n     }\n \n     pub fn probe_const_var("}, {"sha": "8671f8d45a91721d597bb8aa72d514e4dd5027cf", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/62108124946582e7536d84adedc1507e5c35e8fd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62108124946582e7536d84adedc1507e5c35e8fd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=62108124946582e7536d84adedc1507e5c35e8fd", "patch": "@@ -1,5 +1,6 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::{FixupError, FixupResult, InferCtxt, Span};\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::fold::{FallibleTypeFolder, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitor};\n use rustc_middle::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n@@ -110,48 +111,77 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticRegionResolver<'a, 'tcx> {\n /// type variables that don't yet have a value. The first unresolved type is stored.\n /// It does not construct the fully resolved type (which might\n /// involve some hashing and so forth).\n-pub struct UnresolvedTypeFinder<'a, 'tcx> {\n+pub struct UnresolvedTypeOrConstFinder<'a, 'tcx> {\n     infcx: &'a InferCtxt<'tcx>,\n }\n \n-impl<'a, 'tcx> UnresolvedTypeFinder<'a, 'tcx> {\n+impl<'a, 'tcx> UnresolvedTypeOrConstFinder<'a, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'tcx>) -> Self {\n-        UnresolvedTypeFinder { infcx }\n+        UnresolvedTypeOrConstFinder { infcx }\n     }\n }\n \n-impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n-    type BreakTy = (Ty<'tcx>, Option<Span>);\n+impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeOrConstFinder<'a, 'tcx> {\n+    type BreakTy = (ty::Term<'tcx>, Option<Span>);\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let t = self.infcx.shallow_resolve(t);\n-        if t.has_infer_types() {\n-            if let ty::Infer(infer_ty) = *t.kind() {\n-                // Since we called `shallow_resolve` above, this must\n-                // be an (as yet...) unresolved inference variable.\n-                let ty_var_span = if let ty::TyVar(ty_vid) = infer_ty {\n-                    let mut inner = self.infcx.inner.borrow_mut();\n-                    let ty_vars = &inner.type_variables();\n-                    if let TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeParameterDefinition(_, _),\n-                        span,\n-                    } = *ty_vars.var_origin(ty_vid)\n-                    {\n-                        Some(span)\n-                    } else {\n-                        None\n-                    }\n+        if let ty::Infer(infer_ty) = *t.kind() {\n+            // Since we called `shallow_resolve` above, this must\n+            // be an (as yet...) unresolved inference variable.\n+            let ty_var_span = if let ty::TyVar(ty_vid) = infer_ty {\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let ty_vars = &inner.type_variables();\n+                if let TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeParameterDefinition(_, _),\n+                    span,\n+                } = *ty_vars.var_origin(ty_vid)\n+                {\n+                    Some(span)\n                 } else {\n                     None\n-                };\n-                ControlFlow::Break((t, ty_var_span))\n+                }\n             } else {\n-                // Otherwise, visit its contents.\n-                t.super_visit_with(self)\n-            }\n+                None\n+            };\n+            ControlFlow::Break((t.into(), ty_var_span))\n+        } else if !t.has_non_region_infer() {\n+            // All const/type variables in inference types must already be resolved,\n+            // no need to visit the contents.\n+            ControlFlow::CONTINUE\n         } else {\n-            // All type variables in inference types must already be resolved,\n-            // - no need to visit the contents, continue visiting.\n+            // Otherwise, keep visiting.\n+            t.super_visit_with(self)\n+        }\n+    }\n+\n+    fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let ct = self.infcx.shallow_resolve(ct);\n+        if let ty::ConstKind::Infer(i) = ct.kind() {\n+            // Since we called `shallow_resolve` above, this must\n+            // be an (as yet...) unresolved inference variable.\n+            let ct_var_span = if let ty::InferConst::Var(vid) = i {\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let ct_vars = &mut inner.const_unification_table();\n+                if let ConstVariableOrigin {\n+                    span,\n+                    kind: ConstVariableOriginKind::ConstParameterDefinition(_, _),\n+                } = ct_vars.probe_value(vid).origin\n+                {\n+                    Some(span)\n+                } else {\n+                    None\n+                }\n+            } else {\n+                None\n+            };\n+            ControlFlow::Break((ct.into(), ct_var_span))\n+        } else if !ct.has_non_region_infer() {\n+            // All const/type variables in inference types must already be resolved,\n+            // no need to visit the contents.\n             ControlFlow::CONTINUE\n+        } else {\n+            // Otherwise, keep visiting.\n+            ct.super_visit_with(self)\n         }\n     }\n }"}, {"sha": "239b67bd226746e364212bcd4b64b04938c6f6bc", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/62108124946582e7536d84adedc1507e5c35e8fd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62108124946582e7536d84adedc1507e5c35e8fd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=62108124946582e7536d84adedc1507e5c35e8fd", "patch": "@@ -140,6 +140,15 @@ impl<'tcx> From<ty::Const<'tcx>> for GenericArg<'tcx> {\n     }\n }\n \n+impl<'tcx> From<ty::Term<'tcx>> for GenericArg<'tcx> {\n+    fn from(value: ty::Term<'tcx>) -> Self {\n+        match value.unpack() {\n+            ty::TermKind::Ty(t) => t.into(),\n+            ty::TermKind::Const(c) => c.into(),\n+        }\n+    }\n+}\n+\n impl<'tcx> GenericArg<'tcx> {\n     #[inline]\n     pub fn unpack(self) -> GenericArgKind<'tcx> {"}, {"sha": "0a1570fc2395ec43658061c387aa6a97a49da787", "filename": "src/test/ui/generator/unresolved-ct-var.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/62108124946582e7536d84adedc1507e5c35e8fd/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62108124946582e7536d84adedc1507e5c35e8fd/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.rs?ref=62108124946582e7536d84adedc1507e5c35e8fd", "patch": "@@ -0,0 +1,14 @@\n+// incremental\n+// edition:2021\n+\n+fn main() {\n+    let _ = async {\n+        let s = std::array::from_fn(|_| ()).await;\n+        //~^ ERROR `[(); _]` is not a future\n+        //~| ERROR type inside `async` block must be known in this context\n+        //~| ERROR type inside `async` block must be known in this context\n+        //~| ERROR type inside `async` block must be known in this context\n+        //~| ERROR type inside `async` block must be known in this context\n+        //~| ERROR type inside `async` block must be known in this context\n+    };\n+}"}, {"sha": "fdf00dfad7ab7eed36024ff78f1376d8ff351969", "filename": "src/test/ui/generator/unresolved-ct-var.stderr", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/62108124946582e7536d84adedc1507e5c35e8fd/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62108124946582e7536d84adedc1507e5c35e8fd/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.stderr?ref=62108124946582e7536d84adedc1507e5c35e8fd", "patch": "@@ -0,0 +1,78 @@\n+error[E0277]: `[(); _]` is not a future\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ---------------------------^^^^^^\n+   |                 |                          |\n+   |                 |                          `[(); _]` is not a future\n+   |                 |                          help: remove the `.await`\n+   |                 this call returns `[(); _]`\n+   |\n+   = help: the trait `Future` is not implemented for `[(); _]`\n+   = note: [(); _] must be a future or must implement `IntoFuture` to be awaited\n+   = note: required for `[(); _]` to implement `IntoFuture`\n+\n+error[E0698]: type inside `async` block must be known in this context\n+  --> $DIR/unresolved-ct-var.rs:6:17\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `from_fn`\n+   |\n+note: the type is part of the `async` block because of this `await`\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                                            ^^^^^^\n+\n+error[E0698]: type inside `async` block must be known in this context\n+  --> $DIR/unresolved-ct-var.rs:6:17\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `from_fn`\n+   |\n+note: the type is part of the `async` block because of this `await`\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                                            ^^^^^^\n+\n+error[E0698]: type inside `async` block must be known in this context\n+  --> $DIR/unresolved-ct-var.rs:6:17\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `from_fn`\n+   |\n+note: the type is part of the `async` block because of this `await`\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                                            ^^^^^^\n+\n+error[E0698]: type inside `async` block must be known in this context\n+  --> $DIR/unresolved-ct-var.rs:6:17\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `from_fn`\n+   |\n+note: the type is part of the `async` block because of this `await`\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                                            ^^^^^^\n+\n+error[E0698]: type inside `async` block must be known in this context\n+  --> $DIR/unresolved-ct-var.rs:6:17\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `from_fn`\n+   |\n+note: the type is part of the `async` block because of this `await`\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                                            ^^^^^^\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0277, E0698.\n+For more information about an error, try `rustc --explain E0277`."}]}