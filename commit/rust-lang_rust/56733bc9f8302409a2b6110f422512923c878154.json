{"sha": "56733bc9f8302409a2b6110f422512923c878154", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NzMzYmM5ZjgzMDI0MDlhMmI2MTEwZjQyMjUxMjkyM2M4NzgxNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-01T07:33:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-01T07:33:35Z"}, "message": "Auto merge of #47738 - nikomatsakis:issue-47139-master, r=arielb1\n\nremove intercrate ambiguity hints\n\nThe scheme was causing overflows during coherence checking (e.g. #47139). This is sort of a temporary fix; the proper fix I think involves reworking trait selection in deeper ways.\n\ncc @sgrif -- this *should* fix diesel\n\ncc @qnighy -- I'd like to discuss you with alternative techniques for achieving the same end. =) Actually, it might be good to put some energy into refactoring traits first.\n\nr? @eddyb", "tree": {"sha": "59ed2b8a8934b96cd173180f840560e2d17bc908", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59ed2b8a8934b96cd173180f840560e2d17bc908"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56733bc9f8302409a2b6110f422512923c878154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56733bc9f8302409a2b6110f422512923c878154", "html_url": "https://github.com/rust-lang/rust/commit/56733bc9f8302409a2b6110f422512923c878154", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56733bc9f8302409a2b6110f422512923c878154/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26792f0607bea2b03daa5195c2688fd53289042b", "url": "https://api.github.com/repos/rust-lang/rust/commits/26792f0607bea2b03daa5195c2688fd53289042b", "html_url": "https://github.com/rust-lang/rust/commit/26792f0607bea2b03daa5195c2688fd53289042b"}, {"sha": "2fc573945afe6b1ea4846f5e8fbeb7d18be45e9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fc573945afe6b1ea4846f5e8fbeb7d18be45e9d", "html_url": "https://github.com/rust-lang/rust/commit/2fc573945afe6b1ea4846f5e8fbeb7d18be45e9d"}], "stats": {"total": 400, "additions": 307, "deletions": 93}, "files": [{"sha": "db6863d6dadc272a0d01fc86296d6c92d4ec38ea", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56733bc9f8302409a2b6110f422512923c878154/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56733bc9f8302409a2b6110f422512923c878154/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=56733bc9f8302409a2b6110f422512923c878154", "patch": "@@ -66,6 +66,7 @@\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n #![feature(underscore_lifetimes)]\n+#![feature(universal_impl_trait)]\n #![feature(trace_macros)]\n #![feature(catch_expr)]\n #![feature(test)]"}, {"sha": "9de18612d816c468db047ff0bab636e344c9f690", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/56733bc9f8302409a2b6110f422512923c878154/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56733bc9f8302409a2b6110f422512923c878154/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=56733bc9f8302409a2b6110f422512923c878154", "patch": "@@ -19,7 +19,7 @@ use ty::{self, Ty, TyCtxt};\n use ty::fold::TypeFoldable;\n use ty::subst::Subst;\n \n-use infer::{InferCtxt, InferOk};\n+use infer::{InferOk};\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -40,13 +40,20 @@ pub struct OverlapResult<'tcx> {\n     pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n }\n \n-/// If there are types that satisfy both impls, returns a suitably-freshened\n-/// `ImplHeader` with those types substituted\n-pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n-                                          impl1_def_id: DefId,\n-                                          impl2_def_id: DefId,\n-                                          intercrate_mode: IntercrateMode)\n-                                          -> Option<OverlapResult<'tcx>>\n+/// If there are types that satisfy both impls, invokes `on_overlap`\n+/// with a suitably-freshened `ImplHeader` with those types\n+/// substituted. Otherwise, invokes `no_overlap`.\n+pub fn overlapping_impls<'gcx, F1, F2, R>(\n+    tcx: TyCtxt<'_, 'gcx, 'gcx>,\n+    impl1_def_id: DefId,\n+    impl2_def_id: DefId,\n+    intercrate_mode: IntercrateMode,\n+    on_overlap: F1,\n+    no_overlap: F2,\n+) -> R\n+where\n+    F1: FnOnce(OverlapResult<'_>) -> R,\n+    F2: FnOnce() -> R,\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n@@ -56,8 +63,23 @@ pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n            impl2_def_id,\n            intercrate_mode);\n \n-    let selcx = &mut SelectionContext::intercrate(infcx, intercrate_mode);\n-    overlap(selcx, impl1_def_id, impl2_def_id)\n+    let overlaps = tcx.infer_ctxt().enter(|infcx| {\n+        let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n+        overlap(selcx, impl1_def_id, impl2_def_id).is_some()\n+    });\n+\n+    if !overlaps {\n+        return no_overlap();\n+    }\n+\n+    // In the case where we detect an error, run the check again, but\n+    // this time tracking intercrate ambuiguity causes for better\n+    // diagnostics. (These take time and can lead to false errors.)\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n+        selcx.enable_tracking_intercrate_ambiguity_causes();\n+        on_overlap(overlap(selcx, impl1_def_id, impl2_def_id).unwrap())\n+    })\n }\n \n fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n@@ -135,10 +157,10 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n         return None\n     }\n \n-    Some(OverlapResult {\n-        impl_header: selcx.infcx().resolve_type_vars_if_possible(&a_impl_header),\n-        intercrate_ambiguity_causes: selcx.intercrate_ambiguity_causes().to_vec(),\n-    })\n+    let impl_header =  selcx.infcx().resolve_type_vars_if_possible(&a_impl_header);\n+    let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n+    debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n+    Some(OverlapResult { impl_header, intercrate_ambiguity_causes })\n }\n \n pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "4ed25646d436d03671852d1d3a0fcd0f625e9c85", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 64, "deletions": 40, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/56733bc9f8302409a2b6110f422512923c878154/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56733bc9f8302409a2b6110f422512923c878154/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=56733bc9f8302409a2b6110f422512923c878154", "patch": "@@ -92,10 +92,10 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n \n     inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n \n-    intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n+    intercrate_ambiguity_causes: Option<Vec<IntercrateAmbiguityCause>>,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub enum IntercrateAmbiguityCause {\n     DownstreamCrate {\n         trait_desc: String,\n@@ -423,7 +423,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             freshener: infcx.freshener(),\n             intercrate: None,\n             inferred_obligations: SnapshotVec::new(),\n-            intercrate_ambiguity_causes: Vec::new(),\n+            intercrate_ambiguity_causes: None,\n         }\n     }\n \n@@ -435,10 +435,30 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             freshener: infcx.freshener(),\n             intercrate: Some(mode),\n             inferred_obligations: SnapshotVec::new(),\n-            intercrate_ambiguity_causes: Vec::new(),\n+            intercrate_ambiguity_causes: None,\n         }\n     }\n \n+    /// Enables tracking of intercrate ambiguity causes. These are\n+    /// used in coherence to give improved diagnostics. We don't do\n+    /// this until we detect a coherence error because it can lead to\n+    /// false overflow results (#47139) and because it costs\n+    /// computation time.\n+    pub fn enable_tracking_intercrate_ambiguity_causes(&mut self) {\n+        assert!(self.intercrate.is_some());\n+        assert!(self.intercrate_ambiguity_causes.is_none());\n+        self.intercrate_ambiguity_causes = Some(vec![]);\n+        debug!(\"selcx: enable_tracking_intercrate_ambiguity_causes\");\n+    }\n+\n+    /// Gets the intercrate ambiguity causes collected since tracking\n+    /// was enabled and disables tracking at the same time. If\n+    /// tracking is not enabled, just returns an empty vector.\n+    pub fn take_intercrate_ambiguity_causes(&mut self) -> Vec<IntercrateAmbiguityCause> {\n+        assert!(self.intercrate.is_some());\n+        self.intercrate_ambiguity_causes.take().unwrap_or(vec![])\n+    }\n+\n     pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n@@ -451,10 +471,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn intercrate_ambiguity_causes(&self) -> &[IntercrateAmbiguityCause] {\n-        &self.intercrate_ambiguity_causes\n-    }\n-\n     /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n     /// context's self.\n     fn in_snapshot<R, F>(&mut self, f: F) -> R\n@@ -828,19 +844,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n                    stack.fresh_trait_ref);\n             // Heuristics: show the diagnostics when there are no candidates in crate.\n-            if let Ok(candidate_set) = self.assemble_candidates(stack) {\n-                if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n-                    let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                    let self_ty = trait_ref.self_ty();\n-                    let cause = IntercrateAmbiguityCause::DownstreamCrate {\n-                        trait_desc: trait_ref.to_string(),\n-                        self_desc: if self_ty.has_concrete_skeleton() {\n-                            Some(self_ty.to_string())\n-                        } else {\n-                            None\n-                        },\n-                    };\n-                    self.intercrate_ambiguity_causes.push(cause);\n+            if self.intercrate_ambiguity_causes.is_some() {\n+                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n+                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n+                    if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n+                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                        let self_ty = trait_ref.self_ty();\n+                        let cause = IntercrateAmbiguityCause::DownstreamCrate {\n+                            trait_desc: trait_ref.to_string(),\n+                            self_desc: if self_ty.has_concrete_skeleton() {\n+                                Some(self_ty.to_string())\n+                            } else {\n+                                None\n+                            },\n+                        };\n+                        debug!(\"evaluate_stack: pushing cause = {:?}\", cause);\n+                        self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n+                    }\n                 }\n             }\n             return EvaluatedToAmbig;\n@@ -1092,25 +1112,29 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             None => {}\n             Some(conflict) => {\n                 debug!(\"coherence stage: not knowable\");\n-                // Heuristics: show the diagnostics when there are no candidates in crate.\n-                let candidate_set = self.assemble_candidates(stack)?;\n-                if !candidate_set.ambiguous && candidate_set.vec.iter().all(|c| {\n-                    !self.evaluate_candidate(stack, &c).may_apply()\n-                }) {\n-                    let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                    let self_ty = trait_ref.self_ty();\n-                    let trait_desc = trait_ref.to_string();\n-                    let self_desc = if self_ty.has_concrete_skeleton() {\n-                        Some(self_ty.to_string())\n-                    } else {\n-                        None\n-                    };\n-                    let cause = if let Conflict::Upstream = conflict {\n-                        IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n-                    } else {\n-                        IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n-                    };\n-                    self.intercrate_ambiguity_causes.push(cause);\n+                if self.intercrate_ambiguity_causes.is_some() {\n+                    debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n+                    // Heuristics: show the diagnostics when there are no candidates in crate.\n+                    let candidate_set = self.assemble_candidates(stack)?;\n+                    if !candidate_set.ambiguous && candidate_set.vec.iter().all(|c| {\n+                        !self.evaluate_candidate(stack, &c).may_apply()\n+                    }) {\n+                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                        let self_ty = trait_ref.self_ty();\n+                        let trait_desc = trait_ref.to_string();\n+                        let self_desc = if self_ty.has_concrete_skeleton() {\n+                            Some(self_ty.to_string())\n+                        } else {\n+                            None\n+                        };\n+                        let cause = if let Conflict::Upstream = conflict {\n+                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n+                        } else {\n+                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n+                        };\n+                        debug!(\"evaluate_stack: pushing cause = {:?}\", cause);\n+                        self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n+                    }\n                 }\n                 return Ok(None);\n             }"}, {"sha": "a10169e13e60a705e4bc9e0bc3d6cf75cf5a4a75", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/56733bc9f8302409a2b6110f422512923c878154/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56733bc9f8302409a2b6110f422512923c878154/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=56733bc9f8302409a2b6110f422512923c878154", "patch": "@@ -133,12 +133,12 @@ impl<'a, 'gcx, 'tcx> Children {\n             };\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = tcx.infer_ctxt().enter(|infcx| {\n-                let overlap = traits::overlapping_impls(&infcx,\n-                                                        possible_sibling,\n-                                                        impl_def_id,\n-                                                        traits::IntercrateMode::Issue43355);\n-                if let Some(overlap) = overlap {\n+            let (le, ge) = traits::overlapping_impls(\n+                tcx,\n+                possible_sibling,\n+                impl_def_id,\n+                traits::IntercrateMode::Issue43355,\n+                |overlap| {\n                     if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n                         return Ok((false, false));\n                     }\n@@ -151,10 +151,9 @@ impl<'a, 'gcx, 'tcx> Children {\n                     } else {\n                         Ok((le, ge))\n                     }\n-                } else {\n-                    Ok((false, false))\n-                }\n-            })?;\n+                },\n+                || Ok((false, false)),\n+            )?;\n \n             if le && !ge {\n                 debug!(\"descending as child of TraitRef {:?}\",\n@@ -171,16 +170,14 @@ impl<'a, 'gcx, 'tcx> Children {\n                 return Ok(Inserted::Replaced(possible_sibling));\n             } else {\n                 if !tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n-                    tcx.infer_ctxt().enter(|infcx| {\n-                        if let Some(overlap) = traits::overlapping_impls(\n-                            &infcx,\n-                            possible_sibling,\n-                            impl_def_id,\n-                            traits::IntercrateMode::Fixed)\n-                        {\n-                            last_lint = Some(overlap_error(overlap));\n-                        }\n-                    });\n+                    traits::overlapping_impls(\n+                        tcx,\n+                        possible_sibling,\n+                        impl_def_id,\n+                        traits::IntercrateMode::Fixed,\n+                        |overlap| last_lint = Some(overlap_error(overlap)),\n+                        || (),\n+                    );\n                 }\n \n                 // no overlap (error bailed already via ?)"}, {"sha": "88a2dc817ae63f139f1ad1a38bee016c777fa732", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/56733bc9f8302409a2b6110f422512923c878154/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56733bc9f8302409a2b6110f422512923c878154/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=56733bc9f8302409a2b6110f422512923c878154", "patch": "@@ -82,29 +82,37 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                let used_to_be_allowed = self.tcx.infer_ctxt().enter(|infcx| {\n-                    if let Some(overlap) =\n-                        traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id,\n-                                                  IntercrateMode::Issue43355)\n-                    {\n+                let used_to_be_allowed = traits::overlapping_impls(\n+                    self.tcx,\n+                    impl1_def_id,\n+                    impl2_def_id,\n+                    IntercrateMode::Issue43355,\n+                    |overlap| {\n                         self.check_for_common_items_in_impls(\n-                            impl1_def_id, impl2_def_id, overlap, false);\n+                            impl1_def_id,\n+                            impl2_def_id,\n+                            overlap,\n+                            false,\n+                        );\n                         false\n-                    } else {\n-                        true\n-                    }\n-                });\n+                    },\n+                    || true,\n+                );\n \n                 if used_to_be_allowed {\n-                    self.tcx.infer_ctxt().enter(|infcx| {\n-                        if let Some(overlap) =\n-                            traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id,\n-                                                      IntercrateMode::Fixed)\n-                        {\n-                            self.check_for_common_items_in_impls(\n-                                impl1_def_id, impl2_def_id, overlap, true);\n-                        }\n-                    });\n+                    traits::overlapping_impls(\n+                        self.tcx,\n+                        impl1_def_id,\n+                        impl2_def_id,\n+                        IntercrateMode::Fixed,\n+                        |overlap| self.check_for_common_items_in_impls(\n+                            impl1_def_id,\n+                            impl2_def_id,\n+                            overlap,\n+                            true,\n+                        ),\n+                        || (),\n+                    );\n                 }\n             }\n         }"}, {"sha": "cb87991a491db2303dcf1efa844545689e95277b", "filename": "src/test/run-pass/issue-47139-1.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/56733bc9f8302409a2b6110f422512923c878154/src%2Ftest%2Frun-pass%2Fissue-47139-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56733bc9f8302409a2b6110f422512923c878154/src%2Ftest%2Frun-pass%2Fissue-47139-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-47139-1.rs?ref=56733bc9f8302409a2b6110f422512923c878154", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #47139:\n+//\n+// Coherence was encountering an (unnecessary) overflow trying to\n+// decide if the two impls of dummy overlap.\n+//\n+// The overflow went something like:\n+//\n+// - `&'a ?T: Insertable` ?\n+// - let ?T = Option<?U> ?\n+// - `Option<?U>: Insertable` ?\n+// - `Option<&'a ?U>: Insertable` ?\n+// - `&'a ?U: Insertable` ?\n+//\n+// While somewhere in the middle, a projection would occur, which\n+// broke cycle detection.\n+//\n+// It turned out that this cycle was being kicked off due to some\n+// extended diagnostic attempts in coherence, so removing those\n+// sidestepped the issue for now.\n+\n+#![allow(dead_code)]\n+\n+pub trait Insertable {\n+    type Values;\n+\n+    fn values(self) -> Self::Values;\n+}\n+\n+impl<T> Insertable for Option<T>\n+    where\n+    T: Insertable,\n+    T::Values: Default,\n+{\n+    type Values = T::Values;\n+\n+    fn values(self) -> Self::Values {\n+        self.map(Insertable::values).unwrap_or_default()\n+    }\n+}\n+\n+impl<'a, T> Insertable for &'a Option<T>\n+    where\n+    Option<&'a T>: Insertable,\n+{\n+    type Values = <Option<&'a T> as Insertable>::Values;\n+\n+    fn values(self) -> Self::Values {\n+        self.as_ref().values()\n+    }\n+}\n+\n+impl<'a, T> Insertable for &'a [T]\n+{\n+    type Values = Self;\n+\n+    fn values(self) -> Self::Values {\n+        self\n+    }\n+}\n+\n+trait Unimplemented { }\n+\n+trait Dummy { }\n+\n+struct Foo<T> { t: T }\n+\n+impl<'a, U> Dummy for Foo<&'a U>\n+    where &'a U: Insertable\n+{\n+}\n+\n+impl<T> Dummy for T\n+    where T: Unimplemented\n+{ }\n+\n+fn main() {\n+}"}, {"sha": "08eaee5acd730213e41e73b1da212b559ca2be77", "filename": "src/test/run-pass/issue-47139-2.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/56733bc9f8302409a2b6110f422512923c878154/src%2Ftest%2Frun-pass%2Fissue-47139-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56733bc9f8302409a2b6110f422512923c878154/src%2Ftest%2Frun-pass%2Fissue-47139-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-47139-2.rs?ref=56733bc9f8302409a2b6110f422512923c878154", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #47139:\n+//\n+// Same as issue-47139-1.rs, but the impls of dummy are in the\n+// opposite order. This influenced the way that coherence ran and in\n+// some cases caused the overflow to occur when it wouldn't otherwise.\n+// In an effort to make the regr test more robust, I am including both\n+// orderings.\n+\n+#![allow(dead_code)]\n+\n+pub trait Insertable {\n+    type Values;\n+\n+    fn values(self) -> Self::Values;\n+}\n+\n+impl<T> Insertable for Option<T>\n+    where\n+    T: Insertable,\n+    T::Values: Default,\n+{\n+    type Values = T::Values;\n+\n+    fn values(self) -> Self::Values {\n+        self.map(Insertable::values).unwrap_or_default()\n+    }\n+}\n+\n+impl<'a, T> Insertable for &'a Option<T>\n+    where\n+    Option<&'a T>: Insertable,\n+{\n+    type Values = <Option<&'a T> as Insertable>::Values;\n+\n+    fn values(self) -> Self::Values {\n+        self.as_ref().values()\n+    }\n+}\n+\n+impl<'a, T> Insertable for &'a [T]\n+{\n+    type Values = Self;\n+\n+    fn values(self) -> Self::Values {\n+        self\n+    }\n+}\n+\n+trait Unimplemented { }\n+\n+trait Dummy { }\n+\n+struct Foo<T> { t: T }\n+\n+impl<T> Dummy for T\n+    where T: Unimplemented\n+{ }\n+\n+impl<'a, U> Dummy for Foo<&'a U>\n+    where &'a U: Insertable\n+{\n+}\n+\n+fn main() {\n+}"}]}