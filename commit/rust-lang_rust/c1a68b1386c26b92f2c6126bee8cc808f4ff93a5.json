{"sha": "c1a68b1386c26b92f2c6126bee8cc808f4ff93a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYTY4YjEzODZjMjZiOTJmMmM2MTI2YmVlOGNjODA4ZjRmZjkzYTU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-08-15T16:55:32Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-08-15T17:08:19Z"}, "message": "Emulate the cpuid arch intrinsic", "tree": {"sha": "a9da16e53d3db7e3097cbc32755de7490b4f593f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9da16e53d3db7e3097cbc32755de7490b4f593f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5", "html_url": "https://github.com/rust-lang/rust/commit/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "847cc7ab2a96c9d2f3c225dc8e86f19a24eefcb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/847cc7ab2a96c9d2f3c225dc8e86f19a24eefcb4", "html_url": "https://github.com/rust-lang/rust/commit/847cc7ab2a96c9d2f3c225dc8e86f19a24eefcb4"}], "stats": {"total": 150, "additions": 107, "deletions": 43}, "files": [{"sha": "8e6ab2d712c3e9d930f2737525b5aaf97ed0d542", "filename": "example/std_example.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=c1a68b1386c26b92f2c6126bee8cc808f4ff93a5", "patch": "@@ -126,6 +126,8 @@ fn panic(_: u128) {\n \n #[target_feature(enable = \"sse2\")]\n unsafe fn test_simd() {\n+    assert!(is_x86_feature_detected!(\"sse2\"));\n+\n     let x = _mm_setzero_si128();\n     let y = _mm_set1_epi16(7);\n     let or = _mm_or_si128(x, y);"}, {"sha": "c1d24c3c0c569aa5244ca15f10df11f023697d4a", "filename": "patches/0016-Disable-cpuid-intrinsic.patch", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/847cc7ab2a96c9d2f3c225dc8e86f19a24eefcb4/patches%2F0016-Disable-cpuid-intrinsic.patch", "raw_url": "https://github.com/rust-lang/rust/raw/847cc7ab2a96c9d2f3c225dc8e86f19a24eefcb4/patches%2F0016-Disable-cpuid-intrinsic.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0016-Disable-cpuid-intrinsic.patch?ref=847cc7ab2a96c9d2f3c225dc8e86f19a24eefcb4", "patch": "@@ -1,27 +0,0 @@\n-From 7403e2998345ef0650fd50628d7098d4d1e88e5c Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Sat, 6 Apr 2019 12:16:21 +0200\n-Subject: [PATCH] Remove usage of unsized locals\n-\n----\n- library/stdarch/crates/core_arch/src/x86/cpuid.rs | 2 ++\n- 1 files changed, 2 insertions(+), 0 deletions(-)\n-\n-diff --git a/library/stdarch/crates/core_arch/src/x86/cpuid.rs b/library/stdarch/crates/core_arch/src/x86/cpuid.rs\n-index f313c42..ff952bc 100644\n---- a/library/stdarch/crates/core_arch/src/x86/cpuid.rs\n-+++ b/library/stdarch/crates/core_arch/src/x86/cpuid.rs\n-@@ -84,6 +84,11 @@ pub unsafe fn __cpuid(leaf: u32) -> CpuidResult {\n- /// Does the host support the `cpuid` instruction?\n- #[inline]\n- pub fn has_cpuid() -> bool {\n-+    // __cpuid intrinsic is not yet implemented\n-+    #[cfg(target_feature = \"cg_clif\")] {\n-+        return false;\n-+    }\n-+\n-     #[cfg(target_env = \"sgx\")]\n-     {\n-         false\n--- \n-2.20.1 (Apple Git-117)"}, {"sha": "83e13265d054d39edfe63cb0d481d93a54ecef56", "filename": "src/base.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=c1a68b1386c26b92f2c6126bee8cc808f4ff93a5", "patch": "@@ -681,37 +681,57 @@ fn trans_stmt<'tcx>(\n             use rustc_span::symbol::Symbol;\n             let LlvmInlineAsm {\n                 asm,\n-                outputs: _,\n-                inputs: _,\n+                outputs,\n+                inputs,\n             } = &**asm;\n             let rustc_hir::LlvmInlineAsmInner {\n                 asm: asm_code, // Name\n-                outputs,       // Vec<Name>\n-                inputs,        // Vec<Name>\n+                outputs: output_names, // Vec<LlvmInlineAsmOutput>\n+                inputs: input_names,   // Vec<Name>\n                 clobbers,      // Vec<Name>\n                 volatile,      // bool\n                 alignstack,    // bool\n-                dialect: _,    // rustc_ast::ast::AsmDialect\n+                dialect: _,\n                 asm_str_style: _,\n             } = asm;\n-            match &*asm_code.as_str() {\n+            match asm_code.as_str().trim() {\n                 \"\" => {\n                     // Black box\n                 }\n-                cpuid if cpuid.contains(\"cpuid\") => {\n-                    crate::trap::trap_unimplemented(\n-                        fx,\n-                        \"__cpuid_count arch intrinsic is not supported\",\n-                    );\n+                \"mov %rbx, %rsi\\n                  cpuid\\n                  xchg %rbx, %rsi\" => {\n+                    assert_eq!(input_names, &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]);\n+                    assert_eq!(output_names.len(), 4);\n+                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"]).iter().enumerate() {\n+                        assert_eq!(&output_names[i].constraint.as_str(), c);\n+                        assert!(!output_names[i].is_rw);\n+                        assert!(!output_names[i].is_indirect);\n+                    }\n+\n+                    assert_eq!(clobbers, &[]);\n+\n+                    assert!(!volatile);\n+                    assert!(!alignstack);\n+\n+                    assert_eq!(inputs.len(), 2);\n+                    let leaf = trans_operand(fx, &inputs[0].1).load_scalar(fx); // %eax\n+                    let subleaf = trans_operand(fx, &inputs[1].1).load_scalar(fx); // %ecx\n+\n+                    let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, subleaf);\n+\n+                    assert_eq!(outputs.len(), 4);\n+                    trans_place(fx, outputs[0]).write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n+                    trans_place(fx, outputs[1]).write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n+                    trans_place(fx, outputs[2]).write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n+                    trans_place(fx, outputs[3]).write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n                 }\n                 \"xgetbv\" => {\n-                    assert_eq!(inputs, &[Symbol::intern(\"{ecx}\")]);\n+                    assert_eq!(input_names, &[Symbol::intern(\"{ecx}\")]);\n \n-                    assert_eq!(outputs.len(), 2);\n+                    assert_eq!(output_names.len(), 2);\n                     for (i, c) in (&[\"={eax}\", \"={edx}\"]).iter().enumerate() {\n-                        assert_eq!(&outputs[i].constraint.as_str(), c);\n-                        assert!(!outputs[i].is_rw);\n-                        assert!(!outputs[i].is_indirect);\n+                        assert_eq!(&output_names[i].constraint.as_str(), c);\n+                        assert!(!output_names[i].is_rw);\n+                        assert!(!output_names[i].is_indirect);\n                     }\n \n                     assert_eq!(clobbers, &[]);"}, {"sha": "cbfeefed692342c51af2354dc45d7d9a56a9f708", "filename": "src/intrinsics/cpuid.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5/src%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5/src%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fcpuid.rs?ref=c1a68b1386c26b92f2c6126bee8cc808f4ff93a5", "patch": "@@ -0,0 +1,67 @@\n+use crate::prelude::*;\n+\n+/// Emulates a subset of the cpuid call.\n+///\n+/// This emulates an intel cpu with sse and sse2 support, but which doesn't support anything else.\n+pub(crate) fn codegen_cpuid_call<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    leaf: Value,\n+    _subleaf: Value,\n+) -> (Value, Value, Value, Value) {\n+    let leaf_0 = fx.bcx.create_block();\n+    let leaf_1 = fx.bcx.create_block();\n+    let leaf_8000_0000 = fx.bcx.create_block();\n+    let leaf_8000_0001 = fx.bcx.create_block();\n+    let unsupported_leaf = fx.bcx.create_block();\n+\n+    let dest = fx.bcx.create_block();\n+    let eax = fx.bcx.append_block_param(dest, types::I32);\n+    let ebx = fx.bcx.append_block_param(dest, types::I32);\n+    let ecx = fx.bcx.append_block_param(dest, types::I32);\n+    let edx = fx.bcx.append_block_param(dest, types::I32);\n+\n+    let mut switch = cranelift_frontend::Switch::new();\n+    switch.set_entry(0, leaf_0);\n+    switch.set_entry(1, leaf_1);\n+    switch.set_entry(0x8000_0000, leaf_8000_0000);\n+    switch.set_entry(0x8000_0001, leaf_8000_0001);\n+    switch.emit(&mut fx.bcx, leaf, unsupported_leaf);\n+\n+    fx.bcx.switch_to_block(leaf_0);\n+    let max_basic_leaf = fx.bcx.ins().iconst(types::I32, 1);\n+    let vend0 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n+    let vend2 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n+    let vend1 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n+    fx.bcx.ins().jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n+\n+    fx.bcx.switch_to_block(leaf_1);\n+    let cpu_signature = fx.bcx.ins().iconst(types::I32, 0);\n+    let additional_information = fx.bcx.ins().iconst(types::I32, 0);\n+    let ecx_features = fx.bcx.ins().iconst(\n+        types::I32,\n+        0,\n+    );\n+    let edx_features = fx.bcx.ins().iconst(\n+        types::I32,\n+        1 << 25 /* sse */ | 1 << 26 /* sse2 */,\n+    );\n+    fx.bcx.ins().jump(dest, &[cpu_signature, additional_information, ecx_features, edx_features]);\n+\n+    fx.bcx.switch_to_block(leaf_8000_0000);\n+    let extended_max_basic_leaf = fx.bcx.ins().iconst(types::I32, 0);\n+    let zero = fx.bcx.ins().iconst(types::I32, 0);\n+    fx.bcx.ins().jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n+\n+    fx.bcx.switch_to_block(leaf_8000_0001);\n+    let zero = fx.bcx.ins().iconst(types::I32, 0);\n+    let proc_info_ecx = fx.bcx.ins().iconst(types::I32, 0);\n+    let proc_info_edx = fx.bcx.ins().iconst(types::I32, 0);\n+    fx.bcx.ins().jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n+\n+    fx.bcx.switch_to_block(unsupported_leaf);\n+    crate::trap::trap_unreachable(fx, \"__cpuid_count arch intrinsic doesn't yet support specified leaf\");\n+\n+    fx.bcx.switch_to_block(dest);\n+\n+    (eax, ebx, ecx, edx)\n+}"}, {"sha": "488c08815baceca65a234a7759465e422d245bcf", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1a68b1386c26b92f2c6126bee8cc808f4ff93a5/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=c1a68b1386c26b92f2c6126bee8cc808f4ff93a5", "patch": "@@ -1,6 +1,8 @@\n+mod cpuid;\n mod llvm;\n mod simd;\n \n+pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n use crate::prelude::*;"}]}