{"sha": "744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NGRkNmMxZDVkYjUyMmQ1ZDNiN2YyYmI4MmFiZGU1ZGM0MWNiZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-02T19:46:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-02T19:46:51Z"}, "message": "Auto merge of #44066 - cuviper:powerpc64-extern-abi, r=alexcrichton\n\npowerpc64: improve extern struct ABI\n\nThese fixes all have to do with the 64-bit PowerPC ELF ABI for big-endian\ntargets.  The ELF v2 ABI for powerpc64le already worked well.\n\n- Return after marking return aggregates indirect. Fixes #42757.\n- Pass one-member float aggregates as direct argument values.\n- Aggregate arguments less than 64-bit must be written in the least-\n  significant bits of the parameter space.\n- Larger aggregates are instead padded at the tail.\n  (i.e. filling MSBs, padding the remaining LSBs.)\n\nNew tests were also added for the single-float aggregate, and a 3-byte\naggregate to check that it's filled into LSBs.  Overall, at least these\nformerly-failing tests now pass on powerpc64:\n\n- run-make/extern-fn-struct-passing-abi\n- run-make/extern-fn-with-packed-struct\n- run-pass/extern-pass-TwoU16s.rs\n- run-pass/extern-pass-TwoU8s.rs\n- run-pass/struct-return.rs", "tree": {"sha": "8aa52013c4f9fb978c3d47c4e8a7b41f122a61a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aa52013c4f9fb978c3d47c4e8a7b41f122a61a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb", "html_url": "https://github.com/rust-lang/rust/commit/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "204c0a47e7b7e371cf1cdc159404d405b86386ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/204c0a47e7b7e371cf1cdc159404d405b86386ba", "html_url": "https://github.com/rust-lang/rust/commit/204c0a47e7b7e371cf1cdc159404d405b86386ba"}, {"sha": "40b14736a05c1d26d5be38a48a88cb938e317e59", "url": "https://api.github.com/repos/rust-lang/rust/commits/40b14736a05c1d26d5be38a48a88cb938e317e59", "html_url": "https://github.com/rust-lang/rust/commit/40b14736a05c1d26d5be38a48a88cb938e317e59"}], "stats": {"total": 195, "additions": 151, "deletions": 44}, "files": [{"sha": "fb5472eb6ae1fa3bb154efa6583329ca08945d7e", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb", "patch": "@@ -14,14 +14,26 @@\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n+use rustc::ty::layout;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+enum ABI {\n+    ELFv1, // original ABI used for powerpc64 (big-endian)\n+    ELFv2, // newer ABI used for powerpc64le\n+}\n+use self::ABI::*;\n+\n+fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                      arg: &mut ArgType<'tcx>,\n+                                      abi: ABI)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n         let size = arg.layout.size(ccx);\n \n-        // Ensure we have at most eight uniquely addressable members.\n-        if size > unit.size.checked_mul(8, ccx).unwrap() {\n+        // ELFv1 only passes one-member aggregates transparently.\n+        // ELFv2 passes up to eight uniquely addressable members.\n+        if (abi == ELFv1 && size > unit.size)\n+                || size > unit.size.checked_mul(8, ccx).unwrap() {\n             return None;\n         }\n \n@@ -42,21 +54,23 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut Ar\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>, abi: ABI) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n     }\n \n-    // The PowerPC64 big endian ABI doesn't return aggregates in registers\n-    if ccx.sess().target.target.target_endian == \"big\" {\n+    // The ELFv1 ABI doesn't return aggregates in registers\n+    if abi == ELFv1 {\n         ret.make_indirect(ccx);\n+        return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n+    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret, abi) {\n         ret.cast_to(ccx, uniform);\n         return;\n     }\n+\n     let size = ret.layout.size(ccx);\n     let bits = size.bits();\n     if bits <= 128 {\n@@ -80,31 +94,55 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>, abi: ABI) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n+    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg, abi) {\n         arg.cast_to(ccx, uniform);\n         return;\n     }\n \n-    let total = arg.layout.size(ccx);\n+    let size = arg.layout.size(ccx);\n+    let (unit, total) = match abi {\n+        ELFv1 => {\n+            // In ELFv1, aggregates smaller than a doubleword should appear in\n+            // the least-significant bits of the parameter doubleword.  The rest\n+            // should be padded at their tail to fill out multiple doublewords.\n+            if size.bits() <= 64 {\n+                (Reg { kind: RegKind::Integer, size }, size)\n+            } else {\n+                let align = layout::Align::from_bits(64, 64).unwrap();\n+                (Reg::i64(), size.abi_align(align))\n+            }\n+        },\n+        ELFv2 => {\n+            // In ELFv2, we can just cast directly.\n+            (Reg::i64(), size)\n+        },\n+    };\n+\n     arg.cast_to(ccx, Uniform {\n-        unit: Reg::i64(),\n+        unit,\n         total\n     });\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let abi = match ccx.sess().target.target.target_endian.as_str() {\n+        \"big\" => ELFv1,\n+        \"little\" => ELFv2,\n+        _ => unimplemented!(),\n+    };\n+\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(ccx, &mut fty.ret, abi);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(ccx, arg, abi);\n     }\n }"}, {"sha": "49634d6e78ce9a589eb68d9e68c5833aa7558bbc", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb", "patch": "@@ -11,12 +11,30 @@\n use abi::{ArgAttribute, FnType, LayoutExt, Reg, RegKind};\n use common::CrateContext;\n \n+use rustc::ty::layout::{self, Layout, TyLayout};\n+\n #[derive(PartialEq)]\n pub enum Flavor {\n     General,\n     Fastcall\n }\n \n+fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                  layout: TyLayout<'tcx>) -> bool {\n+    match *layout {\n+        Layout::Scalar { value: layout::F32, .. } |\n+        Layout::Scalar { value: layout::F64, .. } => true,\n+        Layout::Univariant { .. } => {\n+            if layout.field_count() == 1 {\n+                is_single_fp_element(ccx, layout.field(ccx, 0))\n+            } else {\n+                false\n+            }\n+        }\n+        _ => false\n+    }\n+}\n+\n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   fty: &mut FnType<'tcx>,\n                                   flavor: Flavor) {\n@@ -33,12 +51,23 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             if t.options.is_like_osx || t.options.is_like_windows\n                 || t.options.is_like_openbsd {\n                 let size = fty.ret.layout.size(ccx);\n-                match size.bytes() {\n-                    1 => fty.ret.cast_to(ccx, Reg::i8()),\n-                    2 => fty.ret.cast_to(ccx, Reg::i16()),\n-                    4 => fty.ret.cast_to(ccx, Reg::i32()),\n-                    8 => fty.ret.cast_to(ccx, Reg::i64()),\n-                    _ => fty.ret.make_indirect(ccx)\n+\n+                // According to Clang, everyone but MSVC returns single-element\n+                // float aggregates directly in a floating-point register.\n+                if !t.options.is_like_msvc && is_single_fp_element(ccx, fty.ret.layout) {\n+                    match size.bytes() {\n+                        4 => fty.ret.cast_to(ccx, Reg::f32()),\n+                        8 => fty.ret.cast_to(ccx, Reg::f64()),\n+                        _ => fty.ret.make_indirect(ccx)\n+                    }\n+                } else {\n+                    match size.bytes() {\n+                        1 => fty.ret.cast_to(ccx, Reg::i8()),\n+                        2 => fty.ret.cast_to(ccx, Reg::i16()),\n+                        4 => fty.ret.cast_to(ccx, Reg::i32()),\n+                        8 => fty.ret.cast_to(ccx, Reg::i64()),\n+                        _ => fty.ret.make_indirect(ccx)\n+                    }\n                 }\n             } else {\n                 fty.ret.make_indirect(ccx);"}, {"sha": "25cd6da10b8fd105399db6c286df9d39b887b73e", "filename": "src/test/run-make/extern-fn-struct-passing-abi/test.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c?ref=744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb", "patch": "@@ -43,6 +43,16 @@ struct FloatPoint {\n     double y;\n };\n \n+struct FloatOne {\n+    double x;\n+};\n+\n+struct IntOdd {\n+    int8_t a;\n+    int8_t b;\n+    int8_t c;\n+};\n+\n // System V x86_64 ABI:\n // a, b, c, d, e should be in registers\n // s should be byval pointer\n@@ -283,7 +293,7 @@ struct Huge huge_struct(struct Huge s) {\n // p should be in registers\n // return should be in registers\n //\n-// Win64 ABI:\n+// Win64 ABI and 64-bit PowerPC ELFv1 ABI:\n // p should be a byval pointer\n // return should be in a hidden sret pointer\n struct FloatPoint float_point(struct FloatPoint p) {\n@@ -292,3 +302,23 @@ struct FloatPoint float_point(struct FloatPoint p) {\n \n     return p;\n }\n+\n+// 64-bit PowerPC ELFv1 ABI:\n+// f1 should be in a register\n+// return should be in a hidden sret pointer\n+struct FloatOne float_one(struct FloatOne f1) {\n+    assert(f1.x == 7.);\n+\n+    return f1;\n+}\n+\n+// 64-bit PowerPC ELFv1 ABI:\n+// i should be in the least-significant bits of a register\n+// return should be in a hidden sret pointer\n+struct IntOdd int_odd(struct IntOdd i) {\n+    assert(i.a == 1);\n+    assert(i.b == 2);\n+    assert(i.c == 3);\n+\n+    return i;\n+}"}, {"sha": "54a4f868eb4e53e06e3a68cb0fc1d3182e8c158d", "filename": "src/test/run-make/extern-fn-struct-passing-abi/test.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs?ref=744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb", "patch": "@@ -53,6 +53,20 @@ struct FloatPoint {\n     y: f64\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq)]\n+#[repr(C)]\n+struct FloatOne {\n+    x: f64,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+#[repr(C)]\n+struct IntOdd {\n+    a: i8,\n+    b: i8,\n+    c: i8,\n+}\n+\n #[link(name = \"test\", kind = \"static\")]\n extern {\n     fn byval_rect(a: i32, b: i32, c: i32, d: i32, e: i32, s: Rect);\n@@ -83,6 +97,10 @@ extern {\n     fn huge_struct(s: Huge) -> Huge;\n \n     fn float_point(p: FloatPoint) -> FloatPoint;\n+\n+    fn float_one(f: FloatOne) -> FloatOne;\n+\n+    fn int_odd(i: IntOdd) -> IntOdd;\n }\n \n fn main() {\n@@ -91,6 +109,8 @@ fn main() {\n     let u = FloatRect { a: 3489, b: 3490, c: 8. };\n     let v = Huge { a: 5647, b: 5648, c: 5649, d: 5650, e: 5651 };\n     let p = FloatPoint { x: 5., y: -3. };\n+    let f1 = FloatOne { x: 7. };\n+    let i = IntOdd { a: 1, b: 2, c: 3 };\n \n     unsafe {\n         byval_rect(1, 2, 3, 4, 5, s);\n@@ -113,5 +133,12 @@ fn main() {\n         assert_eq!(sret_byval_struct(1, 2, 3, 4, s), t);\n         assert_eq!(sret_split_struct(1, 2, s), t);\n         assert_eq!(float_point(p), p);\n+        assert_eq!(int_odd(i), i);\n+\n+        // MSVC/GCC/Clang are not consistent in the ABI of single-float aggregates.\n+        // x86_64: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82028\n+        // i686: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82041\n+        #[cfg(not(all(windows, target_env = \"gnu\")))]\n+        assert_eq!(float_one(f1), f1);\n     }\n }"}, {"sha": "4124e202c1dd05d4f0875493c6912dc41748f97b", "filename": "src/test/run-make/extern-fn-with-packed-struct/test.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.c?ref=744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb", "patch": "@@ -1,6 +1,8 @@\n // ignore-license\n // Pragma needed cause of gcc bug on windows: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=52991\n \n+#include <assert.h>\n+\n #ifdef _MSC_VER\n #pragma pack(push,1)\n struct Foo {\n@@ -18,5 +20,8 @@ struct __attribute__((packed)) Foo {\n #endif\n \n struct Foo foo(struct Foo foo) {\n+    assert(foo.a == 1);\n+    assert(foo.b == 2);\n+    assert(foo.c == 3);\n     return foo;\n }"}, {"sha": "d2540ad61542b0bc709cafac2a2fa304388f3218", "filename": "src/test/run-make/extern-fn-with-packed-struct/test.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs?ref=744dd6c1d5db522d5d3b7f2bb82abde5dc41cbeb", "patch": "@@ -8,36 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt;\n-\n-#[repr(packed)]\n-#[derive(Copy, Clone)]\n+#[repr(C, packed)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n struct Foo {\n     a: i8,\n     b: i16,\n     c: i8\n }\n \n-impl PartialEq for Foo {\n-    fn eq(&self, other: &Foo) -> bool {\n-        self.a == other.a && self.b == other.b && self.c == other.c\n-    }\n-}\n-\n-impl fmt::Debug for Foo {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let a = self.a;\n-        let b = self.b;\n-        let c = self.c;\n-\n-        f.debug_struct(\"Foo\")\n-            .field(\"a\", &a)\n-            .field(\"b\", &b)\n-            .field(\"c\", &c)\n-            .finish()\n-    }\n-}\n-\n #[link(name = \"test\", kind = \"static\")]\n extern {\n     fn foo(f: Foo) -> Foo;"}]}