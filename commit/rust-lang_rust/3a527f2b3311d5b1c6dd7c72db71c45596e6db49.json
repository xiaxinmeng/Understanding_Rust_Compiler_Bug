{"sha": "3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNTI3ZjJiMzMxMWQ1YjFjNmRkN2M3MmRiNzFjNDU1OTZlNmRiNDk=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-01T00:03:56Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-09T04:40:38Z"}, "message": "Runtime removal: add private sys, sys_common modules\n\nThese modules will house the code that used to be part of the runtime system\nin libnative. The `sys_common` module contains a few low-level but\ncross-platform details. The `sys` module is set up using `#[cfg()]` to\ninclude either a unix or windows implementation of a common API\nsurface. This API surface is *not* exported directly in `libstd`, but is\ninstead used to bulid `std::os` and `std::io`.\n\nUltimately, the low-level details in `sys` will be exposed in a\ncontrolled way through a separate platform-specific surface, but that\nsetup is not part of this patch.", "tree": {"sha": "1a550dd4b679b0ccf13acef6cc7879e486a3d3de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a550dd4b679b0ccf13acef6cc7879e486a3d3de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "html_url": "https://github.com/rust-lang/rust/commit/3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93c85eb8bdcc910a27caf6abd20207a626ae98e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/93c85eb8bdcc910a27caf6abd20207a626ae98e5", "html_url": "https://github.com/rust-lang/rust/commit/93c85eb8bdcc910a27caf6abd20207a626ae98e5"}], "stats": {"total": 1048, "additions": 592, "deletions": 456}, "files": [{"sha": "90f8f6c214e78d83034bf2b42bf37bdaa24392b9", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "patch": "@@ -73,9 +73,6 @@ pub mod pipe;\n #[path = \"tty_windows.rs\"]\n mod tty;\n \n-#[cfg(unix)]    #[path = \"c_unix.rs\"]  mod c;\n-#[cfg(windows)] #[path = \"c_windows.rs\"] mod c;\n-\n fn unimpl() -> IoError {\n     #[cfg(unix)] use libc::ENOSYS as ERROR;\n     #[cfg(windows)] use libc::ERROR_CALL_NOT_IMPLEMENTED as ERROR;"}, {"sha": "5f69ec00cddd493195ab2989e8aea1ae9268dcce", "filename": "src/libnative/io/util.rs", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/93c85eb8bdcc910a27caf6abd20207a626ae98e5/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c85eb8bdcc910a27caf6abd20207a626ae98e5/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=93c85eb8bdcc910a27caf6abd20207a626ae98e5", "patch": "@@ -1,209 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc;\n-use std::cmp;\n-use std::mem;\n-use std::os;\n-use std::ptr;\n-use std::rt::rtio::{IoResult, IoError};\n-\n-use super::c;\n-use super::net;\n-use super::{retry, last_error};\n-\n-#[deriving(Show)]\n-pub enum SocketStatus {\n-    Readable,\n-    Writable,\n-}\n-\n-pub fn timeout(desc: &'static str) -> IoError {\n-    #[cfg(unix)] use libc::ETIMEDOUT as ERROR;\n-    #[cfg(windows)] use libc::ERROR_OPERATION_ABORTED as ERROR;\n-    IoError {\n-        code: ERROR as uint,\n-        extra: 0,\n-        detail: Some(desc.to_string()),\n-    }\n-}\n-\n-pub fn short_write(n: uint, desc: &'static str) -> IoError {\n-    #[cfg(unix)] use libc::EAGAIN as ERROR;\n-    #[cfg(windows)] use libc::ERROR_OPERATION_ABORTED as ERROR;\n-    IoError {\n-        code: ERROR as uint,\n-        extra: n,\n-        detail: Some(desc.to_string()),\n-    }\n-}\n-\n-pub fn eof() -> IoError {\n-    IoError {\n-        code: libc::EOF as uint,\n-        extra: 0,\n-        detail: None,\n-    }\n-}\n-\n-#[cfg(windows)]\n-pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n-    libc::timeval {\n-        tv_sec: (ms / 1000) as libc::c_long,\n-        tv_usec: ((ms % 1000) * 1000) as libc::c_long,\n-    }\n-}\n-#[cfg(not(windows))]\n-pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n-    libc::timeval {\n-        tv_sec: (ms / 1000) as libc::time_t,\n-        tv_usec: ((ms % 1000) * 1000) as libc::suseconds_t,\n-    }\n-}\n-\n-#[cfg(unix)]\n-pub fn wouldblock() -> bool {\n-    let err = os::errno();\n-    err == libc::EWOULDBLOCK as int || err == libc::EAGAIN as int\n-}\n-\n-#[cfg(windows)]\n-pub fn wouldblock() -> bool {\n-    let err = os::errno();\n-    err == libc::WSAEWOULDBLOCK as uint\n-}\n-\n-#[cfg(unix)]\n-pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n-    let set = nb as libc::c_int;\n-    super::mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n-}\n-\n-#[cfg(windows)]\n-pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n-    let mut set = nb as libc::c_ulong;\n-    if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n-        Err(last_error())\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n-// See http://developerweb.net/viewtopic.php?id=3196 for where this is\n-// derived from.\n-pub fn connect_timeout(fd: net::sock_t,\n-                       addrp: *const libc::sockaddr,\n-                       len: libc::socklen_t,\n-                       timeout_ms: u64) -> IoResult<()> {\n-    use std::os;\n-    #[cfg(unix)]    use libc::EINPROGRESS as INPROGRESS;\n-    #[cfg(windows)] use libc::WSAEINPROGRESS as INPROGRESS;\n-    #[cfg(unix)]    use libc::EWOULDBLOCK as WOULDBLOCK;\n-    #[cfg(windows)] use libc::WSAEWOULDBLOCK as WOULDBLOCK;\n-\n-    // Make sure the call to connect() doesn't block\n-    try!(set_nonblocking(fd, true));\n-\n-    let ret = match unsafe { libc::connect(fd, addrp, len) } {\n-        // If the connection is in progress, then we need to wait for it to\n-        // finish (with a timeout). The current strategy for doing this is\n-        // to use select() with a timeout.\n-        -1 if os::errno() as int == INPROGRESS as int ||\n-              os::errno() as int == WOULDBLOCK as int => {\n-            let mut set: c::fd_set = unsafe { mem::zeroed() };\n-            c::fd_set(&mut set, fd);\n-            match await(fd, &mut set, timeout_ms) {\n-                0 => Err(timeout(\"connection timed out\")),\n-                -1 => Err(last_error()),\n-                _ => {\n-                    let err: libc::c_int = try!(\n-                        net::getsockopt(fd, libc::SOL_SOCKET, libc::SO_ERROR));\n-                    if err == 0 {\n-                        Ok(())\n-                    } else {\n-                        Err(IoError {\n-                            code: err as uint,\n-                            extra: 0,\n-                            detail: Some(os::error_string(err as uint)),\n-                        })\n-                    }\n-                }\n-            }\n-        }\n-\n-        -1 => Err(last_error()),\n-        _ => Ok(()),\n-    };\n-\n-    // be sure to turn blocking I/O back on\n-    try!(set_nonblocking(fd, false));\n-    return ret;\n-\n-    #[cfg(unix)]\n-    fn await(fd: net::sock_t, set: &mut c::fd_set,\n-             timeout: u64) -> libc::c_int {\n-        let start = ::io::timer::now();\n-        retry(|| unsafe {\n-            // Recalculate the timeout each iteration (it is generally\n-            // undefined what the value of the 'tv' is after select\n-            // returns EINTR).\n-            let mut tv = ms_to_timeval(timeout - (::io::timer::now() - start));\n-            c::select(fd + 1, ptr::null_mut(), set as *mut _,\n-                      ptr::null_mut(), &mut tv)\n-        })\n-    }\n-    #[cfg(windows)]\n-    fn await(_fd: net::sock_t, set: &mut c::fd_set,\n-             timeout: u64) -> libc::c_int {\n-        let mut tv = ms_to_timeval(timeout);\n-        unsafe { c::select(1, ptr::null_mut(), set, ptr::null_mut(), &mut tv) }\n-    }\n-}\n-\n-pub fn await(fds: &[net::sock_t], deadline: Option<u64>,\n-             status: SocketStatus) -> IoResult<()> {\n-    let mut set: c::fd_set = unsafe { mem::zeroed() };\n-    let mut max = 0;\n-    for &fd in fds.iter() {\n-        c::fd_set(&mut set, fd);\n-        max = cmp::max(max, fd + 1);\n-    }\n-    if cfg!(windows) {\n-        max = fds.len() as net::sock_t;\n-    }\n-\n-    let (read, write) = match status {\n-        Readable => (&mut set as *mut _, ptr::null_mut()),\n-        Writable => (ptr::null_mut(), &mut set as *mut _),\n-    };\n-    let mut tv: libc::timeval = unsafe { mem::zeroed() };\n-\n-    match retry(|| {\n-        let now = ::io::timer::now();\n-        let tvp = match deadline {\n-            None => ptr::null_mut(),\n-            Some(deadline) => {\n-                // If we're past the deadline, then pass a 0 timeout to\n-                // select() so we can poll the status\n-                let ms = if deadline < now {0} else {deadline - now};\n-                tv = ms_to_timeval(ms);\n-                &mut tv as *mut _\n-            }\n-        };\n-        let r = unsafe {\n-            c::select(max as libc::c_int, read, write, ptr::null_mut(), tvp)\n-        };\n-        r\n-    }) {\n-        -1 => Err(last_error()),\n-        0 => Err(timeout(\"timed out\")),\n-        _ => Ok(()),\n-    }\n-}"}, {"sha": "78abbb9f80df770901895781bfe4457611022d8d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 87, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "patch": "@@ -236,8 +236,7 @@ use os;\n use boxed::Box;\n use result::{Ok, Err, Result};\n use rt::rtio;\n-use slice::{AsSlice, SlicePrelude};\n-use str::{Str, StrPrelude};\n+use sys;\n use str;\n use string::String;\n use uint;\n@@ -312,91 +311,10 @@ impl IoError {\n     /// struct is filled with an allocated string describing the error\n     /// in more detail, retrieved from the operating system.\n     pub fn from_errno(errno: uint, detail: bool) -> IoError {\n-\n-        #[cfg(windows)]\n-        fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n-            match errno {\n-                libc::EOF => (EndOfFile, \"end of file\"),\n-                libc::ERROR_NO_DATA => (BrokenPipe, \"the pipe is being closed\"),\n-                libc::ERROR_FILE_NOT_FOUND => (FileNotFound, \"file not found\"),\n-                libc::ERROR_INVALID_NAME => (InvalidInput, \"invalid file name\"),\n-                libc::WSAECONNREFUSED => (ConnectionRefused, \"connection refused\"),\n-                libc::WSAECONNRESET => (ConnectionReset, \"connection reset\"),\n-                libc::ERROR_ACCESS_DENIED | libc::WSAEACCES =>\n-                    (PermissionDenied, \"permission denied\"),\n-                libc::WSAEWOULDBLOCK => {\n-                    (ResourceUnavailable, \"resource temporarily unavailable\")\n-                }\n-                libc::WSAENOTCONN => (NotConnected, \"not connected\"),\n-                libc::WSAECONNABORTED => (ConnectionAborted, \"connection aborted\"),\n-                libc::WSAEADDRNOTAVAIL => (ConnectionRefused, \"address not available\"),\n-                libc::WSAEADDRINUSE => (ConnectionRefused, \"address in use\"),\n-                libc::ERROR_BROKEN_PIPE => (EndOfFile, \"the pipe has ended\"),\n-                libc::ERROR_OPERATION_ABORTED =>\n-                    (TimedOut, \"operation timed out\"),\n-                libc::WSAEINVAL => (InvalidInput, \"invalid argument\"),\n-                libc::ERROR_CALL_NOT_IMPLEMENTED =>\n-                    (IoUnavailable, \"function not implemented\"),\n-                libc::ERROR_INVALID_HANDLE =>\n-                    (MismatchedFileTypeForOperation,\n-                     \"invalid handle provided to function\"),\n-                libc::ERROR_NOTHING_TO_TERMINATE =>\n-                    (InvalidInput, \"no process to kill\"),\n-\n-                // libuv maps this error code to EISDIR. we do too. if it is found\n-                // to be incorrect, we can add in some more machinery to only\n-                // return this message when ERROR_INVALID_FUNCTION after certain\n-                // Windows calls.\n-                libc::ERROR_INVALID_FUNCTION => (InvalidInput,\n-                                                 \"illegal operation on a directory\"),\n-\n-                _ => (OtherIoError, \"unknown error\")\n-            }\n-        }\n-\n-        #[cfg(not(windows))]\n-        fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n-            // FIXME: this should probably be a bit more descriptive...\n-            match errno {\n-                libc::EOF => (EndOfFile, \"end of file\"),\n-                libc::ECONNREFUSED => (ConnectionRefused, \"connection refused\"),\n-                libc::ECONNRESET => (ConnectionReset, \"connection reset\"),\n-                libc::EPERM | libc::EACCES =>\n-                    (PermissionDenied, \"permission denied\"),\n-                libc::EPIPE => (BrokenPipe, \"broken pipe\"),\n-                libc::ENOTCONN => (NotConnected, \"not connected\"),\n-                libc::ECONNABORTED => (ConnectionAborted, \"connection aborted\"),\n-                libc::EADDRNOTAVAIL => (ConnectionRefused, \"address not available\"),\n-                libc::EADDRINUSE => (ConnectionRefused, \"address in use\"),\n-                libc::ENOENT => (FileNotFound, \"no such file or directory\"),\n-                libc::EISDIR => (InvalidInput, \"illegal operation on a directory\"),\n-                libc::ENOSYS => (IoUnavailable, \"function not implemented\"),\n-                libc::EINVAL => (InvalidInput, \"invalid argument\"),\n-                libc::ENOTTY =>\n-                    (MismatchedFileTypeForOperation,\n-                     \"file descriptor is not a TTY\"),\n-                libc::ETIMEDOUT => (TimedOut, \"operation timed out\"),\n-                libc::ECANCELED => (TimedOut, \"operation aborted\"),\n-\n-                // These two constants can have the same value on some systems,\n-                // but different values on others, so we can't use a match\n-                // clause\n-                x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n-                    (ResourceUnavailable, \"resource temporarily unavailable\"),\n-\n-                _ => (OtherIoError, \"unknown error\")\n-            }\n-        }\n-\n-        let (kind, desc) = get_err(errno as i32);\n-        IoError {\n-            kind: kind,\n-            desc: desc,\n-            detail: if detail && kind == OtherIoError {\n-                Some(os::error_string(errno).as_slice().chars().map(|c| c.to_lowercase()).collect())\n-            } else {\n-                None\n-            },\n+        let mut err = sys::decode_error(errno as i32);\n+        if detail && err.kind == OtherIoError {\n+            err.detail = Some(os::error_string(errno).as_slice().chars()\n+                                 .map(|c| c.to_lowercase()).collect())\n         }\n     }\n "}, {"sha": "7eac455f97f250ab6efe998e315251f33295260d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "patch": "@@ -242,6 +242,13 @@ pub mod io;\n pub mod path;\n pub mod fmt;\n \n+#[cfg(unix)]\n+#[path = \"sys/unix/mod.rs\"] mod sys;\n+#[cfg(windows)]\n+#[path = \"sys/windows/mod.rs\"] mod sys;\n+\n+#[path = \"sys/common/mod.rs\"] mod sys_common;\n+\n // FIXME #7809: This shouldn't be pub, and it should be reexported under 'unstable'\n // but name resolution doesn't work without it being pub.\n pub mod rt;"}, {"sha": "175e23bf8192ad251b9360f58676755687f90901", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 151, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "patch": "@@ -34,7 +34,7 @@\n use clone::Clone;\n use error::{FromError, Error};\n use fmt;\n-use io::{IoResult, IoError};\n+use io::IoResult;\n use iter::Iterator;\n use libc::{c_void, c_int};\n use libc;\n@@ -43,6 +43,7 @@ use ops::Drop;\n use option::{Some, None, Option};\n use os;\n use path::{Path, GenericPath, BytesContainer};\n+use sys::os as os_imp;\n use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n@@ -905,59 +906,9 @@ pub fn change_dir(p: &Path) -> bool {\n     }\n }\n \n-#[cfg(unix)]\n-/// Returns the platform-specific value of errno\n-pub fn errno() -> int {\n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"ios\",\n-              target_os = \"freebsd\"))]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __error() -> *const c_int;\n-        }\n-        unsafe {\n-            __error()\n-        }\n-    }\n-\n-    #[cfg(target_os = \"dragonfly\")]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __dfly_error() -> *const c_int;\n-        }\n-        unsafe {\n-            __dfly_error()\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __errno_location() -> *const c_int;\n-        }\n-        unsafe {\n-            __errno_location()\n-        }\n-    }\n-\n-    unsafe {\n-        (*errno_location()) as int\n-    }\n-}\n-\n-#[cfg(windows)]\n /// Returns the platform-specific value of errno\n pub fn errno() -> uint {\n-    use libc::types::os::arch::extra::DWORD;\n-\n-    #[link_name = \"kernel32\"]\n-    extern \"system\" {\n-        fn GetLastError() -> DWORD;\n-    }\n-\n-    unsafe {\n-        GetLastError() as uint\n-    }\n+    os_imp::errno() as uint\n }\n \n /// Return the string corresponding to an `errno()` value of `errnum`.\n@@ -969,105 +920,7 @@ pub fn errno() -> uint {\n /// println!(\"{}\", os::error_string(os::errno() as uint));\n /// ```\n pub fn error_string(errnum: uint) -> String {\n-    return strerror(errnum);\n-\n-    #[cfg(unix)]\n-    fn strerror(errnum: uint) -> String {\n-        #[cfg(any(target_os = \"macos\",\n-                  target_os = \"ios\",\n-                  target_os = \"android\",\n-                  target_os = \"freebsd\",\n-                  target_os = \"dragonfly\"))]\n-        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)\n-                      -> c_int {\n-            extern {\n-                fn strerror_r(errnum: c_int, buf: *mut c_char,\n-                              buflen: libc::size_t) -> c_int;\n-            }\n-            unsafe {\n-                strerror_r(errnum, buf, buflen)\n-            }\n-        }\n-\n-        // GNU libc provides a non-compliant version of strerror_r by default\n-        // and requires macros to instead use the POSIX compliant variant.\n-        // So we just use __xpg_strerror_r which is always POSIX compliant\n-        #[cfg(target_os = \"linux\")]\n-        fn strerror_r(errnum: c_int, buf: *mut c_char,\n-                      buflen: libc::size_t) -> c_int {\n-            extern {\n-                fn __xpg_strerror_r(errnum: c_int,\n-                                    buf: *mut c_char,\n-                                    buflen: libc::size_t)\n-                                    -> c_int;\n-            }\n-            unsafe {\n-                __xpg_strerror_r(errnum, buf, buflen)\n-            }\n-        }\n-\n-        let mut buf = [0 as c_char, ..TMPBUF_SZ];\n-\n-        let p = buf.as_mut_ptr();\n-        unsafe {\n-            if strerror_r(errnum as c_int, p, buf.len() as libc::size_t) < 0 {\n-                panic!(\"strerror_r failure\");\n-            }\n-\n-            ::string::raw::from_buf(p as *const u8)\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn strerror(errnum: uint) -> String {\n-        use libc::types::os::arch::extra::DWORD;\n-        use libc::types::os::arch::extra::LPWSTR;\n-        use libc::types::os::arch::extra::LPVOID;\n-        use libc::types::os::arch::extra::WCHAR;\n-\n-        #[link_name = \"kernel32\"]\n-        extern \"system\" {\n-            fn FormatMessageW(flags: DWORD,\n-                              lpSrc: LPVOID,\n-                              msgId: DWORD,\n-                              langId: DWORD,\n-                              buf: LPWSTR,\n-                              nsize: DWORD,\n-                              args: *const c_void)\n-                              -> DWORD;\n-        }\n-\n-        static FORMAT_MESSAGE_FROM_SYSTEM: DWORD = 0x00001000;\n-        static FORMAT_MESSAGE_IGNORE_INSERTS: DWORD = 0x00000200;\n-\n-        // This value is calculated from the macro\n-        // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)\n-        let langId = 0x0800 as DWORD;\n-\n-        let mut buf = [0 as WCHAR, ..TMPBUF_SZ];\n-\n-        unsafe {\n-            let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n-                                     FORMAT_MESSAGE_IGNORE_INSERTS,\n-                                     ptr::null_mut(),\n-                                     errnum as DWORD,\n-                                     langId,\n-                                     buf.as_mut_ptr(),\n-                                     buf.len() as DWORD,\n-                                     ptr::null());\n-            if res == 0 {\n-                // Sometimes FormatMessageW can fail e.g. system doesn't like langId,\n-                let fm_err = errno();\n-                return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n-            }\n-\n-            let msg = String::from_utf16(::str::truncate_utf16_at_nul(buf));\n-            match msg {\n-                Some(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n-                None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", errnum),\n-            }\n-        }\n-    }\n+    return os_imp::error_string(errnum as i32);\n }\n \n /// Get a string representing the platform-dependent last error"}, {"sha": "402c62bb35e4fd90e8b99694859553545f743650", "filename": "src/libstd/sys/common/mod.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_doc)]\n+#![allow(dead_code)]\n+\n+use io::{mod, IoError, IoResult};\n+use prelude::*;\n+use num;\n+use sys::{last_error, retry, fs};\n+use c_str::CString;\n+use path::BytesContainer;\n+use collections;\n+\n+pub mod net;\n+\n+// common error constructors\n+\n+pub fn eof() -> IoError {\n+    IoError {\n+        kind: io::EndOfFile,\n+        desc: \"end of file\",\n+        detail: None,\n+    }\n+}\n+\n+pub fn timeout(desc: &'static str) -> IoError {\n+    IoError {\n+        kind: io::TimedOut,\n+        desc: desc,\n+        detail: None,\n+    }\n+}\n+\n+pub fn short_write(n: uint, desc: &'static str) -> IoError {\n+    IoError {\n+        kind: if n == 0 { io::TimedOut } else { io::ShortWrite(n) },\n+        desc: desc,\n+        detail: None,\n+    }\n+}\n+\n+// unix has nonzero values as errors\n+pub fn mkerr_libc<Int: num::Zero>(ret: Int) -> IoResult<()> {\n+    if !ret.is_zero() {\n+        Err(last_error())\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+pub fn keep_going(data: &[u8], f: |*const u8, uint| -> i64) -> i64 {\n+    let origamt = data.len();\n+    let mut data = data.as_ptr();\n+    let mut amt = origamt;\n+    while amt > 0 {\n+        let ret = retry(|| f(data, amt));\n+        if ret == 0 {\n+            break\n+        } else if ret != -1 {\n+            amt -= ret as uint;\n+            data = unsafe { data.offset(ret as int) };\n+        } else {\n+            return ret;\n+        }\n+    }\n+    return (origamt - amt) as i64;\n+}\n+\n+// traits for extracting representations from\n+\n+pub trait AsFileDesc {\n+    fn as_fd(&self) -> &fs::FileDesc;\n+}\n+\n+pub trait ProcessConfig<K: BytesContainer, V: BytesContainer> {\n+    fn program(&self) -> &CString;\n+    fn args(&self) -> &[CString];\n+    fn env(&self) -> Option<&collections::HashMap<K, V>>;\n+    fn cwd(&self) -> Option<&CString>;\n+    fn uid(&self) -> Option<uint>;\n+    fn gid(&self) -> Option<uint>;\n+    fn detach(&self) -> bool;\n+}"}, {"sha": "e76f2a2b872db2211a8da1881e2d7e1cc6853901", "filename": "src/libstd/sys/unix/c.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "patch": "@@ -11,6 +11,7 @@\n //! C definitions used by libnative that don't belong in liblibc\n \n #![allow(dead_code)]\n+#![allow(non_camel_case_types)]\n \n pub use self::select::fd_set;\n pub use self::signal::{sigaction, siginfo, sigset_t};\n@@ -106,7 +107,7 @@ mod select {\n           target_os = \"dragonfly\",\n           target_os = \"linux\"))]\n mod select {\n-    use std::uint;\n+    use uint;\n     use libc;\n \n     pub const FD_SETSIZE: uint = 1024;", "previous_filename": "src/libnative/io/c_unix.rs"}, {"sha": "ad5de2dad480d40e3ae6b0aa44070716ce4d0cee", "filename": "src/libstd/sys/unix/mod.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate libc;\n+\n+use num;\n+use prelude::*;\n+use io::{mod, IoResult, IoError};\n+\n+pub mod fs;\n+pub mod os;\n+pub mod c;\n+\n+pub type sock_t = io::file::fd_t;\n+pub type wrlen = libc::size_t;\n+pub unsafe fn close_sock(sock: sock_t) { let _ = libc::close(sock); }\n+\n+pub fn last_error() -> IoError {\n+    let errno = os::errno() as i32;\n+    let mut err = decode_error(errno);\n+    err.detail = Some(os::error_string(errno));\n+    err\n+}\n+\n+/// Convert an `errno` value into a high-level error variant and description.\n+pub fn decode_error(errno: i32) -> IoError {\n+    // FIXME: this should probably be a bit more descriptive...\n+    let (kind, desc) = match errno {\n+        libc::EOF => (io::EndOfFile, \"end of file\"),\n+        libc::ECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n+        libc::ECONNRESET => (io::ConnectionReset, \"connection reset\"),\n+        libc::EPERM | libc::EACCES =>\n+            (io::PermissionDenied, \"permission denied\"),\n+        libc::EPIPE => (io::BrokenPipe, \"broken pipe\"),\n+        libc::ENOTCONN => (io::NotConnected, \"not connected\"),\n+        libc::ECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n+        libc::EADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n+        libc::EADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n+        libc::ENOENT => (io::FileNotFound, \"no such file or directory\"),\n+        libc::EISDIR => (io::InvalidInput, \"illegal operation on a directory\"),\n+        libc::ENOSYS => (io::IoUnavailable, \"function not implemented\"),\n+        libc::EINVAL => (io::InvalidInput, \"invalid argument\"),\n+        libc::ENOTTY =>\n+            (io::MismatchedFileTypeForOperation,\n+             \"file descriptor is not a TTY\"),\n+        libc::ETIMEDOUT => (io::TimedOut, \"operation timed out\"),\n+        libc::ECANCELED => (io::TimedOut, \"operation aborted\"),\n+\n+        // These two constants can have the same value on some systems,\n+        // but different values on others, so we can't use a match\n+        // clause\n+        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+            (io::ResourceUnavailable, \"resource temporarily unavailable\"),\n+\n+        _ => (io::OtherIoError, \"unknown error\")\n+    };\n+    IoError { kind: kind, desc: desc, detail: None }\n+}\n+\n+#[inline]\n+pub fn retry<I: PartialEq + num::One + Neg<I>> (f: || -> I) -> I {\n+    let minus_one = -num::one::<I>();\n+    loop {\n+        let n = f();\n+        if n == minus_one && os::errno() == libc::EINTR as int { }\n+        else { return n }\n+    }\n+}\n+\n+pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n+    libc::timeval {\n+        tv_sec: (ms / 1000) as libc::time_t,\n+        tv_usec: ((ms % 1000) * 1000) as libc::suseconds_t,\n+    }\n+}\n+\n+pub fn wouldblock() -> bool {\n+    let err = os::errno();\n+    err == libc::EWOULDBLOCK as int || err == libc::EAGAIN as int\n+}\n+\n+pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n+    let set = nb as libc::c_int;\n+    super::mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n+}"}, {"sha": "34699eb27c11528636e0579a875de92a0899a4b3", "filename": "src/libstd/sys/unix/os.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc;\n+use libc::{c_int, c_char};\n+use prelude::*;\n+\n+use os::TMPBUF_SZ;\n+\n+/// Returns the platform-specific value of errno\n+pub fn errno() -> int {\n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"freebsd\"))]\n+    fn errno_location() -> *const c_int {\n+        extern {\n+            fn __error() -> *const c_int;\n+        }\n+        unsafe {\n+            __error()\n+        }\n+    }\n+\n+    #[cfg(target_os = \"dragonfly\")]\n+    fn errno_location() -> *const c_int {\n+        extern {\n+            fn __dfly_error() -> *const c_int;\n+        }\n+        unsafe {\n+            __dfly_error()\n+        }\n+    }\n+\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    fn errno_location() -> *const c_int {\n+        extern {\n+            fn __errno_location() -> *const c_int;\n+        }\n+        unsafe {\n+            __errno_location()\n+        }\n+    }\n+\n+    unsafe {\n+        (*errno_location()) as int\n+    }\n+}\n+\n+/// Get a detailed string description for the given error number\n+pub fn error_string(errno: i32) -> String {\n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"android\",\n+              target_os = \"freebsd\",\n+              target_os = \"dragonfly\"))]\n+    fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)\n+                  -> c_int {\n+        extern {\n+            fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                          buflen: libc::size_t) -> c_int;\n+        }\n+        unsafe {\n+            strerror_r(errnum, buf, buflen)\n+        }\n+    }\n+\n+    // GNU libc provides a non-compliant version of strerror_r by default\n+    // and requires macros to instead use the POSIX compliant variant.\n+    // So we just use __xpg_strerror_r which is always POSIX compliant\n+    #[cfg(target_os = \"linux\")]\n+    fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                  buflen: libc::size_t) -> c_int {\n+        extern {\n+            fn __xpg_strerror_r(errnum: c_int,\n+                                buf: *mut c_char,\n+                                buflen: libc::size_t)\n+                                -> c_int;\n+        }\n+        unsafe {\n+            __xpg_strerror_r(errnum, buf, buflen)\n+        }\n+    }\n+\n+    let mut buf = [0 as c_char, ..TMPBUF_SZ];\n+\n+    let p = buf.as_mut_ptr();\n+    unsafe {\n+        if strerror_r(errno as c_int, p, buf.len() as libc::size_t) < 0 {\n+            panic!(\"strerror_r failure\");\n+        }\n+\n+        ::string::raw::from_buf(p as *const u8)\n+    }\n+}"}, {"sha": "b8e9b1dca3abc7e11b45795135c9033725a4d9a4", "filename": "src/libstd/sys/windows/c.rs", "status": "renamed", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "patch": "@@ -11,8 +11,11 @@\n //! C definitions used by libnative that don't belong in liblibc\n \n #![allow(overflowing_literals)]\n+#![allow(dead_code)]\n+#![allow(non_camel_case_types)]\n \n use libc;\n+use prelude::*;\n \n pub const WSADESCRIPTION_LEN: uint = 256;\n pub const WSASYS_STATUS_LEN: uint = 128;\n@@ -127,9 +130,10 @@ extern \"system\" {\n }\n \n pub mod compat {\n-    use std::intrinsics::{atomic_store_relaxed, transmute};\n-    use std::iter::Iterator;\n+    use intrinsics::{atomic_store_relaxed, transmute};\n+    use iter::Iterator;\n     use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n+    use prelude::*;\n \n     extern \"system\" {\n         fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n@@ -174,17 +178,17 @@ pub mod compat {\n \n                 extern \"system\" fn thunk($($argname: $argtype),*) -> $rettype {\n                     unsafe {\n-                        ::io::c::compat::store_func(&mut ptr as *mut _ as *mut uint,\n+                        ::sys::c::compat::store_func(&mut ptr as *mut _ as *mut uint,\n                                                     stringify!($module),\n                                                     stringify!($symbol),\n                                                     fallback as uint);\n-                        ::std::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+                        ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n                     }\n                 }\n \n                 extern \"system\" fn fallback($($argname: $argtype),*) -> $rettype $fallback\n \n-                ::std::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+                ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n             }\n         );\n ", "previous_filename": "src/libnative/io/c_windows.rs"}, {"sha": "5f4129c14842a1dd7e5ce866c9f059afb040c10e", "filename": "src/libstd/sys/windows/mod.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_doc)]\n+#![allow(non_camel_case_types)]\n+#![allow(non_snake_case)]\n+#![allow(unused_imports)]\n+#![allow(dead_code)]\n+#![allow(unused_unsafe)]\n+#![allow(unused_mut)]\n+\n+extern crate libc;\n+\n+use num;\n+use mem;\n+use prelude::*;\n+use io::{mod, IoResult, IoError};\n+use sync::{Once, ONCE_INIT};\n+\n+macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n+    static $name: Helper<$m> = Helper {\n+        lock: ::rt::mutex::NATIVE_MUTEX_INIT,\n+        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n+        signal: ::cell::UnsafeCell { value: 0 },\n+        initialized: ::cell::UnsafeCell { value: false },\n+    };\n+) )\n+\n+pub mod fs;\n+pub mod os;\n+pub mod c;\n+\n+pub type sock_t = libc::SOCKET;\n+pub type wrlen = libc::c_int;\n+pub unsafe fn close_sock(sock: sock_t) { let _ = libc::closesocket(sock); }\n+\n+// windows has zero values as errors\n+fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n+    if ret == 0 {\n+        Err(last_error())\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+pub fn last_error() -> IoError {\n+    let errno = os::errno() as i32;\n+    let mut err = decode_error(errno);\n+    err.detail = Some(os::error_string(errno));\n+    err\n+}\n+\n+pub fn last_net_error() -> IoError {\n+    let errno = unsafe { c::WSAGetLastError() as i32 };\n+    let mut err = decode_error(errno);\n+    err.detail = Some(os::error_string(errno));\n+    err\n+}\n+\n+pub fn last_gai_error(_errno: i32) -> IoError {\n+    last_net_error()\n+}\n+\n+/// Convert an `errno` value into a high-level error variant and description.\n+pub fn decode_error(errno: i32) -> IoError {\n+    let (kind, desc) = match errno {\n+        libc::EOF => (io::EndOfFile, \"end of file\"),\n+        libc::ERROR_NO_DATA => (io::BrokenPipe, \"the pipe is being closed\"),\n+        libc::ERROR_FILE_NOT_FOUND => (io::FileNotFound, \"file not found\"),\n+        libc::ERROR_INVALID_NAME => (io::InvalidInput, \"invalid file name\"),\n+        libc::WSAECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n+        libc::WSAECONNRESET => (io::ConnectionReset, \"connection reset\"),\n+        libc::ERROR_ACCESS_DENIED | libc::WSAEACCES =>\n+            (io::PermissionDenied, \"permission denied\"),\n+        libc::WSAEWOULDBLOCK => {\n+            (io::ResourceUnavailable, \"resource temporarily unavailable\")\n+        }\n+        libc::WSAENOTCONN => (io::NotConnected, \"not connected\"),\n+        libc::WSAECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n+        libc::WSAEADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n+        libc::WSAEADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n+        libc::ERROR_BROKEN_PIPE => (io::EndOfFile, \"the pipe has ended\"),\n+        libc::ERROR_OPERATION_ABORTED =>\n+            (io::TimedOut, \"operation timed out\"),\n+        libc::WSAEINVAL => (io::InvalidInput, \"invalid argument\"),\n+        libc::ERROR_CALL_NOT_IMPLEMENTED =>\n+            (io::IoUnavailable, \"function not implemented\"),\n+        libc::ERROR_INVALID_HANDLE =>\n+            (io::MismatchedFileTypeForOperation,\n+             \"invalid handle provided to function\"),\n+        libc::ERROR_NOTHING_TO_TERMINATE =>\n+            (io::InvalidInput, \"no process to kill\"),\n+\n+        // libuv maps this error code to EISDIR. we do too. if it is found\n+        // to be incorrect, we can add in some more machinery to only\n+        // return this message when ERROR_INVALID_FUNCTION after certain\n+        // Windows calls.\n+        libc::ERROR_INVALID_FUNCTION => (io::InvalidInput,\n+                                         \"illegal operation on a directory\"),\n+\n+        _ => (io::OtherIoError, \"unknown error\")\n+    };\n+    IoError { kind: kind, desc: desc, detail: None }\n+}\n+\n+pub fn decode_error_detailed(errno: i32) -> IoError {\n+    let mut err = decode_error(errno);\n+    err.detail = Some(os::error_string(errno));\n+    err\n+}\n+\n+#[inline]\n+pub fn retry<I> (f: || -> I) -> I { f() } // PR rust-lang/rust/#17020\n+\n+pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n+    libc::timeval {\n+        tv_sec: (ms / 1000) as libc::c_long,\n+        tv_usec: ((ms % 1000) * 1000) as libc::c_long,\n+    }\n+}\n+\n+pub fn wouldblock() -> bool {\n+    let err = os::errno();\n+    err == libc::WSAEWOULDBLOCK as uint\n+}\n+\n+pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n+    let mut set = nb as libc::c_ulong;\n+    if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n+        Err(last_error())\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+// FIXME: call this\n+pub fn init_net() {\n+    unsafe {\n+        static START: Once = ONCE_INIT;\n+\n+        START.doit(|| {\n+            let mut data: c::WSADATA = mem::zeroed();\n+            let ret = c::WSAStartup(0x202, // version 2.2\n+                                    &mut data);\n+            assert_eq!(ret, 0);\n+        });\n+    }\n+}\n+\n+pub fn unimpl() -> IoError {\n+    IoError {\n+        kind: io::IoUnavailable,\n+        desc: \"operation is not implemented\",\n+        detail: None,\n+    }\n+}\n+\n+pub fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> {\n+    match s {\n+        Some(s) => Ok({\n+            let mut s = s.utf16_units().collect::<Vec<u16>>();\n+            s.push(0);\n+            s\n+        }),\n+        None => Err(IoError {\n+            kind: io::InvalidInput,\n+            desc: \"valid unicode input required\",\n+            detail: None\n+        })\n+    }\n+}"}, {"sha": "aaa1aaf6327944a8514840a088003e664715f47c", "filename": "src/libstd/sys/windows/os.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a527f2b3311d5b1c6dd7c72db71c45596e6db49/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=3a527f2b3311d5b1c6dd7c72db71c45596e6db49", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME: move various extern bindings from here into liblibc or\n+// something similar\n+\n+use libc;\n+use libc::{c_int, c_char, c_void};\n+use prelude::*;\n+use io::{IoResult, IoError};\n+use sys::fs::FileDesc;\n+use ptr;\n+\n+use os::TMPBUF_SZ;\n+\n+pub fn errno() -> uint {\n+    use libc::types::os::arch::extra::DWORD;\n+\n+    #[link_name = \"kernel32\"]\n+    extern \"system\" {\n+        fn GetLastError() -> DWORD;\n+    }\n+\n+    unsafe {\n+        GetLastError() as uint\n+    }\n+}\n+\n+/// Get a detailed string description for the given error number\n+pub fn error_string(errnum: i32) -> String {\n+    use libc::types::os::arch::extra::DWORD;\n+    use libc::types::os::arch::extra::LPWSTR;\n+    use libc::types::os::arch::extra::LPVOID;\n+    use libc::types::os::arch::extra::WCHAR;\n+\n+    #[link_name = \"kernel32\"]\n+    extern \"system\" {\n+        fn FormatMessageW(flags: DWORD,\n+                          lpSrc: LPVOID,\n+                          msgId: DWORD,\n+                          langId: DWORD,\n+                          buf: LPWSTR,\n+                          nsize: DWORD,\n+                          args: *const c_void)\n+                          -> DWORD;\n+    }\n+\n+    static FORMAT_MESSAGE_FROM_SYSTEM: DWORD = 0x00001000;\n+    static FORMAT_MESSAGE_IGNORE_INSERTS: DWORD = 0x00000200;\n+\n+    // This value is calculated from the macro\n+    // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)\n+    let langId = 0x0800 as DWORD;\n+\n+    let mut buf = [0 as WCHAR, ..TMPBUF_SZ];\n+\n+    unsafe {\n+        let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n+                                 FORMAT_MESSAGE_IGNORE_INSERTS,\n+                                 ptr::null_mut(),\n+                                 errnum as DWORD,\n+                                 langId,\n+                                 buf.as_mut_ptr(),\n+                                 buf.len() as DWORD,\n+                                 ptr::null());\n+        if res == 0 {\n+            // Sometimes FormatMessageW can fail e.g. system doesn't like langId,\n+            let fm_err = errno();\n+            return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n+        }\n+\n+        let msg = String::from_utf16(::str::truncate_utf16_at_nul(buf));\n+        match msg {\n+            Some(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n+            None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", errnum),\n+        }\n+    }\n+}\n+\n+pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n+    // Windows pipes work subtly differently than unix pipes, and their\n+    // inheritance has to be handled in a different way that I do not\n+    // fully understand. Here we explicitly make the pipe non-inheritable,\n+    // which means to pass it to a subprocess they need to be duplicated\n+    // first, as in std::run.\n+    let mut fds = [0, ..2];\n+    match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n+                     (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n+        0 => {\n+            assert!(fds[0] != -1 && fds[0] != 0);\n+            assert!(fds[1] != -1 && fds[1] != 0);\n+            Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n+        }\n+        _ => Err(IoError::last_error()),\n+    }\n+}"}]}