{"sha": "135c8b9297597732daa938d6afada16d36cc42c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNWM4YjkyOTc1OTc3MzJkYWE5MzhkNmFmYWRhMTZkMzZjYzQyYzM=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-11-24T01:06:23Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-11-24T01:06:23Z"}, "message": "drive-by cleanup in region naming", "tree": {"sha": "bfbf737b64e19fb4a316e9183c9abc2e9361641e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfbf737b64e19fb4a316e9183c9abc2e9361641e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/135c8b9297597732daa938d6afada16d36cc42c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/135c8b9297597732daa938d6afada16d36cc42c3", "html_url": "https://github.com/rust-lang/rust/commit/135c8b9297597732daa938d6afada16d36cc42c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/135c8b9297597732daa938d6afada16d36cc42c3/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c987c5c02498b4e77f5dfae1f6914ffb9268575", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c987c5c02498b4e77f5dfae1f6914ffb9268575", "html_url": "https://github.com/rust-lang/rust/commit/0c987c5c02498b4e77f5dfae1f6914ffb9268575"}], "stats": {"total": 43, "additions": 21, "deletions": 22}, "files": [{"sha": "a8cc0cc044a01ce437bbae0e91ef3ca9f962c544", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/135c8b9297597732daa938d6afada16d36cc42c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/135c8b9297597732daa938d6afada16d36cc42c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=135c8b9297597732daa938d6afada16d36cc42c3", "patch": "@@ -77,17 +77,30 @@ impl RegionErrorNamingCtx {\n         }\n     }\n \n+    /// Get the name of `region` if it has previously been named.\n     crate fn get(&self, region: &RegionVid) -> Option<&RegionName> {\n         self.renctx.get(region)\n     }\n \n+    /// Give `region` the name `name`.\n     crate fn insert(&mut self, region: RegionVid, name: RegionName) {\n         self.renctx.insert(region, name);\n     }\n+\n+    /// Creates a synthetic region named `'N`, where `N` is the next value of the counter. Then,\n+    /// increment the counter.\n+    ///\n+    /// The name is not memoized. A separate call to `insert` should be made later. (Currently,\n+    /// this happens at the end of `give_region_a_name`).\n+    crate fn synthesize_region_name(&mut self) -> Symbol {\n+        let c = self.counter;\n+        self.counter += 1;\n+\n+        Symbol::intern(&format!(\"'{:?}\", c))\n+    }\n }\n \n impl RegionName {\n-    #[allow(dead_code)]\n     crate fn was_named(&self) -> bool {\n         match self.source {\n             RegionNameSource::NamedEarlyBoundRegion(..) |\n@@ -103,12 +116,6 @@ impl RegionName {\n         }\n     }\n \n-    #[allow(dead_code)]\n-    crate fn was_synthesized(&self) -> bool {\n-        !self.was_named()\n-    }\n-\n-    #[allow(dead_code)]\n     crate fn name(&self) -> Symbol {\n         self.name\n     }\n@@ -298,7 +305,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         } else {\n                             bug!(\"Closure is not defined by a closure expr\");\n                         };\n-                        let region_name = self.synthesize_region_name(renctx);\n+                        let region_name = renctx.synthesize_region_name();\n \n                         let closure_kind_ty = substs.as_closure().kind_ty(def_id, tcx);\n                         let note = match closure_kind_ty.to_opt_closure_kind() {\n@@ -478,7 +485,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // This counter value will already have been used, so this function will increment\n                 // it so the next value will be used next and return the region name that would\n                 // have been used.\n-                name: self.synthesize_region_name(renctx),\n+                name: renctx.synthesize_region_name(),\n                 source: RegionNameSource::CannotMatchHirTy(span, type_name),\n             })\n         } else {\n@@ -533,7 +540,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n                 ) => {\n                     if region.to_region_vid() == needle_fr {\n-                        let region_name = self.synthesize_region_name(renctx);\n+                        let region_name = renctx.synthesize_region_name();\n \n                         // Just grab the first character, the `&`.\n                         let source_map = tcx.sess.source_map();\n@@ -621,7 +628,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static\n             | hir::LifetimeName::Underscore => {\n-                let region_name = self.synthesize_region_name(renctx);\n+                let region_name = renctx.synthesize_region_name();\n                 let ampersand_span = lifetime.span;\n                 Some(RegionName {\n                     name: region_name,\n@@ -713,7 +720,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n         let (upvar_name, upvar_span) =\n             self.get_upvar_name_and_span_for_region(tcx, upvars, upvar_index);\n-        let region_name = self.synthesize_region_name(renctx);\n+        let region_name = renctx.synthesize_region_name();\n \n         Some(RegionName {\n             name: region_name,\n@@ -776,7 +783,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // This counter value will already have been used, so this function will increment it\n             // so the next value will be used next and return the region name that would have been\n             // used.\n-            name: self.synthesize_region_name(renctx),\n+            name: renctx.synthesize_region_name(),\n             source: RegionNameSource::AnonRegionFromOutput(\n                 return_span,\n                 mir_description.to_string(),\n@@ -831,16 +838,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         Some(RegionName {\n-            name: self.synthesize_region_name(renctx),\n+            name: renctx.synthesize_region_name(),\n             source: RegionNameSource::AnonRegionFromYieldTy(yield_span, type_name),\n         })\n     }\n-\n-    /// Creates a synthetic region named `'1`, incrementing the counter.\n-    fn synthesize_region_name(&self, renctx: &mut RegionErrorNamingCtx) -> Symbol {\n-        let c = renctx.counter;\n-        renctx.counter += 1;\n-\n-        Symbol::intern(&format!(\"'{:?}\", c))\n-    }\n }"}]}