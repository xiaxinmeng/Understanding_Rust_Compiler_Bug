{"sha": "d51db24132fedaa5a3a0d8f97be27a0013123ce6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MWRiMjQxMzJmZWRhYTVhM2EwZDhmOTdiZTI3YTAwMTMxMjNjZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-07T08:40:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-07T08:40:41Z"}, "message": "Auto merge of #6660 - camsteffen:path-to-local, r=llogiq\n\nCleanup path-to-local checks\n\nchangelog: none\n\nIt seemed like too much ceremony going on to check if an expression matches a variable. So I created two util functions `path_to_local(Expr) -> Option<HirId>` and `path_to_local_id(Expr, HirId) -> bool` to make this easier, and used them wherever applicable.\n\nI changed logic in a few places to use `HirId` instead of `Symbol` where it was easy to do so. I believe this is more correct and may even fix some bugs.\n\nI also removed some calls to `qpath_res`. This is not needed if you are only looking for a `Res::Local`.\n\nAs a note, I wanted to name the util functions in a way that encourages understanding of the HIR.", "tree": {"sha": "62275fd8caede0bea5fb0bed4e114e7d5b0d0536", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62275fd8caede0bea5fb0bed4e114e7d5b0d0536"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d51db24132fedaa5a3a0d8f97be27a0013123ce6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d51db24132fedaa5a3a0d8f97be27a0013123ce6", "html_url": "https://github.com/rust-lang/rust/commit/d51db24132fedaa5a3a0d8f97be27a0013123ce6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d51db24132fedaa5a3a0d8f97be27a0013123ce6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b36d1a47274fb865deff3e7ade36a4c0e65c2d77", "url": "https://api.github.com/repos/rust-lang/rust/commits/b36d1a47274fb865deff3e7ade36a4c0e65c2d77", "html_url": "https://github.com/rust-lang/rust/commit/b36d1a47274fb865deff3e7ade36a4c0e65c2d77"}, {"sha": "56f7fbb4ae67041fc1d2474da7fe52f5a2fd25a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/56f7fbb4ae67041fc1d2474da7fe52f5a2fd25a8", "html_url": "https://github.com/rust-lang/rust/commit/56f7fbb4ae67041fc1d2474da7fe52f5a2fd25a8"}], "stats": {"total": 481, "additions": 180, "deletions": 301}, "files": [{"sha": "834f294283e37d8eb6afb0ec4fcdd604b5bb2c8b", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,10 +1,10 @@\n use crate::utils::visitors::LocalUsedVisitor;\n-use crate::utils::{span_lint_and_then, SpanlessEq};\n+use crate::utils::{path_to_local, span_lint_and_then, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, QPath, StmtKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{DefIdTree, TyCtxt};\n+use rustc_middle::ty::{DefIdTree, TyCtxt, TypeckResults};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n \n@@ -72,7 +72,7 @@ fn check_arm(arm: &Arm<'_>, wild_outer_arm: &Arm<'_>, cx: &LateContext<'_>) {\n         if arms_inner.iter().all(|arm| arm.guard.is_none());\n         // match expression must be a local binding\n         // match <local> { .. }\n-        if let Some(binding_id) = addr_adjusted_binding(expr_in, cx);\n+        if let Some(binding_id) = path_to_local(strip_ref_operators(expr_in, cx.typeck_results()));\n         // one of the branches must be \"wild-like\"\n         if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(arm_inner, cx.tcx));\n         let (wild_inner_arm, non_wild_inner_arm) =\n@@ -175,19 +175,15 @@ fn is_none_ctor(res: Res, tcx: TyCtxt<'_>) -> bool {\n     false\n }\n \n-/// Retrieves a binding ID with optional `&` and/or `*` operators removed. (e.g. `&**foo`)\n-/// Returns `None` if a non-reference type is de-referenced.\n-/// For example, if `Vec` is de-referenced to a slice, `None` is returned.\n-fn addr_adjusted_binding(mut expr: &Expr<'_>, cx: &LateContext<'_>) -> Option<HirId> {\n+/// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n+/// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n+fn strip_ref_operators<'hir>(mut expr: &'hir Expr<'hir>, typeck_results: &TypeckResults<'_>) -> &'hir Expr<'hir> {\n     loop {\n         match expr.kind {\n             ExprKind::AddrOf(_, _, e) => expr = e,\n-            ExprKind::Path(QPath::Resolved(None, path)) => match path.res {\n-                Res::Local(binding_id) => break Some(binding_id),\n-                _ => break None,\n-            },\n-            ExprKind::Unary(UnOp::UnDeref, e) if cx.typeck_results().expr_ty(e).is_ref() => expr = e,\n-            _ => break None,\n+            ExprKind::Unary(UnOp::UnDeref, e) if typeck_results.expr_ty(e).is_ref() => expr = e,\n+            _ => break,\n         }\n     }\n+    expr\n }"}, {"sha": "83cee11c3a85921d8615326974d4254f2901dfd5", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 23, "deletions": 37, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,7 +1,6 @@\n-use crate::utils::{get_parent_expr, span_lint, span_lint_and_note};\n-use if_chain::if_chain;\n+use crate::utils::{get_parent_expr, path_to_local, path_to_local_id, span_lint, span_lint_and_note};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{def, BinOpKind, Block, Expr, ExprKind, Guard, HirId, Local, Node, QPath, Stmt, StmtKind};\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, Guard, HirId, Local, Node, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n@@ -72,20 +71,14 @@ impl<'tcx> LateLintPass<'tcx> for EvalOrderDependence {\n         // Find a write to a local variable.\n         match expr.kind {\n             ExprKind::Assign(ref lhs, ..) | ExprKind::AssignOp(_, ref lhs, _) => {\n-                if let ExprKind::Path(ref qpath) = lhs.kind {\n-                    if let QPath::Resolved(_, ref path) = *qpath {\n-                        if path.segments.len() == 1 {\n-                            if let def::Res::Local(var) = cx.qpath_res(qpath, lhs.hir_id) {\n-                                let mut visitor = ReadVisitor {\n-                                    cx,\n-                                    var,\n-                                    write_expr: expr,\n-                                    last_expr: expr,\n-                                };\n-                                check_for_unsequenced_reads(&mut visitor);\n-                            }\n-                        }\n-                    }\n+                if let Some(var) = path_to_local(lhs) {\n+                    let mut visitor = ReadVisitor {\n+                        cx,\n+                        var,\n+                        write_expr: expr,\n+                        last_expr: expr,\n+                    };\n+                    check_for_unsequenced_reads(&mut visitor);\n                 }\n             },\n             _ => {},\n@@ -304,27 +297,20 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        match expr.kind {\n-            ExprKind::Path(ref qpath) => {\n-                if_chain! {\n-                    if let QPath::Resolved(None, ref path) = *qpath;\n-                    if path.segments.len() == 1;\n-                    if let def::Res::Local(local_id) = self.cx.qpath_res(qpath, expr.hir_id);\n-                    if local_id == self.var;\n-                    // Check that this is a read, not a write.\n-                    if !is_in_assignment_position(self.cx, expr);\n-                    then {\n-                        span_lint_and_note(\n-                            self.cx,\n-                            EVAL_ORDER_DEPENDENCE,\n-                            expr.span,\n-                            \"unsequenced read of a variable\",\n-                            Some(self.write_expr.span),\n-                            \"whether read occurs before this write depends on evaluation order\"\n-                        );\n-                    }\n-                }\n+        if path_to_local_id(expr, self.var) {\n+            // Check that this is a read, not a write.\n+            if !is_in_assignment_position(self.cx, expr) {\n+                span_lint_and_note(\n+                    self.cx,\n+                    EVAL_ORDER_DEPENDENCE,\n+                    expr.span,\n+                    \"unsequenced read of a variable\",\n+                    Some(self.write_expr.span),\n+                    \"whether read occurs before this write depends on evaluation order\",\n+                );\n             }\n+        }\n+        match expr.kind {\n             // We're about to descend a closure. Since we don't know when (or\n             // if) the closure will be evaluated, any reads in it might not\n             // occur here (or ever). Like above, bail to avoid false positives."}, {"sha": "8344d97472890c0521345eeb5dcc260aa27c8c9b", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,15 +1,15 @@\n use crate::utils::{\n     attr_by_name, attrs::is_proc_macro, is_must_use_ty, is_trait_impl_item, is_type_diagnostic_item, iter_input_pats,\n-    last_path_segment, match_def_path, must_use_attr, return_ty, snippet, snippet_opt, span_lint, span_lint_and_help,\n-    span_lint_and_then, trait_ref_of_method, type_is_unsafe_function,\n+    last_path_segment, match_def_path, must_use_attr, path_to_local, return_ty, snippet, snippet_opt, span_lint,\n+    span_lint_and_help, span_lint_and_then, trait_ref_of_method, type_is_unsafe_function,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit;\n-use rustc_hir::{def::Res, def_id::DefId};\n+use rustc_hir::{def::Res, def_id::DefId, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n@@ -658,16 +658,14 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr<'_>) {\n-        if let hir::ExprKind::Path(ref qpath) = ptr.kind {\n-            if let Res::Local(id) = self.cx.qpath_res(qpath, ptr.hir_id) {\n-                if self.ptrs.contains(&id) {\n-                    span_lint(\n-                        self.cx,\n-                        NOT_UNSAFE_PTR_ARG_DEREF,\n-                        ptr.span,\n-                        \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n-                    );\n-                }\n+        if let Some(id) = path_to_local(ptr) {\n+            if self.ptrs.contains(&id) {\n+                span_lint(\n+                    self.cx,\n+                    NOT_UNSAFE_PTR_ARG_DEREF,\n+                    ptr.span,\n+                    \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n+                );\n             }\n         }\n     }\n@@ -698,7 +696,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n                             arg.span,\n                             &mut tys,\n                         )\n-                        && is_mutated_static(self.cx, arg)\n+                        && is_mutated_static(arg)\n                     {\n                         self.mutates_static = true;\n                         return;\n@@ -707,7 +705,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n                 }\n             },\n             Assign(ref target, ..) | AssignOp(_, ref target, _) | AddrOf(_, hir::Mutability::Mut, ref target) => {\n-                self.mutates_static |= is_mutated_static(self.cx, target)\n+                self.mutates_static |= is_mutated_static(target)\n             },\n             _ => {},\n         }\n@@ -718,12 +716,13 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n     }\n }\n \n-fn is_mutated_static(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> bool {\n+fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n     use hir::ExprKind::{Field, Index, Path};\n \n     match e.kind {\n-        Path(ref qpath) => !matches!(cx.qpath_res(qpath, e.hir_id), Res::Local(_)),\n-        Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(cx, inner),\n+        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n+        Path(_) => true,\n+        Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(inner),\n         _ => false,\n     }\n }"}, {"sha": "6beaa51729a0217142cccc0d6fbc4b852ff5bd1b", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,8 +1,7 @@\n-use crate::utils::{snippet, span_lint_and_then, visitors::LocalUsedVisitor};\n+use crate::utils::{path_to_local_id, snippet, span_lint_and_then, visitors::LocalUsedVisitor};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n use rustc_hir::BindingAnnotation;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -66,7 +65,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 if let hir::ExprKind::If(ref cond, ref then, ref else_) = if_.kind;\n                 if !LocalUsedVisitor::new(canonical_id).check_expr(cond);\n                 if let hir::ExprKind::Block(ref then, _) = then.kind;\n-                if let Some(value) = check_assign(cx, canonical_id, &*then);\n+                if let Some(value) = check_assign(canonical_id, &*then);\n                 if !LocalUsedVisitor::new(canonical_id).check_expr(value);\n                 then {\n                     let span = stmt.span.to(if_.span);\n@@ -79,7 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n \n                     let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n                         if let hir::ExprKind::Block(ref else_, _) = else_.kind {\n-                            if let Some(default) = check_assign(cx, canonical_id, else_) {\n+                            if let Some(default) = check_assign(canonical_id, else_) {\n                                 (else_.stmts.len() > 1, default)\n                             } else if let Some(ref default) = local.init {\n                                 (true, &**default)\n@@ -134,19 +133,13 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n     }\n }\n \n-fn check_assign<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    decl: hir::HirId,\n-    block: &'tcx hir::Block<'_>,\n-) -> Option<&'tcx hir::Expr<'tcx>> {\n+fn check_assign<'tcx>(decl: hir::HirId, block: &'tcx hir::Block<'_>) -> Option<&'tcx hir::Expr<'tcx>> {\n     if_chain! {\n         if block.expr.is_none();\n         if let Some(expr) = block.stmts.iter().last();\n         if let hir::StmtKind::Semi(ref expr) = expr.kind;\n         if let hir::ExprKind::Assign(ref var, ref value, _) = expr.kind;\n-        if let hir::ExprKind::Path(ref qpath) = var.kind;\n-        if let Res::Local(local_id) = cx.qpath_res(qpath, var.hir_id);\n-        if decl == local_id;\n+        if path_to_local_id(var, decl);\n         then {\n             let mut v = LocalUsedVisitor::new(decl);\n "}, {"sha": "d202072e920dc3bef3ad39760f72d146c50f39eb", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 57, "deletions": 111, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,14 +1,13 @@\n use crate::consts::constant;\n-use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n-use crate::utils::usage::{is_unused, mutated_variables};\n+use crate::utils::usage::mutated_variables;\n use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n     indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_ok_ctor, is_refutable, is_some_ctor,\n-    is_type_diagnostic_item, last_path_segment, match_trait_method, match_type, match_var, multispan_sugg,\n-    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n+    is_type_diagnostic_item, last_path_segment, match_trait_method, match_type, multispan_sugg, path_to_local,\n+    path_to_local_id, paths, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n+    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -877,21 +876,6 @@ fn get_span_of_entire_for_loop(expr: &Expr<'_>) -> Span {\n     }\n }\n \n-fn same_var<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n-    if_chain! {\n-        if let ExprKind::Path(qpath) = &expr.kind;\n-        if let QPath::Resolved(None, path) = qpath;\n-        if path.segments.len() == 1;\n-        if let Res::Local(local_id) = cx.qpath_res(qpath, expr.hir_id);\n-        then {\n-            // our variable!\n-            local_id == var\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n /// a wrapper of `Sugg`. Besides what `Sugg` do, this removes unnecessary `0`;\n /// and also, it avoids subtracting a variable from the same one by replacing it with `0`.\n /// it exists for the convenience of the overloaded operators while normal functions can do the\n@@ -1044,14 +1028,9 @@ fn get_details_from_idx<'tcx>(\n     idx: &Expr<'_>,\n     starts: &[Start<'tcx>],\n ) -> Option<(StartKind<'tcx>, Offset)> {\n-    fn get_start<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<StartKind<'tcx>> {\n-        starts.iter().find_map(|start| {\n-            if same_var(cx, e, start.id) {\n-                Some(start.kind)\n-            } else {\n-                None\n-            }\n-        })\n+    fn get_start<'tcx>(e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<StartKind<'tcx>> {\n+        let id = path_to_local(e)?;\n+        starts.iter().find(|start| start.id == id).map(|start| start.kind)\n     }\n \n     fn get_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<Sugg<'static>> {\n@@ -1060,26 +1039,26 @@ fn get_details_from_idx<'tcx>(\n                 ast::LitKind::Int(x, _ty) => Some(Sugg::NonParen(x.to_string().into())),\n                 _ => None,\n             },\n-            ExprKind::Path(..) if get_start(cx, e, starts).is_none() => Some(Sugg::hir(cx, e, \"???\")),\n+            ExprKind::Path(..) if get_start(e, starts).is_none() => Some(Sugg::hir(cx, e, \"???\")),\n             _ => None,\n         }\n     }\n \n     match idx.kind {\n         ExprKind::Binary(op, lhs, rhs) => match op.node {\n             BinOpKind::Add => {\n-                let offset_opt = get_start(cx, lhs, starts)\n+                let offset_opt = get_start(lhs, starts)\n                     .and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, o)))\n-                    .or_else(|| get_start(cx, rhs, starts).and_then(|s| get_offset(cx, lhs, starts).map(|o| (s, o))));\n+                    .or_else(|| get_start(rhs, starts).and_then(|s| get_offset(cx, lhs, starts).map(|o| (s, o))));\n \n                 offset_opt.map(|(s, o)| (s, Offset::positive(o)))\n             },\n             BinOpKind::Sub => {\n-                get_start(cx, lhs, starts).and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, Offset::negative(o))))\n+                get_start(lhs, starts).and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, Offset::negative(o))))\n             },\n             _ => None,\n         },\n-        ExprKind::Path(..) => get_start(cx, idx, starts).map(|s| (s, Offset::empty())),\n+        ExprKind::Path(..) => get_start(idx, starts).map(|s| (s, Offset::empty())),\n         _ => None,\n     }\n }\n@@ -1096,11 +1075,10 @@ fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx\n /// The returned iterator yields `None` if no assignment expressions are there,\n /// filtering out the increments of the given whitelisted loop counters;\n /// because its job is to make sure there's nothing other than assignments and the increments.\n-fn get_assignments<'a: 'c, 'tcx: 'c, 'c>(\n-    cx: &'a LateContext<'tcx>,\n+fn get_assignments<'a, 'tcx>(\n     Block { stmts, expr, .. }: &'tcx Block<'tcx>,\n-    loop_counters: &'c [Start<'tcx>],\n-) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> + 'c {\n+    loop_counters: &'a [Start<'tcx>],\n+) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> + 'a {\n     // As the `filter` and `map` below do different things, I think putting together\n     // just increases complexity. (cc #3188 and #4193)\n     stmts\n@@ -1112,12 +1090,14 @@ fn get_assignments<'a: 'c, 'tcx: 'c, 'c>(\n         .chain((*expr).into_iter())\n         .filter(move |e| {\n             if let ExprKind::AssignOp(_, place, _) = e.kind {\n-                !loop_counters\n-                    .iter()\n-                    // skip the first item which should be `StartKind::Range`\n-                    // this makes it possible to use the slice with `StartKind::Range` in the same iterator loop.\n-                    .skip(1)\n-                    .any(|counter| same_var(cx, place, counter.id))\n+                path_to_local(place).map_or(false, |id| {\n+                    !loop_counters\n+                        .iter()\n+                        // skip the first item which should be `StartKind::Range`\n+                        // this makes it possible to use the slice with `StartKind::Range` in the same iterator loop.\n+                        .skip(1)\n+                        .any(|counter| counter.id == id)\n+                })\n             } else {\n                 true\n             }\n@@ -1174,7 +1154,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n             if method.ident.name == sym!(len);\n             if len_args.len() == 1;\n             if let Some(arg) = len_args.get(0);\n-            if var_def_id(cx, arg) == var_def_id(cx, base);\n+            if path_to_local(arg) == path_to_local(base);\n             then {\n                 if sugg.as_str() == end_str {\n                     sugg::EMPTY.into()\n@@ -1279,7 +1259,7 @@ fn detect_manual_memcpy<'tcx>(\n                 if let Some(loop_counters) = get_loop_counters(cx, block, expr) {\n                     starts.extend(loop_counters);\n                 }\n-                iter_a = Some(get_assignments(cx, block, &starts));\n+                iter_a = Some(get_assignments(block, &starts));\n             } else {\n                 iter_b = Some(get_assignment(body));\n             }\n@@ -1301,7 +1281,7 @@ fn detect_manual_memcpy<'tcx>(\n                             if let Some((start_right, offset_right)) = get_details_from_idx(cx, &idx_right, &starts);\n \n                             // Source and destination must be different\n-                            if var_def_id(cx, base_left) != var_def_id(cx, base_right);\n+                            if path_to_local(base_left) != path_to_local(base_right);\n                             then {\n                                 Some((IndexExpr { base: base_left, idx: start_left, idx_offset: offset_left },\n                                     IndexExpr { base: base_right, idx: start_right, idx_offset: offset_right }))\n@@ -2018,9 +1998,7 @@ fn check_manual_flatten<'tcx>(\n             ) = inner_expr.kind;\n             // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n             if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n-            if let ExprKind::Path(QPath::Resolved(None, match_expr_path)) = match_expr.kind;\n-            if let Res::Local(match_expr_path_id) = match_expr_path.res;\n-            if pat_hir_id == match_expr_path_id;\n+            if path_to_local_id(match_expr, pat_hir_id);\n             // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n             if let PatKind::TupleStruct(QPath::Resolved(None, path), _, _) = match_arms[0].pat.kind;\n             let some_ctor = is_some_ctor(cx, path.res);\n@@ -2131,20 +2109,11 @@ fn mut_warn_with_span(cx: &LateContext<'_>, span: Option<Span>) {\n \n fn check_for_mutability(cx: &LateContext<'_>, bound: &Expr<'_>) -> Option<HirId> {\n     if_chain! {\n-        if let ExprKind::Path(ref qpath) = bound.kind;\n-        if let QPath::Resolved(None, _) = *qpath;\n+        if let Some(hir_id) = path_to_local(bound);\n+        if let Node::Binding(pat) = cx.tcx.hir().get(hir_id);\n+        if let PatKind::Binding(BindingAnnotation::Mutable, ..) = pat.kind;\n         then {\n-            let res = cx.qpath_res(qpath, bound.hir_id);\n-            if let Res::Local(hir_id) = res {\n-                let node_str = cx.tcx.hir().get(hir_id);\n-                if_chain! {\n-                    if let Node::Binding(pat) = node_str;\n-                    if let PatKind::Binding(BindingAnnotation::Mutable, ..) = pat.kind;\n-                    then {\n-                        return Some(hir_id);\n-                    }\n-                }\n-            }\n+            return Some(hir_id);\n         }\n     }\n     None\n@@ -2179,7 +2148,9 @@ fn check_for_mutation<'tcx>(\n fn pat_is_wild<'tcx>(pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Binding(.., ident, None) if ident.as_str().starts_with('_') => is_unused(&ident, body),\n+        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => {\n+            !LocalUsedVisitor::new(id).check_expr(body)\n+        },\n         _ => false,\n     }\n }\n@@ -2215,7 +2186,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n             if let QPath::Resolved(None, ref seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n             then {\n-                let index_used_directly = same_var(self.cx, idx, self.var);\n+                let index_used_directly = path_to_local_id(idx, self.var);\n                 let indexed_indirectly = {\n                     let mut used_visitor = LocalUsedVisitor::new(self.var);\n                     walk_expr(&mut used_visitor, idx);\n@@ -2286,17 +2257,14 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n \n         if_chain! {\n             // directly using a variable\n-            if let ExprKind::Path(ref qpath) = expr.kind;\n-            if let QPath::Resolved(None, ref path) = *qpath;\n-            if path.segments.len() == 1;\n+            if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind;\n+            if let Res::Local(local_id) = path.res;\n             then {\n-                if let Res::Local(local_id) = self.cx.qpath_res(qpath, expr.hir_id) {\n-                    if local_id == self.var {\n-                        self.nonindex = true;\n-                    } else {\n-                        // not the correct variable, but still a variable\n-                        self.referenced.insert(path.segments[0].ident.name);\n-                    }\n+                if local_id == self.var {\n+                    self.nonindex = true;\n+                } else {\n+                    // not the correct variable, but still a variable\n+                    self.referenced.insert(path.segments[0].ident.name);\n                 }\n             }\n         }\n@@ -2354,7 +2322,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n }\n \n fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n-    let def_id = match var_def_id(cx, expr) {\n+    let def_id = match path_to_local(expr) {\n         Some(id) => id,\n         None => return false,\n     };\n@@ -2367,12 +2335,11 @@ fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container:\n }\n \n fn is_iterator_used_after_while_let<'tcx>(cx: &LateContext<'tcx>, iter_expr: &'tcx Expr<'_>) -> bool {\n-    let def_id = match var_def_id(cx, iter_expr) {\n+    let def_id = match path_to_local(iter_expr) {\n         Some(id) => id,\n         None => return false,\n     };\n     let mut visitor = VarUsedAfterLoopVisitor {\n-        cx,\n         def_id,\n         iter_expr_id: iter_expr.hir_id,\n         past_while_let: false,\n@@ -2384,20 +2351,19 @@ fn is_iterator_used_after_while_let<'tcx>(cx: &LateContext<'tcx>, iter_expr: &'t\n     visitor.var_used_after_while_let\n }\n \n-struct VarUsedAfterLoopVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n+struct VarUsedAfterLoopVisitor {\n     def_id: HirId,\n     iter_expr_id: HirId,\n     past_while_let: bool,\n     var_used_after_while_let: bool,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if self.past_while_let {\n-            if Some(self.def_id) == var_def_id(self.cx, expr) {\n+            if path_to_local_id(expr, self.def_id) {\n                 self.var_used_after_while_let = true;\n             }\n         } else if self.iter_expr_id == expr.hir_id {\n@@ -2519,7 +2485,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n         }\n \n         // If node is a variable\n-        if let Some(def_id) = var_def_id(self.cx, expr) {\n+        if let Some(def_id) = path_to_local(expr) {\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n                 let state = self.states.entry(def_id).or_insert(IncrementVisitorVarState::Initial);\n                 if *state == IncrementVisitorVarState::IncrOnce {\n@@ -2646,7 +2612,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         }\n \n         // If node is the desired variable, see how it's used\n-        if var_def_id(self.cx, expr) == Some(self.var_id) {\n+        if path_to_local_id(expr, self.var_id) {\n             if self.past_loop {\n                 self.state = InitializeVisitorState::DontWarn;\n                 return;\n@@ -2693,16 +2659,6 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     }\n }\n \n-fn var_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<HirId> {\n-    if let ExprKind::Path(ref qpath) = expr.kind {\n-        let path_res = cx.qpath_res(qpath, expr.hir_id);\n-        if let Res::Local(hir_id) = path_res {\n-            return Some(hir_id);\n-        }\n-    }\n-    None\n-}\n-\n fn is_loop(expr: &Expr<'_>) -> bool {\n     matches!(expr.kind, ExprKind::Loop(..))\n }\n@@ -2725,8 +2681,8 @@ fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>)\n \n fn is_loop_nested(cx: &LateContext<'_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n     let mut id = loop_expr.hir_id;\n-    let iter_name = if let Some(name) = path_name(iter_expr) {\n-        name\n+    let iter_id = if let Some(id) = path_to_local(iter_expr) {\n+        id\n     } else {\n         return true;\n     };\n@@ -2744,7 +2700,7 @@ fn is_loop_nested(cx: &LateContext<'_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'\n             Some(Node::Block(block)) => {\n                 let mut block_visitor = LoopNestVisitor {\n                     hir_id: id,\n-                    iterator: iter_name,\n+                    iterator: iter_id,\n                     nesting: Unknown,\n                 };\n                 walk_block(&mut block_visitor, block);\n@@ -2772,7 +2728,7 @@ use self::Nesting::{LookFurther, RuledOut, Unknown};\n \n struct LoopNestVisitor {\n     hir_id: HirId,\n-    iterator: Symbol,\n+    iterator: HirId,\n     nesting: Nesting,\n }\n \n@@ -2797,7 +2753,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n         }\n         match expr.kind {\n             ExprKind::Assign(ref path, _, _) | ExprKind::AssignOp(_, ref path, _) => {\n-                if match_var(path, self.iterator) {\n+                if path_to_local_id(path, self.iterator) {\n                     self.nesting = RuledOut;\n                 }\n             },\n@@ -2809,8 +2765,8 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n         if self.nesting != Unknown {\n             return;\n         }\n-        if let PatKind::Binding(.., span_name, _) = pat.kind {\n-            if self.iterator == span_name.name {\n+        if let PatKind::Binding(_, id, ..) = pat.kind {\n+            if id == self.iterator {\n                 self.nesting = RuledOut;\n                 return;\n             }\n@@ -2823,16 +2779,6 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n     }\n }\n \n-fn path_name(e: &Expr<'_>) -> Option<Symbol> {\n-    if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.kind {\n-        let segments = &path.segments;\n-        if segments.len() == 1 {\n-            return Some(segments[0].ident.name);\n-        }\n-    };\n-    None\n-}\n-\n fn check_infinite_loop<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n     if constant(cx, cx.typeck_results(), cond).is_some() {\n         // A pure constant condition (e.g., `while false`) is not linted.\n@@ -3194,7 +3140,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if same_var(self.cx, expr, self.id) {\n+        if path_to_local_id(expr, self.id) {\n             self.count += 1;\n         } else {\n             walk_expr(self, expr);"}, {"sha": "efb05b8ffdf4f4a7a49cd752b197bda51e281159", "filename": "clippy_lints/src/manual_ok_or.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_ok_or.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,9 +1,10 @@\n use crate::utils::{\n-    indent_of, is_type_diagnostic_item, match_qpath, paths, reindent_multiline, snippet_opt, span_lint_and_sugg,\n+    indent_of, is_type_diagnostic_item, match_qpath, path_to_local_id, paths, reindent_multiline, snippet_opt,\n+    span_lint_and_sugg,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{def, Expr, ExprKind, PatKind, QPath};\n+use rustc_hir::{Expr, ExprKind, PatKind};\n use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -90,8 +91,6 @@ fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n         if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n         if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, &[ref ok_arg]) = body.value.kind;\n         if match_qpath(ok_path, &paths::RESULT_OK);\n-        if let ExprKind::Path(QPath::Resolved(_, ok_arg_path)) = ok_arg.kind;\n-        if let def::Res::Local(ok_arg_path_id) = ok_arg_path.res;\n-        then { param_id == ok_arg_path_id } else { false }\n+        then { path_to_local_id(ok_arg, param_id) } else { false }\n     }\n }"}, {"sha": "b452225b5db6cc53864220b08d24beba9cea14a4", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,9 +1,9 @@\n use crate::consts::constant_simple;\n use crate::utils;\n-use crate::utils::sugg;\n+use crate::utils::{path_to_local_id, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{def, Arm, Expr, ExprKind, Pat, PatKind, QPath};\n+use rustc_hir::{Arm, Expr, ExprKind, Pat, PatKind};\n use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -83,9 +83,7 @@ fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n             if utils::match_qpath(unwrap_qpath, &utils::paths::OPTION_SOME)\n                 || utils::match_qpath(unwrap_qpath, &utils::paths::RESULT_OK);\n             if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, body_path)) = unwrap_arm.body.kind;\n-            if let def::Res::Local(body_path_hir_id) = body_path.res;\n-            if body_path_hir_id == binding_hir_id;\n+            if path_to_local_id(unwrap_arm.body, binding_hir_id);\n             if !utils::usage::contains_return_break_continue_macro(or_arm.body);\n             then {\n                 Some(or_arm)"}, {"sha": "c4aa2b30e7b52a6bd724a0f9859e9c3e15a6b4a8", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,11 +1,12 @@\n use crate::consts::{constant, miri_to_const, Constant};\n use crate::utils::sugg::Sugg;\n-use crate::utils::usage::is_unused;\n+use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n-    expr_block, get_arg_name, get_parent_expr, implements_trait, in_macro, indent_of, is_allowed, is_expn_of,\n-    is_refutable, is_type_diagnostic_item, is_wild, match_qpath, match_type, match_var, meets_msrv, multispan_sugg,\n+    expr_block, get_parent_expr, implements_trait, in_macro, indent_of, is_allowed, is_expn_of, is_refutable,\n+    is_type_diagnostic_item, is_wild, match_qpath, match_type, meets_msrv, multispan_sugg, path_to_local_id,\n     peel_hir_pat_refs, peel_mid_ty_refs, peel_n_hir_expr_refs, remove_blocks, snippet, snippet_block, snippet_opt,\n     snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n+    strip_pat_refs,\n };\n use crate::utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n@@ -616,9 +617,9 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             if let PatKind::TupleStruct(\n                 QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pat.kind;\n             if args.len() == 1;\n-            if let Some(arg) = get_arg_name(&args[0]);\n+            if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n             let body = remove_blocks(&arms[0].body);\n-            if match_var(body, arg);\n+            if path_to_local_id(body, arg);\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n@@ -922,8 +923,8 @@ fn check_wild_err_arm(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n                     if !matching_wild {\n                         // Looking for unused bindings (i.e.: `_e`)\n                         inner.iter().for_each(|pat| {\n-                            if let PatKind::Binding(.., ident, None) = &pat.kind {\n-                                if ident.as_str().starts_with('_') && is_unused(ident, arm.body) {\n+                            if let PatKind::Binding(_, id, ident, None) = pat.kind {\n+                                if ident.as_str().starts_with('_') && !LocalUsedVisitor::new(id).check_expr(arm.body) {\n                                     ident_bind_name = (&ident.name.as_str()).to_string();\n                                     matching_wild = true;\n                                 }"}, {"sha": "3dc4cd278e6b2292ad493c94904eb559f3aa6b55", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -15,8 +15,7 @@ use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n-use rustc_hir::{Expr, ExprKind, PatKind, QPath, TraitItem, TraitItemKind, UnOp};\n+use rustc_hir::{Expr, ExprKind, PatKind, TraitItem, TraitItemKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass, Lint, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n@@ -30,12 +29,12 @@ use crate::consts::{constant, Constant};\n use crate::utils::eager_or_lazy::is_lazyness_candidate;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n-    contains_return, contains_ty, get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, higher,\n-    implements_trait, in_macro, is_copy, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment,\n-    match_def_path, match_qpath, match_trait_method, match_type, match_var, meets_msrv, method_calls,\n-    method_chain_args, paths, remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability,\n-    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg,\n-    walk_ptrs_ty_depth, SpanlessEq,\n+    contains_return, contains_ty, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n+    in_macro, is_copy, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path,\n+    match_qpath, match_trait_method, match_type, meets_msrv, method_calls, method_chain_args, path_to_local_id, paths,\n+    remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n+    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, strip_pat_refs, sugg, walk_ptrs_ty_depth,\n+    SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -2396,11 +2395,12 @@ fn lint_unnecessary_fold(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args:\n             if bin_op.node == op;\n \n             // Extract the names of the two arguments to the closure\n-            if let Some(first_arg_ident) = get_arg_name(&closure_body.params[0].pat);\n-            if let Some(second_arg_ident) = get_arg_name(&closure_body.params[1].pat);\n+            if let [param_a, param_b] = closure_body.params;\n+            if let PatKind::Binding(_, first_arg_id, ..) = strip_pat_refs(&param_a.pat).kind;\n+            if let PatKind::Binding(_, second_arg_id, second_arg_ident, _) = strip_pat_refs(&param_b.pat).kind;\n \n-            if match_var(&*left_expr, first_arg_ident);\n-            if replacement_has_args || match_var(&*right_expr, second_arg_ident);\n+            if path_to_local_id(left_expr, first_arg_id);\n+            if replacement_has_args || path_to_local_id(right_expr, second_arg_id);\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n@@ -3068,10 +3068,8 @@ fn lint_filter_map<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_f\n             };\n             // let the filter closure arg and the map closure arg be equal\n             if_chain! {\n-                if let ExprKind::Path(QPath::Resolved(None, a_path)) = a_path.kind;\n-                if let ExprKind::Path(QPath::Resolved(None, b_path)) = b.kind;\n-                if a_path.res == Res::Local(filter_param_id);\n-                if b_path.res == Res::Local(map_param_id);\n+                if path_to_local_id(a_path, filter_param_id);\n+                if path_to_local_id(b, map_param_id);\n                 if TyS::same_type(cx.typeck_results().expr_ty_adjusted(a), cx.typeck_results().expr_ty_adjusted(b));\n                 then {\n                     return true;\n@@ -3255,8 +3253,9 @@ fn lint_search_is_some<'tcx>(\n                 then {\n                     if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n                         Some(search_snippet.replacen('&', \"\", 1))\n-                    } else if let Some(name) = get_arg_name(&closure_arg.pat) {\n-                        Some(search_snippet.replace(&format!(\"*{}\", name), &name.as_str()))\n+                    } else if let PatKind::Binding(_, _, ident, _) = strip_pat_refs(&closure_arg.pat).kind {\n+                        let name = &*ident.name.as_str();\n+                        Some(search_snippet.replace(&format!(\"*{}\", name), name))\n                     } else {\n                         None\n                     }\n@@ -3688,9 +3687,7 @@ fn lint_option_as_ref_deref<'tcx>(\n                 hir::ExprKind::MethodCall(_, _, args, _) => {\n                     if_chain! {\n                         if args.len() == 1;\n-                        if let hir::ExprKind::Path(qpath) = &args[0].kind;\n-                        if let hir::def::Res::Local(local_id) = cx.qpath_res(qpath, args[0].hir_id);\n-                        if closure_body.params[0].pat.hir_id == local_id;\n+                        if path_to_local_id(&args[0], closure_body.params[0].pat.hir_id);\n                         let adj = cx\n                             .typeck_results()\n                             .expr_adjustments(&args[0])\n@@ -3710,10 +3707,8 @@ fn lint_option_as_ref_deref<'tcx>(\n                     if_chain! {\n                         if let hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner1) = inner.kind;\n                         if let hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner2) = inner1.kind;\n-                        if let hir::ExprKind::Path(ref qpath) = inner2.kind;\n-                        if let hir::def::Res::Local(local_id) = cx.qpath_res(qpath, inner2.hir_id);\n                         then {\n-                            closure_body.params[0].pat.hir_id == local_id\n+                            path_to_local_id(inner2, closure_body.params[0].pat.hir_id)\n                         } else {\n                             false\n                         }"}, {"sha": "5691fcb88e95ccb59c707fb936cf3904f0c6f628", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,8 +1,6 @@\n-use crate::utils::paths;\n use crate::utils::usage::mutated_variables;\n-use crate::utils::{match_qpath, match_trait_method, span_lint};\n+use crate::utils::{match_qpath, match_trait_method, path_to_local_id, paths, span_lint};\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n@@ -59,14 +57,8 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n                 if let hir::ExprKind::Path(ref path) = func.kind;\n                 then {\n                     if match_qpath(path, &paths::OPTION_SOME) {\n-                        if_chain! {\n-                            if let hir::ExprKind::Path(path) = &args[0].kind;\n-                            if let Res::Local(ref local) = cx.qpath_res(path, args[0].hir_id);\n-                            then {\n-                                if arg_id == *local {\n-                                    return (false, false)\n-                                }\n-                            }\n+                        if path_to_local_id(&args[0], arg_id) {\n+                            return (false, false)\n                         }\n                         return (true, false);\n                     }"}, {"sha": "fdd105e624605fefad209c4262ec0d5983b156ae", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,6 +1,5 @@\n-use crate::utils::{match_def_path, match_trait_method, paths, span_lint};\n+use crate::utils::{match_def_path, match_trait_method, path_to_local_id, paths, span_lint};\n use if_chain::if_chain;\n-use rustc_hir::def::Res;\n use rustc_hir::{Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -89,14 +88,12 @@ impl LateLintPass<'_> for ToStringInDisplay {\n \n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n+            if self.in_display_impl;\n+            if let Some(self_hir_id) = self.self_hir_id;\n             if let ExprKind::MethodCall(ref path, _, args, _) = expr.kind;\n             if path.ident.name == sym!(to_string);\n             if match_trait_method(cx, expr, &paths::TO_STRING);\n-            if self.in_display_impl;\n-            if let ExprKind::Path(ref qpath) = args[0].kind;\n-            if let Res::Local(hir_id) = cx.qpath_res(qpath, args[0].hir_id);\n-            if let Some(self_hir_id) = self.self_hir_id;\n-            if hir_id == self_hir_id;\n+            if path_to_local_id(&args[0], self_hir_id);\n             then {\n                 span_lint(\n                     cx,"}, {"sha": "15a254244c18d091c4e8a8707bc56996677a6207", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -307,6 +307,22 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n         .all(|(a, b)| a.ident.name.as_str() == *b)\n }\n \n+/// If the expression is a path to a local, returns the canonical `HirId` of the local.\n+pub fn path_to_local(expr: &Expr<'_>) -> Option<HirId> {\n+    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n+        if let Res::Local(id) = path.res {\n+            return Some(id);\n+        }\n+    }\n+    None\n+}\n+\n+/// Returns true if the expression is a path to a local with the specified `HirId`.\n+/// Use this function to see if an expression matches a function argument or a match binding.\n+pub fn path_to_local_id(expr: &Expr<'_>, id: HirId) -> bool {\n+    path_to_local(expr) == Some(id)\n+}\n+\n /// Gets the definition associated to a path.\n #[allow(clippy::shadow_unrelated)] // false positive #6563\n pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n@@ -1135,9 +1151,7 @@ pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n             if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.kind;\n             if match_qpath(path, &paths::RESULT_OK[1..]);\n             if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n-            if let ExprKind::Path(QPath::Resolved(None, ref path)) = arm.body.kind;\n-            if let Res::Local(lid) = path.res;\n-            if lid == hir_id;\n+            if path_to_local_id(arm.body, hir_id);\n             then {\n                 return true;\n             }\n@@ -1181,12 +1195,11 @@ pub fn is_allowed(cx: &LateContext<'_>, lint: &'static Lint, id: HirId) -> bool\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n \n-pub fn get_arg_name(pat: &Pat<'_>) -> Option<Symbol> {\n-    match pat.kind {\n-        PatKind::Binding(.., ident, None) => Some(ident.name),\n-        PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n-        _ => None,\n+pub fn strip_pat_refs<'hir>(mut pat: &'hir Pat<'hir>) -> &'hir Pat<'hir> {\n+    while let PatKind::Ref(subpat, _) = pat.kind {\n+        pat = subpat;\n     }\n+    pat\n }\n \n pub fn int_bits(tcx: TyCtxt<'_>, ity: ty::IntTy) -> u64 {"}, {"sha": "7c7580a2c6612992b0aeaa3bd4230ae8f95e80f4", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,16 +1,14 @@\n use crate::utils;\n-use crate::utils::match_var;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::intravisit;\n-use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{Expr, ExprKind, HirId, Path};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n-use rustc_span::symbol::{Ident, Symbol};\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n /// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n@@ -81,36 +79,6 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n     }\n }\n \n-pub struct UsedVisitor {\n-    pub var: Symbol, // var to look for\n-    pub used: bool,  // has the var been used otherwise?\n-}\n-\n-impl<'tcx> Visitor<'tcx> for UsedVisitor {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if match_var(expr, self.var) {\n-            self.used = true;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-pub fn is_unused<'tcx>(ident: &'tcx Ident, body: &'tcx Expr<'_>) -> bool {\n-    let mut visitor = UsedVisitor {\n-        var: ident.name,\n-        used: false,\n-    };\n-    walk_expr(&mut visitor, body);\n-    !visitor.used\n-}\n-\n pub struct ParamBindingIdCollector {\n     binding_hir_ids: Vec<hir::HirId>,\n }"}, {"sha": "a4064c3e705cd1abd320dc31eecee578dae182ef", "filename": "clippy_lints/src/utils/visitors.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51db24132fedaa5a3a0d8f97be27a0013123ce6/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs?ref=d51db24132fedaa5a3a0d8f97be27a0013123ce6", "patch": "@@ -1,7 +1,7 @@\n+use crate::utils::path_to_local_id;\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Arm, Expr, ExprKind, HirId, QPath, Stmt};\n+use rustc_hir::{Arm, Expr, HirId, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n \n@@ -168,15 +168,11 @@ impl<'v> Visitor<'v> for LocalUsedVisitor {\n     type Map = Map<'v>;\n \n     fn visit_expr(&mut self, expr: &'v Expr<'v>) {\n-        if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind {\n-            if let Res::Local(id) = path.res {\n-                if id == self.local_hir_id {\n-                    self.used = true;\n-                    return;\n-                }\n-            }\n+        if path_to_local_id(expr, self.local_hir_id) {\n+            self.used = true;\n+        } else {\n+            walk_expr(self, expr);\n         }\n-        walk_expr(self, expr);\n     }\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}]}