{"sha": "7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYzJjYmY1ZGIzZTIwZTZmOTc0OTRiNzBiMmExZDY1YWMyZTYxZmM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-04-26T15:52:19Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-04-28T03:20:13Z"}, "message": "travis: Parallelize tests on Android\n\nCurrently our slowest test suite on android, run-pass, takes over 5 times longer\nthan the x86_64 component (~400 -> ~2200s). Typically QEMU emulation does indeed\nadd overhead, but not 5x for this kind of workload. One of the slowest parts of\nthe Android process is that *compilation* happens serially. Tests themselves\nneed to run single-threaded on the emulator (due to how the test harness works)\nand this forces the compiles themselves to be single threaded.\n\nNow Travis gives us more than one core per machine, so it'd be much better if we\ncould take advantage of them! The emulator itself is still fundamentally\nsingle-threaded, but we should see a nice speedup by sending binaries for it to\nrun much more quickly.\n\nIt turns out that we've already got all the tools to do this in-tree. The\nqemu-test-{server,client} that are in use for the ARM Linux testing are a\nperfect match for the Android emulator. This commit migrates the custom adb\nmanagement code in compiletest/rustbuild to the same qemu-test-{server,client}\nimplementation that ARM Linux uses.\n\nThis allows us to lift the parallelism restriction on the compiletest test\nsuites, namely run-pass. Consequently although we'll still basically run the\ntests themselves in single threaded mode we'll be able to compile all of them in\nparallel, keeping the pipeline much more full and using more cores for the work\nat hand. Additionally the architecture here should be a bit speedier as it\nshould have less overhead than adb which is a whole new process on both the host\nand the emulator!\n\nLocally on an 8 core machine I've seen the run-pass test suite speed up from\ntaking nearly an hour to only taking 6 minutes. I don't think we'll see quite a\ndrastic speedup on Travis but I'm hoping this change can place the Android tests\nwell below 2 hours instead of just above 2 hours.\n\nBecause the client/server here are now repurposed for more than just QEMU,\nthey've been renamed to `remote-test-{server,client}`.\n\nNote that this PR does not currently modify how debuginfo tests are executed on\nAndroid. While parallelizable it wouldn't be quite as easy, so that's left to\nanother day. Thankfully that test suite is much smaller than the run-pass test\nsuite.\n\nAs a final fix I discovered that the ARM and Android test suites were actually\nrunning all library unit tests (e.g. stdtest, coretest, etc) twice. I've\ncorrected that to only run tests once which should also give a nice boost in\noverall cycle time here.", "tree": {"sha": "e2c2ceae1cb7c87836acebf400dea70644c199f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2c2ceae1cb7c87836acebf400dea70644c199f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "html_url": "https://github.com/rust-lang/rust/commit/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70baf4f13ec70cb17942704849b0f3c047ad347b", "url": "https://api.github.com/repos/rust-lang/rust/commits/70baf4f13ec70cb17942704849b0f3c047ad347b", "html_url": "https://github.com/rust-lang/rust/commit/70baf4f13ec70cb17942704849b0f3c047ad347b"}], "stats": {"total": 710, "additions": 243, "deletions": 467}, "files": [{"sha": "5d97ccaabbf02ee57252f03363d2a8e844cb39b1", "filename": "src/Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -366,14 +366,6 @@ dependencies = [\n  \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"qemu-test-client\"\n-version = \"0.1.0\"\n-\n-[[package]]\n-name = \"qemu-test-server\"\n-version = \"0.1.0\"\n-\n [[package]]\n name = \"quick-error\"\n version = \"1.1.0\"\n@@ -403,6 +395,14 @@ name = \"regex-syntax\"\n version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"remote-test-client\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"remote-test-server\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"rls-data\"\n version = \"0.1.0\""}, {"sha": "8f6150c6438fe058e74cbf5da565e904106e9d26", "filename": "src/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -11,8 +11,8 @@ members = [\n   \"tools/rustbook\",\n   \"tools/tidy\",\n   \"tools/build-manifest\",\n-  \"tools/qemu-test-client\",\n-  \"tools/qemu-test-server\",\n+  \"tools/remote-test-client\",\n+  \"tools/remote-test-server\",\n ]\n \n # Curiously, compiletest will segfault if compiled with opt-level=3 on 64-bit"}, {"sha": "1bcec2cdedec45ce208dbb4bc01baf22f9005b47", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 27, "deletions": 113, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -28,7 +28,7 @@ use {Build, Compiler, Mode};\n use dist;\n use util::{self, dylib_path, dylib_path_var, exe};\n \n-const ADB_TEST_DIR: &'static str = \"/data/tmp\";\n+const ADB_TEST_DIR: &'static str = \"/data/tmp/work\";\n \n /// The two modes of the test runner; tests or benchmarks.\n #[derive(Copy, Clone)]\n@@ -243,10 +243,10 @@ pub fn compiletest(build: &Build,\n            .arg(\"--llvm-cxxflags\").arg(\"\");\n     }\n \n-    if build.qemu_rootfs(target).is_some() {\n-        cmd.arg(\"--qemu-test-client\")\n+    if build.remote_tested(target) {\n+        cmd.arg(\"--remote-test-client\")\n            .arg(build.tool(&Compiler::new(0, &build.config.build),\n-                           \"qemu-test-client\"));\n+                           \"remote-test-client\"));\n     }\n \n     // Running a C compiler on MSVC requires a few env vars to be set, to be\n@@ -445,9 +445,7 @@ pub fn krate(build: &Build,\n     dylib_path.insert(0, build.sysroot_libdir(&compiler, target));\n     cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n-    if target.contains(\"android\") ||\n-       target.contains(\"emscripten\") ||\n-       build.qemu_rootfs(target).is_some() {\n+    if target.contains(\"emscripten\") || build.remote_tested(target) {\n         cargo.arg(\"--no-run\");\n     }\n \n@@ -459,75 +457,24 @@ pub fn krate(build: &Build,\n \n     let _time = util::timeit();\n \n-    if target.contains(\"android\") {\n-        build.run(&mut cargo);\n-        krate_android(build, &compiler, target, mode);\n-    } else if target.contains(\"emscripten\") {\n+    if target.contains(\"emscripten\") {\n         build.run(&mut cargo);\n         krate_emscripten(build, &compiler, target, mode);\n-    } else if build.qemu_rootfs(target).is_some() {\n+    } else if build.remote_tested(target) {\n         build.run(&mut cargo);\n-        krate_qemu(build, &compiler, target, mode);\n+        krate_remote(build, &compiler, target, mode);\n     } else {\n         cargo.args(&build.flags.cmd.test_args());\n         build.run(&mut cargo);\n     }\n }\n \n-fn krate_android(build: &Build,\n-                 compiler: &Compiler,\n-                 target: &str,\n-                 mode: Mode) {\n-    let mut tests = Vec::new();\n-    let out_dir = build.cargo_out(compiler, mode, target);\n-    find_tests(&out_dir, target, &mut tests);\n-    find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n-\n-    for test in tests {\n-        build.run(Command::new(\"adb\").arg(\"push\").arg(&test).arg(ADB_TEST_DIR));\n-\n-        let test_file_name = test.file_name().unwrap().to_string_lossy();\n-        let log = format!(\"{}/check-stage{}-T-{}-H-{}-{}.log\",\n-                          ADB_TEST_DIR,\n-                          compiler.stage,\n-                          target,\n-                          compiler.host,\n-                          test_file_name);\n-        let quiet = if build.config.quiet_tests { \"--quiet\" } else { \"\" };\n-        let program = format!(\"(cd {dir}; \\\n-                                LD_LIBRARY_PATH=./{target} ./{test} \\\n-                                    --logfile {log} \\\n-                                    {quiet} \\\n-                                    {args})\",\n-                              dir = ADB_TEST_DIR,\n-                              target = target,\n-                              test = test_file_name,\n-                              log = log,\n-                              quiet = quiet,\n-                              args = build.flags.cmd.test_args().join(\" \"));\n-\n-        let output = output(Command::new(\"adb\").arg(\"shell\").arg(&program));\n-        println!(\"{}\", output);\n-\n-        t!(fs::create_dir_all(build.out.join(\"tmp\")));\n-        build.run(Command::new(\"adb\")\n-                          .arg(\"pull\")\n-                          .arg(&log)\n-                          .arg(build.out.join(\"tmp\")));\n-        build.run(Command::new(\"adb\").arg(\"shell\").arg(\"rm\").arg(&log));\n-        if !output.contains(\"result: ok\") {\n-            panic!(\"some tests failed\");\n-        }\n-    }\n-}\n-\n fn krate_emscripten(build: &Build,\n                     compiler: &Compiler,\n                     target: &str,\n                     mode: Mode) {\n     let mut tests = Vec::new();\n     let out_dir = build.cargo_out(compiler, mode, target);\n-    find_tests(&out_dir, target, &mut tests);\n     find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n \n     for test in tests {\n@@ -543,17 +490,16 @@ fn krate_emscripten(build: &Build,\n     }\n }\n \n-fn krate_qemu(build: &Build,\n-              compiler: &Compiler,\n-              target: &str,\n-              mode: Mode) {\n+fn krate_remote(build: &Build,\n+                compiler: &Compiler,\n+                target: &str,\n+                mode: Mode) {\n     let mut tests = Vec::new();\n     let out_dir = build.cargo_out(compiler, mode, target);\n-    find_tests(&out_dir, target, &mut tests);\n     find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n \n     let tool = build.tool(&Compiler::new(0, &build.config.build),\n-                          \"qemu-test-client\");\n+                          \"remote-test-client\");\n     for test in tests {\n         let mut cmd = Command::new(&tool);\n         cmd.arg(\"run\")\n@@ -566,7 +512,6 @@ fn krate_qemu(build: &Build,\n     }\n }\n \n-\n fn find_tests(dir: &Path,\n               target: &str,\n               dst: &mut Vec<PathBuf>) {\n@@ -585,59 +530,28 @@ fn find_tests(dir: &Path,\n }\n \n pub fn emulator_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n-    if target.contains(\"android\") {\n-        android_copy_libs(build, compiler, target)\n-    } else if let Some(s) = build.qemu_rootfs(target) {\n-        qemu_copy_libs(build, compiler, target, s)\n-    }\n-}\n-\n-fn android_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n-    println!(\"Android copy libs to emulator ({})\", target);\n-    build.run(Command::new(\"adb\").arg(\"wait-for-device\"));\n-    build.run(Command::new(\"adb\").arg(\"remount\"));\n-    build.run(Command::new(\"adb\").args(&[\"shell\", \"rm\", \"-r\", ADB_TEST_DIR]));\n-    build.run(Command::new(\"adb\").args(&[\"shell\", \"mkdir\", ADB_TEST_DIR]));\n-    build.run(Command::new(\"adb\")\n-                      .arg(\"push\")\n-                      .arg(build.src.join(\"src/etc/adb_run_wrapper.sh\"))\n-                      .arg(ADB_TEST_DIR));\n-\n-    let target_dir = format!(\"{}/{}\", ADB_TEST_DIR, target);\n-    build.run(Command::new(\"adb\").args(&[\"shell\", \"mkdir\", &target_dir]));\n-\n-    for f in t!(build.sysroot_libdir(compiler, target).read_dir()) {\n-        let f = t!(f);\n-        let name = f.file_name().into_string().unwrap();\n-        if util::is_dylib(&name) {\n-            build.run(Command::new(\"adb\")\n-                              .arg(\"push\")\n-                              .arg(f.path())\n-                              .arg(&target_dir));\n-        }\n+    if !build.remote_tested(target) {\n+        return\n     }\n-}\n \n-fn qemu_copy_libs(build: &Build,\n-                  compiler: &Compiler,\n-                  target: &str,\n-                  rootfs: &Path) {\n-    println!(\"QEMU copy libs to emulator ({})\", target);\n-    assert!(target.starts_with(\"arm\"), \"only works with arm for now\");\n+    println!(\"REMOTE copy libs to emulator ({})\", target);\n     t!(fs::create_dir_all(build.out.join(\"tmp\")));\n \n-    // Copy our freshly compiled test server over to the rootfs\n     let server = build.cargo_out(compiler, Mode::Tool, target)\n-                      .join(exe(\"qemu-test-server\", target));\n-    t!(fs::copy(&server, rootfs.join(\"testd\")));\n+                      .join(exe(\"remote-test-server\", target));\n \n     // Spawn the emulator and wait for it to come online\n     let tool = build.tool(&Compiler::new(0, &build.config.build),\n-                          \"qemu-test-client\");\n-    build.run(Command::new(&tool)\n-                      .arg(\"spawn-emulator\")\n-                      .arg(rootfs)\n-                      .arg(build.out.join(\"tmp\")));\n+                          \"remote-test-client\");\n+    let mut cmd = Command::new(&tool);\n+    cmd.arg(\"spawn-emulator\")\n+       .arg(target)\n+       .arg(&server)\n+       .arg(build.out.join(\"tmp\"));\n+    if let Some(rootfs) = build.qemu_rootfs(target) {\n+        cmd.arg(rootfs);\n+    }\n+    build.run(&mut cmd);\n \n     // Push all our dylibs to the emulator\n     for f in t!(build.sysroot_libdir(compiler, target).read_dir()) {"}, {"sha": "74c58844741c7dcd89d4ad60f297f70cda9f258d", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -945,6 +945,12 @@ impl Build {\n             .map(|p| &**p)\n     }\n \n+    /// Returns whether the target will be tested using the `remote-test-client`\n+    /// and `remote-test-server` binaries.\n+    fn remote_tested(&self, target: &str) -> bool {\n+        self.qemu_rootfs(target).is_some() || target.contains(\"android\")\n+    }\n+\n     /// Returns the root of the \"rootfs\" image that this target will be using,\n     /// if one was configured.\n     ///"}, {"sha": "a4d6f91fbef7577c389124ab0759ba64432fb392", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -513,15 +513,15 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.test(\"emulator-copy-libs\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n          .dep(move |s| {\n-             if build.qemu_rootfs(s.target).is_some() {\n-                s.name(\"tool-qemu-test-client\").target(s.host).stage(0)\n+             if build.remote_tested(s.target) {\n+                s.name(\"tool-remote-test-client\").target(s.host).stage(0)\n              } else {\n                  Step::noop()\n              }\n          })\n          .dep(move |s| {\n-             if build.qemu_rootfs(s.target).is_some() {\n-                s.name(\"tool-qemu-test-server\")\n+             if build.remote_tested(s.target) {\n+                s.name(\"tool-remote-test-server\")\n              } else {\n                  Step::noop()\n              }\n@@ -566,14 +566,14 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(|s| s.name(\"maybe-clean-tools\"))\n          .dep(|s| s.name(\"libstd-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n-    rules.build(\"tool-qemu-test-server\", \"src/tools/qemu-test-server\")\n+    rules.build(\"tool-remote-test-server\", \"src/tools/remote-test-server\")\n          .dep(|s| s.name(\"maybe-clean-tools\"))\n          .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"qemu-test-server\"));\n-    rules.build(\"tool-qemu-test-client\", \"src/tools/qemu-test-client\")\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-server\"));\n+    rules.build(\"tool-remote-test-client\", \"src/tools/remote-test-client\")\n          .dep(|s| s.name(\"maybe-clean-tools\"))\n          .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"qemu-test-client\"));\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-client\"));\n     rules.build(\"tool-cargo\", \"cargo\")\n          .dep(|s| s.name(\"maybe-clean-tools\"))\n          .dep(|s| s.name(\"libstd-tool\"))"}, {"sha": "bd6c483156f8125df69f0f2753b0dbf5eed15487", "filename": "src/etc/adb_run_wrapper.sh", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Fetc%2Fadb_run_wrapper.sh", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Fetc%2Fadb_run_wrapper.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fadb_run_wrapper.sh?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -1,35 +0,0 @@\n-# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-#\n-# ignore-tidy-linelength\n-#\n-# usage : adb_run_wrapper [test dir - where test executables exist] [test executable]\n-#\n-\n-TEST_PATH=$1\n-BIN_PATH=/system/bin\n-if [ -d \"$TEST_PATH\" ]\n-then\n-    shift\n-    RUN=$1\n-\n-    if [ ! -z \"$RUN\" ]\n-    then\n-        shift\n-\n-        # The length of binary path (i.e. ./$RUN) should be shorter than 128 characters.\n-        cd $TEST_PATH\n-        TEST_EXEC_ENV=22 LD_LIBRARY_PATH=$TEST_PATH PATH=$BIN_PATH:$TEST_PATH ./$RUN $@ 1>$TEST_PATH/$RUN.stdout 2>$TEST_PATH/$RUN.stderr\n-        L_RET=$?\n-\n-        echo $L_RET > $TEST_PATH/$RUN.exitcode\n-\n-    fi\n-fi"}, {"sha": "8ad6ca0abb027a6c00414a956b640c20d6513e3c", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -13,9 +13,11 @@\n #![feature(rand)]\n #![feature(const_fn)]\n \n-use std::sync::atomic::{AtomicUsize, Ordering};\n use std::__rand::{thread_rng, Rng};\n+use std::panic;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread;\n+use std::cell::Cell;\n \n const MAX_LEN: usize = 80;\n \n@@ -76,6 +78,7 @@ fn test(input: &[DropCounter]) {\n             let mut panic_countdown = panic_countdown;\n             v.sort_by(|a, b| {\n                 if panic_countdown == 0 {\n+                    SILENCE_PANIC.with(|s| s.set(true));\n                     panic!();\n                 }\n                 panic_countdown -= 1;\n@@ -94,7 +97,15 @@ fn test(input: &[DropCounter]) {\n     }\n }\n \n+thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n+\n fn main() {\n+    let prev = panic::take_hook();\n+    panic::set_hook(Box::new(move |info| {\n+        if !SILENCE_PANIC.with(|s| s.get()) {\n+            prev(info);\n+        }\n+    }));\n     for len in (1..20).chain(70..MAX_LEN) {\n         // Test on a random array.\n         let mut rng = thread_rng();"}, {"sha": "df41e786be58fc120b37709717e79e2eedc543df", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -185,8 +185,8 @@ pub struct Config {\n     // Print one character per test instead of one line\n     pub quiet: bool,\n \n-    // where to find the qemu test client process, if we're using it\n-    pub qemu_test_client: Option<PathBuf>,\n+    // where to find the remote test client process, if we're using it\n+    pub remote_test_client: Option<PathBuf>,\n \n     // Configuration for various run-make tests frobbing things like C compilers\n     // or querying about various LLVM component information."}, {"sha": "0e4901ef1aba661b74a5971774f9218b9951a640", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -106,7 +106,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           reqopt(\"\", \"llvm-components\", \"list of LLVM components built in\", \"LIST\"),\n           reqopt(\"\", \"llvm-cxxflags\", \"C++ flags for LLVM\", \"FLAGS\"),\n           optopt(\"\", \"nodejs\", \"the name of nodejs\", \"PATH\"),\n-          optopt(\"\", \"qemu-test-client\", \"path to the qemu test client\", \"PATH\"),\n+          optopt(\"\", \"remote-test-client\", \"path to the remote test client\", \"PATH\"),\n           optflag(\"h\", \"help\", \"show this message\")];\n \n     let (argv0, args_) = args.split_first().unwrap();\n@@ -177,17 +177,15 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         llvm_version: matches.opt_str(\"llvm-version\"),\n         android_cross_path: opt_path(matches, \"android-cross-path\"),\n         adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n-        adb_test_dir: format!(\"{}/{}\",\n-            opt_str2(matches.opt_str(\"adb-test-dir\")),\n-            opt_str2(matches.opt_str(\"target\"))),\n+        adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n         adb_device_status:\n             opt_str2(matches.opt_str(\"target\")).contains(\"android\") &&\n             \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\")) &&\n             !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n         verbose: matches.opt_present(\"verbose\"),\n         quiet: matches.opt_present(\"quiet\"),\n-        qemu_test_client: matches.opt_str(\"qemu-test-client\").map(PathBuf::from),\n+        remote_test_client: matches.opt_str(\"remote-test-client\").map(PathBuf::from),\n \n         cc: matches.opt_str(\"cc\").unwrap(),\n         cxx: matches.opt_str(\"cxx\").unwrap(),\n@@ -252,27 +250,14 @@ pub fn run_tests(config: &Config) {\n         if let DebugInfoGdb = config.mode {\n             println!(\"{} debug-info test uses tcp 5039 port.\\\n                      please reserve it\", config.target);\n-        }\n-\n-        // android debug-info test uses remote debugger\n-        // so, we test 1 thread at once.\n-        // also trying to isolate problems with adb_run_wrapper.sh ilooping\n-        match config.mode {\n-            // These tests don't actually run code or don't run for android, so\n-            // we don't need to limit ourselves there\n-            Mode::Ui |\n-            Mode::CompileFail |\n-            Mode::ParseFail |\n-            Mode::RunMake |\n-            Mode::Codegen |\n-            Mode::CodegenUnits |\n-            Mode::Pretty |\n-            Mode::Rustdoc => {}\n-\n-            _ => {\n-                env::set_var(\"RUST_TEST_THREADS\", \"1\");\n-            }\n \n+            // android debug-info test uses remote debugger so, we test 1 thread\n+            // at once as they're all sharing the same TCP port to communicate\n+            // over.\n+            //\n+            // we should figure out how to lift this restriction! (run them all\n+            // on different ports allocated dynamically).\n+            env::set_var(\"RUST_TEST_THREADS\", \"1\");\n         }\n     }\n \n@@ -296,9 +281,10 @@ pub fn run_tests(config: &Config) {\n         }\n \n         DebugInfoGdb => {\n-            if config.qemu_test_client.is_some() {\n+            if config.remote_test_client.is_some() &&\n+               !config.target.contains(\"android\"){\n                 println!(\"WARNING: debuginfo tests are not available when \\\n-                          testing with QEMU\");\n+                          testing with remote\");\n                 return\n             }\n         }"}, {"sha": "3d40cc419fa443f85776357d80d999da7cfd59c3", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 12, "deletions": 203, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -24,7 +24,6 @@ use util::logv;\n \n use std::collections::HashSet;\n use std::env;\n-use std::fmt;\n use std::fs::{self, File, create_dir_all};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n@@ -469,7 +468,9 @@ actual:\\n\\\n \n         let debugger_run_result;\n         match &*self.config.target {\n-            \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n+            \"arm-linux-androideabi\" |\n+            \"armv7-linux-androideabi\" |\n+            \"aarch64-linux-android\" => {\n \n                 cmds = cmds.replace(\"run\", \"continue\");\n \n@@ -534,6 +535,7 @@ actual:\\n\\\n                                       exe_file.file_name().unwrap().to_str()\n                                       .unwrap());\n \n+                debug!(\"adb arg: {}\", adb_arg);\n                 let mut process = procsrv::run_background(\"\",\n                                                           &self.config.adb_path\n                                                           ,\n@@ -590,7 +592,7 @@ actual:\\n\\\n                 };\n \n                 debugger_run_result = ProcRes {\n-                    status: Status::Normal(status),\n+                    status: status,\n                     stdout: out,\n                     stderr: err,\n                     cmdline: cmdline\n@@ -841,7 +843,7 @@ actual:\\n\\\n \n         self.dump_output(&out, &err);\n         ProcRes {\n-            status: Status::Normal(status),\n+            status: status,\n             stdout: out,\n             stderr: err,\n             cmdline: format!(\"{:?}\", cmd)\n@@ -1190,25 +1192,20 @@ actual:\\n\\\n         let env = self.props.exec_env.clone();\n \n         match &*self.config.target {\n-\n-            \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n-                self._arm_exec_compiled_test(env)\n-            }\n-\n             // This is pretty similar to below, we're transforming:\n             //\n             //      program arg1 arg2\n             //\n             // into\n             //\n-            //      qemu-test-client run program:support-lib.so arg1 arg2\n+            //      remote-test-client run program:support-lib.so arg1 arg2\n             //\n             // The test-client program will upload `program` to the emulator\n             // along with all other support libraries listed (in this case\n             // `support-lib.so`. It will then execute the program on the\n             // emulator with the arguments specified (in the environment we give\n             // the process) and then report back the same result.\n-            _ if self.config.qemu_test_client.is_some() => {\n+            _ if self.config.remote_test_client.is_some() => {\n                 let aux_dir = self.aux_output_dir_name();\n                 let mut args = self.make_run_args();\n                 let mut program = args.prog.clone();\n@@ -1224,7 +1221,7 @@ actual:\\n\\\n                 }\n                 args.args.insert(0, program);\n                 args.args.insert(0, \"run\".to_string());\n-                args.prog = self.config.qemu_test_client.clone().unwrap()\n+                args.prog = self.config.remote_test_client.clone().unwrap()\n                                 .into_os_string().into_string().unwrap();\n                 self.compose_and_run(args,\n                                      env,\n@@ -1324,13 +1321,6 @@ actual:\\n\\\n                              aux_testpaths.file.display()),\n                     &auxres);\n             }\n-\n-            match &*self.config.target {\n-                \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n-                    self._arm_push_aux_shared_library();\n-                }\n-                _ => {}\n-            }\n         }\n \n         self.compose_and_run(args,\n@@ -1564,7 +1554,7 @@ actual:\\n\\\n                          input).expect(&format!(\"failed to exec `{}`\", prog));\n         self.dump_output(&out, &err);\n         return ProcRes {\n-            status: Status::Normal(status),\n+            status: status,\n             stdout: out,\n             stderr: err,\n             cmdline: cmdline,\n@@ -1698,157 +1688,6 @@ actual:\\n\\\n         println!(\"---------------------------------------------------\");\n     }\n \n-    fn _arm_exec_compiled_test(&self, env: Vec<(String, String)>) -> ProcRes {\n-        let args = self.make_run_args();\n-        let cmdline = self.make_cmdline(\"\", &args.prog, &args.args);\n-\n-        // get bare program string\n-        let mut tvec: Vec<String> = args.prog\n-                                        .split('/')\n-                                        .map(str::to_owned)\n-                                        .collect();\n-        let prog_short = tvec.pop().unwrap();\n-\n-        // copy to target\n-        let copy_result = procsrv::run(\"\",\n-                                       &self.config.adb_path,\n-                                       None,\n-                                       &[\n-                                           \"push\".to_owned(),\n-                                           args.prog.clone(),\n-                                           self.config.adb_test_dir.clone()\n-                                       ],\n-                                       vec![(\"\".to_owned(), \"\".to_owned())],\n-                                       Some(\"\".to_owned()))\n-            .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-        if self.config.verbose {\n-            println!(\"push ({}) {} {} {}\",\n-                     self.config.target,\n-                     args.prog,\n-                     copy_result.out,\n-                     copy_result.err);\n-        }\n-\n-        logv(self.config, format!(\"executing ({}) {}\", self.config.target, cmdline));\n-\n-        let mut runargs = Vec::new();\n-\n-        // run test via adb_run_wrapper\n-        runargs.push(\"shell\".to_owned());\n-        for (key, val) in env {\n-            runargs.push(format!(\"{}={}\", key, val));\n-        }\n-        runargs.push(format!(\"{}/../adb_run_wrapper.sh\", self.config.adb_test_dir));\n-        runargs.push(format!(\"{}\", self.config.adb_test_dir));\n-        runargs.push(format!(\"{}\", prog_short));\n-\n-        for tv in &args.args {\n-            runargs.push(tv.to_owned());\n-        }\n-        procsrv::run(\"\",\n-                     &self.config.adb_path,\n-                     None,\n-                     &runargs,\n-                     vec![(\"\".to_owned(), \"\".to_owned())], Some(\"\".to_owned()))\n-            .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-        // get exitcode of result\n-        runargs = Vec::new();\n-        runargs.push(\"shell\".to_owned());\n-        runargs.push(\"cat\".to_owned());\n-        runargs.push(format!(\"{}/{}.exitcode\", self.config.adb_test_dir, prog_short));\n-\n-        let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n-            procsrv::run(\"\",\n-                         &self.config.adb_path,\n-                         None,\n-                         &runargs,\n-                         vec![(\"\".to_owned(), \"\".to_owned())],\n-                         Some(\"\".to_owned()))\n-            .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-        let mut exitcode: i32 = 0;\n-        for c in exitcode_out.chars() {\n-            if !c.is_numeric() { break; }\n-            exitcode = exitcode * 10 + match c {\n-                '0' ... '9' => c as i32 - ('0' as i32),\n-                _ => 101,\n-            }\n-        }\n-\n-        // get stdout of result\n-        runargs = Vec::new();\n-        runargs.push(\"shell\".to_owned());\n-        runargs.push(\"cat\".to_owned());\n-        runargs.push(format!(\"{}/{}.stdout\", self.config.adb_test_dir, prog_short));\n-\n-        let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n-            procsrv::run(\"\",\n-                         &self.config.adb_path,\n-                         None,\n-                         &runargs,\n-                         vec![(\"\".to_owned(), \"\".to_owned())],\n-                         Some(\"\".to_owned()))\n-            .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-        // get stderr of result\n-        runargs = Vec::new();\n-        runargs.push(\"shell\".to_owned());\n-        runargs.push(\"cat\".to_owned());\n-        runargs.push(format!(\"{}/{}.stderr\", self.config.adb_test_dir, prog_short));\n-\n-        let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n-            procsrv::run(\"\",\n-                         &self.config.adb_path,\n-                         None,\n-                         &runargs,\n-                         vec![(\"\".to_owned(), \"\".to_owned())],\n-                         Some(\"\".to_owned()))\n-            .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-        self.dump_output(&stdout_out, &stderr_out);\n-\n-        ProcRes {\n-            status: Status::Parsed(exitcode),\n-            stdout: stdout_out,\n-            stderr: stderr_out,\n-            cmdline: cmdline\n-        }\n-    }\n-\n-    fn _arm_push_aux_shared_library(&self) {\n-        let tdir = self.aux_output_dir_name();\n-\n-        let dirs = fs::read_dir(&tdir).unwrap();\n-        for file in dirs {\n-            let file = file.unwrap().path();\n-            if file.extension().and_then(|s| s.to_str()) == Some(\"so\") {\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let copy_result = procsrv::run(\"\",\n-                                               &self.config.adb_path,\n-                                               None,\n-                                               &[\n-                                                   \"push\".to_owned(),\n-                                                   file.to_str()\n-                                                       .unwrap()\n-                                                       .to_owned(),\n-                                                   self.config.adb_test_dir.to_owned(),\n-                                               ],\n-                                               vec![(\"\".to_owned(),\n-                                                     \"\".to_owned())],\n-                                               Some(\"\".to_owned()))\n-                    .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-                if self.config.verbose {\n-                    println!(\"push ({}) {:?} {} {}\",\n-                             self.config.target, file.display(),\n-                             copy_result.out, copy_result.err);\n-                }\n-            }\n-        }\n-    }\n-\n     // codegen tests (using FileCheck)\n \n     fn compile_test_and_save_ir(&self) -> ProcRes {\n@@ -2347,7 +2186,7 @@ actual:\\n\\\n         let output = cmd.output().expect(\"failed to spawn `make`\");\n         if !output.status.success() {\n             let res = ProcRes {\n-                status: Status::Normal(output.status),\n+                status: output.status,\n                 stdout: String::from_utf8_lossy(&output.stdout).into_owned(),\n                 stderr: String::from_utf8_lossy(&output.stderr).into_owned(),\n                 cmdline: format!(\"{:?}\", cmd),\n@@ -2594,17 +2433,12 @@ struct ProcArgs {\n }\n \n pub struct ProcRes {\n-    status: Status,\n+    status: ExitStatus,\n     stdout: String,\n     stderr: String,\n     cmdline: String,\n }\n \n-enum Status {\n-    Parsed(i32),\n-    Normal(ExitStatus),\n-}\n-\n impl ProcRes {\n     pub fn fatal(&self, err: Option<&str>) -> ! {\n         if let Some(e) = err {\n@@ -2628,31 +2462,6 @@ impl ProcRes {\n     }\n }\n \n-impl Status {\n-    fn code(&self) -> Option<i32> {\n-        match *self {\n-            Status::Parsed(i) => Some(i),\n-            Status::Normal(ref e) => e.code(),\n-        }\n-    }\n-\n-    fn success(&self) -> bool {\n-        match *self {\n-            Status::Parsed(i) => i == 0,\n-            Status::Normal(ref e) => e.success(),\n-        }\n-    }\n-}\n-\n-impl fmt::Display for Status {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Status::Parsed(i) => write!(f, \"exit code: {}\", i),\n-            Status::Normal(ref e) => e.fmt(f),\n-        }\n-    }\n-}\n-\n enum TargetLocation {\n     ThisFile(PathBuf),\n     ThisDirectory(PathBuf),"}, {"sha": "54739101f1eff6bced78a9096e4b5b32a72358d0", "filename": "src/tools/remote-test-client/Cargo.toml", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fremote-test-client%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fremote-test-client%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-client%2FCargo.toml?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -1,5 +1,5 @@\n [package]\n-name = \"qemu-test-client\"\n+name = \"remote-test-client\"\n version = \"0.1.0\"\n authors = [\"The Rust Project Developers\"]\n ", "previous_filename": "src/tools/qemu-test-client/Cargo.toml"}, {"sha": "265354ff800543440fea28419ba58b77eb986887", "filename": "src/tools/remote-test-client/src/main.rs", "status": "renamed", "additions": 93, "deletions": 33, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -8,19 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// This is a small client program intended to pair with `qemu-test-server` in\n+/// This is a small client program intended to pair with `remote-test-server` in\n /// this repository. This client connects to the server over TCP and is used to\n /// push artifacts and run tests on the server instead of locally.\n ///\n /// Here is also where we bake in the support to spawn the QEMU emulator as\n /// well.\n \n use std::env;\n-use std::fs::File;\n+use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter};\n use std::net::TcpStream;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::thread;\n use std::time::Duration;\n@@ -37,8 +37,10 @@ fn main() {\n \n     match &args.next().unwrap()[..] {\n         \"spawn-emulator\" => {\n-            spawn_emulator(Path::new(&args.next().unwrap()),\n-                           Path::new(&args.next().unwrap()))\n+            spawn_emulator(&args.next().unwrap(),\n+                           Path::new(&args.next().unwrap()),\n+                           Path::new(&args.next().unwrap()),\n+                           args.next().map(|s| s.into()))\n         }\n         \"push\" => {\n             push(Path::new(&args.next().unwrap()))\n@@ -50,11 +52,74 @@ fn main() {\n     }\n }\n \n-fn spawn_emulator(rootfs: &Path, tmpdir: &Path) {\n+fn spawn_emulator(target: &str,\n+                  server: &Path,\n+                  tmpdir: &Path,\n+                  rootfs: Option<PathBuf>) {\n+    if target.contains(\"android\") {\n+        start_android_emulator(server);\n+    } else {\n+        let rootfs = rootfs.as_ref().expect(\"need rootfs on non-android\");\n+        start_qemu_emulator(rootfs, server, tmpdir);\n+    }\n+\n+    // Wait for the emulator to come online\n+    loop {\n+        let dur = Duration::from_millis(100);\n+        if let Ok(mut client) = TcpStream::connect(\"127.0.0.1:12345\") {\n+            t!(client.set_read_timeout(Some(dur)));\n+            t!(client.set_write_timeout(Some(dur)));\n+            if client.write_all(b\"ping\").is_ok() {\n+                let mut b = [0; 4];\n+                if client.read_exact(&mut b).is_ok() {\n+                    break\n+                }\n+            }\n+        }\n+        thread::sleep(dur);\n+    }\n+}\n+\n+fn start_android_emulator(server: &Path) {\n+    println!(\"waiting for device to come online\");\n+    let status = Command::new(\"adb\")\n+                    .arg(\"wait-for-device\")\n+                    .status()\n+                    .unwrap();\n+    assert!(status.success());\n+\n+    println!(\"pushing server\");\n+    let status = Command::new(\"adb\")\n+                    .arg(\"push\")\n+                    .arg(server)\n+                    .arg(\"/data/tmp/testd\")\n+                    .status()\n+                    .unwrap();\n+    assert!(status.success());\n+\n+    println!(\"forwarding tcp\");\n+    let status = Command::new(\"adb\")\n+                    .arg(\"forward\")\n+                    .arg(\"tcp:12345\")\n+                    .arg(\"tcp:12345\")\n+                    .status()\n+                    .unwrap();\n+    assert!(status.success());\n+\n+    println!(\"executing server\");\n+    Command::new(\"adb\")\n+                    .arg(\"shell\")\n+                    .arg(\"/data/tmp/testd\")\n+                    .spawn()\n+                    .unwrap();\n+}\n+\n+fn start_qemu_emulator(rootfs: &Path, server: &Path, tmpdir: &Path) {\n     // Generate a new rootfs image now that we've updated the test server\n     // executable. This is the equivalent of:\n     //\n     //      find $rootfs -print 0 | cpio --null -o --format=newc > rootfs.img\n+    t!(fs::copy(server, rootfs.join(\"testd\")));\n     let rootfs_img = tmpdir.join(\"rootfs.img\");\n     let mut cmd = Command::new(\"cpio\");\n     cmd.arg(\"--null\")\n@@ -83,22 +148,6 @@ fn spawn_emulator(rootfs: &Path, tmpdir: &Path) {\n        .arg(\"-redir\").arg(\"tcp:12345::12345\");\n     t!(cmd.spawn());\n \n-    // Wait for the emulator to come online\n-    loop {\n-        let dur = Duration::from_millis(100);\n-        if let Ok(mut client) = TcpStream::connect(\"127.0.0.1:12345\") {\n-            t!(client.set_read_timeout(Some(dur)));\n-            t!(client.set_write_timeout(Some(dur)));\n-            if client.write_all(b\"ping\").is_ok() {\n-                let mut b = [0; 4];\n-                if client.read_exact(&mut b).is_ok() {\n-                    break\n-                }\n-            }\n-        }\n-        thread::sleep(dur);\n-    }\n-\n     fn add_files(w: &mut Write, root: &Path, cur: &Path) {\n         for entry in t!(cur.read_dir()) {\n             let entry = t!(entry);\n@@ -116,11 +165,15 @@ fn push(path: &Path) {\n     let client = t!(TcpStream::connect(\"127.0.0.1:12345\"));\n     let mut client = BufWriter::new(client);\n     t!(client.write_all(b\"push\"));\n-    t!(client.write_all(path.file_name().unwrap().to_str().unwrap().as_bytes()));\n-    t!(client.write_all(&[0]));\n-    let mut file = t!(File::open(path));\n-    t!(io::copy(&mut file, &mut client));\n+    send(path, &mut client);\n     t!(client.flush());\n+\n+    // Wait for an acknowledgement that all the data was received. No idea\n+    // why this is necessary, seems like it shouldn't be!\n+    let mut client = client.into_inner().unwrap();\n+    let mut buf = [0; 4];\n+    t!(client.read_exact(&mut buf));\n+    assert_eq!(&buf, b\"ack \");\n     println!(\"done pushing {:?}\", path);\n }\n \n@@ -137,22 +190,27 @@ fn run(files: String, args: Vec<String>) {\n     t!(client.write_all(&[0]));\n \n     // Send over env vars\n+    //\n+    // Don't send over *everything* though as some env vars are set by and used\n+    // by the client.\n     for (k, v) in env::vars() {\n-        if k != \"PATH\" && k != \"LD_LIBRARY_PATH\" {\n-            t!(client.write_all(k.as_bytes()));\n-            t!(client.write_all(&[0]));\n-            t!(client.write_all(v.as_bytes()));\n-            t!(client.write_all(&[0]));\n+        match &k[..] {\n+            \"PATH\" |\n+            \"LD_LIBRARY_PATH\" |\n+            \"PWD\" => continue,\n+            _ => {}\n         }\n+        t!(client.write_all(k.as_bytes()));\n+        t!(client.write_all(&[0]));\n+        t!(client.write_all(v.as_bytes()));\n+        t!(client.write_all(&[0]));\n     }\n     t!(client.write_all(&[0]));\n \n     // Send over support libraries\n     let mut files = files.split(':');\n     let exe = files.next().unwrap();\n     for file in files.map(Path::new) {\n-        t!(client.write_all(file.file_name().unwrap().to_str().unwrap().as_bytes()));\n-        t!(client.write_all(&[0]));\n         send(&file, &mut client);\n     }\n     t!(client.write_all(&[0]));\n@@ -209,6 +267,8 @@ fn run(files: String, args: Vec<String>) {\n }\n \n fn send(path: &Path, dst: &mut Write) {\n+    t!(dst.write_all(path.file_name().unwrap().to_str().unwrap().as_bytes()));\n+    t!(dst.write_all(&[0]));\n     let mut file = t!(File::open(&path));\n     let amt = t!(file.metadata()).len();\n     t!(dst.write_all(&[", "previous_filename": "src/tools/qemu-test-client/src/main.rs"}, {"sha": "8704296289e83648ab4d694d6693102b868d7489", "filename": "src/tools/remote-test-server/Cargo.toml", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fremote-test-server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fremote-test-server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-server%2FCargo.toml?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -1,5 +1,5 @@\n [package]\n-name = \"qemu-test-server\"\n+name = \"remote-test-server\"\n version = \"0.1.0\"\n authors = [\"The Rust Project Developers\"]\n ", "previous_filename": "src/tools/qemu-test-server/Cargo.toml"}, {"sha": "308ccdbef77baeb7e72c47253c8f5c28d9a5481a", "filename": "src/tools/remote-test-server/src/main.rs", "status": "renamed", "additions": 58, "deletions": 33, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs?ref=7bc2cbf5db3e20e6f97494b70b2a1d65ac2e61fc", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n /// This is a small server which is intended to run inside of an emulator. This\n-/// server pairs with the `qemu-test-client` program in this repository. The\n-/// `qemu-test-client` connects to this server over a TCP socket and performs\n+/// server pairs with the `remote-test-client` program in this repository. The\n+/// `remote-test-client` connects to this server over a TCP socket and performs\n /// work such as:\n ///\n /// 1. Pushing shared libraries to the server\n@@ -20,17 +20,18 @@\n /// themselves having support libraries. All data over the TCP sockets is in a\n /// basically custom format suiting our needs.\n \n+use std::cmp;\n use std::fs::{self, File, Permissions};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::net::{TcpListener, TcpStream};\n use std::os::unix::prelude::*;\n-use std::sync::{Arc, Mutex};\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, Stdio};\n use std::str;\n use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::{Arc, Mutex};\n use std::thread;\n-use std::process::{Command, Stdio};\n \n macro_rules! t {\n     ($e:expr) => (match $e {\n@@ -43,18 +44,24 @@ static TEST: AtomicUsize = ATOMIC_USIZE_INIT;\n \n fn main() {\n     println!(\"starting test server\");\n-    let listener = t!(TcpListener::bind(\"10.0.2.15:12345\"));\n+    let (listener, work) = if cfg!(target_os = \"android\") {\n+        (t!(TcpListener::bind(\"0.0.0.0:12345\")), \"/data/tmp/work\")\n+    } else {\n+        (t!(TcpListener::bind(\"10.0.2.15:12345\")), \"/tmp/work\")\n+    };\n     println!(\"listening!\");\n \n-    let work = Path::new(\"/tmp/work\");\n+    let work = Path::new(work);\n     t!(fs::create_dir_all(work));\n \n     let lock = Arc::new(Mutex::new(()));\n \n     for socket in listener.incoming() {\n         let mut socket = t!(socket);\n         let mut buf = [0; 4];\n-        t!(socket.read_exact(&mut buf));\n+        if socket.read_exact(&mut buf).is_err() {\n+            continue\n+        }\n         if &buf[..] == b\"ping\" {\n             t!(socket.write_all(b\"pong\"));\n         } else if &buf[..] == b\"push\" {\n@@ -70,14 +77,10 @@ fn main() {\n \n fn handle_push(socket: TcpStream, work: &Path) {\n     let mut reader = BufReader::new(socket);\n-    let mut filename = Vec::new();\n-    t!(reader.read_until(0, &mut filename));\n-    filename.pop(); // chop off the 0\n-    let filename = t!(str::from_utf8(&filename));\n+    recv(&work, &mut reader);\n \n-    let path = work.join(filename);\n-    t!(io::copy(&mut reader, &mut t!(File::create(&path))));\n-    t!(fs::set_permissions(&path, Permissions::from_mode(0o755)));\n+    let mut socket = reader.into_inner();\n+    t!(socket.write_all(b\"ack \"));\n }\n \n struct RemoveOnDrop<'a> {\n@@ -98,29 +101,29 @@ fn handle_run(socket: TcpStream, work: &Path, lock: &Mutex<()>) {\n     // space.\n     let n = TEST.fetch_add(1, Ordering::SeqCst);\n     let path = work.join(format!(\"test{}\", n));\n-    let exe = path.join(\"exe\");\n     t!(fs::create_dir(&path));\n     let _a = RemoveOnDrop { inner: &path };\n \n     // First up we'll get a list of arguments delimited with 0 bytes. An empty\n     // argument means that we're done.\n-    let mut cmd = Command::new(&exe);\n+    let mut args = Vec::new();\n     while t!(reader.read_until(0, &mut arg)) > 1 {\n-        cmd.arg(t!(str::from_utf8(&arg[..arg.len() - 1])));\n+        args.push(t!(str::from_utf8(&arg[..arg.len() - 1])).to_string());\n         arg.truncate(0);\n     }\n \n     // Next we'll get a bunch of env vars in pairs delimited by 0s as well\n+    let mut env = Vec::new();\n     arg.truncate(0);\n     while t!(reader.read_until(0, &mut arg)) > 1 {\n         let key_len = arg.len() - 1;\n         let val_len = t!(reader.read_until(0, &mut arg)) - 1;\n         {\n             let key = &arg[..key_len];\n             let val = &arg[key_len + 1..][..val_len];\n-            let key = t!(str::from_utf8(key));\n-            let val = t!(str::from_utf8(val));\n-            cmd.env(key, val);\n+            let key = t!(str::from_utf8(key)).to_string();\n+            let val = t!(str::from_utf8(val)).to_string();\n+            env.push((key, val));\n         }\n         arg.truncate(0);\n     }\n@@ -148,23 +151,23 @@ fn handle_run(socket: TcpStream, work: &Path, lock: &Mutex<()>) {\n     let lock = lock.lock();\n \n     // Next there's a list of dynamic libraries preceded by their filenames.\n-    arg.truncate(0);\n-    while t!(reader.read_until(0, &mut arg)) > 1 {\n-        let dst = path.join(t!(str::from_utf8(&arg[..arg.len() - 1])));\n-        let amt = read_u32(&mut reader) as u64;\n-        t!(io::copy(&mut reader.by_ref().take(amt),\n-                    &mut t!(File::create(&dst))));\n-        t!(fs::set_permissions(&dst, Permissions::from_mode(0o755)));\n-        arg.truncate(0);\n+    while t!(reader.fill_buf())[0] != 0 {\n+        recv(&path, &mut reader);\n     }\n+    assert_eq!(t!(reader.read(&mut [0])), 1);\n \n     // Finally we'll get the binary. The other end will tell us how big the\n     // binary is and then we'll download it all to the exe path we calculated\n     // earlier.\n-    let amt = read_u32(&mut reader) as u64;\n-    t!(io::copy(&mut reader.by_ref().take(amt),\n-                &mut t!(File::create(&exe))));\n-    t!(fs::set_permissions(&exe, Permissions::from_mode(0o755)));\n+    let exe = recv(&path, &mut reader);\n+\n+    let mut cmd = Command::new(&exe);\n+    for arg in args {\n+        cmd.arg(arg);\n+    }\n+    for (k, v) in env {\n+        cmd.env(k, v);\n+    }\n \n     // Support libraries were uploaded to `work` earlier, so make sure that's\n     // in `LD_LIBRARY_PATH`. Also include our own current dir which may have\n@@ -202,6 +205,28 @@ fn handle_run(socket: TcpStream, work: &Path, lock: &Mutex<()>) {\n     ]));\n }\n \n+fn recv<B: BufRead>(dir: &Path, io: &mut B) -> PathBuf {\n+    let mut filename = Vec::new();\n+    t!(io.read_until(0, &mut filename));\n+\n+    // We've got some tests with *really* long names. We try to name the test\n+    // executable the same on the target as it is on the host to aid with\n+    // debugging, but the targets we're emulating are often more restrictive\n+    // than the hosts as well.\n+    //\n+    // To ensure we can run a maximum number of tests without modifications we\n+    // just arbitrarily truncate the filename to 50 bytes. That should\n+    // hopefully allow us to still identify what's running while staying under\n+    // the filesystem limits.\n+    let len = cmp::min(filename.len() - 1, 50);\n+    let dst = dir.join(t!(str::from_utf8(&filename[..len])));\n+    let amt = read_u32(io) as u64;\n+    t!(io::copy(&mut io.take(amt),\n+                &mut t!(File::create(&dst))));\n+    t!(fs::set_permissions(&dst, Permissions::from_mode(0o755)));\n+    return dst\n+}\n+\n fn my_copy(src: &mut Read, which: u8, dst: &Mutex<Write>) {\n     let mut b = [0; 1024];\n     loop {", "previous_filename": "src/tools/qemu-test-server/src/main.rs"}]}