{"sha": "9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "node_id": "C_kwDOAAsO6NoAKDlkMWYxNTA4NmFkZjJjYjBlZGM4ZjJkMWM5YWE3YTc5MjQxZGFlNjg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-27T15:38:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-27T15:38:42Z"}, "message": "Merge #10649\n\n10649: internal: Remove `CompletionKind` in favor of `CompletionItemKind` r=Veykril a=Veykril\n\nand move some more tests around\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "2070971562a4e0b25a79ba2df2a3756eae02bb5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2070971562a4e0b25a79ba2df2a3756eae02bb5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJheXKCCRBK7hj4Ov3rIwAAYOgIACfOS6UTpG/ZskGRfayuOP51\n6gdBN04TgpsTzP2CAqZOuYA8CJjSbPpGpZaJJ4WwzQkxWokGw7tA2n/uO0qk3gpx\nsT8lC4U0ob3NRs6zoYIUX8koa83usRhpXQwNlPXjQ+5snJsaNIoV5M8fvyyJ47Xl\nGfA7wXTOVQEL2wgJyzmEMr0zfEeFWmez4ALbqRzDv8uo9L2xeVrrRk0VUkUbVXcw\nuTGDJhG62mH3foiCWLqTKH95nshwzpja0/NeRew64e+tBKBYpsN9m8LyHtT5WxLT\nVCshwTr+uq4TUm4rjVzFkB5Yw1urpNwekx8R/trbZ05BI+k5JZ/Eld9PHwXMU2M=\n=vwJ2\n-----END PGP SIGNATURE-----\n", "payload": "tree 2070971562a4e0b25a79ba2df2a3756eae02bb5e\nparent dd43f3f2d13a32199828e758ddf13176df1f17f9\nparent 0468b11de7cbd2ad5d311597d9cfaabdedfab9cd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1635349122 +0000\ncommitter GitHub <noreply@github.com> 1635349122 +0000\n\nMerge #10649\n\n10649: internal: Remove `CompletionKind` in favor of `CompletionItemKind` r=Veykril a=Veykril\n\nand move some more tests around\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "html_url": "https://github.com/rust-lang/rust/commit/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd43f3f2d13a32199828e758ddf13176df1f17f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd43f3f2d13a32199828e758ddf13176df1f17f9", "html_url": "https://github.com/rust-lang/rust/commit/dd43f3f2d13a32199828e758ddf13176df1f17f9"}, {"sha": "0468b11de7cbd2ad5d311597d9cfaabdedfab9cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0468b11de7cbd2ad5d311597d9cfaabdedfab9cd", "html_url": "https://github.com/rust-lang/rust/commit/0468b11de7cbd2ad5d311597d9cfaabdedfab9cd"}], "stats": {"total": 3121, "additions": 1558, "deletions": 1563}, "files": [{"sha": "3e658c6e91d898f4625dc678cee1f66a73e5ee6c", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -21,7 +21,7 @@ use hir::known;\n use ide_db::SymbolKind;\n \n use crate::{\n-    item::{Builder, CompletionKind},\n+    item::Builder,\n     render::{\n         const_::render_const,\n         enum_variant::render_variant,\n@@ -76,8 +76,7 @@ impl Completions {\n     }\n \n     pub(crate) fn add_keyword(&mut self, ctx: &CompletionContext, keyword: &'static str) {\n-        let mut item = CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), keyword);\n-        item.kind(CompletionItemKind::Keyword);\n+        let item = CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), keyword);\n         item.add_to(self);\n     }\n \n@@ -191,9 +190,7 @@ impl Completions {\n     }\n \n     pub(crate) fn add_static_lifetime(&mut self, ctx: &CompletionContext) {\n-        let mut item =\n-            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), \"'static\");\n-        item.kind(CompletionItemKind::SymbolKind(SymbolKind::LifetimeParam));\n+        let item = CompletionItem::new(SymbolKind::LifetimeParam, ctx.source_range(), \"'static\");\n         self.add(item.build());\n     }\n "}, {"sha": "2482418ae6a1fdff982a606ce28f6a86caa9bb67", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -12,7 +12,7 @@ use syntax::{algo::non_trivia_sibling, ast, AstNode, Direction, SyntaxKind, T};\n \n use crate::{\n     context::CompletionContext,\n-    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    item::{CompletionItem, CompletionItemKind},\n     Completions,\n };\n \n@@ -69,11 +69,10 @@ fn complete_new_attribute(acc: &mut Completions, ctx: &CompletionContext, attrib\n \n     let add_completion = |attr_completion: &AttrCompletion| {\n         let mut item = CompletionItem::new(\n-            CompletionKind::Attribute,\n+            CompletionItemKind::Attribute,\n             ctx.source_range(),\n             attr_completion.label,\n         );\n-        item.kind(CompletionItemKind::Attribute);\n \n         if let Some(lookup) = attr_completion.lookup {\n             item.lookup_by(lookup);\n@@ -103,11 +102,10 @@ fn complete_new_attribute(acc: &mut Completions, ctx: &CompletionContext, attrib\n         if let hir::ScopeDef::MacroDef(mac) = scope_def {\n             if mac.kind() == hir::MacroKind::Attr {\n                 let mut item = CompletionItem::new(\n-                    CompletionKind::Attribute,\n+                    CompletionItemKind::Attribute,\n                     ctx.source_range(),\n                     name.to_string(),\n                 );\n-                item.kind(CompletionItemKind::Attribute);\n                 if let Some(docs) = mac.docs(ctx.sema.db) {\n                     item.documentation(docs);\n                 }"}, {"sha": "c83e1718ece49e702f0a2835744df13594ed3fd2", "filename": "crates/ide_completion/src/completions/attribute/cfg.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -5,16 +5,14 @@ use std::iter;\n use syntax::SyntaxKind;\n \n use crate::{\n-    completions::Completions, context::CompletionContext, item::CompletionKind, CompletionItem,\n-    CompletionItemKind,\n+    completions::Completions, context::CompletionContext, CompletionItem, CompletionItemKind,\n };\n \n pub(crate) fn complete_cfg(acc: &mut Completions, ctx: &CompletionContext) {\n     let add_completion = |item: &str| {\n         let mut completion =\n-            CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), item);\n+            CompletionItem::new(CompletionItemKind::Attribute, ctx.source_range(), item);\n         completion.insert_text(format!(r#\"\"{}\"\"#, item));\n-        completion.kind(CompletionItemKind::Attribute);\n         acc.add(completion.build());\n     };\n \n@@ -35,7 +33,7 @@ pub(crate) fn complete_cfg(acc: &mut Completions, ctx: &CompletionContext) {\n             if let Some(krate) = ctx.krate {\n                 krate.potential_cfg(ctx.db).get_cfg_values(&name).iter().for_each(|s| {\n                     let mut item = CompletionItem::new(\n-                        CompletionKind::Attribute,\n+                        CompletionItemKind::Attribute,\n                         ctx.source_range(),\n                         s.as_str(),\n                     );\n@@ -49,7 +47,7 @@ pub(crate) fn complete_cfg(acc: &mut Completions, ctx: &CompletionContext) {\n             if let Some(krate) = ctx.krate {\n                 krate.potential_cfg(ctx.db).get_cfg_keys().iter().for_each(|s| {\n                     let item = CompletionItem::new(\n-                        CompletionKind::Attribute,\n+                        CompletionItemKind::Attribute,\n                         ctx.source_range(),\n                         s.as_str(),\n                     );"}, {"sha": "7f050f25c9b1c90403b29d7eb84cb6759548efaa", "filename": "crates/ide_completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -7,7 +7,7 @@ use syntax::ast;\n \n use crate::{\n     context::CompletionContext,\n-    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    item::{CompletionItem, CompletionItemKind},\n     Completions,\n };\n \n@@ -56,8 +56,8 @@ pub(super) fn complete_derive(\n             _ => (&*name, None),\n         };\n \n-        let mut item = CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), label);\n-        item.kind(CompletionItemKind::Attribute);\n+        let mut item =\n+            CompletionItem::new(CompletionItemKind::Attribute, ctx.source_range(), label);\n         if let Some(docs) = mac.docs(ctx.db) {\n             item.documentation(docs);\n         }"}, {"sha": "05a29dd0ae216cfc077bb140d4b7f1482ad633d1", "filename": "crates/ide_completion/src/completions/attribute/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -4,7 +4,7 @@ use syntax::{ast, T};\n \n use crate::{\n     context::CompletionContext,\n-    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    item::{CompletionItem, CompletionItemKind},\n     Completions,\n };\n \n@@ -58,9 +58,9 @@ pub(super) fn complete_lint(\n             Some(qual) if !is_qualified => format!(\"{}::{}\", qual, name),\n             _ => name.to_owned(),\n         };\n-        let mut item = CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), label);\n-        item.kind(CompletionItemKind::Attribute)\n-            .documentation(hir::Documentation::new(description.to_owned()));\n+        let mut item =\n+            CompletionItem::new(CompletionItemKind::Attribute, ctx.source_range(), label);\n+        item.documentation(hir::Documentation::new(description.to_owned()));\n         item.add_to(acc)\n     }\n }"}, {"sha": "c240912f023da8619e574ea369f5d07f3e57f61f", "filename": "crates/ide_completion/src/completions/attribute/repr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -4,7 +4,7 @@ use syntax::ast;\n \n use crate::{\n     context::CompletionContext,\n-    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    item::{CompletionItem, CompletionItemKind},\n     Completions,\n };\n \n@@ -30,8 +30,7 @@ pub(super) fn complete_repr(acc: &mut Completions, ctx: &CompletionContext, inpu\n             }\n \n             let mut item =\n-                CompletionItem::new(CompletionKind::Attribute, ctx.source_range(), label);\n-            item.kind(CompletionItemKind::Attribute);\n+                CompletionItem::new(CompletionItemKind::Attribute, ctx.source_range(), label);\n             if let Some(lookup) = lookup {\n                 item.lookup_by(lookup);\n             }"}, {"sha": "ce964e986b076100e4a89a0869db535c343219b9", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -99,13 +99,10 @@ fn complete_methods(\n mod tests {\n     use expect_test::{expect, Expect};\n \n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n+    use crate::tests::{check_edit, completion_list_no_kw};\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Reference);\n+        let actual = completion_list_no_kw(ra_fixture);\n         expect.assert_eq(&actual);\n     }\n \n@@ -166,7 +163,7 @@ impl A {\n struct A { the_field: u32 }\n fn foo(a: A) { a.$0() }\n \"#,\n-            expect![[\"\"]],\n+            expect![[r#\"\"#]],\n         );\n     }\n \n@@ -405,7 +402,7 @@ fn foo(a: A) {\n    a.$0\n }\n \"#,\n-            expect![[\"\"]],\n+            expect![[r#\"\"#]],\n         );\n     }\n \n@@ -654,6 +651,7 @@ impl Foo { fn foo(&self) { $0 } }\"#,\n                 lc self       &Foo\n                 sp Self\n                 st Foo\n+                bt u32\n                 fd self.field i32\n                 me self.foo() fn(&self)\n             \"#]],\n@@ -667,6 +665,7 @@ impl Foo { fn foo(&mut self) { $0 } }\"#,\n                 lc self       &mut Foo\n                 sp Self\n                 st Foo\n+                bt u32\n                 fd self.0     i32\n                 me self.foo() fn(&mut self)\n             \"#]],"}, {"sha": "486cbff685988cb54c0ebc5aad08b14da2fe3f47", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 0, "deletions": 1015, "changes": 1015, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -219,1018 +219,3 @@ fn compute_fuzzy_completion_order_key(\n         None => usize::MAX,\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-\n-    use crate::{\n-        item::CompletionKind,\n-        tests::{check_edit, check_edit_with_config, filtered_completion_list, TEST_CONFIG},\n-    };\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Magic);\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn function_fuzzy_completion() {\n-        check_edit(\n-            \"stdin\",\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod io {\n-    pub fn stdin() {}\n-};\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    stdi$0\n-}\n-\"#,\n-            r#\"\n-use dep::io::stdin;\n-\n-fn main() {\n-    stdin()$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn macro_fuzzy_completion() {\n-        check_edit(\n-            \"macro_with_curlies!\",\n-            r#\"\n-//- /lib.rs crate:dep\n-/// Please call me as macro_with_curlies! {}\n-#[macro_export]\n-macro_rules! macro_with_curlies {\n-    () => {}\n-}\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    curli$0\n-}\n-\"#,\n-            r#\"\n-use dep::macro_with_curlies;\n-\n-fn main() {\n-    macro_with_curlies! {$0}\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn struct_fuzzy_completion() {\n-        check_edit(\n-            \"ThirdStruct\",\n-            r#\"\n-//- /lib.rs crate:dep\n-pub struct FirstStruct;\n-pub mod some_module {\n-    pub struct SecondStruct;\n-    pub struct ThirdStruct;\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::{FirstStruct, some_module::SecondStruct};\n-\n-fn main() {\n-    this$0\n-}\n-\"#,\n-            r#\"\n-use dep::{FirstStruct, some_module::{SecondStruct, ThirdStruct}};\n-\n-fn main() {\n-    ThirdStruct\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn short_paths_are_ignored() {\n-        cov_mark::check!(ignore_short_input_for_path);\n-\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub struct FirstStruct;\n-pub mod some_module {\n-    pub struct SecondStruct;\n-    pub struct ThirdStruct;\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::{FirstStruct, some_module::SecondStruct};\n-\n-fn main() {\n-    t$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn fuzzy_completions_come_in_specific_order() {\n-        cov_mark::check!(certain_fuzzy_order_test);\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub struct FirstStruct;\n-pub mod some_module {\n-    // already imported, omitted\n-    pub struct SecondStruct;\n-    // does not contain all letters from the query, omitted\n-    pub struct UnrelatedOne;\n-    // contains all letters from the query, but not in sequence, displayed last\n-    pub struct ThiiiiiirdStruct;\n-    // contains all letters from the query, but not in the beginning, displayed second\n-    pub struct AfterThirdStruct;\n-    // contains all letters from the query in the begginning, displayed first\n-    pub struct ThirdStruct;\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::{FirstStruct, some_module::SecondStruct};\n-\n-fn main() {\n-    hir$0\n-}\n-\"#,\n-            expect![[r#\"\n-                st ThirdStruct (use dep::some_module::ThirdStruct)\n-                st AfterThirdStruct (use dep::some_module::AfterThirdStruct)\n-                st ThiiiiiirdStruct (use dep::some_module::ThiiiiiirdStruct)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn trait_function_fuzzy_completion() {\n-        let fixture = r#\"\n-        //- /lib.rs crate:dep\n-        pub mod test_mod {\n-            pub trait TestTrait {\n-                const SPECIAL_CONST: u8;\n-                type HumbleType;\n-                fn weird_function();\n-                fn random_method(&self);\n-            }\n-            pub struct TestStruct {}\n-            impl TestTrait for TestStruct {\n-                const SPECIAL_CONST: u8 = 42;\n-                type HumbleType = ();\n-                fn weird_function() {}\n-                fn random_method(&self) {}\n-            }\n-        }\n-\n-        //- /main.rs crate:main deps:dep\n-        fn main() {\n-            dep::test_mod::TestStruct::wei$0\n-        }\n-        \"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-                fn weird_function() (use dep::test_mod::TestTrait) fn()\n-            \"#]],\n-        );\n-\n-        check_edit(\n-            \"weird_function\",\n-            fixture,\n-            r#\"\n-use dep::test_mod::TestTrait;\n-\n-fn main() {\n-    dep::test_mod::TestStruct::weird_function()$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn trait_const_fuzzy_completion() {\n-        let fixture = r#\"\n-        //- /lib.rs crate:dep\n-        pub mod test_mod {\n-            pub trait TestTrait {\n-                const SPECIAL_CONST: u8;\n-                type HumbleType;\n-                fn weird_function();\n-                fn random_method(&self);\n-            }\n-            pub struct TestStruct {}\n-            impl TestTrait for TestStruct {\n-                const SPECIAL_CONST: u8 = 42;\n-                type HumbleType = ();\n-                fn weird_function() {}\n-                fn random_method(&self) {}\n-            }\n-        }\n-\n-        //- /main.rs crate:main deps:dep\n-        fn main() {\n-            dep::test_mod::TestStruct::spe$0\n-        }\n-        \"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-            ct SPECIAL_CONST (use dep::test_mod::TestTrait)\n-        \"#]],\n-        );\n-\n-        check_edit(\n-            \"SPECIAL_CONST\",\n-            fixture,\n-            r#\"\n-use dep::test_mod::TestTrait;\n-\n-fn main() {\n-    dep::test_mod::TestStruct::SPECIAL_CONST\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn trait_method_fuzzy_completion() {\n-        let fixture = r#\"\n-        //- /lib.rs crate:dep\n-        pub mod test_mod {\n-            pub trait TestTrait {\n-                const SPECIAL_CONST: u8;\n-                type HumbleType;\n-                fn weird_function();\n-                fn random_method(&self);\n-            }\n-            pub struct TestStruct {}\n-            impl TestTrait for TestStruct {\n-                const SPECIAL_CONST: u8 = 42;\n-                type HumbleType = ();\n-                fn weird_function() {}\n-                fn random_method(&self) {}\n-            }\n-        }\n-\n-        //- /main.rs crate:main deps:dep\n-        fn main() {\n-            let test_struct = dep::test_mod::TestStruct {};\n-            test_struct.ran$0\n-        }\n-        \"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-                me random_method() (use dep::test_mod::TestTrait) fn(&self)\n-            \"#]],\n-        );\n-\n-        check_edit(\n-            \"random_method\",\n-            fixture,\n-            r#\"\n-use dep::test_mod::TestTrait;\n-\n-fn main() {\n-    let test_struct = dep::test_mod::TestStruct {};\n-    test_struct.random_method()$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_trait_type_fuzzy_completion() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    pub trait TestTrait {\n-        const SPECIAL_CONST: u8;\n-        type HumbleType;\n-        fn weird_function();\n-        fn random_method(&self);\n-    }\n-    pub struct TestStruct {}\n-    impl TestTrait for TestStruct {\n-        const SPECIAL_CONST: u8 = 42;\n-        type HumbleType = ();\n-        fn weird_function() {}\n-        fn random_method(&self) {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    dep::test_mod::TestStruct::hum$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn does_not_propose_names_in_scope() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    pub trait TestTrait {\n-        const SPECIAL_CONST: u8;\n-        type HumbleType;\n-        fn weird_function();\n-        fn random_method(&self);\n-    }\n-    pub struct TestStruct {}\n-    impl TestTrait for TestStruct {\n-        const SPECIAL_CONST: u8 = 42;\n-        type HumbleType = ();\n-        fn weird_function() {}\n-        fn random_method(&self) {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::test_mod::TestStruct;\n-fn main() {\n-    TestSt$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn does_not_propose_traits_in_scope() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    pub trait TestTrait {\n-        const SPECIAL_CONST: u8;\n-        type HumbleType;\n-        fn weird_function();\n-        fn random_method(&self);\n-    }\n-    pub struct TestStruct {}\n-    impl TestTrait for TestStruct {\n-        const SPECIAL_CONST: u8 = 42;\n-        type HumbleType = ();\n-        fn weird_function() {}\n-        fn random_method(&self) {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-use dep::test_mod::{TestStruct, TestTrait};\n-fn main() {\n-    dep::test_mod::TestStruct::hum$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn blanket_trait_impl_import() {\n-        check_edit(\n-            \"another_function\",\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    pub struct TestStruct {}\n-    pub trait TestTrait {\n-        fn another_function();\n-    }\n-    impl<T> TestTrait for T {\n-        fn another_function() {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    dep::test_mod::TestStruct::ano$0\n-}\n-\"#,\n-            r#\"\n-use dep::test_mod::TestTrait;\n-\n-fn main() {\n-    dep::test_mod::TestStruct::another_function()$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn zero_input_deprecated_assoc_item_completion() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    #[deprecated]\n-    pub trait TestTrait {\n-        const SPECIAL_CONST: u8;\n-        type HumbleType;\n-        fn weird_function();\n-        fn random_method(&self);\n-    }\n-    pub struct TestStruct {}\n-    impl TestTrait for TestStruct {\n-        const SPECIAL_CONST: u8 = 42;\n-        type HumbleType = ();\n-        fn weird_function() {}\n-        fn random_method(&self) {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    let test_struct = dep::test_mod::TestStruct {};\n-    test_struct.$0\n-}\n-        \"#,\n-            expect![[r#\"\n-                me random_method() (use dep::test_mod::TestTrait) fn(&self) DEPRECATED\n-            \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod test_mod {\n-    #[deprecated]\n-    pub trait TestTrait {\n-        const SPECIAL_CONST: u8;\n-        type HumbleType;\n-        fn weird_function();\n-        fn random_method(&self);\n-    }\n-    pub struct TestStruct {}\n-    impl TestTrait for TestStruct {\n-        const SPECIAL_CONST: u8 = 42;\n-        type HumbleType = ();\n-        fn weird_function() {}\n-        fn random_method(&self) {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:dep\n-fn main() {\n-    dep::test_mod::TestStruct::$0\n-}\n-\"#,\n-            expect![[r#\"\n-                fn weird_function() (use dep::test_mod::TestTrait) fn() DEPRECATED\n-                ct SPECIAL_CONST (use dep::test_mod::TestTrait) DEPRECATED\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn no_completions_in_use_statements() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:dep\n-pub mod io {\n-    pub fn stdin() {}\n-};\n-\n-//- /main.rs crate:main deps:dep\n-use stdi$0\n-\n-fn main() {}\n-\"#,\n-            expect![[]],\n-        );\n-    }\n-\n-    #[test]\n-    fn prefix_config_usage() {\n-        let fixture = r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-    }\n-}\n-\n-use crate::foo::bar;\n-\n-fn main() {\n-    Ite$0\n-}\"#;\n-        let mut config = TEST_CONFIG;\n-\n-        config.insert_use.prefix_kind = hir::PrefixKind::ByCrate;\n-        check_edit_with_config(\n-            config.clone(),\n-            \"Item\",\n-            fixture,\n-            r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-    }\n-}\n-\n-use crate::foo::bar::{self, Item};\n-\n-fn main() {\n-    Item\n-}\"#,\n-        );\n-\n-        config.insert_use.prefix_kind = hir::PrefixKind::BySelf;\n-        check_edit_with_config(\n-            config.clone(),\n-            \"Item\",\n-            fixture,\n-            r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-    }\n-}\n-\n-use crate::foo::bar;\n-\n-use self::foo::bar::Item;\n-\n-fn main() {\n-    Item\n-}\"#,\n-        );\n-\n-        config.insert_use.prefix_kind = hir::PrefixKind::Plain;\n-        check_edit_with_config(\n-            config,\n-            \"Item\",\n-            fixture,\n-            r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-    }\n-}\n-\n-use foo::bar::Item;\n-\n-use crate::foo::bar;\n-\n-fn main() {\n-    Item\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unresolved_qualifier() {\n-        let fixture = r#\"\n-mod foo {\n-    pub mod bar {\n-        pub mod baz {\n-            pub struct Item;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    bar::baz::Ite$0\n-}\"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-        st Item (use foo::bar::baz::Item)\n-        \"#]],\n-        );\n-\n-        check_edit(\n-            \"Item\",\n-            fixture,\n-            r#\"\n-        use foo::bar;\n-\n-        mod foo {\n-            pub mod bar {\n-                pub mod baz {\n-                    pub struct Item;\n-                }\n-            }\n-        }\n-\n-        fn main() {\n-            bar::baz::Item\n-        }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unresolved_assoc_item_container() {\n-        let fixture = r#\"\n-mod foo {\n-    pub struct Item;\n-\n-    impl Item {\n-        pub const TEST_ASSOC: usize = 3;\n-    }\n-}\n-\n-fn main() {\n-    Item::TEST_A$0\n-}\"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-        ct TEST_ASSOC (use foo::Item)\n-        \"#]],\n-        );\n-\n-        check_edit(\n-            \"TEST_ASSOC\",\n-            fixture,\n-            r#\"\n-use foo::Item;\n-\n-mod foo {\n-    pub struct Item;\n-\n-    impl Item {\n-        pub const TEST_ASSOC: usize = 3;\n-    }\n-}\n-\n-fn main() {\n-    Item::TEST_ASSOC\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unresolved_assoc_item_container_with_path() {\n-        let fixture = r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-\n-        impl Item {\n-            pub const TEST_ASSOC: usize = 3;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    bar::Item::TEST_A$0\n-}\"#;\n-\n-        check(\n-            fixture,\n-            expect![[r#\"\n-        ct TEST_ASSOC (use foo::bar::Item)\n-    \"#]],\n-        );\n-\n-        check_edit(\n-            \"TEST_ASSOC\",\n-            fixture,\n-            r#\"\n-use foo::bar;\n-\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-\n-        impl Item {\n-            pub const TEST_ASSOC: usize = 3;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    bar::Item::TEST_ASSOC\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn fuzzy_unresolved_path() {\n-        check(\n-            r#\"\n-mod foo {\n-    pub mod bar {\n-        pub struct Item;\n-\n-        impl Item {\n-            pub const TEST_ASSOC: usize = 3;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    bar::ASS$0\n-}\"#,\n-            expect![[]],\n-        )\n-    }\n-\n-    #[test]\n-    fn unqualified_assoc_items_are_omitted() {\n-        check(\n-            r#\"\n-mod something {\n-    pub trait BaseTrait {\n-        fn test_function() -> i32;\n-    }\n-\n-    pub struct Item1;\n-    pub struct Item2;\n-\n-    impl BaseTrait for Item1 {\n-        fn test_function() -> i32 {\n-            1\n-        }\n-    }\n-\n-    impl BaseTrait for Item2 {\n-        fn test_function() -> i32 {\n-            2\n-        }\n-    }\n-}\n-\n-fn main() {\n-    test_f$0\n-}\"#,\n-            expect![[]],\n-        )\n-    }\n-\n-    #[test]\n-    fn case_matters() {\n-        check(\n-            r#\"\n-mod foo {\n-    pub const TEST_CONST: usize = 3;\n-    pub fn test_function() -> i32 {\n-        4\n-    }\n-}\n-\n-fn main() {\n-    TE$0\n-}\"#,\n-            expect![[r#\"\n-        ct TEST_CONST (use foo::TEST_CONST)\n-    \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-mod foo {\n-    pub const TEST_CONST: usize = 3;\n-    pub fn test_function() -> i32 {\n-        4\n-    }\n-}\n-\n-fn main() {\n-    te$0\n-}\"#,\n-            expect![[r#\"\n-        ct TEST_CONST (use foo::TEST_CONST)\n-        fn test_function() (use foo::test_function) fn() -> i32\n-    \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-mod foo {\n-    pub const TEST_CONST: usize = 3;\n-    pub fn test_function() -> i32 {\n-        4\n-    }\n-}\n-\n-fn main() {\n-    Te$0\n-}\"#,\n-            expect![[]],\n-        );\n-    }\n-\n-    #[test]\n-    fn no_fuzzy_during_fields_of_record_lit_syntax() {\n-        check(\n-            r#\"\n-mod m {\n-    pub fn some_fn() -> i32 {\n-        42\n-    }\n-}\n-struct Foo {\n-    some_field: i32,\n-}\n-fn main() {\n-    let _ = Foo { so$0 };\n-}\n-\"#,\n-            expect![[]],\n-        );\n-    }\n-\n-    #[test]\n-    fn fuzzy_after_fields_of_record_lit_syntax() {\n-        check(\n-            r#\"\n-mod m {\n-    pub fn some_fn() -> i32 {\n-        42\n-    }\n-}\n-struct Foo {\n-    some_field: i32,\n-}\n-fn main() {\n-    let _ = Foo { some_field: so$0 };\n-}\n-\"#,\n-            expect![[r#\"\n-                fn some_fn() (use m::some_fn) fn() -> i32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn no_flyimports_in_traits_and_impl_declarations() {\n-        check(\n-            r#\"\n-mod m {\n-    pub fn some_fn() -> i32 {\n-        42\n-    }\n-}\n-trait Foo {\n-    som$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-\n-        check(\n-            r#\"\n-mod m {\n-    pub fn some_fn() -> i32 {\n-        42\n-    }\n-}\n-struct Foo;\n-impl Foo {\n-    som$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-\n-        check(\n-            r#\"\n-mod m {\n-    pub fn some_fn() -> i32 {\n-        42\n-    }\n-}\n-struct Foo;\n-trait Bar {}\n-impl Bar for Foo {\n-    som$0\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn no_inherent_candidates_proposed() {\n-        check(\n-            r#\"\n-mod baz {\n-    pub trait DefDatabase {\n-        fn method1(&self);\n-    }\n-    pub trait HirDatabase: DefDatabase {\n-        fn method2(&self);\n-    }\n-}\n-\n-mod bar {\n-    fn test(db: &dyn crate::baz::HirDatabase) {\n-        db.metho$0\n-    }\n-}\n-            \"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn respects_doc_hidden() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:lib deps:dep\n-fn f() {\n-    ().fro$0\n-}\n-\n-//- /dep.rs crate:dep\n-#[doc(hidden)]\n-pub trait Private {\n-    fn frob(&self) {}\n-}\n-\n-impl<T> Private for T {}\n-            \"#,\n-            expect![[r#\"\"#]],\n-        );\n-        check(\n-            r#\"\n-//- /lib.rs crate:lib deps:dep\n-fn f() {\n-    ().fro$0\n-}\n-\n-//- /dep.rs crate:dep\n-pub trait Private {\n-    #[doc(hidden)]\n-    fn frob(&self) {}\n-}\n-\n-impl<T> Private for T {}\n-            \"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn regression_9760() {\n-        check(\n-            r#\"\n-struct Struct;\n-fn main() {}\n-\n-mod mud {\n-    fn func() {\n-        let struct_instance = Stru$0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                st Struct (use crate::Struct)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn flyimport_pattern() {\n-        check(\n-            r#\"\n-mod module {\n-    pub struct Struct;\n-}\n-fn function() {\n-    let Str$0\n-}\n-\"#,\n-            expect![[r#\"\n-                st Struct (use module::Struct)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn flyimport_rename() {\n-        check(\n-            r#\"\n-mod module {\n-    pub struct Struct;\n-}\n-use self as Str$0;\n-    \"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-}"}, {"sha": "e910c1daaadaca994d9f0f6b33e69d2b607d49bd", "filename": "crates/ide_completion/src/completions/fn_param.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -8,7 +8,7 @@ use syntax::{\n \n use crate::{\n     context::{ParamKind, PatternContext},\n-    CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n+    CompletionContext, CompletionItem, CompletionItemKind, Completions,\n };\n \n /// Complete repeated parameters, both name and type. For example, if all\n@@ -75,7 +75,7 @@ fn add_new_item_to_acc(\n     label: String,\n     lookup: String,\n ) {\n-    let mut item = CompletionItem::new(CompletionKind::Magic, ctx.source_range(), label);\n-    item.kind(CompletionItemKind::Binding).lookup_by(lookup);\n+    let mut item = CompletionItem::new(CompletionItemKind::Binding, ctx.source_range(), label);\n+    item.lookup_by(lookup);\n     item.add_to(acc)\n }"}, {"sha": "afb8df29116818fefdc0abb1411d3069de031ef3", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 31, "deletions": 269, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -6,7 +6,7 @@ use syntax::{SyntaxKind, T};\n \n use crate::{\n     context::PathCompletionContext, patterns::ImmediateLocation, CompletionContext, CompletionItem,\n-    CompletionItemKind, CompletionKind, Completions,\n+    CompletionItemKind, Completions,\n };\n \n pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -158,8 +158,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n }\n \n fn add_keyword(ctx: &CompletionContext, acc: &mut Completions, kw: &str, snippet: &str) {\n-    let mut item = CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), kw);\n-    item.kind(CompletionItemKind::Keyword);\n+    let mut item = CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), kw);\n \n     match ctx.config.snippet_cap {\n         Some(cap) => {\n@@ -181,115 +180,15 @@ fn add_keyword(ctx: &CompletionContext, acc: &mut Completions, kw: &str, snippet\n mod tests {\n     use expect_test::{expect, Expect};\n \n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n+    use crate::tests::{check_edit, completion_list};\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Keyword);\n+        let actual = completion_list(ra_fixture);\n         expect.assert_eq(&actual)\n     }\n \n     #[test]\n-    fn test_keywords_in_function() {\n-        check(\n-            r\"fn quux() { $0 }\",\n-            expect![[r#\"\n-                kw unsafe\n-                kw fn\n-                kw const\n-                kw type\n-                kw impl\n-                kw extern\n-                kw use\n-                kw trait\n-                kw static\n-                kw mod\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw let\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_keywords_inside_block() {\n-        check(\n-            r\"fn quux() { if true { $0 } }\",\n-            expect![[r#\"\n-                kw unsafe\n-                kw fn\n-                kw const\n-                kw type\n-                kw impl\n-                kw extern\n-                kw use\n-                kw trait\n-                kw static\n-                kw mod\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw let\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_keywords_after_if() {\n-        check(\n-            r#\"fn quux() { if true { () } $0 }\"#,\n-            expect![[r#\"\n-                kw unsafe\n-                kw fn\n-                kw const\n-                kw type\n-                kw impl\n-                kw extern\n-                kw use\n-                kw trait\n-                kw static\n-                kw mod\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw let\n-                kw else\n-                kw else if\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n+    fn test_else_edit_after_if() {\n         check_edit(\n             \"else\",\n             r#\"fn quux() { if true { () } $0 }\"#,\n@@ -299,68 +198,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn test_keywords_in_match_arm() {\n-        check(\n-            r#\"\n-fn quux() -> i32 {\n-    match () { () => $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                kw unsafe\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_keywords_in_loop() {\n-        check(\n-            r\"fn my() { loop { $0 } }\",\n-            expect![[r#\"\n-                kw unsafe\n-                kw fn\n-                kw const\n-                kw type\n-                kw impl\n-                kw extern\n-                kw use\n-                kw trait\n-                kw static\n-                kw mod\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw let\n-                kw continue\n-                kw break\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn test_keywords_after_unsafe_in_block_expr() {\n         check(\n@@ -369,38 +206,12 @@ fn quux() -> i32 {\n                 kw fn\n                 kw trait\n                 kw impl\n+                sn pd\n+                sn ppd\n             \"#]],\n         );\n     }\n \n-    #[test]\n-    fn no_keyword_completion_in_comments() {\n-        cov_mark::check!(no_keyword_completion_in_comments);\n-        check(\n-            r#\"\n-fn test() {\n-    let x = 2; // A comment$0\n-}\n-\"#,\n-            expect![[\"\"]],\n-        );\n-        check(\n-            r#\"\n-/*\n-Some multi-line comment$0\n-*/\n-\"#,\n-            expect![[\"\"]],\n-        );\n-        check(\n-            r#\"\n-/// Some doc comment\n-/// let test$0 = 1\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n     #[test]\n     fn test_completion_await_impls_future() {\n         check(\n@@ -413,6 +224,18 @@ fn foo(a: A) { a.$0 }\n \"#,\n             expect![[r#\"\n                 kw await expr.await\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n             \"#]],\n         );\n \n@@ -427,83 +250,22 @@ fn foo() {\n \"#,\n             expect![[r#\"\n                 kw await expr.await\n+                sn ref   &expr\n+                sn refm  &mut expr\n+                sn match match expr {}\n+                sn box   Box::new(expr)\n+                sn ok    Ok(expr)\n+                sn err   Err(expr)\n+                sn some  Some(expr)\n+                sn dbg   dbg!(expr)\n+                sn dbgr  dbg!(&expr)\n+                sn call  function(expr)\n+                sn let   let\n+                sn letm  let mut\n             \"#]],\n         )\n     }\n \n-    #[test]\n-    fn after_let() {\n-        check(\n-            r#\"fn main() { let _ = $0 }\"#,\n-            expect![[r#\"\n-                kw unsafe\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn skip_struct_initializer() {\n-        cov_mark::check!(no_keyword_completion_in_record_lit);\n-        check(\n-            r#\"\n-struct Foo {\n-    pub f: i32,\n-}\n-fn foo() {\n-    Foo {\n-        $0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn struct_initializer_field_expr() {\n-        check(\n-            r#\"\n-struct Foo {\n-    pub f: i32,\n-}\n-fn foo() {\n-    Foo {\n-        f: $0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                kw unsafe\n-                kw match\n-                kw while\n-                kw while let\n-                kw loop\n-                kw if\n-                kw if let\n-                kw for\n-                kw true\n-                kw false\n-                kw return\n-                kw self\n-                kw super\n-                kw crate\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn let_semi() {\n         cov_mark::check!(let_semi);"}, {"sha": "28be83f196aded7896ef1b4d8a6fa32f84eacf00", "filename": "crates/ide_completion/src/completions/mod_.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -11,7 +11,7 @@ use rustc_hash::FxHashSet;\n \n use crate::{patterns::ImmediateLocation, CompletionItem};\n \n-use crate::{context::CompletionContext, item::CompletionKind, Completions};\n+use crate::{context::CompletionContext, Completions};\n \n /// Complete mod declaration, i.e. `mod $0 ;`\n pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n@@ -80,8 +80,7 @@ pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Op\n             if mod_under_caret.semicolon_token().is_none() {\n                 label.push(';');\n             }\n-            let mut item = CompletionItem::new(CompletionKind::Magic, ctx.source_range(), &label);\n-            item.kind(SymbolKind::Module);\n+            let item = CompletionItem::new(SymbolKind::Module, ctx.source_range(), &label);\n             item.add_to(acc)\n         });\n \n@@ -141,9 +140,10 @@ fn module_chain_to_containing_module_file(\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::completion_list;\n     use expect_test::{expect, Expect};\n \n+    use crate::tests::completion_list;\n+\n     fn check(ra_fixture: &str, expect: Expect) {\n         let actual = completion_list(ra_fixture);\n         expect.assert_eq(&actual);"}, {"sha": "4ee257ab43ae899237d7c00adc3e857bbde5b3e5", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -15,11 +15,9 @@ use syntax::{\n use text_edit::TextEdit;\n \n use crate::{\n-    completions::postfix::format_like::add_format_like_completions,\n-    context::CompletionContext,\n-    item::{Builder, CompletionKind},\n-    patterns::ImmediateLocation,\n-    CompletionItem, CompletionItemKind, CompletionRelevance, Completions, SnippetScope,\n+    completions::postfix::format_like::add_format_like_completions, context::CompletionContext,\n+    item::Builder, patterns::ImmediateLocation, CompletionItem, CompletionItemKind,\n+    CompletionRelevance, Completions, SnippetScope,\n };\n \n pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -45,8 +43,9 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n \n     // Suggest .await syntax for types that implement Future trait\n     if receiver_ty.impls_future(ctx.db) {\n-        let mut item = CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), \"await\");\n-        item.kind(CompletionItemKind::Keyword).detail(\"expr.await\");\n+        let mut item =\n+            CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), \"await\");\n+        item.detail(\"expr.await\");\n         item.add_to(acc);\n     }\n \n@@ -224,8 +223,9 @@ fn build_postfix_snippet_builder<'ctx>(\n     ) -> impl Fn(&str, &str, &str) -> Builder + 'ctx {\n         move |label, detail, snippet| {\n             let edit = TextEdit::replace(delete_range, snippet.to_string());\n-            let mut item = CompletionItem::new(CompletionKind::Postfix, ctx.source_range(), label);\n-            item.detail(detail).kind(CompletionItemKind::Snippet).snippet_edit(cap, edit);\n+            let mut item =\n+                CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), label);\n+            item.detail(detail).snippet_edit(cap, edit);\n             if ctx.original_token.text() == label {\n                 let relevance =\n                     CompletionRelevance { exact_postfix_snippet_match: true, ..Default::default() };\n@@ -270,12 +270,12 @@ mod tests {\n     use expect_test::{expect, Expect};\n \n     use crate::{\n-        tests::{check_edit, check_edit_with_config, filtered_completion_list, TEST_CONFIG},\n-        CompletionConfig, CompletionKind, Snippet,\n+        tests::{check_edit, check_edit_with_config, completion_list, TEST_CONFIG},\n+        CompletionConfig, Snippet,\n     };\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Postfix);\n+        let actual = completion_list(ra_fixture);\n         expect.assert_eq(&actual)\n     }\n "}, {"sha": "e9d39edc43a28a48f047688d77c2a957109cb694", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -250,13 +250,10 @@ fn add_enum_variants(acc: &mut Completions, ctx: &CompletionContext, e: hir::Enu\n mod tests {\n     use expect_test::{expect, Expect};\n \n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n+    use crate::tests::{check_edit, completion_list_no_kw};\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Reference);\n+        let actual = completion_list_no_kw(ra_fixture);\n         expect.assert_eq(&actual);\n     }\n "}, {"sha": "f0c81f66bc8d14255e8a596e416bef42730702e2", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -3,8 +3,7 @@ use ide_db::{helpers::FamousDefs, SymbolKind};\n use syntax::{ast::Expr, T};\n \n use crate::{\n-    item::CompletionKind, patterns::ImmediateLocation, CompletionContext, CompletionItem,\n-    CompletionItemKind, Completions,\n+    patterns::ImmediateLocation, CompletionContext, CompletionItem, CompletionItemKind, Completions,\n };\n \n pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n@@ -22,20 +21,17 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n             let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n             if impl_default_trait && !missing_fields.is_empty() && ctx.path_qual().is_none() {\n                 let completion_text = \"..Default::default()\";\n-                let mut item = CompletionItem::new(\n-                    CompletionKind::Snippet,\n-                    ctx.source_range(),\n-                    completion_text,\n-                );\n+                let mut item =\n+                    CompletionItem::new(SymbolKind::Field, ctx.source_range(), completion_text);\n                 let completion_text =\n                     completion_text.strip_prefix(ctx.token.text()).unwrap_or(completion_text);\n-                item.insert_text(completion_text).kind(SymbolKind::Field);\n+                item.insert_text(completion_text);\n                 item.add_to(acc);\n             }\n             if ctx.previous_token_is(T![.]) {\n                 let mut item =\n-                    CompletionItem::new(CompletionKind::Snippet, ctx.source_range(), \"..\");\n-                item.insert_text(\".\").kind(CompletionItemKind::Snippet);\n+                    CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), \"..\");\n+                item.insert_text(\".\");\n                 item.add_to(acc);\n                 return None;\n             }"}, {"sha": "1840e780edf8f4fd06c4940dd315d2e98eb97fb0", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -6,12 +6,12 @@ use syntax::T;\n \n use crate::{\n     context::PathCompletionContext, item::Builder, CompletionContext, CompletionItem,\n-    CompletionItemKind, CompletionKind, Completions, SnippetScope,\n+    CompletionItemKind, Completions, SnippetScope,\n };\n \n fn snippet(ctx: &CompletionContext, cap: SnippetCap, label: &str, snippet: &str) -> Builder {\n-    let mut item = CompletionItem::new(CompletionKind::Snippet, ctx.source_range(), label);\n-    item.insert_snippet(cap, snippet).kind(CompletionItemKind::Snippet);\n+    let mut item = CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), label);\n+    item.insert_snippet(cap, snippet);\n     item\n }\n "}, {"sha": "fc6ef5839c89cc6ac97c7189ebfa8e0f4a6e1992", "filename": "crates/ide_completion/src/completions/trait_impl.rs", "status": "modified", "additions": 54, "deletions": 24, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -40,7 +40,7 @@ use syntax::{\n };\n use text_edit::TextEdit;\n \n-use crate::{CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions};\n+use crate::{CompletionContext, CompletionItem, CompletionItemKind, Completions};\n \n #[derive(Debug, PartialEq, Eq)]\n enum ImplCompletionKind {\n@@ -141,14 +141,14 @@ fn add_function_impl(\n         format!(\"fn {}(..)\", fn_name)\n     };\n \n-    let mut item = CompletionItem::new(CompletionKind::Magic, ctx.source_range(), label);\n-    item.lookup_by(fn_name).set_documentation(func.docs(ctx.db));\n-\n     let completion_kind = if func.self_param(ctx.db).is_some() {\n         CompletionItemKind::Method\n     } else {\n         CompletionItemKind::SymbolKind(SymbolKind::Function)\n     };\n+    let mut item = CompletionItem::new(completion_kind, ctx.source_range(), label);\n+    item.lookup_by(fn_name).set_documentation(func.docs(ctx.db));\n+\n     let range = replacement_range(ctx, fn_def_node);\n \n     if let Some(source) = func.source(ctx.db) {\n@@ -170,7 +170,6 @@ fn add_function_impl(\n                     item.text_edit(TextEdit::replace(range, header));\n                 }\n             };\n-            item.kind(completion_kind);\n             item.add_to(acc);\n         }\n     }\n@@ -211,10 +210,9 @@ fn add_type_alias_impl(\n     let snippet = format!(\"type {} = \", alias_name);\n \n     let range = replacement_range(ctx, type_def_node);\n-    let mut item = CompletionItem::new(CompletionKind::Magic, ctx.source_range(), snippet.clone());\n+    let mut item = CompletionItem::new(SymbolKind::TypeAlias, ctx.source_range(), snippet.clone());\n     item.text_edit(TextEdit::replace(range, snippet))\n         .lookup_by(alias_name)\n-        .kind(SymbolKind::TypeAlias)\n         .set_documentation(type_alias.docs(ctx.db));\n     item.add_to(acc);\n }\n@@ -241,10 +239,9 @@ fn add_const_impl(\n \n                 let range = replacement_range(ctx, const_def_node);\n                 let mut item =\n-                    CompletionItem::new(CompletionKind::Magic, ctx.source_range(), snippet.clone());\n+                    CompletionItem::new(SymbolKind::Const, ctx.source_range(), snippet.clone());\n                 item.text_edit(TextEdit::replace(range, snippet))\n                     .lookup_by(const_name)\n-                    .kind(SymbolKind::Const)\n                     .set_documentation(const_.docs(ctx.db));\n                 item.add_to(acc);\n             }\n@@ -290,13 +287,10 @@ fn replacement_range(ctx: &CompletionContext, item: &SyntaxNode) -> TextRange {\n mod tests {\n     use expect_test::{expect, Expect};\n \n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n+    use crate::tests::{check_edit, completion_list_no_kw};\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Magic);\n+        let actual = completion_list_no_kw(ra_fixture);\n         expect.assert_eq(&actual)\n     }\n \n@@ -313,7 +307,12 @@ impl Test for T {\n     }\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n \n         check(\n@@ -356,7 +355,7 @@ impl Test for T {\n     }\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\"#]],\n         );\n \n         check(\n@@ -368,7 +367,10 @@ impl Test for T {\n     fn test(t$0)\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                st T\n+            \"#]],\n         );\n \n         check(\n@@ -380,7 +382,10 @@ impl Test for T {\n     fn test(f: fn $0)\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                st T\n+            \"#]],\n         );\n     }\n \n@@ -395,7 +400,7 @@ impl Test for T {\n     const TEST: fn $0\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\"#]],\n         );\n \n         check(\n@@ -407,7 +412,12 @@ impl Test for T {\n     const TEST: T$0\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n \n         check(\n@@ -419,7 +429,12 @@ impl Test for T {\n     const TEST: u32 = f$0\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n \n         check(\n@@ -433,7 +448,12 @@ impl Test for T {\n     };\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n \n         check(\n@@ -476,7 +496,12 @@ impl Test for T {\n     type Test = T$0;\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n \n         check(\n@@ -488,7 +513,12 @@ impl Test for T {\n     type Test = fn $0;\n }\n \",\n-            expect![[\"\"]],\n+            expect![[r#\"\n+                sp Self\n+                tt Test\n+                st T\n+                bt u32\n+            \"#]],\n         );\n     }\n "}, {"sha": "825fae587b1d3084ab14e4b79a4bc50b088a41a2", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -117,24 +117,15 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n mod tests {\n     use expect_test::{expect, Expect};\n \n-    use crate::{\n-        tests::{check_edit, filtered_completion_list_with_config, TEST_CONFIG},\n-        CompletionConfig, CompletionKind,\n-    };\n+    use crate::tests::{check_edit, completion_list_no_kw};\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        check_with_config(TEST_CONFIG, ra_fixture, expect);\n-    }\n-\n-    fn check_with_config(config: CompletionConfig, ra_fixture: &str, expect: Expect) {\n-        let actual =\n-            filtered_completion_list_with_config(config, ra_fixture, CompletionKind::Reference);\n+        let actual = completion_list_no_kw(ra_fixture);\n         expect.assert_eq(&actual)\n     }\n \n     #[test]\n     fn completes_if_prefix_is_keyword() {\n-        cov_mark::check!(completes_if_prefix_is_keyword);\n         check_edit(\n             \"wherewolf\",\n             r#\"\n@@ -188,6 +179,7 @@ pub mod prelude {\n \"#,\n             expect![[r#\"\n                 md std\n+                bt u32\n                 st Option\n             \"#]],\n         );\n@@ -217,6 +209,7 @@ mod macros {\n                 fn f()        fn()\n                 ma concat!(\u2026) #[macro_export] macro_rules! concat\n                 md std\n+                bt u32\n             \"##]],\n         );\n     }\n@@ -245,6 +238,7 @@ pub mod prelude {\n             expect![[r#\"\n                 md std\n                 md core\n+                bt u32\n                 st String\n             \"#]],\n         );\n@@ -273,6 +267,7 @@ pub mod prelude {\n             expect![[r#\"\n                 fn f() fn()\n                 md std\n+                bt u32\n             \"#]],\n         );\n     }"}, {"sha": "0cb484d50755d4a4b868d7f6ff37595db7121e2b", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -134,7 +134,6 @@ impl<'a> CompletionContext<'a> {\n         // check kind of macro-expanded token, but use range of original token\n         let kind = self.token.kind();\n         if kind == IDENT || kind == LIFETIME_IDENT || kind == UNDERSCORE || kind.is_keyword() {\n-            cov_mark::hit!(completes_if_prefix_is_keyword);\n             self.original_token.text_range()\n         } else if kind == CHAR {\n             // assume we are completing a lifetime but the user has only typed the '"}, {"sha": "3f0accfbe17fa5fd9b8b987f449a5f6972ff68ac", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -21,10 +21,6 @@ use text_edit::TextEdit;\n /// `CompletionItem`, use `new` method and the `Builder` struct.\n #[derive(Clone)]\n pub struct CompletionItem {\n-    /// Used only internally in tests, to check only specific kind of\n-    /// completion (postfix, keyword, reference, etc).\n-    #[allow(unused)]\n-    pub(crate) completion_kind: CompletionKind,\n     /// Label in the completion pop up which identifies completion.\n     label: String,\n     /// Range of identifier that is being completed.\n@@ -43,7 +39,7 @@ pub struct CompletionItem {\n     is_snippet: bool,\n \n     /// What item (struct, function, etc) are we completing.\n-    kind: Option<CompletionItemKind>,\n+    kind: CompletionItemKind,\n \n     /// Lookup is used to check if completion item indeed can complete current\n     /// ident.\n@@ -92,9 +88,7 @@ impl fmt::Debug for CompletionItem {\n         } else {\n             s.field(\"text_edit\", &self.text_edit);\n         }\n-        if let Some(kind) = self.kind().as_ref() {\n-            s.field(\"kind\", kind);\n-        }\n+        s.field(\"kind\", &self.kind());\n         if self.lookup() != self.label() {\n             s.field(\"lookup\", &self.lookup());\n         }\n@@ -270,40 +264,23 @@ impl CompletionItemKind {\n     }\n }\n \n-// FIXME remove this?\n-/// Like [`CompletionItemKind`] but solely used for filtering test results.\n-#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n-pub(crate) enum CompletionKind {\n-    /// Parser-based keyword completion.\n-    Keyword,\n-    /// Your usual \"complete all valid identifiers\".\n-    Reference,\n-    /// \"Secret sauce\" completions.\n-    Magic,\n-    Snippet,\n-    Postfix,\n-    BuiltinType,\n-    Attribute,\n-}\n-\n impl CompletionItem {\n     pub(crate) fn new(\n-        completion_kind: CompletionKind,\n+        kind: impl Into<CompletionItemKind>,\n         source_range: TextRange,\n         label: impl Into<String>,\n     ) -> Builder {\n         let label = label.into();\n         Builder {\n             source_range,\n-            completion_kind,\n             label,\n             insert_text: None,\n             is_snippet: false,\n             trait_name: None,\n             detail: None,\n             documentation: None,\n             lookup: None,\n-            kind: None,\n+            kind: kind.into(),\n             text_edit: None,\n             deprecated: false,\n             trigger_call_info: None,\n@@ -342,7 +319,7 @@ impl CompletionItem {\n         self.lookup.as_deref().unwrap_or(&self.label)\n     }\n \n-    pub fn kind(&self) -> Option<CompletionItemKind> {\n+    pub fn kind(&self) -> CompletionItemKind {\n         self.kind\n     }\n \n@@ -401,7 +378,6 @@ impl ImportEdit {\n #[derive(Clone)]\n pub(crate) struct Builder {\n     source_range: TextRange,\n-    completion_kind: CompletionKind,\n     imports_to_add: SmallVec<[ImportEdit; 1]>,\n     trait_name: Option<String>,\n     label: String,\n@@ -410,7 +386,7 @@ pub(crate) struct Builder {\n     detail: Option<String>,\n     documentation: Option<Documentation>,\n     lookup: Option<String>,\n-    kind: Option<CompletionItemKind>,\n+    kind: CompletionItemKind,\n     text_edit: Option<TextEdit>,\n     deprecated: bool,\n     trigger_call_info: Option<bool>,\n@@ -454,7 +430,6 @@ impl Builder {\n             documentation: self.documentation,\n             lookup,\n             kind: self.kind,\n-            completion_kind: self.completion_kind,\n             deprecated: self.deprecated,\n             trigger_call_info: self.trigger_call_info.unwrap_or(false),\n             relevance: self.relevance,\n@@ -487,10 +462,6 @@ impl Builder {\n         self.is_snippet = true;\n         self.insert_text(snippet)\n     }\n-    pub(crate) fn kind(&mut self, kind: impl Into<CompletionItemKind>) -> &mut Builder {\n-        self.kind = Some(kind.into());\n-        self\n-    }\n     pub(crate) fn text_edit(&mut self, edit: TextEdit) -> &mut Builder {\n         self.text_edit = Some(edit);\n         self"}, {"sha": "d555eff878c7a5c789477bcf84f92a2e39758508", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -24,7 +24,7 @@ use ide_db::{\n use syntax::algo;\n use text_edit::TextEdit;\n \n-use crate::{completions::Completions, context::CompletionContext, item::CompletionKind};\n+use crate::{completions::Completions, context::CompletionContext};\n \n pub use crate::{\n     config::CompletionConfig,"}, {"sha": "4180d704a3084a70e00c4ab60e309d284b799aad", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 96, "deletions": 73, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -22,7 +22,7 @@ use crate::{\n     context::{PathCompletionContext, PathKind},\n     item::{CompletionRelevanceTypeMatch, ImportEdit},\n     render::{enum_variant::render_variant, function::render_fn, macro_::render_macro},\n-    CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, CompletionRelevance,\n+    CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n };\n /// Interface for data and methods required for items rendering.\n #[derive(Debug)]\n@@ -85,7 +85,7 @@ pub(crate) fn render_field(\n     let is_deprecated = ctx.is_deprecated(field);\n     let name = field.name(ctx.db()).to_string();\n     let mut item = CompletionItem::new(\n-        CompletionKind::Reference,\n+        SymbolKind::Field,\n         ctx.source_range(),\n         receiver.map_or_else(|| name.clone(), |receiver| format!(\"{}.{}\", receiver, name)),\n     );\n@@ -94,8 +94,7 @@ pub(crate) fn render_field(\n         exact_name_match: compute_exact_name_match(ctx.completion, name.as_str()),\n         ..CompletionRelevance::default()\n     });\n-    item.kind(SymbolKind::Field)\n-        .detail(ty.display(ctx.db()).to_string())\n+    item.detail(ty.display(ctx.db()).to_string())\n         .set_documentation(field.docs(ctx.db()))\n         .set_deprecated(is_deprecated)\n         .lookup_by(name.as_str());\n@@ -118,13 +117,11 @@ pub(crate) fn render_tuple_field(\n     ty: &hir::Type,\n ) -> CompletionItem {\n     let mut item = CompletionItem::new(\n-        CompletionKind::Reference,\n+        SymbolKind::Field,\n         ctx.source_range(),\n         receiver.map_or_else(|| field.to_string(), |receiver| format!(\"{}.{}\", receiver, field)),\n     );\n-    item.kind(SymbolKind::Field)\n-        .detail(ty.display(ctx.db()).to_string())\n-        .lookup_by(field.to_string());\n+    item.detail(ty.display(ctx.db()).to_string()).lookup_by(field.to_string());\n     item.build()\n }\n \n@@ -147,10 +144,7 @@ pub(crate) fn render_resolution_with_import(\n         hir::ScopeDef::ModuleDef(hir::ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db),\n         _ => item_name(ctx.db(), import_edit.import.original_item)?,\n     };\n-    render_resolution_(ctx, local_name, Some(import_edit), &resolution).map(|mut item| {\n-        item.completion_kind = CompletionKind::Magic;\n-        item\n-    })\n+    render_resolution_(ctx, local_name, Some(import_edit), &resolution)\n }\n \n fn render_resolution_(\n@@ -162,11 +156,6 @@ fn render_resolution_(\n     let _p = profile::span(\"render_resolution\");\n     use hir::ModuleDef::*;\n \n-    let completion_kind = match resolution {\n-        hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n-        _ => CompletionKind::Reference,\n-    };\n-\n     let kind = match resolution {\n         hir::ScopeDef::ModuleDef(Function(func)) => {\n             return render_fn(ctx, import_to_add, Some(local_name), *func);\n@@ -208,11 +197,10 @@ fn render_resolution_(\n         }\n         hir::ScopeDef::Unknown => {\n             let mut item = CompletionItem::new(\n-                CompletionKind::Reference,\n+                CompletionItemKind::UnresolvedReference,\n                 ctx.source_range(),\n                 local_name.to_string(),\n             );\n-            item.kind(CompletionItemKind::UnresolvedReference);\n             if let Some(import_to_add) = import_to_add {\n                 item.add_import(import_to_add);\n             }\n@@ -221,7 +209,7 @@ fn render_resolution_(\n     };\n \n     let local_name = local_name.to_string();\n-    let mut item = CompletionItem::new(completion_kind, ctx.source_range(), local_name.clone());\n+    let mut item = CompletionItem::new(kind, ctx.source_range(), local_name.clone());\n     if let hir::ScopeDef::Local(local) = resolution {\n         let ty = local.ty(ctx.db());\n         if !ty.is_unknown() {\n@@ -260,8 +248,7 @@ fn render_resolution_(\n             }\n         }\n     }\n-    item.kind(kind)\n-        .set_documentation(scope_def_docs(ctx.db(), resolution))\n+    item.set_documentation(scope_def_docs(ctx.db(), resolution))\n         .set_deprecated(scope_def_is_deprecated(&ctx, resolution));\n \n     if let Some(import_to_add) = import_to_add {\n@@ -344,37 +331,54 @@ mod tests {\n     use std::cmp;\n \n     use expect_test::{expect, Expect};\n+    use ide_db::SymbolKind;\n     use itertools::Itertools;\n \n     use crate::{\n         item::CompletionRelevanceTypeMatch,\n         tests::{check_edit, do_completion, get_all_items, TEST_CONFIG},\n-        CompletionKind, CompletionRelevance,\n+        CompletionItem, CompletionItemKind, CompletionRelevance,\n     };\n \n     #[track_caller]\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = do_completion(ra_fixture, CompletionKind::Reference);\n+    fn check(ra_fixture: &str, kind: impl Into<CompletionItemKind>, expect: Expect) {\n+        let actual = do_completion(ra_fixture, kind.into());\n         expect.assert_debug_eq(&actual);\n     }\n \n     #[track_caller]\n-    fn check_relevance(ra_fixture: &str, expect: Expect) {\n-        check_relevance_for_kinds(&[CompletionKind::Reference], ra_fixture, expect)\n+    fn check_kinds(ra_fixture: &str, kinds: &[CompletionItemKind], expect: Expect) {\n+        let actual: Vec<_> =\n+            kinds.iter().flat_map(|&kind| do_completion(ra_fixture, kind)).collect();\n+        expect.assert_debug_eq(&actual);\n+    }\n+\n+    #[track_caller]\n+    fn check_relevance_for_kinds(ra_fixture: &str, kinds: &[CompletionItemKind], expect: Expect) {\n+        let mut actual = get_all_items(TEST_CONFIG, ra_fixture);\n+        actual.retain(|it| kinds.contains(&it.kind()));\n+        actual.sort_by_key(|it| cmp::Reverse(it.relevance().score()));\n+        check_relevance_(actual, expect);\n     }\n \n     #[track_caller]\n-    fn check_relevance_for_kinds(kinds: &[CompletionKind], ra_fixture: &str, expect: Expect) {\n+    fn check_relevance(ra_fixture: &str, expect: Expect) {\n         let mut actual = get_all_items(TEST_CONFIG, ra_fixture);\n-        actual.retain(|it| kinds.contains(&it.completion_kind));\n+        actual.retain(|it| it.kind() != CompletionItemKind::Snippet);\n+        actual.retain(|it| it.kind() != CompletionItemKind::Keyword);\n+        actual.retain(|it| it.kind() != CompletionItemKind::BuiltinType);\n         actual.sort_by_key(|it| cmp::Reverse(it.relevance().score()));\n+        check_relevance_(actual, expect);\n+    }\n \n+    #[track_caller]\n+    fn check_relevance_(actual: Vec<CompletionItem>, expect: Expect) {\n         let actual = actual\n             .into_iter()\n             .flat_map(|it| {\n                 let mut items = vec![];\n \n-                let tag = it.kind().unwrap().tag();\n+                let tag = it.kind().tag();\n                 let relevance = display_relevance(it.relevance());\n                 items.push(format!(\"{} {} {}\\n\", tag, it.label(), relevance));\n \n@@ -418,6 +422,7 @@ enum Foo { Foo { x: i32, y: i32 } }\n \n fn main() { Foo::Fo$0 }\n \"#,\n+            SymbolKind::Variant,\n             expect![[r#\"\n                 [\n                     CompletionItem {\n@@ -443,6 +448,7 @@ enum Foo { Foo (i32, i32) }\n \n fn main() { Foo::Fo$0 }\n \"#,\n+            SymbolKind::Variant,\n             expect![[r#\"\n                 [\n                     CompletionItem {\n@@ -470,6 +476,7 @@ fn foo<T>(a: u32, b: u32, t: T) -> (u32, T) { (a, t) }\n \n fn main() { fo$0 }\n \"#,\n+            SymbolKind::Function,\n             expect![[r#\"\n                 [\n                     CompletionItem {\n@@ -508,6 +515,7 @@ enum Foo { Foo }\n \n fn main() { Foo::Fo$0 }\n \"#,\n+            SymbolKind::Variant,\n             expect![[r#\"\n                 [\n                     CompletionItem {\n@@ -527,15 +535,40 @@ fn main() { Foo::Fo$0 }\n \n     #[test]\n     fn lookup_enums_by_two_qualifiers() {\n-        check(\n+        check_kinds(\n             r#\"\n mod m {\n     pub enum Spam { Foo, Bar(i32) }\n }\n fn main() { let _: m::Spam = S$0 }\n \"#,\n+            &[\n+                CompletionItemKind::SymbolKind(SymbolKind::Function),\n+                CompletionItemKind::SymbolKind(SymbolKind::Module),\n+                CompletionItemKind::SymbolKind(SymbolKind::Variant),\n+            ],\n             expect![[r#\"\n                 [\n+                    CompletionItem {\n+                        label: \"main()\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"main()$0\",\n+                        kind: SymbolKind(\n+                            Function,\n+                        ),\n+                        lookup: \"main\",\n+                        detail: \"fn()\",\n+                    },\n+                    CompletionItem {\n+                        label: \"m\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"m\",\n+                        kind: SymbolKind(\n+                            Module,\n+                        ),\n+                    },\n                     CompletionItem {\n                         label: \"Spam::Bar(\u2026)\",\n                         source_range: 75..76,\n@@ -556,15 +589,6 @@ fn main() { let _: m::Spam = S$0 }\n                         },\n                         trigger_call_info: true,\n                     },\n-                    CompletionItem {\n-                        label: \"m\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"m\",\n-                        kind: SymbolKind(\n-                            Module,\n-                        ),\n-                    },\n                     CompletionItem {\n                         label: \"m::Spam::Foo\",\n                         source_range: 75..76,\n@@ -584,17 +608,6 @@ fn main() { let _: m::Spam = S$0 }\n                             exact_postfix_snippet_match: false,\n                         },\n                     },\n-                    CompletionItem {\n-                        label: \"main()\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"main()$0\",\n-                        kind: SymbolKind(\n-                            Function,\n-                        ),\n-                        lookup: \"main\",\n-                        detail: \"fn()\",\n-                    },\n                 ]\n             \"#]],\n         )\n@@ -611,6 +624,7 @@ fn something_else_deprecated() {}\n \n fn main() { som$0 }\n \"#,\n+            SymbolKind::Function,\n             expect![[r#\"\n                 [\n                     CompletionItem {\n@@ -657,6 +671,7 @@ fn main() { som$0 }\n struct A { #[deprecated] the_field: u32 }\n fn foo() { A { the$0 } }\n \"#,\n+            SymbolKind::Field,\n             expect![[r#\"\n                 [\n                     CompletionItem {\n@@ -685,7 +700,7 @@ fn foo() { A { the$0 } }\n \n     #[test]\n     fn renders_docs() {\n-        check(\n+        check_kinds(\n             r#\"\n struct S {\n     /// Field docs\n@@ -695,6 +710,7 @@ impl S {\n     /// Method docs\n     fn bar(self) { self.$0 }\n }\"#,\n+            &[CompletionItemKind::Method, CompletionItemKind::SymbolKind(SymbolKind::Field)],\n             expect![[r#\"\n                 [\n                     CompletionItem {\n@@ -726,7 +742,7 @@ impl S {\n             \"#]],\n         );\n \n-        check(\n+        check_kinds(\n             r#\"\n use self::my$0;\n \n@@ -740,18 +756,23 @@ enum E {\n }\n use self::E::*;\n \"#,\n+            &[\n+                CompletionItemKind::SymbolKind(SymbolKind::Module),\n+                CompletionItemKind::SymbolKind(SymbolKind::Variant),\n+                CompletionItemKind::SymbolKind(SymbolKind::Enum),\n+            ],\n             expect![[r#\"\n                 [\n                     CompletionItem {\n-                        label: \"E\",\n+                        label: \"my\",\n                         source_range: 10..12,\n                         delete: 10..12,\n-                        insert: \"E\",\n+                        insert: \"my\",\n                         kind: SymbolKind(\n-                            Enum,\n+                            Module,\n                         ),\n                         documentation: Documentation(\n-                            \"enum docs\",\n+                            \"mod docs\",\n                         ),\n                     },\n                     CompletionItem {\n@@ -768,15 +789,15 @@ use self::E::*;\n                         ),\n                     },\n                     CompletionItem {\n-                        label: \"my\",\n+                        label: \"E\",\n                         source_range: 10..12,\n                         delete: 10..12,\n-                        insert: \"my\",\n+                        insert: \"E\",\n                         kind: SymbolKind(\n-                            Module,\n+                            Enum,\n                         ),\n                         documentation: Documentation(\n-                            \"mod docs\",\n+                            \"enum docs\",\n                         ),\n                     },\n                 ]\n@@ -795,6 +816,7 @@ impl S {\n }\n fn foo(s: S) { s.$0 }\n \"#,\n+            CompletionItemKind::Method,\n             expect![[r#\"\n                 [\n                     CompletionItem {\n@@ -1318,18 +1340,28 @@ fn main() {\n \n     #[test]\n     fn struct_field_method_ref() {\n-        check(\n+        check_kinds(\n             r#\"\n struct Foo { bar: u32 }\n impl Foo { fn baz(&self) -> u32 { 0 } }\n \n fn foo(f: Foo) { let _: &u32 = f.b$0 }\n \"#,\n+            &[CompletionItemKind::Method, CompletionItemKind::SymbolKind(SymbolKind::Field)],\n             // FIXME\n             // Ideally we'd also suggest &f.bar and &f.baz() as exact\n             // type matches. See #8058.\n             expect![[r#\"\n                 [\n+                    CompletionItem {\n+                        label: \"baz()\",\n+                        source_range: 98..99,\n+                        delete: 98..99,\n+                        insert: \"baz()$0\",\n+                        kind: Method,\n+                        lookup: \"baz\",\n+                        detail: \"fn(&self) -> u32\",\n+                    },\n                     CompletionItem {\n                         label: \"bar\",\n                         source_range: 98..99,\n@@ -1340,15 +1372,6 @@ fn foo(f: Foo) { let _: &u32 = f.b$0 }\n                         ),\n                         detail: \"u32\",\n                     },\n-                    CompletionItem {\n-                        label: \"baz()\",\n-                        source_range: 98..99,\n-                        delete: 98..99,\n-                        insert: \"baz()$0\",\n-                        kind: Method,\n-                        lookup: \"baz\",\n-                        detail: \"fn(&self) -> u32\",\n-                    },\n                 ]\n             \"#]],\n         );\n@@ -1387,7 +1410,6 @@ fn foo() {\n     #[test]\n     fn postfix_completion_relevance() {\n         check_relevance_for_kinds(\n-            &[CompletionKind::Postfix, CompletionKind::Magic],\n             r#\"\n mod ops {\n     pub trait Not {\n@@ -1404,7 +1426,8 @@ mod ops {\n fn main() {\n     let _: bool = (9 > 2).not$0;\n }\n-\"#,\n+    \"#,\n+            &[CompletionItemKind::Snippet, CompletionItemKind::Method],\n             expect![[r#\"\n                 sn not [snippet]\n                 me not() (use ops::Not) [type_could_unify]"}, {"sha": "241e0043c9c5222e8fd458625e7f76b4499ad12d", "filename": "crates/ide_completion/src/render/const_.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Fconst_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Fconst_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fconst_.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -7,10 +7,7 @@ use syntax::{\n     display::const_label,\n };\n \n-use crate::{\n-    item::{CompletionItem, CompletionKind},\n-    render::RenderContext,\n-};\n+use crate::{item::CompletionItem, render::RenderContext};\n \n pub(crate) fn render_const(ctx: RenderContext<'_>, const_: hir::Const) -> Option<CompletionItem> {\n     ConstRender::new(ctx, const_)?.render()\n@@ -34,9 +31,8 @@ impl<'a> ConstRender<'a> {\n         let detail = self.detail();\n \n         let mut item =\n-            CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), name.clone());\n-        item.kind(SymbolKind::Const)\n-            .set_documentation(self.ctx.docs(self.const_))\n+            CompletionItem::new(SymbolKind::Const, self.ctx.source_range(), name.clone());\n+        item.set_documentation(self.ctx.docs(self.const_))\n             .set_deprecated(\n                 self.ctx.is_deprecated(self.const_)\n                     || self.ctx.is_deprecated_assoc_item(self.const_),"}, {"sha": "728e0e2a174bbf5cca014b81aa1f592f7acf048c", "filename": "crates/ide_completion/src/render/enum_variant.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -7,7 +7,7 @@ use ide_db::SymbolKind;\n use itertools::Itertools;\n \n use crate::{\n-    item::{CompletionItem, CompletionKind, ImportEdit},\n+    item::{CompletionItem, ImportEdit},\n     render::{builder_ext::Params, compute_ref_match, compute_type_match, RenderContext},\n     CompletionRelevance,\n };\n@@ -61,12 +61,11 @@ impl<'a> EnumRender<'a> {\n     }\n     fn render(self, import_to_add: Option<ImportEdit>) -> CompletionItem {\n         let mut item = CompletionItem::new(\n-            CompletionKind::Reference,\n+            SymbolKind::Variant,\n             self.ctx.source_range(),\n             self.qualified_name.to_string(),\n         );\n-        item.kind(SymbolKind::Variant)\n-            .set_documentation(self.variant.docs(self.ctx.db()))\n+        item.set_documentation(self.variant.docs(self.ctx.db()))\n             .set_deprecated(self.ctx.is_deprecated(self.variant))\n             .detail(self.detail());\n "}, {"sha": "7515bb6d47db3f41de18b880682dbd5ab89b4ef1", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -7,7 +7,7 @@ use itertools::Itertools;\n use syntax::ast;\n \n use crate::{\n-    item::{CompletionItem, CompletionItemKind, CompletionKind, CompletionRelevance, ImportEdit},\n+    item::{CompletionItem, CompletionItemKind, CompletionRelevance, ImportEdit},\n     render::{\n         builder_ext::Params, compute_exact_name_match, compute_ref_match, compute_type_match,\n         RenderContext,\n@@ -79,10 +79,8 @@ impl<'a> FunctionRender<'a> {\n             Some(receiver) => format!(\"{}.{}\", receiver, &self.name),\n             None => self.name.clone(),\n         };\n-        let mut item =\n-            CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), call.clone());\n-        item.kind(self.kind())\n-            .set_documentation(self.ctx.docs(self.func))\n+        let mut item = CompletionItem::new(self.kind(), self.ctx.source_range(), call.clone());\n+        item.set_documentation(self.ctx.docs(self.func))\n             .set_deprecated(\n                 self.ctx.is_deprecated(self.func) || self.ctx.is_deprecated_assoc_item(self.func),\n             )"}, {"sha": "b1ddfab0cbbf2f875c7ce097456b3c09e1fdad9a", "filename": "crates/ide_completion/src/render/macro_.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -6,7 +6,7 @@ use syntax::display::macro_label;\n \n use crate::{\n     context::CallKind,\n-    item::{CompletionItem, CompletionKind, ImportEdit},\n+    item::{CompletionItem, ImportEdit},\n     render::RenderContext,\n };\n \n@@ -47,9 +47,8 @@ impl<'a> MacroRender<'a> {\n         } else {\n             Some(self.ctx.source_range())\n         }?;\n-        let mut item = CompletionItem::new(CompletionKind::Reference, source_range, &self.label());\n-        item.kind(SymbolKind::Macro)\n-            .set_documentation(self.docs.clone())\n+        let mut item = CompletionItem::new(SymbolKind::Macro, source_range, &self.label());\n+        item.set_documentation(self.docs.clone())\n             .set_deprecated(self.ctx.is_deprecated(self.macro_))\n             .set_detail(self.detail());\n "}, {"sha": "b7032806204af3a02f62be0c8a0202781448e14c", "filename": "crates/ide_completion/src/render/pattern.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fpattern.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -6,7 +6,6 @@ use itertools::Itertools;\n \n use crate::{\n     context::{ParamKind, PatternContext},\n-    item::CompletionKind,\n     render::RenderContext,\n     CompletionItem, CompletionItemKind,\n };\n@@ -58,11 +57,8 @@ fn build_completion(\n     pat: String,\n     def: impl HasAttrs + Copy,\n ) -> CompletionItem {\n-    let mut item = CompletionItem::new(CompletionKind::Snippet, ctx.source_range(), name);\n-    item.kind(CompletionItemKind::Binding)\n-        .set_documentation(ctx.docs(def))\n-        .set_deprecated(ctx.is_deprecated(def))\n-        .detail(&pat);\n+    let mut item = CompletionItem::new(CompletionItemKind::Binding, ctx.source_range(), name);\n+    item.set_documentation(ctx.docs(def)).set_deprecated(ctx.is_deprecated(def)).detail(&pat);\n     match ctx.snippet_cap() {\n         Some(snippet_cap) => item.insert_snippet(snippet_cap, pat),\n         None => item.insert_text(pat),"}, {"sha": "4eb4f6b9f127c31bb27af10342fbb666fcbdca7f", "filename": "crates/ide_completion/src/render/struct_literal.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Fstruct_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Fstruct_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fstruct_literal.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -4,7 +4,7 @@ use hir::{db::HirDatabase, HasAttrs, HasVisibility, Name, StructKind};\n use ide_db::helpers::SnippetCap;\n use itertools::Itertools;\n \n-use crate::{item::CompletionKind, render::RenderContext, CompletionItem, CompletionItemKind};\n+use crate::{render::RenderContext, CompletionItem, CompletionItemKind};\n \n pub(crate) fn render_struct_literal(\n     ctx: RenderContext<'_>,\n@@ -33,11 +33,9 @@ fn build_completion(\n     literal: String,\n     def: impl HasAttrs + Copy,\n ) -> CompletionItem {\n-    let mut item = CompletionItem::new(CompletionKind::Snippet, ctx.source_range(), name + \" {\u2026}\");\n-    item.kind(CompletionItemKind::Snippet)\n-        .set_documentation(ctx.docs(def))\n-        .set_deprecated(ctx.is_deprecated(def))\n-        .detail(&literal);\n+    let mut item =\n+        CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), name + \" {\u2026}\");\n+    item.set_documentation(ctx.docs(def)).set_deprecated(ctx.is_deprecated(def)).detail(&literal);\n     match ctx.snippet_cap() {\n         Some(snippet_cap) => item.insert_snippet(snippet_cap, literal),\n         None => item.insert_text(literal),"}, {"sha": "7b6d2fa5c3abc5bc99fe39ff555513cd067aef7c", "filename": "crates/ide_completion/src/render/type_alias.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Frender%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ftype_alias.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -7,10 +7,7 @@ use syntax::{\n     display::type_label,\n };\n \n-use crate::{\n-    item::{CompletionItem, CompletionKind},\n-    render::RenderContext,\n-};\n+use crate::{item::CompletionItem, render::RenderContext};\n \n pub(crate) fn render_type_alias(\n     ctx: RenderContext<'_>,\n@@ -50,9 +47,8 @@ impl<'a> TypeAliasRender<'a> {\n         let detail = self.detail();\n \n         let mut item =\n-            CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), name.clone());\n-        item.kind(SymbolKind::TypeAlias)\n-            .set_documentation(self.ctx.docs(self.type_alias))\n+            CompletionItem::new(SymbolKind::TypeAlias, self.ctx.source_range(), name.clone());\n+        item.set_documentation(self.ctx.docs(self.type_alias))\n             .set_deprecated(\n                 self.ctx.is_deprecated(self.type_alias)\n                     || self.ctx.is_deprecated_assoc_item(self.type_alias),"}, {"sha": "f063a9638ca2656aebb88e6b1a468afafcf56e6c", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 53, "deletions": 22, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -20,6 +20,7 @@ mod record;\n mod type_pos;\n mod use_tree;\n mod visibility;\n+mod flyimport;\n \n use std::mem;\n \n@@ -37,7 +38,7 @@ use stdx::{format_to, trim_indent};\n use syntax::{AstNode, NodeOrToken, SyntaxElement};\n use test_utils::assert_eq_text;\n \n-use crate::{item::CompletionKind, CompletionConfig, CompletionItem};\n+use crate::{CompletionConfig, CompletionItem, CompletionItemKind};\n \n /// Lots of basic item definitions\n const BASE_ITEMS_FIXTURE: &str = r#\"\n@@ -77,18 +78,28 @@ pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {\n };\n \n pub(crate) fn completion_list(ra_fixture: &str) -> String {\n-    completion_list_with_config(TEST_CONFIG, ra_fixture)\n+    completion_list_with_config(TEST_CONFIG, ra_fixture, true)\n }\n \n-fn completion_list_with_config(config: CompletionConfig, ra_fixture: &str) -> String {\n+pub(crate) fn completion_list_no_kw(ra_fixture: &str) -> String {\n+    completion_list_with_config(TEST_CONFIG, ra_fixture, false)\n+}\n+\n+fn completion_list_with_config(\n+    config: CompletionConfig,\n+    ra_fixture: &str,\n+    include_keywords: bool,\n+) -> String {\n     // filter out all but one builtintype completion for smaller test outputs\n     let items = get_all_items(config, ra_fixture);\n     let mut bt_seen = false;\n     let items = items\n         .into_iter()\n         .filter(|it| {\n-            it.completion_kind != CompletionKind::BuiltinType || !mem::replace(&mut bt_seen, true)\n+            it.kind() != CompletionItemKind::BuiltinType || !mem::replace(&mut bt_seen, true)\n         })\n+        .filter(|it| include_keywords || it.kind() != CompletionItemKind::Keyword)\n+        .filter(|it| include_keywords || it.kind() != CompletionItemKind::Snippet)\n         .collect();\n     render_completion_list(items)\n }\n@@ -104,36 +115,22 @@ pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n     (database, FilePosition { file_id, offset })\n }\n \n-pub(crate) fn do_completion(code: &str, kind: CompletionKind) -> Vec<CompletionItem> {\n+pub(crate) fn do_completion(code: &str, kind: CompletionItemKind) -> Vec<CompletionItem> {\n     do_completion_with_config(TEST_CONFIG, code, kind)\n }\n \n pub(crate) fn do_completion_with_config(\n     config: CompletionConfig,\n     code: &str,\n-    kind: CompletionKind,\n+    kind: CompletionItemKind,\n ) -> Vec<CompletionItem> {\n     get_all_items(config, code)\n         .into_iter()\n-        .filter(|c| c.completion_kind == kind)\n+        .filter(|c| c.kind() == kind)\n         .sorted_by(|l, r| l.label().cmp(r.label()))\n         .collect()\n }\n \n-pub(crate) fn filtered_completion_list(code: &str, kind: CompletionKind) -> String {\n-    filtered_completion_list_with_config(TEST_CONFIG, code, kind)\n-}\n-\n-pub(crate) fn filtered_completion_list_with_config(\n-    config: CompletionConfig,\n-    code: &str,\n-    kind: CompletionKind,\n-) -> String {\n-    let kind_completions: Vec<CompletionItem> =\n-        get_all_items(config, code).into_iter().filter(|c| c.completion_kind == kind).collect();\n-    render_completion_list(kind_completions)\n-}\n-\n fn render_completion_list(completions: Vec<CompletionItem>) -> String {\n     fn monospace_width(s: &str) -> usize {\n         s.chars().count()\n@@ -143,7 +140,7 @@ fn render_completion_list(completions: Vec<CompletionItem>) -> String {\n     completions\n         .into_iter()\n         .map(|it| {\n-            let tag = it.kind().unwrap().tag();\n+            let tag = it.kind().tag();\n             let var_name = format!(\"{} {}\", tag, it.label());\n             let mut buf = var_name;\n             if let Some(detail) = it.detail() {\n@@ -254,3 +251,37 @@ fn foo() {\n \"#,\n     );\n }\n+\n+#[test]\n+fn no_completions_in_comments() {\n+    cov_mark::check!(no_keyword_completion_in_comments);\n+    assert_eq!(\n+        completion_list(\n+            r#\"\n+fn test() {\n+let x = 2; // A comment$0\n+}\n+\"#,\n+        ),\n+        String::new(),\n+    );\n+    assert_eq!(\n+        completion_list(\n+            r#\"\n+/*\n+Some multi-line comment$0\n+*/\n+\"#,\n+        ),\n+        String::new(),\n+    );\n+    assert_eq!(\n+        completion_list(\n+            r#\"\n+/// Some doc comment\n+/// let test$0 = 1\n+\"#,\n+        ),\n+        String::new(),\n+    );\n+}"}, {"sha": "a63480873447ac2fb03540f730e62e99516ebb23", "filename": "crates/ide_completion/src/tests/expression.rs", "status": "modified", "additions": 218, "deletions": 1, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -110,7 +110,7 @@ fn func(param0 @ (param1, param2): (i32, i32)) {\n }\n \n #[test]\n-fn completes_all_the_things() {\n+fn completes_all_the_things_in_fn_body() {\n     cov_mark::check!(unqualified_skip_lifetime_completion);\n     check(\n         r#\"\n@@ -206,6 +206,223 @@ impl Unit {\n     );\n }\n \n+#[test]\n+fn complete_in_block() {\n+    check_empty(\n+        r#\"\n+    fn foo() {\n+        if true {\n+            $0\n+        }\n+    }\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw impl\n+            kw extern\n+            kw use\n+            kw trait\n+            kw static\n+            kw mod\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw let\n+            kw return\n+            sn pd\n+            sn ppd\n+            kw self\n+            kw super\n+            kw crate\n+            fn foo()     fn()\n+            bt u32\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn complete_after_if_expr() {\n+    check_empty(\n+        r#\"\n+    fn foo() {\n+        if true {}\n+        $0\n+    }\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw impl\n+            kw extern\n+            kw use\n+            kw trait\n+            kw static\n+            kw mod\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw let\n+            kw else\n+            kw else if\n+            kw return\n+            sn pd\n+            sn ppd\n+            kw self\n+            kw super\n+            kw crate\n+            fn foo()     fn()\n+            bt u32\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn complete_in_match_arm() {\n+    check_empty(\n+        r#\"\n+    fn foo() {\n+        match () {\n+            () => $0\n+        }\n+    }\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            fn foo()     fn()\n+            bt u32\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn completes_in_loop_ctx() {\n+    check_empty(\n+        r\"fn my() { loop { $0 } }\",\n+        expect![[r#\"\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw impl\n+            kw extern\n+            kw use\n+            kw trait\n+            kw static\n+            kw mod\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw let\n+            kw continue\n+            kw break\n+            kw return\n+            sn pd\n+            sn ppd\n+            kw self\n+            kw super\n+            kw crate\n+            fn my()      fn()\n+            bt u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_in_let_initializer() {\n+    check_empty(\n+        r#\"fn main() { let _ = $0 }\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            fn main()    fn()\n+            bt u32\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn struct_initializer_field_expr() {\n+    check_empty(\n+        r#\"\n+struct Foo {\n+    pub f: i32,\n+}\n+fn foo() {\n+    Foo {\n+        f: $0\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            st Foo\n+            fn foo()     fn()\n+            bt u32\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn shadowing_shows_single_completion() {\n     cov_mark::check!(shadowing_shows_single_completion);"}, {"sha": "201443e10c2f0c56ac00bd5781a7fc65fb8a1e71", "filename": "crates/ide_completion/src/tests/flyimport.rs", "status": "added", "additions": 1014, "deletions": 0, "changes": 1014, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -0,0 +1,1014 @@\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::{check_edit, check_edit_with_config, TEST_CONFIG};\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let config = TEST_CONFIG;\n+    let (db, position) = crate::tests::position(ra_fixture);\n+    let ctx = crate::context::CompletionContext::new(&db, position, &config).unwrap();\n+\n+    let mut acc = crate::completions::Completions::default();\n+    crate::completions::flyimport::import_on_the_fly(&mut acc, &ctx);\n+\n+    expect.assert_eq(&super::render_completion_list(Vec::from(acc)));\n+}\n+\n+#[test]\n+fn function_fuzzy_completion() {\n+    check_edit(\n+        \"stdin\",\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod io {\n+    pub fn stdin() {}\n+};\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    stdi$0\n+}\n+\"#,\n+        r#\"\n+use dep::io::stdin;\n+\n+fn main() {\n+    stdin()$0\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn macro_fuzzy_completion() {\n+    check_edit(\n+        \"macro_with_curlies!\",\n+        r#\"\n+//- /lib.rs crate:dep\n+/// Please call me as macro_with_curlies! {}\n+#[macro_export]\n+macro_rules! macro_with_curlies {\n+    () => {}\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    curli$0\n+}\n+\"#,\n+        r#\"\n+use dep::macro_with_curlies;\n+\n+fn main() {\n+    macro_with_curlies! {$0}\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn struct_fuzzy_completion() {\n+    check_edit(\n+        \"ThirdStruct\",\n+        r#\"\n+//- /lib.rs crate:dep\n+pub struct FirstStruct;\n+pub mod some_module {\n+    pub struct SecondStruct;\n+    pub struct ThirdStruct;\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::{FirstStruct, some_module::SecondStruct};\n+\n+fn main() {\n+    this$0\n+}\n+\"#,\n+        r#\"\n+use dep::{FirstStruct, some_module::{SecondStruct, ThirdStruct}};\n+\n+fn main() {\n+    ThirdStruct\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn short_paths_are_ignored() {\n+    cov_mark::check!(ignore_short_input_for_path);\n+\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub struct FirstStruct;\n+pub mod some_module {\n+    pub struct SecondStruct;\n+    pub struct ThirdStruct;\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::{FirstStruct, some_module::SecondStruct};\n+\n+fn main() {\n+    t$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn fuzzy_completions_come_in_specific_order() {\n+    cov_mark::check!(certain_fuzzy_order_test);\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub struct FirstStruct;\n+pub mod some_module {\n+    // already imported, omitted\n+    pub struct SecondStruct;\n+    // does not contain all letters from the query, omitted\n+    pub struct UnrelatedOne;\n+    // contains all letters from the query, but not in sequence, displayed last\n+    pub struct ThiiiiiirdStruct;\n+    // contains all letters from the query, but not in the beginning, displayed second\n+    pub struct AfterThirdStruct;\n+    // contains all letters from the query in the begginning, displayed first\n+    pub struct ThirdStruct;\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::{FirstStruct, some_module::SecondStruct};\n+\n+fn main() {\n+    hir$0\n+}\n+\"#,\n+        expect![[r#\"\n+                st ThirdStruct (use dep::some_module::ThirdStruct)\n+                st AfterThirdStruct (use dep::some_module::AfterThirdStruct)\n+                st ThiiiiiirdStruct (use dep::some_module::ThiiiiiirdStruct)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn trait_function_fuzzy_completion() {\n+    let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            dep::test_mod::TestStruct::wei$0\n+        }\n+        \"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+                fn weird_function() (use dep::test_mod::TestTrait) fn()\n+            \"#]],\n+    );\n+\n+    check_edit(\n+        \"weird_function\",\n+        fixture,\n+        r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    dep::test_mod::TestStruct::weird_function()$0\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn trait_const_fuzzy_completion() {\n+    let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            dep::test_mod::TestStruct::spe$0\n+        }\n+        \"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+            ct SPECIAL_CONST (use dep::test_mod::TestTrait)\n+        \"#]],\n+    );\n+\n+    check_edit(\n+        \"SPECIAL_CONST\",\n+        fixture,\n+        r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    dep::test_mod::TestStruct::SPECIAL_CONST\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn trait_method_fuzzy_completion() {\n+    let fixture = r#\"\n+        //- /lib.rs crate:dep\n+        pub mod test_mod {\n+            pub trait TestTrait {\n+                const SPECIAL_CONST: u8;\n+                type HumbleType;\n+                fn weird_function();\n+                fn random_method(&self);\n+            }\n+            pub struct TestStruct {}\n+            impl TestTrait for TestStruct {\n+                const SPECIAL_CONST: u8 = 42;\n+                type HumbleType = ();\n+                fn weird_function() {}\n+                fn random_method(&self) {}\n+            }\n+        }\n+\n+        //- /main.rs crate:main deps:dep\n+        fn main() {\n+            let test_struct = dep::test_mod::TestStruct {};\n+            test_struct.ran$0\n+        }\n+        \"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+                me random_method() (use dep::test_mod::TestTrait) fn(&self)\n+            \"#]],\n+    );\n+\n+    check_edit(\n+        \"random_method\",\n+        fixture,\n+        r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    let test_struct = dep::test_mod::TestStruct {};\n+    test_struct.random_method()$0\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn no_trait_type_fuzzy_completion() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::hum$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn does_not_propose_names_in_scope() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::test_mod::TestStruct;\n+fn main() {\n+    TestSt$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn does_not_propose_traits_in_scope() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+use dep::test_mod::{TestStruct, TestTrait};\n+fn main() {\n+    dep::test_mod::TestStruct::hum$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn blanket_trait_impl_import() {\n+    check_edit(\n+        \"another_function\",\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    pub struct TestStruct {}\n+    pub trait TestTrait {\n+        fn another_function();\n+    }\n+    impl<T> TestTrait for T {\n+        fn another_function() {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::ano$0\n+}\n+\"#,\n+        r#\"\n+use dep::test_mod::TestTrait;\n+\n+fn main() {\n+    dep::test_mod::TestStruct::another_function()$0\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn zero_input_deprecated_assoc_item_completion() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    #[deprecated]\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    let test_struct = dep::test_mod::TestStruct {};\n+    test_struct.$0\n+}\n+        \"#,\n+        expect![[r#\"\n+                me random_method() (use dep::test_mod::TestTrait) fn(&self) DEPRECATED\n+            \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod test_mod {\n+    #[deprecated]\n+    pub trait TestTrait {\n+        const SPECIAL_CONST: u8;\n+        type HumbleType;\n+        fn weird_function();\n+        fn random_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const SPECIAL_CONST: u8 = 42;\n+        type HumbleType = ();\n+        fn weird_function() {}\n+        fn random_method(&self) {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::$0\n+}\n+\"#,\n+        expect![[r#\"\n+                fn weird_function() (use dep::test_mod::TestTrait) fn() DEPRECATED\n+                ct SPECIAL_CONST (use dep::test_mod::TestTrait) DEPRECATED\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn no_completions_in_use_statements() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:dep\n+pub mod io {\n+    pub fn stdin() {}\n+};\n+\n+//- /main.rs crate:main deps:dep\n+use stdi$0\n+\n+fn main() {}\n+\"#,\n+        expect![[]],\n+    );\n+}\n+\n+#[test]\n+fn prefix_config_usage() {\n+    let fixture = r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+    }\n+}\n+\n+use crate::foo::bar;\n+\n+fn main() {\n+    Ite$0\n+}\"#;\n+    let mut config = TEST_CONFIG;\n+\n+    config.insert_use.prefix_kind = hir::PrefixKind::ByCrate;\n+    check_edit_with_config(\n+        config.clone(),\n+        \"Item\",\n+        fixture,\n+        r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+    }\n+}\n+\n+use crate::foo::bar::{self, Item};\n+\n+fn main() {\n+    Item\n+}\"#,\n+    );\n+\n+    config.insert_use.prefix_kind = hir::PrefixKind::BySelf;\n+    check_edit_with_config(\n+        config.clone(),\n+        \"Item\",\n+        fixture,\n+        r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+    }\n+}\n+\n+use crate::foo::bar;\n+\n+use self::foo::bar::Item;\n+\n+fn main() {\n+    Item\n+}\"#,\n+    );\n+\n+    config.insert_use.prefix_kind = hir::PrefixKind::Plain;\n+    check_edit_with_config(\n+        config,\n+        \"Item\",\n+        fixture,\n+        r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+    }\n+}\n+\n+use foo::bar::Item;\n+\n+use crate::foo::bar;\n+\n+fn main() {\n+    Item\n+}\"#,\n+    );\n+}\n+\n+#[test]\n+fn unresolved_qualifier() {\n+    let fixture = r#\"\n+mod foo {\n+    pub mod bar {\n+        pub mod baz {\n+            pub struct Item;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::baz::Ite$0\n+}\"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+        st Item (use foo::bar::baz::Item)\n+        \"#]],\n+    );\n+\n+    check_edit(\n+        \"Item\",\n+        fixture,\n+        r#\"\n+        use foo::bar;\n+\n+        mod foo {\n+            pub mod bar {\n+                pub mod baz {\n+                    pub struct Item;\n+                }\n+            }\n+        }\n+\n+        fn main() {\n+            bar::baz::Item\n+        }\"#,\n+    );\n+}\n+\n+#[test]\n+fn unresolved_assoc_item_container() {\n+    let fixture = r#\"\n+mod foo {\n+    pub struct Item;\n+\n+    impl Item {\n+        pub const TEST_ASSOC: usize = 3;\n+    }\n+}\n+\n+fn main() {\n+    Item::TEST_A$0\n+}\"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+        ct TEST_ASSOC (use foo::Item)\n+        \"#]],\n+    );\n+\n+    check_edit(\n+        \"TEST_ASSOC\",\n+        fixture,\n+        r#\"\n+use foo::Item;\n+\n+mod foo {\n+    pub struct Item;\n+\n+    impl Item {\n+        pub const TEST_ASSOC: usize = 3;\n+    }\n+}\n+\n+fn main() {\n+    Item::TEST_ASSOC\n+}\"#,\n+    );\n+}\n+\n+#[test]\n+fn unresolved_assoc_item_container_with_path() {\n+    let fixture = r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+\n+        impl Item {\n+            pub const TEST_ASSOC: usize = 3;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::Item::TEST_A$0\n+}\"#;\n+\n+    check(\n+        fixture,\n+        expect![[r#\"\n+        ct TEST_ASSOC (use foo::bar::Item)\n+    \"#]],\n+    );\n+\n+    check_edit(\n+        \"TEST_ASSOC\",\n+        fixture,\n+        r#\"\n+use foo::bar;\n+\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+\n+        impl Item {\n+            pub const TEST_ASSOC: usize = 3;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::Item::TEST_ASSOC\n+}\"#,\n+    );\n+}\n+\n+#[test]\n+fn fuzzy_unresolved_path() {\n+    check(\n+        r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+\n+        impl Item {\n+            pub const TEST_ASSOC: usize = 3;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::ASS$0\n+}\"#,\n+        expect![[]],\n+    )\n+}\n+\n+#[test]\n+fn unqualified_assoc_items_are_omitted() {\n+    check(\n+        r#\"\n+mod something {\n+    pub trait BaseTrait {\n+        fn test_function() -> i32;\n+    }\n+\n+    pub struct Item1;\n+    pub struct Item2;\n+\n+    impl BaseTrait for Item1 {\n+        fn test_function() -> i32 {\n+            1\n+        }\n+    }\n+\n+    impl BaseTrait for Item2 {\n+        fn test_function() -> i32 {\n+            2\n+        }\n+    }\n+}\n+\n+fn main() {\n+    test_f$0\n+}\"#,\n+        expect![[]],\n+    )\n+}\n+\n+#[test]\n+fn case_matters() {\n+    check(\n+        r#\"\n+mod foo {\n+    pub const TEST_CONST: usize = 3;\n+    pub fn test_function() -> i32 {\n+        4\n+    }\n+}\n+\n+fn main() {\n+    TE$0\n+}\"#,\n+        expect![[r#\"\n+        ct TEST_CONST (use foo::TEST_CONST)\n+    \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+mod foo {\n+    pub const TEST_CONST: usize = 3;\n+    pub fn test_function() -> i32 {\n+        4\n+    }\n+}\n+\n+fn main() {\n+    te$0\n+}\"#,\n+        expect![[r#\"\n+        ct TEST_CONST (use foo::TEST_CONST)\n+        fn test_function() (use foo::test_function) fn() -> i32\n+    \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+mod foo {\n+    pub const TEST_CONST: usize = 3;\n+    pub fn test_function() -> i32 {\n+        4\n+    }\n+}\n+\n+fn main() {\n+    Te$0\n+}\"#,\n+        expect![[]],\n+    );\n+}\n+\n+#[test]\n+fn no_fuzzy_during_fields_of_record_lit_syntax() {\n+    check(\n+        r#\"\n+mod m {\n+    pub fn some_fn() -> i32 {\n+        42\n+    }\n+}\n+struct Foo {\n+    some_field: i32,\n+}\n+fn main() {\n+    let _ = Foo { so$0 };\n+}\n+\"#,\n+        expect![[]],\n+    );\n+}\n+\n+#[test]\n+fn fuzzy_after_fields_of_record_lit_syntax() {\n+    check(\n+        r#\"\n+mod m {\n+    pub fn some_fn() -> i32 {\n+        42\n+    }\n+}\n+struct Foo {\n+    some_field: i32,\n+}\n+fn main() {\n+    let _ = Foo { some_field: so$0 };\n+}\n+\"#,\n+        expect![[r#\"\n+                fn some_fn() (use m::some_fn) fn() -> i32\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn no_flyimports_in_traits_and_impl_declarations() {\n+    check(\n+        r#\"\n+mod m {\n+    pub fn some_fn() -> i32 {\n+        42\n+    }\n+}\n+trait Foo {\n+    som$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+\n+    check(\n+        r#\"\n+mod m {\n+    pub fn some_fn() -> i32 {\n+        42\n+    }\n+}\n+struct Foo;\n+impl Foo {\n+    som$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+\n+    check(\n+        r#\"\n+mod m {\n+    pub fn some_fn() -> i32 {\n+        42\n+    }\n+}\n+struct Foo;\n+trait Bar {}\n+impl Bar for Foo {\n+    som$0\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn no_inherent_candidates_proposed() {\n+    check(\n+        r#\"\n+mod baz {\n+    pub trait DefDatabase {\n+        fn method1(&self);\n+    }\n+    pub trait HirDatabase: DefDatabase {\n+        fn method2(&self);\n+    }\n+}\n+\n+mod bar {\n+    fn test(db: &dyn crate::baz::HirDatabase) {\n+        db.metho$0\n+    }\n+}\n+            \"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn respects_doc_hidden() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:lib deps:dep\n+fn f() {\n+    ().fro$0\n+}\n+\n+//- /dep.rs crate:dep\n+#[doc(hidden)]\n+pub trait Private {\n+    fn frob(&self) {}\n+}\n+\n+impl<T> Private for T {}\n+            \"#,\n+        expect![[r#\"\"#]],\n+    );\n+    check(\n+        r#\"\n+//- /lib.rs crate:lib deps:dep\n+fn f() {\n+    ().fro$0\n+}\n+\n+//- /dep.rs crate:dep\n+pub trait Private {\n+    #[doc(hidden)]\n+    fn frob(&self) {}\n+}\n+\n+impl<T> Private for T {}\n+            \"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn regression_9760() {\n+    check(\n+        r#\"\n+struct Struct;\n+fn main() {}\n+\n+mod mud {\n+    fn func() {\n+        let struct_instance = Stru$0\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+                st Struct (use crate::Struct)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn flyimport_pattern() {\n+    check(\n+        r#\"\n+mod module {\n+    pub struct Struct;\n+}\n+fn function() {\n+    let Str$0\n+}\n+\"#,\n+        expect![[r#\"\n+                st Struct (use module::Struct)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn flyimport_rename() {\n+    check(\n+        r#\"\n+mod module {\n+    pub struct Struct;\n+}\n+use self as Str$0;\n+    \"#,\n+        expect![[r#\"\"#]],\n+    );\n+}"}, {"sha": "e09e99aad5e7b1558ebe85edb1eda35b8c33fd31", "filename": "crates/ide_completion/src/tests/record.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -9,6 +9,7 @@ fn check(ra_fixture: &str, expect: Expect) {\n \n #[test]\n fn without_default_impl() {\n+    cov_mark::check!(no_keyword_completion_in_record_lit);\n     check(\n         r#\"\n struct Struct { foo: u32, bar: usize }"}, {"sha": "473b7a870f404b00d05ae1c33c2926d1f75affe5", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -248,7 +248,7 @@ fn completion_item(\n         label: item.label().to_string(),\n         detail: item.detail().map(|it| it.to_string()),\n         filter_text: Some(item.lookup().to_string()),\n-        kind: item.kind().map(completion_item_kind),\n+        kind: Some(completion_item_kind(item.kind())),\n         text_edit: Some(text_edit),\n         additional_text_edits: Some(additional_text_edits),\n         documentation: item.documentation().map(documentation),"}, {"sha": "5debb9fb3d1910014e3cac675dcf76dd367d8d06", "filename": "crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=9d1f15086adf2cb0edc8f2d1c9aa7a79241dae68", "patch": "@@ -313,6 +313,7 @@ fn check_dbg(path: &Path, text: &str) {\n         \"handlers/remove_dbg.rs\",\n         // We have .dbg postfix\n         \"ide_completion/src/completions/postfix.rs\",\n+        \"ide_completion/src/completions/keyword.rs\",\n         \"ide_completion/src/tests/proc_macros.rs\",\n         // The documentation in string literals may contain anything for its own purposes\n         \"ide_completion/src/lib.rs\","}]}