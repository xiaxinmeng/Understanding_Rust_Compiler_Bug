{"sha": "ac20ded1f8af6a35edf27059a6ee215d61666fef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMjBkZWQxZjhhZjZhMzVlZGYyNzA1OWE2ZWUyMTVkNjE2NjZmZWY=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-01T06:09:58Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-03T02:55:10Z"}, "message": "metadata: Avoid the use of raw `wr_str` or `write_all`.\n\nThey are, with a conjunction of `start_tag` and `end_tag`, commonly\nused to write a document with a binary data of known size. However\nthe use of `start_tag` makes the length always 4 bytes long, which\nis almost not optimal (requiring the relaxation step to remedy).\nDirectly using `wr_tagged_*` methods is better for both readability\nand resulting metadata size.", "tree": {"sha": "c7f087dfb8a09d6eacdf04c32b68410cc3d5b5f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7f087dfb8a09d6eacdf04c32b68410cc3d5b5f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac20ded1f8af6a35edf27059a6ee215d61666fef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac20ded1f8af6a35edf27059a6ee215d61666fef", "html_url": "https://github.com/rust-lang/rust/commit/ac20ded1f8af6a35edf27059a6ee215d61666fef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac20ded1f8af6a35edf27059a6ee215d61666fef/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4c965ee803a4521d8b4575f634e036f93e408f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c965ee803a4521d8b4575f634e036f93e408f3", "html_url": "https://github.com/rust-lang/rust/commit/b4c965ee803a4521d8b4575f634e036f93e408f3"}], "stats": {"total": 221, "additions": 70, "deletions": 151}, "files": [{"sha": "7c28f0e17b5e4ac3b601b682ae5122f97cdd56c1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 70, "deletions": 151, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/ac20ded1f8af6a35edf27059a6ee215d61666fef/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac20ded1f8af6a35edf27059a6ee215d61666fef/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ac20ded1f8af6a35edf27059a6ee215d61666fef", "patch": "@@ -121,9 +121,7 @@ fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n \n // Item info table encoding\n fn encode_family(rbml_w: &mut Encoder, c: char) {\n-    rbml_w.start_tag(tag_items_data_item_family);\n-    rbml_w.writer.write_all(&[c as u8]);\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_u8(tag_items_data_item_family, c as u8);\n }\n \n pub fn def_to_string(did: DefId) -> String {\n@@ -157,14 +155,9 @@ fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n }\n \n fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n-    rbml_w.start_tag(tag_items_data_item_variant);\n     let s = def_to_string(vid);\n-    rbml_w.writer.write_all(s.as_bytes());\n-    rbml_w.end_tag();\n-\n-    rbml_w.start_tag(tag_mod_child);\n-    rbml_w.wr_str(&s[..]);\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_items_data_item_variant, &s[..]);\n+    rbml_w.wr_tagged_str(tag_mod_child, &s[..]);\n }\n \n pub fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n@@ -265,34 +258,26 @@ fn encode_method_fty<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n fn encode_symbol(ecx: &EncodeContext,\n                  rbml_w: &mut Encoder,\n                  id: NodeId) {\n-    rbml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.borrow().get(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id={}, str={})\", id, *x);\n-            rbml_w.writer.write_all(x.as_bytes());\n+            rbml_w.wr_tagged_str(tag_items_data_item_symbol, x);\n         }\n         None => {\n             ecx.diag.handler().bug(\n                 &format!(\"encode_symbol: id not found {}\", id));\n         }\n     }\n-    rbml_w.end_tag();\n }\n \n fn encode_disr_val(_: &EncodeContext,\n                    rbml_w: &mut Encoder,\n                    disr_val: ty::Disr) {\n-    rbml_w.start_tag(tag_disr_val);\n-    let s = disr_val.to_string();\n-    rbml_w.writer.write_all(s.as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_string());\n }\n \n fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.start_tag(tag_items_data_parent_item);\n-    let s = def_to_string(id);\n-    rbml_w.writer.write_all(s.as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_items_data_parent_item, &def_to_string(id));\n }\n \n fn encode_struct_fields(rbml_w: &mut Encoder,\n@@ -307,10 +292,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n         }\n         encode_struct_field_family(rbml_w, f.vis);\n         encode_def_id(rbml_w, f.id);\n-        rbml_w.start_tag(tag_item_field_origin);\n-        let s = def_to_string(origin);\n-        rbml_w.writer.write_all(s.as_bytes());\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_item_field_origin, &def_to_string(origin));\n         rbml_w.end_tag();\n     }\n }\n@@ -393,14 +375,11 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n     debug!(\"(encode reexported static method) {}::{}\",\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n-    rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    rbml_w.wr_str(&def_to_string(method_def_id));\n-    rbml_w.end_tag();\n-    rbml_w.start_tag(tag_items_data_item_reexport_name);\n-    rbml_w.wr_str(&format!(\"{}::{}\",\n-                          exp.name,\n-                          token::get_name(method_name)));\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_items_data_item_reexport_def_id,\n+                         &def_to_string(method_def_id));\n+    rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n+                         &format!(\"{}::{}\", exp.name,\n+                                            token::get_name(method_name)));\n     rbml_w.end_tag();\n }\n \n@@ -536,12 +515,10 @@ fn encode_reexports(ecx: &EncodeContext,\n                        exp.def_id.node,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n-                rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                rbml_w.wr_str(&def_to_string(exp.def_id));\n-                rbml_w.end_tag();\n-                rbml_w.start_tag(tag_items_data_item_reexport_name);\n-                rbml_w.wr_str(exp.name.as_str());\n-                rbml_w.end_tag();\n+                rbml_w.wr_tagged_str(tag_items_data_item_reexport_def_id,\n+                                     &def_to_string(exp.def_id));\n+                rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n+                                     exp.name.as_str());\n                 rbml_w.end_tag();\n                 encode_reexported_static_methods(ecx, rbml_w, path.clone(), exp);\n             }\n@@ -569,15 +546,12 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     // Encode info about all the module children.\n     for item in &md.items {\n-        rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(&def_to_string(local_def(item.id)));\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_mod_child,\n+                             &def_to_string(local_def(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n-            rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(local_def(\n-                        auxiliary_node_id)));\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_mod_child,\n+                                 &def_to_string(local_def(auxiliary_node_id)));\n             true\n         });\n \n@@ -587,9 +561,8 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    token::get_ident(ident),\n                    did, ecx.tcx.map.node_to_string(did));\n \n-            rbml_w.start_tag(tag_mod_impl);\n-            rbml_w.wr_str(&def_to_string(local_def(did)));\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_mod_impl,\n+                                 &def_to_string(local_def(did)));\n         }\n     }\n \n@@ -618,67 +591,56 @@ fn encode_struct_field_family(rbml_w: &mut Encoder,\n }\n \n fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n-    rbml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n         ast::Public => 'y',\n         ast::Inherited => 'i',\n     };\n-    rbml_w.wr_str(&ch.to_string());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n }\n \n fn encode_explicit_self(rbml_w: &mut Encoder,\n                         explicit_self: &ty::ExplicitSelfCategory) {\n-    rbml_w.start_tag(tag_item_trait_method_explicit_self);\n+    let tag = tag_item_trait_method_explicit_self;\n \n     // Encode the base self type.\n     match *explicit_self {\n         ty::StaticExplicitSelfCategory => {\n-            rbml_w.writer.write_all(&[ 's' as u8 ]);\n+            rbml_w.wr_tagged_bytes(tag, &['s' as u8]);\n         }\n         ty::ByValueExplicitSelfCategory => {\n-            rbml_w.writer.write_all(&[ 'v' as u8 ]);\n+            rbml_w.wr_tagged_bytes(tag, &['v' as u8]);\n         }\n         ty::ByBoxExplicitSelfCategory => {\n-            rbml_w.writer.write_all(&[ '~' as u8 ]);\n+            rbml_w.wr_tagged_bytes(tag, &['~' as u8]);\n         }\n         ty::ByReferenceExplicitSelfCategory(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n-            rbml_w.writer.write_all(&['&' as u8]);\n-            encode_mutability(rbml_w, m);\n+            let ch = encode_mutability(m);\n+            rbml_w.wr_tagged_bytes(tag, &['&' as u8, ch]);\n         }\n     }\n \n-    rbml_w.end_tag();\n-\n-    fn encode_mutability(rbml_w: &mut Encoder,\n-                         m: ast::Mutability) {\n+    fn encode_mutability(m: ast::Mutability) -> u8 {\n         match m {\n-            ast::MutImmutable => { rbml_w.writer.write_all(&[ 'i' as u8 ]); }\n-            ast::MutMutable => { rbml_w.writer.write_all(&[ 'm' as u8 ]); }\n+            ast::MutImmutable => 'i' as u8,\n+            ast::MutMutable => 'm' as u8,\n         }\n     }\n }\n \n fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n-    rbml_w.start_tag(tag_item_trait_item_sort);\n-    rbml_w.writer.write_all(&[ sort as u8 ]);\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_u8(tag_item_trait_item_sort, sort as u8);\n }\n \n fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n-    rbml_w.start_tag(tag_item_trait_parent_sort);\n-    rbml_w.writer.write_all(&[ sort as u8 ]);\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_u8(tag_item_trait_parent_sort, sort as u8);\n }\n \n fn encode_provided_source(rbml_w: &mut Encoder,\n                           source_opt: Option<DefId>) {\n     if let Some(source) = source_opt {\n-        rbml_w.start_tag(tag_item_method_provided_source);\n-        let s = def_to_string(source);\n-        rbml_w.writer.write_all(s.as_bytes());\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_item_method_provided_source,\n+                             &def_to_string(source));\n     }\n }\n \n@@ -747,8 +709,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     // indicate that this is a tuple struct ctor, because downstream users will normally want\n     // the tuple struct definition, but without this there is no way for them to tell that\n     // they actually have a ctor rather than a normal function\n-    rbml_w.start_tag(tag_items_data_item_is_tuple_struct_ctor);\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n \n     rbml_w.end_tag();\n }\n@@ -919,12 +880,13 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n                                 decl: &ast::FnDecl) {\n     rbml_w.start_tag(tag_method_argument_names);\n     for arg in &decl.inputs {\n-        rbml_w.start_tag(tag_method_argument_name);\n+        let tag = tag_method_argument_name;\n         if let ast::PatIdent(_, ref path1, _) = arg.pat.node {\n             let name = token::get_ident(path1.node);\n-            rbml_w.writer.write_all(name.as_bytes());\n+            rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n+        } else {\n+            rbml_w.wr_tagged_bytes(tag, &[]);\n         }\n-        rbml_w.end_tag();\n     }\n     rbml_w.end_tag();\n }\n@@ -1091,9 +1053,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         // Encode all the items in this module.\n         for foreign_item in &fm.items {\n-            rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(local_def(foreign_item.id)));\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_mod_child,\n+                                 &def_to_string(local_def(foreign_item.id)));\n         }\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1339,9 +1300,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n \n-            rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(method_def_id.def_id()));\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_mod_child,\n+                                 &def_to_string(method_def_id.def_id()));\n         }\n         encode_path(rbml_w, path.clone());\n \n@@ -1642,31 +1602,23 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n     match mi.node {\n       ast::MetaWord(ref name) => {\n         rbml_w.start_tag(tag_meta_item_word);\n-        rbml_w.start_tag(tag_meta_item_name);\n-        rbml_w.writer.write_all(name.as_bytes());\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_meta_item_name, name);\n         rbml_w.end_tag();\n       }\n       ast::MetaNameValue(ref name, ref value) => {\n         match value.node {\n           ast::LitStr(ref value, _) => {\n             rbml_w.start_tag(tag_meta_item_name_value);\n-            rbml_w.start_tag(tag_meta_item_name);\n-            rbml_w.writer.write_all(name.as_bytes());\n-            rbml_w.end_tag();\n-            rbml_w.start_tag(tag_meta_item_value);\n-            rbml_w.writer.write_all(value.as_bytes());\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_meta_item_name, name);\n+            rbml_w.wr_tagged_str(tag_meta_item_value, value);\n             rbml_w.end_tag();\n           }\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n       ast::MetaList(ref name, ref items) => {\n         rbml_w.start_tag(tag_meta_item_list);\n-        rbml_w.start_tag(tag_meta_item_name);\n-        rbml_w.writer.write_all(name.as_bytes());\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_meta_item_name, name);\n         for inner_item in items {\n             encode_meta_item(rbml_w, &**inner_item);\n         }\n@@ -1760,22 +1712,9 @@ fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n         if let Some(id) = def_id {\n             if id.krate == ast::LOCAL_CRATE {\n                 rbml_w.start_tag(tag_lang_items_item);\n-\n-                rbml_w.start_tag(tag_lang_items_item_id);\n-                {\n-                    let wr: &mut SeekableMemWriter = rbml_w.writer;\n-                    wr.write_be_u32(i as u32);\n-                }\n-                rbml_w.end_tag();   // tag_lang_items_item_id\n-\n-                rbml_w.start_tag(tag_lang_items_item_node_id);\n-                {\n-                    let wr: &mut SeekableMemWriter = rbml_w.writer;\n-                    wr.write_be_u32(id.node as u32);\n-                }\n-                rbml_w.end_tag();   // tag_lang_items_item_node_id\n-\n-                rbml_w.end_tag();   // tag_lang_items_item\n+                rbml_w.wr_tagged_u32(tag_lang_items_item_id, i as u32);\n+                rbml_w.wr_tagged_u32(tag_lang_items_item_node_id, id.node as u32);\n+                rbml_w.end_tag();\n             }\n         }\n     }\n@@ -1796,15 +1735,8 @@ fn encode_native_libraries(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n             cstore::NativeStatic => {} // these libraries are not propagated\n             cstore::NativeFramework | cstore::NativeUnknown => {\n                 rbml_w.start_tag(tag_native_libraries_lib);\n-\n-                rbml_w.start_tag(tag_native_libraries_kind);\n-                rbml_w.writer.write_be_u32(kind as u32);\n-                rbml_w.end_tag();\n-\n-                rbml_w.start_tag(tag_native_libraries_name);\n-                rbml_w.writer.write_all(lib.as_bytes());\n-                rbml_w.end_tag();\n-\n+                rbml_w.wr_tagged_u32(tag_native_libraries_kind, kind as u32);\n+                rbml_w.wr_tagged_str(tag_native_libraries_name, lib);\n                 rbml_w.end_tag();\n             }\n         }\n@@ -1830,9 +1762,8 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n         encode_name(rbml_w, def.ident.name);\n         encode_attributes(rbml_w, &def.attrs);\n \n-        rbml_w.start_tag(tag_macro_def_body);\n-        rbml_w.wr_str(&pprust::tts_to_string(&def.body));\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_macro_def_body,\n+                             &pprust::tts_to_string(&def.body));\n \n         rbml_w.end_tag();\n     }\n@@ -1917,15 +1848,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in &krate.module.items {\n-        rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(&def_to_string(local_def(item.id)));\n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_str(tag_mod_child,\n+                             &def_to_string(local_def(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n-            rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(local_def(\n-                        auxiliary_node_id)));\n-            rbml_w.end_tag();\n+            rbml_w.wr_tagged_str(tag_mod_child,\n+                                 &def_to_string(local_def(auxiliary_node_id)));\n             true\n         });\n     }\n@@ -1956,35 +1884,25 @@ fn encode_reachable_extern_fns(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n fn encode_crate_dep(rbml_w: &mut Encoder,\n                     dep: decoder::CrateDep) {\n     rbml_w.start_tag(tag_crate_dep);\n-    rbml_w.start_tag(tag_crate_dep_crate_name);\n-    rbml_w.writer.write_all(dep.name.as_bytes());\n-    rbml_w.end_tag();\n-    rbml_w.start_tag(tag_crate_dep_hash);\n-    rbml_w.writer.write_all(dep.hash.as_str().as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_crate_dep_crate_name, &dep.name);\n+    rbml_w.wr_tagged_str(tag_crate_dep_hash, dep.hash.as_str());\n     rbml_w.end_tag();\n }\n \n fn encode_hash(rbml_w: &mut Encoder, hash: &Svh) {\n-    rbml_w.start_tag(tag_crate_hash);\n-    rbml_w.writer.write_all(hash.as_str().as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_crate_hash, hash.as_str());\n }\n \n fn encode_crate_name(rbml_w: &mut Encoder, crate_name: &str) {\n-    rbml_w.start_tag(tag_crate_crate_name);\n-    rbml_w.writer.write_all(crate_name.as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_crate_crate_name, crate_name);\n }\n \n fn encode_crate_triple(rbml_w: &mut Encoder, triple: &str) {\n-    rbml_w.start_tag(tag_crate_triple);\n-    rbml_w.writer.write_all(triple.as_bytes());\n-    rbml_w.end_tag();\n+    rbml_w.wr_tagged_str(tag_crate_triple, triple);\n }\n \n fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n-    rbml_w.start_tag(tag_dylib_dependency_formats);\n+    let tag = tag_dylib_dependency_formats;\n     match ecx.tcx.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n         Some(arr) => {\n             let s = arr.iter().enumerate().filter_map(|(i, slot)| {\n@@ -1993,11 +1911,12 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n                     cstore::RequireStatic => \"s\",\n                 })).to_string())\n             }).collect::<Vec<String>>();\n-            rbml_w.writer.write_all(s.connect(\",\").as_bytes());\n+            rbml_w.wr_tagged_str(tag, &s.connect(\",\"));\n+        }\n+        None => {\n+            rbml_w.wr_tagged_str(tag, \"\");\n         }\n-        None => {}\n     }\n-    rbml_w.end_tag();\n }\n \n // NB: Increment this as you change the metadata encoding version."}]}