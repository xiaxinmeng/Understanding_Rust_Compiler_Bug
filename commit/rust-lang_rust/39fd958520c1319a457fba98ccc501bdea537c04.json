{"sha": "39fd958520c1319a457fba98ccc501bdea537c04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZmQ5NTg1MjBjMTMxOWE0NTdmYmE5OGNjYzUwMWJkZWE1MzdjMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-12T07:48:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-12T07:48:11Z"}, "message": "Auto merge of #44967 - wesleywiser:trans_fulfill_obligation, r=nikomatsakis\n\nTurn `trans_fulfill_obligation` into a query\n\nPart of #44891", "tree": {"sha": "e2bfb322cf7cb4096aa6f6ec4f62eeb0ca44e82f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2bfb322cf7cb4096aa6f6ec4f62eeb0ca44e82f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39fd958520c1319a457fba98ccc501bdea537c04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39fd958520c1319a457fba98ccc501bdea537c04", "html_url": "https://github.com/rust-lang/rust/commit/39fd958520c1319a457fba98ccc501bdea537c04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39fd958520c1319a457fba98ccc501bdea537c04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d27411494a98e7958cd7aa1c61d370e8cce29fcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d27411494a98e7958cd7aa1c61d370e8cce29fcc", "html_url": "https://github.com/rust-lang/rust/commit/d27411494a98e7958cd7aa1c61d370e8cce29fcc"}, {"sha": "31f4b570025f46d0b29c79f2b493d2db65438b30", "url": "https://api.github.com/repos/rust-lang/rust/commits/31f4b570025f46d0b29c79f2b493d2db65438b30", "html_url": "https://github.com/rust-lang/rust/commit/31f4b570025f46d0b29c79f2b493d2db65438b30"}], "stats": {"total": 308, "additions": 226, "deletions": 82}, "files": [{"sha": "b44262416343d1d9338d726374eaef6582cd33da", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=39fd958520c1319a457fba98ccc501bdea537c04", "patch": "@@ -65,7 +65,7 @@ use hir::map::DefPathHash;\n use hir::{HirId, ItemLocalId};\n \n use ich::Fingerprint;\n-use ty::{TyCtxt, Instance, InstanceDef, ParamEnvAnd, Ty};\n+use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n use ty::subst::Substs;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use ich::StableHashingContext;\n@@ -505,6 +505,7 @@ define_dep_nodes!( <'tcx>\n     [] InstanceSymbolName { instance: Instance<'tcx> },\n     [] SpecializationGraph(DefId),\n     [] ObjectSafety(DefId),\n+    [] FulfillObligation { param_env: ParamEnv<'tcx>, trait_ref: PolyTraitRef<'tcx> },\n \n     [] IsCopy { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n     [] IsSized { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },"}, {"sha": "6e55365980cde7abcb5ca17119df6bb34d94a456", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=39fd958520c1319a457fba98ccc501bdea537c04", "patch": "@@ -841,3 +841,129 @@ impl_stable_hash_for!(struct ::util::common::ErrorReported {});\n impl_stable_hash_for!(tuple_struct ::middle::reachable::ReachableSet {\n     reachable_set\n });\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::Vtable::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match self {\n+            &VtableImpl(ref table_impl) => table_impl.hash_stable(hcx, hasher),\n+            &VtableDefaultImpl(ref table_def_impl) => table_def_impl.hash_stable(hcx, hasher),\n+            &VtableParam(ref table_param) => table_param.hash_stable(hcx, hasher),\n+            &VtableObject(ref table_obj) => table_obj.hash_stable(hcx, hasher),\n+            &VtableBuiltin(ref table_builtin) => table_builtin.hash_stable(hcx, hasher),\n+            &VtableClosure(ref table_closure) => table_closure.hash_stable(hcx, hasher),\n+            &VtableFnPointer(ref table_fn_pointer) => table_fn_pointer.hash_stable(hcx, hasher),\n+            &VtableGenerator(ref table_generator) => table_generator.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableImplData {\n+            impl_def_id,\n+            substs,\n+            ref nested,\n+        } = *self;\n+        impl_def_id.hash_stable(hcx, hasher);\n+        substs.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableDefaultImplData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableDefaultImplData {\n+            trait_def_id,\n+            ref nested,\n+        } = *self;\n+        trait_def_id.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableObjectData {\n+            upcast_trait_ref,\n+            vtable_base,\n+            ref nested,\n+        } = *self;\n+        upcast_trait_ref.hash_stable(hcx, hasher);\n+        vtable_base.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableBuiltinData {\n+            ref nested,\n+        } = *self;\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableClosureData {\n+            closure_def_id,\n+            substs,\n+            ref nested,\n+        } = *self;\n+        closure_def_id.hash_stable(hcx, hasher);\n+        substs.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableFnPointerData {\n+            fn_ty,\n+            ref nested,\n+        } = *self;\n+        fn_ty.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableGeneratorData {\n+            closure_def_id,\n+            substs,\n+            ref nested,\n+        } = *self;\n+        closure_def_id.hash_stable(hcx, hasher);\n+        substs.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "bdfbefd13649e75337f83aeb88b4493b31c747d7", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=39fd958520c1319a457fba98ccc501bdea537c04", "patch": "@@ -835,6 +835,7 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n+        trans_fulfill_obligation: trans::trans_fulfill_obligation,\n         ..*providers\n     };\n }\n@@ -844,6 +845,7 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n+        trans_fulfill_obligation: trans::trans_fulfill_obligation,\n         ..*providers\n     };\n }"}, {"sha": "aa3179dd01f566d487ee03f97e4629b2780a4bd4", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 64, "deletions": 74, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=39fd958520c1319a457fba98ccc501bdea537c04", "patch": "@@ -17,85 +17,77 @@ use dep_graph::{DepGraph, DepKind, DepTrackingMap, DepTrackingMapConfig};\n use infer::TransNormalize;\n use std::cell::RefCell;\n use std::marker::PhantomData;\n-use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::DUMMY_SP;\n use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, Vtable};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::{Subst, Substs};\n use ty::fold::{TypeFoldable, TypeFolder};\n use util::common::MemoizationMap;\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-    /// Attempts to resolve an obligation to a vtable.. The result is\n-    /// a shallow vtable resolution -- meaning that we do not\n-    /// (necessarily) resolve all nested obligations on the impl. Note\n-    /// that type check should guarantee to us that all nested\n-    /// obligations *could be* resolved if we wanted to.\n-    /// Assumes that this is run after the entire crate has been successfully type-checked.\n-    pub fn trans_fulfill_obligation(self,\n-                                    span: Span,\n-                                    param_env: ty::ParamEnv<'tcx>,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> Vtable<'tcx, ()>\n-    {\n-        // Remove any references to regions; this helps improve caching.\n-        let trait_ref = self.erase_regions(&trait_ref);\n-\n-        self.trans_trait_caches.trait_cache.memoize((param_env, trait_ref), || {\n-            debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-                   (param_env, trait_ref), trait_ref.def_id());\n-\n-            // Do the initial selection for the obligation. This yields the\n-            // shallow result we are looking for -- that is, what specific impl.\n-            self.infer_ctxt().enter(|infcx| {\n-                let mut selcx = SelectionContext::new(&infcx);\n-\n-                let obligation_cause = ObligationCause::misc(span,\n-                                                             ast::DUMMY_NODE_ID);\n-                let obligation = Obligation::new(obligation_cause,\n-                                                 param_env,\n-                                                 trait_ref.to_poly_trait_predicate());\n-\n-                let selection = match selcx.select(&obligation) {\n-                    Ok(Some(selection)) => selection,\n-                    Ok(None) => {\n-                        // Ambiguity can happen when monomorphizing during trans\n-                        // expands to some humongo type that never occurred\n-                        // statically -- this humongo type can then overflow,\n-                        // leading to an ambiguous result. So report this as an\n-                        // overflow bug, since I believe this is the only case\n-                        // where ambiguity can result.\n-                        debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n-                                presuming due to overflow\",\n-                               trait_ref);\n-                        self.sess.span_fatal(span,\n-                                            \"reached the recursion limit during monomorphization \\\n-                                             (selection ambiguity)\");\n-                    }\n-                    Err(e) => {\n-                        span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                                  e, trait_ref)\n-                    }\n-                };\n-\n-                debug!(\"fulfill_obligation: selection={:?}\", selection);\n-\n-                // Currently, we use a fulfillment context to completely resolve\n-                // all nested obligations. This is because they can inform the\n-                // inference of the impl's type parameters.\n-                let mut fulfill_cx = FulfillmentContext::new();\n-                let vtable = selection.map(|predicate| {\n-                    debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n-                    fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-                });\n-                let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n-\n-                info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-                vtable\n-            })\n-        })\n-    }\n+/// Attempts to resolve an obligation to a vtable.. The result is\n+/// a shallow vtable resolution -- meaning that we do not\n+/// (necessarily) resolve all nested obligations on the impl. Note\n+/// that type check should guarantee to us that all nested\n+/// obligations *could be* resolved if we wanted to.\n+/// Assumes that this is run after the entire crate has been successfully type-checked.\n+pub fn trans_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n+                                          (param_env, trait_ref):\n+                                          (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>))\n+                                          -> Vtable<'tcx, ()>\n+{\n+    // Remove any references to regions; this helps improve caching.\n+    let trait_ref = ty.erase_regions(&trait_ref);\n+\n+    debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+            (param_env, trait_ref), trait_ref.def_id());\n+\n+    // Do the initial selection for the obligation. This yields the\n+    // shallow result we are looking for -- that is, what specific impl.\n+    ty.infer_ctxt().enter(|infcx| {\n+        let mut selcx = SelectionContext::new(&infcx);\n+\n+        let obligation_cause = ObligationCause::dummy();\n+        let obligation = Obligation::new(obligation_cause,\n+                                            param_env,\n+                                            trait_ref.to_poly_trait_predicate());\n+\n+        let selection = match selcx.select(&obligation) {\n+            Ok(Some(selection)) => selection,\n+            Ok(None) => {\n+                // Ambiguity can happen when monomorphizing during trans\n+                // expands to some humongo type that never occurred\n+                // statically -- this humongo type can then overflow,\n+                // leading to an ambiguous result. So report this as an\n+                // overflow bug, since I believe this is the only case\n+                // where ambiguity can result.\n+                bug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                        presuming due to overflow\",\n+                        trait_ref)\n+            }\n+            Err(e) => {\n+                bug!(\"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                            e, trait_ref)\n+            }\n+        };\n+\n+        debug!(\"fulfill_obligation: selection={:?}\", selection);\n+\n+        // Currently, we use a fulfillment context to completely resolve\n+        // all nested obligations. This is because they can inform the\n+        // inference of the impl's type parameters.\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let vtable = selection.map(|predicate| {\n+            debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n+            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+        });\n+        let vtable = infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable);\n+\n+        info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+        vtable\n+    })\n+}\n \n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// Monomorphizes a type from the AST by first applying the in-scope\n     /// substitutions and then normalizing any associated types.\n     pub fn trans_apply_param_substs<T>(self,\n@@ -149,14 +141,12 @@ impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n /// Specializes caches used in trans -- in particular, they assume all\n /// types are fully monomorphized and that free regions can be erased.\n pub struct TransTraitCaches<'tcx> {\n-    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n     project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n }\n \n impl<'tcx> TransTraitCaches<'tcx> {\n     pub fn new(graph: DepGraph) -> Self {\n         TransTraitCaches {\n-            trait_cache: RefCell::new(DepTrackingMap::new(graph.clone())),\n             project_cache: RefCell::new(DepTrackingMap::new(graph)),\n         }\n     }"}, {"sha": "600b2572f92b858544abdb018f63ab335d90d226", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=39fd958520c1319a457fba98ccc501bdea537c04", "patch": "@@ -13,7 +13,6 @@ use ty::{self, Ty, TypeFoldable, Substs, TyCtxt};\n use ty::subst::{Kind, Subst};\n use traits;\n use syntax::abi::Abi;\n-use syntax::codemap::DUMMY_SP;\n use util::ppaux;\n \n use std::fmt;\n@@ -212,7 +211,7 @@ fn resolve_associated_item<'a, 'tcx>(\n            def_id, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = tcx.trans_fulfill_obligation(DUMMY_SP, param_env, ty::Binder(trait_ref));\n+    let vtbl = tcx.trans_fulfill_obligation((param_env, ty::Binder(trait_ref)));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:"}, {"sha": "dee1516e0f8b310efe16cee10b13ef4895765e99", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=39fd958520c1319a457fba98ccc501bdea537c04", "patch": "@@ -221,6 +221,12 @@ impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::trans_fulfill_obligation<'tcx> {\n+    fn describe(tcx: TyCtxt, key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> String {\n+        format!(\"checking if `{}` fulfills its obligations\", tcx.item_path_str(key.1.def_id()))\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))"}, {"sha": "1bd4f3e657eb0260d632b263266927d4b4b43243", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=39fd958520c1319a457fba98ccc501bdea537c04", "patch": "@@ -134,6 +134,15 @@ impl Key for (MirSuite, MirPassIndex, DefId) {\n     }\n }\n \n+impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.1.def_id().krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.1.def_id())\n+    }\n+}\n+\n impl<'tcx> Key for Ty<'tcx> {\n     fn map_crate(&self) -> CrateNum {\n         LOCAL_CRATE"}, {"sha": "2001de88803aa233ced8fe63e65513fc50067f68", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=39fd958520c1319a457fba98ccc501bdea537c04", "patch": "@@ -30,6 +30,7 @@ use middle::trans::{CodegenUnit, Stats};\n use mir;\n use session::CompileResult;\n use session::config::OutputFilenames;\n+use traits::Vtable;\n use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::layout::{Layout, LayoutError};\n@@ -228,6 +229,8 @@ define_maps! { <'tcx>\n     [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n \n+    [] fn trans_fulfill_obligation: fulfill_obligation_dep_node(\n+        (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Vtable<'tcx, ()>,\n     [] fn trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n     [] fn specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n     [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n@@ -347,6 +350,14 @@ fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstr\n     }\n }\n \n+fn fulfill_obligation_dep_node<'tcx>((param_env, trait_ref):\n+    (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> DepConstructor<'tcx> {\n+    DepConstructor::FulfillObligation {\n+        param_env,\n+        trait_ref\n+    }\n+}\n+\n fn coherent_trait_dep_node<'tcx>((_, def_id): (CrateNum, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::CoherenceCheckTrait(def_id)\n }"}, {"sha": "61355381761091effa681331470e1f214faf2252", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=39fd958520c1319a457fba98ccc501bdea537c04", "patch": "@@ -748,6 +748,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::TypeParamPredicates |\n         DepKind::CodegenUnit |\n         DepKind::CompileCodegenUnit |\n+        DepKind::FulfillObligation |\n \n         // These are just odd\n         DepKind::Null |"}, {"sha": "471be439a8f3bb41df43d7d241ffb0bf2a13c5a2", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fd958520c1319a457fba98ccc501bdea537c04/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=39fd958520c1319a457fba98ccc501bdea537c04", "patch": "@@ -15,8 +15,6 @@ use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n \n-use syntax::codemap::DUMMY_SP;\n-\n pub use rustc::ty::Instance;\n \n fn fn_once_adapter_instance<'a, 'tcx>(\n@@ -110,13 +108,14 @@ pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            source_ty: Ty<'tcx>,\n                                            target_ty: Ty<'tcx>)\n                                            -> CustomCoerceUnsized {\n+    let def_id = tcx.lang_items().coerce_unsized_trait().unwrap();\n+\n     let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n+        def_id: def_id,\n         substs: tcx.mk_substs_trait(source_ty, &[target_ty])\n     });\n \n-    match tcx.trans_fulfill_obligation(\n-        DUMMY_SP, ty::ParamEnv::empty(traits::Reveal::All), trait_ref) {\n+    match tcx.trans_fulfill_obligation( (ty::ParamEnv::empty(traits::Reveal::All), trait_ref)) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n             tcx.coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }"}]}