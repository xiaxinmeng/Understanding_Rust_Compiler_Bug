{"sha": "7f52239cab61f58c46f89c1a83616186a873c921", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNTIyMzljYWI2MWY1OGM0NmY4OWMxYTgzNjE2MTg2YTg3M2M5MjE=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-17T15:51:30Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-17T17:58:21Z"}, "message": "consts: convert to using a struct with state\n\nStruct has the context reference (as an Option) and the\nneeded_resolution flag.", "tree": {"sha": "2145024d848f6ce153591d1c7d1762d5506a142d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2145024d848f6ce153591d1c7d1762d5506a142d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f52239cab61f58c46f89c1a83616186a873c921", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f52239cab61f58c46f89c1a83616186a873c921", "html_url": "https://github.com/rust-lang/rust/commit/7f52239cab61f58c46f89c1a83616186a873c921", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f52239cab61f58c46f89c1a83616186a873c921/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "202e66708ebfbce1a066cdc11c8f0a813d130f40", "url": "https://api.github.com/repos/rust-lang/rust/commits/202e66708ebfbce1a066cdc11c8f0a813d130f40", "html_url": "https://github.com/rust-lang/rust/commit/202e66708ebfbce1a066cdc11c8f0a813d130f40"}], "stats": {"total": 619, "additions": 289, "deletions": 330}, "files": [{"sha": "df669007b1e639b84c3ce733d00e9774a27aa149", "filename": "src/consts.rs", "status": "modified", "additions": 277, "deletions": 310, "changes": 587, "blob_url": "https://github.com/rust-lang/rust/blob/7f52239cab61f58c46f89c1a83616186a873c921/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f52239cab61f58c46f89c1a83616186a873c921/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=7f52239cab61f58c46f89c1a83616186a873c921", "patch": "@@ -8,7 +8,7 @@ use std::cmp::PartialOrd;\n use std::cmp::Ordering::{self, Greater, Less, Equal};\n use std::rc::Rc;\n use std::ops::Deref;\n-use self::ConstantVariant::*;\n+use self::Constant::*;\n use self::FloatWidth::*;\n \n #[derive(PartialEq, Eq, Debug, Copy, Clone)]\n@@ -27,42 +27,9 @@ impl From<FloatTy> for FloatWidth {\n     }\n }\n \n-#[derive(PartialEq, Eq, Debug, Clone)]\n-pub struct Constant {\n-    pub constant: ConstantVariant,\n-    pub needed_resolution: bool\n-}\n-\n-impl Constant {\n-    pub fn new(variant: ConstantVariant) -> Constant {\n-        Constant { constant: variant, needed_resolution: false }\n-    }\n-\n-    pub fn new_resolved(variant: ConstantVariant) -> Constant {\n-        Constant { constant: variant, needed_resolution: true }\n-    }\n-\n-    // convert this constant to a f64, if possible\n-    pub fn as_float(&self) -> Option<f64> {\n-        match &self.constant {\n-            &ConstantByte(b) => Some(b as f64),\n-            &ConstantFloat(ref s, _) => s.parse().ok(),\n-            &ConstantInt(i, ty) => Some(if is_negative(ty) {\n-                -(i as f64) } else { i as f64 }),\n-            _ => None\n-        }\n-    }\n-}\n-\n-impl PartialOrd for Constant {\n-    fn partial_cmp(&self, other: &Constant) -> Option<Ordering> {\n-        self.constant.partial_cmp(&other.constant)\n-    }\n-}\n-\n /// a Lit_-like enum to fold constant `Expr`s into\n #[derive(Eq, Debug, Clone)]\n-pub enum ConstantVariant {\n+pub enum Constant {\n     /// a String \"abc\"\n     ConstantStr(String, StrStyle),\n     /// a Binary String b\"abc\"\n@@ -80,12 +47,12 @@ pub enum ConstantVariant {\n     /// an array of constants\n     ConstantVec(Vec<Constant>),\n     /// also an array, but with only one constant, repeated N times\n-    ConstantRepeat(Box<ConstantVariant>, usize),\n+    ConstantRepeat(Box<Constant>, usize),\n     /// a tuple of constants\n     ConstantTuple(Vec<Constant>),\n }\n \n-impl ConstantVariant {\n+impl Constant {\n     /// convert to u64 if possible\n     ///\n     /// # panics\n@@ -98,10 +65,21 @@ impl ConstantVariant {\n             panic!(\"Could not convert a {:?} to u64\");\n         }\n     }\n+\n+    /// convert this constant to a f64, if possible\n+   pub fn as_float(&self) -> Option<f64> {\n+       match *self {\n+           ConstantByte(b) => Some(b as f64),\n+           ConstantFloat(ref s, _) => s.parse().ok(),\n+           ConstantInt(i, ty) => Some(if is_negative(ty) {\n+               -(i as f64) } else { i as f64 }),\n+           _ => None\n+       }\n+   }\n }\n \n-impl PartialEq for ConstantVariant {\n-    fn eq(&self, other: &ConstantVariant) -> bool {\n+impl PartialEq for Constant {\n+    fn eq(&self, other: &Constant) -> bool {\n         match (self, other) {\n             (&ConstantStr(ref ls, ref lsty), &ConstantStr(ref rs, ref rsty)) =>\n                 ls == rs && lsty == rsty,\n@@ -130,8 +108,8 @@ impl PartialEq for ConstantVariant {\n     }\n }\n \n-impl PartialOrd for ConstantVariant {\n-    fn partial_cmp(&self, other: &ConstantVariant) -> Option<Ordering> {\n+impl PartialOrd for Constant {\n+    fn partial_cmp(&self, other: &Constant) -> Option<Ordering> {\n         match (self, other) {\n             (&ConstantStr(ref ls, ref lsty), &ConstantStr(ref rs, ref rsty)) =>\n                 if lsty != rsty { None } else { Some(ls.cmp(rs)) },\n@@ -168,173 +146,67 @@ impl PartialOrd for ConstantVariant {\n     }\n }\n \n-/// simple constant folding: Insert an expression, get a constant or none.\n-pub fn constant(cx: &Context, e: &Expr) -> Option<Constant> {\n-    match &e.node {\n-        &ExprParen(ref inner) => constant(cx, inner),\n-        &ExprPath(_, _) => fetch_path(cx, e),\n-        &ExprBlock(ref block) => constant_block(cx, block),\n-        &ExprIf(ref cond, ref then, ref otherwise) =>\n-            constant_if(cx, &*cond, &*then, &*otherwise),\n-        &ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n-        &ExprVec(ref vec) => constant_vec(cx, &vec[..]),\n-        &ExprTup(ref tup) => constant_tup(cx, &tup[..]),\n-        &ExprRepeat(ref value, ref number) =>\n-            constant_binop_apply(cx, value, number,|v, n|\n-                Some(ConstantRepeat(Box::new(v), n.as_u64() as usize))),\n-        &ExprUnary(op, ref operand) => constant(cx, operand).and_then(\n-            |o| match op {\n-                UnNot => constant_not(o),\n-                UnNeg => constant_negate(o),\n-                UnUniq | UnDeref => Some(o),\n-            }),\n-        &ExprBinary(op, ref left, ref right) =>\n-            constant_binop(cx, op, left, right),\n-        //TODO: add other expressions\n-        _ => None,\n-    }\n-}\n+\n \n fn lit_to_constant(lit: &Lit_) -> Constant {\n     match lit {\n-        &LitStr(ref is, style) =>\n-            Constant::new(ConstantStr(is.to_string(), style)),\n-        &LitBinary(ref blob) => Constant::new(ConstantBinary(blob.clone())),\n-        &LitByte(b) => Constant::new(ConstantByte(b)),\n-        &LitChar(c) => Constant::new(ConstantChar(c)),\n-        &LitInt(value, ty) => Constant::new(ConstantInt(value, ty)),\n-        &LitFloat(ref is, ty) => {\n-            Constant::new(ConstantFloat(is.to_string(), ty.into()))\n-        },\n-        &LitFloatUnsuffixed(ref is) => {\n-            Constant::new(ConstantFloat(is.to_string(), FwAny))\n-        },\n-        &LitBool(b) => Constant::new(ConstantBool(b)),\n+        &LitStr(ref is, style) => ConstantStr(is.to_string(), style),\n+        &LitBinary(ref blob) => ConstantBinary(blob.clone()),\n+        &LitByte(b) => ConstantByte(b),\n+        &LitChar(c) => ConstantChar(c),\n+        &LitInt(value, ty) => ConstantInt(value, ty),\n+        &LitFloat(ref is, ty) => ConstantFloat(is.to_string(), ty.into()),\n+        &LitFloatUnsuffixed(ref is) => ConstantFloat(is.to_string(), FwAny),\n+        &LitBool(b) => ConstantBool(b),\n     }\n }\n \n-/// create `Some(ConstantVec(..))` of all constants, unless there is any\n-/// non-constant part\n-fn constant_vec<E: Deref<Target=Expr> + Sized>(cx: &Context, vec: &[E]) -> Option<Constant> {\n-    let mut parts = Vec::new();\n-    let mut resolved = false;\n-    for opt_part in vec {\n-        match constant(cx, opt_part) {\n-            Some(p) => {\n-                resolved |= p.needed_resolution;\n-                parts.push(p)\n-            },\n-            None => { return None; },\n-        }\n-    }\n-    Some(Constant {\n-        constant: ConstantVec(parts),\n-        needed_resolution: resolved\n-    })\n-}\n-\n-fn constant_tup<E: Deref<Target=Expr> + Sized>(cx: &Context, tup: &[E]) -> Option<Constant> {\n-    let mut parts = Vec::new();\n-    let mut resolved = false;\n-    for opt_part in tup {\n-        match constant(cx, opt_part) {\n-            Some(p) => {\n-                resolved |= p.needed_resolution;\n-                parts.push(p)\n-            },\n-            None => { return None; },\n-        }\n-    }\n-    Some(Constant {\n-        constant: ConstantTuple(parts),\n-        needed_resolution: resolved\n-    })\n-}\n-\n-/// lookup a possibly constant expression from a ExprPath\n-fn fetch_path(cx: &Context, e: &Expr) -> Option<Constant> {\n-    if let Some(&PathResolution { base_def: DefConst(id), ..}) =\n-            cx.tcx.def_map.borrow().get(&e.id) {\n-        lookup_const_by_id(cx.tcx, id, None).and_then(\n-            |l| constant(cx, l).map(|c| Constant::new_resolved(c.constant)))\n-    } else { None }\n-}\n-\n-/// A block can only yield a constant if it only has one constant expression\n-fn constant_block(cx: &Context, block: &Block) -> Option<Constant> {\n-    if block.stmts.is_empty() {\n-        block.expr.as_ref().and_then(|b| constant(cx, &*b))\n-    } else { None }\n-}\n-\n-fn constant_if(cx: &Context, cond: &Expr, then: &Block, otherwise:\n-        &Option<P<Expr>>) -> Option<Constant> {\n-    if let Some(Constant{ constant: ConstantBool(b), needed_resolution: res }) =\n-            constant(cx, cond) {\n-        if b {\n-            constant_block(cx, then)\n-        } else {\n-            otherwise.as_ref().and_then(|expr| constant(cx, &*expr))\n-        }.map(|part|\n-            Constant {\n-                constant: part.constant,\n-                needed_resolution: res || part.needed_resolution,\n-            })\n-    } else { None }\n-}\n-\n fn constant_not(o: Constant) -> Option<Constant> {\n-    Some(Constant {\n-        needed_resolution: o.needed_resolution,\n-        constant: match o.constant {\n-            ConstantBool(b) => ConstantBool(!b),\n-            ConstantInt(value, ty) => {\n-                let (nvalue, nty) = match ty {\n-                    SignedIntLit(ity, Plus) => {\n-                        if value == ::std::u64::MAX { return None; }\n-                        (value + 1, SignedIntLit(ity, Minus))\n-                    },\n-                    SignedIntLit(ity, Minus) => {\n-                        if value == 0 {\n-                            (1, SignedIntLit(ity, Minus))\n-                        } else {\n-                            (value - 1, SignedIntLit(ity, Plus))\n-                        }\n-                    }\n-                    UnsignedIntLit(ity) => {\n-                        let mask = match ity {\n-                            UintTy::TyU8 => ::std::u8::MAX as u64,\n-                            UintTy::TyU16 => ::std::u16::MAX as u64,\n-                            UintTy::TyU32 => ::std::u32::MAX as u64,\n-                            UintTy::TyU64 => ::std::u64::MAX,\n-                            UintTy::TyUs => { return None; }  // refuse to guess\n-                        };\n-                        (!value & mask, UnsignedIntLit(ity))\n+    Some(match o {\n+        ConstantBool(b) => ConstantBool(!b),\n+        ConstantInt(value, ty) => {\n+            let (nvalue, nty) = match ty {\n+                SignedIntLit(ity, Plus) => {\n+                    if value == ::std::u64::MAX { return None; }\n+                    (value + 1, SignedIntLit(ity, Minus))\n+                },\n+                SignedIntLit(ity, Minus) => {\n+                    if value == 0 {\n+                        (1, SignedIntLit(ity, Minus))\n+                    } else {\n+                        (value - 1, SignedIntLit(ity, Plus))\n                     }\n-                    UnsuffixedIntLit(_) => { return None; }  // refuse to guess\n-                };\n-                ConstantInt(nvalue, nty)\n-            },\n-            _ => { return None; }\n-        }\n+                }\n+                UnsignedIntLit(ity) => {\n+                    let mask = match ity {\n+                        UintTy::TyU8 => ::std::u8::MAX as u64,\n+                        UintTy::TyU16 => ::std::u16::MAX as u64,\n+                        UintTy::TyU32 => ::std::u32::MAX as u64,\n+                        UintTy::TyU64 => ::std::u64::MAX,\n+                        UintTy::TyUs => { return None; }  // refuse to guess\n+                    };\n+                    (!value & mask, UnsignedIntLit(ity))\n+                }\n+                UnsuffixedIntLit(_) => { return None; }  // refuse to guess\n+            };\n+            ConstantInt(nvalue, nty)\n+        },\n+        _ => { return None; }\n     })\n }\n \n fn constant_negate(o: Constant) -> Option<Constant> {\n-    Some(Constant{\n-        needed_resolution: o.needed_resolution,\n-        constant: match o.constant {\n-            ConstantInt(value, ty) =>\n-                ConstantInt(value, match ty {\n-                    SignedIntLit(ity, sign) =>\n-                        SignedIntLit(ity, neg_sign(sign)),\n-                    UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n-                    _ => { return None; },\n-                }),\n-            ConstantFloat(is, ty) =>\n-                ConstantFloat(neg_float_str(is), ty),\n-            _ => { return None; },\n-        }\n+    Some(match o {\n+        ConstantInt(value, ty) =>\n+            ConstantInt(value, match ty {\n+                SignedIntLit(ity, sign) =>\n+                    SignedIntLit(ity, neg_sign(sign)),\n+                UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n+                _ => { return None; },\n+            }),\n+        ConstantFloat(is, ty) =>\n+            ConstantFloat(neg_float_str(is), ty),\n+        _ => { return None; },\n     })\n }\n \n@@ -386,92 +258,8 @@ fn unify_int_type(l: LitIntType, r: LitIntType, s: Sign) -> Option<LitIntType> {\n     }\n }\n \n-fn constant_binop(cx: &Context, op: BinOp, left: &Expr, right: &Expr)\n-        -> Option<Constant> {\n-    match op.node {\n-        BiAdd => constant_binop_apply(cx, left, right, |l, r|\n-            match (l, r) {\n-                (ConstantByte(l8), ConstantByte(r8)) =>\n-                    l8.checked_add(r8).map(ConstantByte),\n-                (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n-                    let (ln, rn) = (is_negative(lty), is_negative(rty));\n-                    if ln == rn {\n-                        unify_int_type(lty, rty, if ln { Minus } else { Plus })\n-                            .and_then(|ty| l64.checked_add(r64).map(\n-                                |v| ConstantInt(v, ty)))\n-                    } else {\n-                        if ln {\n-                            add_neg_int(r64, rty, l64, lty)\n-                        } else {\n-                            add_neg_int(l64, lty, r64, rty)\n-                        }\n-                    }\n-                },\n-                // TODO: float (would need bignum library?)\n-                _ => None\n-            }),\n-        BiSub => constant_binop_apply(cx, left, right, |l, r|\n-            match (l, r) {\n-                (ConstantByte(l8), ConstantByte(r8)) => if r8 > l8 {\n-                    None } else { Some(ConstantByte(l8 - r8)) },\n-                (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n-                    let (ln, rn) = (is_negative(lty), is_negative(rty));\n-                    match (ln, rn) {\n-                        (false, false) => sub_int(l64, lty, r64, rty, r64 > l64),\n-                        (true, true) => sub_int(l64, lty, r64, rty, l64 > r64),\n-                        (true, false) => unify_int_type(lty, rty, Minus)\n-                            .and_then(|ty| l64.checked_add(r64).map(\n-                                |v| ConstantInt(v, ty))),\n-                        (false, true) => unify_int_type(lty, rty, Plus)\n-                            .and_then(|ty| l64.checked_add(r64).map(\n-                                |v| ConstantInt(v, ty))),\n-                    }\n-                },\n-                _ => None,\n-            }),\n-        //BiMul,\n-        //BiDiv,\n-        //BiRem,\n-        BiAnd => constant_short_circuit(cx, left, right, false),\n-        BiOr => constant_short_circuit(cx, left, right, true),\n-        BiBitXor => constant_bitop(cx, left, right, |x, y| x ^ y),\n-        BiBitAnd => constant_bitop(cx, left, right, |x, y| x & y),\n-        BiBitOr => constant_bitop(cx, left, right, |x, y| (x | y)),\n-        BiShl => constant_bitop(cx, left, right, |x, y| x << y),\n-        BiShr => constant_bitop(cx, left, right, |x, y| x >> y),\n-        BiEq => constant_binop_apply(cx, left, right,\n-            |l, r| Some(ConstantBool(l == r))),\n-        BiNe => constant_binop_apply(cx, left, right,\n-            |l, r| Some(ConstantBool(l != r))),\n-        BiLt => constant_cmp(cx, left, right, Less, true),\n-        BiLe => constant_cmp(cx, left, right, Greater, false),\n-        BiGe => constant_cmp(cx, left, right, Less, false),\n-        BiGt => constant_cmp(cx, left, right, Greater, true),\n-        _ => None\n-    }\n-}\n-\n-fn constant_bitop<F>(cx: &Context, left: &Expr, right: &Expr, f: F)\n-        -> Option<Constant> where F: Fn(u64, u64) -> u64 {\n-    constant_binop_apply(cx, left, right, |l, r| match (l, r) {\n-        (ConstantBool(l), ConstantBool(r)) =>\n-            Some(ConstantBool(f(l as u64, r as u64) != 0)),\n-        (ConstantByte(l8), ConstantByte(r8)) =>\n-            Some(ConstantByte(f(l8 as u64, r8 as u64) as u8)),\n-        (ConstantInt(l, lty), ConstantInt(r, rty)) =>\n-            unify_int_type(lty, rty, Plus).map(|ty| ConstantInt(f(l, r), ty)),\n-        _ => None\n-    })\n-}\n-\n-fn constant_cmp(cx: &Context, left: &Expr, right: &Expr, ordering: Ordering,\n-        b: bool) -> Option<Constant> {\n-    constant_binop_apply(cx, left, right, |l, r| l.partial_cmp(&r).map(|o|\n-        ConstantBool(b == (o == ordering))))\n-}\n-\n fn add_neg_int(pos: u64, pty: LitIntType, neg: u64, nty: LitIntType) ->\n-        Option<ConstantVariant> {\n+        Option<Constant> {\n     if neg > pos {\n         unify_int_type(nty, pty, Minus).map(|ty| ConstantInt(neg - pos, ty))\n     } else {\n@@ -480,42 +268,221 @@ fn add_neg_int(pos: u64, pty: LitIntType, neg: u64, nty: LitIntType) ->\n }\n \n fn sub_int(l: u64, lty: LitIntType, r: u64, rty: LitIntType, neg: bool) ->\n-        Option<ConstantVariant> {\n+        Option<Constant> {\n      unify_int_type(lty, rty, if neg { Minus } else { Plus }).and_then(\n         |ty| l.checked_sub(r).map(|v| ConstantInt(v, ty)))\n }\n \n-fn constant_binop_apply<F>(cx: &Context, left: &Expr, right: &Expr, op: F)\n-        -> Option<Constant>\n-where F: Fn(ConstantVariant, ConstantVariant) -> Option<ConstantVariant> {\n-    if let (Some(Constant { constant: lc, needed_resolution: ln }),\n-            Some(Constant { constant: rc, needed_resolution: rn })) =\n-            (constant(cx, left), constant(cx, right)) {\n-        op(lc, rc).map(|c|\n-            Constant {\n-                needed_resolution: ln || rn,\n-                constant: c,\n-            })\n-    } else { None }\n+\n+pub fn constant(lcx: &Context, e: &Expr) -> Option<(Constant, bool)> {\n+    let mut cx = ConstEvalContext { lcx: Some(lcx), needed_resolution: false };\n+    cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n }\n \n-fn constant_short_circuit(cx: &Context, left: &Expr, right: &Expr, b: bool) ->\n-        Option<Constant> {\n-    constant(cx, left).and_then(|left|\n-        if let &ConstantBool(lbool) = &left.constant {\n-            if lbool == b {\n-                Some(left)\n+pub fn constant_simple(e: &Expr) -> Option<Constant> {\n+    let mut cx = ConstEvalContext { lcx: None, needed_resolution: false };\n+    cx.expr(e)\n+}\n+\n+struct ConstEvalContext<'c, 'cc: 'c> {\n+    lcx: Option<&'c Context<'c, 'cc>>,\n+    needed_resolution: bool\n+}\n+\n+impl<'c, 'cc> ConstEvalContext<'c, 'cc> {\n+\n+    /// simple constant folding: Insert an expression, get a constant or none.\n+    fn expr(&mut self, e: &Expr) -> Option<Constant> {\n+        match &e.node {\n+            &ExprParen(ref inner) => self.expr(inner),\n+            &ExprPath(_, _) => self.fetch_path(e),\n+            &ExprBlock(ref block) => self.block(block),\n+            &ExprIf(ref cond, ref then, ref otherwise) =>\n+                self.ifthenelse(&*cond, &*then, &*otherwise),\n+            &ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n+            &ExprVec(ref vec) => self.vec(&vec[..]),\n+            &ExprTup(ref tup) => self.tup(&tup[..]),\n+            &ExprRepeat(ref value, ref number) =>\n+                self.binop_apply(value, number,|v, n|\n+                    Some(ConstantRepeat(Box::new(v), n.as_u64() as usize))),\n+            &ExprUnary(op, ref operand) => self.expr(operand).and_then(\n+                |o| match op {\n+                    UnNot => constant_not(o),\n+                    UnNeg => constant_negate(o),\n+                    UnUniq | UnDeref => Some(o),\n+                }),\n+            &ExprBinary(op, ref left, ref right) =>\n+                self.binop(op, left, right),\n+            //TODO: add other expressions\n+            _ => None,\n+        }\n+    }\n+\n+    /// create `Some(ConstantVec(..))` of all constants, unless there is any\n+    /// non-constant part\n+    fn vec<E: Deref<Target=Expr> + Sized>(&mut self, vec: &[E]) -> Option<Constant> {\n+        let mut parts = Vec::new();\n+        for opt_part in vec {\n+            match self.expr(opt_part) {\n+                Some(p) => {\n+                    parts.push(p)\n+                },\n+                None => { return None; },\n+            }\n+        }\n+        Some(ConstantVec(parts))\n+    }\n+\n+    fn tup<E: Deref<Target=Expr> + Sized>(&mut self, tup: &[E]) -> Option<Constant> {\n+        let mut parts = Vec::new();\n+        for opt_part in tup {\n+            match self.expr(opt_part) {\n+                Some(p) => {\n+                    parts.push(p)\n+                },\n+                None => { return None; },\n+            }\n+        }\n+        Some(ConstantTuple(parts),)\n+    }\n+\n+    /// lookup a possibly constant expression from a ExprPath\n+    fn fetch_path(&mut self, e: &Expr) -> Option<Constant> {\n+        if let Some(lcx) = self.lcx {\n+            if let Some(&PathResolution { base_def: DefConst(id), ..}) =\n+                lcx.tcx.def_map.borrow().get(&e.id) {\n+                if let Some(const_expr) = lookup_const_by_id(lcx.tcx, id, None) {\n+                    let ret = self.expr(const_expr);\n+                    if ret.is_some() {\n+                        self.needed_resolution = true;\n+                    }\n+                    return ret;\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    /// A block can only yield a constant if it only has one constant expression\n+    fn block(&mut self, block: &Block) -> Option<Constant> {\n+        if block.stmts.is_empty() {\n+            block.expr.as_ref().and_then(|b| self.expr(&*b))\n+        } else { None }\n+    }\n+\n+    fn ifthenelse(&mut self, cond: &Expr, then: &Block, otherwise: &Option<P<Expr>>)\n+                  -> Option<Constant> {\n+        if let Some(ConstantBool(b)) = self.expr(cond) {\n+            if b {\n+                self.block(then)\n             } else {\n-                constant(cx, right).and_then(|right|\n-                    if let ConstantBool(_) = right.constant {\n-                        Some(Constant {\n-                            constant: right.constant,\n-                            needed_resolution: left.needed_resolution ||\n-                                               right.needed_resolution,\n-                        })\n-                    } else { None }\n-                )\n+                otherwise.as_ref().and_then(|expr| self.expr(&*expr))\n             }\n         } else { None }\n-    )\n+    }\n+\n+    fn binop(&mut self, op: BinOp, left: &Expr, right: &Expr) -> Option<Constant> {\n+        match op.node {\n+            BiAdd => self.binop_apply(left, right, |l, r|\n+                match (l, r) {\n+                    (ConstantByte(l8), ConstantByte(r8)) =>\n+                        l8.checked_add(r8).map(ConstantByte),\n+                    (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n+                        let (ln, rn) = (is_negative(lty), is_negative(rty));\n+                        if ln == rn {\n+                            unify_int_type(lty, rty, if ln { Minus } else { Plus })\n+                                .and_then(|ty| l64.checked_add(r64).map(\n+                                    |v| ConstantInt(v, ty)))\n+                        } else {\n+                            if ln {\n+                                add_neg_int(r64, rty, l64, lty)\n+                            } else {\n+                                add_neg_int(l64, lty, r64, rty)\n+                            }\n+                        }\n+                    },\n+                    // TODO: float (would need bignum library?)\n+                    _ => None\n+                }),\n+            BiSub => self.binop_apply(left, right, |l, r|\n+                match (l, r) {\n+                    (ConstantByte(l8), ConstantByte(r8)) => if r8 > l8 {\n+                        None } else { Some(ConstantByte(l8 - r8)) },\n+                    (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n+                        let (ln, rn) = (is_negative(lty), is_negative(rty));\n+                        match (ln, rn) {\n+                            (false, false) => sub_int(l64, lty, r64, rty, r64 > l64),\n+                            (true, true) => sub_int(l64, lty, r64, rty, l64 > r64),\n+                            (true, false) => unify_int_type(lty, rty, Minus)\n+                                .and_then(|ty| l64.checked_add(r64).map(\n+                                    |v| ConstantInt(v, ty))),\n+                            (false, true) => unify_int_type(lty, rty, Plus)\n+                                .and_then(|ty| l64.checked_add(r64).map(\n+                                    |v| ConstantInt(v, ty))),\n+                        }\n+                    },\n+                    _ => None,\n+                }),\n+            //BiMul,\n+            //BiDiv,\n+            //BiRem,\n+            BiAnd => self.short_circuit(left, right, false),\n+            BiOr => self.short_circuit(left, right, true),\n+            BiBitXor => self.bitop(left, right, |x, y| x ^ y),\n+            BiBitAnd => self.bitop(left, right, |x, y| x & y),\n+            BiBitOr => self.bitop(left, right, |x, y| (x | y)),\n+            BiShl => self.bitop(left, right, |x, y| x << y),\n+            BiShr => self.bitop(left, right, |x, y| x >> y),\n+            BiEq => self.binop_apply(left, right,\n+                |l, r| Some(ConstantBool(l == r))),\n+            BiNe => self.binop_apply(left, right,\n+                |l, r| Some(ConstantBool(l != r))),\n+            BiLt => self.cmp(left, right, Less, true),\n+            BiLe => self.cmp(left, right, Greater, false),\n+            BiGe => self.cmp(left, right, Less, false),\n+            BiGt => self.cmp(left, right, Greater, true),\n+            _ => None\n+        }\n+    }\n+\n+    fn bitop<F>(&mut self, left: &Expr, right: &Expr, f: F)\n+            -> Option<Constant> where F: Fn(u64, u64) -> u64 {\n+        self.binop_apply(left, right, |l, r| match (l, r) {\n+            (ConstantBool(l), ConstantBool(r)) =>\n+                Some(ConstantBool(f(l as u64, r as u64) != 0)),\n+            (ConstantByte(l8), ConstantByte(r8)) =>\n+                Some(ConstantByte(f(l8 as u64, r8 as u64) as u8)),\n+            (ConstantInt(l, lty), ConstantInt(r, rty)) =>\n+                unify_int_type(lty, rty, Plus).map(|ty| ConstantInt(f(l, r), ty)),\n+            _ => None\n+        })\n+    }\n+\n+    fn cmp(&mut self, left: &Expr, right: &Expr, ordering: Ordering, b: bool) -> Option<Constant> {\n+        self.binop_apply(left, right, |l, r| l.partial_cmp(&r).map(|o|\n+            ConstantBool(b == (o == ordering))))\n+    }\n+\n+    fn binop_apply<F>(&mut self, left: &Expr, right: &Expr, op: F) -> Option<Constant>\n+    where F: Fn(Constant, Constant) -> Option<Constant> {\n+        if let (Some(lc), Some(rc)) = (self.expr(left), self.expr(right)) {\n+            op(lc, rc)\n+        } else { None }\n+    }\n+\n+    fn short_circuit(&mut self, left: &Expr, right: &Expr, b: bool) -> Option<Constant> {\n+        self.expr(left).and_then(|left|\n+            if let &ConstantBool(lbool) = &left {\n+                if lbool == b {\n+                    Some(left)\n+                } else {\n+                    self.expr(right).and_then(|right|\n+                        if let ConstantBool(_) = right {\n+                            Some(right)\n+                        } else { None }\n+                    )\n+                }\n+            } else { None }\n+        )\n+    }\n }"}, {"sha": "cd7d6351c807f4e02fe1f7b9eb5c46588b0e6a25", "filename": "src/identity_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f52239cab61f58c46f89c1a83616186a873c921/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f52239cab61f58c46f89c1a83616186a873c921/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=7f52239cab61f58c46f89c1a83616186a873c921", "patch": "@@ -3,7 +3,7 @@ use syntax::ast::*;\n use syntax::codemap::Span;\n \n use consts::{constant, is_negative};\n-use consts::ConstantVariant::ConstantInt;\n+use consts::Constant::ConstantInt;\n use utils::{span_lint, snippet};\n \n declare_lint! { pub IDENTITY_OP, Warn,\n@@ -44,9 +44,9 @@ impl LintPass for IdentityOp {\n \n \n fn check(cx: &Context, e: &Expr, m: i8, span: Span, arg: Span) {\n-    if let Some(c) = constant(cx, e) {\n-        if c.needed_resolution { return; } // skip linting w/ lookup for now\n-        if let ConstantInt(v, ty) = c.constant {\n+    if let Some((c, needed_resolution)) = constant(cx, e) {\n+        if needed_resolution { return; } // skip linting w/ lookup for now\n+        if let ConstantInt(v, ty) = c {\n             if match m {\n                 0 => v == 0,\n                 -1 => is_negative(ty) && v == 1,"}, {"sha": "aca849931bb2dec4144aea43f78fa094038ccfde", "filename": "src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f52239cab61f58c46f89c1a83616186a873c921/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f52239cab61f58c46f89c1a83616186a873c921/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=7f52239cab61f58c46f89c1a83616186a873c921", "patch": "@@ -149,7 +149,7 @@ impl LintPass for FloatCmp {\n             let op = cmp.node;\n             if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n                 if constant(cx, left).or_else(|| constant(cx, right)).map_or(\n-                        false, |c| c.as_float().map_or(false, |f| f == 0.0)) {\n+                        false, |c| c.0.as_float().map_or(false, |f| f == 0.0)) {\n                     return;\n                 }\n                 span_lint(cx, FLOAT_CMP, expr.span, &format!("}, {"sha": "bcc5aa4c30a59b8f3f07b8e208d692c0cd24f4c5", "filename": "tests/consts.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7f52239cab61f58c46f89c1a83616186a873c921/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f52239cab61f58c46f89c1a83616186a873c921/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=7f52239cab61f58c46f89c1a83616186a873c921", "patch": "@@ -5,21 +5,13 @@ extern crate clippy;\n extern crate syntax;\n extern crate rustc;\n \n-use clippy::consts::{constant, ConstantVariant};\n-use clippy::consts::ConstantVariant::*;\n use syntax::ast::*;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::codemap::{Spanned, COMMAND_LINE_SP};\n-use std::mem;\n-use rustc::lint::Context;\n \n-fn ctx() -> &'static Context<'static, 'static> {\n-    unsafe {\n-        let x : *const Context<'static, 'static> = std::ptr::null();\n-        mem::transmute(x)\n-    }\n-}\n+use clippy::consts::{constant_simple, Constant};\n+use clippy::consts::Constant::*;\n \n fn spanned<T>(t: T) -> Spanned<T> {\n     Spanned{ node: t, span: COMMAND_LINE_SP }\n@@ -41,13 +33,13 @@ fn binop(op: BinOp_, l: Expr, r: Expr) -> Expr {\n     expr(ExprBinary(spanned(op), P(l), P(r)))\n }\n \n-fn check(expect: ConstantVariant, expr: &Expr) {\n-    assert_eq!(Some(expect), constant(ctx(), expr).map(|x| x.constant))\n+fn check(expect: Constant, expr: &Expr) {\n+    assert_eq!(Some(expect), constant_simple(expr))\n }\n \n-const TRUE : ConstantVariant = ConstantBool(true);\n-const FALSE : ConstantVariant = ConstantBool(false);\n-const ZERO : ConstantVariant = ConstantInt(0, UnsuffixedIntLit(Plus));\n+const TRUE : Constant = ConstantBool(true);\n+const FALSE : Constant = ConstantBool(false);\n+const ZERO : Constant = ConstantInt(0, UnsuffixedIntLit(Plus));\n \n #[test]\n fn test_lit() {"}]}