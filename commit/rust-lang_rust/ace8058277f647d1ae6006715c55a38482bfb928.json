{"sha": "ace8058277f647d1ae6006715c55a38482bfb928", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZTgwNTgyNzdmNjQ3ZDFhZTYwMDY3MTVjNTVhMzg0ODJiZmI5Mjg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T03:11:25Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T03:13:04Z"}, "message": "rustc: Have typechecking no longer rebuild the AST", "tree": {"sha": "ae6803cfcd88dc464bbfd5bdbdcf57acb0ad76e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae6803cfcd88dc464bbfd5bdbdcf57acb0ad76e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ace8058277f647d1ae6006715c55a38482bfb928", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ace8058277f647d1ae6006715c55a38482bfb928", "html_url": "https://github.com/rust-lang/rust/commit/ace8058277f647d1ae6006715c55a38482bfb928", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ace8058277f647d1ae6006715c55a38482bfb928/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df9801c9f0b3b3f7d433a521870574a59bc8b679", "url": "https://api.github.com/repos/rust-lang/rust/commits/df9801c9f0b3b3f7d433a521870574a59bc8b679", "html_url": "https://github.com/rust-lang/rust/commit/df9801c9f0b3b3f7d433a521870574a59bc8b679"}], "stats": {"total": 113, "additions": 64, "deletions": 49}, "files": [{"sha": "d4f45fc6a11566666005d478c5807e7c5e19ba1c", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ace8058277f647d1ae6006715c55a38482bfb928/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ace8058277f647d1ae6006715c55a38482bfb928/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=ace8058277f647d1ae6006715c55a38482bfb928", "patch": "@@ -99,10 +99,9 @@ fn compile_input(session::session sess,\n     auto ty_cx = ty::mk_ctxt(sess, def_map);\n     auto typeck_result =\n         time[typeck::typecheck_result](time_passes, \"typechecking\",\n-                                      bind typeck::check_crate(ty_cx, crate));\n+            bind typeck::check_crate(ty_cx, crate));\n     auto node_type_table = typeck_result._0;\n     auto type_cache = typeck_result._1;\n-    crate = typeck_result._2;\n \n     if (sess.get_opts().run_typestate) {\n         crate = time(time_passes, \"typestate checking\",\n@@ -130,7 +129,6 @@ fn pretty_print_input(session::session sess, eval::env env, str input,\n         auto def_map = resolve::resolve_crate(sess, crate);\n         auto ty_cx = ty::mk_ctxt(sess, def_map);\n         auto typeck_result = typeck::check_crate(ty_cx, crate);\n-        crate = typeck_result._2;\n         mode = pprust::mo_typed(ty_cx, typeck_result._0, typeck_result._1);\n     } else {\n         mode = pprust::mo_untyped;"}, {"sha": "4470d0defa79993a8eafa10302ae5980c03c2fc4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 54, "deletions": 46, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ace8058277f647d1ae6006715c55a38482bfb928/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ace8058277f647d1ae6006715c55a38482bfb928/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=ace8058277f647d1ae6006715c55a38482bfb928", "patch": "@@ -62,11 +62,12 @@ type fn_purity_table = hashmap[ast::def_id, ast::purity];\n type unify_cache_entry = tup(ty::t,ty::t,vec[mutable ty::t]);\n type unify_cache = hashmap[unify_cache_entry,ty::unify::result];\n \n+type obj_info = rec(vec[ast::obj_field] obj_fields, ast::def_id this_obj);\n+\n type crate_ctxt = rec(session::session sess,\n                       ty::type_cache type_cache,\n                       @ty_item_table item_items,\n-                      vec[ast::obj_field] obj_fields,\n-                      option::t[ast::def_id] this_obj,\n+                      mutable vec[obj_info] obj_infos,\n                       @fn_purity_table fn_purity_table,\n                       mutable int next_var_id,\n                       unify_cache unify_cache,\n@@ -2275,21 +2276,10 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto t = ty::mk_nil(fcx.ccx.tcx);\n             let ty::t this_obj_ty;\n \n-            auto this_obj_id = fcx.ccx.this_obj;\n-            alt (this_obj_id) {\n-                // If we're inside a current object, grab its type.\n-                case (some[ast::def_id](?def_id)) {\n-                    this_obj_ty = ty::lookup_item_type(fcx.ccx.sess,\n-                        fcx.ccx.tcx, fcx.ccx.type_cache, def_id)._1;\n-                }\n-                // Otherwise, we should be able to look up the object we're\n-                // \"with\".\n-                case (_) {\n-                    // TODO.\n-\n-                    fail;\n-                }\n-            }\n+            auto oinfo_opt = get_obj_info(fcx.ccx);\n+            auto this_obj_id = option::get[obj_info](oinfo_opt).this_obj;\n+            this_obj_ty = ty::lookup_item_type(fcx.ccx.sess,\n+                fcx.ccx.tcx, fcx.ccx.type_cache, this_obj_id)._1;\n \n             // Grab this method's type out of the current object type.\n             alt (struct(fcx.ccx.tcx, this_obj_ty)) {\n@@ -2561,6 +2551,10 @@ fn next_ty_var(&@crate_ctxt ccx) -> ty::t {\n     ret t;\n }\n \n+fn get_obj_info(&@crate_ctxt ccx) -> option::t[obj_info] {\n+    ret vec::last[obj_info](ccx.obj_infos);\n+}\n+\n fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n     alt (decl.node) {\n         case (ast::decl_local(?local)) {\n@@ -2661,8 +2655,7 @@ fn check_block(&@fn_ctxt fcx, &ast::block block) {\n     write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, block.node.a.id);\n }\n \n-fn check_const(&@crate_ctxt ccx, &span sp, &ast::ident ident, &@ast::ty t,\n-               &@ast::expr e, &ast::def_id id, &ast::ann ann) {\n+fn check_const(&@crate_ctxt ccx, &span sp, &@ast::expr e, &ast::ann ann) {\n     // FIXME: this is kinda a kludge; we manufacture a fake \"function context\"\n     // for checking the initializer expression.\n     auto rty = ann_to_type(ccx.node_types, ann);\n@@ -2675,17 +2668,21 @@ fn check_const(&@crate_ctxt ccx, &span sp, &ast::ident ident, &@ast::ty t,\n }\n \n fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n-            &ast::block body) -> ast::_fn {\n+            &ast::block body) {\n     auto local_ty_table = @common::new_def_hash[ty::t]();\n \n     // FIXME: duplicate work: the item annotation already has the arg types\n     // and return type translated to typeck::ty values. We don't need do to it\n     // again here, we can extract them.\n \n-\n-    for (ast::obj_field f in ccx.obj_fields) {\n-        auto field_ty = ty::ann_to_type(ccx.node_types, f.ann);\n-        local_ty_table.insert(f.id, field_ty);\n+    alt (get_obj_info(ccx)) {\n+        case (option::some[obj_info](?oinfo)) {\n+            for (ast::obj_field f in oinfo.obj_fields) {\n+                auto field_ty = ty::ann_to_type(ccx.node_types, f.ann);\n+                local_ty_table.insert(f.id, field_ty);\n+            }\n+        }\n+        case (option::none[obj_info]) { /* no fields */ }\n     }\n \n     // Store the type of each argument in the table.\n@@ -2713,21 +2710,38 @@ fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n     }\n \n     writeback::resolve_local_types_in_block(fcx, body);\n+}\n \n-    ret rec(decl=decl, proto=proto, body=body);\n+fn check_method(&@crate_ctxt ccx, &@ast::method method) {\n+    check_fn(ccx, method.node.meth.decl, method.node.meth.proto,\n+             method.node.meth.body);\n }\n \n-fn update_obj_fields(&@crate_ctxt ccx, &@ast::item i) -> @crate_ctxt {\n-    alt (i.node) {\n+fn check_item(@crate_ctxt ccx, &@ast::item it) {\n+    alt (it.node) {\n+        case (ast::item_const(_, _, ?e, _, ?a)) {\n+            check_const(ccx, it.span, e, a);\n+        }\n+        case (ast::item_fn(_, ?f, _, _, _)) {\n+            check_fn(ccx, f.decl, f.proto, f.body);\n+        }\n         case (ast::item_obj(_, ?ob, _, ?obj_def_ids, _)) {\n+            // We're entering an object, so gather up the info we need.\n             let ast::def_id di = obj_def_ids.ty;\n-            ret @rec(obj_fields = ob.fields,\n-                     this_obj = some[ast::def_id](di) with *ccx);\n-        }\n-        case (_) {\n+            vec::push[obj_info](ccx.obj_infos,\n+                                rec(obj_fields=ob.fields, this_obj=di));\n+\n+            // Typecheck the methods.\n+            for (@ast::method method in ob.methods) {\n+                check_method(ccx, method);\n+            }\n+            option::may[@ast::method](bind check_method(ccx, _), ob.dtor);\n+\n+            // Now remove the info from the stack.\n+            vec::pop[obj_info](ccx.obj_infos);\n         }\n+        case (_) { /* nothing to do */ }\n     }\n-    ret ccx;\n }\n \n \n@@ -2783,15 +2797,13 @@ fn mk_fn_purity_table(&@ast::crate crate) -> @fn_purity_table {\n     ret res;\n }\n \n-// TODO: Remove the third element of this tuple; rely solely on the node type\n-// table.\n-type typecheck_result = tup(node_type_table, ty::type_cache, @ast::crate);\n+type typecheck_result = tup(node_type_table, ty::type_cache);\n \n fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n     auto sess = tcx.sess;\n     auto result = collect::collect_item_types(sess, tcx, crate);\n \n-    let vec[ast::obj_field] fields = [];\n+    let vec[obj_info] obj_infos = [];\n \n     auto hasher = hash_unify_cache_entry;\n     auto eqer = eq_unify_cache_entry;\n@@ -2803,28 +2815,24 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n     auto ccx = @rec(sess=sess,\n                     type_cache=result._0,\n                     item_items=result._1,\n-                    obj_fields=fields,\n-                    this_obj=none[ast::def_id],\n-                    fn_purity_table = fpt,\n+                    mutable obj_infos=obj_infos,\n+                    fn_purity_table=fpt,\n                     mutable next_var_id=0,\n                     unify_cache=unify_cache,\n                     mutable cache_hits=0u,\n                     mutable cache_misses=0u,\n                     tcx=tcx,\n                     node_types=node_types);\n \n-    auto fld = fold::new_identity_fold[@crate_ctxt]();\n-\n-    fld = @rec(update_env_for_item = bind update_obj_fields(_, _),\n-               fold_fn      = bind check_fn(_,_,_,_)\n-               with *fld);\n+    auto visit = rec(visit_item_pre = bind check_item(ccx, _)\n+                     with walk::default_visitor());\n \n-    auto crate_1 = fold::fold_crate[@crate_ctxt](ccx, fld, crate);\n+    walk::walk_crate(visit, *crate);\n \n     log #fmt(\"cache hit rate: %u/%u\", ccx.cache_hits,\n              ccx.cache_hits + ccx.cache_misses);\n \n-    ret tup(node_types, ccx.type_cache, crate_1);\n+    ret tup(node_types, ccx.type_cache);\n }\n \n //"}, {"sha": "371fedf24d552c92a1b6a32be420f3229b02c845", "filename": "src/lib/option.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ace8058277f647d1ae6006715c55a38482bfb928/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ace8058277f647d1ae6006715c55a38482bfb928/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=ace8058277f647d1ae6006715c55a38482bfb928", "patch": "@@ -49,6 +49,15 @@ fn maybe[T, U](&U def, fn(&T) -> U f, &t[T] opt) -> U {\n         case (some[T](?t)) { ret f(t); }\n     }\n }\n+\n+// Can be defined in terms of the above when/if we have const bind.\n+fn may[T](fn(&T) f, &t[T] opt) {\n+    alt (opt) {\n+        case (none[T]) { /* nothing */ }\n+        case (some[T](?t)) { f(t); }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}]}