{"sha": "3c496f7fa7afe78102ea2c7ee5f7e006a66629d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNDk2ZjdmYTdhZmU3ODEwMmVhMmM3ZWU1ZjdlMDA2YTY2NjI5ZDQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-04T17:30:29Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-04T17:33:01Z"}, "message": "Use `ImportMap` in `find_path`, remove old queries", "tree": {"sha": "5c88e48492b514d14b8fa183a4474c2aaf49d7ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c88e48492b514d14b8fa183a4474c2aaf49d7ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c496f7fa7afe78102ea2c7ee5f7e006a66629d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c496f7fa7afe78102ea2c7ee5f7e006a66629d4", "html_url": "https://github.com/rust-lang/rust/commit/3c496f7fa7afe78102ea2c7ee5f7e006a66629d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c496f7fa7afe78102ea2c7ee5f7e006a66629d4/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d08c63cb9e3574fa97374a8529136814530bf416", "url": "https://api.github.com/repos/rust-lang/rust/commits/d08c63cb9e3574fa97374a8529136814530bf416", "html_url": "https://github.com/rust-lang/rust/commit/d08c63cb9e3574fa97374a8529136814530bf416"}], "stats": {"total": 237, "additions": 140, "deletions": 97}, "files": [{"sha": "10cc26480f365271c801cfd3e29559fbc8b0a835", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c496f7fa7afe78102ea2c7ee5f7e006a66629d4/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c496f7fa7afe78102ea2c7ee5f7e006a66629d4/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=3c496f7fa7afe78102ea2c7ee5f7e006a66629d4", "patch": "@@ -1,7 +1,7 @@\n //! Defines database & queries for name resolution.\n use std::sync::Arc;\n \n-use hir_expand::{db::AstDatabase, name::Name, HirFileId};\n+use hir_expand::{db::AstDatabase, HirFileId};\n use ra_db::{salsa, CrateId, SourceDatabase, Upcast};\n use ra_prof::profile;\n use ra_syntax::SmolStr;\n@@ -12,14 +12,10 @@ use crate::{\n     body::{scope::ExprScopes, Body, BodySourceMap},\n     data::{ConstData, FunctionData, ImplData, StaticData, TraitData, TypeAliasData},\n     docs::Documentation,\n-    find_path,\n     generics::GenericParams,\n     import_map::ImportMap,\n-    item_scope::ItemInNs,\n     lang_item::{LangItemTarget, LangItems},\n     nameres::{raw::RawItems, CrateDefMap},\n-    path::ModPath,\n-    visibility::Visibility,\n     AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId, FunctionLoc,\n     GenericDefId, ImplId, ImplLoc, ModuleId, StaticId, StaticLoc, StructId, StructLoc, TraitId,\n     TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc,\n@@ -114,16 +110,6 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(Documentation::documentation_query)]\n     fn documentation(&self, def: AttrDefId) -> Option<Documentation>;\n \n-    #[salsa::invoke(find_path::importable_locations_of_query)]\n-    fn importable_locations_of(\n-        &self,\n-        item: ItemInNs,\n-        krate: CrateId,\n-    ) -> Arc<[(ModuleId, Name, Visibility)]>;\n-\n-    #[salsa::invoke(find_path::find_path_inner_query)]\n-    fn find_path_inner(&self, item: ItemInNs, from: ModuleId, max_len: usize) -> Option<ModPath>;\n-\n     #[salsa::invoke(ImportMap::import_map_query)]\n     fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;\n }"}, {"sha": "79f4afab623ff3cb0245fae0544fdeba4fc256a3", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 119, "deletions": 80, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/3c496f7fa7afe78102ea2c7ee5f7e006a66629d4/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c496f7fa7afe78102ea2c7ee5f7e006a66629d4/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=3c496f7fa7afe78102ea2c7ee5f7e006a66629d4", "patch": "@@ -1,7 +1,5 @@\n //! An algorithm to find a path to refer to a certain item.\n \n-use std::sync::Arc;\n-\n use hir_expand::name::{known, AsName, Name};\n use ra_prof::profile;\n use test_utils::mark;\n@@ -11,16 +9,17 @@ use crate::{\n     item_scope::ItemInNs,\n     path::{ModPath, PathKind},\n     visibility::Visibility,\n-    CrateId, ModuleDefId, ModuleId,\n+    ModuleDefId, ModuleId,\n };\n+use rustc_hash::FxHashSet;\n \n // FIXME: handle local items\n \n /// Find a path that can be used to refer to a certain item. This can depend on\n /// *from where* you're referring to the item, hence the `from` parameter.\n pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n     let _p = profile(\"find_path\");\n-    db.find_path_inner(item, from, MAX_PATH_LEN)\n+    find_path_inner(db, item, from, MAX_PATH_LEN)\n }\n \n const MAX_PATH_LEN: usize = 15;\n@@ -38,7 +37,7 @@ impl ModPath {\n     }\n }\n \n-pub(crate) fn find_path_inner_query(\n+pub(crate) fn find_path_inner(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n@@ -122,31 +121,61 @@ pub(crate) fn find_path_inner_query(\n     }\n \n     // - otherwise, look for modules containing (reexporting) it and import it from one of those\n+\n     let crate_root = ModuleId { local_id: def_map.root, krate: from.krate };\n     let crate_attrs = db.attrs(crate_root.into());\n     let prefer_no_std = crate_attrs.by_key(\"no_std\").exists();\n-    let importable_locations = find_importable_locations(db, item, from);\n     let mut best_path = None;\n     let mut best_path_len = max_len;\n-    for (module_id, name) in importable_locations {\n-        let mut path = match db.find_path_inner(\n-            ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n-            from,\n-            best_path_len - 1,\n-        ) {\n-            None => continue,\n-            Some(path) => path,\n-        };\n-        path.segments.push(name);\n \n-        let new_path = if let Some(best_path) = best_path {\n-            select_best_path(best_path, path, prefer_no_std)\n-        } else {\n-            path\n-        };\n-        best_path_len = new_path.len();\n-        best_path = Some(new_path);\n+    if item.defining_crate(db) == Some(from.krate) {\n+        // Item was defined in the same crate that wants to import it. It cannot be found in any\n+        // dependency in this case.\n+\n+        let local_imports = find_local_import_locations(db, item, from);\n+        for (module_id, name) in local_imports {\n+            if let Some(mut path) = find_path_inner(\n+                db,\n+                ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n+                from,\n+                best_path_len - 1,\n+            ) {\n+                path.segments.push(name);\n+\n+                let new_path = if let Some(best_path) = best_path {\n+                    select_best_path(best_path, path, prefer_no_std)\n+                } else {\n+                    path\n+                };\n+                best_path_len = new_path.len();\n+                best_path = Some(new_path);\n+            }\n+        }\n+    } else {\n+        // Item was defined in some upstream crate. This means that it must be exported from one,\n+        // too (unless we can't name it at all). It could *also* be (re)exported by the same crate\n+        // that wants to import it here, but we always prefer to use the external path here.\n+\n+        let crate_graph = db.crate_graph();\n+        let extern_paths = crate_graph[from.krate].dependencies.iter().filter_map(|dep| {\n+            let import_map = db.import_map(dep.crate_id);\n+            import_map.path_of(item).map(|modpath| {\n+                let mut modpath = modpath.clone();\n+                modpath.segments.insert(0, dep.as_name());\n+                modpath\n+            })\n+        });\n+\n+        for path in extern_paths {\n+            let new_path = if let Some(best_path) = best_path {\n+                select_best_path(best_path, path, prefer_no_std)\n+            } else {\n+                path\n+            };\n+            best_path = Some(new_path);\n+        }\n     }\n+\n     best_path\n }\n \n@@ -174,77 +203,86 @@ fn select_best_path(old_path: ModPath, new_path: ModPath, prefer_no_std: bool) -\n     }\n }\n \n-fn find_importable_locations(\n+/// Finds locations in `from.krate` from which `item` can be imported by `from`.\n+fn find_local_import_locations(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n ) -> Vec<(ModuleId, Name)> {\n-    let crate_graph = db.crate_graph();\n-    let mut result = Vec::new();\n-\n-    // We only look in the crate from which we are importing, and the direct\n-    // dependencies. We cannot refer to names from transitive dependencies\n-    // directly (only through reexports in direct dependencies).\n-\n-    // For the crate from which we're importing, we have to check whether any\n-    // module visible to `from` exports the item we're looking for.\n-    // For dependencies of the crate only `pub` items reachable through `pub`\n-    // modules from the crate root are relevant. For that we precompute an\n-    // import map that tells us the shortest path to any importable item with a\n-    // single lookup.\n-    for krate in Some(from.krate)\n-        .into_iter()\n-        .chain(crate_graph[from.krate].dependencies.iter().map(|dep| dep.crate_id))\n-    {\n-        result.extend(\n-            db.importable_locations_of(item, krate)\n-                .iter()\n-                .filter(|(_, _, vis)| vis.is_visible_from(db, from))\n-                .map(|(m, n, _)| (*m, n.clone())),\n-        );\n-    }\n-    result\n-}\n+    let _p = profile(\"find_local_import_locations\");\n+\n+    // `from` can import anything below `from` with visibility of at least `from`, and anything\n+    // above `from` with any visibility. That means we do not need to descend into private siblings\n+    // of `from` (and similar).\n+\n+    let def_map = db.crate_def_map(from.krate);\n+\n+    // Compute the initial worklist. We start with all direct child modules of `from` as well as all\n+    // of its (recursive) parent modules.\n+    let data = &def_map.modules[from.local_id];\n+    let mut worklist = data\n+        .children\n+        .values()\n+        .map(|child| ModuleId { krate: from.krate, local_id: *child })\n+        .collect::<Vec<_>>();\n+    let mut parent = data.parent;\n+    while let Some(p) = parent {\n+        worklist.push(ModuleId { krate: from.krate, local_id: p });\n+        parent = def_map.modules[p].parent;\n+    }\n+\n+    let mut seen: FxHashSet<_> = FxHashSet::default();\n+\n+    let mut locations = Vec::new();\n+    while let Some(module) = worklist.pop() {\n+        if !seen.insert(module) {\n+            continue; // already processed this module\n+        }\n+\n+        let ext_def_map;\n+        let data = if module.krate == from.krate {\n+            &def_map[module.local_id]\n+        } else {\n+            // The crate might reexport a module defined in another crate.\n+            ext_def_map = db.crate_def_map(module.krate);\n+            &ext_def_map[module.local_id]\n+        };\n \n-/// Collects all locations from which we might import the item in a particular\n-/// crate. These include the original definition of the item, and any\n-/// non-private `use`s.\n-///\n-/// Note that the crate doesn't need to be the one in which the item is defined;\n-/// it might be re-exported in other crates.\n-pub(crate) fn importable_locations_of_query(\n-    db: &dyn DefDatabase,\n-    item: ItemInNs,\n-    krate: CrateId,\n-) -> Arc<[(ModuleId, Name, Visibility)]> {\n-    let _p = profile(\"importable_locations_of_query\");\n-    let def_map = db.crate_def_map(krate);\n-    let mut result = Vec::new();\n-    for (local_id, data) in def_map.modules.iter() {\n         if let Some((name, vis)) = data.scope.name_of(item) {\n-            let is_private = if let Visibility::Module(private_to) = vis {\n-                private_to.local_id == local_id\n-            } else {\n-                false\n-            };\n-            let is_original_def = if let Some(module_def_id) = item.as_module_def_id() {\n-                data.scope.declarations().any(|it| it == module_def_id)\n-            } else {\n-                false\n-            };\n-            if is_private && !is_original_def {\n+            if vis.is_visible_from(db, from) {\n+                let is_private = if let Visibility::Module(private_to) = vis {\n+                    private_to.local_id == module.local_id\n+                } else {\n+                    false\n+                };\n+                let is_original_def = if let Some(module_def_id) = item.as_module_def_id() {\n+                    data.scope.declarations().any(|it| it == module_def_id)\n+                } else {\n+                    false\n+                };\n+\n                 // Ignore private imports. these could be used if we are\n                 // in a submodule of this module, but that's usually not\n                 // what the user wants; and if this module can import\n                 // the item and we're a submodule of it, so can we.\n                 // Also this keeps the cached data smaller.\n-                continue;\n+                if !is_private || is_original_def {\n+                    locations.push((module, name.clone()));\n+                }\n+            }\n+        }\n+\n+        // Descend into all modules visible from `from`.\n+        for (_, per_ns) in data.scope.entries() {\n+            if let Some((ModuleDefId::ModuleId(module), vis)) = per_ns.take_types_vis() {\n+                if vis.is_visible_from(db, from) {\n+                    worklist.push(module);\n+                }\n             }\n-            result.push((ModuleId { krate, local_id }, name.clone(), vis));\n         }\n     }\n \n-    Arc::from(result)\n+    locations\n }\n \n #[cfg(test)]\n@@ -382,14 +420,15 @@ mod tests {\n \n     #[test]\n     fn different_crate_renamed() {\n+        // Even if a local path exists, if the item is defined externally, prefer an external path.\n         let code = r#\"\n             //- /main.rs crate:main deps:std\n             extern crate std as std_renamed;\n             <|>\n             //- /std.rs crate:std\n             pub struct S;\n         \"#;\n-        check_found_path(code, \"std_renamed::S\");\n+        check_found_path(code, \"std::S\");\n     }\n \n     #[test]"}, {"sha": "ede1aa045357c3f19b1404b4e473741db0103a4b", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3c496f7fa7afe78102ea2c7ee5f7e006a66629d4/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c496f7fa7afe78102ea2c7ee5f7e006a66629d4/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=3c496f7fa7afe78102ea2c7ee5f7e006a66629d4", "patch": "@@ -6,9 +6,10 @@ use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, ImplId, MacroDefId, ModuleDefId,\n-    TraitId,\n+    db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, HasModule, ImplId,\n+    Lookup, MacroDefId, ModuleDefId, TraitId,\n };\n+use ra_db::CrateId;\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n@@ -203,4 +204,21 @@ impl ItemInNs {\n             ItemInNs::Macros(_) => None,\n         }\n     }\n+\n+    pub fn defining_crate(&self, db: &dyn DefDatabase) -> Option<CrateId> {\n+        Some(match self {\n+            ItemInNs::Types(did) | ItemInNs::Values(did) => match did {\n+                ModuleDefId::ModuleId(id) => id.krate,\n+                ModuleDefId::FunctionId(id) => id.lookup(db).module(db).krate,\n+                ModuleDefId::AdtId(id) => id.module(db).krate,\n+                ModuleDefId::EnumVariantId(id) => id.parent.lookup(db).container.module(db).krate,\n+                ModuleDefId::ConstId(id) => id.lookup(db).container.module(db).krate,\n+                ModuleDefId::StaticId(id) => id.lookup(db).container.module(db).krate,\n+                ModuleDefId::TraitId(id) => id.lookup(db).container.module(db).krate,\n+                ModuleDefId::TypeAliasId(id) => id.lookup(db).module(db).krate,\n+                ModuleDefId::BuiltinType(_) => return None,\n+            },\n+            ItemInNs::Macros(id) => return id.krate,\n+        })\n+    }\n }"}]}