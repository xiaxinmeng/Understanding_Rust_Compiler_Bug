{"sha": "582cee2cdf5355b681f14bbb33bd5c431c284d87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MmNlZTJjZGY1MzU1YjY4MWYxNGJiYjMzYmQ1YzQzMWMyODRkODc=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-02-24T23:06:31Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-08T21:59:18Z"}, "message": "Return more data about located imports", "tree": {"sha": "47d25e9c057759b1aa334abf3f584f1d0317d941", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47d25e9c057759b1aa334abf3f584f1d0317d941"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/582cee2cdf5355b681f14bbb33bd5c431c284d87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/582cee2cdf5355b681f14bbb33bd5c431c284d87", "html_url": "https://github.com/rust-lang/rust/commit/582cee2cdf5355b681f14bbb33bd5c431c284d87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/582cee2cdf5355b681f14bbb33bd5c431c284d87/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "309421c117fc20e58b9f30fb28a01a89f50b0086", "url": "https://api.github.com/repos/rust-lang/rust/commits/309421c117fc20e58b9f30fb28a01a89f50b0086", "html_url": "https://github.com/rust-lang/rust/commit/309421c117fc20e58b9f30fb28a01a89f50b0086"}], "stats": {"total": 297, "additions": 172, "deletions": 125}, "files": [{"sha": "7188724be78c3e5a34d947314fd399b5b87dcd47", "filename": "crates/ide_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=582cee2cdf5355b681f14bbb33bd5c431c284d87", "patch": "@@ -92,14 +92,18 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let range = ctx.sema.original_range(&syntax_under_caret).range;\n     let group = import_group_message(import_assets.import_candidate());\n     let scope = ImportScope::find_insert_use_container(&syntax_under_caret, &ctx.sema)?;\n-    for (import, _) in proposed_imports {\n+    for import in proposed_imports {\n         acc.add_group(\n             &group,\n             AssistId(\"auto_import\", AssistKind::QuickFix),\n-            format!(\"Import `{}`\", &import),\n+            format!(\"Import `{}`\", import.display_path()),\n             range,\n             |builder| {\n-                let rewriter = insert_use(&scope, mod_path_to_ast(&import), ctx.config.insert_use);\n+                let rewriter = insert_use(\n+                    &scope,\n+                    mod_path_to_ast(import.import_path()),\n+                    ctx.config.insert_use,\n+                );\n                 builder.rewrite(rewriter);\n             },\n         );"}, {"sha": "a40cdd80e03c461eab231fba85582b05e3ba11d0", "filename": "crates/ide_assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=582cee2cdf5355b681f14bbb33bd5c431c284d87", "patch": "@@ -74,17 +74,17 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     };\n \n     let group_label = group_label(candidate);\n-    for (import, item) in proposed_imports {\n+    for import in proposed_imports {\n         acc.add_group(\n             &group_label,\n             AssistId(\"qualify_path\", AssistKind::QuickFix),\n-            label(candidate, &import),\n+            label(candidate, import.display_path()),\n             range,\n             |builder| {\n                 qualify_candidate.qualify(\n                     |replace_with: String| builder.replace(range, replace_with),\n-                    import,\n-                    item,\n+                    import.import_path(),\n+                    import.item_to_import(),\n                 )\n             },\n         );\n@@ -100,8 +100,13 @@ enum QualifyCandidate<'db> {\n }\n \n impl QualifyCandidate<'_> {\n-    fn qualify(&self, mut replacer: impl FnMut(String), import: hir::ModPath, item: hir::ItemInNs) {\n-        let import = mod_path_to_ast(&import);\n+    fn qualify(\n+        &self,\n+        mut replacer: impl FnMut(String),\n+        import: &hir::ModPath,\n+        item: hir::ItemInNs,\n+    ) {\n+        let import = mod_path_to_ast(import);\n         match self {\n             QualifyCandidate::QualifierStart(segment, generics) => {\n                 let generics = generics.as_ref().map_or_else(String::new, ToString::to_string);"}, {"sha": "8ff76688e1229ea649d5940203e14d93040c33f7", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=582cee2cdf5355b681f14bbb33bd5c431c284d87", "patch": "@@ -96,33 +96,30 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n     let mut all_mod_paths = import_assets\n         .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n         .into_iter()\n-        .map(|(mod_path, item_in_ns)| {\n-            let scope_item = match item_in_ns {\n+        .map(|import| {\n+            let proposed_def = match import.item_to_import() {\n                 hir::ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n                 hir::ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n                 hir::ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n             };\n-            (mod_path, scope_item)\n+            (import, proposed_def)\n         })\n         .filter(|(_, proposed_def)| !scope_definitions.contains(proposed_def))\n         .collect::<Vec<_>>();\n-    all_mod_paths.sort_by_cached_key(|(mod_path, _)| {\n-        compute_fuzzy_completion_order_key(mod_path, &user_input_lowercased)\n+    all_mod_paths.sort_by_cached_key(|(import, _)| {\n+        compute_fuzzy_completion_order_key(import.display_path(), &user_input_lowercased)\n     });\n \n-    acc.add_all(all_mod_paths.into_iter().filter_map(|(import_path, definition)| {\n+    acc.add_all(all_mod_paths.into_iter().filter_map(|(import, definition)| {\n         let import_for_trait_assoc_item = match definition {\n             ScopeDef::ModuleDef(module_def) => module_def\n                 .as_assoc_item(ctx.db)\n                 .and_then(|assoc| assoc.containing_trait(ctx.db))\n                 .is_some(),\n             _ => false,\n         };\n-        let import_edit = ImportEdit {\n-            import_path,\n-            import_scope: import_scope.clone(),\n-            import_for_trait_assoc_item,\n-        };\n+        let import_edit =\n+            ImportEdit { import, import_scope: import_scope.clone(), import_for_trait_assoc_item };\n         render_resolution_with_import(RenderContext::new(ctx), import_edit, &definition)\n     }));\n     Some(())\n@@ -186,11 +183,11 @@ fn compute_fuzzy_completion_order_key(\n     user_input_lowercased: &str,\n ) -> usize {\n     cov_mark::hit!(certain_fuzzy_order_test);\n-    let proposed_import_name = match proposed_mod_path.segments().last() {\n+    let import_name = match proposed_mod_path.segments().last() {\n         Some(name) => name.to_string().to_lowercase(),\n         None => return usize::MAX,\n     };\n-    match proposed_import_name.match_indices(user_input_lowercased).next() {\n+    match import_name.match_indices(user_input_lowercased).next() {\n         Some((first_matching_index, _)) => first_matching_index,\n         None => usize::MAX,\n     }"}, {"sha": "0390fe226665d7cc1f6426a2750412366793be14", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=582cee2cdf5355b681f14bbb33bd5c431c284d87", "patch": "@@ -2,9 +2,10 @@\n \n use std::fmt;\n \n-use hir::{Documentation, ModPath, Mutability};\n+use hir::{Documentation, Mutability};\n use ide_db::{\n     helpers::{\n+        import_assets::LocatedImport,\n         insert_use::{self, ImportScope, InsertUseConfig},\n         mod_path_to_ast, SnippetCap,\n     },\n@@ -272,7 +273,7 @@ impl CompletionItem {\n /// An extra import to add after the completion is applied.\n #[derive(Debug, Clone)]\n pub struct ImportEdit {\n-    pub import_path: ModPath,\n+    pub import: LocatedImport,\n     pub import_scope: ImportScope,\n     pub import_for_trait_assoc_item: bool,\n }\n@@ -283,8 +284,11 @@ impl ImportEdit {\n     pub fn to_text_edit(&self, cfg: InsertUseConfig) -> Option<TextEdit> {\n         let _p = profile::span(\"ImportEdit::to_text_edit\");\n \n-        let rewriter =\n-            insert_use::insert_use(&self.import_scope, mod_path_to_ast(&self.import_path), cfg);\n+        let rewriter = insert_use::insert_use(\n+            &self.import_scope,\n+            mod_path_to_ast(self.import.import_path()),\n+            cfg,\n+        );\n         let old_ast = rewriter.rewrite_root()?;\n         let mut import_insert = TextEdit::builder();\n         algo::diff(&old_ast, &rewriter.rewrite(&old_ast)).into_text_edit(&mut import_insert);\n@@ -323,19 +327,13 @@ impl Builder {\n         let mut insert_text = self.insert_text;\n \n         if let Some(import_to_add) = self.import_to_add.as_ref() {\n+            lookup = lookup.or_else(|| Some(label.clone()));\n+            insert_text = insert_text.or_else(|| Some(label.clone()));\n+            let display_path = import_to_add.import.display_path();\n             if import_to_add.import_for_trait_assoc_item {\n-                lookup = lookup.or_else(|| Some(label.clone()));\n-                insert_text = insert_text.or_else(|| Some(label.clone()));\n-                label = format!(\"{} ({})\", label, import_to_add.import_path);\n+                label = format!(\"{} ({})\", label, display_path);\n             } else {\n-                let mut import_path_without_last_segment = import_to_add.import_path.to_owned();\n-                let _ = import_path_without_last_segment.pop_segment();\n-\n-                if !import_path_without_last_segment.segments().is_empty() {\n-                    lookup = lookup.or_else(|| Some(label.clone()));\n-                    insert_text = insert_text.or_else(|| Some(label.clone()));\n-                    label = format!(\"{}::{}\", import_path_without_last_segment, label);\n-                }\n+                label = display_path.to_string();\n             }\n         }\n "}, {"sha": "ca2e5e706a71a11574ae5ef4e29b4d35e9105c95", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=582cee2cdf5355b681f14bbb33bd5c431c284d87", "patch": "@@ -13,7 +13,9 @@ mod completions;\n \n use completions::flyimport::position_for_import;\n use ide_db::{\n-    base_db::FilePosition, helpers::insert_use::ImportScope, imports_locator, RootDatabase,\n+    base_db::FilePosition,\n+    helpers::{import_assets::LocatedImport, insert_use::ImportScope},\n+    imports_locator, RootDatabase,\n };\n use text_edit::TextEdit;\n \n@@ -148,12 +150,16 @@ pub fn resolve_completion_edits(\n     let current_module = ctx.sema.scope(position_for_import).module()?;\n     let current_crate = current_module.krate();\n \n-    let import_path = imports_locator::find_exact_imports(&ctx.sema, current_crate, imported_name)\n-        .filter_map(|candidate| {\n-            let item: hir::ItemInNs = candidate.either(Into::into, Into::into);\n-            current_module.find_use_path_prefixed(db, item, config.insert_use.prefix_kind)\n-        })\n-        .find(|mod_path| mod_path.to_string() == full_import_path)?;\n+    let (import_path, item_to_import) =\n+        imports_locator::find_exact_imports(&ctx.sema, current_crate, imported_name)\n+            .filter_map(|candidate| {\n+                let item: hir::ItemInNs = candidate.either(Into::into, Into::into);\n+                current_module\n+                    .find_use_path_prefixed(db, item, config.insert_use.prefix_kind)\n+                    .zip(Some(item))\n+            })\n+            .find(|(mod_path, _)| mod_path.to_string() == full_import_path)?;\n+    let import = LocatedImport::new(import_path, item_to_import, None);\n \n     ImportEdit { import_path, import_scope, import_for_trait_assoc_item }\n         .to_text_edit(config.insert_use)"}, {"sha": "df26e764264a36fcd0195996a46b181f5ac2fc5e", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=582cee2cdf5355b681f14bbb33bd5c431c284d87", "patch": "@@ -56,7 +56,7 @@ pub(crate) fn render_resolution_with_import<'a>(\n         ScopeDef::ModuleDef(ModuleDef::Function(f)) => f.name(ctx.completion.db).to_string(),\n         ScopeDef::ModuleDef(ModuleDef::Const(c)) => c.name(ctx.completion.db)?.to_string(),\n         ScopeDef::ModuleDef(ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db).to_string(),\n-        _ => import_edit.import_path.segments().last()?.to_string(),\n+        _ => import_edit.import.display_path().segments().last()?.to_string(),\n     };\n     Render::new(ctx).render_resolution(local_name, Some(import_edit), resolution).map(|mut item| {\n         item.completion_kind = CompletionKind::Magic;"}, {"sha": "d8bf61aaaf219b8026f601892a5252481bacc556", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 109, "deletions": 70, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=582cee2cdf5355b681f14bbb33bd5c431c284d87", "patch": "@@ -117,6 +117,42 @@ impl ImportAssets {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LocatedImport {\n+    import_path: ModPath,\n+    item_to_import: ItemInNs,\n+    import_display_override: Option<(ModPath, ItemInNs)>,\n+}\n+\n+impl LocatedImport {\n+    pub fn new(\n+        import_path: ModPath,\n+        item_to_import: ItemInNs,\n+        import_display_override: Option<(ModPath, ItemInNs)>,\n+    ) -> Self {\n+        Self { import_path, item_to_import, import_display_override }\n+    }\n+\n+    pub fn display_path(&self) -> &ModPath {\n+        self.import_display_override\n+            .as_ref()\n+            .map(|(mod_path, _)| mod_path)\n+            .unwrap_or(&self.import_path)\n+    }\n+\n+    pub fn import_path(&self) -> &ModPath {\n+        &self.import_path\n+    }\n+\n+    pub fn item_to_display(&self) -> ItemInNs {\n+        self.import_display_override.as_ref().map(|&(_, item)| item).unwrap_or(self.item_to_import)\n+    }\n+\n+    pub fn item_to_import(&self) -> ItemInNs {\n+        self.item_to_import\n+    }\n+}\n+\n impl ImportAssets {\n     pub fn import_candidate(&self) -> &ImportCandidate {\n         &self.import_candidate\n@@ -134,16 +170,13 @@ impl ImportAssets {\n         &self,\n         sema: &Semantics<RootDatabase>,\n         prefix_kind: PrefixKind,\n-    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n+    ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_imports\");\n         self.search_for(sema, Some(prefix_kind))\n     }\n \n     /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n-    pub fn search_for_relative_paths(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n+    pub fn search_for_relative_paths(&self, sema: &Semantics<RootDatabase>) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_relative_paths\");\n         self.search_for(sema, None)\n     }\n@@ -152,7 +185,7 @@ impl ImportAssets {\n         &self,\n         sema: &Semantics<RootDatabase>,\n         prefixed: Option<hir::PrefixKind>,\n-    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n+    ) -> Vec<LocatedImport> {\n         let current_crate = self.module_with_candidate.krate();\n \n         let imports_for_candidate_name = match self.name_to_import() {\n@@ -181,61 +214,53 @@ impl ImportAssets {\n             }\n         };\n \n-        let mut res = self\n-            .applicable_defs(sema, prefixed, imports_for_candidate_name)\n-            .filter(|(use_path, _)| use_path.len() > 1)\n-            .collect::<Vec<_>>();\n-        res.sort_by_cached_key(|(path, _)| path.clone());\n-        res\n+        self.applicable_defs(sema.db, prefixed, imports_for_candidate_name)\n+            .into_iter()\n+            .filter(|import| import.import_path().len() > 1)\n+            .collect()\n     }\n \n-    fn applicable_defs<'a>(\n-        &'a self,\n-        sema: &'a Semantics<RootDatabase>,\n+    fn applicable_defs(\n+        &self,\n+        db: &RootDatabase,\n         prefixed: Option<hir::PrefixKind>,\n-        unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>> + 'a,\n-    ) -> Box<dyn Iterator<Item = (ModPath, ItemInNs)> + 'a> {\n+        unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n+    ) -> FxHashSet<LocatedImport> {\n         let current_crate = self.module_with_candidate.krate();\n-        let db = sema.db;\n+\n+        let import_path_locator =\n+            |item| get_mod_path(db, item, &self.module_with_candidate, prefixed);\n \n         match &self.import_candidate {\n-            ImportCandidate::Path(path_candidate) => Box::new(\n-                path_applicable_items(\n-                    db,\n-                    path_candidate,\n-                    &self.module_with_candidate,\n-                    prefixed,\n-                    unfiltered_defs,\n-                )\n-                .into_iter(),\n-            ),\n-            ImportCandidate::TraitAssocItem(trait_candidate) => Box::new(\n-                trait_applicable_defs(db, current_crate, trait_candidate, true, unfiltered_defs)\n-                    .into_iter()\n-                    .filter_map(move |item_to_search| {\n-                        get_mod_path(db, item_to_search, &self.module_with_candidate, prefixed)\n-                            .zip(Some(item_to_search))\n-                    }),\n+            ImportCandidate::Path(path_candidate) => {\n+                path_applicable_imports(db, path_candidate, import_path_locator, unfiltered_defs)\n+            }\n+            ImportCandidate::TraitAssocItem(trait_candidate) => trait_applicable_items(\n+                db,\n+                current_crate,\n+                trait_candidate,\n+                true,\n+                import_path_locator,\n+                unfiltered_defs,\n             ),\n-            ImportCandidate::TraitMethod(trait_candidate) => Box::new(\n-                trait_applicable_defs(db, current_crate, trait_candidate, false, unfiltered_defs)\n-                    .into_iter()\n-                    .filter_map(move |item_to_search| {\n-                        get_mod_path(db, item_to_search, &self.module_with_candidate, prefixed)\n-                            .zip(Some(item_to_search))\n-                    }),\n+            ImportCandidate::TraitMethod(trait_candidate) => trait_applicable_items(\n+                db,\n+                current_crate,\n+                trait_candidate,\n+                false,\n+                import_path_locator,\n+                unfiltered_defs,\n             ),\n         }\n     }\n }\n \n-fn path_applicable_items<'a>(\n-    db: &'a RootDatabase,\n-    path_candidate: &'a PathImportCandidate,\n-    module_with_candidate: &hir::Module,\n-    prefixed: Option<hir::PrefixKind>,\n-    unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>> + 'a,\n-) -> FxHashSet<(ModPath, ItemInNs)> {\n+fn path_applicable_imports(\n+    db: &RootDatabase,\n+    path_candidate: &PathImportCandidate,\n+    import_path_locator: impl Fn(ItemInNs) -> Option<ModPath>,\n+    unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n+) -> FxHashSet<LocatedImport> {\n     let applicable_items = unfiltered_defs\n         .filter_map(|def| {\n             let (assoc_original, candidate) = match def {\n@@ -256,14 +281,15 @@ fn path_applicable_items<'a>(\n             Some((assoc_original, candidate))\n         })\n         .filter_map(|(assoc_original, candidate)| {\n-            get_mod_path(db, candidate, module_with_candidate, prefixed)\n-                .zip(Some((assoc_original, candidate)))\n+            import_path_locator(candidate).zip(Some((assoc_original, candidate)))\n         });\n \n     let (unresolved_first_segment, unresolved_qualifier) = match &path_candidate.qualifier {\n         Qualifier::Absent => {\n             return applicable_items\n-                .map(|(candidate_path, (_, candidate))| (candidate_path, candidate))\n+                .map(|(candidate_path, (_, candidate))| {\n+                    LocatedImport::new(candidate_path, candidate, None)\n+                })\n                 .collect();\n         }\n         Qualifier::FirstSegmentUnresolved(first_segment, qualifier) => (first_segment, qualifier),\n@@ -283,19 +309,22 @@ fn path_applicable_items<'a>(\n         .filter_map(|(candidate_path, (assoc_original, candidate))| {\n             if let Some(assoc_original) = assoc_original {\n                 if item_name(db, candidate)?.to_string() == unresolved_first_segment_string {\n-                    return Some((candidate_path, ItemInNs::from(assoc_original)));\n+                    return Some(LocatedImport::new(\n+                        candidate_path.clone(),\n+                        ItemInNs::from(assoc_original),\n+                        Some((candidate_path, candidate)),\n+                    ));\n                 }\n             }\n \n             let matching_module =\n                 module_with_matching_name(db, &unresolved_first_segment_string, candidate)?;\n-            let path = get_mod_path(\n-                db,\n-                ItemInNs::from(ModuleDef::from(matching_module)),\n-                module_with_candidate,\n-                prefixed,\n-            )?;\n-            Some((path, candidate))\n+            let item = ItemInNs::from(ModuleDef::from(matching_module));\n+            Some(LocatedImport::new(\n+                import_path_locator(item)?,\n+                item,\n+                Some((candidate_path, candidate)),\n+            ))\n         })\n         .collect()\n }\n@@ -336,13 +365,14 @@ fn module_with_matching_name(\n     None\n }\n \n-fn trait_applicable_defs<'a>(\n-    db: &'a RootDatabase,\n+fn trait_applicable_items(\n+    db: &RootDatabase,\n     current_crate: Crate,\n     trait_candidate: &TraitImportCandidate,\n     trait_assoc_item: bool,\n-    unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>> + 'a,\n-) -> FxHashSet<ItemInNs> {\n+    import_path_locator: impl Fn(ItemInNs) -> Option<ModPath>,\n+    unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n+) -> FxHashSet<LocatedImport> {\n     let mut required_assoc_items = FxHashSet::default();\n \n     let trait_candidates = unfiltered_defs\n@@ -357,7 +387,7 @@ fn trait_applicable_defs<'a>(\n         })\n         .collect();\n \n-    let mut applicable_traits = FxHashSet::default();\n+    let mut located_imports = FxHashSet::default();\n \n     if trait_assoc_item {\n         trait_candidate.receiver_ty.iterate_path_candidates(\n@@ -372,8 +402,13 @@ fn trait_applicable_defs<'a>(\n                             return None;\n                         }\n                     }\n-                    applicable_traits\n-                        .insert(ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?)));\n+\n+                    let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n+                    located_imports.insert(LocatedImport::new(\n+                        import_path_locator(item)?,\n+                        item,\n+                        None,\n+                    ));\n                 }\n                 None::<()>\n             },\n@@ -387,15 +422,19 @@ fn trait_applicable_defs<'a>(\n             |_, function| {\n                 let assoc = function.as_assoc_item(db)?;\n                 if required_assoc_items.contains(&assoc) {\n-                    applicable_traits\n-                        .insert(ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?)));\n+                    let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n+                    located_imports.insert(LocatedImport::new(\n+                        import_path_locator(item)?,\n+                        item,\n+                        None,\n+                    ));\n                 }\n                 None::<()>\n             },\n         )\n     };\n \n-    applicable_traits\n+    located_imports\n }\n \n fn get_mod_path("}, {"sha": "fd700e04ff49a5f09e18f1459f708c07e1ab54b6", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=582cee2cdf5355b681f14bbb33bd5c431c284d87", "patch": "@@ -17,8 +17,8 @@ use rustc_hash::FxHashSet;\n \n pub(crate) const DEFAULT_QUERY_SEARCH_LIMIT: usize = 40;\n \n-pub fn find_exact_imports<'a>(\n-    sema: &Semantics<'a, RootDatabase>,\n+pub fn find_exact_imports(\n+    sema: &Semantics<'_, RootDatabase>,\n     krate: Crate,\n     name_to_import: String,\n ) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>>> {\n@@ -48,7 +48,7 @@ pub enum AssocItemSearch {\n }\n \n pub fn find_similar_imports<'a>(\n-    sema: &Semantics<'a, RootDatabase>,\n+    sema: &'a Semantics<'a, RootDatabase>,\n     krate: Crate,\n     fuzzy_search_string: String,\n     assoc_item_search: AssocItemSearch,\n@@ -77,12 +77,11 @@ pub fn find_similar_imports<'a>(\n         local_query.limit(limit);\n     }\n \n-    let db = sema.db;\n     Box::new(find_imports(sema, krate, local_query, external_query).filter(\n         move |import_candidate| match assoc_item_search {\n             AssocItemSearch::Include => true,\n-            AssocItemSearch::Exclude => !is_assoc_item(import_candidate, db),\n-            AssocItemSearch::AssocItemsOnly => is_assoc_item(import_candidate, db),\n+            AssocItemSearch::Exclude => !is_assoc_item(import_candidate, sema.db),\n+            AssocItemSearch::AssocItemsOnly => is_assoc_item(import_candidate, sema.db),\n         },\n     ))\n }"}, {"sha": "d479d826fbda833ebfe25f6acb4c86ee0ac1eb32", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582cee2cdf5355b681f14bbb33bd5c431c284d87/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=582cee2cdf5355b681f14bbb33bd5c431c284d87", "patch": "@@ -1534,14 +1534,13 @@ fn fill_resolve_data(\n     position: &TextDocumentPositionParams,\n ) -> Option<()> {\n     let import_edit = item.import_to_add()?;\n-    let full_import_path = import_edit.import_path.to_string();\n-    let imported_name = import_edit.import_path.segments().last()?.to_string();\n+    let import_path = import_edit.import.import_path();\n \n     *resolve_data = Some(\n         to_value(CompletionResolveData {\n             position: position.to_owned(),\n-            full_import_path,\n-            imported_name,\n+            full_import_path: import_path.to_string(),\n+            imported_name: import_path.segments().last()?.to_string(),\n             import_for_trait_assoc_item: import_edit.import_for_trait_assoc_item,\n         })\n         .unwrap(),"}]}