{"sha": "05f13a843370995181904ec961a7920eea9ae7bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZjEzYTg0MzM3MDk5NTE4MTkwNGVjOTYxYTc5MjBlZWE5YWU3YmI=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-11-14T06:21:39Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-11-14T21:33:39Z"}, "message": "Make `process_obligations()` greedier.\n\n`process_obligations()` adds new nodes, but it does not process these\nnew nodes until the next time it is called.\n\nThis commit changes it so that it does process these new nodes within\nthe same call. This change reduces the number of calls to\n`process_obligations()` required to complete processing, sometimes\ngiving significant speed-ups.\n\nThe change required some changes to tests.\n- The output of `cycle-cache-err-60010.rs` is slightly different.\n- The unit tests required extra cases to handle the earlier processing\n  of the added nodes. I mostly did these in the simplest possible way,\n  by making the added nodes be ignored, thus giving outcomes the same as\n  with the old behaviour. But I changed `success_in_grandchildren()`\n  more extensively so that some obligations are completed earlier than\n  they used to be.", "tree": {"sha": "76bc314763b39257a9b3bb97f601136925044a7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76bc314763b39257a9b3bb97f601136925044a7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05f13a843370995181904ec961a7920eea9ae7bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05f13a843370995181904ec961a7920eea9ae7bb", "html_url": "https://github.com/rust-lang/rust/commit/05f13a843370995181904ec961a7920eea9ae7bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05f13a843370995181904ec961a7920eea9ae7bb/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caf018714189db0b15f9f803adfcb4572ab7a988", "url": "https://api.github.com/repos/rust-lang/rust/commits/caf018714189db0b15f9f803adfcb4572ab7a988", "html_url": "https://github.com/rust-lang/rust/commit/caf018714189db0b15f9f803adfcb4572ab7a988"}], "stats": {"total": 47, "additions": 36, "deletions": 11}, "files": [{"sha": "8a5badd0afc69ee37897ac14d64dad307be96a8e", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/05f13a843370995181904ec961a7920eea9ae7bb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f13a843370995181904ec961a7920eea9ae7bb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=05f13a843370995181904ec961a7920eea9ae7bb", "patch": "@@ -395,7 +395,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let mut errors = vec![];\n         let mut stalled = true;\n \n-        for index in 0..self.nodes.len() {\n+        // Note that the loop body can append new nodes, and those new nodes\n+        // will then be processed by subsequent iterations of the loop.\n+        //\n+        // We can't use an iterator for the loop because `self.nodes` is\n+        // appended to and the borrow checker would complain. We also can't use\n+        // `for index in 0..self.nodes.len() { ... }` because the range would\n+        // be computed with the initial length, and we would miss the appended\n+        // nodes. Therefore we use a `while` loop.\n+        let mut index = 0;\n+        while index < self.nodes.len() {\n             let node = &mut self.nodes[index];\n \n             debug!(\"process_obligations: node {} == {:?}\", index, node);\n@@ -406,6 +415,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             // out of sync with `nodes`. It's not very common, but it does\n             // happen, and code in `compress` has to allow for it.\n             if node.state.get() != NodeState::Pending {\n+                index += 1;\n                 continue;\n             }\n             let result = processor.process_obligation(&mut node.obligation);\n@@ -441,6 +451,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     });\n                 }\n             }\n+            index += 1;\n         }\n \n         if stalled {"}, {"sha": "995c99bfec307f9f55380ba581cca24c8437224f", "filename": "src/librustc_data_structures/obligation_forest/tests.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/05f13a843370995181904ec961a7920eea9ae7bb/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f13a843370995181904ec961a7920eea9ae7bb/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs?ref=05f13a843370995181904ec961a7920eea9ae7bb", "patch": "@@ -70,6 +70,7 @@ fn push_pop() {\n                 \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n                 \"B\" => ProcessResult::Error(\"B is for broken\"),\n                 \"C\" => ProcessResult::Changed(vec![]),\n+                \"A.1\" | \"A.2\" | \"A.3\" => ProcessResult::Unchanged,\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n@@ -94,6 +95,7 @@ fn push_pop() {\n                 \"A.2\" => ProcessResult::Unchanged,\n                 \"A.3\" => ProcessResult::Changed(vec![\"A.3.i\"]),\n                 \"D\" => ProcessResult::Changed(vec![\"D.1\", \"D.2\"]),\n+                \"A.3.i\" | \"D.1\" | \"D.2\" => ProcessResult::Unchanged,\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n@@ -113,6 +115,7 @@ fn push_pop() {\n                 \"A.3.i\" => ProcessResult::Changed(vec![]),\n                 \"D.1\" => ProcessResult::Changed(vec![\"D.1.i\"]),\n                 \"D.2\" => ProcessResult::Changed(vec![\"D.2.i\"]),\n+                \"D.1.i\" | \"D.2.i\" => ProcessResult::Unchanged,\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n@@ -161,35 +164,38 @@ fn success_in_grandchildren() {\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n+                \"A.1\" => ProcessResult::Changed(vec![]),\n+                \"A.2\" => ProcessResult::Changed(vec![\"A.2.i\", \"A.2.ii\"]),\n+                \"A.3\" => ProcessResult::Changed(vec![]),\n+                \"A.2.i\" | \"A.2.ii\" => ProcessResult::Unchanged,\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n-    assert!(ok.unwrap().is_empty());\n+    let mut ok = ok.unwrap();\n+    ok.sort();\n+    assert_eq!(ok, vec![\"A.1\", \"A.3\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1\" => ProcessResult::Changed(vec![]),\n-                \"A.2\" => ProcessResult::Changed(vec![\"A.2.i\", \"A.2.ii\"]),\n-                \"A.3\" => ProcessResult::Changed(vec![]),\n+                \"A.2.i\" => ProcessResult::Unchanged,\n+                \"A.2.ii\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n-    let mut ok = ok.unwrap();\n-    ok.sort();\n-    assert_eq!(ok, vec![\"A.1\", \"A.3\"]);\n+    assert_eq!(ok.unwrap(), vec![\"A.2.ii\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A.2.i\" => ProcessResult::Changed(vec![\"A.2.i.a\"]),\n-                \"A.2.ii\" => ProcessResult::Changed(vec![]),\n+                \"A.2.i.a\" => ProcessResult::Unchanged,\n                 _ => unreachable!(),\n             }\n         }, |_| {}), DoCompleted::Yes);\n-    assert_eq!(ok.unwrap(), vec![\"A.2.ii\"]);\n+    assert!(ok.unwrap().is_empty());\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -222,6 +228,7 @@ fn to_errors_no_throw() {\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n+                \"A.1\" | \"A.2\" | \"A.3\" => ProcessResult::Unchanged,\n                 _ => unreachable!(),\n             }\n         }, |_|{}), DoCompleted::Yes);\n@@ -243,6 +250,7 @@ fn diamond() {\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\"]),\n+                \"A.1\" | \"A.2\" => ProcessResult::Unchanged,\n                 _ => unreachable!(),\n             }\n         }, |_|{}), DoCompleted::Yes);\n@@ -254,6 +262,7 @@ fn diamond() {\n             match *obligation {\n                 \"A.1\" => ProcessResult::Changed(vec![\"D\"]),\n                 \"A.2\" => ProcessResult::Changed(vec![\"D\"]),\n+                \"D\" => ProcessResult::Unchanged,\n                 _ => unreachable!(),\n             }\n         }, |_|{}), DoCompleted::Yes);\n@@ -282,6 +291,7 @@ fn diamond() {\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A'\" => ProcessResult::Changed(vec![\"A'.1\", \"A'.2\"]),\n+                \"A'.1\" | \"A'.2\" => ProcessResult::Unchanged,\n                 _ => unreachable!(),\n             }\n         }, |_|{}), DoCompleted::Yes);\n@@ -293,6 +303,7 @@ fn diamond() {\n             match *obligation {\n                 \"A'.1\" => ProcessResult::Changed(vec![\"D'\", \"A'\"]),\n                 \"A'.2\" => ProcessResult::Changed(vec![\"D'\"]),\n+                \"D'\" | \"A'\" => ProcessResult::Unchanged,\n                 _ => unreachable!(),\n             }\n         }, |_|{}), DoCompleted::Yes);\n@@ -370,6 +381,7 @@ fn orphan() {\n                 \"B\" => ProcessResult::Unchanged,\n                 \"C1\" => ProcessResult::Changed(vec![]),\n                 \"C2\" => ProcessResult::Changed(vec![]),\n+                \"D\" | \"E\" => ProcessResult::Unchanged,\n                 _ => unreachable!(),\n             }\n         }, |_|{}), DoCompleted::Yes);"}, {"sha": "295845b1146ef6451629878cc5f5064abbfb7bbd", "filename": "src/test/ui/traits/cycle-cache-err-60010.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05f13a843370995181904ec961a7920eea9ae7bb/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05f13a843370995181904ec961a7920eea9ae7bb/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr?ref=05f13a843370995181904ec961a7920eea9ae7bb", "patch": "@@ -6,7 +6,7 @@ LL |     _parse: <ParseQuery as Query<RootDatabase>>::Data,\n    |\n    = note: required because of the requirements on the impl of `Query<RootDatabase>` for `ParseQuery`\n \n-error[E0275]: overflow evaluating the requirement `RootDatabase: SourceDatabase`\n+error[E0275]: overflow evaluating the requirement `Runtime<RootDatabase>: std::panic::RefUnwindSafe`\n   --> $DIR/cycle-cache-err-60010.rs:31:5\n    |\n LL |     type Storage;\n@@ -17,6 +17,8 @@ LL | impl Database for RootDatabase {\n LL |     type Storage = SalsaStorage;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+   = note: required because it appears within the type `RootDatabase`\n+   = note: required because of the requirements on the impl of `SourceDatabase` for `RootDatabase`\n    = note: required because of the requirements on the impl of `Query<RootDatabase>` for `ParseQuery`\n    = note: required because it appears within the type `SalsaStorage`\n "}]}