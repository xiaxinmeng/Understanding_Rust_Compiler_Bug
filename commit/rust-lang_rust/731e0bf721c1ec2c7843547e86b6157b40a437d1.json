{"sha": "731e0bf721c1ec2c7843547e86b6157b40a437d1", "node_id": "C_kwDOAAsO6NoAKDczMWUwYmY3MjFjMWVjMmM3ODQzNTQ3ZTg2YjYxNTdiNDBhNDM3ZDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-26T12:03:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-26T12:03:47Z"}, "message": "Auto merge of #103828 - cassaundra:fix-format-args-span2, r=cjgillot\n\nFix incorrect span when using byte-escaped rbrace\n\nFix #103826, a format args span issue introduced in #102214.\n\nThe current solution for tracking skipped characters made it so that certain situations were ambiguous enough that the original span couldn't be worked out later. This PR improves on the original solution by keeping track of groups of skipped characters using a map, and fixes the previous bug. See an example of this ambiguity in the [previous PR's discussion](https://github.com/rust-lang/rust/pull/102214#issuecomment-1258711015).", "tree": {"sha": "2adf07470f23ec77fecd22bae1c7c1366ebe9da6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2adf07470f23ec77fecd22bae1c7c1366ebe9da6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/731e0bf721c1ec2c7843547e86b6157b40a437d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/731e0bf721c1ec2c7843547e86b6157b40a437d1", "html_url": "https://github.com/rust-lang/rust/commit/731e0bf721c1ec2c7843547e86b6157b40a437d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/731e0bf721c1ec2c7843547e86b6157b40a437d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f206533fd40378da6e2a07567e8d7592edd13ee4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f206533fd40378da6e2a07567e8d7592edd13ee4", "html_url": "https://github.com/rust-lang/rust/commit/f206533fd40378da6e2a07567e8d7592edd13ee4"}, {"sha": "35c7939ae5d3a0e34963bbd57bbc4b91c3ce0ce3", "url": "https://api.github.com/repos/rust-lang/rust/commits/35c7939ae5d3a0e34963bbd57bbc4b91c3ce0ce3", "html_url": "https://github.com/rust-lang/rust/commit/35c7939ae5d3a0e34963bbd57bbc4b91c3ce0ce3"}], "stats": {"total": 155, "additions": 107, "deletions": 48}, "files": [{"sha": "ab0463045faf998ddf7868ff189ba0600a24e42a", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 79, "deletions": 48, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/731e0bf721c1ec2c7843547e86b6157b40a437d1/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/731e0bf721c1ec2c7843547e86b6157b40a437d1/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=731e0bf721c1ec2c7843547e86b6157b40a437d1", "patch": "@@ -38,6 +38,24 @@ impl InnerSpan {\n     }\n }\n \n+/// The location and before/after width of a character whose width has changed from its source code\n+/// representation\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub struct InnerWidthMapping {\n+    /// Index of the character in the source\n+    pub position: usize,\n+    /// The inner width in characters\n+    pub before: usize,\n+    /// The transformed width in characters\n+    pub after: usize,\n+}\n+\n+impl InnerWidthMapping {\n+    pub fn new(position: usize, before: usize, after: usize) -> InnerWidthMapping {\n+        InnerWidthMapping { position, before, after }\n+    }\n+}\n+\n /// The type of format string that we are parsing.\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum ParseMode {\n@@ -200,8 +218,8 @@ pub struct Parser<'a> {\n     style: Option<usize>,\n     /// Start and end byte offset of every successfully parsed argument\n     pub arg_places: Vec<InnerSpan>,\n-    /// Characters that need to be shifted\n-    skips: Vec<usize>,\n+    /// Characters whose length has been changed from their in-code representation\n+    width_map: Vec<InnerWidthMapping>,\n     /// Span of the last opening brace seen, used for error reporting\n     last_opening_brace: Option<InnerSpan>,\n     /// Whether the source string is comes from `println!` as opposed to `format!` or `print!`\n@@ -224,7 +242,7 @@ impl<'a> Iterator for Parser<'a> {\n                 '{' => {\n                     let curr_last_brace = self.last_opening_brace;\n                     let byte_pos = self.to_span_index(pos);\n-                    let lbrace_end = self.to_span_index(pos + 1);\n+                    let lbrace_end = InnerOffset(byte_pos.0 + self.to_span_width(pos));\n                     self.last_opening_brace = Some(byte_pos.to(lbrace_end));\n                     self.cur.next();\n                     if self.consume('{') {\n@@ -233,12 +251,15 @@ impl<'a> Iterator for Parser<'a> {\n                         Some(String(self.string(pos + 1)))\n                     } else {\n                         let arg = self.argument(lbrace_end);\n-                        if let Some(rbrace_byte_idx) = self.must_consume('}') {\n-                            let lbrace_inner_offset = self.to_span_index(pos);\n-                            let rbrace_inner_offset = self.to_span_index(rbrace_byte_idx);\n+                        if let Some(rbrace_pos) = self.must_consume('}') {\n                             if self.is_literal {\n+                                let lbrace_byte_pos = self.to_span_index(pos);\n+                                let rbrace_byte_pos = self.to_span_index(rbrace_pos);\n+\n+                                let width = self.to_span_width(rbrace_pos);\n+\n                                 self.arg_places.push(\n-                                    lbrace_inner_offset.to(InnerOffset(rbrace_inner_offset.0 + 1)),\n+                                    lbrace_byte_pos.to(InnerOffset(rbrace_byte_pos.0 + width)),\n                                 );\n                             }\n                         } else {\n@@ -285,7 +306,7 @@ impl<'a> Parser<'a> {\n         append_newline: bool,\n         mode: ParseMode,\n     ) -> Parser<'a> {\n-        let (skips, is_literal) = find_skips_from_snippet(snippet, style);\n+        let (width_map, is_literal) = find_width_map_from_snippet(snippet, style);\n         Parser {\n             mode,\n             input: s,\n@@ -294,7 +315,7 @@ impl<'a> Parser<'a> {\n             curarg: 0,\n             style,\n             arg_places: vec![],\n-            skips,\n+            width_map,\n             last_opening_brace: None,\n             append_newline,\n             is_literal,\n@@ -367,21 +388,34 @@ impl<'a> Parser<'a> {\n         None\n     }\n \n+    fn remap_pos(&self, mut pos: usize) -> InnerOffset {\n+        for width in &self.width_map {\n+            if pos > width.position {\n+                pos += width.before - width.after;\n+            } else if pos == width.position && width.after == 0 {\n+                pos += width.before;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        InnerOffset(pos)\n+    }\n+\n     fn to_span_index(&self, pos: usize) -> InnerOffset {\n-        let mut pos = pos;\n         // This handles the raw string case, the raw argument is the number of #\n         // in r###\"...\"### (we need to add one because of the `r`).\n         let raw = self.style.map_or(0, |raw| raw + 1);\n-        for skip in &self.skips {\n-            if pos > *skip {\n-                pos += 1;\n-            } else if pos == *skip && raw == 0 {\n-                pos += 1;\n-            } else {\n-                break;\n-            }\n+        let pos = self.remap_pos(pos);\n+        InnerOffset(raw + pos.0 + 1)\n+    }\n+\n+    fn to_span_width(&self, pos: usize) -> usize {\n+        let pos = self.remap_pos(pos);\n+        match self.width_map.iter().find(|w| w.position == pos.0) {\n+            Some(w) => w.before,\n+            None => 1,\n         }\n-        InnerOffset(raw + pos + 1)\n     }\n \n     fn span(&self, start_pos: usize, end_pos: usize) -> InnerSpan {\n@@ -809,10 +843,10 @@ impl<'a> Parser<'a> {\n /// Finds the indices of all characters that have been processed and differ between the actual\n /// written code (code snippet) and the `InternedString` that gets processed in the `Parser`\n /// in order to properly synthesise the intra-string `Span`s for error diagnostics.\n-fn find_skips_from_snippet(\n+fn find_width_map_from_snippet(\n     snippet: Option<string::String>,\n     str_style: Option<usize>,\n-) -> (Vec<usize>, bool) {\n+) -> (Vec<InnerWidthMapping>, bool) {\n     let snippet = match snippet {\n         Some(ref s) if s.starts_with('\"') || s.starts_with(\"r\\\"\") || s.starts_with(\"r#\") => s,\n         _ => return (vec![], false),\n@@ -825,43 +859,39 @@ fn find_skips_from_snippet(\n     let snippet = &snippet[1..snippet.len() - 1];\n \n     let mut s = snippet.char_indices();\n-    let mut skips = vec![];\n+    let mut width_mappings = vec![];\n     while let Some((pos, c)) = s.next() {\n         match (c, s.clone().next()) {\n             // skip whitespace and empty lines ending in '\\\\'\n-            ('\\\\', Some((next_pos, '\\n'))) => {\n-                skips.push(pos);\n-                skips.push(next_pos);\n+            ('\\\\', Some((_, '\\n'))) => {\n                 let _ = s.next();\n+                let mut width = 2;\n \n-                while let Some((pos, c)) = s.clone().next() {\n+                while let Some((_, c)) = s.clone().next() {\n                     if matches!(c, ' ' | '\\n' | '\\t') {\n-                        skips.push(pos);\n+                        width += 1;\n                         let _ = s.next();\n                     } else {\n                         break;\n                     }\n                 }\n+\n+                width_mappings.push(InnerWidthMapping::new(pos, width, 0));\n             }\n-            ('\\\\', Some((next_pos, 'n' | 't' | 'r' | '0' | '\\\\' | '\\'' | '\\\"'))) => {\n-                skips.push(next_pos);\n+            ('\\\\', Some((_, 'n' | 't' | 'r' | '0' | '\\\\' | '\\'' | '\\\"'))) => {\n+                width_mappings.push(InnerWidthMapping::new(pos, 2, 1));\n                 let _ = s.next();\n             }\n             ('\\\\', Some((_, 'x'))) => {\n-                for _ in 0..3 {\n-                    // consume `\\xAB` literal\n-                    if let Some((pos, _)) = s.next() {\n-                        skips.push(pos);\n-                    } else {\n-                        break;\n-                    }\n-                }\n+                // consume `\\xAB` literal\n+                s.nth(2);\n+                width_mappings.push(InnerWidthMapping::new(pos, 4, 1));\n             }\n             ('\\\\', Some((_, 'u'))) => {\n-                if let Some((pos, _)) = s.next() {\n-                    skips.push(pos);\n-                }\n-                if let Some((next_pos, next_c)) = s.next() {\n+                let mut width = 2;\n+                let _ = s.next();\n+\n+                if let Some((_, next_c)) = s.next() {\n                     if next_c == '{' {\n                         // consume up to 6 hexanumeric chars\n                         let digits_len =\n@@ -881,31 +911,32 @@ fn find_skips_from_snippet(\n                         let required_skips = digits_len.saturating_sub(len_utf8.saturating_sub(1));\n \n                         // skip '{' and '}' also\n-                        for pos in (next_pos..).take(required_skips + 2) {\n-                            skips.push(pos)\n-                        }\n+                        width += required_skips + 2;\n \n                         s.nth(digits_len);\n                     } else if next_c.is_digit(16) {\n-                        skips.push(next_pos);\n+                        width += 1;\n+\n                         // We suggest adding `{` and `}` when appropriate, accept it here as if\n                         // it were correct\n                         let mut i = 0; // consume up to 6 hexanumeric chars\n-                        while let (Some((next_pos, c)), _) = (s.next(), i < 6) {\n+                        while let (Some((_, c)), _) = (s.next(), i < 6) {\n                             if c.is_digit(16) {\n-                                skips.push(next_pos);\n+                                width += 1;\n                             } else {\n                                 break;\n                             }\n                             i += 1;\n                         }\n                     }\n                 }\n+\n+                width_mappings.push(InnerWidthMapping::new(pos, width, 1));\n             }\n             _ => {}\n         }\n     }\n-    (skips, true)\n+    (width_mappings, true)\n }\n \n // Assert a reasonable size for `Piece`"}, {"sha": "a11ec37a06dbb7c3572688e9de5830f42259ddf5", "filename": "src/test/ui/fmt/issue-103826.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/731e0bf721c1ec2c7843547e86b6157b40a437d1/src%2Ftest%2Fui%2Ffmt%2Fissue-103826.rs", "raw_url": "https://github.com/rust-lang/rust/raw/731e0bf721c1ec2c7843547e86b6157b40a437d1/src%2Ftest%2Fui%2Ffmt%2Fissue-103826.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fissue-103826.rs?ref=731e0bf721c1ec2c7843547e86b6157b40a437d1", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    format!(\"{\\x7D\");\n+    //~^ ERROR 1 positional argument in format string, but no arguments were given\n+    format!(\"\\x7B\\x7D\");\n+    //~^ ERROR 1 positional argument in format string, but no arguments were given\n+    format!(\"{\\x7D {\\x7D\");\n+    //~^ ERROR 2 positional arguments in format string, but no arguments were given\n+}"}, {"sha": "0f27e1930bc3e49f33e6859c8bcbeb85799a4232", "filename": "src/test/ui/fmt/issue-103826.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/731e0bf721c1ec2c7843547e86b6157b40a437d1/src%2Ftest%2Fui%2Ffmt%2Fissue-103826.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/731e0bf721c1ec2c7843547e86b6157b40a437d1/src%2Ftest%2Fui%2Ffmt%2Fissue-103826.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fissue-103826.stderr?ref=731e0bf721c1ec2c7843547e86b6157b40a437d1", "patch": "@@ -0,0 +1,20 @@\n+error: 1 positional argument in format string, but no arguments were given\n+  --> $DIR/issue-103826.rs:2:14\n+   |\n+LL |     format!(\"{\\x7D\");\n+   |              ^^^^^\n+\n+error: 1 positional argument in format string, but no arguments were given\n+  --> $DIR/issue-103826.rs:4:14\n+   |\n+LL |     format!(\"\\x7B\\x7D\");\n+   |              ^^^^^^^^\n+\n+error: 2 positional arguments in format string, but no arguments were given\n+  --> $DIR/issue-103826.rs:6:14\n+   |\n+LL |     format!(\"{\\x7D {\\x7D\");\n+   |              ^^^^^ ^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}]}