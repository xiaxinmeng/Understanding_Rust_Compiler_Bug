{"sha": "cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkMWI2Yzg5NzkxMWM5MTE2N2M1YTNjNWUzYzJmYTBkOTMzNGFkNDU=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2013-07-05T10:15:21Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-07-07T10:51:09Z"}, "message": "De-managed ast::Path", "tree": {"sha": "547f2b0e84098a4aeea47dc30fa08b70541f30f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/547f2b0e84098a4aeea47dc30fa08b70541f30f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "html_url": "https://github.com/rust-lang/rust/commit/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a69eb952336bb3d483dd046373daa8e3948390a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a69eb952336bb3d483dd046373daa8e3948390a7", "html_url": "https://github.com/rust-lang/rust/commit/a69eb952336bb3d483dd046373daa8e3948390a7"}], "stats": {"total": 404, "additions": 206, "deletions": 198}, "files": [{"sha": "699799929ba00ad3a0efba28b30f0e6506e401b8", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -75,7 +75,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n         fold_mod: |module, fld| {\n             let n2 = sess.next_node_id();\n \n-            let prelude_path = @ast::Path {\n+            let prelude_path = ast::Path {\n                 span: dummy_sp(),\n                 global: false,\n                 idents: ~["}, {"sha": "f2670a663ea0c4ce14d5ee0dac007da1ea930c5a", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -342,16 +342,16 @@ fn nospan<T:Copy>(t: T) -> codemap::spanned<T> {\n     codemap::spanned { node: t, span: dummy_sp() }\n }\n \n-fn path_node(ids: ~[ast::ident]) -> @ast::Path {\n-    @ast::Path { span: dummy_sp(),\n+fn path_node(ids: ~[ast::ident]) -> ast::Path {\n+    ast::Path { span: dummy_sp(),\n                 global: false,\n                 idents: ids,\n                 rp: None,\n                 types: ~[] }\n }\n \n-fn path_node_global(ids: ~[ast::ident]) -> @ast::Path {\n-    @ast::Path { span: dummy_sp(),\n+fn path_node_global(ids: ~[ast::ident]) -> ast::Path {\n+    ast::Path { span: dummy_sp(),\n                  global: true,\n                  idents: ids,\n                  rp: None,"}, {"sha": "91dba63a182e0d6ab73cc4b436d487d19f351e3a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -1014,7 +1014,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n-            ast::ty_path(path, bounds, _) if path.idents.len() == 1 => {\n+            ast::ty_path(ref path, bounds, _) if path.idents.len() == 1 => {\n                 assert!(bounds.is_none());\n                 encode_impl_type_basename(ecx, ebml_w,\n                                           ast_util::path_to_ident(path));"}, {"sha": "7113244c7f6cf3e589b907928d2fee528143fdaa", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -112,7 +112,7 @@ pub fn check_expr(sess: Session,\n                               \"` in a constant expression\");\n             }\n           }\n-          expr_path(pth) => {\n+          expr_path(ref pth) => {\n             // NB: In the future you might wish to relax this slightly\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on"}, {"sha": "7dd7ae6ec9ae0a71f86513d37a35a936f282a059", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -71,10 +71,10 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n }\n \n pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n-                    it: &fn(binding_mode, node_id, span, @Path)) {\n+                    it: &fn(binding_mode, node_id, span, &Path)) {\n     for walk_pat(pat) |p| {\n         match p.node {\n-          pat_ident(binding_mode, pth, _) if pat_is_binding(dm, p) => {\n+          pat_ident(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}"}, {"sha": "dd6b5615c3f3fe460849ea9866536fd107b6cf67", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -276,7 +276,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     };\n \n     // Checks that a private path is in scope.\n-    let check_path: @fn(span: span, def: def, path: @Path) =\n+    let check_path: @fn(span: span, def: def, path: &Path) =\n             |span, def, path| {\n         debug!(\"checking path\");\n         match def {\n@@ -449,7 +449,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         _ => {}\n                     }\n                 }\n-                expr_path(path) => {\n+                expr_path(ref path) => {\n                     check_path(expr.span, tcx.def_map.get_copy(&expr.id), path);\n                 }\n                 expr_struct(_, ref fields, _) => {"}, {"sha": "69cdbbb89771481f5bcd2acc355ad172544f46ae", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -784,7 +784,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     // then check whether it is region-parameterized and consider\n     // that as a direct dependency.\n     match ty.node {\n-      ast::ty_path(path, _bounds, id) => {\n+      ast::ty_path(ref path, _bounds, id) => {\n         match cx.def_map.find(&id) {\n           Some(&ast::def_ty(did)) |\n           Some(&ast::def_trait(did)) |\n@@ -820,7 +820,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n         visit_mt(mt, (cx, visitor));\n       }\n \n-      ast::ty_path(path, _bounds, _) => {\n+      ast::ty_path(ref path, _bounds, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for path.types.iter().advance |tp| {"}, {"sha": "8f73c8fc173008116fb99bfdfe08ad9a18a7f925", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -1245,7 +1245,7 @@ impl Resolver {\n                 // Create the module and add all methods.\n                 match *ty {\n                     Ty {\n-                        node: ty_path(path, _, _),\n+                        node: ty_path(ref path, _, _),\n                         _\n                     } if path.idents.len() == 1 => {\n                         let name = path_to_ident(path);\n@@ -1446,7 +1446,7 @@ impl Resolver {\n \n                     let mut module_path = ~[];\n                     match view_path.node {\n-                        view_path_simple(_, full_path, _) => {\n+                        view_path_simple(_, ref full_path, _) => {\n                             let path_len = full_path.idents.len();\n                             assert!(path_len != 0);\n \n@@ -1457,8 +1457,8 @@ impl Resolver {\n                             }\n                         }\n \n-                        view_path_glob(module_ident_path, _) |\n-                        view_path_list(module_ident_path, _, _) => {\n+                        view_path_glob(ref module_ident_path, _) |\n+                        view_path_list(ref module_ident_path, _, _) => {\n                             for module_ident_path.idents.iter().advance |ident| {\n                                 module_path.push(*ident);\n                             }\n@@ -1468,7 +1468,7 @@ impl Resolver {\n                     // Build up the import directives.\n                     let module_ = self.get_module_from_parent(parent);\n                     match view_path.node {\n-                        view_path_simple(binding, full_path, id) => {\n+                        view_path_simple(binding, ref full_path, id) => {\n                             let source_ident = *full_path.idents.last();\n                             let subclass = @SingleImport(binding,\n                                                          source_ident);\n@@ -3561,7 +3561,7 @@ impl Resolver {\n \n                     // Resolve derived traits.\n                     for traits.iter().advance |trt| {\n-                        self.resolve_trait_reference(*trt, visitor, TraitDerivation);\n+                        self.resolve_trait_reference(trt, visitor, TraitDerivation);\n                     }\n \n                     for (*methods).iter().advance |method| {\n@@ -4117,7 +4117,7 @@ impl Resolver {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n \n-            ty_path(path, bounds, path_id) => {\n+            ty_path(ref path, bounds, path_id) => {\n                 // This is a path in the type namespace. Walk through scopes\n                 // scopes looking for it.\n                 let mut result_def = None;\n@@ -4211,7 +4211,7 @@ impl Resolver {\n         let pat_id = pattern.id;\n         for walk_pat(pattern) |pattern| {\n             match pattern.node {\n-                pat_ident(binding_mode, path, _)\n+                pat_ident(binding_mode, ref path, _)\n                         if !path.global && path.idents.len() == 1 => {\n \n                     // The meaning of pat_ident with no type parameters\n@@ -4338,7 +4338,7 @@ impl Resolver {\n                     }\n                 }\n \n-                pat_ident(binding_mode, path, _) => {\n+                pat_ident(binding_mode, ref path, _) => {\n                     // This must be an enum variant, struct, or constant.\n                     match self.resolve_path(path, ValueNS, false, visitor) {\n                         Some(def @ def_variant(*)) |\n@@ -4371,7 +4371,7 @@ impl Resolver {\n                     }\n                 }\n \n-                pat_enum(path, _) => {\n+                pat_enum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n                     match self.resolve_path(path, ValueNS, false, visitor) {\n                         Some(def @ def_fn(*))      |\n@@ -4409,7 +4409,7 @@ impl Resolver {\n                     self.resolve_expr(last_expr, visitor);\n                 }\n \n-                pat_struct(path, _, _) => {\n+                pat_struct(ref path, _, _) => {\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n                                 if self.structs.contains(&class_id) => {\n@@ -4484,7 +4484,7 @@ impl Resolver {\n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n     pub fn resolve_path(@mut self,\n-                        path: @Path,\n+                        path: &Path,\n                         namespace: Namespace,\n                         check_ribs: bool,\n                         visitor: ResolveVisitor)\n@@ -4610,7 +4610,7 @@ impl Resolver {\n         return NoNameDefinition;\n     }\n \n-    pub fn intern_module_part_of_path(@mut self, path: @Path) -> ~[ident] {\n+    pub fn intern_module_part_of_path(@mut self, path: &Path) -> ~[ident] {\n         let mut module_path_idents = ~[];\n         for path.idents.iter().enumerate().advance |(index, ident)| {\n             if index == path.idents.len() - 1 {\n@@ -4624,7 +4624,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_module_relative_path(@mut self,\n-                                        path: @Path,\n+                                        path: &Path,\n                                         xray: XrayFlag,\n                                         namespace: Namespace)\n                                         -> Option<def> {\n@@ -4690,7 +4690,7 @@ impl Resolver {\n     /// Invariant: This must be called only during main resolution, not during\n     /// import resolution.\n     pub fn resolve_crate_relative_path(@mut self,\n-                                       path: @Path,\n+                                       path: &Path,\n                                        xray: XrayFlag,\n                                        namespace: Namespace)\n                                        -> Option<def> {\n@@ -4916,7 +4916,7 @@ impl Resolver {\n             // The interpretation of paths depends on whether the path has\n             // multiple elements in it or not.\n \n-            expr_path(path) => {\n+            expr_path(ref path) => {\n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n \n@@ -4985,7 +4985,7 @@ impl Resolver {\n                                       visitor);\n             }\n \n-            expr_struct(path, _, _) => {\n+            expr_struct(ref path, _, _) => {\n                 // Resolve the path to the structure it goes to.\n                 match self.resolve_path(path, TypeNS, false, visitor) {\n                     Some(def_ty(class_id)) | Some(def_struct(class_id))"}, {"sha": "3e828a891d49eac71b946147857e75a617919e35", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -385,7 +385,7 @@ pub fn expand_nested_bindings<'r>(bcx: block,\n \n     do m.map |br| {\n         match br.pats[col].node {\n-            ast::pat_ident(_, path, Some(inner)) => {\n+            ast::pat_ident(_, ref path, Some(inner)) => {\n                 let pats = vec::append(\n                     br.pats.slice(0u, col).to_owned(),\n                     vec::append(~[inner],\n@@ -441,7 +441,7 @@ pub fn enter_match<'r>(bcx: block,\n \n                 let this = br.pats[col];\n                 match this.node {\n-                    ast::pat_ident(_, path, None) => {\n+                    ast::pat_ident(_, ref path, None) => {\n                         if pat_is_binding(dm, this) {\n                             let binding_info =\n                                 br.data.bindings_map.get("}, {"sha": "e5edd43cf05130e34eabe089580ec93e85b3924e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -1399,7 +1399,7 @@ pub fn alloc_local(cx: block, local: &ast::local) -> block {\n     let _icx = push_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = match local.node.pat.node {\n-      ast::pat_ident(_, pth, None) => Some(path_to_ident(pth)),\n+      ast::pat_ident(_, ref pth, None) => Some(path_to_ident(pth)),\n       _ => None\n     };\n     let val = alloc_ty(cx, t);"}, {"sha": "bbec78880fe23b323d2e67b2bc0811a6ad66fd57", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -525,7 +525,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n             }\n           }\n-          ast::expr_path(pth) => {\n+          ast::expr_path(ref pth) => {\n             assert_eq!(pth.types.len(), 0);\n             let tcx = cx.tcx;\n             match tcx.def_map.find(&e.id) {"}, {"sha": "32a71ea7019723e840501e88d7a6a15fd8331e76", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -133,7 +133,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n     let cx = bcx.ccx();\n \n     let ident = match local.node.pat.node {\n-      ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n+      ast::pat_ident(_, ref pth, _) => ast_util::path_to_ident(pth),\n       // FIXME this should be handled (#2533)\n       _ => {\n         bcx.sess().span_note(local.span, \"debuginfo for pattern bindings NYI\");\n@@ -204,7 +204,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n     let context = create_function(fcx);\n \n     match arg.pat.node {\n-        ast::pat_ident(_, path, _) => {\n+        ast::pat_ident(_, ref path, _) => {\n             // XXX: This is wrong; it should work for multiple bindings.\n             let ident = path.idents.last();\n             let name: &str = cx.sess.str_of(*ident);"}, {"sha": "1cab6607077d5d9a56ef10c5917c57b531cdc02b", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -136,7 +136,7 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n     def_id: ast::def_id,\n     decl_generics: &ty::Generics,\n     self_ty: Option<ty::t>,\n-    path: @ast::Path) -> ty::substs\n+    path: &ast::Path) -> ty::substs\n {\n     /*!\n      *\n@@ -188,7 +188,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::def_id,\n-    path: @ast::Path) -> ty_param_substs_and_ty\n+    path: &ast::Path) -> ty_param_substs_and_ty\n {\n     let tcx = this.tcx();\n     let ty::ty_param_bounds_and_ty {\n@@ -206,7 +206,7 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Copy + 'static>(\n     rscope: &RS,\n     trait_def_id: ast::def_id,\n     self_ty: Option<ty::t>,\n-    path: @ast::Path) -> @ty::TraitRef\n+    path: &ast::Path) -> @ty::TraitRef\n {\n     let trait_def =\n         this.get_trait_def(trait_def_id);\n@@ -228,7 +228,7 @@ pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n         this: &AC,\n         rscope: &RS,\n         did: ast::def_id,\n-        path: @ast::Path)\n+        path: &ast::Path)\n      -> ty_param_substs_and_ty\n {\n     // Look up the polytype of the item and then substitute the provided types\n@@ -276,7 +276,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                 }\n                 return ty::mk_evec(tcx, mt, vst);\n             }\n-            ast::ty_path(path, bounds, id) => {\n+            ast::ty_path(ref path, bounds, id) => {\n                 // Note that the \"bounds must be empty if path is not a trait\"\n                 // restriction is enforced in the below case for ty_path, which\n                 // will run after this as long as the path isn't a trait.\n@@ -321,7 +321,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n     }\n \n     fn check_path_args(tcx: ty::ctxt,\n-                       path: @ast::Path,\n+                       path: &ast::Path,\n                        flags: uint) {\n         if (flags & NO_TPS) != 0u {\n             if path.types.len() > 0u {\n@@ -405,7 +405,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n       }\n-      ast::ty_path(path, bounds, id) => {\n+      ast::ty_path(ref path, bounds, id) => {\n         let a_def = match tcx.def_map.find(&id) {\n           None => tcx.sess.span_fatal(\n               ast_ty.span, fmt!(\"unbound path %s\","}, {"sha": "1f7946576db5c6cd95c010b952403a000e27a5bf", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -105,7 +105,7 @@ pub struct pat_ctxt {\n     map: PatIdMap,\n }\n \n-pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n+pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                          subpats: &Option<~[@ast::pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n@@ -271,7 +271,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n /// `etc` is true if the pattern said '...' and false otherwise.\n pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                span: span,\n-                               path: @ast::Path,\n+                               path: &ast::Path,\n                                fields: &[ast::field_pat],\n                                class_fields: ~[ty::field_ty],\n                                class_id: ast::def_id,\n@@ -322,7 +322,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n }\n \n pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::node_id, span: span,\n-                        expected: ty::t, path: @ast::Path,\n+                        expected: ty::t, path: &ast::Path,\n                         fields: &[ast::field_pat], etc: bool,\n                         class_id: ast::def_id, substitutions: &ty::substs) {\n     let fcx = pcx.fcx;\n@@ -356,7 +356,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                           pat_id: ast::node_id,\n                                           span: span,\n                                           expected: ty::t,\n-                                          path: @ast::Path,\n+                                          path: &ast::Path,\n                                           fields: &[ast::field_pat],\n                                           etc: bool,\n                                           enum_id: ast::def_id,\n@@ -440,7 +440,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);\n       }\n-      ast::pat_ident(bm, name, sub) if pat_is_binding(tcx.def_map, pat) => {\n+      ast::pat_ident(bm, ref name, sub) if pat_is_binding(tcx.def_map, pat) => {\n         let typ = fcx.local_ty(pat.span, pat.id);\n \n         match bm {\n@@ -476,13 +476,13 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           _ => ()\n         }\n       }\n-      ast::pat_ident(_, path, _) => {\n+      ast::pat_ident(_, ref path, _) => {\n         check_pat_variant(pcx, pat, path, &Some(~[]), expected);\n       }\n-      ast::pat_enum(path, ref subpats) => {\n+      ast::pat_enum(ref path, ref subpats) => {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n       }\n-      ast::pat_struct(path, ref fields, etc) => {\n+      ast::pat_struct(ref path, ref fields, etc) => {\n         // Grab the class data that we care about.\n         let structure = structure_of(fcx, pat.span, expected);\n         let mut error_happened = false;"}, {"sha": "f595b2dfc6a07e4ea1b1d8914534705a938b04b4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -489,7 +489,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Add pattern bindings.\n         let visit_pat: @fn(@ast::pat, ((), visit::vt<()>)) = |p, (e, v)| {\n             match p.node {\n-              ast::pat_ident(_, path, _)\n+              ast::pat_ident(_, ref path, _)\n                   if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n                 assign(p.id, None);\n                 debug!(\"Pattern binding %s is assigned to %s\",\n@@ -2437,7 +2437,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n-      ast::expr_path(pth) => {\n+      ast::expr_path(ref pth) => {\n         let defn = lookup_def(fcx, pth.span, id);\n \n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n@@ -2775,7 +2775,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_ty(id, typ);\n         }\n       }\n-      ast::expr_struct(path, ref fields, base_expr) => {\n+      ast::expr_struct(ref path, ref fields, base_expr) => {\n         // Resolve the path.\n         match tcx.def_map.find(&id) {\n             Some(&ast::def_struct(type_def_id)) => {\n@@ -3286,7 +3286,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n pub fn instantiate_path(fcx: @mut FnCtxt,\n-                        pth: @ast::Path,\n+                        pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         span: span,\n                         node_id: ast::node_id) {"}, {"sha": "b642eff12a8db24e57f60b195bb492ba05638ac1", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -671,7 +671,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                     impl_m.span,\n                     fmt!(\"method `%s` is not a member of trait `%s`\",\n                          tcx.sess.str_of(impl_m.mty.ident),\n-                         path_to_str(a_trait_ty.path, tcx.sess.intr())));\n+                         path_to_str(&a_trait_ty.path, tcx.sess.intr())));\n             }\n         }\n     }\n@@ -966,7 +966,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n         ast::def_trait(trait_did) => {\n             let trait_ref =\n                 astconv::ast_path_to_trait_ref(\n-                    ccx, &rscope, trait_did, Some(self_ty), ast_trait_ref.path);\n+                    ccx, &rscope, trait_did, Some(self_ty), &ast_trait_ref.path);\n             ccx.tcx.trait_refs.insert(\n                 ast_trait_ref.ref_id, trait_ref);\n             return trait_ref;\n@@ -975,7 +975,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n             ccx.tcx.sess.span_fatal(\n                 ast_trait_ref.path.span,\n                 fmt!(\"%s is not a trait\",\n-                    path_to_str(ast_trait_ref.path,\n+                    path_to_str(&ast_trait_ref.path,\n                                 ccx.tcx.sess.intr())));\n         }\n     }"}, {"sha": "d053c203b91a592139bb04d574de58ce367bca51", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -255,10 +255,10 @@ pub enum pat_ {\n     // which it is. The resolver determines this, and\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n-    pat_ident(binding_mode, @Path, Option<@pat>),\n-    pat_enum(@Path, Option<~[@pat]>), /* \"none\" means a * pattern where\n+    pat_ident(binding_mode, Path, Option<@pat>),\n+    pat_enum(Path, Option<~[@pat]>), /* \"none\" means a * pattern where\n                                        * we don't bind the fields to names */\n-    pat_struct(@Path, ~[field_pat], bool),\n+    pat_struct(Path, ~[field_pat], bool),\n     pat_tup(~[@pat]),\n     pat_box(@pat),\n     pat_uniq(@pat),\n@@ -456,7 +456,7 @@ pub enum expr_ {\n     expr_assign_op(node_id, binop, @expr, @expr),\n     expr_field(@expr, ident, ~[@Ty]),\n     expr_index(node_id, @expr, @expr),\n-    expr_path(@Path),\n+    expr_path(Path),\n \n     /// The special identifier `self`.\n     expr_self,\n@@ -471,7 +471,7 @@ pub enum expr_ {\n     expr_mac(mac),\n \n     // A struct literal expression.\n-    expr_struct(@Path, ~[field], Option<@expr>),\n+    expr_struct(Path, ~[field], Option<@expr>),\n \n     // A vector literal constructed from one repeated element.\n     expr_repeat(@expr /* element */, @expr /* count */, mutability),\n@@ -583,7 +583,7 @@ pub type mac = spanned<mac_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum mac_ {\n-    mac_invoc_tt(@Path,~[token_tree]),   // new macro-invocation\n+    mac_invoc_tt(Path,~[token_tree]),   // new macro-invocation\n }\n \n pub type lit = spanned<lit_>;\n@@ -734,7 +734,7 @@ pub enum ty_ {\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n     ty_tup(~[@Ty]),\n-    ty_path(@Path, @Option<OptVec<TyParamBound>>, node_id), // for #7264; see above\n+    ty_path(Path, @Option<OptVec<TyParamBound>>, node_id), // for #7264; see above\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n@@ -890,13 +890,13 @@ pub enum view_path_ {\n     // or just\n     //\n     // foo::bar::baz  (with 'baz =' implicitly on the left)\n-    view_path_simple(ident, @Path, node_id),\n+    view_path_simple(ident, Path, node_id),\n \n     // foo::bar::*\n-    view_path_glob(@Path, node_id),\n+    view_path_glob(Path, node_id),\n \n     // foo::bar::{a,b,c}\n-    view_path_list(@Path, ~[path_list_ident], node_id)\n+    view_path_list(Path, ~[path_list_ident], node_id)\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n@@ -939,7 +939,7 @@ pub struct attribute_ {\n  */\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct trait_ref {\n-    path: @Path,\n+    path: Path,\n     ref_id: node_id,\n }\n "}, {"sha": "59020e9d18377a463b69eb97ac30f650f6cdbc8e", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -196,7 +196,7 @@ pub fn map_block(b: &blk, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n \n pub fn map_pat(pat: @pat, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     match pat.node {\n-        pat_ident(_, path, _) => {\n+        pat_ident(_, ref path, _) => {\n             // Note: this is at least *potentially* a pattern...\n             cx.map.insert(pat.id, node_local(ast_util::path_to_ident(path)));\n         }"}, {"sha": "35f9782f694fef6c7589aaebc979764d1325db53", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -27,7 +27,7 @@ pub fn path_name_i(idents: &[ident]) -> ~str {\n     idents.map(|i| token::interner_get(i.name)).connect(\"::\")\n }\n \n-pub fn path_to_ident(p: @Path) -> ident { copy *p.idents.last() }\n+pub fn path_to_ident(p: &Path) -> ident { copy *p.idents.last() }\n \n pub fn local_def(id: node_id) -> def_id {\n     ast::def_id { crate: local_crate, node: id }\n@@ -212,8 +212,8 @@ pub fn default_block(\n     }\n }\n \n-pub fn ident_to_path(s: span, i: ident) -> @Path {\n-    @ast::Path { span: s,\n+pub fn ident_to_path(s: span, i: ident) -> Path {\n+    ast::Path { span: s,\n                  global: false,\n                  idents: ~[i],\n                  rp: None,"}, {"sha": "5686887491615feb1ec1c2c263a3ad110d3d8dc8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -326,7 +326,7 @@ pub fn expr_to_ident(cx: @ExtCtxt,\n                      expr: @ast::expr,\n                      err_msg: &str) -> ast::ident {\n     match expr.node {\n-      ast::expr_path(p) => {\n+      ast::expr_path(ref p) => {\n         if p.types.len() > 0u || p.idents.len() != 1u {\n             cx.span_fatal(expr.span, err_msg);\n         }"}, {"sha": "c933caa16c4cc600d2f67d5930bad753cf17db11", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -32,21 +32,21 @@ mod syntax {\n \n pub trait AstBuilder {\n     // paths\n-    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n-    fn path_ident(&self, span: span, id: ast::ident) -> @ast::Path;\n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> ast::Path;\n+    fn path_ident(&self, span: span, id: ast::ident) -> ast::Path;\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> ast::Path;\n     fn path_all(&self, sp: span,\n                 global: bool,\n                 idents: ~[ast::ident],\n                 rp: Option<@ast::Lifetime>,\n                 types: ~[@ast::Ty])\n-        -> @ast::Path;\n+        -> ast::Path;\n \n     // types\n     fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt;\n \n     fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty;\n-    fn ty_path(&self, @ast::Path, @Option<OptVec<ast::TyParamBound>>) -> @ast::Ty;\n+    fn ty_path(&self, ast::Path, @Option<OptVec<ast::TyParamBound>>) -> @ast::Ty;\n     fn ty_ident(&self, span: span, idents: ast::ident) -> @ast::Ty;\n \n     fn ty_rptr(&self, span: span,\n@@ -68,8 +68,8 @@ pub trait AstBuilder {\n \n     fn typaram(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>) -> ast::TyParam;\n \n-    fn trait_ref(&self, path: @ast::Path) -> @ast::trait_ref;\n-    fn typarambound(&self, path: @ast::Path) -> ast::TyParamBound;\n+    fn trait_ref(&self, path: ast::Path) -> @ast::trait_ref;\n+    fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n     fn lifetime(&self, span: span, ident: ast::ident) -> ast::Lifetime;\n \n     // statements\n@@ -86,7 +86,7 @@ pub trait AstBuilder {\n \n     // expressions\n     fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n-    fn expr_path(&self, path: @ast::Path) -> @ast::expr;\n+    fn expr_path(&self, path: ast::Path) -> @ast::expr;\n     fn expr_ident(&self, span: span, id: ast::ident) -> @ast::expr;\n \n     fn expr_self(&self, span: span) -> @ast::expr;\n@@ -110,7 +110,7 @@ pub trait AstBuilder {\n     fn expr_blk(&self, b: ast::blk) -> @ast::expr;\n \n     fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::field;\n-    fn expr_struct(&self, span: span, path: @ast::Path, fields: ~[ast::field]) -> @ast::expr;\n+    fn expr_struct(&self, span: span, path: ast::Path, fields: ~[ast::field]) -> @ast::expr;\n     fn expr_struct_ident(&self, span: span, id: ast::ident, fields: ~[ast::field]) -> @ast::expr;\n \n     fn expr_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr;\n@@ -138,9 +138,9 @@ pub trait AstBuilder {\n                               span: span,\n                               ident: ast::ident,\n                               bm: ast::binding_mode) -> @ast::pat;\n-    fn pat_enum(&self, span: span, path: @ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n+    fn pat_enum(&self, span: span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n     fn pat_struct(&self, span: span,\n-                  path: @ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat;\n+                  path: ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat;\n \n     fn arm(&self, span: span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm;\n     fn arm_unreachable(&self, span: span) -> ast::arm;\n@@ -226,22 +226,22 @@ pub trait AstBuilder {\n }\n \n impl AstBuilder for @ExtCtxt {\n-    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> ast::Path {\n         self.path_all(span, false, strs, None, ~[])\n     }\n-    fn path_ident(&self, span: span, id: ast::ident) -> @ast::Path {\n+    fn path_ident(&self, span: span, id: ast::ident) -> ast::Path {\n         self.path(span, ~[id])\n     }\n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> ast::Path {\n         self.path_all(span, true, strs, None, ~[])\n     }\n     fn path_all(&self, sp: span,\n                 global: bool,\n                 idents: ~[ast::ident],\n                 rp: Option<@ast::Lifetime>,\n                 types: ~[@ast::Ty])\n-        -> @ast::Path {\n-        @ast::Path {\n+        -> ast::Path {\n+        ast::Path {\n             span: sp,\n             global: global,\n             idents: idents,\n@@ -265,7 +265,7 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn ty_path(&self, path: @ast::Path, bounds: @Option<OptVec<ast::TyParamBound>>)\n+    fn ty_path(&self, path: ast::Path, bounds: @Option<OptVec<ast::TyParamBound>>)\n               -> @ast::Ty {\n         self.ty(path.span,\n                 ast::ty_path(path, bounds, self.next_id()))\n@@ -358,14 +358,14 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn trait_ref(&self, path: @ast::Path) -> @ast::trait_ref {\n+    fn trait_ref(&self, path: ast::Path) -> @ast::trait_ref {\n         @ast::trait_ref {\n             path: path,\n             ref_id: self.next_id()\n         }\n     }\n \n-    fn typarambound(&self, path: @ast::Path) -> ast::TyParamBound {\n+    fn typarambound(&self, path: ast::Path) -> ast::TyParamBound {\n         ast::TraitTyParamBound(self.trait_ref(path))\n     }\n \n@@ -421,7 +421,7 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn expr_path(&self, path: @ast::Path) -> @ast::expr {\n+    fn expr_path(&self, path: ast::Path) -> @ast::expr {\n         self.expr(path.span, ast::expr_path(path))\n     }\n \n@@ -487,7 +487,7 @@ impl AstBuilder for @ExtCtxt {\n     fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::field {\n         respan(span, ast::field_ { ident: name, expr: e })\n     }\n-    fn expr_struct(&self, span: span, path: @ast::Path, fields: ~[ast::field]) -> @ast::expr {\n+    fn expr_struct(&self, span: span, path: ast::Path, fields: ~[ast::field]) -> @ast::expr {\n         self.expr(span, ast::expr_struct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: span,\n@@ -570,12 +570,12 @@ impl AstBuilder for @ExtCtxt {\n         let pat = ast::pat_ident(bm, path, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: span, path: @ast::Path, subpats: ~[@ast::pat]) -> @ast::pat {\n+    fn pat_enum(&self, span: span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat {\n         let pat = ast::pat_enum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n     fn pat_struct(&self, span: span,\n-                  path: @ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat {\n+                  path: ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat {\n         let pat = ast::pat_struct(path, field_pats, false);\n         self.pat(span, pat)\n     }"}, {"sha": "900668df117e3cb3ab963dac4817bb843574a61d", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -36,7 +36,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     let e = @ast::expr {\n         id: cx.next_id(),\n         node: ast::expr_path(\n-            @ast::Path {\n+            ast::Path {\n                  span: sp,\n                  global: false,\n                  idents: ~[res],"}, {"sha": "e397a41630455f2908d0a713591ec81d5de560b3", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -335,7 +335,7 @@ impl<'self> TraitDef<'self> {\n                     cx.typarambound(p.to_path(cx, span, type_ident, generics))\n                 });\n             // require the current trait\n-            bounds.push(cx.typarambound(trait_path));\n+            bounds.push(cx.typarambound(copy trait_path));\n \n             trait_generics.ty_params.push(cx.typaram(ty_param.ident, @bounds));\n         }\n@@ -890,7 +890,7 @@ fn summarise_struct(cx: @ExtCtxt, span: span,\n \n pub fn create_subpatterns(cx: @ExtCtxt,\n                           span: span,\n-                          field_paths: ~[@ast::Path],\n+                          field_paths: ~[ast::Path],\n                           mutbl: ast::mutability)\n                    -> ~[@ast::pat] {\n     do field_paths.map |&path| {\n@@ -941,7 +941,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n         };\n         let path = cx.path_ident(span,\n                                  cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n-        paths.push(path);\n+        paths.push(copy path);\n         ident_expr.push((opt_id, cx.expr_path(path)));\n     }\n \n@@ -987,7 +987,7 @@ fn create_enum_variant_pattern(cx: @ExtCtxt,\n                 let path = cx.path_ident(span,\n                                          cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n \n-                paths.push(path);\n+                paths.push(copy path);\n                 ident_expr.push((None, cx.expr_path(path)));\n             }\n "}, {"sha": "4dee2e2cdb898efda5779f9ed47c263bfd5fb0cd", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -70,7 +70,7 @@ impl<'self> Path<'self> {\n                    span: span,\n                    self_ty: ident,\n                    self_generics: &Generics)\n-                   -> @ast::Path {\n+                   -> ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n         let lt = mk_lifetime(cx, span, &self.lifetime);\n         let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n@@ -162,7 +162,7 @@ impl<'self> Ty<'self> {\n                    span: span,\n                    self_ty: ident,\n                    self_generics: &Generics)\n-                   -> @ast::Path {\n+                   -> ast::Path {\n         match *self {\n             Self => {\n                 let self_params = do self_generics.ty_params.map |ty_param| {"}, {"sha": "940bd5ef61c11bed2d5aa393eff19ef42246c3fb", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -40,7 +40,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n         expr_mac(ref mac) => {\n             match (*mac).node {\n                 // Token-tree macros:\n-                mac_invoc_tt(pth, ref tts) => {\n+                mac_invoc_tt(ref pth, ref tts) => {\n                     if (pth.idents.len() > 1u) {\n                         cx.span_fatal(\n                             pth.span,\n@@ -208,7 +208,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                        fld: @ast_fold)\n                     -> Option<@ast::item> {\n     let (pth, tts) = match it.node {\n-        item_mac(codemap::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n+        item_mac(codemap::spanned { node: mac_invoc_tt(ref pth, ref tts), _}) => {\n             (pth, copy *tts)\n         }\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n@@ -298,7 +298,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n     let (mac, pth, tts, semi) = match *s {\n         stmt_mac(ref mac, semi) => {\n             match mac.node {\n-                mac_invoc_tt(pth, ref tts) => {\n+                mac_invoc_tt(ref pth, ref tts) => {\n                     (copy *mac, pth, copy *tts, semi)\n                 }\n             }\n@@ -372,10 +372,10 @@ pub fn new_name_finder() -> @Visitor<@mut ~[ast::ident]> {\n                      (ident_accum, v): (@mut ~[ast::ident], visit::vt<@mut ~[ast::ident]>)| {\n             match *p {\n                 // we found a pat_ident!\n-                ast::pat{id:_, node: ast::pat_ident(_,path,ref inner), span:_} => {\n+                ast::pat{id:_, node: ast::pat_ident(_,ref path,ref inner), span:_} => {\n                     match path {\n                         // a path of length one:\n-                        @ast::Path{global: false,idents: [id], span:_,rp:_,types:_} =>\n+                        &ast::Path{global: false,idents: [id], span:_,rp:_,types:_} =>\n                         ident_accum.push(id),\n                         // I believe these must be enums...\n                         _ => ()"}, {"sha": "58838b0c40bd036191eca58c225b172f7323800a", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -25,39 +25,39 @@ mod syntax {\n     pub use parse;\n }\n \n-pub fn path(ids: ~[ident], span: span) -> @ast::Path {\n-    @ast::Path { span: span,\n+pub fn path(ids: ~[ident], span: span) -> ast::Path {\n+    ast::Path { span: span,\n                  global: false,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n-pub fn path_global(ids: ~[ident], span: span) -> @ast::Path {\n-    @ast::Path { span: span,\n+pub fn path_global(ids: ~[ident], span: span) -> ast::Path {\n+    ast::Path { span: span,\n                  global: true,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n pub trait append_types {\n-    fn add_ty(&self, ty: @ast::Ty) -> @ast::Path;\n-    fn add_tys(&self, tys: ~[@ast::Ty]) -> @ast::Path;\n+    fn add_ty(&self, ty: @ast::Ty) -> ast::Path;\n+    fn add_tys(&self, tys: ~[@ast::Ty]) -> ast::Path;\n }\n \n-impl append_types for @ast::Path {\n-    fn add_ty(&self, ty: @ast::Ty) -> @ast::Path {\n-        @ast::Path {\n+impl append_types for ast::Path {\n+    fn add_ty(&self, ty: @ast::Ty) -> ast::Path {\n+        ast::Path {\n             types: vec::append_one(copy self.types, ty),\n-            .. copy **self\n+            .. copy *self\n         }\n     }\n \n-    fn add_tys(&self, tys: ~[@ast::Ty]) -> @ast::Path {\n-        @ast::Path {\n+    fn add_tys(&self, tys: ~[@ast::Ty]) -> ast::Path {\n+        ast::Path {\n             types: vec::append(copy self.types, tys),\n-            .. copy **self\n+            .. copy *self\n         }\n     }\n }"}, {"sha": "e9710c9e114d5bb44b33f6d9df8f4998196e305e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -33,7 +33,7 @@ pub trait ast_fold {\n     fn fold_foreign_mod(@self, &foreign_mod) -> foreign_mod;\n     fn fold_variant(@self, &variant) -> variant;\n     fn fold_ident(@self, ident) -> ident;\n-    fn fold_path(@self, @Path) -> @Path;\n+    fn fold_path(@self, &Path) -> Path;\n     fn fold_local(@self, @local) -> @local;\n     fn map_exprs(@self, @fn(@expr) -> @expr, &[@expr]) -> ~[@expr];\n     fn new_id(@self, node_id) -> node_id;\n@@ -62,7 +62,7 @@ pub struct AstFoldFns {\n     fold_foreign_mod: @fn(&foreign_mod, @ast_fold) -> foreign_mod,\n     fold_variant: @fn(&variant_, span, @ast_fold) -> (variant_, span),\n     fold_ident: @fn(ident, @ast_fold) -> ident,\n-    fold_path: @fn(@Path, @ast_fold) -> Path,\n+    fold_path: @fn(&Path, @ast_fold) -> Path,\n     fold_local: @fn(&local_, span, @ast_fold) -> (local_, span),\n     map_exprs: @fn(@fn(@expr) -> @expr, &[@expr]) -> ~[@expr],\n     new_id: @fn(node_id) -> node_id,\n@@ -117,7 +117,7 @@ fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n fn fold_mac_(m: &mac, fld: @ast_fold) -> mac {\n     spanned {\n         node: match m.node {\n-            mac_invoc_tt(p,ref tts) =>\n+            mac_invoc_tt(ref p,ref tts) =>\n             mac_invoc_tt(fld.fold_path(p),\n                          fold_tts(*tts,fld))\n         },\n@@ -337,7 +337,7 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n \n fn fold_trait_ref(p: @trait_ref, fld: @ast_fold) -> @trait_ref {\n     @ast::trait_ref {\n-        path: fld.fold_path(p.path),\n+        path: fld.fold_path(&p.path),\n         ref_id: fld.new_id(p.ref_id),\n     }\n }\n@@ -419,21 +419,21 @@ fn noop_fold_arm(a: &arm, fld: @ast_fold) -> arm {\n pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n     match *p {\n         pat_wild => pat_wild,\n-        pat_ident(binding_mode, pth, ref sub) => {\n+        pat_ident(binding_mode, ref pth, ref sub) => {\n             pat_ident(\n                 binding_mode,\n                 fld.fold_path(pth),\n                 sub.map(|x| fld.fold_pat(*x))\n             )\n         }\n         pat_lit(e) => pat_lit(fld.fold_expr(e)),\n-        pat_enum(pth, ref pats) => {\n+        pat_enum(ref pth, ref pats) => {\n             pat_enum(\n                 fld.fold_path(pth),\n                 pats.map(|pats| pats.map(|x| fld.fold_pat(*x)))\n             )\n         }\n-        pat_struct(pth, ref fields, etc) => {\n+        pat_struct(ref pth, ref fields, etc) => {\n             let pth_ = fld.fold_path(pth);\n             let fs = do fields.map |f| {\n                 ast::field_pat {\n@@ -596,7 +596,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n                 fld.fold_expr(er)\n             )\n         }\n-        expr_path(pth) => expr_path(fld.fold_path(pth)),\n+        expr_path(ref pth) => expr_path(fld.fold_path(pth)),\n         expr_self => expr_self,\n         expr_break(ref opt_ident) => {\n             expr_break(opt_ident.map(|x| fld.fold_ident(*x)))\n@@ -621,7 +621,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n             })\n         }\n         expr_mac(ref mac) => expr_mac(fold_mac(mac)),\n-        expr_struct(path, ref fields, maybe_expr) => {\n+        expr_struct(ref path, ref fields, maybe_expr) => {\n             expr_struct(\n                 fld.fold_path(path),\n                 fields.map(|x| fold_field(*x)),\n@@ -682,7 +682,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n             })\n         }\n         ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(*ty))),\n-        ty_path(path, bounds, id) =>\n+        ty_path(ref path, bounds, id) =>\n             ty_path(fld.fold_path(path), @fold_opt_bounds(bounds, fld), fld.new_id(id)),\n         ty_fixed_length_vec(ref mt, e) => {\n             ty_fixed_length_vec(\n@@ -754,7 +754,7 @@ fn noop_fold_ident(i: ident, _fld: @ast_fold) -> ident {\n     /* FIXME (#2543) */ copy i\n }\n \n-fn noop_fold_path(p: @Path, fld: @ast_fold) -> Path {\n+fn noop_fold_path(p: &Path, fld: @ast_fold) -> Path {\n     ast::Path {\n         span: fld.new_span(p.span),\n         global: p.global,\n@@ -907,8 +907,8 @@ impl ast_fold for AstFoldFns {\n     fn fold_ident(@self, x: ident) -> ident {\n         (self.fold_ident)(x, self as @ast_fold)\n     }\n-    fn fold_path(@self, x: @Path) -> @Path {\n-        @(self.fold_path)(x, self as @ast_fold)\n+    fn fold_path(@self, x: &Path) -> Path {\n+        (self.fold_path)(x, self as @ast_fold)\n     }\n     fn fold_local(@self, x: @local) -> @local {\n         let (n, s) = (self.fold_local)(&x.node, x.span, self as @ast_fold);"}, {"sha": "634efbe165daab00bf9eaaa42848f074bd4235bd", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -366,7 +366,7 @@ mod test {\n     #[test] fn path_exprs_1 () {\n         assert_eq!(string_to_expr(@\"a\"),\n                    @ast::expr{id:1,\n-                              node:ast::expr_path(@ast::Path {span:sp(0,1),\n+                              node:ast::expr_path(ast::Path {span:sp(0,1),\n                                                               global:false,\n                                                               idents:~[str_to_ident(\"a\")],\n                                                               rp:None,\n@@ -378,7 +378,7 @@ mod test {\n         assert_eq!(string_to_expr(@\"::a::b\"),\n                    @ast::expr{id:1,\n                                node:ast::expr_path(\n-                                   @ast::Path {span:sp(0,6),\n+                                    ast::Path {span:sp(0,6),\n                                                global:true,\n                                                idents:strs_to_idents(~[\"a\",\"b\"]),\n                                                rp:None,\n@@ -428,7 +428,7 @@ mod test {\n                               node:ast::expr_ret(\n                                   Some(@ast::expr{id:1,\n                                                   node:ast::expr_path(\n-                                                      @ast::Path{span:sp(7,8),\n+                                                       ast::Path{span:sp(7,8),\n                                                                  global:false,\n                                                                  idents:~[str_to_ident(\"d\")],\n                                                                  rp:None,\n@@ -444,7 +444,7 @@ mod test {\n                        node: ast::stmt_expr(@ast::expr{\n                            id: 1,\n                            node: ast::expr_path(\n-                               @ast::Path{\n+                                ast::Path{\n                                    span:sp(0,1),\n                                    global:false,\n                                    idents:~[str_to_ident(\"b\")],\n@@ -465,7 +465,7 @@ mod test {\n         assert_eq!(parser.parse_pat(),\n                    @ast::pat{id:1, // fixme\n                              node: ast::pat_ident(ast::bind_infer,\n-                                                  @ast::Path{\n+                                                   ast::Path{\n                                                       span:sp(0,1),\n                                                       global:false,\n                                                       idents:~[str_to_ident(\"b\")],\n@@ -483,7 +483,7 @@ mod test {\n                    ast::arg{\n                        is_mutbl: false,\n                        ty: @ast::Ty{id:3, // fixme\n-                                    node: ast::ty_path(@ast::Path{\n+                                    node: ast::ty_path(ast::Path{\n                                         span:sp(4,4), // this is bizarre...\n                                         // check this in the original parser?\n                                         global:false,\n@@ -494,7 +494,7 @@ mod test {\n                                     span:sp(4,7)},\n                        pat: @ast::pat{id:1,\n                                       node: ast::pat_ident(ast::bind_infer,\n-                                                           @ast::Path{\n+                                                            ast::Path{\n                                                                span:sp(0,1),\n                                                                global:false,\n                                                                idents:~[str_to_ident(\"b\")],\n@@ -520,7 +520,7 @@ mod test {\n                                 inputs: ~[ast::arg{\n                                     is_mutbl: false,\n                                     ty: @ast::Ty{id:3, // fixme\n-                                                node: ast::ty_path(@ast::Path{\n+                                                node: ast::ty_path(ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n                                         idents:~[str_to_ident(\"int\")],\n@@ -531,7 +531,7 @@ mod test {\n                                     pat: @ast::pat{id:1, // fixme\n                                                    node: ast::pat_ident(\n                                                        ast::bind_infer,\n-                                                       @ast::Path{\n+                                                       ast::Path{\n                                                            span:sp(6,7),\n                                                            global:false,\n                                                            idents:~[str_to_ident(\"b\")],\n@@ -561,7 +561,7 @@ mod test {\n                                                 node: ast::stmt_semi(@ast::expr{\n                                                     id: 6,\n                                                     node: ast::expr_path(\n-                                                        @ast::Path{\n+                                                          ast::Path{\n                                                             span:sp(17,18),\n                                                             global:false,\n                                                             idents:~[str_to_ident(\"b\")],"}, {"sha": "00386f611b148798981f8cc88c038dd0b79504f2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -130,20 +130,28 @@ The important thing is to make sure that lookahead doesn't balk\n at INTERPOLATED tokens */\n macro_rules! maybe_whole_expr (\n     ($p:expr) => (\n-        match *($p).token {\n-            INTERPOLATED(token::nt_expr(e)) => {\n-                $p.bump();\n-                return e;\n-            }\n-            INTERPOLATED(token::nt_path(pt)) => {\n-                $p.bump();\n-                return $p.mk_expr(\n-                    ($p).span.lo,\n-                    ($p).span.hi,\n-                    expr_path(pt)\n-                );\n+        {\n+            // This horrible convolution is brought to you by\n+            // @mut, have a terrible day\n+            let ret = match *($p).token {\n+                INTERPOLATED(token::nt_expr(e)) => {\n+                    Some(e)\n+                }\n+                INTERPOLATED(token::nt_path(ref pt)) => {\n+                    Some($p.mk_expr(\n+                        ($p).span.lo,\n+                        ($p).span.hi,\n+                        expr_path(/* bad */ copy *pt)))\n+                }\n+                _ => None\n+            };\n+            match ret {\n+                Some(e) => {\n+                    $p.bump();\n+                    return e;\n+                }\n+                None => ()\n             }\n-            _ => ()\n         }\n     )\n )\n@@ -1218,18 +1226,18 @@ impl Parser {\n     }\n \n     // parse a path that doesn't have type parameters attached\n-    pub fn parse_path_without_tps(&self) -> @ast::Path {\n+    pub fn parse_path_without_tps(&self) -> ast::Path {\n         maybe_whole!(self, nt_path);\n         let (ids,is_global,sp) = self.parse_path();\n-        @ast::Path { span: sp,\n+        ast::Path { span: sp,\n                      global: is_global,\n                      idents: ids,\n                      rp: None,\n                      types: ~[] }\n     }\n \n     pub fn parse_bounded_path_with_tps(&self, colons: bool,\n-                                        before_tps: Option<&fn()>) -> @ast::Path {\n+                                        before_tps: Option<&fn()>) -> ast::Path {\n         debug!(\"parse_path_with_tps(colons=%b)\", colons);\n \n         maybe_whole!(self, nt_path);\n@@ -1288,22 +1296,22 @@ impl Parser {\n             }\n         };\n \n-        @ast::Path { span: mk_sp(lo, hi),\n+        ast::Path { span: mk_sp(lo, hi),\n                      rp: rp,\n                      types: tps,\n-                     .. copy *path }\n+                     .. path }\n     }\n \n     // parse a path optionally with type parameters. If 'colons'\n     // is true, then type parameters must be preceded by colons,\n     // as in a::t::<t1,t2>\n-    pub fn parse_path_with_tps(&self, colons: bool) -> @ast::Path {\n+    pub fn parse_path_with_tps(&self, colons: bool) -> ast::Path {\n         self.parse_bounded_path_with_tps(colons, None)\n     }\n \n     // Like the above, but can also parse kind bounds in the case of a\n     // path to be used as a type that might be a trait.\n-    pub fn parse_type_path(&self) -> (@ast::Path, Option<OptVec<TyParamBound>>) {\n+    pub fn parse_type_path(&self) -> (ast::Path, Option<OptVec<TyParamBound>>) {\n         let mut bounds = None;\n         let path = self.parse_bounded_path_with_tps(false, Some(|| {\n             // Note: this closure might not even get called in the case of a\n@@ -3557,9 +3565,9 @@ impl Parser {\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n-                ty_path(path, @None, node_id) => {\n+                ty_path(ref path, @None, node_id) => {\n                     Some(@trait_ref {\n-                        path: path,\n+                        path: /* bad */ copy *path,\n                         ref_id: node_id\n                     })\n                 }\n@@ -4558,7 +4566,7 @@ impl Parser {\n                 let id = self.parse_ident();\n                 path.push(id);\n             }\n-            let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+            let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                     global: false,\n                                     idents: path,\n                                     rp: None,\n@@ -4588,7 +4596,7 @@ impl Parser {\n                         seq_sep_trailing_allowed(token::COMMA),\n                         |p| p.parse_path_list_ident()\n                     );\n-                    let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+                    let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                             global: false,\n                                             idents: path,\n                                             rp: None,\n@@ -4600,7 +4608,7 @@ impl Parser {\n                   // foo::bar::*\n                   token::BINOP(token::STAR) => {\n                     self.bump();\n-                    let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+                    let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                             global: false,\n                                             idents: path,\n                                             rp: None,\n@@ -4616,7 +4624,7 @@ impl Parser {\n           _ => ()\n         }\n         let last = path[path.len() - 1u];\n-        let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+        let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                 global: false,\n                                 idents: path,\n                                 rp: None,"}, {"sha": "0264903076b9ca865fa5a665311d52c97be438e4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -106,7 +106,7 @@ pub enum nonterminal {\n     nt_expr(@ast::expr),\n     nt_ty(  @ast::Ty),\n     nt_ident(ast::ident, bool),\n-    nt_path(@ast::Path),\n+    nt_path( ast::Path),\n     nt_tt(  @ast::token_tree), //needs @ed to break a circularity\n     nt_matchers(~[ast::matcher])\n }"}, {"sha": "36e9ba4b08a28d3328257b183f0d046ff946a356", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -179,7 +179,7 @@ pub fn generics_to_str(generics: &ast::Generics,\n     to_str(generics, print_generics, intr)\n }\n \n-pub fn path_to_str(p: @ast::Path, intr: @ident_interner) -> ~str {\n+pub fn path_to_str(p: &ast::Path, intr: @ident_interner) -> ~str {\n     to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n@@ -419,7 +419,7 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n                       f.purity, f.onceness, &f.decl, None, &f.bounds,\n                       Some(&generics), None);\n       }\n-      ast::ty_path(path, bounds, _) => print_bounded_path(s, path, bounds),\n+      ast::ty_path(ref path, bounds, _) => print_bounded_path(s, path, bounds),\n       ast::ty_fixed_length_vec(ref mt, v) => {\n         word(s.s, \"[\");\n         match mt.mutbl {\n@@ -600,7 +600,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n                 if i != 0 {\n                     word_space(s, \"+\");\n                 }\n-                print_path(s, trait_.path, false);\n+                print_path(s, &trait_.path, false);\n             }\n         }\n         word(s.s, \" \");\n@@ -610,7 +610,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_mac(codemap::spanned { node: ast::mac_invoc_tt(pth, ref tts),\n+      ast::item_mac(codemap::spanned { node: ast::mac_invoc_tt(ref pth, ref tts),\n                                    _}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n@@ -627,7 +627,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n }\n \n fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n-    print_path(s, t.path, false);\n+    print_path(s, &t.path, false);\n }\n \n pub fn print_enum_def(s: @ps, enum_definition: &ast::enum_def,\n@@ -1005,7 +1005,7 @@ pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n \n pub fn print_mac(s: @ps, m: &ast::mac) {\n     match m.node {\n-      ast::mac_invoc_tt(pth, ref tts) => {\n+      ast::mac_invoc_tt(ref pth, ref tts) => {\n         print_path(s, pth, false);\n         word(s.s, \"!\");\n         popen(s);\n@@ -1134,7 +1134,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         end(s);\n       }\n \n-      ast::expr_struct(path, ref fields, wth) => {\n+      ast::expr_struct(ref path, ref fields, wth) => {\n         print_path(s, path, true);\n         word(s.s, \"{\");\n         commasep_cmnt(s, consistent, (*fields), print_field, get_span);\n@@ -1359,7 +1359,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_expr(s, index);\n         word(s.s, \"]\");\n       }\n-      ast::expr_path(path) => print_path(s, path, true),\n+      ast::expr_path(ref path) => print_path(s, path, true),\n       ast::expr_self => word(s.s, \"self\"),\n       ast::expr_break(opt_ident) => {\n         word(s.s, \"break\");\n@@ -1486,7 +1486,7 @@ pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n     print_expr(s, coll);\n }\n \n-fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n+fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n                opt_bounds: &Option<OptVec<ast::TyParamBound>>) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, \"::\"); }\n@@ -1518,11 +1518,11 @@ fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n     }\n }\n \n-pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n+pub fn print_path(s: @ps, path: &ast::Path, colons_before_params: bool) {\n     print_path_(s, path, colons_before_params, &None)\n }\n \n-pub fn print_bounded_path(s: @ps, path: @ast::Path,\n+pub fn print_bounded_path(s: @ps, path: &ast::Path,\n                           bounds: &Option<OptVec<ast::TyParamBound>>) {\n     print_path_(s, path, false, bounds)\n }\n@@ -1543,7 +1543,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n      is that it doesn't matter */\n     match pat.node {\n       ast::pat_wild => word(s.s, \"_\"),\n-      ast::pat_ident(binding_mode, path, sub) => {\n+      ast::pat_ident(binding_mode, ref path, sub) => {\n           if refutable {\n               match binding_mode {\n                   ast::bind_by_ref(mutbl) => {\n@@ -1562,7 +1562,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n               None => ()\n           }\n       }\n-      ast::pat_enum(path, ref args_) => {\n+      ast::pat_enum(ref path, ref args_) => {\n         print_path(s, path, true);\n         match *args_ {\n           None => word(s.s, \"(*)\"),\n@@ -1576,7 +1576,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n           }\n         }\n       }\n-      ast::pat_struct(path, ref fields, etc) => {\n+      ast::pat_struct(ref path, ref fields, etc) => {\n         print_path(s, path, true);\n         word(s.s, \"{\");\n         fn print_field(s: @ps, f: ast::field_pat, refutable: bool) {\n@@ -1815,7 +1815,7 @@ pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n \n pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n     match vp.node {\n-      ast::view_path_simple(ident, path, _) => {\n+      ast::view_path_simple(ident, ref path, _) => {\n         if path.idents[path.idents.len()-1u] != ident {\n             print_ident(s, ident);\n             space(s.s);\n@@ -1824,12 +1824,12 @@ pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n         print_path(s, path, false);\n       }\n \n-      ast::view_path_glob(path, _) => {\n+      ast::view_path_glob(ref path, _) => {\n         print_path(s, path, false);\n         word(s.s, \"::*\");\n       }\n \n-      ast::view_path_list(path, ref idents, _) => {\n+      ast::view_path_list(ref path, ref idents, _) => {\n         print_path(s, path, false);\n         word(s.s, \"::{\");\n         do commasep(s, inconsistent, (*idents)) |s, w| {\n@@ -1892,7 +1892,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n       ast::ty_infer => print_irrefutable_pat(s, input.pat),\n       _ => {\n         match input.pat.node {\n-            ast::pat_ident(_, path, _) if\n+            ast::pat_ident(_, ref path, _) if\n                 path.idents.len() == 1 &&\n                 path.idents[0] == parse::token::special_idents::invalid => {\n                 // Do nothing."}, {"sha": "1e615ccb777593fe6c6a64f65eafb495d2f8d856", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "patch": "@@ -139,7 +139,7 @@ pub fn visit_local<E: Copy>(loc: &local, (e, v): (E, vt<E>)) {\n }\n \n fn visit_trait_ref<E: Copy>(tref: &ast::trait_ref, (e, v): (E, vt<E>)) {\n-    visit_path(tref.path, (e, v));\n+    visit_path(&tref.path, (e, v));\n }\n \n pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n@@ -197,7 +197,7 @@ pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n             (v.visit_generics)(generics, (copy e, v));\n-            for traits.iter().advance |p| { visit_path(p.path, (copy e, v)); }\n+            for traits.iter().advance |p| { visit_path(&p.path, (copy e, v)); }\n             for methods.iter().advance |m| {\n                 (v.visit_trait_method)(m, (copy e, v));\n             }\n@@ -252,7 +252,7 @@ pub fn visit_ty<E: Copy>(t: &Ty, (e, v): (E, vt<E>)) {\n             for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n             (v.visit_ty)(f.decl.output, (e, v));\n         },\n-        ty_path(p, bounds, _) => {\n+        ty_path(ref p, bounds, _) => {\n             visit_path(p, (copy e, v));\n             do bounds.map |bounds| {\n                 visit_ty_param_bounds(bounds, (copy e, v));\n@@ -272,15 +272,15 @@ pub fn visit_path<E: Copy>(p: &Path, (e, v): (E, vt<E>)) {\n \n pub fn visit_pat<E: Copy>(p: &pat, (e, v): (E, vt<E>)) {\n     match p.node {\n-        pat_enum(path, ref children) => {\n+        pat_enum(ref path, ref children) => {\n             visit_path(path, (copy e, v));\n             for children.iter().advance |children| {\n                 for children.iter().advance |child| {\n                     (v.visit_pat)(*child, (copy e, v));\n                 }\n             }\n         }\n-        pat_struct(path, ref fields, _) => {\n+        pat_struct(ref path, ref fields, _) => {\n             visit_path(path, (copy e, v));\n             for fields.iter().advance |f| {\n                 (v.visit_pat)(f.pat, (copy e, v));\n@@ -294,7 +294,7 @@ pub fn visit_pat<E: Copy>(p: &pat, (e, v): (E, vt<E>)) {\n         pat_box(inner) | pat_uniq(inner) | pat_region(inner) => {\n             (v.visit_pat)(inner, (e, v))\n         },\n-        pat_ident(_, path, ref inner) => {\n+        pat_ident(_, ref path, ref inner) => {\n             visit_path(path, (copy e, v));\n             for inner.iter().advance |subpat| {\n                 (v.visit_pat)(*subpat, (copy e, v))\n@@ -458,7 +458,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n             (v.visit_expr)(element, (copy e, v));\n             (v.visit_expr)(count, (copy e, v));\n         }\n-        expr_struct(p, ref flds, base) => {\n+        expr_struct(ref p, ref flds, base) => {\n             visit_path(p, (copy e, v));\n             for flds.iter().advance |f| {\n                 (v.visit_expr)(f.node.expr, (copy e, v));\n@@ -534,7 +534,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n             (v.visit_expr)(a, (copy e, v));\n             (v.visit_expr)(b, (copy e, v));\n         }\n-        expr_path(p) => visit_path(p, (copy e, v)),\n+        expr_path(ref p) => visit_path(p, (copy e, v)),\n         expr_self => (),\n         expr_break(_) => (),\n         expr_again(_) => (),"}]}