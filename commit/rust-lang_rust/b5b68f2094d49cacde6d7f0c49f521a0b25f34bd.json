{"sha": "b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YjY4ZjIwOTRkNDljYWNkZTZkN2YwYzQ5ZjUyMWEwYjI1ZjM0YmQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-24T18:07:48Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-25T14:16:42Z"}, "message": "Add basic HIR and types for structs/enums", "tree": {"sha": "5439bb80896c211b3cadb2c037383243fe1fc140", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5439bb80896c211b3cadb2c037383243fe1fc140"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "html_url": "https://github.com/rust-lang/rust/commit/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fb426cb9eeefa69a53d7c8c3367f7c6b714b9b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb426cb9eeefa69a53d7c8c3367f7c6b714b9b8", "html_url": "https://github.com/rust-lang/rust/commit/5fb426cb9eeefa69a53d7c8c3367f7c6b714b9b8"}], "stats": {"total": 273, "additions": 244, "deletions": 29}, "files": [{"sha": "7043a0f4d099b54cdf13374785432c4bbdf08721", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "patch": "@@ -95,6 +95,8 @@ salsa::database_storage! {\n             fn submodules() for hir::db::SubmodulesQuery;\n             fn infer() for hir::db::InferQuery;\n             fn type_for_def() for hir::db::TypeForDefQuery;\n+            fn struct_data() for db::StructDataQuery;\n+            fn enum_data() for db::EnumDataQuery;\n         }\n     }\n }"}, {"sha": "a2d228593af7f132a52e88924fab6f5aab14c7e5", "filename": "crates/ra_hir/src/adt.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "patch": "@@ -0,0 +1,114 @@\n+use ra_syntax::{SmolStr, ast::{self, NameOwner}};\n+\n+use crate::{\n+    DefId, Cancelable,\n+    db::{HirDatabase},\n+    ty::{Ty},\n+};\n+\n+pub struct Struct {\n+    def_id: DefId,\n+}\n+\n+impl Struct {\n+    pub(crate) fn new(def_id: DefId) -> Self {\n+        Struct { def_id }\n+    }\n+\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<SmolStr> {\n+        Ok(db.struct_data(self.def_id)?.name.clone())\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct StructData {\n+    name: SmolStr,\n+    variant_data: VariantData,\n+}\n+\n+impl StructData {\n+    pub(crate) fn new(struct_def: ast::StructDef) -> StructData {\n+        let name = struct_def\n+            .name()\n+            .map(|n| n.text())\n+            .unwrap_or(SmolStr::new(\"[error]\"));\n+        let variant_data = VariantData::Unit; // TODO implement this\n+        StructData { name, variant_data }\n+    }\n+}\n+\n+pub struct Enum {\n+    def_id: DefId,\n+}\n+\n+impl Enum {\n+    pub(crate) fn new(def_id: DefId) -> Self {\n+        Enum { def_id }\n+    }\n+\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<SmolStr> {\n+        Ok(db.enum_data(self.def_id)?.name.clone())\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct EnumData {\n+    name: SmolStr,\n+    variants: Vec<(SmolStr, VariantData)>,\n+}\n+\n+impl EnumData {\n+    pub(crate) fn new(enum_def: ast::EnumDef) -> Self {\n+        let name = enum_def\n+            .name()\n+            .map(|n| n.text())\n+            .unwrap_or(SmolStr::new(\"[error]\"));\n+        let variants = Vec::new(); // TODO implement this\n+        EnumData { name, variants }\n+    }\n+}\n+\n+/// A single field of an enum variant or struct\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct StructField {\n+    name: SmolStr,\n+    ty: Ty,\n+}\n+\n+/// Fields of an enum variant or struct\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum VariantData {\n+    Struct(Vec<StructField>),\n+    Tuple(Vec<StructField>),\n+    Unit,\n+}\n+\n+impl VariantData {\n+    pub fn fields(&self) -> &[StructField] {\n+        match *self {\n+            VariantData::Struct(ref fields) | VariantData::Tuple(ref fields) => fields,\n+            _ => &[],\n+        }\n+    }\n+    pub fn is_struct(&self) -> bool {\n+        if let VariantData::Struct(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+    pub fn is_tuple(&self) -> bool {\n+        if let VariantData::Tuple(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+    pub fn is_unit(&self) -> bool {\n+        if let VariantData::Unit = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "113790ee9b7e65c51dc2132e20e2825e6391a2b3", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "patch": "@@ -15,6 +15,7 @@ use crate::{\n     module::{ModuleId, ModuleTree, ModuleSource,\n     nameres::{ItemMap, InputModuleItems}},\n     ty::{InferenceResult, Ty},\n+    adt::{StructData, EnumData},\n };\n \n salsa::query_group! {\n@@ -31,6 +32,16 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::fn_syntax;\n     }\n \n+    fn struct_data(def_id: DefId) -> Cancelable<Arc<StructData>> {\n+        type StructDataQuery;\n+        use fn query_definitions::struct_data;\n+    }\n+\n+    fn enum_data(def_id: DefId) -> Cancelable<Arc<EnumData>> {\n+        type EnumDataQuery;\n+        use fn query_definitions::enum_data;\n+    }\n+\n     fn infer(fn_id: FnId) -> Cancelable<Arc<InferenceResult>> {\n         type InferQuery;\n         use fn query_definitions::infer;"}, {"sha": "7e9824de9ca96b024d81440950efcf00e2f44373", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "patch": "@@ -25,6 +25,7 @@ pub mod source_binder;\n mod krate;\n mod module;\n mod function;\n+mod adt;\n mod ty;\n \n use std::ops::Index;\n@@ -42,6 +43,7 @@ pub use self::{\n     krate::Crate,\n     module::{Module, ModuleId, Problem, nameres::ItemMap, ModuleScope, Resolution},\n     function::{Function, FnScopes},\n+    adt::{Struct, Enum},\n };\n \n pub use self::function::FnSignatureInfo;\n@@ -56,6 +58,8 @@ ra_db::impl_numeric_id!(DefId);\n pub(crate) enum DefKind {\n     Module,\n     Function,\n+    Struct,\n+    Enum,\n     Item,\n }\n \n@@ -73,8 +77,8 @@ impl DefKind {\n             SyntaxKind::FN_DEF => Some(DefKind::Function),\n             SyntaxKind::MODULE => Some(DefKind::Module),\n             // These define items, but don't have their own DefKinds yet:\n-            SyntaxKind::STRUCT_DEF => Some(DefKind::Item),\n-            SyntaxKind::ENUM_DEF => Some(DefKind::Item),\n+            SyntaxKind::STRUCT_DEF => Some(DefKind::Struct),\n+            SyntaxKind::ENUM_DEF => Some(DefKind::Enum),\n             SyntaxKind::TRAIT_DEF => Some(DefKind::Item),\n             SyntaxKind::TYPE_DEF => Some(DefKind::Item),\n             SyntaxKind::CONST_DEF => Some(DefKind::Item),\n@@ -99,6 +103,8 @@ impl DefLoc {\n pub enum Def {\n     Module(Module),\n     Function(Function),\n+    Struct(Struct),\n+    Enum(Enum),\n     Item,\n }\n \n@@ -114,6 +120,14 @@ impl DefId {\n                 let function = Function::new(self);\n                 Def::Function(function)\n             }\n+            DefKind::Struct => {\n+                let struct_def = Struct::new(self);\n+                Def::Struct(struct_def)\n+            }\n+            DefKind::Enum => {\n+                let enum_def = Enum::new(self);\n+                Def::Enum(enum_def)\n+            }\n             DefKind::Item => Def::Item,\n         };\n         Ok(res)"}, {"sha": "ead2b8414b3ed084377f252c77282b967ade5d16", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "patch": "@@ -193,6 +193,8 @@ salsa::database_storage! {\n             fn submodules() for db::SubmodulesQuery;\n             fn infer() for db::InferQuery;\n             fn type_for_def() for db::TypeForDefQuery;\n+            fn struct_data() for db::StructDataQuery;\n+            fn enum_data() for db::EnumDataQuery;\n         }\n     }\n }"}, {"sha": "72440d1d6f3896cc6f632977f72b3c18fc7b9eaa", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "patch": "@@ -19,7 +19,8 @@ use crate::{\n         imp::Submodule,\n         nameres::{InputModuleItems, ItemMap, Resolver},\n     },\n-    ty::{self, InferenceResult, Ty}\n+    ty::{self, InferenceResult, Ty},\n+    adt::{StructData, EnumData},\n };\n \n /// Resolve `FnId` to the corresponding `SyntaxNode`\n@@ -45,6 +46,24 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<T\n     ty::type_for_def(db, def_id)\n }\n \n+pub(super) fn struct_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<StructData>> {\n+    let def_loc = def_id.loc(db);\n+    assert!(def_loc.kind == DefKind::Struct);\n+    let syntax = db.file_item(def_loc.source_item_id);\n+    let struct_def =\n+        ast::StructDef::cast(syntax.borrowed()).expect(\"struct def should point to StructDef node\");\n+    Ok(Arc::new(StructData::new(struct_def.borrowed())))\n+}\n+\n+pub(super) fn enum_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<EnumData>> {\n+    let def_loc = def_id.loc(db);\n+    assert!(def_loc.kind == DefKind::Enum);\n+    let syntax = db.file_item(def_loc.source_item_id);\n+    let enum_def =\n+        ast::EnumDef::cast(syntax.borrowed()).expect(\"enum def should point to EnumDef node\");\n+    Ok(Arc::new(EnumData::new(enum_def.borrowed())))\n+}\n+\n pub(super) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<SourceFileItems> {\n     let mut res = SourceFileItems::new(file_id);\n     let source_file = db.source_file(file_id);"}, {"sha": "f86b749ec19d2e66874fad6ce26f2c6a83bc3b34", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 46, "deletions": 26, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "patch": "@@ -17,7 +17,7 @@ use ra_syntax::{\n \n use crate::{Def, DefId, FnScopes, Module, Function, Path, db::HirDatabase};\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Ty {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n@@ -35,8 +35,15 @@ pub enum Ty {\n     /// A primitive floating-point type. For example, `f64`.\n     Float(primitive::FloatTy),\n \n-    // Structures, enumerations and unions.\n-    // Adt(AdtDef, Substs),\n+    /// Structures, enumerations and unions.\n+    Adt {\n+        /// The DefId of the struct/enum.\n+        def_id: DefId,\n+        /// The name, for displaying.\n+        name: SmolStr,\n+        // later we'll need generic substitutions here\n+    },\n+\n     /// The pointee of a string slice. Written as `str`.\n     Str,\n \n@@ -107,45 +114,48 @@ pub enum Ty {\n \n type TyRef = Arc<Ty>;\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FnSig {\n     input: Vec<Ty>,\n     output: Ty,\n }\n \n impl Ty {\n-    pub fn new(_db: &impl HirDatabase, node: ast::TypeRef) -> Cancelable<Self> {\n+    pub(crate) fn new(\n+        db: &impl HirDatabase,\n+        module: &Module,\n+        node: ast::TypeRef,\n+    ) -> Cancelable<Self> {\n         use ra_syntax::ast::TypeRef::*;\n         Ok(match node {\n             ParenType(_inner) => Ty::Unknown, // TODO\n             TupleType(_inner) => Ty::Unknown, // TODO\n             NeverType(..) => Ty::Never,\n             PathType(inner) => {\n-                let path = if let Some(p) = inner.path() {\n+                let path = if let Some(p) = inner.path().and_then(Path::from_ast) {\n                     p\n                 } else {\n                     return Ok(Ty::Unknown);\n                 };\n-                if path.qualifier().is_none() {\n-                    let name = path\n-                        .segment()\n-                        .and_then(|s| s.name_ref())\n-                        .map(|n| n.text())\n-                        .unwrap_or(SmolStr::new(\"\"));\n+                if path.is_ident() {\n+                    let name = &path.segments[0];\n                     if let Some(int_ty) = primitive::IntTy::from_string(&name) {\n-                        Ty::Int(int_ty)\n+                        return Ok(Ty::Int(int_ty));\n                     } else if let Some(uint_ty) = primitive::UintTy::from_string(&name) {\n-                        Ty::Uint(uint_ty)\n+                        return Ok(Ty::Uint(uint_ty));\n                     } else if let Some(float_ty) = primitive::FloatTy::from_string(&name) {\n-                        Ty::Float(float_ty)\n-                    } else {\n-                        // TODO\n-                        Ty::Unknown\n+                        return Ok(Ty::Float(float_ty));\n                     }\n-                } else {\n-                    // TODO\n-                    Ty::Unknown\n                 }\n+\n+                // Resolve in module (in type namespace)\n+                let resolved = if let Some(r) = module.resolve_path(db, path)? {\n+                    r\n+                } else {\n+                    return Ok(Ty::Unknown);\n+                };\n+                let ty = db.type_for_def(resolved)?;\n+                ty\n             }\n             PointerType(_inner) => Ty::Unknown,     // TODO\n             ArrayType(_inner) => Ty::Unknown,       // TODO\n@@ -189,13 +199,15 @@ impl fmt::Display for Ty {\n                 }\n                 write!(f, \") -> {}\", sig.output)\n             }\n+            Ty::Adt { name, .. } => write!(f, \"{}\", name),\n             Ty::Unknown => write!(f, \"[unknown]\"),\n         }\n     }\n }\n \n pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n     let syntax = f.syntax(db);\n+    let module = f.module(db)?;\n     let node = syntax.borrowed();\n     // TODO we ignore type parameters for now\n     let input = node\n@@ -204,7 +216,7 @@ pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n             pl.params()\n                 .map(|p| {\n                     p.type_ref()\n-                        .map(|t| Ty::new(db, t))\n+                        .map(|t| Ty::new(db, &module, t))\n                         .unwrap_or(Ok(Ty::Unknown))\n                 })\n                 .collect()\n@@ -213,7 +225,7 @@ pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n     let output = node\n         .ret_type()\n         .and_then(|rt| rt.type_ref())\n-        .map(|t| Ty::new(db, t))\n+        .map(|t| Ty::new(db, &module, t))\n         .unwrap_or(Ok(Ty::Unknown))?;\n     let sig = FnSig { input, output };\n     Ok(Ty::FnPtr(Arc::new(sig)))\n@@ -232,6 +244,14 @@ pub fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n             Ok(Ty::Unknown)\n         }\n         Def::Function(f) => type_for_fn(db, f),\n+        Def::Struct(s) => Ok(Ty::Adt {\n+            def_id,\n+            name: s.name(db)?,\n+        }),\n+        Def::Enum(e) => Ok(Ty::Adt {\n+            def_id,\n+            name: e.name(db)?,\n+        }),\n         Def::Item => {\n             log::debug!(\"trying to get type for item of unknown type {:?}\", def_id);\n             Ok(Ty::Unknown)\n@@ -492,7 +512,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 };\n                 let cast_ty = e\n                     .type_ref()\n-                    .map(|t| Ty::new(self.db, t))\n+                    .map(|t| Ty::new(self.db, &self.module, t))\n                     .unwrap_or(Ok(Ty::Unknown))?;\n                 // TODO do the coercion...\n                 cast_ty\n@@ -526,7 +546,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             match stmt {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let decl_ty = if let Some(type_ref) = stmt.type_ref() {\n-                        Ty::new(self.db, type_ref)?\n+                        Ty::new(self.db, &self.module, type_ref)?\n                     } else {\n                         Ty::Unknown\n                     };\n@@ -576,7 +596,7 @@ pub fn infer(db: &impl HirDatabase, function: Function) -> Cancelable<InferenceR\n                 continue;\n             };\n             if let Some(type_ref) = param.type_ref() {\n-                let ty = Ty::new(db, type_ref)?;\n+                let ty = Ty::new(db, &ctx.module, type_ref)?;\n                 ctx.type_of.insert(LocalSyntaxPtr::new(pat.syntax()), ty);\n             } else {\n                 // TODO self param"}, {"sha": "170eef1471b4a9256a297d105235d85ea6d81d1c", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "patch": "@@ -68,6 +68,29 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_struct() {\n+    check_inference(\n+        r#\"\n+struct A {\n+    b: B,\n+    c: C,\n+}\n+struct B;\n+struct C(usize);\n+\n+fn test() {\n+    let c = C(1);\n+    B;\n+    let a: A = A { b: B, c: C() };\n+    a.b;\n+    a.c;\n+}\n+\"#,\n+        \"0004_struct.txt\",\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.source_file(file_id);"}, {"sha": "70ad055ff308b782778a7e6891f7e63134eca836", "filename": "crates/ra_hir/src/ty/tests/data/0004_struct.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b5b68f2094d49cacde6d7f0c49f521a0b25f34bd/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt?ref=b5b68f2094d49cacde6d7f0c49f521a0b25f34bd", "patch": "@@ -0,0 +1,10 @@\n+[86; 90) 'C(1)': [unknown]\n+[72; 153) '{     ...a.c; }': ()\n+[86; 87) 'C': C\n+[107; 108) 'a': A\n+[114; 132) 'A { b:... C() }': [unknown]\n+[138; 141) 'a.b': [unknown]\n+[147; 150) 'a.c': [unknown]\n+[96; 97) 'B': B\n+[88; 89) '1': [unknown]\n+[82; 83) 'c': [unknown]"}]}