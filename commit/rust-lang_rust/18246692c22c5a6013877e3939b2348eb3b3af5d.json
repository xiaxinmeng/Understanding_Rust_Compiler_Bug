{"sha": "18246692c22c5a6013877e3939b2348eb3b3af5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MjQ2NjkyYzIyYzVhNjAxMzg3N2UzOTM5YjIzNDhlYjNiM2FmNWQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-04-13T20:40:55Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-04-13T20:40:55Z"}, "message": "Merge pull request #914 from kamalmarhubi/invalid-operation-result\n\nrustfmt: Make error handling more idiomatic", "tree": {"sha": "5e8b8a3d444767a5db29c9276714e73390c621db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e8b8a3d444767a5db29c9276714e73390c621db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18246692c22c5a6013877e3939b2348eb3b3af5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18246692c22c5a6013877e3939b2348eb3b3af5d", "html_url": "https://github.com/rust-lang/rust/commit/18246692c22c5a6013877e3939b2348eb3b3af5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18246692c22c5a6013877e3939b2348eb3b3af5d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58b022c56a51669e1e36b94eba864b8ca6d4c41b", "url": "https://api.github.com/repos/rust-lang/rust/commits/58b022c56a51669e1e36b94eba864b8ca6d4c41b", "html_url": "https://github.com/rust-lang/rust/commit/58b022c56a51669e1e36b94eba864b8ca6d4c41b"}, {"sha": "72427356eb6d99a26c6596742e96df5516a8adc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/72427356eb6d99a26c6596742e96df5516a8adc1", "html_url": "https://github.com/rust-lang/rust/commit/72427356eb6d99a26c6596742e96df5516a8adc1"}], "stats": {"total": 99, "additions": 44, "deletions": 55}, "files": [{"sha": "e2a2a4918480b9ded3483ef4753589218349cc69", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 44, "deletions": 55, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/18246692c22c5a6013877e3939b2348eb3b3af5d/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18246692c22c5a6013877e3939b2348eb3b3af5d/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=18246692c22c5a6013877e3939b2348eb3b3af5d", "patch": "@@ -20,14 +20,16 @@ extern crate getopts;\n use rustfmt::{run, Input};\n use rustfmt::config::{Config, WriteMode};\n \n-use std::env;\n+use std::{env, error};\n use std::fs::{self, File};\n use std::io::{self, ErrorKind, Read, Write};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n use getopts::{Matches, Options};\n \n+type FmtError = Box<error::Error + Send + Sync>;\n+type FmtResult<T> = std::result::Result<T, FmtError>;\n \n /// Rustfmt operations.\n enum Operation {\n@@ -42,10 +44,6 @@ enum Operation {\n     Version,\n     /// Print detailed configuration help.\n     ConfigHelp,\n-    /// Invalid program input.\n-    InvalidInput {\n-        reason: String,\n-    },\n     /// No file specified, read from stdin\n     Stdin {\n         input: String,\n@@ -55,7 +53,7 @@ enum Operation {\n \n /// Try to find a project file in the given directory and its parents. Returns the path of a the\n /// nearest project file if one exists, or `None` if no project file was found.\n-fn lookup_project_file(dir: &Path) -> io::Result<Option<PathBuf>> {\n+fn lookup_project_file(dir: &Path) -> FmtResult<Option<PathBuf>> {\n     let mut current = if dir.is_relative() {\n         try!(env::current_dir()).join(dir)\n     } else {\n@@ -67,19 +65,17 @@ fn lookup_project_file(dir: &Path) -> io::Result<Option<PathBuf>> {\n     loop {\n         let config_file = current.join(\"rustfmt.toml\");\n         match fs::metadata(&config_file) {\n-            Ok(md) => {\n-                // Properly handle unlikely situation of a directory named `rustfmt.toml`.\n-                if md.is_file() {\n-                    return Ok(Some(config_file));\n-                }\n-            }\n-            // If it's not found, we continue searching; otherwise something went wrong and we\n-            // return the error.\n+            // Only return if it's a file to handle the unlikely situation of a directory named\n+            // `rustfmt.toml`.\n+            Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n+            // Return the error if it's something other than `NotFound`; otherwise we didn't find\n+            // the project file yet, and continue searching.\n             Err(e) => {\n                 if e.kind() != ErrorKind::NotFound {\n-                    return Err(e);\n+                    return Err(FmtError::from(e));\n                 }\n             }\n+            _ => {}\n         }\n \n         // If the current directory has no parent, we're done searching.\n@@ -93,7 +89,7 @@ fn lookup_project_file(dir: &Path) -> io::Result<Option<PathBuf>> {\n ///\n /// Returns the `Config` to use, and the path of the project file if there was\n /// one.\n-fn resolve_config(dir: &Path) -> io::Result<(Config, Option<PathBuf>)> {\n+fn resolve_config(dir: &Path) -> FmtResult<(Config, Option<PathBuf>)> {\n     let path = try!(lookup_project_file(dir));\n     if path.is_none() {\n         return Ok((Config::default(), None));\n@@ -108,7 +104,7 @@ fn resolve_config(dir: &Path) -> io::Result<(Config, Option<PathBuf>)> {\n /// read the given config file path recursively if present else read the project file path\n fn match_cli_path_or_file(config_path: Option<PathBuf>,\n                           input_file: &Path)\n-                          -> io::Result<(Config, Option<PathBuf>)> {\n+                          -> FmtResult<(Config, Option<PathBuf>)> {\n \n     if let Some(config_file) = config_path {\n         let (toml, path) = try!(resolve_config(config_file.as_ref()));\n@@ -119,7 +115,7 @@ fn match_cli_path_or_file(config_path: Option<PathBuf>,\n     resolve_config(input_file)\n }\n \n-fn update_config(config: &mut Config, matches: &Matches) -> Result<(), String> {\n+fn update_config(config: &mut Config, matches: &Matches) -> FmtResult<()> {\n     config.verbose = matches.opt_present(\"verbose\");\n     config.skip_children = matches.opt_present(\"skip-children\");\n \n@@ -130,11 +126,14 @@ fn update_config(config: &mut Config, matches: &Matches) -> Result<(), String> {\n             config.write_mode = write_mode;\n             Ok(())\n         }\n-        Some(Err(_)) => Err(format!(\"Invalid write-mode: {}\", write_mode.expect(\"cannot happen\"))),\n+        Some(Err(_)) => {\n+            Err(FmtError::from(format!(\"Invalid write-mode: {}\",\n+                                       write_mode.expect(\"cannot happen\"))))\n+        }\n     }\n }\n \n-fn execute() -> i32 {\n+fn make_opts() -> Options {\n     let mut opts = Options::new();\n     opts.optflag(\"h\", \"help\", \"show this message\");\n     opts.optflag(\"V\", \"version\", \"show version information\");\n@@ -154,32 +153,21 @@ fn execute() -> i32 {\n                  found reverts to the input file path\",\n                 \"[Path for the configuration file]\");\n \n-    let matches = match opts.parse(env::args().skip(1)) {\n-        Ok(m) => m,\n-        Err(e) => {\n-            print_usage(&opts, &e.to_string());\n-            return 1;\n-        }\n-    };\n+    opts\n+}\n \n-    let operation = determine_operation(&matches);\n+fn execute(opts: &Options) -> FmtResult<()> {\n+    let matches = try!(opts.parse(env::args().skip(1)));\n \n-    match operation {\n-        Operation::InvalidInput { reason } => {\n-            print_usage(&opts, &reason);\n-            1\n-        }\n+    match try!(determine_operation(&matches)) {\n         Operation::Help => {\n             print_usage(&opts, \"\");\n-            0\n         }\n         Operation::Version => {\n             print_version();\n-            0\n         }\n         Operation::ConfigHelp => {\n             Config::print_docs();\n-            0\n         }\n         Operation::Stdin { input, config_path } => {\n             // try to read config from local directory\n@@ -190,7 +178,6 @@ fn execute() -> i32 {\n             config.write_mode = WriteMode::Plain;\n \n             run(Input::Text(input), &config);\n-            0\n         }\n         Operation::Format { files, config_path } => {\n             let mut config = Config::default();\n@@ -221,21 +208,26 @@ fn execute() -> i32 {\n                     config = config_tmp;\n                 }\n \n-                if let Err(e) = update_config(&mut config, &matches) {\n-                    print_usage(&opts, &e);\n-                    return 1;\n-                }\n+                try!(update_config(&mut config, &matches));\n                 run(Input::File(file), &config);\n             }\n-            0\n         }\n     }\n+    Ok(())\n }\n \n fn main() {\n     let _ = env_logger::init();\n-    let exit_code = execute();\n \n+    let opts = make_opts();\n+\n+    let exit_code = match execute(&opts) {\n+        Ok(..) => 0,\n+        Err(e) => {\n+            print_usage(&opts, &e.to_string());\n+            1\n+        }\n+    };\n     // Make sure standard output is flushed before we exit.\n     std::io::stdout().flush().unwrap();\n \n@@ -261,17 +253,17 @@ fn print_version() {\n              option_env!(\"CARGO_PKG_VERSION_PRE\").unwrap_or(\"\"));\n }\n \n-fn determine_operation(matches: &Matches) -> Operation {\n+fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n     if matches.opt_present(\"h\") {\n-        return Operation::Help;\n+        return Ok(Operation::Help);\n     }\n \n     if matches.opt_present(\"config-help\") {\n-        return Operation::ConfigHelp;\n+        return Ok(Operation::ConfigHelp);\n     }\n \n     if matches.opt_present(\"version\") {\n-        return Operation::Version;\n+        return Ok(Operation::Version);\n     }\n \n     // Read the config_path and convert to parent dir if a file is provided.\n@@ -288,21 +280,18 @@ fn determine_operation(matches: &Matches) -> Operation {\n     if matches.free.is_empty() {\n \n         let mut buffer = String::new();\n-        match io::stdin().read_to_string(&mut buffer) {\n-            Ok(..) => (),\n-            Err(e) => return Operation::InvalidInput { reason: e.to_string() },\n-        }\n+        try!(io::stdin().read_to_string(&mut buffer));\n \n-        return Operation::Stdin {\n+        return Ok(Operation::Stdin {\n             input: buffer,\n             config_path: config_path,\n-        };\n+        });\n     }\n \n     let files: Vec<_> = matches.free.iter().map(PathBuf::from).collect();\n \n-    Operation::Format {\n+    Ok(Operation::Format {\n         files: files,\n         config_path: config_path,\n-    }\n+    })\n }"}]}