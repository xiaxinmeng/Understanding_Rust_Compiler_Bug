{"sha": "e56d6a68dbda754b414abff41517f3fad9e547b0", "node_id": "C_kwDOAAsO6NoAKGU1NmQ2YTY4ZGJkYTc1NGI0MTRhYmZmNDE1MTdmM2ZhZDllNTQ3YjA", "commit": {"author": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-08-30T11:19:17Z"}, "committer": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-27T18:29:18Z"}, "message": "Move rustc_parse diagnostic structs to separate module", "tree": {"sha": "99aa2ec03c7f5b0eb7c7181c1197a2b6fc10ddd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99aa2ec03c7f5b0eb7c7181c1197a2b6fc10ddd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e56d6a68dbda754b414abff41517f3fad9e547b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e56d6a68dbda754b414abff41517f3fad9e547b0", "html_url": "https://github.com/rust-lang/rust/commit/e56d6a68dbda754b414abff41517f3fad9e547b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e56d6a68dbda754b414abff41517f3fad9e547b0/comments", "author": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ae7a30927704fd2b48d72b2119d4c0185542e56", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ae7a30927704fd2b48d72b2119d4c0185542e56", "html_url": "https://github.com/rust-lang/rust/commit/6ae7a30927704fd2b48d72b2119d4c0185542e56"}], "stats": {"total": 1630, "additions": 819, "deletions": 811}, "files": [{"sha": "dc7a39457a0c0083981006ed0c2b887a36ecadf2", "filename": "compiler/rustc_parse/src/errors.rs", "status": "added", "additions": 783, "deletions": 0, "changes": 783, "blob_url": "https://github.com/rust-lang/rust/blob/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=e56d6a68dbda754b414abff41517f3fad9e547b0", "patch": "@@ -0,0 +1,783 @@\n+use rustc_errors::Applicability;\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_session::errors::ExprParenthesesNeeded;\n+use rustc_span::symbol::Ident;\n+use rustc_span::{Span, Symbol};\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::maybe_report_ambiguous_plus)]\n+pub(crate) struct AmbiguousPlus {\n+    pub sum_ty: String,\n+    #[primary_span]\n+    #[suggestion(code = \"({sum_ty})\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::maybe_recover_from_bad_type_plus, code = \"E0178\")]\n+pub(crate) struct BadTypePlus {\n+    pub ty: String,\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: BadTypePlusSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum BadTypePlusSub {\n+    #[suggestion(\n+        parser::add_paren,\n+        code = \"{sum_with_parens}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    AddParen {\n+        sum_with_parens: String,\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(parser::forgot_paren)]\n+    ForgotParen {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(parser::expect_path)]\n+    ExpectPath {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::maybe_recover_from_bad_qpath_stage_2)]\n+pub(crate) struct BadQPathStage2 {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    pub ty: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::incorrect_semicolon)]\n+pub(crate) struct IncorrectSemicolon<'a> {\n+    #[primary_span]\n+    #[suggestion_short(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[help]\n+    pub opt_help: Option<()>,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::incorrect_use_of_await)]\n+pub(crate) struct IncorrectUseOfAwait {\n+    #[primary_span]\n+    #[suggestion(parser::parentheses_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::incorrect_use_of_await)]\n+pub(crate) struct IncorrectAwait {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(parser::postfix_suggestion, code = \"{expr}.await{question_mark}\")]\n+    pub sugg_span: (Span, Applicability),\n+    pub expr: String,\n+    pub question_mark: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::in_in_typo)]\n+pub(crate) struct InInTypo {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub sugg_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_variable_declaration)]\n+pub(crate) struct InvalidVariableDeclaration {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: InvalidVariableDeclarationSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum InvalidVariableDeclarationSub {\n+    #[suggestion(\n+        parser::switch_mut_let_order,\n+        applicability = \"maybe-incorrect\",\n+        code = \"let mut\"\n+    )]\n+    SwitchMutLetOrder(#[primary_span] Span),\n+    #[suggestion(\n+        parser::missing_let_before_mut,\n+        applicability = \"machine-applicable\",\n+        code = \"let mut\"\n+    )]\n+    MissingLet(#[primary_span] Span),\n+    #[suggestion(parser::use_let_not_auto, applicability = \"machine-applicable\", code = \"let\")]\n+    UseLetNotAuto(#[primary_span] Span),\n+    #[suggestion(parser::use_let_not_var, applicability = \"machine-applicable\", code = \"let\")]\n+    UseLetNotVar(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_comparison_operator)]\n+pub(crate) struct InvalidComparisonOperator {\n+    #[primary_span]\n+    pub span: Span,\n+    pub invalid: String,\n+    #[subdiagnostic]\n+    pub sub: InvalidComparisonOperatorSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum InvalidComparisonOperatorSub {\n+    #[suggestion_short(\n+        parser::use_instead,\n+        applicability = \"machine-applicable\",\n+        code = \"{correct}\"\n+    )]\n+    Correctable {\n+        #[primary_span]\n+        span: Span,\n+        invalid: String,\n+        correct: String,\n+    },\n+    #[label(parser::spaceship_operator_invalid)]\n+    Spaceship(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_logical_operator)]\n+#[note]\n+pub(crate) struct InvalidLogicalOperator {\n+    #[primary_span]\n+    pub span: Span,\n+    pub incorrect: String,\n+    #[subdiagnostic]\n+    pub sub: InvalidLogicalOperatorSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum InvalidLogicalOperatorSub {\n+    #[suggestion_short(\n+        parser::use_amp_amp_for_conjunction,\n+        applicability = \"machine-applicable\",\n+        code = \"&&\"\n+    )]\n+    Conjunction(#[primary_span] Span),\n+    #[suggestion_short(\n+        parser::use_pipe_pipe_for_disjunction,\n+        applicability = \"machine-applicable\",\n+        code = \"||\"\n+    )]\n+    Disjunction(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::tilde_is_not_unary_operator)]\n+pub(crate) struct TildeAsUnaryOperator(\n+    #[primary_span]\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"!\")]\n+    pub Span,\n+);\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unexpected_token_after_not)]\n+pub(crate) struct NotAsNegationOperator {\n+    #[primary_span]\n+    pub negated: Span,\n+    pub negated_desc: String,\n+    #[subdiagnostic]\n+    pub sub: NotAsNegationOperatorSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum NotAsNegationOperatorSub {\n+    #[suggestion_short(\n+        parser::unexpected_token_after_not_default,\n+        applicability = \"machine-applicable\",\n+        code = \"!\"\n+    )]\n+    SuggestNotDefault(#[primary_span] Span),\n+\n+    #[suggestion_short(\n+        parser::unexpected_token_after_not_bitwise,\n+        applicability = \"machine-applicable\",\n+        code = \"!\"\n+    )]\n+    SuggestNotBitwise(#[primary_span] Span),\n+\n+    #[suggestion_short(\n+        parser::unexpected_token_after_not_logical,\n+        applicability = \"machine-applicable\",\n+        code = \"!\"\n+    )]\n+    SuggestNotLogical(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::malformed_loop_label)]\n+pub(crate) struct MalformedLoopLabel {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"{correct_label}\")]\n+    pub span: Span,\n+    pub correct_label: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::lifetime_in_borrow_expression)]\n+pub(crate) struct LifetimeInBorrowExpression {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n+    #[label]\n+    pub lifetime_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::field_expression_with_generic)]\n+pub(crate) struct FieldExpressionWithGeneric(#[primary_span] pub Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::macro_invocation_with_qualified_path)]\n+pub(crate) struct MacroInvocationWithQualifiedPath(#[primary_span] pub Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unexpected_token_after_label)]\n+pub(crate) struct UnexpectedTokenAfterLabel {\n+    #[primary_span]\n+    #[label(parser::unexpected_token_after_label)]\n+    pub span: Span,\n+    #[suggestion_verbose(parser::suggestion_remove_label, code = \"\")]\n+    pub remove_label: Option<Span>,\n+    #[subdiagnostic]\n+    pub enclose_in_block: Option<UnexpectedTokenAfterLabelSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion_enclose_in_block, applicability = \"machine-applicable\")]\n+pub(crate) struct UnexpectedTokenAfterLabelSugg {\n+    #[suggestion_part(code = \"{{ \")]\n+    pub left: Span,\n+    #[suggestion_part(code = \" }}\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::require_colon_after_labeled_expression)]\n+#[note]\n+pub(crate) struct RequireColonAfterLabeledExpression {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub label: Span,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \": \")]\n+    pub label_end: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::do_catch_syntax_removed)]\n+#[note]\n+pub(crate) struct DoCatchSyntaxRemoved {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"try\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::float_literal_requires_integer_part)]\n+pub(crate) struct FloatLiteralRequiresIntegerPart {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"{correct}\")]\n+    pub span: Span,\n+    pub correct: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_int_literal_width)]\n+#[help]\n+pub(crate) struct InvalidIntLiteralWidth {\n+    #[primary_span]\n+    pub span: Span,\n+    pub width: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_num_literal_base_prefix)]\n+#[note]\n+pub(crate) struct InvalidNumLiteralBasePrefix {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"{fixed}\")]\n+    pub span: Span,\n+    pub fixed: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_num_literal_suffix)]\n+#[help]\n+pub(crate) struct InvalidNumLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_float_literal_width)]\n+#[help]\n+pub(crate) struct InvalidFloatLiteralWidth {\n+    #[primary_span]\n+    pub span: Span,\n+    pub width: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_float_literal_suffix)]\n+#[help]\n+pub(crate) struct InvalidFloatLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::int_literal_too_large)]\n+pub(crate) struct IntLiteralTooLarge {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::missing_semicolon_before_array)]\n+pub(crate) struct MissingSemicolonBeforeArray {\n+    #[primary_span]\n+    pub open_delim: Span,\n+    #[suggestion_verbose(applicability = \"maybe-incorrect\", code = \";\")]\n+    pub semicolon: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_block_macro_segment)]\n+pub(crate) struct InvalidBlockMacroSegment {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub context: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::if_expression_missing_then_block)]\n+pub(crate) struct IfExpressionMissingThenBlock {\n+    #[primary_span]\n+    pub if_span: Span,\n+    #[subdiagnostic]\n+    pub sub: IfExpressionMissingThenBlockSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum IfExpressionMissingThenBlockSub {\n+    #[help(parser::condition_possibly_unfinished)]\n+    UnfinishedCondition(#[primary_span] Span),\n+    #[help(parser::add_then_block)]\n+    AddThenBlock(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::if_expression_missing_condition)]\n+pub(crate) struct IfExpressionMissingCondition {\n+    #[primary_span]\n+    #[label(parser::condition_label)]\n+    pub if_span: Span,\n+    #[label(parser::block_label)]\n+    pub block_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::expected_expression_found_let)]\n+pub(crate) struct ExpectedExpressionFoundLet {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::expected_else_block)]\n+pub(crate) struct ExpectedElseBlock {\n+    #[primary_span]\n+    pub first_tok_span: Span,\n+    pub first_tok: String,\n+    #[label]\n+    pub else_span: Span,\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"if \")]\n+    pub condition_start: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::outer_attribute_not_allowed_on_if_else)]\n+pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n+    #[primary_span]\n+    pub last: Span,\n+\n+    #[label(parser::branch_label)]\n+    pub branch_span: Span,\n+\n+    #[label(parser::ctx_label)]\n+    pub ctx_span: Span,\n+    pub ctx: String,\n+\n+    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n+    pub attributes: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::missing_in_in_for_loop)]\n+pub(crate) struct MissingInInForLoop {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: MissingInInForLoopSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum MissingInInForLoopSub {\n+    // Has been misleading, at least in the past (closed Issue #48492), thus maybe-incorrect\n+    #[suggestion_short(parser::use_in_not_of, applicability = \"maybe-incorrect\", code = \"in\")]\n+    InNotOf(#[primary_span] Span),\n+    #[suggestion_short(parser::add_in, applicability = \"maybe-incorrect\", code = \" in \")]\n+    AddIn(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::missing_comma_after_match_arm)]\n+pub(crate) struct MissingCommaAfterMatchArm {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \",\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::catch_after_try)]\n+#[help]\n+pub(crate) struct CatchAfterTry {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::comma_after_base_struct)]\n+#[note]\n+pub(crate) struct CommaAfterBaseStruct {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n+    pub comma: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::eq_field_init)]\n+pub(crate) struct EqFieldInit {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(applicability = \"machine-applicable\", code = \":\")]\n+    pub eq: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::dotdotdot)]\n+pub(crate) struct DotDotDot {\n+    #[primary_span]\n+    #[suggestion(parser::suggest_exclusive_range, applicability = \"maybe-incorrect\", code = \"..\")]\n+    #[suggestion(parser::suggest_inclusive_range, applicability = \"maybe-incorrect\", code = \"..=\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::left_arrow_operator)]\n+pub(crate) struct LeftArrowOperator {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"< -\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::remove_let)]\n+pub(crate) struct RemoveLet {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::use_eq_instead)]\n+pub(crate) struct UseEqInstead {\n+    #[primary_span]\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"=\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::use_empty_block_not_semi)]\n+pub(crate) struct UseEmptyBlockNotSemi {\n+    #[primary_span]\n+    #[suggestion_hidden(applicability = \"machine-applicable\", code = \"{{}}\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::comparison_interpreted_as_generic)]\n+pub(crate) struct ComparisonInterpretedAsGeneric {\n+    #[primary_span]\n+    #[label(parser::label_comparison)]\n+    pub comparison: Span,\n+    pub typename: String,\n+    #[label(parser::label_args)]\n+    pub args: Span,\n+    #[subdiagnostic]\n+    pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::shift_interpreted_as_generic)]\n+pub(crate) struct ShiftInterpretedAsGeneric {\n+    #[primary_span]\n+    #[label(parser::label_comparison)]\n+    pub shift: Span,\n+    pub typename: String,\n+    #[label(parser::label_args)]\n+    pub args: Span,\n+    #[subdiagnostic]\n+    pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct ComparisonOrShiftInterpretedAsGenericSugg {\n+    #[suggestion_part(code = \"(\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::found_expr_would_be_stmt)]\n+pub(crate) struct FoundExprWouldBeStmt {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub token: String,\n+    #[subdiagnostic]\n+    pub suggestion: ExprParenthesesNeeded,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::leading_plus_not_supported)]\n+pub(crate) struct LeadingPlusNotSupported {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[suggestion_verbose(\n+        parser::suggestion_remove_plus,\n+        code = \"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    pub remove_plus: Option<Span>,\n+    #[subdiagnostic]\n+    pub add_parentheses: Option<ExprParenthesesNeeded>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::parentheses_with_struct_fields)]\n+pub(crate) struct ParenthesesWithStructFields {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: String,\n+    #[subdiagnostic]\n+    pub braces_for_struct: BracesForStructLiteral,\n+    #[subdiagnostic]\n+    pub no_fields_for_fn: NoFieldsForFnCall,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion_braces_for_struct, applicability = \"maybe-incorrect\")]\n+pub(crate) struct BracesForStructLiteral {\n+    #[suggestion_part(code = \" {{ \")]\n+    pub first: Span,\n+    #[suggestion_part(code = \" }}\")]\n+    pub second: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion_no_fields_for_fn, applicability = \"maybe-incorrect\")]\n+pub(crate) struct NoFieldsForFnCall {\n+    #[suggestion_part(code = \"\")]\n+    pub fields: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::labeled_loop_in_break)]\n+pub(crate) struct LabeledLoopInBreak {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: LabeledLoopInBreakSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct LabeledLoopInBreakSub {\n+    #[suggestion_part(code = \"(\")]\n+    pub first: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub second: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::array_brackets_instead_of_braces)]\n+pub(crate) struct ArrayBracketsInsteadOfSpaces {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: ArrayBracketsInsteadOfSpacesSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"maybe-incorrect\")]\n+pub(crate) struct ArrayBracketsInsteadOfSpacesSugg {\n+    #[suggestion_part(code = \"[\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \"]\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::match_arm_body_without_braces)]\n+pub(crate) struct MatchArmBodyWithoutBraces {\n+    #[primary_span]\n+    #[label(parser::label_statements)]\n+    pub statements: Span,\n+    #[label(parser::label_arrow)]\n+    pub arrow: Span,\n+    pub num_statements: usize,\n+    #[subdiagnostic]\n+    pub sub: MatchArmBodyWithoutBracesSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum MatchArmBodyWithoutBracesSugg {\n+    #[multipart_suggestion(parser::suggestion_add_braces, applicability = \"machine-applicable\")]\n+    AddBraces {\n+        #[suggestion_part(code = \"{{ \")]\n+        left: Span,\n+        #[suggestion_part(code = \" }}\")]\n+        right: Span,\n+    },\n+    #[suggestion(\n+        parser::suggestion_use_comma_not_semicolon,\n+        code = \",\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    UseComma {\n+        #[primary_span]\n+        semicolon: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::struct_literal_not_allowed_here)]\n+pub(crate) struct StructLiteralNotAllowedHere {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: StructLiteralNotAllowedHereSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct StructLiteralNotAllowedHereSugg {\n+    #[suggestion_part(code = \"(\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_interpolated_expression)]\n+pub(crate) struct InvalidInterpolatedExpression {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::hexadecimal_float_literal_not_supported)]\n+pub(crate) struct HexadecimalFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser::not_supported)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::octal_float_literal_not_supported)]\n+pub(crate) struct OctalFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser::not_supported)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::binary_float_literal_not_supported)]\n+pub(crate) struct BinaryFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser::not_supported)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_literal_suffix)]\n+pub(crate) struct InvalidLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    // FIXME(#100717)\n+    pub kind: String,\n+    pub suffix: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_literal_suffix_on_tuple_index)]\n+pub(crate) struct InvalidLiteralSuffixOnTupleIndex {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: Symbol,\n+    #[help(parser::tuple_exception_line_1)]\n+    #[help(parser::tuple_exception_line_2)]\n+    #[help(parser::tuple_exception_line_3)]\n+    pub exception: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::non_string_abi_literal)]\n+pub(crate) struct NonStringAbiLiteral {\n+    #[primary_span]\n+    #[suggestion(code = \"\\\"C\\\"\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::mismatched_closing_delimiter)]\n+pub(crate) struct MismatchedClosingDelimiter {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    pub delimiter: String,\n+    #[label(parser::label_unmatched)]\n+    pub unmatched: Span,\n+    #[label(parser::label_opening_candidate)]\n+    pub opening_candidate: Option<Span>,\n+    #[label(parser::label_unclosed)]\n+    pub unclosed: Option<Span>,\n+}"}, {"sha": "0bdfe10359c0bea9d36b670aaf77f022c9bd89cc", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=e56d6a68dbda754b414abff41517f3fad9e547b0", "patch": "@@ -32,6 +32,8 @@ use parser::{emit_unclosed_delims, make_unclosed_delims_error, Parser};\n pub mod lexer;\n pub mod validate_attr;\n \n+mod errors;\n+\n // A bunch of utility functions of the form `parse_<thing>_from_<source>`\n // where <thing> includes crate, expr, item, stmt, tts, and one that\n // uses a HOF to parse anything, and <source> includes file and"}, {"sha": "0fdde2917575825687af3ad4302152e1f2843d23", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 781, "changes": 786, "blob_url": "https://github.com/rust-lang/rust/blob/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=e56d6a68dbda754b414abff41517f3fad9e547b0", "patch": "@@ -3,6 +3,10 @@ use super::{\n     BlockMode, CommaRecoveryMode, Parser, PathStyle, Restrictions, SemiColonMode, SeqSep,\n     TokenExpectType, TokenType,\n };\n+use crate::errors::{\n+    AmbiguousPlus, BadQPathStage2, BadTypePlus, BadTypePlusSub, InInTypo, IncorrectAwait,\n+    IncorrectSemicolon, IncorrectUseOfAwait, UseEqInstead,\n+};\n \n use crate::lexer::UnmatchedBrace;\n use rustc_ast as ast;\n@@ -20,11 +24,9 @@ use rustc_errors::{\n     fluent, Applicability, DiagnosticBuilder, DiagnosticMessage, Handler, MultiSpan, PResult,\n };\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed};\n-use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{Span, SpanSnippetError, Symbol, DUMMY_SP};\n+use rustc_span::{Span, SpanSnippetError, DUMMY_SP};\n use std::ops::{Deref, DerefMut};\n \n use std::mem::take;\n@@ -243,784 +245,6 @@ impl MultiSugg {\n     }\n }\n \n-#[derive(Diagnostic)]\n-#[diag(parser::maybe_report_ambiguous_plus)]\n-struct AmbiguousPlus {\n-    pub sum_ty: String,\n-    #[primary_span]\n-    #[suggestion(code = \"({sum_ty})\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::maybe_recover_from_bad_type_plus, code = \"E0178\")]\n-struct BadTypePlus {\n-    pub ty: String,\n-    #[primary_span]\n-    pub span: Span,\n-    #[subdiagnostic]\n-    pub sub: BadTypePlusSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub enum BadTypePlusSub {\n-    #[suggestion(\n-        parser::add_paren,\n-        code = \"{sum_with_parens}\",\n-        applicability = \"machine-applicable\"\n-    )]\n-    AddParen {\n-        sum_with_parens: String,\n-        #[primary_span]\n-        span: Span,\n-    },\n-    #[label(parser::forgot_paren)]\n-    ForgotParen {\n-        #[primary_span]\n-        span: Span,\n-    },\n-    #[label(parser::expect_path)]\n-    ExpectPath {\n-        #[primary_span]\n-        span: Span,\n-    },\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::maybe_recover_from_bad_qpath_stage_2)]\n-struct BadQPathStage2 {\n-    #[primary_span]\n-    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n-    span: Span,\n-    ty: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::incorrect_semicolon)]\n-struct IncorrectSemicolon<'a> {\n-    #[primary_span]\n-    #[suggestion_short(code = \"\", applicability = \"machine-applicable\")]\n-    span: Span,\n-    #[help]\n-    opt_help: Option<()>,\n-    name: &'a str,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::incorrect_use_of_await)]\n-struct IncorrectUseOfAwait {\n-    #[primary_span]\n-    #[suggestion(parser::parentheses_suggestion, code = \"\", applicability = \"machine-applicable\")]\n-    span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::incorrect_use_of_await)]\n-struct IncorrectAwait {\n-    #[primary_span]\n-    span: Span,\n-    #[suggestion(parser::postfix_suggestion, code = \"{expr}.await{question_mark}\")]\n-    sugg_span: (Span, Applicability),\n-    expr: String,\n-    question_mark: &'static str,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::in_in_typo)]\n-struct InInTypo {\n-    #[primary_span]\n-    span: Span,\n-    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n-    sugg_span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_variable_declaration)]\n-pub struct InvalidVariableDeclaration {\n-    #[primary_span]\n-    pub span: Span,\n-    #[subdiagnostic]\n-    pub sub: InvalidVariableDeclarationSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub enum InvalidVariableDeclarationSub {\n-    #[suggestion(\n-        parser::switch_mut_let_order,\n-        applicability = \"maybe-incorrect\",\n-        code = \"let mut\"\n-    )]\n-    SwitchMutLetOrder(#[primary_span] Span),\n-    #[suggestion(\n-        parser::missing_let_before_mut,\n-        applicability = \"machine-applicable\",\n-        code = \"let mut\"\n-    )]\n-    MissingLet(#[primary_span] Span),\n-    #[suggestion(parser::use_let_not_auto, applicability = \"machine-applicable\", code = \"let\")]\n-    UseLetNotAuto(#[primary_span] Span),\n-    #[suggestion(parser::use_let_not_var, applicability = \"machine-applicable\", code = \"let\")]\n-    UseLetNotVar(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_comparison_operator)]\n-pub(crate) struct InvalidComparisonOperator {\n-    #[primary_span]\n-    pub span: Span,\n-    pub invalid: String,\n-    #[subdiagnostic]\n-    pub sub: InvalidComparisonOperatorSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub(crate) enum InvalidComparisonOperatorSub {\n-    #[suggestion_short(\n-        parser::use_instead,\n-        applicability = \"machine-applicable\",\n-        code = \"{correct}\"\n-    )]\n-    Correctable {\n-        #[primary_span]\n-        span: Span,\n-        invalid: String,\n-        correct: String,\n-    },\n-    #[label(parser::spaceship_operator_invalid)]\n-    Spaceship(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_logical_operator)]\n-#[note]\n-pub(crate) struct InvalidLogicalOperator {\n-    #[primary_span]\n-    pub span: Span,\n-    pub incorrect: String,\n-    #[subdiagnostic]\n-    pub sub: InvalidLogicalOperatorSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub(crate) enum InvalidLogicalOperatorSub {\n-    #[suggestion_short(\n-        parser::use_amp_amp_for_conjunction,\n-        applicability = \"machine-applicable\",\n-        code = \"&&\"\n-    )]\n-    Conjunction(#[primary_span] Span),\n-    #[suggestion_short(\n-        parser::use_pipe_pipe_for_disjunction,\n-        applicability = \"machine-applicable\",\n-        code = \"||\"\n-    )]\n-    Disjunction(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::tilde_is_not_unary_operator)]\n-pub(crate) struct TildeAsUnaryOperator(\n-    #[primary_span]\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"!\")]\n-    pub Span,\n-);\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::unexpected_token_after_not)]\n-pub(crate) struct NotAsNegationOperator {\n-    #[primary_span]\n-    pub negated: Span,\n-    pub negated_desc: String,\n-    #[subdiagnostic]\n-    pub sub: NotAsNegationOperatorSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub enum NotAsNegationOperatorSub {\n-    #[suggestion_short(\n-        parser::unexpected_token_after_not_default,\n-        applicability = \"machine-applicable\",\n-        code = \"!\"\n-    )]\n-    SuggestNotDefault(#[primary_span] Span),\n-\n-    #[suggestion_short(\n-        parser::unexpected_token_after_not_bitwise,\n-        applicability = \"machine-applicable\",\n-        code = \"!\"\n-    )]\n-    SuggestNotBitwise(#[primary_span] Span),\n-\n-    #[suggestion_short(\n-        parser::unexpected_token_after_not_logical,\n-        applicability = \"machine-applicable\",\n-        code = \"!\"\n-    )]\n-    SuggestNotLogical(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::malformed_loop_label)]\n-pub(crate) struct MalformedLoopLabel {\n-    #[primary_span]\n-    #[suggestion(applicability = \"machine-applicable\", code = \"{correct_label}\")]\n-    pub span: Span,\n-    pub correct_label: Ident,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::lifetime_in_borrow_expression)]\n-pub(crate) struct LifetimeInBorrowExpression {\n-    #[primary_span]\n-    pub span: Span,\n-    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n-    #[label]\n-    pub lifetime_span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::field_expression_with_generic)]\n-pub(crate) struct FieldExpressionWithGeneric(#[primary_span] pub Span);\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::macro_invocation_with_qualified_path)]\n-pub(crate) struct MacroInvocationWithQualifiedPath(#[primary_span] pub Span);\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::unexpected_token_after_label)]\n-pub(crate) struct UnexpectedTokenAfterLabel {\n-    #[primary_span]\n-    #[label(parser::unexpected_token_after_label)]\n-    pub span: Span,\n-    #[suggestion_verbose(parser::suggestion_remove_label, code = \"\")]\n-    pub remove_label: Option<Span>,\n-    #[subdiagnostic]\n-    pub enclose_in_block: Option<UnexpectedTokenAfterLabelSugg>,\n-}\n-\n-#[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion_enclose_in_block, applicability = \"machine-applicable\")]\n-pub(crate) struct UnexpectedTokenAfterLabelSugg {\n-    #[suggestion_part(code = \"{{ \")]\n-    pub left: Span,\n-    #[suggestion_part(code = \" }}\")]\n-    pub right: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::require_colon_after_labeled_expression)]\n-#[note]\n-pub(crate) struct RequireColonAfterLabeledExpression {\n-    #[primary_span]\n-    pub span: Span,\n-    #[label]\n-    pub label: Span,\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \": \")]\n-    pub label_end: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::do_catch_syntax_removed)]\n-#[note]\n-pub(crate) struct DoCatchSyntaxRemoved {\n-    #[primary_span]\n-    #[suggestion(applicability = \"machine-applicable\", code = \"try\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::float_literal_requires_integer_part)]\n-pub(crate) struct FloatLiteralRequiresIntegerPart {\n-    #[primary_span]\n-    #[suggestion(applicability = \"machine-applicable\", code = \"{correct}\")]\n-    pub span: Span,\n-    pub correct: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_int_literal_width)]\n-#[help]\n-pub(crate) struct InvalidIntLiteralWidth {\n-    #[primary_span]\n-    pub span: Span,\n-    pub width: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_num_literal_base_prefix)]\n-#[note]\n-pub(crate) struct InvalidNumLiteralBasePrefix {\n-    #[primary_span]\n-    #[suggestion(applicability = \"maybe-incorrect\", code = \"{fixed}\")]\n-    pub span: Span,\n-    pub fixed: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_num_literal_suffix)]\n-#[help]\n-pub(crate) struct InvalidNumLiteralSuffix {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    pub suffix: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_float_literal_width)]\n-#[help]\n-pub(crate) struct InvalidFloatLiteralWidth {\n-    #[primary_span]\n-    pub span: Span,\n-    pub width: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_float_literal_suffix)]\n-#[help]\n-pub(crate) struct InvalidFloatLiteralSuffix {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    pub suffix: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::int_literal_too_large)]\n-pub(crate) struct IntLiteralTooLarge {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::missing_semicolon_before_array)]\n-pub(crate) struct MissingSemicolonBeforeArray {\n-    #[primary_span]\n-    pub open_delim: Span,\n-    #[suggestion_verbose(applicability = \"maybe-incorrect\", code = \";\")]\n-    pub semicolon: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_block_macro_segment)]\n-pub(crate) struct InvalidBlockMacroSegment {\n-    #[primary_span]\n-    pub span: Span,\n-    #[label]\n-    pub context: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::if_expression_missing_then_block)]\n-pub(crate) struct IfExpressionMissingThenBlock {\n-    #[primary_span]\n-    pub if_span: Span,\n-    #[subdiagnostic]\n-    pub sub: IfExpressionMissingThenBlockSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub(crate) enum IfExpressionMissingThenBlockSub {\n-    #[help(parser::condition_possibly_unfinished)]\n-    UnfinishedCondition(#[primary_span] Span),\n-    #[help(parser::add_then_block)]\n-    AddThenBlock(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::if_expression_missing_condition)]\n-pub(crate) struct IfExpressionMissingCondition {\n-    #[primary_span]\n-    #[label(parser::condition_label)]\n-    pub if_span: Span,\n-    #[label(parser::block_label)]\n-    pub block_span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::expected_expression_found_let)]\n-pub(crate) struct ExpectedExpressionFoundLet {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::expected_else_block)]\n-pub(crate) struct ExpectedElseBlock {\n-    #[primary_span]\n-    pub first_tok_span: Span,\n-    pub first_tok: String,\n-    #[label]\n-    pub else_span: Span,\n-    #[suggestion(applicability = \"maybe-incorrect\", code = \"if \")]\n-    pub condition_start: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::outer_attribute_not_allowed_on_if_else)]\n-pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n-    #[primary_span]\n-    pub last: Span,\n-\n-    #[label(parser::branch_label)]\n-    pub branch_span: Span,\n-\n-    #[label(parser::ctx_label)]\n-    pub ctx_span: Span,\n-    pub ctx: String,\n-\n-    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n-    pub attributes: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::missing_in_in_for_loop)]\n-pub(crate) struct MissingInInForLoop {\n-    #[primary_span]\n-    pub span: Span,\n-    #[subdiagnostic]\n-    pub sub: MissingInInForLoopSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub(crate) enum MissingInInForLoopSub {\n-    // Has been misleading, at least in the past (closed Issue #48492), thus maybe-incorrect\n-    #[suggestion_short(parser::use_in_not_of, applicability = \"maybe-incorrect\", code = \"in\")]\n-    InNotOf(#[primary_span] Span),\n-    #[suggestion_short(parser::add_in, applicability = \"maybe-incorrect\", code = \" in \")]\n-    AddIn(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::missing_comma_after_match_arm)]\n-pub(crate) struct MissingCommaAfterMatchArm {\n-    #[primary_span]\n-    #[suggestion(applicability = \"machine-applicable\", code = \",\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::catch_after_try)]\n-#[help]\n-pub(crate) struct CatchAfterTry {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::comma_after_base_struct)]\n-#[note]\n-pub(crate) struct CommaAfterBaseStruct {\n-    #[primary_span]\n-    pub span: Span,\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n-    pub comma: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::eq_field_init)]\n-pub(crate) struct EqFieldInit {\n-    #[primary_span]\n-    pub span: Span,\n-    #[suggestion(applicability = \"machine-applicable\", code = \":\")]\n-    pub eq: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::dotdotdot)]\n-pub(crate) struct DotDotDot {\n-    #[primary_span]\n-    #[suggestion(parser::suggest_exclusive_range, applicability = \"maybe-incorrect\", code = \"..\")]\n-    #[suggestion(parser::suggest_inclusive_range, applicability = \"maybe-incorrect\", code = \"..=\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::left_arrow_operator)]\n-pub(crate) struct LeftArrowOperator {\n-    #[primary_span]\n-    #[suggestion(applicability = \"maybe-incorrect\", code = \"< -\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::remove_let)]\n-pub(crate) struct RemoveLet {\n-    #[primary_span]\n-    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::use_eq_instead)]\n-pub(crate) struct UseEqInstead {\n-    #[primary_span]\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"=\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::use_empty_block_not_semi)]\n-pub(crate) struct UseEmptyBlockNotSemi {\n-    #[primary_span]\n-    #[suggestion_hidden(applicability = \"machine-applicable\", code = \"{{}}\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::comparison_interpreted_as_generic)]\n-pub(crate) struct ComparisonInterpretedAsGeneric {\n-    #[primary_span]\n-    #[label(parser::label_comparison)]\n-    pub comparison: Span,\n-    pub typename: String,\n-    #[label(parser::label_args)]\n-    pub args: Span,\n-    #[subdiagnostic]\n-    pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::shift_interpreted_as_generic)]\n-pub(crate) struct ShiftInterpretedAsGeneric {\n-    #[primary_span]\n-    #[label(parser::label_comparison)]\n-    pub shift: Span,\n-    pub typename: String,\n-    #[label(parser::label_args)]\n-    pub args: Span,\n-    #[subdiagnostic]\n-    pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n-}\n-\n-#[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n-pub(crate) struct ComparisonOrShiftInterpretedAsGenericSugg {\n-    #[suggestion_part(code = \"(\")]\n-    pub left: Span,\n-    #[suggestion_part(code = \")\")]\n-    pub right: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::found_expr_would_be_stmt)]\n-pub(crate) struct FoundExprWouldBeStmt {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    pub token: String,\n-    #[subdiagnostic]\n-    pub suggestion: ExprParenthesesNeeded,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::leading_plus_not_supported)]\n-pub(crate) struct LeadingPlusNotSupported {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    #[suggestion_verbose(\n-        parser::suggestion_remove_plus,\n-        code = \"\",\n-        applicability = \"machine-applicable\"\n-    )]\n-    pub remove_plus: Option<Span>,\n-    #[subdiagnostic]\n-    pub add_parentheses: Option<ExprParenthesesNeeded>,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::parentheses_with_struct_fields)]\n-pub(crate) struct ParenthesesWithStructFields {\n-    #[primary_span]\n-    pub span: Span,\n-    pub name: String,\n-    #[subdiagnostic]\n-    pub braces_for_struct: BracesForStructLiteral,\n-    #[subdiagnostic]\n-    pub no_fields_for_fn: NoFieldsForFnCall,\n-}\n-\n-#[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion_braces_for_struct, applicability = \"maybe-incorrect\")]\n-pub(crate) struct BracesForStructLiteral {\n-    #[suggestion_part(code = \" {{ \")]\n-    pub first: Span,\n-    #[suggestion_part(code = \" }}\")]\n-    pub second: Span,\n-}\n-\n-#[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion_no_fields_for_fn, applicability = \"maybe-incorrect\")]\n-pub(crate) struct NoFieldsForFnCall {\n-    #[suggestion_part(code = \"\")]\n-    pub fields: Vec<Span>,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::labeled_loop_in_break)]\n-pub(crate) struct LabeledLoopInBreak {\n-    #[primary_span]\n-    pub span: Span,\n-    #[subdiagnostic]\n-    pub sub: LabeledLoopInBreakSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n-pub(crate) struct LabeledLoopInBreakSub {\n-    #[suggestion_part(code = \"(\")]\n-    pub first: Span,\n-    #[suggestion_part(code = \")\")]\n-    pub second: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::array_brackets_instead_of_braces)]\n-pub(crate) struct ArrayBracketsInsteadOfSpaces {\n-    #[primary_span]\n-    pub span: Span,\n-    #[subdiagnostic]\n-    pub sub: ArrayBracketsInsteadOfSpacesSugg,\n-}\n-\n-#[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"maybe-incorrect\")]\n-pub(crate) struct ArrayBracketsInsteadOfSpacesSugg {\n-    #[suggestion_part(code = \"[\")]\n-    pub left: Span,\n-    #[suggestion_part(code = \"]\")]\n-    pub right: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::match_arm_body_without_braces)]\n-pub(crate) struct MatchArmBodyWithoutBraces {\n-    #[primary_span]\n-    #[label(parser::label_statements)]\n-    pub statements: Span,\n-    #[label(parser::label_arrow)]\n-    pub arrow: Span,\n-    pub num_statements: usize,\n-    #[subdiagnostic]\n-    pub sub: MatchArmBodyWithoutBracesSugg,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub(crate) enum MatchArmBodyWithoutBracesSugg {\n-    #[multipart_suggestion(parser::suggestion_add_braces, applicability = \"machine-applicable\")]\n-    AddBraces {\n-        #[suggestion_part(code = \"{{ \")]\n-        left: Span,\n-        #[suggestion_part(code = \" }}\")]\n-        right: Span,\n-    },\n-    #[suggestion(\n-        parser::suggestion_use_comma_not_semicolon,\n-        code = \",\",\n-        applicability = \"machine-applicable\"\n-    )]\n-    UseComma {\n-        #[primary_span]\n-        semicolon: Span,\n-    },\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::struct_literal_not_allowed_here)]\n-pub(crate) struct StructLiteralNotAllowedHere {\n-    #[primary_span]\n-    pub span: Span,\n-    #[subdiagnostic]\n-    pub sub: StructLiteralNotAllowedHereSugg,\n-}\n-\n-#[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n-pub(crate) struct StructLiteralNotAllowedHereSugg {\n-    #[suggestion_part(code = \"(\")]\n-    pub left: Span,\n-    #[suggestion_part(code = \")\")]\n-    pub right: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_interpolated_expression)]\n-pub(crate) struct InvalidInterpolatedExpression {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::hexadecimal_float_literal_not_supported)]\n-pub(crate) struct HexadecimalFloatLiteralNotSupported {\n-    #[primary_span]\n-    #[label(parser::not_supported)]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::octal_float_literal_not_supported)]\n-pub(crate) struct OctalFloatLiteralNotSupported {\n-    #[primary_span]\n-    #[label(parser::not_supported)]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::binary_float_literal_not_supported)]\n-pub(crate) struct BinaryFloatLiteralNotSupported {\n-    #[primary_span]\n-    #[label(parser::not_supported)]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_literal_suffix)]\n-pub(crate) struct InvalidLiteralSuffix {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    // FIXME(#100717)\n-    pub kind: String,\n-    pub suffix: Symbol,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_literal_suffix_on_tuple_index)]\n-pub(crate) struct InvalidLiteralSuffixOnTupleIndex {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    pub suffix: Symbol,\n-    #[help(parser::tuple_exception_line_1)]\n-    #[help(parser::tuple_exception_line_2)]\n-    #[help(parser::tuple_exception_line_3)]\n-    pub exception: Option<()>,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::non_string_abi_literal)]\n-pub(crate) struct NonStringAbiLiteral {\n-    #[primary_span]\n-    #[suggestion(code = \"\\\"C\\\"\", applicability = \"maybe-incorrect\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::mismatched_closing_delimiter)]\n-pub(crate) struct MismatchedClosingDelimiter {\n-    #[primary_span]\n-    pub spans: Vec<Span>,\n-    pub delimiter: String,\n-    #[label(parser::label_unmatched)]\n-    pub unmatched: Span,\n-    #[label(parser::label_opening_candidate)]\n-    pub opening_candidate: Option<Span>,\n-    #[label(parser::label_unclosed)]\n-    pub unclosed: Option<Span>,\n-}\n-\n // SnapshotParser is used to create a snapshot of the parser\n // without causing duplicate errors being emitted when the `Parser`\n // is dropped."}, {"sha": "784a8ae4c2ef6371a1f0dcd84d48b0c99b3b22c2", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=e56d6a68dbda754b414abff41517f3fad9e547b0", "patch": "@@ -1,34 +1,32 @@\n-use super::diagnostics::{\n-    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, BracesForStructLiteral,\n-    CatchAfterTry, CommaAfterBaseStruct, ComparisonInterpretedAsGeneric,\n-    ComparisonOrShiftInterpretedAsGenericSugg, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n-    ExpectedElseBlock, ExpectedExpressionFoundLet, FieldExpressionWithGeneric,\n-    FloatLiteralRequiresIntegerPart, FoundExprWouldBeStmt, IfExpressionMissingCondition,\n-    IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub, InvalidBlockMacroSegment,\n-    InvalidComparisonOperator, InvalidComparisonOperatorSub, InvalidInterpolatedExpression,\n-    InvalidLiteralSuffix, InvalidLiteralSuffixOnTupleIndex, InvalidLogicalOperator,\n-    InvalidLogicalOperatorSub, LabeledLoopInBreak, LeftArrowOperator, LifetimeInBorrowExpression,\n-    MacroInvocationWithQualifiedPath, MalformedLoopLabel, MatchArmBodyWithoutBraces,\n-    MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray, NoFieldsForFnCall,\n-    NotAsNegationOperator, NotAsNegationOperatorSub, OuterAttributeNotAllowedOnIfElse,\n-    ParenthesesWithStructFields, RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric,\n-    SnapshotParser, StructLiteralNotAllowedHere, TildeAsUnaryOperator, UnexpectedTokenAfterLabel,\n-    UnexpectedTokenAfterLabelSugg,\n-};\n+use super::diagnostics::SnapshotParser;\n use super::pat::{CommaRecoveryMode, RecoverColon, RecoverComma, PARAM_EXPECTED};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{\n     AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions,\n     SemiColonMode, SeqSep, TokenExpectType, TokenType, TrailingToken,\n };\n-use crate::maybe_recover_from_interpolated_ty_qpath;\n-use crate::parser::diagnostics::{\n-    BinaryFloatLiteralNotSupported, HexadecimalFloatLiteralNotSupported, IntLiteralTooLarge,\n-    InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth, InvalidIntLiteralWidth,\n-    InvalidNumLiteralBasePrefix, InvalidNumLiteralSuffix, LabeledLoopInBreakSub,\n-    LeadingPlusNotSupported, MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm,\n-    OctalFloatLiteralNotSupported, StructLiteralNotAllowedHereSugg,\n+use crate::errors::{\n+    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, BinaryFloatLiteralNotSupported,\n+    BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct, ComparisonInterpretedAsGeneric,\n+    ComparisonOrShiftInterpretedAsGenericSugg, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n+    ExpectedElseBlock, ExpectedExpressionFoundLet, FieldExpressionWithGeneric,\n+    FloatLiteralRequiresIntegerPart, FoundExprWouldBeStmt, HexadecimalFloatLiteralNotSupported,\n+    IfExpressionMissingCondition, IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub,\n+    IntLiteralTooLarge, InvalidBlockMacroSegment, InvalidComparisonOperator,\n+    InvalidComparisonOperatorSub, InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth,\n+    InvalidIntLiteralWidth, InvalidInterpolatedExpression, InvalidLiteralSuffix,\n+    InvalidLiteralSuffixOnTupleIndex, InvalidLogicalOperator, InvalidLogicalOperatorSub,\n+    InvalidNumLiteralBasePrefix, InvalidNumLiteralSuffix, LabeledLoopInBreak,\n+    LabeledLoopInBreakSub, LeadingPlusNotSupported, LeftArrowOperator, LifetimeInBorrowExpression,\n+    MacroInvocationWithQualifiedPath, MalformedLoopLabel, MatchArmBodyWithoutBraces,\n+    MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm, MissingInInForLoop,\n+    MissingInInForLoopSub, MissingSemicolonBeforeArray, NoFieldsForFnCall, NotAsNegationOperator,\n+    NotAsNegationOperatorSub, OctalFloatLiteralNotSupported, OuterAttributeNotAllowedOnIfElse,\n+    ParenthesesWithStructFields, RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric,\n+    StructLiteralNotAllowedHere, StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator,\n+    UnexpectedTokenAfterLabel, UnexpectedTokenAfterLabelSugg,\n };\n+use crate::maybe_recover_from_interpolated_ty_qpath;\n \n use core::mem;\n use rustc_ast::ptr::P;"}, {"sha": "37d12f783975c208539cdbb2c1393bb474dd8d40", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=e56d6a68dbda754b414abff41517f3fad9e547b0", "patch": "@@ -1,4 +1,6 @@\n-use super::diagnostics::{dummy_arg, ConsumeClosingDelim, Error, UseEmptyBlockNotSemi};\n+use crate::errors::UseEmptyBlockNotSemi;\n+\n+use super::diagnostics::{dummy_arg, ConsumeClosingDelim, Error};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{AttrWrapper, FollowedByType, ForceCollect, Parser, PathStyle, TrailingToken};\n "}, {"sha": "af6c0e34e2feed47a70ed32da52c9a7980ac733a", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=e56d6a68dbda754b414abff41517f3fad9e547b0", "patch": "@@ -42,7 +42,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use std::ops::Range;\n use std::{cmp, mem, slice};\n \n-use self::diagnostics::{MismatchedClosingDelimiter, NonStringAbiLiteral};\n+use crate::errors::{MismatchedClosingDelimiter, NonStringAbiLiteral};\n \n bitflags::bitflags! {\n     struct Restrictions: u8 {"}, {"sha": "542a1ac5dc65cc0b0d138d22112fe22a710bb586", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=e56d6a68dbda754b414abff41517f3fad9e547b0", "patch": "@@ -1,5 +1,5 @@\n use super::{ForceCollect, Parser, PathStyle, TrailingToken};\n-use crate::parser::diagnostics::RemoveLet;\n+use crate::errors::RemoveLet;\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;"}, {"sha": "03ced75d7633bc4ba9a0dde25cc1a77e15e83eb5", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e56d6a68dbda754b414abff41517f3fad9e547b0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=e56d6a68dbda754b414abff41517f3fad9e547b0", "patch": "@@ -1,14 +1,13 @@\n use super::attr::DEFAULT_INNER_ATTR_FORBIDDEN;\n-use super::diagnostics::{\n-    AttemptLocalParseRecovery, Error, InvalidVariableDeclaration, InvalidVariableDeclarationSub,\n-};\n+use super::diagnostics::{AttemptLocalParseRecovery, Error};\n use super::expr::LhsExpr;\n use super::pat::RecoverComma;\n use super::path::PathStyle;\n use super::TrailingToken;\n use super::{\n     AttrWrapper, BlockMode, FnParseMode, ForceCollect, Parser, Restrictions, SemiColonMode,\n };\n+use crate::errors::{InvalidVariableDeclaration, InvalidVariableDeclarationSub};\n use crate::maybe_whole;\n \n use rustc_ast as ast;"}]}