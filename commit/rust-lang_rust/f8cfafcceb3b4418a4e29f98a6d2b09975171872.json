{"sha": "f8cfafcceb3b4418a4e29f98a6d2b09975171872", "node_id": "C_kwDOAAsO6NoAKGY4Y2ZhZmNjZWIzYjQ0MThhNGUyOWY5OGE2ZDJiMDk5NzUxNzE4NzI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-30T18:19:20Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-05T19:34:38Z"}, "message": "Extract check_assertion.", "tree": {"sha": "b706879b35d8e4891ae088b306bccba2bbb1671c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b706879b35d8e4891ae088b306bccba2bbb1671c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8cfafcceb3b4418a4e29f98a6d2b09975171872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8cfafcceb3b4418a4e29f98a6d2b09975171872", "html_url": "https://github.com/rust-lang/rust/commit/f8cfafcceb3b4418a4e29f98a6d2b09975171872", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8cfafcceb3b4418a4e29f98a6d2b09975171872/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b833fcae90b42a9b55224288d5ec9cfd86835d0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b833fcae90b42a9b55224288d5ec9cfd86835d0d", "html_url": "https://github.com/rust-lang/rust/commit/b833fcae90b42a9b55224288d5ec9cfd86835d0d"}], "stats": {"total": 143, "additions": 71, "deletions": 72}, "files": [{"sha": "c8ed30cdcf303770cf5abd93310cfd1fde27f39a", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 71, "deletions": 72, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/f8cfafcceb3b4418a4e29f98a6d2b09975171872/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cfafcceb3b4418a4e29f98a6d2b09975171872/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=f8cfafcceb3b4418a4e29f98a6d2b09975171872", "patch": "@@ -480,6 +480,76 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Some(())\n     }\n \n+    fn check_assertion(\n+        &mut self,\n+        expected: bool,\n+        msg: &AssertKind<Operand<'tcx>>,\n+        cond: &Operand<'tcx>,\n+        location: Location,\n+    ) -> Option<!> {\n+        let ref value = self.eval_operand(&cond, location)?;\n+        trace!(\"assertion on {:?} should be {:?}\", value, expected);\n+\n+        let expected = Scalar::from_bool(expected);\n+        let value_const = self.use_ecx(location, |this| this.ecx.read_scalar(&value))?;\n+\n+        if expected != value_const {\n+            // Poison all places this operand references so that further code\n+            // doesn't use the invalid value\n+            match cond {\n+                Operand::Move(ref place) | Operand::Copy(ref place) => {\n+                    Self::remove_const(&mut self.ecx, place.local);\n+                }\n+                Operand::Constant(_) => {}\n+            }\n+            enum DbgVal<T> {\n+                Val(T),\n+                Underscore,\n+            }\n+            impl<T: std::fmt::Debug> std::fmt::Debug for DbgVal<T> {\n+                fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+                    match self {\n+                        Self::Val(val) => val.fmt(fmt),\n+                        Self::Underscore => fmt.write_str(\"_\"),\n+                    }\n+                }\n+            }\n+            let mut eval_to_int = |op| {\n+                // This can be `None` if the lhs wasn't const propagated and we just\n+                // triggered the assert on the value of the rhs.\n+                self.eval_operand(op, location)\n+                    .and_then(|op| self.ecx.read_immediate(&op).ok())\n+                    .map_or(DbgVal::Underscore, |op| DbgVal::Val(op.to_const_int()))\n+            };\n+            let msg = match msg {\n+                AssertKind::DivisionByZero(op) => AssertKind::DivisionByZero(eval_to_int(op)),\n+                AssertKind::RemainderByZero(op) => AssertKind::RemainderByZero(eval_to_int(op)),\n+                AssertKind::Overflow(bin_op @ (BinOp::Div | BinOp::Rem), op1, op2) => {\n+                    // Division overflow is *UB* in the MIR, and different than the\n+                    // other overflow checks.\n+                    AssertKind::Overflow(*bin_op, eval_to_int(op1), eval_to_int(op2))\n+                }\n+                AssertKind::BoundsCheck { ref len, ref index } => {\n+                    let len = eval_to_int(len);\n+                    let index = eval_to_int(index);\n+                    AssertKind::BoundsCheck { len, index }\n+                }\n+                // Remaining overflow errors are already covered by checks on the binary operators.\n+                AssertKind::Overflow(..) | AssertKind::OverflowNeg(_) => return None,\n+                // Need proper const propagator for these.\n+                _ => return None,\n+            };\n+            self.report_assert_as_lint(\n+                lint::builtin::UNCONDITIONAL_PANIC,\n+                location,\n+                \"this operation will panic at runtime\",\n+                msg,\n+            );\n+        }\n+\n+        None\n+    }\n+\n     fn ensure_not_propagated(&self, local: Local) {\n         if cfg!(debug_assertions) {\n             assert!(\n@@ -585,78 +655,7 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         self.super_terminator(terminator, location);\n         match &terminator.kind {\n             TerminatorKind::Assert { expected, ref msg, ref cond, .. } => {\n-                if let Some(ref value) = self.eval_operand(&cond, location) {\n-                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                    let expected = Scalar::from_bool(*expected);\n-                    let Ok(value_const) = self.ecx.read_scalar(&value) else {\n-                        // FIXME should be used use_ecx rather than a local match... but we have\n-                        // quite a few of these read_scalar/read_immediate that need fixing.\n-                        return\n-                    };\n-                    if expected != value_const {\n-                        enum DbgVal<T> {\n-                            Val(T),\n-                            Underscore,\n-                        }\n-                        impl<T: std::fmt::Debug> std::fmt::Debug for DbgVal<T> {\n-                            fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-                                match self {\n-                                    Self::Val(val) => val.fmt(fmt),\n-                                    Self::Underscore => fmt.write_str(\"_\"),\n-                                }\n-                            }\n-                        }\n-                        let mut eval_to_int = |op| {\n-                            // This can be `None` if the lhs wasn't const propagated and we just\n-                            // triggered the assert on the value of the rhs.\n-                            self.eval_operand(op, location)\n-                                .and_then(|op| self.ecx.read_immediate(&op).ok())\n-                                .map_or(DbgVal::Underscore, |op| DbgVal::Val(op.to_const_int()))\n-                        };\n-                        let msg = match msg {\n-                            AssertKind::DivisionByZero(op) => {\n-                                Some(AssertKind::DivisionByZero(eval_to_int(op)))\n-                            }\n-                            AssertKind::RemainderByZero(op) => {\n-                                Some(AssertKind::RemainderByZero(eval_to_int(op)))\n-                            }\n-                            AssertKind::Overflow(bin_op @ (BinOp::Div | BinOp::Rem), op1, op2) => {\n-                                // Division overflow is *UB* in the MIR, and different than the\n-                                // other overflow checks.\n-                                Some(AssertKind::Overflow(\n-                                    *bin_op,\n-                                    eval_to_int(op1),\n-                                    eval_to_int(op2),\n-                                ))\n-                            }\n-                            AssertKind::BoundsCheck { ref len, ref index } => {\n-                                let len = eval_to_int(len);\n-                                let index = eval_to_int(index);\n-                                Some(AssertKind::BoundsCheck { len, index })\n-                            }\n-                            // Remaining overflow errors are already covered by checks on the binary operators.\n-                            AssertKind::Overflow(..) | AssertKind::OverflowNeg(_) => None,\n-                            // Need proper const propagator for these.\n-                            _ => None,\n-                        };\n-                        // Poison all places this operand references so that further code\n-                        // doesn't use the invalid value\n-                        match cond {\n-                            Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n-                            Operand::Constant(_) => {}\n-                        }\n-                        if let Some(msg) = msg {\n-                            self.report_assert_as_lint(\n-                                lint::builtin::UNCONDITIONAL_PANIC,\n-                                location,\n-                                \"this operation will panic at runtime\",\n-                                msg,\n-                            );\n-                        }\n-                    }\n-                }\n+                self.check_assertion(*expected, msg, cond, location);\n             }\n             // None of these have Operands to const-propagate.\n             TerminatorKind::Goto { .. }"}]}