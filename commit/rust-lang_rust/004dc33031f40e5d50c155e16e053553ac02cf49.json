{"sha": "004dc33031f40e5d50c155e16e053553ac02cf49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNGRjMzMwMzFmNDBlNWQ1MGMxNTVlMTZlMDUzNTUzYWMwMmNmNDk=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-04-16T16:41:07Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-04-21T12:59:05Z"}, "message": "Refactor archive.rs for future usage of ar::GnuBuilder", "tree": {"sha": "7687cc1eb19aff7eb73104bc284f9007016812d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7687cc1eb19aff7eb73104bc284f9007016812d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/004dc33031f40e5d50c155e16e053553ac02cf49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/004dc33031f40e5d50c155e16e053553ac02cf49", "html_url": "https://github.com/rust-lang/rust/commit/004dc33031f40e5d50c155e16e053553ac02cf49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/004dc33031f40e5d50c155e16e053553ac02cf49/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fedac85e7d40bb5db956f940e6920d662427d06", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fedac85e7d40bb5db956f940e6920d662427d06", "html_url": "https://github.com/rust-lang/rust/commit/3fedac85e7d40bb5db956f940e6920d662427d06"}], "stats": {"total": 97, "additions": 54, "deletions": 43}, "files": [{"sha": "fb17bc8844133d65d5142e5dcc1f20128187cc4b", "filename": "src/archive.rs", "status": "modified", "additions": 54, "deletions": 43, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/004dc33031f40e5d50c155e16e053553ac02cf49/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004dc33031f40e5d50c155e16e053553ac02cf49/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=004dc33031f40e5d50c155e16e053553ac02cf49", "patch": "@@ -14,25 +14,29 @@ struct ArchiveConfig<'a> {\n     pub lib_search_paths: Vec<PathBuf>,\n }\n \n+enum ArchiveEntry {\n+    FromArchive { archive_index: usize, entry_index: usize },\n+    File(File),\n+}\n+\n pub struct ArArchiveBuilder<'a> {\n     config: ArchiveConfig<'a>,\n-    src_archive: Option<ar::Archive<File>>,\n-    src_entries: HashMap<String, usize>,\n-    builder: ar::Builder<File>,\n+    src_archives: Vec<ar::Archive<File>>,\n+    entries: HashMap<String, ArchiveEntry>,\n     update_symbols: bool,\n }\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self {\n         use rustc_codegen_ssa::back::link::archive_search_paths;\n-        let cfg = ArchiveConfig {\n+        let config = ArchiveConfig {\n             sess,\n             dst: output.to_path_buf(),\n             src: input.map(|p| p.to_path_buf()),\n             lib_search_paths: archive_search_paths(sess),\n         };\n \n-        let (src_archive, src_entries) = if let Some(src) = &cfg.src {\n+        let (src_archives, entries) = if let Some(src) = &config.src {\n             let mut archive = ar::Archive::new(File::open(src).unwrap());\n             let mut entries = HashMap::new();\n \n@@ -41,41 +45,41 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 let entry = entry.unwrap();\n                 entries.insert(\n                     String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n-                    i,\n+                    ArchiveEntry::FromArchive { archive_index: 0, entry_index: i },\n                 );\n                 i += 1;\n             }\n \n-            (Some(archive), entries)\n+            (vec![archive], entries)\n         } else {\n-            (None, HashMap::new())\n+            (vec![], HashMap::new())\n         };\n \n-        let builder = ar::Builder::new(File::create(&cfg.dst).unwrap());\n-\n         ArArchiveBuilder {\n-            config: cfg,\n-            src_archive,\n-            src_entries,\n-            builder,\n+            config,\n+            src_archives,\n+            entries,\n             update_symbols: false,\n         }\n     }\n \n     fn src_files(&mut self) -> Vec<String> {\n-        self.src_entries.keys().cloned().collect()\n+        self.entries.keys().cloned().collect()\n     }\n \n     fn remove_file(&mut self, name: &str) {\n-        let file = self.src_entries.remove(name);\n+        let file = self.entries.remove(name);\n         assert!(\n             file.is_some(),\n             \"Tried to remove file not existing in src archive\",\n         );\n     }\n \n     fn add_file(&mut self, file: &Path) {\n-        self.builder.append_path(file).unwrap();\n+        self.entries.insert(\n+            file.file_name().unwrap().to_str().unwrap().to_string(),\n+            ArchiveEntry::File(File::open(file).unwrap()),\n+        );\n     }\n \n     fn add_native_library(&mut self, name: &str) {\n@@ -115,23 +119,30 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     }\n \n     fn build(mut self) {\n-        // Add files from original archive\n-        if let Some(mut src_archive) = self.src_archive {\n-            for (_entry_name, entry_idx) in self.src_entries.into_iter() {\n-                let entry = src_archive.jump_to_entry(entry_idx).unwrap();\n-                let orig_header = entry.header();\n-                let mut header =\n-                    ar::Header::new(orig_header.identifier().to_vec(), orig_header.size());\n-                header.set_mtime(orig_header.mtime());\n-                header.set_uid(orig_header.uid());\n-                header.set_gid(orig_header.gid());\n-                header.set_mode(orig_header.mode());\n-                self.builder.append(&header, entry).unwrap();\n+        let mut builder = ar::Builder::new(File::create(&self.config.dst).unwrap());\n+\n+        // Add all files\n+        for (entry_name, entry) in self.entries.into_iter() {\n+            match entry {\n+                ArchiveEntry::FromArchive { archive_index, entry_index } => {\n+                    let entry = self.src_archives[archive_index].jump_to_entry(entry_index).unwrap();\n+                    let orig_header = entry.header();\n+                    let mut header =\n+                        ar::Header::new(orig_header.identifier().to_vec(), orig_header.size());\n+                    header.set_mtime(orig_header.mtime());\n+                    header.set_uid(orig_header.uid());\n+                    header.set_gid(orig_header.gid());\n+                    header.set_mode(orig_header.mode());\n+                    builder.append(&header, entry).unwrap();\n+                }\n+                ArchiveEntry::File(mut file) => {\n+                    builder.append_file(entry_name.as_bytes(), &mut file).unwrap();\n+                }\n             }\n         }\n \n         // Finalize archive\n-        std::mem::drop(self.builder);\n+        std::mem::drop(builder);\n \n         // Run ranlib to be able to link the archive\n         let status = std::process::Command::new(\"ranlib\")\n@@ -151,22 +162,22 @@ impl<'a> ArArchiveBuilder<'a> {\n         where F: FnMut(&str) -> bool + 'static\n     {\n         let mut archive = ar::Archive::new(std::fs::File::open(archive)?);\n-        while let Some(entry) = archive.next_entry() {\n-            let entry = entry?;\n-            let orig_header = entry.header();\n+        let archive_index = self.src_archives.len();\n \n-            if skip(std::str::from_utf8(orig_header.identifier()).unwrap()) {\n-                continue;\n+        let mut i = 0;\n+        while let Some(entry) = archive.next_entry() {\n+            let entry = entry.unwrap();\n+            let file_name = String::from_utf8(entry.header().identifier().to_vec()).unwrap();\n+            if !skip(&file_name) {\n+                self.entries.insert(\n+                    file_name,\n+                    ArchiveEntry::FromArchive { archive_index, entry_index: i },\n+                );\n             }\n-\n-            let mut header =\n-                ar::Header::new(orig_header.identifier().to_vec(), orig_header.size());\n-            header.set_mtime(orig_header.mtime());\n-            header.set_uid(orig_header.uid());\n-            header.set_gid(orig_header.gid());\n-            header.set_mode(orig_header.mode());\n-            self.builder.append(&header, entry).unwrap();\n+            i += 1;\n         }\n+\n+        self.src_archives.push(archive);\n         Ok(())\n     }\n }"}]}