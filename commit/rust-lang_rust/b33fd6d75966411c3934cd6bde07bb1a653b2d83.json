{"sha": "b33fd6d75966411c3934cd6bde07bb1a653b2d83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzM2ZkNmQ3NTk2NjQxMWMzOTM0Y2Q2YmRlMDdiYjFhNjUzYjJkODM=", "commit": {"author": {"name": "petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-06-29T10:16:35Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-06-29T12:19:53Z"}, "message": "Change some terminology around keywords and reserved identifiers", "tree": {"sha": "99da762fe26f23fef6f73a6a2b6302b6569c52da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99da762fe26f23fef6f73a6a2b6302b6569c52da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b33fd6d75966411c3934cd6bde07bb1a653b2d83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b33fd6d75966411c3934cd6bde07bb1a653b2d83", "html_url": "https://github.com/rust-lang/rust/commit/b33fd6d75966411c3934cd6bde07bb1a653b2d83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b33fd6d75966411c3934cd6bde07bb1a653b2d83/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e03948ef3e19ff90066ca366bf76c390d7a42bc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e03948ef3e19ff90066ca366bf76c390d7a42bc5", "html_url": "https://github.com/rust-lang/rust/commit/e03948ef3e19ff90066ca366bf76c390d7a42bc5"}], "stats": {"total": 210, "additions": 100, "deletions": 110}, "files": [{"sha": "de8749c43d95c95ec261a8b61d5379e273d4e7b5", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=b33fd6d75966411c3934cd6bde07bb1a653b2d83", "patch": "@@ -300,7 +300,7 @@ impl<'a> Classifier<'a> {\n                     \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n \n                     \"$crate\" => Class::KeyWord,\n-                    _ if tas.tok.is_any_keyword() => Class::KeyWord,\n+                    _ if tas.tok.is_reserved_ident() => Class::KeyWord,\n \n                     _ => {\n                         if self.in_macro_nonterminal {"}, {"sha": "a35b278a4b0649ebbe58b6b0d15139117daaccfa", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b33fd6d75966411c3934cd6bde07bb1a653b2d83", "patch": "@@ -1283,7 +1283,7 @@ impl<'a> StringReader<'a> {\n                     });\n                     let keyword_checking_token = &token::Ident(keyword_checking_ident);\n                     let last_bpos = self.pos;\n-                    if keyword_checking_token.is_any_keyword() &&\n+                    if keyword_checking_token.is_reserved_ident() &&\n                        !keyword_checking_token.is_keyword(keywords::Static) {\n                         self.err_span_(start, last_bpos, \"lifetimes cannot use keyword names\");\n                     }"}, {"sha": "64506c4af46919b05831a87d18d5dbea99015231", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b33fd6d75966411c3934cd6bde07bb1a653b2d83", "patch": "@@ -511,14 +511,13 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn this_token_descr(&self) -> String {\n-        let s = self.this_token_to_string();\n-        if self.token.is_strict_keyword() {\n-            format!(\"keyword `{}`\", s)\n-        } else if self.token.is_reserved_keyword() {\n-            format!(\"reserved keyword `{}`\", s)\n-        } else {\n-            format!(\"`{}`\", s)\n-        }\n+        let prefix = match &self.token {\n+            t if t.is_special_ident() => \"reserved identifier \",\n+            t if t.is_used_keyword() => \"keyword \",\n+            t if t.is_unused_keyword() => \"reserved keyword \",\n+            _ => \"\",\n+        };\n+        format!(\"{}`{}`\", prefix, self.this_token_to_string())\n     }\n \n     pub fn unexpected_last<T>(&self, t: &token::Token) -> PResult<'a, T> {\n@@ -637,10 +636,12 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        self.check_strict_keywords();\n-        self.check_reserved_keywords();\n         match self.token {\n             token::Ident(i) => {\n+                if self.token.is_reserved_ident() {\n+                    self.span_err(self.span, &format!(\"expected identifier, found {}\",\n+                                                      self.this_token_descr()));\n+                }\n                 self.bump();\n                 Ok(i)\n             }\n@@ -713,25 +714,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Signal an error if the given string is a strict keyword\n-    pub fn check_strict_keywords(&mut self) {\n-        if self.token.is_strict_keyword() {\n-            let token_str = self.this_token_to_string();\n-            let span = self.span;\n-            self.span_err(span,\n-                          &format!(\"expected identifier, found keyword `{}`\",\n-                                  token_str));\n-        }\n-    }\n-\n-    /// Signal an error if the current token is a reserved keyword\n-    pub fn check_reserved_keywords(&mut self) {\n-        if self.token.is_reserved_keyword() {\n-            let token_str = self.this_token_to_string();\n-            self.fatal(&format!(\"`{}` is a reserved keyword\", token_str)).emit()\n-        }\n-    }\n-\n     fn check_ident(&mut self) -> bool {\n         if self.token.is_ident() {\n             true\n@@ -2301,7 +2283,7 @@ impl<'a> Parser<'a> {\n                     ex = ExprKind::Break(lt, e);\n                     hi = self.prev_span;\n                 } else if self.token.is_keyword(keywords::Let) {\n-                    // Catch this syntax error here, instead of in `check_strict_keywords`, so\n+                    // Catch this syntax error here, instead of in `parse_ident`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n                     let mut db = self.fatal(\"expected expression, found statement (`let`)\");\n                     db.note(\"variable declaration using `let` is a statement\");\n@@ -3540,7 +3522,7 @@ impl<'a> Parser<'a> {\n                 // Parse box pat\n                 let subpat = self.parse_pat()?;\n                 pat = PatKind::Box(subpat);\n-            } else if self.token.is_ident() && !self.token.is_any_keyword() &&\n+            } else if self.token.is_ident() && !self.token.is_reserved_ident() &&\n                       self.parse_as_ident() {\n                 // Parse ident @ pat\n                 // This can give false positives and parse nullary enums,\n@@ -3815,7 +3797,7 @@ impl<'a> Parser<'a> {\n \n     fn is_union_item(&self) -> bool {\n         self.token.is_keyword(keywords::Union) &&\n-        self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword())\n+        self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n     }\n \n     fn is_defaultness(&self) -> bool {"}, {"sha": "75969cf2eb85b8022e6cdf9ec1dfe23fa99b1988", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b33fd6d75966411c3934cd6bde07bb1a653b2d83", "patch": "@@ -87,7 +87,7 @@ impl Lit {\n fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n     let ident_token: Token = Ident(ident);\n \n-    !ident_token.is_any_keyword() ||\n+    !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n     [\n         keywords::Do.name(),\n@@ -110,7 +110,7 @@ fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n fn ident_can_begin_type(ident: ast::Ident) -> bool {\n     let ident_token: Token = Ident(ident);\n \n-    !ident_token.is_any_keyword() ||\n+    !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n     [\n         keywords::For.name(),\n@@ -315,7 +315,7 @@ impl Token {\n \n     pub fn is_path_start(&self) -> bool {\n         self == &ModSep || self.is_qpath_start() || self.is_path() ||\n-        self.is_path_segment_keyword() || self.is_ident() && !self.is_any_keyword()\n+        self.is_path_segment_keyword() || self.is_ident() && !self.is_reserved_ident()\n     }\n \n     /// Returns `true` if the token is a given keyword, `kw`.\n@@ -333,26 +333,35 @@ impl Token {\n         }\n     }\n \n-    /// Returns `true` if the token is either a strict or reserved keyword.\n-    pub fn is_any_keyword(&self) -> bool {\n-        self.is_strict_keyword() || self.is_reserved_keyword()\n+    // Returns true for reserved identifiers used internally for elided lifetimes,\n+    // unnamed method parameters, crate root module, error recovery etc.\n+    pub fn is_special_ident(&self) -> bool {\n+        match self.ident() {\n+            Some(id) => id.name <= keywords::DollarCrate.name(),\n+            _ => false,\n+        }\n     }\n \n-    /// Returns `true` if the token is a strict keyword.\n-    pub fn is_strict_keyword(&self) -> bool {\n+    /// Returns `true` if the token is a keyword used in the language.\n+    pub fn is_used_keyword(&self) -> bool {\n         match self.ident() {\n             Some(id) => id.name >= keywords::As.name() && id.name <= keywords::While.name(),\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n-    pub fn is_reserved_keyword(&self) -> bool {\n+    pub fn is_unused_keyword(&self) -> bool {\n         match self.ident() {\n             Some(id) => id.name >= keywords::Abstract.name() && id.name <= keywords::Yield.name(),\n             _ => false,\n         }\n     }\n+\n+    /// Returns `true` if the token is either a special identifier or a keyword.\n+    pub fn is_reserved_ident(&self) -> bool {\n+        self.is_special_ident() || self.is_used_keyword() || self.is_unused_keyword()\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash)]"}, {"sha": "debac70545a99d0f2ff39c08f69bd3c006d753db", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 63, "deletions": 64, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=b33fd6d75966411c3934cd6bde07bb1a653b2d83", "patch": "@@ -237,77 +237,76 @@ macro_rules! declare_keywords {(\n // NB: leaving holes in the ident table is bad! a different ident will get\n // interned with the id from the hole, but it will be between the min and max\n // of the reserved words, and thus tagged as \"reserved\".\n-// After modifying this list adjust `is_strict_keyword`/`is_reserved_keyword`,\n+// After modifying this list adjust `is_special_ident`, `is_used_keyword`/`is_unused_keyword`,\n // this should be rarely necessary though if the keywords are kept in alphabetic order.\n declare_keywords! {\n-    // Invalid identifier\n+    // Special reserved identifiers used internally for elided lifetimes,\n+    // unnamed method parameters, crate root module, error recovery etc.\n     (0,  Invalid,        \"\")\n-\n-    // Strict keywords used in the language.\n-    (1,  As,             \"as\")\n-    (2,  Box,            \"box\")\n-    (3,  Break,          \"break\")\n-    (4,  Const,          \"const\")\n-    (5,  Continue,       \"continue\")\n-    (6,  Crate,          \"crate\")\n-    (7,  DollarCrate,    \"$crate\")\n-    (8,  Else,           \"else\")\n-    (9,  Enum,           \"enum\")\n-    (10, Extern,         \"extern\")\n-    (11, False,          \"false\")\n-    (12, Fn,             \"fn\")\n-    (13, For,            \"for\")\n-    (14, If,             \"if\")\n-    (15, Impl,           \"impl\")\n-    (16, In,             \"in\")\n-    (17, Let,            \"let\")\n-    (18, Loop,           \"loop\")\n-    (19, Match,          \"match\")\n-    (20, Mod,            \"mod\")\n-    (21, Move,           \"move\")\n-    (22, Mut,            \"mut\")\n-    (23, Pub,            \"pub\")\n-    (24, Ref,            \"ref\")\n-    (25, Return,         \"return\")\n-    (26, SelfValue,      \"self\")\n-    (27, SelfType,       \"Self\")\n-    (28, Static,         \"static\")\n-    (29, Struct,         \"struct\")\n-    (30, Super,          \"super\")\n-    (31, Trait,          \"trait\")\n-    (32, True,           \"true\")\n-    (33, Type,           \"type\")\n-    (34, Unsafe,         \"unsafe\")\n-    (35, Use,            \"use\")\n-    (36, Where,          \"where\")\n-    (37, While,          \"while\")\n+    (1,  CrateRoot,      \"{{root}}\")\n+    (2,  DollarCrate,    \"$crate\")\n+\n+    // Keywords used in the language.\n+    (3,  As,             \"as\")\n+    (4,  Box,            \"box\")\n+    (5,  Break,          \"break\")\n+    (6,  Const,          \"const\")\n+    (7,  Continue,       \"continue\")\n+    (8,  Crate,          \"crate\")\n+    (9,  Else,           \"else\")\n+    (10, Enum,           \"enum\")\n+    (11, Extern,         \"extern\")\n+    (12, False,          \"false\")\n+    (13, Fn,             \"fn\")\n+    (14, For,            \"for\")\n+    (15, If,             \"if\")\n+    (16, Impl,           \"impl\")\n+    (17, In,             \"in\")\n+    (18, Let,            \"let\")\n+    (19, Loop,           \"loop\")\n+    (20, Match,          \"match\")\n+    (21, Mod,            \"mod\")\n+    (22, Move,           \"move\")\n+    (23, Mut,            \"mut\")\n+    (24, Pub,            \"pub\")\n+    (25, Ref,            \"ref\")\n+    (26, Return,         \"return\")\n+    (27, SelfValue,      \"self\")\n+    (28, SelfType,       \"Self\")\n+    (29, Static,         \"static\")\n+    (30, Struct,         \"struct\")\n+    (31, Super,          \"super\")\n+    (32, Trait,          \"trait\")\n+    (33, True,           \"true\")\n+    (34, Type,           \"type\")\n+    (35, Unsafe,         \"unsafe\")\n+    (36, Use,            \"use\")\n+    (37, Where,          \"where\")\n+    (38, While,          \"while\")\n \n     // Keywords reserved for future use.\n-    (38, Abstract,       \"abstract\")\n-    (39, Alignof,        \"alignof\")\n-    (40, Become,         \"become\")\n-    (41, Do,             \"do\")\n-    (42, Final,          \"final\")\n-    (43, Macro,          \"macro\")\n-    (44, Offsetof,       \"offsetof\")\n-    (45, Override,       \"override\")\n-    (46, Priv,           \"priv\")\n-    (47, Proc,           \"proc\")\n-    (48, Pure,           \"pure\")\n-    (49, Sizeof,         \"sizeof\")\n-    (50, Typeof,         \"typeof\")\n-    (51, Unsized,        \"unsized\")\n-    (52, Virtual,        \"virtual\")\n-    (53, Yield,          \"yield\")\n+    (39, Abstract,       \"abstract\")\n+    (40, Alignof,        \"alignof\")\n+    (41, Become,         \"become\")\n+    (42, Do,             \"do\")\n+    (43, Final,          \"final\")\n+    (44, Macro,          \"macro\")\n+    (45, Offsetof,       \"offsetof\")\n+    (46, Override,       \"override\")\n+    (47, Priv,           \"priv\")\n+    (48, Proc,           \"proc\")\n+    (49, Pure,           \"pure\")\n+    (50, Sizeof,         \"sizeof\")\n+    (51, Typeof,         \"typeof\")\n+    (52, Unsized,        \"unsized\")\n+    (53, Virtual,        \"virtual\")\n+    (54, Yield,          \"yield\")\n \n     // Weak keywords, have special meaning only in specific contexts.\n-    (54, Default,        \"default\")\n-    (55, StaticLifetime, \"'static\")\n-    (56, Union,          \"union\")\n-    (57, Catch,          \"catch\")\n-\n-    // A virtual keyword that resolves to the crate root when used in a lexical scope.\n-    (58, CrateRoot,      \"{{root}}\")\n+    (55, Default,        \"default\")\n+    (56, StaticLifetime, \"'static\")\n+    (57, Union,          \"union\")\n+    (58, Catch,          \"catch\")\n }\n \n // If an interner exists in TLS, return it. Otherwise, prepare a fresh one."}, {"sha": "70597a230a886f53365e53bed3db763d7e51ff1b", "filename": "src/test/compile-fail/dollar-crate-is-keyword.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs?ref=b33fd6d75966411c3934cd6bde07bb1a653b2d83", "patch": "@@ -10,11 +10,11 @@\n \n macro_rules! m {\n     () => {\n-        struct $crate {} //~ ERROR expected identifier, found keyword `$crate`\n+        struct $crate {} //~ ERROR expected identifier, found reserved identifier `$crate`\n \n         use $crate; // OK\n                     //~^ WARN `$crate` may not be imported\n-        use $crate as $crate; //~ ERROR expected identifier, found keyword `$crate`\n+        use $crate as $crate; //~ ERROR expected identifier, found reserved identifier `$crate`\n                               //~^ WARN `$crate` may not be imported\n     }\n }"}, {"sha": "c7dcaf4137e5d6cc752080e8b9a90e3db1ddf882", "filename": "src/test/parse-fail/macro-keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Ftest%2Fparse-fail%2Fmacro-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33fd6d75966411c3934cd6bde07bb1a653b2d83/src%2Ftest%2Fparse-fail%2Fmacro-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmacro-keyword.rs?ref=b33fd6d75966411c3934cd6bde07bb1a653b2d83", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-fn macro() {  //~ ERROR `macro` is a reserved keyword\n+fn macro() {  //~ ERROR expected identifier, found reserved keyword `macro`\n }\n \n pub fn main() {"}]}