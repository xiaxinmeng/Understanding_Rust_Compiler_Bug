{"sha": "8887782c4ab97d22f3d5c10e142407e4371c5c61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ODc3ODJjNGFiOTdkMjJmM2Q1YzEwZTE0MjQwN2U0MzcxYzVjNjE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-13T11:17:48Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-13T11:17:48Z"}, "message": "Merge #1129\n\n1129: introduce SourceAnalyzer API for ides r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "80b60b2c0c2f6104b98e16648b95d99d9b1d3463", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80b60b2c0c2f6104b98e16648b95d99d9b1d3463"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8887782c4ab97d22f3d5c10e142407e4371c5c61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8887782c4ab97d22f3d5c10e142407e4371c5c61", "html_url": "https://github.com/rust-lang/rust/commit/8887782c4ab97d22f3d5c10e142407e4371c5c61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8887782c4ab97d22f3d5c10e142407e4371c5c61/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "34a05b7fea4add78446b2d93a64538982abacb9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/34a05b7fea4add78446b2d93a64538982abacb9f", "html_url": "https://github.com/rust-lang/rust/commit/34a05b7fea4add78446b2d93a64538982abacb9f"}, {"sha": "2facb5e061971afbf6bd2fabe3966d5de9d46489", "url": "https://api.github.com/repos/rust-lang/rust/commits/2facb5e061971afbf6bd2fabe3966d5de9d46489", "html_url": "https://github.com/rust-lang/rust/commit/2facb5e061971afbf6bd2fabe3966d5de9d46489"}], "stats": {"total": 1204, "additions": 568, "deletions": 636}, "files": [{"sha": "cb0ac988597c390d85c8b576f163e57912bf4dff", "filename": "crates/ra_assists/src/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -1,7 +1,6 @@\n use hir::{\n     HirDisplay, Ty,\n     db::HirDatabase,\n-    source_binder::function_from_child_node,\n };\n use ra_syntax::{\n     SyntaxKind,\n@@ -30,11 +29,8 @@ pub(crate) fn add_explicit_type(mut ctx: AssistCtx<impl HirDatabase>) -> Option<\n     }\n     // Infer type\n     let db = ctx.db;\n-    let func = function_from_child_node(db, ctx.frange.file_id, pat.syntax())?;\n-    let inference_res = func.infer(db);\n-    let source_map = func.body_source_map(db);\n-    let expr_id = source_map.node_expr(expr.into())?;\n-    let ty = inference_res[expr_id].clone();\n+    let analyzer = hir::SourceAnalyzer::new(db, ctx.frange.file_id, stmt.syntax(), None);\n+    let ty = analyzer.type_of(db, expr)?;\n     // Assist not applicable if the type is unknown\n     if is_unknown(&ty) {\n         return None;"}, {"sha": "100ebb7b6f6cca3dd3efbf7971d2f04cf9d2108e", "filename": "crates/ra_assists/src/add_missing_impl_members.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -2,7 +2,6 @@ use std::fmt::Write;\n \n use crate::{Assist, AssistId, AssistCtx};\n \n-use hir::Resolver;\n use hir::db::HirDatabase;\n use ra_syntax::{SmolStr, SyntaxKind, TextRange, TextUnit, TreeArc};\n use ra_syntax::ast::{self, AstNode, AstToken, FnDef, ImplItem, ImplItemKind, NameOwner};\n@@ -46,9 +45,9 @@ fn add_missing_impl_members_inner(\n     let trait_def = {\n         let file_id = ctx.frange.file_id;\n         let position = FilePosition { file_id, offset: impl_node.syntax().range().start() };\n-        let resolver = hir::source_binder::resolver_for_position(ctx.db, position);\n+        let analyzer = hir::SourceAnalyzer::new(ctx.db, position.file_id, impl_node.syntax(), None);\n \n-        resolve_target_trait_def(ctx.db, &resolver, impl_node)?\n+        resolve_target_trait_def(ctx.db, &analyzer, impl_node)?\n     };\n \n     let missing_fns: Vec<_> = {\n@@ -122,14 +121,14 @@ fn add_missing_impl_members_inner(\n /// implemented) to a `ast::TraitDef`.\n fn resolve_target_trait_def(\n     db: &impl HirDatabase,\n-    resolver: &Resolver,\n+    analyzer: &hir::SourceAnalyzer,\n     impl_block: &ast::ImplBlock,\n ) -> Option<TreeArc<ast::TraitDef>> {\n-    let ast_path = impl_block.target_trait().map(AstNode::syntax).and_then(ast::PathType::cast)?;\n-    let hir_path = ast_path.path().and_then(hir::Path::from_ast)?;\n+    let ast_path =\n+        impl_block.target_trait().map(AstNode::syntax).and_then(ast::PathType::cast)?.path()?;\n \n-    match resolver.resolve_path(db, &hir_path).take_types() {\n-        Some(hir::Resolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).1),\n+    match analyzer.resolve_path(db, &ast_path) {\n+        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).1),\n         _ => None,\n     }\n }"}, {"sha": "45e327cd4aeb20f87253232980cf8c6c7a09618d", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -1,7 +1,7 @@\n use std::fmt::Write;\n \n use hir::{\n-    AdtDef, FieldSource, source_binder,\n+    AdtDef, FieldSource,\n     db::HirDatabase,\n };\n use ra_syntax::ast::{self, AstNode};\n@@ -20,12 +20,8 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n     }\n \n     let expr = match_expr.expr()?;\n-    let function =\n-        source_binder::function_from_child_node(ctx.db, ctx.frange.file_id, expr.syntax())?;\n-    let infer_result = function.infer(ctx.db);\n-    let source_map = function.body_source_map(ctx.db);\n-    let node_expr = source_map.node_expr(expr)?;\n-    let match_expr_ty = infer_result[node_expr].clone();\n+    let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, expr.syntax(), None);\n+    let match_expr_ty = analyzer.type_of(ctx.db, expr)?;\n     let enum_def = match_expr_ty.autoderef(ctx.db).find_map(|ty| match ty.as_adt() {\n         Some((AdtDef::Enum(e), _)) => Some(e),\n         _ => None,"}, {"sha": "663b4f669d0fe6cf740ca7effb9c1f1e65aaa003", "filename": "crates/ra_assists/src/fill_struct_fields.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -1,6 +1,6 @@\n use std::fmt::Write;\n \n-use hir::{AdtDef, db::HirDatabase, source_binder::function_from_child_node};\n+use hir::{AdtDef, db::HirDatabase};\n \n use ra_syntax::ast::{self, AstNode};\n \n@@ -51,15 +51,13 @@ where\n     }\n \n     fn evaluate_struct_def_fields(&mut self) -> Option<()> {\n-        let function = function_from_child_node(\n+        let analyzer = hir::SourceAnalyzer::new(\n             self.ctx.db,\n             self.ctx.frange.file_id,\n             self.struct_lit.syntax(),\n-        )?;\n-        let infer_result = function.infer(self.ctx.db);\n-        let source_map = function.body_source_map(self.ctx.db);\n-        let node_expr = source_map.node_expr(self.struct_lit.into())?;\n-        let struct_lit_ty = infer_result[node_expr].clone();\n+            None,\n+        );\n+        let struct_lit_ty = analyzer.type_of(self.ctx.db, self.struct_lit.into())?;\n         let struct_def = match struct_lit_ty.as_adt() {\n             Some((AdtDef::Struct(s), _)) => s,\n             _ => return None,"}, {"sha": "e0479ef1307fce7a8d8cedc057d79fbacb579674", "filename": "crates/ra_assists/src/inline_local_variable.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -1,7 +1,4 @@\n-use hir::{\n-    db::HirDatabase,\n-    source_binder::function_from_child_node,\n-};\n+use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode, AstToken, PatKind, ExprKind},\n     TextRange,\n@@ -29,10 +26,8 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n     } else {\n         let_stmt.syntax().range()\n     };\n-\n-    let function = function_from_child_node(ctx.db, ctx.frange.file_id, bind_pat.syntax())?;\n-    let scope = function.scopes(ctx.db);\n-    let refs = scope.find_all_refs(bind_pat);\n+    let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, bind_pat.syntax(), None);\n+    let refs = analyzer.find_all_refs(bind_pat);\n \n     let mut wrap_in_parens = vec![true; refs.len()];\n "}, {"sha": "5d8cf57b6ca4856fc835142aabb6c522c10e3601", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -4,7 +4,7 @@ use ra_db::{CrateId, SourceRootId, Edition};\n use ra_syntax::{ast::self, TreeArc};\n \n use crate::{\n-    Name, ScopesWithSourceMap, Ty, HirFileId, Either,\n+    Name, Ty, HirFileId, Either,\n     HirDatabase, DefDatabase,\n     type_ref::TypeRef,\n     nameres::{ModuleScope, Namespace, ImportId, CrateModuleId},\n@@ -189,7 +189,7 @@ impl Module {\n         }\n     }\n \n-    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         let def_map = db.crate_def_map(self.krate);\n         Resolver::default().push_module_scope(def_map, self.module_id)\n     }\n@@ -313,7 +313,7 @@ impl Struct {\n \n     // FIXME move to a more general type\n     /// Builds a resolver for type references inside this struct.\n-    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self.module(db).resolver(db);\n         // ...and add generic params, if present\n@@ -373,7 +373,7 @@ impl Enum {\n \n     // FIXME: move to a more general type\n     /// Builds a resolver for type references inside this struct.\n-    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self.module(db).resolver(db);\n         // ...and add generic params, if present\n@@ -450,28 +450,22 @@ impl DefWithBody {\n         db.infer(*self)\n     }\n \n-    pub fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map(*self).1\n-    }\n-\n     pub fn body(&self, db: &impl HirDatabase) -> Arc<Body> {\n         db.body_hir(*self)\n     }\n \n+    pub fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n+        db.body_with_source_map(*self).1\n+    }\n+\n     /// Builds a resolver for code inside this item.\n-    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         match *self {\n             DefWithBody::Const(ref c) => c.resolver(db),\n             DefWithBody::Function(ref f) => f.resolver(db),\n             DefWithBody::Static(ref s) => s.resolver(db),\n         }\n     }\n-\n-    pub fn scopes(&self, db: &impl HirDatabase) -> ScopesWithSourceMap {\n-        let scopes = db.expr_scopes(*self);\n-        let source_map = db.body_with_source_map(*self).1;\n-        ScopesWithSourceMap { scopes, source_map }\n-    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -523,7 +517,7 @@ impl Function {\n         self.signature(db).name.clone()\n     }\n \n-    pub fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n+    pub(crate) fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n         db.body_with_source_map((*self).into()).1\n     }\n \n@@ -535,12 +529,6 @@ impl Function {\n         db.type_for_def((*self).into(), Namespace::Values)\n     }\n \n-    pub fn scopes(&self, db: &impl HirDatabase) -> ScopesWithSourceMap {\n-        let scopes = db.expr_scopes((*self).into());\n-        let source_map = db.body_with_source_map((*self).into()).1;\n-        ScopesWithSourceMap { scopes, source_map }\n-    }\n-\n     pub fn signature(&self, db: &impl HirDatabase) -> Arc<FnSignature> {\n         db.fn_signature(*self)\n     }\n@@ -561,7 +549,7 @@ impl Function {\n \n     // FIXME: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n-    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self\n             .impl_block(db)\n@@ -606,10 +594,6 @@ impl Const {\n         db.infer((*self).into())\n     }\n \n-    pub fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map((*self).into()).1\n-    }\n-\n     /// The containing impl block, if this is a method.\n     pub fn impl_block(&self, db: &impl DefDatabase) -> Option<ImplBlock> {\n         let module_impls = db.impls_in_module(self.module(db));\n@@ -618,7 +602,7 @@ impl Const {\n \n     // FIXME: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n-    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self\n             .impl_block(db)\n@@ -670,18 +654,14 @@ impl Static {\n     }\n \n     /// Builds a resolver for code inside this item.\n-    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         self.module(db).resolver(db)\n     }\n \n     pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n         db.infer((*self).into())\n     }\n-\n-    pub fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map((*self).into()).1\n-    }\n }\n \n impl Docs for Static {\n@@ -756,7 +736,7 @@ impl TypeAlias {\n     }\n \n     /// Builds a resolver for the type references in this type alias.\n-    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n         let r = self\n             .impl_block(db)"}, {"sha": "817e660f9133409d44fa4126116f0d486a1773a9", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -14,9 +14,9 @@ use crate::{\n     name::AsName,\n     type_ref::{Mutability, TypeRef},\n };\n-use crate::{ path::GenericArgs, ty::primitive::{IntTy, UncertainIntTy, FloatTy, UncertainFloatTy}};\n+use crate::{path::GenericArgs, ty::primitive::{IntTy, UncertainIntTy, FloatTy, UncertainFloatTy}};\n \n-pub use self::scope::{ExprScopes, ScopesWithSourceMap, ScopeEntryWithSyntax};\n+pub use self::scope::ExprScopes;\n \n pub(crate) mod scope;\n \n@@ -81,19 +81,23 @@ impl Body {\n }\n \n // needs arbitrary_self_types to be a method... or maybe move to the def?\n-pub fn resolver_for_expr(body: Arc<Body>, db: &impl HirDatabase, expr_id: ExprId) -> Resolver {\n+pub(crate) fn resolver_for_expr(\n+    body: Arc<Body>,\n+    db: &impl HirDatabase,\n+    expr_id: ExprId,\n+) -> Resolver {\n     let scopes = db.expr_scopes(body.owner);\n     resolver_for_scope(body, db, scopes.scope_for(expr_id))\n }\n \n-pub fn resolver_for_scope(\n+pub(crate) fn resolver_for_scope(\n     body: Arc<Body>,\n     db: &impl HirDatabase,\n     scope_id: Option<scope::ScopeId>,\n ) -> Resolver {\n     let mut r = body.owner.resolver(db);\n     let scopes = db.expr_scopes(body.owner);\n-    let scope_chain = scopes.scope_chain_for(scope_id).collect::<Vec<_>>();\n+    let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n     for scope in scope_chain.into_iter().rev() {\n         r = r.push_expr_scope(Arc::clone(&scopes), scope);\n     }\n@@ -117,31 +121,27 @@ impl Index<PatId> for Body {\n }\n \n impl BodySourceMap {\n-    pub fn expr_syntax(&self, expr: ExprId) -> Option<SyntaxNodePtr> {\n+    pub(crate) fn expr_syntax(&self, expr: ExprId) -> Option<SyntaxNodePtr> {\n         self.expr_map_back.get(expr).cloned()\n     }\n \n-    pub fn syntax_expr(&self, ptr: SyntaxNodePtr) -> Option<ExprId> {\n+    pub(crate) fn syntax_expr(&self, ptr: SyntaxNodePtr) -> Option<ExprId> {\n         self.expr_map.get(&ptr).cloned()\n     }\n \n-    pub fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n+    pub(crate) fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n         self.expr_map.get(&SyntaxNodePtr::new(node.syntax())).cloned()\n     }\n \n-    pub fn pat_syntax(&self, pat: PatId) -> Option<PatPtr> {\n+    pub(crate) fn pat_syntax(&self, pat: PatId) -> Option<PatPtr> {\n         self.pat_map_back.get(pat).cloned()\n     }\n \n-    pub fn syntax_pat(&self, ptr: PatPtr) -> Option<PatId> {\n-        self.pat_map.get(&ptr).cloned()\n-    }\n-\n-    pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n+    pub(crate) fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n         self.pat_map.get(&Either::A(AstPtr::new(node))).cloned()\n     }\n \n-    pub fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::NamedField> {\n+    pub(crate) fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::NamedField> {\n         self.field_map[&(expr, field)].clone()\n     }\n }"}, {"sha": "58f365128b9b749b6a28845f9fb87aede978f9d3", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 49, "deletions": 183, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -1,17 +1,11 @@\n use std::sync::Arc;\n \n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n-use ra_syntax::{\n-    AstNode, SyntaxNode, TextUnit, TextRange, SyntaxNodePtr, AstPtr,\n-    algo::generate,\n-    ast,\n-};\n+use rustc_hash::FxHashMap;\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n use crate::{\n-    Name, AsName,DefWithBody, Either,\n-    expr::{PatId, ExprId, Pat, Expr, Body, Statement, BodySourceMap},\n+    Name, DefWithBody,\n+    expr::{PatId, ExprId, Pat, Expr, Body, Statement},\n     HirDatabase,\n };\n \n@@ -23,23 +17,32 @@ impl_arena_id!(ScopeId);\n pub struct ExprScopes {\n     body: Arc<Body>,\n     scopes: Arena<ScopeId, ScopeData>,\n-    scope_for: FxHashMap<ExprId, ScopeId>,\n+    scope_by_expr: FxHashMap<ExprId, ScopeId>,\n }\n \n #[derive(Debug, PartialEq, Eq)]\n-pub struct ScopeEntry {\n+pub(crate) struct ScopeEntry {\n     name: Name,\n     pat: PatId,\n }\n \n+impl ScopeEntry {\n+    pub(crate) fn name(&self) -> &Name {\n+        &self.name\n+    }\n+\n+    pub(crate) fn pat(&self) -> PatId {\n+        self.pat\n+    }\n+}\n+\n #[derive(Debug, PartialEq, Eq)]\n-pub struct ScopeData {\n+pub(crate) struct ScopeData {\n     parent: Option<ScopeId>,\n     entries: Vec<ScopeEntry>,\n }\n \n impl ExprScopes {\n-    // FIXME: This should take something more general than Function\n     pub(crate) fn expr_scopes_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<ExprScopes> {\n         let body = db.body_hir(def);\n         let res = ExprScopes::new(body);\n@@ -50,27 +53,31 @@ impl ExprScopes {\n         let mut scopes = ExprScopes {\n             body: body.clone(),\n             scopes: Arena::default(),\n-            scope_for: FxHashMap::default(),\n+            scope_by_expr: FxHashMap::default(),\n         };\n         let root = scopes.root_scope();\n         scopes.add_params_bindings(root, body.params());\n         compute_expr_scopes(body.body_expr(), &body, &mut scopes, root);\n         scopes\n     }\n \n-    pub fn body(&self) -> Arc<Body> {\n-        self.body.clone()\n-    }\n-\n-    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+    pub(crate) fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n         &self.scopes[scope].entries\n     }\n \n-    pub fn scope_chain_for<'a>(\n+    pub(crate) fn scope_chain<'a>(\n         &'a self,\n         scope: Option<ScopeId>,\n     ) -> impl Iterator<Item = ScopeId> + 'a {\n-        generate(scope, move |&scope| self.scopes[scope].parent)\n+        std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n+    }\n+\n+    pub(crate) fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n+        self.scope_by_expr.get(&expr).map(|&scope| scope)\n+    }\n+\n+    pub(crate) fn scope_by_expr(&self) -> &FxHashMap<ExprId, ScopeId> {\n+        &self.scope_by_expr\n     }\n \n     fn root_scope(&mut self) -> ScopeId {\n@@ -99,130 +106,7 @@ impl ExprScopes {\n     }\n \n     fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n-        self.scope_for.insert(node, scope);\n-    }\n-\n-    pub fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n-        self.scope_for.get(&expr).map(|&scope| scope)\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ScopesWithSourceMap {\n-    pub source_map: Arc<BodySourceMap>,\n-    pub scopes: Arc<ExprScopes>,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ScopeEntryWithSyntax {\n-    name: Name,\n-    ptr: Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>,\n-}\n-\n-impl ScopeEntryWithSyntax {\n-    pub fn name(&self) -> &Name {\n-        &self.name\n-    }\n-\n-    pub fn ptr(&self) -> Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>> {\n-        self.ptr\n-    }\n-}\n-\n-impl ScopesWithSourceMap {\n-    fn scope_chain<'a>(&'a self, node: &SyntaxNode) -> impl Iterator<Item = ScopeId> + 'a {\n-        generate(self.scope_for(node), move |&scope| self.scopes.scopes[scope].parent)\n-    }\n-\n-    pub fn scope_for_offset(&self, offset: TextUnit) -> Option<ScopeId> {\n-        self.scopes\n-            .scope_for\n-            .iter()\n-            .filter_map(|(id, scope)| Some((self.source_map.expr_syntax(*id)?, scope)))\n-            // find containing scope\n-            .min_by_key(|(ptr, _scope)| {\n-                (!(ptr.range().start() <= offset && offset <= ptr.range().end()), ptr.range().len())\n-            })\n-            .map(|(ptr, scope)| self.adjust(ptr, *scope, offset))\n-    }\n-\n-    // XXX: during completion, cursor might be outside of any particular\n-    // expression. Try to figure out the correct scope...\n-    // FIXME: move this to source binder?\n-    fn adjust(&self, ptr: SyntaxNodePtr, original_scope: ScopeId, offset: TextUnit) -> ScopeId {\n-        let r = ptr.range();\n-        let child_scopes = self\n-            .scopes\n-            .scope_for\n-            .iter()\n-            .filter_map(|(id, scope)| Some((self.source_map.expr_syntax(*id)?, scope)))\n-            .map(|(ptr, scope)| (ptr.range(), scope))\n-            .filter(|(range, _)| range.start() <= offset && range.is_subrange(&r) && *range != r);\n-\n-        child_scopes\n-            .max_by(|(r1, _), (r2, _)| {\n-                if r2.is_subrange(&r1) {\n-                    std::cmp::Ordering::Greater\n-                } else if r1.is_subrange(&r2) {\n-                    std::cmp::Ordering::Less\n-                } else {\n-                    r1.start().cmp(&r2.start())\n-                }\n-            })\n-            .map(|(_ptr, scope)| *scope)\n-            .unwrap_or(original_scope)\n-    }\n-\n-    pub fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n-        let mut shadowed = FxHashSet::default();\n-        let name = name_ref.as_name();\n-        let ret = self\n-            .scope_chain(name_ref.syntax())\n-            .flat_map(|scope| self.scopes.entries(scope).iter())\n-            .filter(|entry| shadowed.insert(entry.name()))\n-            .filter(|entry| entry.name() == &name)\n-            .nth(0);\n-        ret.and_then(|entry| {\n-            Some(ScopeEntryWithSyntax {\n-                name: entry.name().clone(),\n-                ptr: self.source_map.pat_syntax(entry.pat())?,\n-            })\n-        })\n-    }\n-\n-    pub fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {\n-        let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n-        let ptr = Either::A(AstPtr::new(pat.into()));\n-        fn_def\n-            .syntax()\n-            .descendants()\n-            .filter_map(ast::NameRef::cast)\n-            .filter(|name_ref| match self.resolve_local_name(*name_ref) {\n-                None => false,\n-                Some(entry) => entry.ptr() == ptr,\n-            })\n-            .map(|name_ref| ReferenceDescriptor {\n-                name: name_ref.syntax().text().to_string(),\n-                range: name_ref.syntax().range(),\n-            })\n-            .collect()\n-    }\n-\n-    pub fn scope_for(&self, node: &SyntaxNode) -> Option<ScopeId> {\n-        node.ancestors()\n-            .map(SyntaxNodePtr::new)\n-            .filter_map(|ptr| self.source_map.syntax_expr(ptr))\n-            .find_map(|it| self.scopes.scope_for(it))\n-    }\n-}\n-\n-impl ScopeEntry {\n-    pub fn name(&self) -> &Name {\n-        &self.name\n-    }\n-\n-    pub fn pat(&self) -> PatId {\n-        self.pat\n+        self.scope_by_expr.insert(node, scope);\n     }\n }\n \n@@ -286,22 +170,13 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n     };\n }\n \n-#[derive(Debug)]\n-pub struct ReferenceDescriptor {\n-    pub range: TextRange,\n-    pub name: String,\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use ra_db::salsa::InternKey;\n-    use ra_syntax::{SourceFile, algo::find_node_at_offset};\n+    use ra_db::SourceDatabase;\n+    use ra_syntax::{algo::find_node_at_offset, AstNode, SyntaxNodePtr, ast};\n     use test_utils::{extract_offset, assert_eq_text};\n-    use crate::Function;\n-\n-    use crate::expr::{ExprCollector};\n \n-    use super::*;\n+    use crate::{source_binder::SourceAnalyzer, mock::MockDatabase};\n \n     fn do_check(code: &str, expected: &[&str]) {\n         let (off, code) = extract_offset(code);\n@@ -313,18 +188,20 @@ mod tests {\n             buf.push_str(&code[off..]);\n             buf\n         };\n-        let file = SourceFile::parse(&code);\n+\n+        let (db, _source_root, file_id) = MockDatabase::with_single_file(&code);\n+        let file = db.parse(file_id);\n         let marker: &ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n-        let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let irrelevant_function =\n-            Function { id: crate::ids::FunctionId::from_intern_id(0u32.into()) };\n-        let (body, source_map) = collect_fn_body_syntax(irrelevant_function, fn_def);\n-        let scopes = ExprScopes::new(Arc::new(body));\n-        let scopes =\n-            ScopesWithSourceMap { scopes: Arc::new(scopes), source_map: Arc::new(source_map) };\n+        let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n+\n+        let scopes = analyzer.scopes();\n+        let expr_id =\n+            analyzer.body_source_map().syntax_expr(SyntaxNodePtr::new(marker.syntax())).unwrap();\n+        let scope = scopes.scope_for(expr_id);\n+\n         let actual = scopes\n-            .scope_chain(marker.syntax())\n-            .flat_map(|scope| scopes.scopes.entries(scope))\n+            .scope_chain(scope)\n+            .flat_map(|scope| scopes.entries(scope))\n             .map(|it| it.name().to_string())\n             .collect::<Vec<_>>()\n             .join(\"\\n\");\n@@ -407,28 +284,17 @@ mod tests {\n         );\n     }\n \n-    fn collect_fn_body_syntax(function: Function, node: &ast::FnDef) -> (Body, BodySourceMap) {\n-        let mut collector = ExprCollector::new(DefWithBody::Function(function));\n-        collector.collect_fn_body(node);\n-        collector.finish()\n-    }\n-\n     fn do_check_local_name(code: &str, expected_offset: u32) {\n         let (off, code) = extract_offset(code);\n-        let file = SourceFile::parse(&code);\n+\n+        let (db, _source_root, file_id) = MockDatabase::with_single_file(&code);\n+        let file = db.parse(file_id);\n         let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n             .expect(\"failed to find a name at the target offset\");\n-\n-        let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n         let name_ref: &ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let analyzer = SourceAnalyzer::new(&db, file_id, name_ref.syntax(), None);\n \n-        let irrelevant_function =\n-            Function { id: crate::ids::FunctionId::from_intern_id(0u32.into()) };\n-        let (body, source_map) = collect_fn_body_syntax(irrelevant_function, fn_def);\n-        let scopes = ExprScopes::new(Arc::new(body));\n-        let scopes =\n-            ScopesWithSourceMap { scopes: Arc::new(scopes), source_map: Arc::new(source_map) };\n-        let local_name_entry = scopes.resolve_local_name(name_ref).unwrap();\n+        let local_name_entry = analyzer.resolve_local_name(name_ref).unwrap();\n         let local_name =\n             local_name_entry.ptr().either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n         assert_eq!(local_name.range(), expected_name.syntax().range());"}, {"sha": "b306874cc109e260a2c1ef4270921335e0061198", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -105,7 +105,7 @@ impl ImplBlock {\n         db.generic_params((*self).into())\n     }\n \n-    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         let r = self.module().resolver(db);\n         // add generic params, if present\n         let p = self.generic_params(db);"}, {"sha": "a9db23060d3680466d3cd200772bacfd1c5750e6", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -51,6 +51,7 @@ use crate::{\n     db::{HirDatabase, DefDatabase},\n     name::{AsName, KnownName},\n     source_id::{FileAstId, AstId},\n+    resolve::Resolver,\n };\n \n pub use self::{\n@@ -60,12 +61,13 @@ pub use self::{\n     source_id::{AstIdMap, ErasedFileAstId},\n     ids::{HirFileId, MacroDefId, MacroCallId, MacroCallLoc},\n     nameres::{PerNs, Namespace, ImportId},\n-    ty::{Ty, ApplicationTy, TypeCtor, Substs, display::HirDisplay},\n+    ty::{Ty, ApplicationTy, TypeCtor, Substs, display::HirDisplay, CallableDef},\n     impl_block::{ImplBlock, ImplItem},\n     docs::{Docs, Documentation},\n     adt::AdtDef,\n-    expr::{ExprScopes, ScopesWithSourceMap, ScopeEntryWithSyntax},\n-    resolve::{Resolver, Resolution},\n+    expr::ExprScopes,\n+    resolve::Resolution,\n+    source_binder::{SourceAnalyzer, PathResolution, ScopeEntryWithSyntax},\n };\n \n pub use self::code_model_api::{"}, {"sha": "685f4b8b1609b1cab25a6a35dbd8f3f31eedb0fc", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -9,13 +9,13 @@ use crate::{\n     name::{Name, KnownName},\n     nameres::{PerNs, CrateDefMap, CrateModuleId},\n     generics::GenericParams,\n-    expr::{scope::{ExprScopes, ScopeId}, PatId, Body},\n+    expr::{scope::{ExprScopes, ScopeId}, PatId},\n     impl_block::ImplBlock,\n     path::Path, Trait\n };\n \n #[derive(Debug, Clone, Default)]\n-pub struct Resolver {\n+pub(crate) struct Resolver {\n     scopes: Vec<Scope>,\n }\n \n@@ -117,7 +117,7 @@ pub enum Resolution {\n }\n \n impl Resolver {\n-    pub fn resolve_name(&self, db: &impl HirDatabase, name: &Name) -> PerNs<Resolution> {\n+    pub(crate) fn resolve_name(&self, db: &impl HirDatabase, name: &Name) -> PerNs<Resolution> {\n         let mut resolution = PerNs::none();\n         for scope in self.scopes.iter().rev() {\n             resolution = resolution.or(scope.resolve_name(db, name));\n@@ -154,12 +154,12 @@ impl Resolver {\n \n     /// Returns the fully resolved path if we were able to resolve it.\n     /// otherwise returns `PerNs::none`\n-    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<Resolution> {\n+    pub(crate) fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<Resolution> {\n         // into_fully_resolved() returns the fully resolved path or PerNs::none() otherwise\n         self.resolve_path_segments(db, path).into_fully_resolved()\n     }\n \n-    pub fn all_names(&self, db: &impl HirDatabase) -> FxHashMap<Name, PerNs<Resolution>> {\n+    pub(crate) fn all_names(&self, db: &impl HirDatabase) -> FxHashMap<Name, PerNs<Resolution>> {\n         let mut names = FxHashMap::default();\n         for scope in self.scopes.iter().rev() {\n             scope.collect_names(db, &mut |name, res| {\n@@ -197,14 +197,6 @@ impl Resolver {\n             _ => None,\n         })\n     }\n-\n-    /// The body from which any `LocalBinding` resolutions in this resolver come.\n-    pub fn body(&self) -> Option<Arc<Body>> {\n-        self.scopes.iter().rev().find_map(|scope| match scope {\n-            Scope::ExprScope(expr_scope) => Some(expr_scope.expr_scopes.body()),\n-            _ => None,\n-        })\n-    }\n }\n \n impl Resolver {"}, {"sha": "bd035ced95dd7d3b07cb7dba110a5a8fc6530a63", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 281, "deletions": 125, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -5,16 +5,21 @@\n ///\n /// So, this modules should not be used during hir construction, it exists\n /// purely for \"IDE needs\".\n+use std::sync::Arc;\n+\n+use rustc_hash::{FxHashSet, FxHashMap};\n use ra_db::{FileId, FilePosition};\n use ra_syntax::{\n-    SyntaxNode,\n+    SyntaxNode, AstPtr, TextUnit, SyntaxNodePtr, TextRange,\n     ast::{self, AstNode, NameOwner},\n-    algo::{find_node_at_offset, find_token_at_offset},\n+    algo::find_node_at_offset,\n+    SyntaxKind::*,\n };\n \n use crate::{\n-    HirDatabase, Function, Struct, Enum,Const,Static,\n+    HirDatabase, Function, Struct, Enum, Const, Static, Either, DefWithBody, PerNs, Name,\n     AsName, Module, HirFileId, Crate, Trait, Resolver,\n+    expr::{BodySourceMap, scope::{ScopeId, ExprScopes}},\n     ids::LocationCtx,\n     expr, AstId\n };\n@@ -87,63 +92,6 @@ fn module_from_source(\n     )\n }\n \n-pub fn const_from_source(\n-    db: &impl HirDatabase,\n-    file_id: FileId,\n-    const_def: &ast::ConstDef,\n-) -> Option<Const> {\n-    let module = module_from_child_node(db, file_id, const_def.syntax())?;\n-    let res = const_from_module(db, module, const_def);\n-    Some(res)\n-}\n-\n-pub fn const_from_module(\n-    db: &impl HirDatabase,\n-    module: Module,\n-    const_def: &ast::ConstDef,\n-) -> Const {\n-    let (file_id, _) = module.definition_source(db);\n-    let file_id = file_id.into();\n-    let ctx = LocationCtx::new(db, module, file_id);\n-    Const { id: ctx.to_def(const_def) }\n-}\n-\n-pub fn function_from_position(db: &impl HirDatabase, position: FilePosition) -> Option<Function> {\n-    let file = db.parse(position.file_id);\n-    let fn_def = find_node_at_offset::<ast::FnDef>(file.syntax(), position.offset)?;\n-    function_from_source(db, position.file_id, fn_def)\n-}\n-\n-pub fn function_from_source(\n-    db: &impl HirDatabase,\n-    file_id: FileId,\n-    fn_def: &ast::FnDef,\n-) -> Option<Function> {\n-    let module = module_from_child_node(db, file_id, fn_def.syntax())?;\n-    let res = function_from_module(db, module, fn_def);\n-    Some(res)\n-}\n-\n-pub fn function_from_module(\n-    db: &impl HirDatabase,\n-    module: Module,\n-    fn_def: &ast::FnDef,\n-) -> Function {\n-    let (file_id, _) = module.definition_source(db);\n-    let file_id = file_id.into();\n-    let ctx = LocationCtx::new(db, module, file_id);\n-    Function { id: ctx.to_def(fn_def) }\n-}\n-\n-pub fn function_from_child_node(\n-    db: &impl HirDatabase,\n-    file_id: FileId,\n-    node: &SyntaxNode,\n-) -> Option<Function> {\n-    let fn_def = node.ancestors().find_map(ast::FnDef::cast)?;\n-    function_from_source(db, file_id, fn_def)\n-}\n-\n pub fn struct_from_module(\n     db: &impl HirDatabase,\n     module: Module,\n@@ -155,27 +103,6 @@ pub fn struct_from_module(\n     Struct { id: ctx.to_def(struct_def) }\n }\n \n-pub fn static_from_source(\n-    db: &impl HirDatabase,\n-    file_id: FileId,\n-    static_def: &ast::StaticDef,\n-) -> Option<Static> {\n-    let module = module_from_child_node(db, file_id, static_def.syntax())?;\n-    let res = static_from_module(db, module, static_def);\n-    Some(res)\n-}\n-\n-pub fn static_from_module(\n-    db: &impl HirDatabase,\n-    module: Module,\n-    static_def: &ast::StaticDef,\n-) -> Static {\n-    let (file_id, _) = module.definition_source(db);\n-    let file_id = file_id.into();\n-    let ctx = LocationCtx::new(db, module, file_id);\n-    Static { id: ctx.to_def(static_def) }\n-}\n-\n pub fn enum_from_module(db: &impl HirDatabase, module: Module, enum_def: &ast::EnumDef) -> Enum {\n     let (file_id, _) = module.definition_source(db);\n     let file_id = file_id.into();\n@@ -194,48 +121,6 @@ pub fn trait_from_module(\n     Trait { id: ctx.to_def(trait_def) }\n }\n \n-pub fn resolver_for_position(db: &impl HirDatabase, position: FilePosition) -> Resolver {\n-    let file_id = position.file_id;\n-    let file = db.parse(file_id);\n-    find_token_at_offset(file.syntax(), position.offset)\n-        .find_map(|token| {\n-            token.parent().ancestors().find_map(|node| {\n-                if ast::Expr::cast(node).is_some() || ast::Block::cast(node).is_some() {\n-                    if let Some(func) = function_from_child_node(db, file_id, node) {\n-                        let scopes = func.scopes(db);\n-                        let scope = scopes.scope_for_offset(position.offset);\n-                        Some(expr::resolver_for_scope(func.body(db), db, scope))\n-                    } else {\n-                        // FIXME const/static/array length\n-                        None\n-                    }\n-                } else {\n-                    try_get_resolver_for_node(db, file_id, node)\n-                }\n-            })\n-        })\n-        .unwrap_or_default()\n-}\n-\n-pub fn resolver_for_node(db: &impl HirDatabase, file_id: FileId, node: &SyntaxNode) -> Resolver {\n-    node.ancestors()\n-        .find_map(|node| {\n-            if ast::Expr::cast(node).is_some() || ast::Block::cast(node).is_some() {\n-                if let Some(func) = function_from_child_node(db, file_id, node) {\n-                    let scopes = func.scopes(db);\n-                    let scope = scopes.scope_for(&node);\n-                    Some(expr::resolver_for_scope(func.body(db), db, scope))\n-                } else {\n-                    // FIXME const/static/array length\n-                    None\n-                }\n-            } else {\n-                try_get_resolver_for_node(db, file_id, node)\n-            }\n-        })\n-        .unwrap_or_default()\n-}\n-\n fn try_get_resolver_for_node(\n     db: &impl HirDatabase,\n     file_id: FileId,\n@@ -251,10 +136,281 @@ fn try_get_resolver_for_node(\n     } else if let Some(e) = ast::EnumDef::cast(node) {\n         let module = module_from_child_node(db, file_id, e.syntax())?;\n         Some(enum_from_module(db, module, e).resolver(db))\n-    } else if let Some(f) = ast::FnDef::cast(node) {\n-        function_from_source(db, file_id, f).map(|f| f.resolver(db))\n+    } else if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n+        Some(def_with_body_from_child_node(db, file_id, node)?.resolver(db))\n     } else {\n         // FIXME add missing cases\n         None\n     }\n }\n+\n+fn def_with_body_from_child_node(\n+    db: &impl HirDatabase,\n+    file_id: FileId,\n+    node: &SyntaxNode,\n+) -> Option<DefWithBody> {\n+    let module = module_from_child_node(db, file_id, node)?;\n+    let ctx = LocationCtx::new(db, module, file_id.into());\n+    node.ancestors().find_map(|node| {\n+        if let Some(def) = ast::FnDef::cast(node) {\n+            return Some(Function { id: ctx.to_def(def) }.into());\n+        }\n+        if let Some(def) = ast::ConstDef::cast(node) {\n+            return Some(Const { id: ctx.to_def(def) }.into());\n+        }\n+        if let Some(def) = ast::StaticDef::cast(node) {\n+            return Some(Static { id: ctx.to_def(def) }.into());\n+        }\n+        None\n+    })\n+}\n+\n+/// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n+/// original source files. It should not be used inside the HIR itself.\n+#[derive(Debug)]\n+pub struct SourceAnalyzer {\n+    resolver: Resolver,\n+    body_source_map: Option<Arc<BodySourceMap>>,\n+    infer: Option<Arc<crate::ty::InferenceResult>>,\n+    scopes: Option<Arc<crate::expr::ExprScopes>>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum PathResolution {\n+    /// An item\n+    Def(crate::ModuleDef),\n+    /// A local binding (only value namespace)\n+    LocalBinding(Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>),\n+    /// A generic parameter\n+    GenericParam(u32),\n+    SelfType(crate::ImplBlock),\n+    AssocItem(crate::ImplItem),\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ScopeEntryWithSyntax {\n+    pub(crate) name: Name,\n+    pub(crate) ptr: Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>,\n+}\n+\n+impl ScopeEntryWithSyntax {\n+    pub fn name(&self) -> &Name {\n+        &self.name\n+    }\n+\n+    pub fn ptr(&self) -> Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>> {\n+        self.ptr\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ReferenceDescriptor {\n+    pub range: TextRange,\n+    pub name: String,\n+}\n+\n+impl SourceAnalyzer {\n+    pub fn new(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        node: &SyntaxNode,\n+        offset: Option<TextUnit>,\n+    ) -> SourceAnalyzer {\n+        let def_with_body = def_with_body_from_child_node(db, file_id, node);\n+        if let Some(def) = def_with_body {\n+            let source_map = def.body_source_map(db);\n+            let scopes = db.expr_scopes(def);\n+            let scope = match offset {\n+                None => scope_for(&scopes, &source_map, &node),\n+                Some(offset) => scope_for_offset(&scopes, &source_map, offset),\n+            };\n+            let resolver = expr::resolver_for_scope(def.body(db), db, scope);\n+            SourceAnalyzer {\n+                resolver,\n+                body_source_map: Some(source_map),\n+                infer: Some(def.infer(db)),\n+                scopes: Some(scopes),\n+            }\n+        } else {\n+            SourceAnalyzer {\n+                resolver: node\n+                    .ancestors()\n+                    .find_map(|node| try_get_resolver_for_node(db, file_id, node))\n+                    .unwrap_or_default(),\n+                body_source_map: None,\n+                infer: None,\n+                scopes: None,\n+            }\n+        }\n+    }\n+\n+    pub fn type_of(&self, _db: &impl HirDatabase, expr: &ast::Expr) -> Option<crate::Ty> {\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(expr)?;\n+        Some(self.infer.as_ref()?[expr_id].clone())\n+    }\n+\n+    pub fn type_of_pat(&self, _db: &impl HirDatabase, pat: &ast::Pat) -> Option<crate::Ty> {\n+        let pat_id = self.body_source_map.as_ref()?.node_pat(pat)?;\n+        Some(self.infer.as_ref()?[pat_id].clone())\n+    }\n+\n+    pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(call.into())?;\n+        self.infer.as_ref()?.method_resolution(expr_id)\n+    }\n+\n+    pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<crate::StructField> {\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(field.into())?;\n+        self.infer.as_ref()?.field_resolution(expr_id)\n+    }\n+\n+    pub fn resolve_hir_path(\n+        &self,\n+        db: &impl HirDatabase,\n+        path: &crate::Path,\n+    ) -> PerNs<crate::Resolution> {\n+        self.resolver.resolve_path(db, path)\n+    }\n+\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &ast::Path) -> Option<PathResolution> {\n+        if let Some(path_expr) = path.syntax().parent().and_then(ast::PathExpr::cast) {\n+            let expr_id = self.body_source_map.as_ref()?.node_expr(path_expr.into())?;\n+            if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_expr(expr_id) {\n+                return Some(PathResolution::AssocItem(assoc));\n+            }\n+        }\n+        if let Some(path_pat) = path.syntax().parent().and_then(ast::PathPat::cast) {\n+            let pat_id = self.body_source_map.as_ref()?.node_pat(path_pat.into())?;\n+            if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_pat(pat_id) {\n+                return Some(PathResolution::AssocItem(assoc));\n+            }\n+        }\n+        let hir_path = crate::Path::from_ast(path)?;\n+        let res = self.resolver.resolve_path(db, &hir_path);\n+        let res = res.clone().take_types().or_else(|| res.take_values())?;\n+        let res = match res {\n+            crate::Resolution::Def(it) => PathResolution::Def(it),\n+            crate::Resolution::LocalBinding(it) => {\n+                PathResolution::LocalBinding(self.body_source_map.as_ref()?.pat_syntax(it)?)\n+            }\n+            crate::Resolution::GenericParam(it) => PathResolution::GenericParam(it),\n+            crate::Resolution::SelfType(it) => PathResolution::SelfType(it),\n+        };\n+        Some(res)\n+    }\n+\n+    pub fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n+        let mut shadowed = FxHashSet::default();\n+        let name = name_ref.as_name();\n+        let source_map = self.body_source_map.as_ref()?;\n+        let scopes = self.scopes.as_ref()?;\n+        let scope = scope_for(scopes, source_map, name_ref.syntax());\n+        let ret = scopes\n+            .scope_chain(scope)\n+            .flat_map(|scope| scopes.entries(scope).iter())\n+            .filter(|entry| shadowed.insert(entry.name()))\n+            .filter(|entry| entry.name() == &name)\n+            .nth(0);\n+        ret.and_then(|entry| {\n+            Some(ScopeEntryWithSyntax {\n+                name: entry.name().clone(),\n+                ptr: source_map.pat_syntax(entry.pat())?,\n+            })\n+        })\n+    }\n+\n+    pub fn all_names(&self, db: &impl HirDatabase) -> FxHashMap<Name, PerNs<crate::Resolution>> {\n+        self.resolver.all_names(db)\n+    }\n+\n+    pub fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {\n+        // FIXME: at least, this should work with any DefWithBody, but ideally\n+        // this should be hir-based altogether\n+        let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n+        let ptr = Either::A(AstPtr::new(pat.into()));\n+        fn_def\n+            .syntax()\n+            .descendants()\n+            .filter_map(ast::NameRef::cast)\n+            .filter(|name_ref| match self.resolve_local_name(*name_ref) {\n+                None => false,\n+                Some(entry) => entry.ptr() == ptr,\n+            })\n+            .map(|name_ref| ReferenceDescriptor {\n+                name: name_ref.text().to_string(),\n+                range: name_ref.syntax().range(),\n+            })\n+            .collect()\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn body_source_map(&self) -> Arc<BodySourceMap> {\n+        self.body_source_map.clone().unwrap()\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn inference_result(&self) -> Arc<crate::ty::InferenceResult> {\n+        self.infer.clone().unwrap()\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn scopes(&self) -> Arc<ExprScopes> {\n+        self.scopes.clone().unwrap()\n+    }\n+}\n+\n+fn scope_for(\n+    scopes: &ExprScopes,\n+    source_map: &BodySourceMap,\n+    node: &SyntaxNode,\n+) -> Option<ScopeId> {\n+    node.ancestors()\n+        .map(SyntaxNodePtr::new)\n+        .filter_map(|ptr| source_map.syntax_expr(ptr))\n+        .find_map(|it| scopes.scope_for(it))\n+}\n+\n+fn scope_for_offset(\n+    scopes: &ExprScopes,\n+    source_map: &BodySourceMap,\n+    offset: TextUnit,\n+) -> Option<ScopeId> {\n+    scopes\n+        .scope_by_expr()\n+        .iter()\n+        .filter_map(|(id, scope)| Some((source_map.expr_syntax(*id)?, scope)))\n+        // find containing scope\n+        .min_by_key(|(ptr, _scope)| {\n+            (!(ptr.range().start() <= offset && offset <= ptr.range().end()), ptr.range().len())\n+        })\n+        .map(|(ptr, scope)| adjust(scopes, source_map, ptr, offset).unwrap_or(*scope))\n+}\n+\n+// XXX: during completion, cursor might be outside of any particular\n+// expression. Try to figure out the correct scope...\n+fn adjust(\n+    scopes: &ExprScopes,\n+    source_map: &BodySourceMap,\n+    ptr: SyntaxNodePtr,\n+    offset: TextUnit,\n+) -> Option<ScopeId> {\n+    let r = ptr.range();\n+    let child_scopes = scopes\n+        .scope_by_expr()\n+        .iter()\n+        .filter_map(|(id, scope)| Some((source_map.expr_syntax(*id)?, scope)))\n+        .map(|(ptr, scope)| (ptr.range(), scope))\n+        .filter(|(range, _)| range.start() <= offset && range.is_subrange(&r) && *range != r);\n+\n+    child_scopes\n+        .max_by(|(r1, _), (r2, _)| {\n+            if r2.is_subrange(&r1) {\n+                std::cmp::Ordering::Greater\n+            } else if r1.is_subrange(&r2) {\n+                std::cmp::Ordering::Less\n+            } else {\n+                r1.start().cmp(&r2.start())\n+            }\n+        })\n+        .map(|(_ptr, scope)| *scope)\n+}"}, {"sha": "ecf13fbc30029a867df4c0992c41e755221c74ed", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -15,10 +15,11 @@ use std::sync::Arc;\n use std::{fmt, mem};\n \n use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait};\n+use display::{HirDisplay, HirFormatter};\n \n-pub(crate) use lower::{TypableDef, CallableDef, type_for_def, type_for_field, callable_item_sig};\n+pub(crate) use lower::{TypableDef, type_for_def, type_for_field, callable_item_sig};\n pub(crate) use infer::{infer, InferenceResult, InferTy};\n-use display::{HirDisplay, HirFormatter};\n+pub use lower::CallableDef;\n \n /// A type constructor or type name: this might be something like the primitive\n /// type `bool`, a struct like `Vec`, or things like function pointers or\n@@ -288,6 +289,15 @@ impl Ty {\n         }\n     }\n \n+    pub fn as_callable(&self) -> Option<(CallableDef, &Substs)> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::FnDef(callable_def), parameters }) => {\n+                Some((*callable_def, parameters))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     fn builtin_deref(&self) -> Option<Ty> {\n         match self {\n             Ty::Apply(a_ty) => match a_ty.ctor {"}, {"sha": "bb23246a6afa716109d9414fb37ffec7b501d738", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -135,7 +135,7 @@ fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n impl Ty {\n     /// Look up the method with the given name, returning the actual autoderefed\n     /// receiver type (but without autoref applied yet).\n-    pub fn lookup_method(\n+    pub(crate) fn lookup_method(\n         self,\n         db: &impl HirDatabase,\n         name: &Name,"}, {"sha": "d7c2ca132db929ec8f03ec0810dd4edea607aeb9", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 25, "deletions": 37, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -4,15 +4,15 @@ use std::fmt::Write;\n use insta::assert_snapshot_matches;\n \n use ra_db::{SourceDatabase, salsa::Database, FilePosition};\n-use ra_syntax::{algo, ast::{self, AstNode}};\n+use ra_syntax::{algo, ast::{self, AstNode}, SyntaxKind::*};\n use test_utils::covers;\n \n use crate::{\n-    source_binder,\n     mock::MockDatabase,\n     ty::display::HirDisplay,\n     ty::InferenceResult,\n-    expr::BodySourceMap\n+    expr::BodySourceMap,\n+    SourceAnalyzer,\n };\n \n // These tests compare the inference results for all expressions in a file\n@@ -1862,14 +1862,14 @@ fn test() {\n         @r###\"\n [49; 50) '0': u32\n [80; 83) '101': u32\n-[126; 128) '99': u32\n [95; 213) '{     ...NST; }': ()\n [138; 139) 'x': {unknown}\n [142; 153) 'LOCAL_CONST': {unknown}\n [163; 164) 'z': u32\n [167; 179) 'GLOBAL_CONST': u32\n [189; 191) 'id': u32\n-[194; 210) 'Foo::A..._CONST': u32\"###\n+[194; 210) 'Foo::A..._CONST': u32\n+[126; 128) '99': u32\"###\n     );\n }\n \n@@ -1891,8 +1891,6 @@ fn test() {\n         @r###\"\n [29; 32) '101': u32\n [70; 73) '101': u32\n-[118; 120) '99': u32\n-[161; 163) '99': u32\n [85; 280) '{     ...MUT; }': ()\n [173; 174) 'x': {unknown}\n [177; 189) 'LOCAL_STATIC': {unknown}\n@@ -1901,7 +1899,9 @@ fn test() {\n [229; 230) 'z': u32\n [233; 246) 'GLOBAL_STATIC': u32\n [256; 257) 'w': u32\n-[260; 277) 'GLOBAL...IC_MUT': u32\"###\n+[260; 277) 'GLOBAL...IC_MUT': u32\n+[118; 120) '99': u32\n+[161; 163) '99': u32\"###\n     );\n }\n \n@@ -2302,13 +2302,10 @@ fn test() -> u64 {\n }\n \n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n-    let func = source_binder::function_from_position(db, pos).unwrap();\n-    let body_source_map = func.body_source_map(db);\n-    let inference_result = func.infer(db);\n-    let (_, syntax) = func.source(db);\n-    let node = algo::find_node_at_offset::<ast::Expr>(syntax.syntax(), pos.offset).unwrap();\n-    let expr = body_source_map.node_expr(node).unwrap();\n-    let ty = &inference_result[expr];\n+    let file = db.parse(pos.file_id);\n+    let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n+    let analyzer = SourceAnalyzer::new(db, pos.file_id, expr.syntax(), Some(pos.offset));\n+    let ty = analyzer.type_of(db, expr).unwrap();\n     ty.display(db).to_string()\n }\n \n@@ -2350,25 +2347,11 @@ fn infer(content: &str) -> String {\n         }\n     };\n \n-    for const_def in source_file.syntax().descendants().filter_map(ast::ConstDef::cast) {\n-        let konst = source_binder::const_from_source(&db, file_id, const_def).unwrap();\n-        let inference_result = konst.infer(&db);\n-        let body_source_map = konst.body_source_map(&db);\n-        infer_def(inference_result, body_source_map)\n-    }\n-\n-    for static_def in source_file.syntax().descendants().filter_map(ast::StaticDef::cast) {\n-        let static_ = source_binder::static_from_source(&db, file_id, static_def).unwrap();\n-        let inference_result = static_.infer(&db);\n-        let body_source_map = static_.body_source_map(&db);\n-        infer_def(inference_result, body_source_map)\n-    }\n-\n-    for fn_def in source_file.syntax().descendants().filter_map(ast::FnDef::cast) {\n-        let func = source_binder::function_from_source(&db, file_id, fn_def).unwrap();\n-        let inference_result = func.infer(&db);\n-        let body_source_map = func.body_source_map(&db);\n-        infer_def(inference_result, body_source_map)\n+    for node in source_file.syntax().descendants() {\n+        if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n+            let analyzer = SourceAnalyzer::new(&db, file_id, node, None);\n+            infer_def(analyzer.inference_result(), analyzer.body_source_map());\n+        }\n     }\n \n     acc.truncate(acc.trim_end().len());\n@@ -2403,10 +2386,12 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n         }\n     \",\n     );\n-    let func = source_binder::function_from_position(&db, pos).unwrap();\n     {\n+        let file = db.parse(pos.file_id);\n+        let node =\n+            algo::find_token_at_offset(file.syntax(), pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            func.infer(&db);\n+            SourceAnalyzer::new(&db, pos.file_id, node, None);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"infer\"))\n     }\n@@ -2423,8 +2408,11 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n     db.query_mut(ra_db::FileTextQuery).set(pos.file_id, Arc::new(new_text));\n \n     {\n+        let file = db.parse(pos.file_id);\n+        let node =\n+            algo::find_token_at_offset(file.syntax(), pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            func.infer(&db);\n+            SourceAnalyzer::new(&db, pos.file_id, node, None);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }"}, {"sha": "4413aec7378d48ad7078751b31b8f6a217c0c82f", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -2,7 +2,6 @@ use test_utils::tested_by;\n use ra_db::SourceDatabase;\n use ra_syntax::{\n     AstNode, SyntaxNode, TextUnit,\n-    SyntaxKind::FN_DEF,\n     ast::{self, ArgListOwner},\n     algo::find_node_at_offset,\n };\n@@ -18,19 +17,26 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     let calling_node = FnCallNode::with_node(syntax, position.offset)?;\n     let name_ref = calling_node.name_ref()?;\n \n-    // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n-    let file_symbols = crate::symbol_index::index_resolve(db, name_ref);\n-    let symbol = file_symbols.into_iter().find(|it| it.ptr.kind() == FN_DEF)?;\n-    let fn_file = db.parse(symbol.file_id);\n-    let fn_def = symbol.ptr.to_node(&fn_file);\n-    let fn_def = ast::FnDef::cast(fn_def).unwrap();\n-    let function = hir::source_binder::function_from_source(db, symbol.file_id, fn_def)?;\n+    let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n+    let function = match calling_node {\n+        FnCallNode::CallExpr(expr) => {\n+            //FIXME: apply subst\n+            let (callable_def, _subst) =\n+                analyzer.type_of(db, expr.expr()?.into())?.as_callable()?;\n+            match callable_def {\n+                hir::CallableDef::Function(it) => it,\n+                //FIXME: handle other callables\n+                _ => return None,\n+            }\n+        }\n+        FnCallNode::MethodCallExpr(expr) => analyzer.resolve_method_call(expr)?,\n+    };\n \n     let mut call_info = CallInfo::new(db, function);\n \n     // If we have a calling expression let's find which argument we are on\n     let num_params = call_info.parameters().len();\n-    let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n+    let has_self = function.signature(db).has_self_param();\n \n     if num_params == 1 {\n         if !has_self {\n@@ -74,7 +80,7 @@ enum FnCallNode<'a> {\n }\n \n impl<'a> FnCallNode<'a> {\n-    pub fn with_node(syntax: &'a SyntaxNode, offset: TextUnit) -> Option<FnCallNode<'a>> {\n+    fn with_node(syntax: &'a SyntaxNode, offset: TextUnit) -> Option<FnCallNode<'a>> {\n         if let Some(expr) = find_node_at_offset::<ast::CallExpr>(syntax, offset) {\n             return Some(FnCallNode::CallExpr(expr));\n         }\n@@ -84,7 +90,7 @@ impl<'a> FnCallNode<'a> {\n         None\n     }\n \n-    pub fn name_ref(&self) -> Option<&'a ast::NameRef> {\n+    fn name_ref(&self) -> Option<&'a ast::NameRef> {\n         match *self {\n             FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()?.kind() {\n                 ast::ExprKind::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n@@ -97,7 +103,7 @@ impl<'a> FnCallNode<'a> {\n         }\n     }\n \n-    pub fn arg_list(&self) -> Option<&'a ast::ArgList> {\n+    fn arg_list(&self) -> Option<&'a ast::ArgList> {\n         match *self {\n             FnCallNode::CallExpr(expr) => expr.arg_list(),\n             FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n@@ -142,7 +148,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_fn_signature_two_args_first() {\n+    fn test_fn_signature_two_args_firstx() {\n         let info = call_info(\n             r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n fn bar() { foo(<|>3, ); }\"#,\n@@ -382,11 +388,9 @@ assert_eq!(6, my_crate::add_one(5));\n     fn test_fn_signature_with_docs_from_actix() {\n         let info = call_info(\n             r#\"\n-pub trait WriteHandler<E>\n-where\n-    Self: Actor,\n-    Self::Context: ActorContext,\n-{\n+struct WriteHandler<E>;\n+\n+impl<E> WriteHandler<E> {\n     /// Method is called when writer emits error.\n     ///\n     /// If this method returns `ErrorAction::Continue` writer processing\n@@ -403,8 +407,7 @@ where\n     }\n }\n \n-pub fn foo() {\n-    WriteHandler r;\n+pub fn foo(mut r: WriteHandler<()>) {\n     r.finished(<|>);\n }\n "}, {"sha": "4a111aba5a9bf9b955c544a55577dbcb224dcf07", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -4,17 +4,10 @@ use crate::completion::{CompletionContext, Completions};\n \n /// Complete dot accesses, i.e. fields or methods (currently only fields).\n pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (function, receiver) = match (&ctx.function, ctx.dot_receiver) {\n-        (Some(function), Some(receiver)) => (function, receiver),\n-        _ => return,\n-    };\n-    let infer_result = function.infer(ctx.db);\n-    let source_map = function.body_source_map(ctx.db);\n-    let expr = match source_map.node_expr(receiver) {\n-        Some(expr) => expr,\n+    let receiver_ty = match ctx.dot_receiver.and_then(|it| ctx.analyzer.type_of(ctx.db, it)) {\n+        Some(it) => it,\n         None => return,\n     };\n-    let receiver_ty = infer_result[expr].clone();\n     if !ctx.is_call {\n         complete_fields(acc, ctx, receiver_ty.clone());\n     }\n@@ -312,6 +305,30 @@ mod tests {\n         kind: Method,\n         detail: \"pub fn blah(&self)\"\n     }\n+]\"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_works_in_consts() {\n+        assert_debug_snapshot_matches!(\n+        do_ref_completion(\n+            r\"\n+            struct A { the_field: u32 }\n+            const X: u32 = {\n+                A { the_field: 92 }.<|>\n+            };\n+            \",\n+        ),\n+        @r###\"[\n+    CompletionItem {\n+        label: \"the_field\",\n+        source_range: [106; 106),\n+        delete: [106; 106),\n+        insert: \"the_field\",\n+        kind: Field,\n+        detail: \"u32\"\n+    }\n ]\"###\n         );\n     }"}, {"sha": "bc03a70957a3a21bab0a75c32dcfcb9f248f49e7", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -9,7 +9,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         Some(path) => path.clone(),\n         _ => return,\n     };\n-    let def = match ctx.resolver.resolve_path(ctx.db, &path).take_types() {\n+    let def = match ctx.analyzer.resolve_hir_path(ctx.db, &path).take_types() {\n         Some(Resolution::Def(def)) => def,\n         _ => return,\n     };"}, {"sha": "0ef248687964cdbb25950f77e6c676d82772895a", "filename": "crates/ra_ide_api/src/completion/complete_pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -7,7 +7,7 @@ pub(super) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n     }\n     // FIXME: ideally, we should look at the type we are matching against and\n     // suggest variants + auto-imports\n-    let names = ctx.resolver.all_names(ctx.db);\n+    let names = ctx.analyzer.all_names(ctx.db);\n     for (name, res) in names.into_iter() {\n         let r = res.as_ref();\n         let def = match r.take_types().or(r.take_values()) {"}, {"sha": "fd256fc3b342ba7f754cec66e005d6bebb51bf34", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -4,7 +4,7 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.is_trivial_path {\n         return;\n     }\n-    let names = ctx.resolver.all_names(ctx.db);\n+    let names = ctx.analyzer.all_names(ctx.db);\n \n     names.into_iter().for_each(|(name, res)| acc.add_resolution(ctx, name.to_string(), &res));\n }"}, {"sha": "48fbf67f74f906448037ba75579dc956ae0e0fcd", "filename": "crates/ra_ide_api/src/completion/complete_struct_literal.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -4,17 +4,10 @@ use crate::completion::{CompletionContext, Completions};\n \n /// Complete fields in fields literals.\n pub(super) fn complete_struct_literal(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (function, struct_lit) = match (&ctx.function, ctx.struct_lit_syntax) {\n-        (Some(function), Some(struct_lit)) => (function, struct_lit),\n-        _ => return,\n-    };\n-    let infer_result = function.infer(ctx.db);\n-    let source_map = function.body_source_map(ctx.db);\n-    let expr = match source_map.node_expr(struct_lit.into()) {\n-        Some(expr) => expr,\n+    let ty = match ctx.struct_lit_syntax.and_then(|it| ctx.analyzer.type_of(ctx.db, it.into())) {\n+        Some(it) => it,\n         None => return,\n     };\n-    let ty = infer_result[expr].clone();\n     let (adt, substs) = match ty.as_adt() {\n         Some(res) => res,\n         _ => return,"}, {"sha": "359f2cffa5496711128c36f92d3d8ff49782da28", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     algo::{find_token_at_offset, find_covering_element, find_node_at_offset},\n     SyntaxKind::*,\n };\n-use hir::{source_binder, Resolver};\n+use hir::source_binder;\n \n use crate::{db, FilePosition};\n \n@@ -14,11 +14,10 @@ use crate::{db, FilePosition};\n #[derive(Debug)]\n pub(crate) struct CompletionContext<'a> {\n     pub(super) db: &'a db::RootDatabase,\n+    pub(super) analyzer: hir::SourceAnalyzer,\n     pub(super) offset: TextUnit,\n     pub(super) token: SyntaxToken<'a>,\n-    pub(super) resolver: Resolver,\n     pub(super) module: Option<hir::Module>,\n-    pub(super) function: Option<hir::Function>,\n     pub(super) function_syntax: Option<&'a ast::FnDef>,\n     pub(super) use_item_syntax: Option<&'a ast::UseItem>,\n     pub(super) struct_lit_syntax: Option<&'a ast::StructLit>,\n@@ -47,16 +46,16 @@ impl<'a> CompletionContext<'a> {\n         original_file: &'a SourceFile,\n         position: FilePosition,\n     ) -> Option<CompletionContext<'a>> {\n-        let resolver = source_binder::resolver_for_position(db, position);\n         let module = source_binder::module_from_position(db, position);\n         let token = find_token_at_offset(original_file.syntax(), position.offset).left_biased()?;\n+        let analyzer =\n+            hir::SourceAnalyzer::new(db, position.file_id, token.parent(), Some(position.offset));\n         let mut ctx = CompletionContext {\n             db,\n+            analyzer,\n             token,\n             offset: position.offset,\n-            resolver,\n             module,\n-            function: None,\n             function_syntax: None,\n             use_item_syntax: None,\n             struct_lit_syntax: None,\n@@ -147,10 +146,6 @@ impl<'a> CompletionContext<'a> {\n             .ancestors()\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::FnDef::cast);\n-        if let (Some(module), Some(fn_def)) = (self.module, self.function_syntax) {\n-            let function = source_binder::function_from_module(self.db, module, fn_def);\n-            self.function = Some(function);\n-        }\n \n         let parent = match name_ref.syntax().parent() {\n             Some(it) => it,"}, {"sha": "84645287d7497d4e44b95a4d20375d10d7619a6b", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -1,11 +1,11 @@\n use ra_db::{FileId, SourceDatabase};\n use ra_syntax::{\n-    SyntaxNode, SyntaxNodePtr, AstNode, SmolStr, TextRange, TreeArc,\n+    SyntaxNode, AstNode, SmolStr, TextRange, TreeArc, AstPtr,\n     SyntaxKind::{self, NAME},\n     ast::{self, NameOwner, VisibilityOwner, TypeAscriptionOwner},\n     algo::visit::{visitor, Visitor},\n };\n-use hir::{ModuleSource, FieldSource, Name, ImplItem};\n+use hir::{ModuleSource, FieldSource, ImplItem, Either};\n \n use crate::{FileSymbol, db::RootDatabase};\n \n@@ -74,15 +74,25 @@ impl NavigationTarget {\n         }\n     }\n \n-    pub(crate) fn from_scope_entry(\n+    pub(crate) fn from_pat(\n+        db: &RootDatabase,\n         file_id: FileId,\n-        name: Name,\n-        ptr: SyntaxNodePtr,\n+        pat: Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>,\n     ) -> NavigationTarget {\n+        let file = db.parse(file_id);\n+        let (name, full_range) = match pat {\n+            Either::A(pat) => match pat.to_node(&file).kind() {\n+                ast::PatKind::BindPat(pat) => {\n+                    return NavigationTarget::from_bind_pat(file_id, &pat)\n+                }\n+                _ => (\"_\".into(), pat.syntax_node_ptr().range()),\n+            },\n+            Either::B(slf) => (\"self\".into(), slf.syntax_node_ptr().range()),\n+        };\n         NavigationTarget {\n             file_id,\n-            name: name.to_string().into(),\n-            full_range: ptr.range(),\n+            name,\n+            full_range,\n             focus_range: None,\n             kind: NAME,\n             container_name: None,\n@@ -229,6 +239,7 @@ impl NavigationTarget {\n \n     /// Allows `NavigationTarget` to be created from a `NameOwner`\n     pub(crate) fn from_named(file_id: FileId, node: &impl ast::NameOwner) -> NavigationTarget {\n+        //FIXME: use `_` instead of empty string\n         let name = node.name().map(|it| it.text().clone()).unwrap_or_default();\n         let focus_range = node.name().map(|it| it.syntax().range());\n         NavigationTarget::from_syntax(file_id, name, focus_range, node.syntax())"}, {"sha": "517dffbca5f393d51ef1fbd57dd21b53eea47349", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 46, "deletions": 104, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -5,7 +5,6 @@ use ra_syntax::{\n     SyntaxNode,\n };\n use test_utils::tested_by;\n-use hir::Resolution;\n \n use crate::{FilePosition, NavigationTarget, db::RootDatabase, RangeInfo};\n \n@@ -48,127 +47,70 @@ pub(crate) fn reference_definition(\n ) -> ReferenceResult {\n     use self::ReferenceResult::*;\n \n-    let function = hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax());\n-\n-    if let Some(function) = function {\n-        // Check if it is a method\n-        if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n-            tested_by!(goto_definition_works_for_methods);\n-            let infer_result = function.infer(db);\n-            let source_map = function.body_source_map(db);\n-            let expr = ast::Expr::cast(method_call.syntax()).unwrap();\n-            if let Some(func) =\n-                source_map.node_expr(expr).and_then(|it| infer_result.method_resolution(it))\n-            {\n-                return Exact(NavigationTarget::from_function(db, func));\n-            };\n-        }\n-        // It could also be a field access\n-        if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::FieldExpr::cast) {\n-            tested_by!(goto_definition_works_for_fields);\n-            let infer_result = function.infer(db);\n-            let source_map = function.body_source_map(db);\n-            let expr = ast::Expr::cast(field_expr.syntax()).unwrap();\n-            if let Some(field) =\n-                source_map.node_expr(expr).and_then(|it| infer_result.field_resolution(it))\n-            {\n-                return Exact(NavigationTarget::from_field(db, field));\n-            };\n-        }\n+    let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n \n-        // It could also be a named field\n-        if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::NamedField::cast) {\n-            tested_by!(goto_definition_works_for_named_fields);\n+    // Special cases:\n \n-            let infer_result = function.infer(db);\n-            let source_map = function.body_source_map(db);\n+    // Check if it is a method\n+    if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n+        tested_by!(goto_definition_works_for_methods);\n+        if let Some(func) = analyzer.resolve_method_call(method_call) {\n+            return Exact(NavigationTarget::from_function(db, func));\n+        }\n+    }\n+    // It could also be a field access\n+    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::FieldExpr::cast) {\n+        tested_by!(goto_definition_works_for_fields);\n+        if let Some(field) = analyzer.resolve_field(field_expr) {\n+            return Exact(NavigationTarget::from_field(db, field));\n+        };\n+    }\n \n-            let struct_lit = field_expr.syntax().ancestors().find_map(ast::StructLit::cast);\n+    // It could also be a named field\n+    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::NamedField::cast) {\n+        tested_by!(goto_definition_works_for_named_fields);\n \n-            if let Some(expr) = struct_lit.and_then(|lit| source_map.node_expr(lit.into())) {\n-                let ty = infer_result[expr].clone();\n-                if let Some((hir::AdtDef::Struct(s), _)) = ty.as_adt() {\n-                    let hir_path = hir::Path::from_name_ref(name_ref);\n-                    let hir_name = hir_path.as_ident().unwrap();\n+        let struct_lit = field_expr.syntax().ancestors().find_map(ast::StructLit::cast);\n \n-                    if let Some(field) = s.field(db, hir_name) {\n-                        return Exact(NavigationTarget::from_field(db, field));\n-                    }\n+        if let Some(ty) = struct_lit.and_then(|lit| analyzer.type_of(db, lit.into())) {\n+            if let Some((hir::AdtDef::Struct(s), _)) = ty.as_adt() {\n+                let hir_path = hir::Path::from_name_ref(name_ref);\n+                let hir_name = hir_path.as_ident().unwrap();\n+\n+                if let Some(field) = s.field(db, hir_name) {\n+                    return Exact(NavigationTarget::from_field(db, field));\n                 }\n             }\n         }\n     }\n \n-    // Try name resolution\n-    let resolver = hir::source_binder::resolver_for_node(db, file_id, name_ref.syntax());\n-    if let Some(path) =\n-        name_ref.syntax().ancestors().find_map(ast::Path::cast).and_then(hir::Path::from_ast)\n-    {\n-        let resolved = resolver.resolve_path(db, &path);\n-        match resolved.clone().take_types().or_else(|| resolved.take_values()) {\n-            Some(Resolution::Def(def)) => return Exact(NavigationTarget::from_def(db, def)),\n-            Some(Resolution::LocalBinding(pat)) => {\n-                let body = resolver.body().expect(\"no body for local binding\");\n-                let source_map = body.owner().body_source_map(db);\n-                let ptr = source_map.pat_syntax(pat).expect(\"pattern not found in syntax mapping\");\n-                let name =\n-                    path.as_ident().cloned().expect(\"local binding from a multi-segment path\");\n-                let ptr = ptr.either(|it| it.into(), |it| it.into());\n-                let nav = NavigationTarget::from_scope_entry(file_id, name, ptr);\n-                return Exact(nav);\n-            }\n-            Some(Resolution::GenericParam(..)) => {\n-                // FIXME: go to the generic param def\n-            }\n-            Some(Resolution::SelfType(impl_block)) => {\n-                let ty = impl_block.target_ty(db);\n-\n-                if let Some((def_id, _)) = ty.as_adt() {\n-                    return Exact(NavigationTarget::from_adt_def(db, def_id));\n+    // General case, a path or a local:\n+    if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n+        if let Some(resolved) = analyzer.resolve_path(db, path) {\n+            match resolved {\n+                hir::PathResolution::Def(def) => return Exact(NavigationTarget::from_def(db, def)),\n+                hir::PathResolution::LocalBinding(pat) => {\n+                    let nav = NavigationTarget::from_pat(db, file_id, pat);\n+                    return Exact(nav);\n                 }\n-            }\n-            None => {\n-                // If we failed to resolve then check associated items\n-                if let Some(function) = function {\n-                    // Resolve associated item for path expressions\n-                    if let Some(path_expr) =\n-                        name_ref.syntax().ancestors().find_map(ast::PathExpr::cast)\n-                    {\n-                        let infer_result = function.infer(db);\n-                        let source_map = function.body_source_map(db);\n-\n-                        if let Some(expr) = ast::Expr::cast(path_expr.syntax()) {\n-                            if let Some(res) = source_map\n-                                .node_expr(expr)\n-                                .and_then(|it| infer_result.assoc_resolutions_for_expr(it.into()))\n-                            {\n-                                return Exact(NavigationTarget::from_impl_item(db, res));\n-                            }\n-                        }\n-                    }\n+                hir::PathResolution::GenericParam(..) => {\n+                    // FIXME: go to the generic param def\n+                }\n+                hir::PathResolution::SelfType(impl_block) => {\n+                    let ty = impl_block.target_ty(db);\n \n-                    // Resolve associated item for path patterns\n-                    if let Some(path_pat) =\n-                        name_ref.syntax().ancestors().find_map(ast::PathPat::cast)\n-                    {\n-                        let infer_result = function.infer(db);\n-                        let source_map = function.body_source_map(db);\n-\n-                        let pat: &ast::Pat = path_pat.into();\n-\n-                        if let Some(res) = source_map\n-                            .node_pat(pat)\n-                            .and_then(|it| infer_result.assoc_resolutions_for_pat(it.into()))\n-                        {\n-                            return Exact(NavigationTarget::from_impl_item(db, res));\n-                        }\n+                    if let Some((def_id, _)) = ty.as_adt() {\n+                        return Exact(NavigationTarget::from_adt_def(db, def_id));\n                     }\n                 }\n+                hir::PathResolution::AssocItem(assoc) => {\n+                    return Exact(NavigationTarget::from_impl_item(db, assoc))\n+                }\n             }\n         }\n     }\n \n-    // If that fails try the index based approach.\n+    // Fallback index based approach:\n     let navs = crate::symbol_index::index_resolve(db, name_ref)\n         .into_iter()\n         .map(NavigationTarget::from_symbol)"}, {"sha": "397b567867a98a24ce9302b4e2b8683992a101a6", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -132,17 +132,15 @@ pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {\n         .ancestors()\n         .take_while(|it| it.range() == leaf_node.range())\n         .find(|&it| ast::Expr::cast(it).is_some() || ast::Pat::cast(it).is_some())?;\n-    let parent_fn = node.ancestors().find_map(ast::FnDef::cast)?;\n-    let function = hir::source_binder::function_from_source(db, frange.file_id, parent_fn)?;\n-    let infer = function.infer(db);\n-    let source_map = function.body_source_map(db);\n-    if let Some(expr) = ast::Expr::cast(node).and_then(|e| source_map.node_expr(e)) {\n-        Some(infer[expr].display(db).to_string())\n-    } else if let Some(pat) = ast::Pat::cast(node).and_then(|p| source_map.node_pat(p)) {\n-        Some(infer[pat].display(db).to_string())\n+    let analyzer = hir::SourceAnalyzer::new(db, frange.file_id, node, None);\n+    let ty = if let Some(ty) = ast::Expr::cast(node).and_then(|e| analyzer.type_of(db, e)) {\n+        ty\n+    } else if let Some(ty) = ast::Pat::cast(node).and_then(|p| analyzer.type_of_pat(db, p)) {\n+        ty\n     } else {\n-        None\n-    }\n+        return None;\n+    };\n+    Some(ty.display(db).to_string())\n }\n \n #[cfg(test)]"}, {"sha": "9f655d83ce03066c52414578d0c77bad7034d304", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -61,11 +61,10 @@ pub(crate) fn find_all_refs(\n     position: FilePosition,\n ) -> Option<ReferenceSearchResult> {\n     let file = db.parse(position.file_id);\n-    let (binding, descr) = find_binding(db, &file, position)?;\n+    let (binding, analyzer) = find_binding(db, &file, position)?;\n     let declaration = NavigationTarget::from_bind_pat(position.file_id, binding);\n \n-    let references = descr\n-        .scopes(db)\n+    let references = analyzer\n         .find_all_refs(binding)\n         .into_iter()\n         .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n@@ -77,21 +76,18 @@ pub(crate) fn find_all_refs(\n         db: &RootDatabase,\n         source_file: &'a SourceFile,\n         position: FilePosition,\n-    ) -> Option<(&'a ast::BindPat, hir::Function)> {\n+    ) -> Option<(&'a ast::BindPat, hir::SourceAnalyzer)> {\n         let syntax = source_file.syntax();\n         if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n-            let descr =\n-                source_binder::function_from_child_node(db, position.file_id, binding.syntax())?;\n-            return Some((binding, descr));\n+            let analyzer = hir::SourceAnalyzer::new(db, position.file_id, binding.syntax(), None);\n+            return Some((binding, analyzer));\n         };\n         let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n-        let descr =\n-            source_binder::function_from_child_node(db, position.file_id, name_ref.syntax())?;\n-        let scope = descr.scopes(db);\n-        let resolved = scope.resolve_local_name(name_ref)?;\n+        let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n+        let resolved = analyzer.resolve_local_name(name_ref)?;\n         if let Either::A(ptr) = resolved.ptr() {\n             if let ast::PatKind::BindPat(binding) = ptr.to_node(source_file).kind() {\n-                return Some((binding, descr));\n+                return Some((binding, analyzer));\n             }\n         }\n         None"}, {"sha": "3969076a8b28310f7341ffe3d991869bdc1e37d1", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -65,7 +65,6 @@ fn runnable_mod(db: &RootDatabase, file_id: FileId, module: &ast::Module) -> Opt\n     let range = module.syntax().range();\n     let module = hir::source_binder::module_from_child_node(db, file_id, module.syntax())?;\n \n-    // FIXME: thread cancellation instead of `.ok`ing\n     let path = module.path_to_root(db).into_iter().rev().filter_map(|it| it.name(db)).join(\"::\");\n     Some(Runnable { range, kind: RunnableKind::TestMod { path } })\n }"}, {"sha": "91799f8b55ae4bc3b989a4e131b690bfaf126434", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8887782c4ab97d22f3d5c10e142407e4371c5c61/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=8887782c4ab97d22f3d5c10e142407e4371c5c61", "patch": "@@ -60,7 +60,7 @@ fn reparse_fuzz_tests() {\n     }\n }\n \n-/// Test that Rust-analyzer can parse and validate the rust-analyser\n+/// Test that Rust-analyzer can parse and validate the rust-analyzer\n /// FIXME: Use this as a benchmark\n #[test]\n fn self_hosting_parsing() {"}]}