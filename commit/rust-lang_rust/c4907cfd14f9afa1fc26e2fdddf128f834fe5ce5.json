{"sha": "c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0OTA3Y2ZkMTRmOWFmYTFmYzI2ZTJmZGRkZjEyOGY4MzRmZTVjZTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-22T00:11:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:21:58Z"}, "message": "Remove std::io from ebml", "tree": {"sha": "f46e25052dc8cbb31dce08c79060f05c84470771", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f46e25052dc8cbb31dce08c79060f05c84470771"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "html_url": "https://github.com/rust-lang/rust/commit/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "620ab3853abf99ecea3a3d055f47cd6d06433c95", "url": "https://api.github.com/repos/rust-lang/rust/commits/620ab3853abf99ecea3a3d055f47cd6d06433c95", "html_url": "https://github.com/rust-lang/rust/commit/620ab3853abf99ecea3a3d055f47cd6d06433c95"}], "stats": {"total": 772, "additions": 393, "deletions": 379}, "files": [{"sha": "1a21150d11b5939e3864052c53d42b9ed8378bdc", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "patch": "@@ -96,17 +96,8 @@ pub mod reader {\n \n     use std::cast::transmute;\n     use std::int;\n-    use std::io;\n     use std::option::{None, Option, Some};\n \n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"x86_64\")]\n-    use std::ptr::offset;\n-\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"x86_64\")]\n-    use std::unstable::intrinsics::bswap32;\n-\n     // ebml reading\n \n     struct Res {\n@@ -144,6 +135,9 @@ pub mod reader {\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"x86_64\")]\n     pub fn vuint_at(data: &[u8], start: uint) -> Res {\n+        use std::ptr::offset;\n+        use std::unstable::intrinsics::bswap32;\n+\n         if data.len() - start < 4 {\n             return vuint_at_slow(data, start);\n         }\n@@ -178,8 +172,7 @@ pub mod reader {\n         }\n     }\n \n-    #[cfg(target_arch = \"arm\")]\n-    #[cfg(target_arch = \"mips\")]\n+    #[cfg(not(target_arch = \"x86\"), not(target_arch = \"x86_64\"))]\n     pub fn vuint_at(data: &[u8], start: uint) -> Res {\n         vuint_at_slow(data, start)\n     }\n@@ -265,17 +258,17 @@ pub mod reader {\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n         assert_eq!(d.end, d.start + 2u);\n-        io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n+        ::std::io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n         assert_eq!(d.end, d.start + 4u);\n-        io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n+        ::std::io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n         assert_eq!(d.end, d.start + 8u);\n-        io::u64_from_be_bytes(*d.data, d.start, 8u)\n+        ::std::io::u64_from_be_bytes(*d.data, d.start, 8u)\n     }\n \n     pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n@@ -614,11 +607,14 @@ pub mod writer {\n \n     use std::cast;\n     use std::clone::Clone;\n-    use std::io;\n+    use std::rt::io;\n+    use std::rt::io::{Writer, Seek};\n+    use std::rt::io::mem::MemWriter;\n \n     // ebml writing\n     pub struct Encoder {\n-        writer: @io::Writer,\n+        // FIXME(#5665): this should take a trait object\n+        writer: @mut MemWriter,\n         priv size_positions: ~[uint],\n     }\n \n@@ -631,7 +627,7 @@ pub mod writer {\n         }\n     }\n \n-    fn write_sized_vuint(w: @io::Writer, n: uint, size: uint) {\n+    fn write_sized_vuint(w: @mut MemWriter, n: uint, size: uint) {\n         match size {\n             1u => w.write(&[0x80u8 | (n as u8)]),\n             2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n@@ -643,15 +639,15 @@ pub mod writer {\n         };\n     }\n \n-    fn write_vuint(w: @io::Writer, n: uint) {\n+    fn write_vuint(w: @mut MemWriter, n: uint) {\n         if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n         if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n         if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n         if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n         fail!(\"vint to write too big: {}\", n);\n     }\n \n-    pub fn Encoder(w: @io::Writer) -> Encoder {\n+    pub fn Encoder(w: @mut MemWriter) -> Encoder {\n         let size_positions: ~[uint] = ~[];\n         Encoder {\n             writer: w,\n@@ -668,18 +664,18 @@ pub mod writer {\n             write_vuint(self.writer, tag_id);\n \n             // Write a placeholder four-byte size.\n-            self.size_positions.push(self.writer.tell());\n+            self.size_positions.push(self.writer.tell() as uint);\n             let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n             self.writer.write(zeroes);\n         }\n \n         pub fn end_tag(&mut self) {\n             let last_size_pos = self.size_positions.pop();\n             let cur_pos = self.writer.tell();\n-            self.writer.seek(last_size_pos as int, io::SeekSet);\n-            let size = (cur_pos - last_size_pos - 4u);\n-            write_sized_vuint(self.writer, size, 4u);\n-            self.writer.seek(cur_pos as int, io::SeekSet);\n+            self.writer.seek(last_size_pos as i64, io::SeekSet);\n+            let size = (cur_pos as uint - last_size_pos - 4);\n+            write_sized_vuint(self.writer, size as uint, 4u);\n+            self.writer.seek(cur_pos as i64, io::SeekSet);\n \n             debug!(\"End tag (size = {})\", size);\n         }\n@@ -697,19 +693,19 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n-            do io::u64_to_be_bytes(v, 8u) |v| {\n+            do ::std::io::u64_to_be_bytes(v, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n-            do io::u64_to_be_bytes(v as u64, 4u) |v| {\n+            do ::std::io::u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n-            do io::u64_to_be_bytes(v as u64, 2u) |v| {\n+            do ::std::io::u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n@@ -719,19 +715,19 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n-            do io::u64_to_be_bytes(v as u64, 8u) |v| {\n+            do ::std::io::u64_to_be_bytes(v as u64, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n-            do io::u64_to_be_bytes(v as u64, 4u) |v| {\n+            do ::std::io::u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n-            do io::u64_to_be_bytes(v as u64, 2u) |v| {\n+            do ::std::io::u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n@@ -963,18 +959,18 @@ mod tests {\n     use serialize::Encodable;\n     use serialize;\n \n-    use std::io;\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n     use std::option::{None, Option, Some};\n \n     #[test]\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {\n             debug!(\"v == {:?}\", v);\n-            let bytes = do io::with_bytes_writer |wr| {\n-                let mut ebml_w = writer::Encoder(wr);\n-                v.encode(&mut ebml_w)\n-            };\n-            let ebml_doc = reader::Doc(@bytes);\n+            let wr = @mut MemWriter::new();\n+            let mut ebml_w = writer::Encoder(wr);\n+            v.encode(&mut ebml_w);\n+            let ebml_doc = reader::Doc(@wr.inner_ref().to_owned());\n             let mut deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&mut deser);\n             debug!(\"v1 == {:?}\", v1);"}, {"sha": "b94b74a696cc26552ca2ec07fcc7a49b2558c16d", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "patch": "@@ -522,6 +522,8 @@ mod test {\n     use std::str;\n     use std::rand;\n     use std::num::Zero;\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n \n     #[test]\n     fn test_new_nil() {\n@@ -795,10 +797,10 @@ mod test {\n         use serialize::{Encodable, Decodable};\n \n         let u = Uuid::new_v4();\n-        let bytes = do std::io::with_bytes_writer |wr| {\n-            u.encode(&mut ebml::writer::Encoder(wr));\n-        };\n-        let u2 = Decodable::decode(&mut ebml::reader::Decoder(ebml::reader::Doc(@bytes)));\n+        let wr = @mut MemWriter::new();\n+        u.encode(&mut ebml::writer::Encoder(wr));\n+        let doc = ebml::reader::Doc(@wr.inner_ref().to_owned());\n+        let u2 = Decodable::decode(&mut ebml::reader::Decoder(doc));\n         assert_eq!(u, u2);\n     }\n }"}, {"sha": "d64820332a5d959ef96cd5e1e389e6adce393db9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 64, "deletions": 50, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "patch": "@@ -22,12 +22,16 @@ use middle::typeck;\n use middle;\n \n use std::hashmap::{HashMap, HashSet};\n-use std::io;\n+use std::rt::io::extensions::WriterByteConversions;\n+use std::rt::io::{Writer, Seek, Decorator};\n+use std::rt::io::mem::MemWriter;\n use std::str;\n use std::vec;\n+\n use extra::flate;\n use extra::serialize::Encodable;\n use extra;\n+\n use syntax::abi::AbiSet;\n use syntax::ast::*;\n use syntax::ast;\n@@ -68,17 +72,17 @@ pub struct EncodeParams<'self> {\n }\n \n struct Stats {\n-    inline_bytes: uint,\n-    attr_bytes: uint,\n-    dep_bytes: uint,\n-    lang_item_bytes: uint,\n-    link_args_bytes: uint,\n-    impl_bytes: uint,\n-    misc_bytes: uint,\n-    item_bytes: uint,\n-    index_bytes: uint,\n-    zero_bytes: uint,\n-    total_bytes: uint,\n+    inline_bytes: u64,\n+    attr_bytes: u64,\n+    dep_bytes: u64,\n+    lang_item_bytes: u64,\n+    link_args_bytes: u64,\n+    impl_bytes: u64,\n+    misc_bytes: u64,\n+    item_bytes: u64,\n+    index_bytes: u64,\n+    zero_bytes: u64,\n+    total_bytes: u64,\n \n     n_inlines: uint\n }\n@@ -133,7 +137,7 @@ fn encode_region_param(ecx: &EncodeContext,\n #[deriving(Clone)]\n struct entry<T> {\n     val: T,\n-    pos: uint\n+    pos: u64\n }\n \n fn add_to_index(ebml_w: &mut writer::Encoder,\n@@ -1395,19 +1399,21 @@ fn create_index<T:Clone + Hash + IterBytes + 'static>(\n fn encode_index<T:'static>(\n                 ebml_w: &mut writer::Encoder,\n                 buckets: ~[@~[entry<T>]],\n-                write_fn: &fn(@io::Writer, &T)) {\n-    let writer = ebml_w.writer;\n+                write_fn: &fn(@mut MemWriter, &T)) {\n     ebml_w.start_tag(tag_index);\n-    let mut bucket_locs: ~[uint] = ~[];\n+    let mut bucket_locs = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n     for bucket in buckets.iter() {\n         bucket_locs.push(ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n         for elt in (**bucket).iter() {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n-            writer.write_be_u32(elt.pos as u32);\n-            write_fn(writer, &elt.val);\n+            {\n+                let wr: &mut MemWriter = ebml_w.writer;\n+                wr.write_be_u32_(elt.pos as u32);\n+            }\n+            write_fn(ebml_w.writer, &elt.val);\n             ebml_w.end_tag();\n         }\n         ebml_w.end_tag();\n@@ -1416,19 +1422,21 @@ fn encode_index<T:'static>(\n     ebml_w.start_tag(tag_index_table);\n     for pos in bucket_locs.iter() {\n         assert!(*pos < 0xffff_ffff);\n-        writer.write_be_u32(*pos as u32);\n+        let wr: &mut MemWriter = ebml_w.writer;\n+        wr.write_be_u32_(*pos as u32);\n     }\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n \n-fn write_str(writer: @io::Writer, s: ~str) {\n-    writer.write_str(s);\n+fn write_str(writer: @mut MemWriter, s: ~str) {\n+    writer.write(s.as_bytes());\n }\n \n-fn write_i64(writer: @io::Writer, &n: &i64) {\n+fn write_i64(writer: @mut MemWriter, &n: &i64) {\n+    let wr: &mut MemWriter = writer;\n     assert!(n < 0x7fff_ffff);\n-    writer.write_be_u32(n as u32);\n+    wr.write_be_u32_(n as u32);\n }\n \n fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n@@ -1581,11 +1589,17 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n                 ebml_w.start_tag(tag_lang_items_item);\n \n                 ebml_w.start_tag(tag_lang_items_item_id);\n-                ebml_w.writer.write_be_u32(i as u32);\n+                {\n+                    let wr: &mut MemWriter = ebml_w.writer;\n+                    wr.write_be_u32_(i as u32);\n+                }\n                 ebml_w.end_tag();   // tag_lang_items_item_id\n \n                 ebml_w.start_tag(tag_lang_items_item_node_id);\n-                ebml_w.writer.write_be_u32(id.node as u32);\n+                {\n+                    let wr: &mut MemWriter = ebml_w.writer;\n+                    wr.write_be_u32_(id.node as u32);\n+                }\n                 ebml_w.end_tag();   // tag_lang_items_item_node_id\n \n                 ebml_w.end_tag();   // tag_lang_items_item\n@@ -1602,7 +1616,7 @@ fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     let link_args = cstore::get_used_link_args(ecx.cstore);\n     for link_arg in link_args.iter() {\n         ebml_w.start_tag(tag_link_args_arg);\n-        ebml_w.writer.write_str(link_arg.to_str());\n+        ebml_w.writer.write(link_arg.as_bytes());\n         ebml_w.end_tag();\n     }\n \n@@ -1720,7 +1734,7 @@ pub static metadata_encoding_version : &'static [u8] =\n       0, 0, 0, 1 ];\n \n pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n-    let wr = @io::BytesWriter::new();\n+    let wr = @mut MemWriter::new();\n     let stats = Stats {\n         inline_bytes: 0,\n         attr_bytes: 0,\n@@ -1765,55 +1779,55 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         reachable: reachable,\n      };\n \n-    let mut ebml_w = writer::Encoder(wr as @io::Writer);\n+    let mut ebml_w = writer::Encoder(wr);\n \n     encode_hash(&mut ebml_w, ecx.link_meta.extras_hash);\n \n-    let mut i = *wr.pos;\n+    let mut i = wr.tell();\n     let crate_attrs = synthesize_crate_attrs(&ecx, crate);\n     encode_attributes(&mut ebml_w, crate_attrs);\n-    ecx.stats.attr_bytes = *wr.pos - i;\n+    ecx.stats.attr_bytes = wr.tell() - i;\n \n-    i = *wr.pos;\n+    i = wr.tell();\n     encode_crate_deps(&ecx, &mut ebml_w, ecx.cstore);\n-    ecx.stats.dep_bytes = *wr.pos - i;\n+    ecx.stats.dep_bytes = wr.tell() - i;\n \n     // Encode the language items.\n-    i = *wr.pos;\n+    i = wr.tell();\n     encode_lang_items(&ecx, &mut ebml_w);\n-    ecx.stats.lang_item_bytes = *wr.pos - i;\n+    ecx.stats.lang_item_bytes = wr.tell() - i;\n \n     // Encode the link args.\n-    i = *wr.pos;\n+    i = wr.tell();\n     encode_link_args(&ecx, &mut ebml_w);\n-    ecx.stats.link_args_bytes = *wr.pos - i;\n+    ecx.stats.link_args_bytes = wr.tell() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n-    i = *wr.pos;\n+    i = wr.tell();\n     encode_impls(&ecx, crate, &mut ebml_w);\n-    ecx.stats.impl_bytes = *wr.pos - i;\n+    ecx.stats.impl_bytes = wr.tell() - i;\n \n     // Encode miscellaneous info.\n-    i = *wr.pos;\n+    i = wr.tell();\n     encode_misc_info(&ecx, crate, &mut ebml_w);\n-    ecx.stats.misc_bytes = *wr.pos - i;\n+    ecx.stats.misc_bytes = wr.tell() - i;\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n-    i = *wr.pos;\n+    i = wr.tell();\n     let items_index = encode_info_for_items(&ecx, &mut ebml_w, crate);\n-    ecx.stats.item_bytes = *wr.pos - i;\n+    ecx.stats.item_bytes = wr.tell() - i;\n \n-    i = *wr.pos;\n+    i = wr.tell();\n     let items_buckets = create_index(items_index);\n     encode_index(&mut ebml_w, items_buckets, write_i64);\n-    ecx.stats.index_bytes = *wr.pos - i;\n+    ecx.stats.index_bytes = wr.tell() - i;\n     ebml_w.end_tag();\n \n-    ecx.stats.total_bytes = *wr.pos;\n+    ecx.stats.total_bytes = wr.tell();\n \n     if (tcx.sess.meta_stats()) {\n-        for e in wr.bytes.iter() {\n+        for e in wr.inner_ref().iter() {\n             if *e == 0 {\n                 ecx.stats.zero_bytes += 1;\n             }\n@@ -1837,7 +1851,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n     // remaining % 4 bytes.\n     wr.write(&[0u8, 0u8, 0u8, 0u8]);\n \n-    let writer_bytes: &mut ~[u8] = wr.bytes;\n+    let writer_bytes: &mut ~[u8] = wr.inner_mut_ref();\n \n     metadata_encoding_version.to_owned() +\n         flate::deflate_bytes(*writer_bytes)\n@@ -1850,7 +1864,7 @@ pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n         ds: def_to_str,\n         tcx: tcx,\n         abbrevs: tyencode::ac_no_abbrevs};\n-    do io::with_str_writer |wr| {\n-        tyencode::enc_ty(wr, cx, t);\n-    }\n+    let wr = @mut MemWriter::new();\n+    tyencode::enc_ty(wr, cx, t);\n+    str::from_utf8(*wr.inner_ref())\n }"}, {"sha": "7fb33c881156b17ff0d334e63e276d0ed3fed942", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 207, "deletions": 245, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "patch": "@@ -10,19 +10,26 @@\n \n // Type encoding\n \n+use std::hashmap::HashMap;\n+use std::rt::io;\n+use std::rt::io::{Decorator, Writer, Seek};\n+use std::rt::io::mem::MemWriter;\n+use std::str;\n+use std::fmt;\n \n use middle::ty::param_ty;\n use middle::ty;\n \n-use std::hashmap::HashMap;\n-use std::io::WriterUtil;\n-use std::io;\n use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::diagnostic::span_handler;\n use syntax::print::pprust::*;\n \n+macro_rules! mywrite( ($wr:expr, $($arg:tt)*) => (\n+    format_args!(|a| { mywrite($wr, a) }, $($arg)*)\n+) )\n+\n pub struct ctxt {\n     diag: @mut span_handler,\n     // Def -> str Callback:\n@@ -46,350 +53,308 @@ pub enum abbrev_ctxt {\n     ac_use_abbrevs(@mut HashMap<ty::t, ty_abbrev>),\n }\n \n+fn mywrite(w: @mut MemWriter, fmt: &fmt::Arguments) {\n+    fmt::write(&mut *w as &mut io::Writer, fmt);\n+}\n+\n fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     match cx.abbrevs {\n       ac_no_abbrevs => return false,\n       ac_use_abbrevs(_) => return true\n     }\n }\n \n-pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n+pub fn enc_ty(w: @mut MemWriter, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n         let result_str = match cx.tcx.short_names_cache.find(&t) {\n             Some(&s) => s,\n             None => {\n-                let s = do io::with_str_writer |wr| {\n-                    enc_sty(wr, cx, &ty::get(t).sty);\n-                }.to_managed();\n+                let wr = @mut MemWriter::new();\n+                enc_sty(wr, cx, &ty::get(t).sty);\n+                let s = str::from_utf8(*wr.inner_ref()).to_managed();\n                 cx.tcx.short_names_cache.insert(t, s);\n                 s\n           }\n         };\n-        w.write_str(result_str);\n+        w.write(result_str.as_bytes());\n       }\n       ac_use_abbrevs(abbrevs) => {\n           match abbrevs.find(&t) {\n-              Some(a) => { w.write_str(a.s); return; }\n+              Some(a) => { w.write(a.s.as_bytes()); return; }\n               None => {}\n           }\n           let pos = w.tell();\n           enc_sty(w, cx, &ty::get(t).sty);\n           let end = w.tell();\n           let len = end - pos;\n-          fn estimate_sz(u: uint) -> uint {\n+          fn estimate_sz(u: u64) -> u64 {\n               let mut n = u;\n-              let mut len = 0u;\n-              while n != 0u { len += 1u; n = n >> 4u; }\n+              let mut len = 0;\n+              while n != 0 { len += 1; n = n >> 4; }\n               return len;\n           }\n-          let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n+          let abbrev_len = 3 + estimate_sz(pos) + estimate_sz(len);\n           if abbrev_len < len {\n               // I.e. it's actually an abbreviation.\n               let s = format!(\"\\\\#{:x}:{:x}\\\\#\", pos, len).to_managed();\n-              let a = ty_abbrev { pos: pos, len: len, s: s };\n+              let a = ty_abbrev { pos: pos as uint,\n+                                  len: len as uint,\n+                                  s: s };\n               abbrevs.insert(t, a);\n           }\n           return;\n       }\n     }\n }\n \n-fn enc_mutability(w: @io::Writer, mt: ast::Mutability) {\n+fn enc_mutability(w: @mut MemWriter, mt: ast::Mutability) {\n     match mt {\n-      MutImmutable => (),\n-      MutMutable => w.write_char('m'),\n+        MutImmutable => (),\n+        MutMutable => mywrite!(w, \"m\"),\n     }\n }\n \n-fn enc_mt(w: @io::Writer, cx: @ctxt, mt: ty::mt) {\n+fn enc_mt(w: @mut MemWriter, cx: @ctxt, mt: ty::mt) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: @io::Writer, t: Option<T>, enc_f: &fn(T)) {\n+fn enc_opt<T>(w: @mut MemWriter, t: Option<T>, enc_f: &fn(T)) {\n     match t {\n-      None => w.write_char('n'),\n-      Some(v) => {\n-        w.write_char('s');\n-        enc_f(v);\n-      }\n+        None => mywrite!(w, \"n\"),\n+        Some(v) => {\n+            mywrite!(w, \"s\");\n+            enc_f(v);\n+        }\n     }\n }\n \n-fn enc_substs(w: @io::Writer, cx: @ctxt, substs: &ty::substs) {\n+fn enc_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::substs) {\n     enc_region_substs(w, cx, &substs.regions);\n     do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n-    w.write_char('[');\n+    mywrite!(w, \"[\");\n     for t in substs.tps.iter() { enc_ty(w, cx, *t); }\n-    w.write_char(']');\n+    mywrite!(w, \"]\");\n }\n \n-fn enc_region_substs(w: @io::Writer, cx: @ctxt, substs: &ty::RegionSubsts) {\n+fn enc_region_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n     match *substs {\n         ty::ErasedRegions => {\n-            w.write_char('e');\n+            mywrite!(w, \"e\");\n         }\n         ty::NonerasedRegions(ref regions) => {\n-            w.write_char('n');\n+            mywrite!(w, \"n\");\n             for &r in regions.iter() {\n                 enc_region(w, cx, r);\n             }\n-            w.write_char('.');\n+            mywrite!(w, \".\");\n         }\n     }\n }\n \n-fn enc_region(w: @io::Writer, cx: @ctxt, r: ty::Region) {\n+fn enc_region(w: @mut MemWriter, cx: @ctxt, r: ty::Region) {\n     match r {\n-      ty::re_bound(br) => {\n-        w.write_char('b');\n-        enc_bound_region(w, cx, br);\n-      }\n-      ty::re_free(ref fr) => {\n-        w.write_char('f');\n-        w.write_char('[');\n-        w.write_int(fr.scope_id);\n-        w.write_char('|');\n-        enc_bound_region(w, cx, fr.bound_region);\n-        w.write_char(']');\n-      }\n-      ty::re_scope(nid) => {\n-        w.write_char('s');\n-        w.write_int(nid);\n-        w.write_char('|');\n-      }\n-      ty::re_static => {\n-        w.write_char('t');\n-      }\n-      ty::re_empty => {\n-        w.write_char('e');\n-      }\n-      ty::re_infer(_) => {\n-        // these should not crop up after typeck\n-        cx.diag.handler().bug(\"Cannot encode region variables\");\n-      }\n+        ty::re_bound(br) => {\n+            mywrite!(w, \"b\");\n+            enc_bound_region(w, cx, br);\n+        }\n+        ty::re_free(ref fr) => {\n+            mywrite!(w, \"f[{}|\", fr.scope_id);\n+            enc_bound_region(w, cx, fr.bound_region);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::re_scope(nid) => mywrite!(w, \"s{}|\", nid),\n+        ty::re_static => mywrite!(w, \"t\"),\n+        ty::re_empty => mywrite!(w, \"e\"),\n+        ty::re_infer(_) => {\n+            // these should not crop up after typeck\n+            cx.diag.handler().bug(\"Cannot encode region variables\");\n+        }\n     }\n }\n \n-fn enc_bound_region(w: @io::Writer, cx: @ctxt, br: ty::bound_region) {\n+fn enc_bound_region(w: @mut MemWriter, cx: @ctxt, br: ty::bound_region) {\n     match br {\n-      ty::br_self => w.write_char('s'),\n-      ty::br_anon(idx) => {\n-        w.write_char('a');\n-        w.write_uint(idx);\n-        w.write_char('|');\n-      }\n-      ty::br_named(s) => {\n-        w.write_char('[');\n-        w.write_str(cx.tcx.sess.str_of(s));\n-        w.write_char(']')\n-      }\n-      ty::br_cap_avoid(id, br) => {\n-        w.write_char('c');\n-        w.write_int(id);\n-        w.write_char('|');\n-        enc_bound_region(w, cx, *br);\n-      }\n-      ty::br_fresh(id) => {\n-        w.write_uint(id);\n-      }\n+        ty::br_self => mywrite!(w, \"s\"),\n+        ty::br_anon(idx) => mywrite!(w, \"a{}|\", idx),\n+        ty::br_named(s) => mywrite!(w, \"[{}]\", cx.tcx.sess.str_of(s)),\n+        ty::br_cap_avoid(id, br) => {\n+            mywrite!(w, \"c{}|\", id);\n+            enc_bound_region(w, cx, *br);\n+        }\n+        ty::br_fresh(id) => mywrite!(w, \"{}\", id),\n     }\n }\n \n-pub fn enc_vstore(w: @io::Writer, cx: @ctxt, v: ty::vstore) {\n-    w.write_char('/');\n+pub fn enc_vstore(w: @mut MemWriter, cx: @ctxt, v: ty::vstore) {\n+    mywrite!(w, \"/\");\n     match v {\n-      ty::vstore_fixed(u) => {\n-        w.write_uint(u);\n-        w.write_char('|');\n-      }\n-      ty::vstore_uniq => {\n-        w.write_char('~');\n-      }\n-      ty::vstore_box => {\n-        w.write_char('@');\n-      }\n-      ty::vstore_slice(r) => {\n-        w.write_char('&');\n-        enc_region(w, cx, r);\n-      }\n+        ty::vstore_fixed(u) => mywrite!(w, \"{}|\", u),\n+        ty::vstore_uniq => mywrite!(w, \"~\"),\n+        ty::vstore_box => mywrite!(w, \"@\"),\n+        ty::vstore_slice(r) => {\n+            mywrite!(w, \"&\");\n+            enc_region(w, cx, r);\n+        }\n     }\n }\n \n-pub fn enc_trait_ref(w: @io::Writer, cx: @ctxt, s: &ty::TraitRef) {\n-    w.write_str((cx.ds)(s.def_id));\n-    w.write_char('|');\n+pub fn enc_trait_ref(w: @mut MemWriter, cx: @ctxt, s: &ty::TraitRef) {\n+    mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, &s.substs);\n }\n \n-pub fn enc_trait_store(w: @io::Writer, cx: @ctxt, s: ty::TraitStore) {\n+pub fn enc_trait_store(w: @mut MemWriter, cx: @ctxt, s: ty::TraitStore) {\n     match s {\n-        ty::UniqTraitStore => w.write_char('~'),\n-        ty::BoxTraitStore => w.write_char('@'),\n+        ty::UniqTraitStore => mywrite!(w, \"~\"),\n+        ty::BoxTraitStore => mywrite!(w, \"@\"),\n         ty::RegionTraitStore(re) => {\n-            w.write_char('&');\n+            mywrite!(w, \"&\");\n             enc_region(w, cx, re);\n         }\n     }\n }\n \n-fn enc_sty(w: @io::Writer, cx: @ctxt, st: &ty::sty) {\n+fn enc_sty(w: @mut MemWriter, cx: @ctxt, st: &ty::sty) {\n     match *st {\n-      ty::ty_nil => w.write_char('n'),\n-      ty::ty_bot => w.write_char('z'),\n-      ty::ty_bool => w.write_char('b'),\n-      ty::ty_char => w.write_char('c'),\n-      ty::ty_int(t) => {\n-        match t {\n-          ty_i => w.write_char('i'),\n-          ty_i8 => w.write_str(&\"MB\"),\n-          ty_i16 => w.write_str(&\"MW\"),\n-          ty_i32 => w.write_str(&\"ML\"),\n-          ty_i64 => w.write_str(&\"MD\")\n+        ty::ty_nil => mywrite!(w, \"n\"),\n+        ty::ty_bot => mywrite!(w, \"z\"),\n+        ty::ty_bool => mywrite!(w, \"b\"),\n+        ty::ty_char => mywrite!(w, \"c\"),\n+        ty::ty_int(t) => {\n+            match t {\n+                ty_i => mywrite!(w, \"i\"),\n+                ty_i8 => mywrite!(w, \"MB\"),\n+                ty_i16 => mywrite!(w, \"MW\"),\n+                ty_i32 => mywrite!(w, \"ML\"),\n+                ty_i64 => mywrite!(w, \"MD\")\n+            }\n         }\n-      }\n-      ty::ty_uint(t) => {\n-        match t {\n-          ty_u => w.write_char('u'),\n-          ty_u8 => w.write_str(&\"Mb\"),\n-          ty_u16 => w.write_str(&\"Mw\"),\n-          ty_u32 => w.write_str(&\"Ml\"),\n-          ty_u64 => w.write_str(&\"Md\")\n+        ty::ty_uint(t) => {\n+            match t {\n+                ty_u => mywrite!(w, \"u\"),\n+                ty_u8 => mywrite!(w, \"Mb\"),\n+                ty_u16 => mywrite!(w, \"Mw\"),\n+                ty_u32 => mywrite!(w, \"Ml\"),\n+                ty_u64 => mywrite!(w, \"Md\")\n+            }\n         }\n-      }\n-      ty::ty_float(t) => {\n-        match t {\n-          ty_f32 => w.write_str(&\"Mf\"),\n-          ty_f64 => w.write_str(&\"MF\"),\n+        ty::ty_float(t) => {\n+            match t {\n+                ty_f32 => mywrite!(w, \"Mf\"),\n+                ty_f64 => mywrite!(w, \"MF\"),\n+            }\n         }\n-      }\n-      ty::ty_enum(def, ref substs) => {\n-        w.write_str(&\"t[\");\n-        w.write_str((cx.ds)(def));\n-        w.write_char('|');\n-        enc_substs(w, cx, substs);\n-        w.write_char(']');\n-      }\n-      ty::ty_trait(def, ref substs, store, mt, bounds) => {\n-        w.write_str(&\"x[\");\n-        w.write_str((cx.ds)(def));\n-        w.write_char('|');\n-        enc_substs(w, cx, substs);\n-        enc_trait_store(w, cx, store);\n-        enc_mutability(w, mt);\n-        let bounds = ty::ParamBounds {builtin_bounds: bounds,\n-                                      trait_bounds: ~[]};\n-        enc_bounds(w, cx, &bounds);\n-        w.write_char(']');\n-      }\n-      ty::ty_tup(ref ts) => {\n-        w.write_str(&\"T[\");\n-        for t in ts.iter() { enc_ty(w, cx, *t); }\n-        w.write_char(']');\n-      }\n-      ty::ty_box(mt) => { w.write_char('@'); enc_mt(w, cx, mt); }\n-      ty::ty_uniq(mt) => { w.write_char('~'); enc_mt(w, cx, mt); }\n-      ty::ty_ptr(mt) => { w.write_char('*'); enc_mt(w, cx, mt); }\n-      ty::ty_rptr(r, mt) => {\n-        w.write_char('&');\n-        enc_region(w, cx, r);\n-        enc_mt(w, cx, mt);\n-      }\n-      ty::ty_evec(mt, v) => {\n-        w.write_char('V');\n-        enc_mt(w, cx, mt);\n-        enc_vstore(w, cx, v);\n-      }\n-      ty::ty_estr(v) => {\n-        w.write_char('v');\n-        enc_vstore(w, cx, v);\n-      }\n-      ty::ty_unboxed_vec(mt) => { w.write_char('U'); enc_mt(w, cx, mt); }\n-      ty::ty_closure(ref f) => {\n-        w.write_char('f');\n-        enc_closure_ty(w, cx, f);\n-      }\n-      ty::ty_bare_fn(ref f) => {\n-        w.write_char('F');\n-        enc_bare_fn_ty(w, cx, f);\n-      }\n-      ty::ty_infer(_) => {\n-        cx.diag.handler().bug(\"Cannot encode inference variable types\");\n-      }\n-      ty::ty_param(param_ty {idx: id, def_id: did}) => {\n-        w.write_char('p');\n-        w.write_str((cx.ds)(did));\n-        w.write_char('|');\n-        w.write_str(id.to_str());\n-      }\n-      ty::ty_self(did) => {\n-        w.write_char('s');\n-        w.write_str((cx.ds)(did));\n-        w.write_char('|');\n-      }\n-      ty::ty_type => w.write_char('Y'),\n-      ty::ty_opaque_closure_ptr(p) => {\n-          w.write_str(&\"C&\");\n-          enc_sigil(w, p);\n-      }\n-      ty::ty_opaque_box => w.write_char('B'),\n-      ty::ty_struct(def, ref substs) => {\n-          debug!(\"~~~~ {}\", \"a[\");\n-          w.write_str(&\"a[\");\n-          let s = (cx.ds)(def);\n-          debug!(\"~~~~ {}\", s);\n-          w.write_str(s);\n-          debug!(\"~~~~ {}\", \"|\");\n-          w.write_char('|');\n-          enc_substs(w, cx, substs);\n-          debug!(\"~~~~ {}\", \"]\");\n-          w.write_char(']');\n-      }\n-      ty::ty_err => fail!(\"Shouldn't encode error type\")\n+        ty::ty_enum(def, ref substs) => {\n+            mywrite!(w, \"t[{}|\", (cx.ds)(def));\n+            enc_substs(w, cx, substs);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_trait(def, ref substs, store, mt, bounds) => {\n+            mywrite!(w, \"x[{}|\", (cx.ds)(def));\n+            enc_substs(w, cx, substs);\n+            enc_trait_store(w, cx, store);\n+            enc_mutability(w, mt);\n+            let bounds = ty::ParamBounds {builtin_bounds: bounds,\n+                                          trait_bounds: ~[]};\n+            enc_bounds(w, cx, &bounds);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_tup(ref ts) => {\n+            mywrite!(w, \"T[\");\n+            for t in ts.iter() { enc_ty(w, cx, *t); }\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_box(mt) => { mywrite!(w, \"@\"); enc_mt(w, cx, mt); }\n+        ty::ty_uniq(mt) => { mywrite!(w, \"~\"); enc_mt(w, cx, mt); }\n+        ty::ty_ptr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n+        ty::ty_rptr(r, mt) => {\n+            mywrite!(w, \"&\");\n+            enc_region(w, cx, r);\n+            enc_mt(w, cx, mt);\n+        }\n+        ty::ty_evec(mt, v) => {\n+            mywrite!(w, \"V\");\n+            enc_mt(w, cx, mt);\n+            enc_vstore(w, cx, v);\n+        }\n+        ty::ty_estr(v) => {\n+            mywrite!(w, \"v\");\n+            enc_vstore(w, cx, v);\n+        }\n+        ty::ty_unboxed_vec(mt) => { mywrite!(w, \"U\"); enc_mt(w, cx, mt); }\n+        ty::ty_closure(ref f) => {\n+            mywrite!(w, \"f\");\n+            enc_closure_ty(w, cx, f);\n+        }\n+        ty::ty_bare_fn(ref f) => {\n+            mywrite!(w, \"F\");\n+            enc_bare_fn_ty(w, cx, f);\n+        }\n+        ty::ty_infer(_) => {\n+            cx.diag.handler().bug(\"Cannot encode inference variable types\");\n+        }\n+        ty::ty_param(param_ty {idx: id, def_id: did}) => {\n+            mywrite!(w, \"p{}|{}\", (cx.ds)(did), id);\n+        }\n+        ty::ty_self(did) => {\n+            mywrite!(w, \"s{}|\", (cx.ds)(did));\n+        }\n+        ty::ty_type => mywrite!(w, \"Y\"),\n+        ty::ty_opaque_closure_ptr(p) => {\n+            mywrite!(w, \"C&\");\n+            enc_sigil(w, p);\n+        }\n+        ty::ty_opaque_box => mywrite!(w, \"B\"),\n+        ty::ty_struct(def, ref substs) => {\n+            mywrite!(w, \"a[{}|\", (cx.ds)(def));\n+            enc_substs(w, cx, substs);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_err => fail!(\"Shouldn't encode error type\")\n     }\n }\n \n-fn enc_sigil(w: @io::Writer, sigil: Sigil) {\n+fn enc_sigil(w: @mut MemWriter, sigil: Sigil) {\n     match sigil {\n-        ManagedSigil => w.write_str(\"@\"),\n-        OwnedSigil => w.write_str(\"~\"),\n-        BorrowedSigil => w.write_str(\"&\"),\n+        ManagedSigil => mywrite!(w, \"@\"),\n+        OwnedSigil => mywrite!(w, \"~\"),\n+        BorrowedSigil => mywrite!(w, \"&\"),\n     }\n }\n \n-fn enc_purity(w: @io::Writer, p: purity) {\n+fn enc_purity(w: @mut MemWriter, p: purity) {\n     match p {\n-      impure_fn => w.write_char('i'),\n-      unsafe_fn => w.write_char('u'),\n-      extern_fn => w.write_char('c')\n+        impure_fn => mywrite!(w, \"i\"),\n+        unsafe_fn => mywrite!(w, \"u\"),\n+        extern_fn => mywrite!(w, \"c\")\n     }\n }\n \n-fn enc_abi_set(w: @io::Writer, abis: AbiSet) {\n-    w.write_char('[');\n+fn enc_abi_set(w: @mut MemWriter, abis: AbiSet) {\n+    mywrite!(w, \"[\");\n     do abis.each |abi| {\n-        w.write_str(abi.name());\n-        w.write_char(',');\n+        mywrite!(w, \"{},\", abi.name());\n         true\n     };\n-    w.write_char(']')\n+    mywrite!(w, \"]\")\n }\n \n-fn enc_onceness(w: @io::Writer, o: Onceness) {\n+fn enc_onceness(w: @mut MemWriter, o: Onceness) {\n     match o {\n-        Once => w.write_char('o'),\n-        Many => w.write_char('m')\n+        Once => mywrite!(w, \"o\"),\n+        Many => mywrite!(w, \"m\")\n     }\n }\n \n-pub fn enc_bare_fn_ty(w: @io::Writer, cx: @ctxt, ft: &ty::BareFnTy) {\n+pub fn enc_bare_fn_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::BareFnTy) {\n     enc_purity(w, ft.purity);\n     enc_abi_set(w, ft.abis);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_closure_ty(w: @io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n+fn enc_closure_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_sigil(w, ft.sigil);\n     enc_purity(w, ft.purity);\n     enc_onceness(w, ft.onceness);\n@@ -400,37 +365,34 @@ fn enc_closure_ty(w: @io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n-    w.write_char('[');\n+fn enc_fn_sig(w: @mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n+    mywrite!(w, \"[\");\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n     }\n-    w.write_char(']');\n+    mywrite!(w, \"]\");\n     enc_ty(w, cx, fsig.output);\n }\n \n-fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: &ty::ParamBounds) {\n+fn enc_bounds(w: @mut MemWriter, cx: @ctxt, bs: &ty::ParamBounds) {\n     for bound in bs.builtin_bounds.iter() {\n         match bound {\n-            ty::BoundSend => w.write_char('S'),\n-            ty::BoundFreeze => w.write_char('K'),\n-            ty::BoundStatic => w.write_char('O'),\n-            ty::BoundSized => w.write_char('Z'),\n+            ty::BoundSend => mywrite!(w, \"S\"),\n+            ty::BoundFreeze => mywrite!(w, \"K\"),\n+            ty::BoundStatic => mywrite!(w, \"O\"),\n+            ty::BoundSized => mywrite!(w, \"Z\"),\n         }\n     }\n \n     for &tp in bs.trait_bounds.iter() {\n-        w.write_char('I');\n+        mywrite!(w, \"I\");\n         enc_trait_ref(w, cx, tp);\n     }\n \n-    w.write_char('.');\n+    mywrite!(w, \".\");\n }\n \n-pub fn enc_type_param_def(w: @io::Writer, cx: @ctxt, v: &ty::TypeParameterDef) {\n-    w.write_str(cx.tcx.sess.str_of(v.ident));\n-    w.write_char(':');\n-    w.write_str((cx.ds)(v.def_id));\n-    w.write_char('|');\n+pub fn enc_type_param_def(w: @mut MemWriter, cx: @ctxt, v: &ty::TypeParameterDef) {\n+    mywrite!(w, \"{}:{}|\", cx.tcx.sess.str_of(v.ident), (cx.ds)(v.def_id));\n     enc_bounds(w, cx, v.bounds);\n }"}, {"sha": "cb8c7b3262fbf2ecfb195cfbe60cf7556b9bb585", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "patch": "@@ -23,13 +23,6 @@ use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n \n-use std::at_vec;\n-use std::libc;\n-use extra::ebml::reader;\n-use extra::ebml;\n-use extra::serialize;\n-use extra::serialize::{Encoder, Encodable, EncoderHelpers, DecoderHelpers};\n-use extra::serialize::{Decoder, Decodable};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::inlined_item_utils;\n@@ -40,9 +33,18 @@ use syntax::fold::*;\n use syntax::fold;\n use syntax::parse::token;\n use syntax;\n-use writer = extra::ebml::writer;\n \n+use std::at_vec;\n+use std::libc;\n use std::cast;\n+use std::rt::io::Seek;\n+\n+use extra::ebml::reader;\n+use extra::ebml;\n+use extra::serialize;\n+use extra::serialize::{Encoder, Encodable, EncoderHelpers, DecoderHelpers};\n+use extra::serialize::{Decoder, Decodable};\n+use writer = extra::ebml::writer;\n \n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n@@ -1319,14 +1321,14 @@ fn mk_ctxt() -> @fake_ext_ctxt {\n \n #[cfg(test)]\n fn roundtrip(in_item: Option<@ast::item>) {\n-    use std::io;\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n \n     let in_item = in_item.unwrap();\n-    let bytes = do io::with_bytes_writer |wr| {\n-        let mut ebml_w = writer::Encoder(wr);\n-        encode_item_ast(&mut ebml_w, in_item);\n-    };\n-    let ebml_doc = reader::Doc(@bytes);\n+    let wr = @mut MemWriter::new();\n+    let mut ebml_w = writer::Encoder(wr);\n+    encode_item_ast(&mut ebml_w, in_item);\n+    let ebml_doc = reader::Doc(@wr.inner_ref().to_owned());\n     let out_item = decode_item_ast(ebml_doc);\n \n     assert_eq!(in_item, out_item);"}, {"sha": "0ec37cd3c07894f46906fca2bb3e069ad2d82417", "filename": "src/libstd/rt/io/mem.rs", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmem.rs?ref=c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "patch": "@@ -22,46 +22,66 @@ use vec;\n \n /// Writes to an owned, growable byte vector\n pub struct MemWriter {\n-    priv buf: ~[u8]\n+    priv buf: ~[u8],\n+    priv pos: uint,\n }\n \n impl MemWriter {\n-    pub fn new() -> MemWriter { MemWriter { buf: vec::with_capacity(128) } }\n+    pub fn new() -> MemWriter {\n+        MemWriter { buf: vec::with_capacity(128), pos: 0 }\n+    }\n }\n \n impl Writer for MemWriter {\n     fn write(&mut self, buf: &[u8]) {\n-        self.buf.push_all(buf)\n+        // Make sure the internal buffer is as least as big as where we\n+        // currently are\n+        let difference = self.pos as i64 - self.buf.len() as i64;\n+        if difference > 0 {\n+            self.buf.grow(difference as uint, &0);\n+        }\n+\n+        // Figure out what bytes will be used to overwrite what's currently\n+        // there (left), and what will be appended on the end (right)\n+        let cap = self.buf.len() - self.pos;\n+        let (left, right) = if cap <= buf.len() {\n+            (buf.slice_to(cap), buf.slice_from(cap))\n+        } else {\n+            (buf, &[])\n+        };\n+\n+        // Do the necessary writes\n+        if left.len() > 0 {\n+            vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos),\n+                                    left, left.len());\n+        }\n+        if right.len() > 0 {\n+            self.buf.push_all(right);\n+        }\n+\n+        // Bump us forward\n+        self.pos += buf.len();\n     }\n \n     fn flush(&mut self) { /* no-op */ }\n }\n \n impl Seek for MemWriter {\n-    fn tell(&self) -> u64 { self.buf.len() as u64 }\n-\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n-}\n-\n-impl Decorator<~[u8]> for MemWriter {\n-\n-    fn inner(self) -> ~[u8] {\n-        match self {\n-            MemWriter { buf: buf } => buf\n-        }\n-    }\n+    fn tell(&self) -> u64 { self.pos as u64 }\n \n-    fn inner_ref<'a>(&'a self) -> &'a ~[u8] {\n-        match *self {\n-            MemWriter { buf: ref buf } => buf\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        match style {\n+            SeekSet => { self.pos = pos as uint; }\n+            SeekEnd => { self.pos = self.buf.len() + pos as uint; }\n+            SeekCur => { self.pos += pos as uint; }\n         }\n     }\n+}\n \n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] {\n-        match *self {\n-            MemWriter { buf: ref mut buf } => buf\n-        }\n-    }\n+impl Decorator<~[u8]> for MemWriter {\n+    fn inner(self) -> ~[u8] { self.buf }\n+    fn inner_ref<'a>(&'a self) -> &'a ~[u8] { &self.buf }\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] { &mut self.buf }\n }\n \n /// Reads from an owned byte vector\n@@ -208,6 +228,7 @@ pub fn with_mem_writer(writeFn:&fn(&mut MemWriter)) -> ~[u8] {\n mod test {\n     use prelude::*;\n     use super::*;\n+    use rt::io::*;\n \n     #[test]\n     fn test_mem_writer() {\n@@ -218,7 +239,24 @@ mod test {\n         writer.write([1, 2, 3]);\n         writer.write([4, 5, 6, 7]);\n         assert_eq!(writer.tell(), 8);\n-        assert_eq!(writer.inner(), ~[0, 1, 2, 3, 4, 5 , 6, 7]);\n+        assert_eq!(*writer.inner_ref(), ~[0, 1, 2, 3, 4, 5, 6, 7]);\n+\n+        writer.seek(0, SeekSet);\n+        assert_eq!(writer.tell(), 0);\n+        writer.write([3, 4]);\n+        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 3, 4, 5, 6, 7]);\n+\n+        writer.seek(1, SeekCur);\n+        writer.write([0, 1]);\n+        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 7]);\n+\n+        writer.seek(-1, SeekEnd);\n+        writer.write([1, 2]);\n+        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 1, 2]);\n+\n+        writer.seek(1, SeekEnd);\n+        writer.write([1]);\n+        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n     }\n \n     #[test]"}, {"sha": "8d3ad26764281ee52d68784e491e94268f86b81e", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "patch": "@@ -17,7 +17,8 @@\n \n extern mod extra;\n \n-use std::io;\n+use std::rt::io::mem::MemWriter;\n+use std::rt::io::Decorator;\n use std::rand::{random, Rand};\n use extra::serialize::{Encodable, Decodable};\n use extra::ebml;\n@@ -55,11 +56,10 @@ struct G<T> {\n \n fn roundtrip<T: Rand + Eq + Encodable<Encoder> + Decodable<Decoder>>() {\n     let obj: T = random();\n-    let bytes = do io::with_bytes_writer |w| {\n-        let mut e = Encoder(w);\n-        obj.encode(&mut e);\n-    };\n-    let doc = ebml::reader::Doc(@bytes);\n+    let w = @mut MemWriter::new();\n+    let mut e = Encoder(w);\n+    obj.encode(&mut e);\n+    let doc = ebml::reader::Doc(@w.inner_ref().to_owned());\n     let mut dec = Decoder(doc);\n     let obj2 = Decodable::decode(&mut dec);\n     assert!(obj == obj2);"}]}