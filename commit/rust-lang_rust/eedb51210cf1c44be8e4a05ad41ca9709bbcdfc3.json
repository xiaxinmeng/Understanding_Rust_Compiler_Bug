{"sha": "eedb51210cf1c44be8e4a05ad41ca9709bbcdfc3", "node_id": "C_kwDOAAsO6NoAKGVlZGI1MTIxMGNmMWM0NGJlOGU0YTA1YWQ0MWNhOTcwOWJiY2RmYzM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-03T18:58:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-03T18:58:54Z"}, "message": "Rollup merge of #99460 - JanBeh:PR_asref_asmut_docs, r=joshtriplett\n\ndocs: Improve AsRef / AsMut docs on blanket impls\n\nThere are several issues with the current state of `AsRef` and `AsMut` as [discussed here on IRLO](https://internals.rust-lang.org/t/semantics-of-asref/17016). See also #39397, #45742, #73390, #98905, and the FIXMEs [here](https://github.com/rust-lang/rust/blob/1.62.0/library/core/src/convert/mod.rs#L509-L515) and [here](https://github.com/rust-lang/rust/blob/1.62.0/library/core/src/convert/mod.rs#L530-L536). These issues are difficult to fix. This PR aims to update the documentation to better reflect the status-quo and to give advice on how `AsRef` and `AsMut` should be used.\n\nIn particular:\n\n- Explicitly mention that `AsRef` and `AsMut` do not auto-dereference generally for all dereferencable types (but only if inner type is a shared and/or mutable reference)\n- Give advice to not use `AsRef` or `AsMut` for the sole purpose of dereferencing\n- Suggest providing a transitive `AsRef` or `AsMut` implementation for types which implement `Deref`\n- Add new section \"Reflexivity\" in documentation comments for `AsRef` and `AsMut`\n- Provide better example for `AsMut`\n- Added heading \"Relation to `Borrow`\" in `AsRef`'s docs to improve structure", "tree": {"sha": "605b93ff7fa6c401dabd15bb71a44b8000d1a4bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/605b93ff7fa6c401dabd15bb71a44b8000d1a4bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eedb51210cf1c44be8e4a05ad41ca9709bbcdfc3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjOzDuCRBK7hj4Ov3rIwAAvDgIADXDBwQvAYDKDpUSVVE/VtYE\noTLA5as9xOR3mTJlVWPGshR1r73U6oI23DhmjtQqfKr7/8XoXfjjq1cMap/XX0ZO\nRPfqbpXUgZ2X4xZ5mxCvcsDU0P++slcjYFlcIPgFcNHdg1FyuV8JMo7oLGHXGH9n\nqgEhx14oVCX6l707TmIRYJDZEb7IE8IK8Ti+9l7IcGiXqQSjn76Z7VZoQCb3t3Zi\nk5vPYG17ExAB5riblzn+dzmZsYl2b4+3MutneNrMW5NxqgVDPPjYQz0wT1zXWnCO\nlIoI9KJ+sAvgILfXVvefjn+PuqXubkfSafIUifdeCuQ+HmJGdH4XgjWEhS8UA94=\n=VBNt\n-----END PGP SIGNATURE-----\n", "payload": "tree 605b93ff7fa6c401dabd15bb71a44b8000d1a4bf\nparent 2110d2de5a894f3088e1d8f20404876e2ef4b65e\nparent e6b761b902fe80ba454368d078fb834554981109\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1664823534 +0200\ncommitter GitHub <noreply@github.com> 1664823534 +0200\n\nRollup merge of #99460 - JanBeh:PR_asref_asmut_docs, r=joshtriplett\n\ndocs: Improve AsRef / AsMut docs on blanket impls\n\nThere are several issues with the current state of `AsRef` and `AsMut` as [discussed here on IRLO](https://internals.rust-lang.org/t/semantics-of-asref/17016). See also #39397, #45742, #73390, #98905, and the FIXMEs [here](https://github.com/rust-lang/rust/blob/1.62.0/library/core/src/convert/mod.rs#L509-L515) and [here](https://github.com/rust-lang/rust/blob/1.62.0/library/core/src/convert/mod.rs#L530-L536). These issues are difficult to fix. This PR aims to update the documentation to better reflect the status-quo and to give advice on how `AsRef` and `AsMut` should be used.\n\nIn particular:\n\n- Explicitly mention that `AsRef` and `AsMut` do not auto-dereference generally for all dereferencable types (but only if inner type is a shared and/or mutable reference)\n- Give advice to not use `AsRef` or `AsMut` for the sole purpose of dereferencing\n- Suggest providing a transitive `AsRef` or `AsMut` implementation for types which implement `Deref`\n- Add new section \"Reflexivity\" in documentation comments for `AsRef` and `AsMut`\n- Provide better example for `AsMut`\n- Added heading \"Relation to `Borrow`\" in `AsRef`'s docs to improve structure\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eedb51210cf1c44be8e4a05ad41ca9709bbcdfc3", "html_url": "https://github.com/rust-lang/rust/commit/eedb51210cf1c44be8e4a05ad41ca9709bbcdfc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eedb51210cf1c44be8e4a05ad41ca9709bbcdfc3/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2110d2de5a894f3088e1d8f20404876e2ef4b65e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2110d2de5a894f3088e1d8f20404876e2ef4b65e", "html_url": "https://github.com/rust-lang/rust/commit/2110d2de5a894f3088e1d8f20404876e2ef4b65e"}, {"sha": "e6b761b902fe80ba454368d078fb834554981109", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6b761b902fe80ba454368d078fb834554981109", "html_url": "https://github.com/rust-lang/rust/commit/e6b761b902fe80ba454368d078fb834554981109"}], "stats": {"total": 205, "additions": 187, "deletions": 18}, "files": [{"sha": "223695c2bec7b48b893358d455e0052e7a283cef", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 187, "deletions": 18, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/eedb51210cf1c44be8e4a05ad41ca9709bbcdfc3/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb51210cf1c44be8e4a05ad41ca9709bbcdfc3/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=eedb51210cf1c44be8e4a05ad41ca9709bbcdfc3", "patch": "@@ -25,6 +25,7 @@\n //! # Generic Implementations\n //!\n //! - [`AsRef`] and [`AsMut`] auto-dereference if the inner type is a reference\n+//!   (but not generally for all [dereferenceable types][core::ops::Deref])\n //! - [`From`]`<U> for T` implies [`Into`]`<T> for U`\n //! - [`TryFrom`]`<U> for T` implies [`TryInto`]`<T> for U`\n //! - [`From`] and [`Into`] are reflexive, which means that all types can\n@@ -109,10 +110,12 @@ pub const fn identity<T>(x: T) -> T {\n /// If you need to do a costly conversion it is better to implement [`From`] with type\n /// `&T` or write a custom function.\n ///\n+/// # Relation to `Borrow`\n+///\n /// `AsRef` has the same signature as [`Borrow`], but [`Borrow`] is different in a few aspects:\n ///\n /// - Unlike `AsRef`, [`Borrow`] has a blanket impl for any `T`, and can be used to accept either\n-///   a reference or a value.\n+///   a reference or a value. (See also note on `AsRef`'s reflexibility below.)\n /// - [`Borrow`] also requires that [`Hash`], [`Eq`] and [`Ord`] for a borrowed value are\n ///   equivalent to those of the owned value. For this reason, if you want to\n ///   borrow only a single field of a struct you can implement `AsRef`, but not [`Borrow`].\n@@ -122,9 +125,66 @@ pub const fn identity<T>(x: T) -> T {\n ///\n /// # Generic Implementations\n ///\n-/// - `AsRef` auto-dereferences if the inner type is a reference or a mutable\n-///   reference (e.g.: `foo.as_ref()` will work the same if `foo` has type\n-///   `&mut Foo` or `&&mut Foo`)\n+/// `AsRef` auto-dereferences if the inner type is a reference or a mutable reference\n+/// (e.g.: `foo.as_ref()` will work the same if `foo` has type `&mut Foo` or `&&mut Foo`).\n+///\n+/// Note that due to historic reasons, the above currently does not hold generally for all\n+/// [dereferenceable types], e.g. `foo.as_ref()` will *not* work the same as\n+/// `Box::new(foo).as_ref()`. Instead, many smart pointers provide an `as_ref` implementation which\n+/// simply returns a reference to the [pointed-to value] (but do not perform a cheap\n+/// reference-to-reference conversion for that value). However, [`AsRef::as_ref`] should not be\n+/// used for the sole purpose of dereferencing; instead ['`Deref` coercion'] can be used:\n+///\n+/// [dereferenceable types]: core::ops::Deref\n+/// [pointed-to value]: core::ops::Deref::Target\n+/// ['`Deref` coercion']: core::ops::Deref#more-on-deref-coercion\n+///\n+/// ```\n+/// let x = Box::new(5i32);\n+/// // Avoid this:\n+/// // let y: &i32 = x.as_ref();\n+/// // Better just write:\n+/// let y: &i32 = &x;\n+/// ```\n+///\n+/// Types which implement [`Deref`] should consider implementing `AsRef<T>` as follows:\n+///\n+/// [`Deref`]: core::ops::Deref\n+///\n+/// ```\n+/// # use core::ops::Deref;\n+/// # struct SomeType;\n+/// # impl Deref for SomeType {\n+/// #     type Target = [u8];\n+/// #     fn deref(&self) -> &[u8] {\n+/// #         &[]\n+/// #     }\n+/// # }\n+/// impl<T> AsRef<T> for SomeType\n+/// where\n+///     T: ?Sized,\n+///     <SomeType as Deref>::Target: AsRef<T>,\n+/// {\n+///     fn as_ref(&self) -> &T {\n+///         self.deref().as_ref()\n+///     }\n+/// }\n+/// ```\n+///\n+/// # Reflexivity\n+///\n+/// Ideally, `AsRef` would be reflexive, i.e. there would be an `impl<T: ?Sized> AsRef<T> for T`\n+/// with [`as_ref`] simply returning its argument unchanged.\n+/// Such a blanket implementation is currently *not* provided due to technical restrictions of\n+/// Rust's type system (it would be overlapping with another existing blanket implementation for\n+/// `&T where T: AsRef<U>` which allows `AsRef` to auto-dereference, see \"Generic Implementations\"\n+/// above).\n+///\n+/// [`as_ref`]: AsRef::as_ref\n+///\n+/// A trivial implementation of `AsRef<T> for T` must be added explicitly for a particular type `T`\n+/// where needed or desired. Note, however, that not all types from `std` contain such an\n+/// implementation, and those cannot be added by external code due to orphan rules.\n ///\n /// # Examples\n ///\n@@ -172,29 +232,138 @@ pub trait AsRef<T: ?Sized> {\n ///\n /// # Generic Implementations\n ///\n-/// - `AsMut` auto-dereferences if the inner type is a mutable reference\n-///   (e.g.: `foo.as_mut()` will work the same if `foo` has type `&mut Foo`\n-///   or `&mut &mut Foo`)\n+/// `AsMut` auto-dereferences if the inner type is a mutable reference\n+/// (e.g.: `foo.as_mut()` will work the same if `foo` has type `&mut Foo` or `&mut &mut Foo`).\n+///\n+/// Note that due to historic reasons, the above currently does not hold generally for all\n+/// [mutably dereferenceable types], e.g. `foo.as_mut()` will *not* work the same as\n+/// `Box::new(foo).as_mut()`. Instead, many smart pointers provide an `as_mut` implementation which\n+/// simply returns a reference to the [pointed-to value] (but do not perform a cheap\n+/// reference-to-reference conversion for that value). However, [`AsMut::as_mut`] should not be\n+/// used for the sole purpose of mutable dereferencing; instead ['`Deref` coercion'] can be used:\n+///\n+/// [mutably dereferenceable types]: core::ops::DerefMut\n+/// [pointed-to value]: core::ops::Deref::Target\n+/// ['`Deref` coercion']: core::ops::DerefMut#more-on-deref-coercion\n+///\n+/// ```\n+/// let mut x = Box::new(5i32);\n+/// // Avoid this:\n+/// // let y: &mut i32 = x.as_mut();\n+/// // Better just write:\n+/// let y: &mut i32 = &mut x;\n+/// ```\n+///\n+/// Types which implement [`DerefMut`] should consider to add an implementation of `AsMut<T>` as\n+/// follows:\n+///\n+/// [`DerefMut`]: core::ops::DerefMut\n+///\n+/// ```\n+/// # use core::ops::{Deref, DerefMut};\n+/// # struct SomeType;\n+/// # impl Deref for SomeType {\n+/// #     type Target = [u8];\n+/// #     fn deref(&self) -> &[u8] {\n+/// #         &[]\n+/// #     }\n+/// # }\n+/// # impl DerefMut for SomeType {\n+/// #     fn deref_mut(&mut self) -> &mut [u8] {\n+/// #         &mut []\n+/// #     }\n+/// # }\n+/// impl<T> AsMut<T> for SomeType\n+/// where\n+///     <SomeType as Deref>::Target: AsMut<T>,\n+/// {\n+///     fn as_mut(&mut self) -> &mut T {\n+///         self.deref_mut().as_mut()\n+///     }\n+/// }\n+/// ```\n+///\n+/// # Reflexivity\n+///\n+/// Ideally, `AsMut` would be reflexive, i.e. there would be an `impl<T: ?Sized> AsMut<T> for T`\n+/// with [`as_mut`] simply returning its argument unchanged.\n+/// Such a blanket implementation is currently *not* provided due to technical restrictions of\n+/// Rust's type system (it would be overlapping with another existing blanket implementation for\n+/// `&mut T where T: AsMut<U>` which allows `AsMut` to auto-dereference, see \"Generic\n+/// Implementations\" above).\n+///\n+/// [`as_mut`]: AsMut::as_mut\n+///\n+/// A trivial implementation of `AsMut<T> for T` must be added explicitly for a particular type `T`\n+/// where needed or desired. Note, however, that not all types from `std` contain such an\n+/// implementation, and those cannot be added by external code due to orphan rules.\n ///\n /// # Examples\n ///\n-/// Using `AsMut` as trait bound for a generic function we can accept all mutable references\n-/// that can be converted to type `&mut T`. Because [`Box<T>`] implements `AsMut<T>` we can\n-/// write a function `add_one` that takes all arguments that can be converted to `&mut u64`.\n-/// Because [`Box<T>`] implements `AsMut<T>`, `add_one` accepts arguments of type\n-/// `&mut Box<u64>` as well:\n+/// Using `AsMut` as trait bound for a generic function, we can accept all mutable references that\n+/// can be converted to type `&mut T`. Unlike [dereference], which has a single [target type],\n+/// there can be multiple implementations of `AsMut` for a type. In particular, `Vec<T>` implements\n+/// both `AsMut<Vec<T>>` and `AsMut<[T]>`.\n+///\n+/// In the following, the example functions `caesar` and `null_terminate` provide a generic\n+/// interface which work with any type that can be converted by cheap mutable-to-mutable conversion\n+/// into a byte slice (`[u8]`) or byte vector (`Vec<u8>`), respectively.\n+///\n+/// [dereference]: core::ops::DerefMut\n+/// [target type]: core::ops::Deref::Target\n ///\n /// ```\n-/// fn add_one<T: AsMut<u64>>(num: &mut T) {\n-///     *num.as_mut() += 1;\n+/// struct Document {\n+///     info: String,\n+///     content: Vec<u8>,\n /// }\n ///\n-/// let mut boxed_num = Box::new(0);\n-/// add_one(&mut boxed_num);\n-/// assert_eq!(*boxed_num, 1);\n+/// impl<T: ?Sized> AsMut<T> for Document\n+/// where\n+///     Vec<u8>: AsMut<T>,\n+/// {\n+///     fn as_mut(&mut self) -> &mut T {\n+///         self.content.as_mut()\n+///     }\n+/// }\n+///\n+/// fn caesar<T: AsMut<[u8]>>(data: &mut T, key: u8) {\n+///     for byte in data.as_mut() {\n+///         *byte = byte.wrapping_add(key);\n+///     }\n+/// }\n+///\n+/// fn null_terminate<T: AsMut<Vec<u8>>>(data: &mut T) {\n+///     // Using a non-generic inner function, which contains most of the\n+///     // functionality, helps to minimize monomorphization overhead.\n+///     fn doit(data: &mut Vec<u8>) {\n+///         let len = data.len();\n+///         if len == 0 || data[len-1] != 0 {\n+///             data.push(0);\n+///         }\n+///     }\n+///     doit(data.as_mut());\n+/// }\n+///\n+/// fn main() {\n+///     let mut v: Vec<u8> = vec![1, 2, 3];\n+///     caesar(&mut v, 5);\n+///     assert_eq!(v, [6, 7, 8]);\n+///     null_terminate(&mut v);\n+///     assert_eq!(v, [6, 7, 8, 0]);\n+///     let mut doc = Document {\n+///         info: String::from(\"Example\"),\n+///         content: vec![17, 19, 8],\n+///     };\n+///     caesar(&mut doc, 1);\n+///     assert_eq!(doc.content, [18, 20, 9]);\n+///     null_terminate(&mut doc);\n+///     assert_eq!(doc.content, [18, 20, 9, 0]);\n+/// }\n /// ```\n ///\n-/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+/// Note, however, that APIs don't need to be generic. In many cases taking a `&mut [u8]` or\n+/// `&mut Vec<u8>`, for example, is the better choice (callers need to pass the correct type then).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"AsMut\")]\n #[const_trait]"}]}