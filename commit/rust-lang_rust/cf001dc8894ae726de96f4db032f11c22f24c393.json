{"sha": "cf001dc8894ae726de96f4db032f11c22f24c393", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMDAxZGM4ODk0YWU3MjZkZTk2ZjRkYjAzMmYxMWMyMmYyNGMzOTM=", "commit": {"author": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-07-15T14:41:35Z"}, "committer": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-07-15T14:58:49Z"}, "message": "Remove failed and review comments", "tree": {"sha": "52600044019d2956bd422dcc89e7a5aaa156483b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52600044019d2956bd422dcc89e7a5aaa156483b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf001dc8894ae726de96f4db032f11c22f24c393", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf001dc8894ae726de96f4db032f11c22f24c393", "html_url": "https://github.com/rust-lang/rust/commit/cf001dc8894ae726de96f4db032f11c22f24c393", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf001dc8894ae726de96f4db032f11c22f24c393/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09978bdcd154aeac01e06a801fe33d29e57a6bdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/09978bdcd154aeac01e06a801fe33d29e57a6bdc", "html_url": "https://github.com/rust-lang/rust/commit/09978bdcd154aeac01e06a801fe33d29e57a6bdc"}], "stats": {"total": 168, "additions": 69, "deletions": 99}, "files": [{"sha": "98fde3707f70ed0613f968590428144582bc22bd", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 56, "deletions": 86, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/cf001dc8894ae726de96f4db032f11c22f24c393/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf001dc8894ae726de96f4db032f11c22f24c393/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=cf001dc8894ae726de96f4db032f11c22f24c393", "patch": "@@ -315,9 +315,11 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n     fn fold<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n         let value = self.selcx.infcx().resolve_vars_if_possible(value);\n \n-        if value.has_escaping_bound_vars() {\n-            bug!(\"Normalizing without wrapping in a `Binder`\");\n-        }\n+        assert!(\n+            !value.has_escaping_bound_vars(),\n+            \"Normalizing {:?} without wrapping in a `Binder`\",\n+            value\n+        );\n \n         if !value.has_projections() { value } else { value.fold_with(self) }\n     }\n@@ -427,40 +429,36 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 // give up and fall back to pretending like we never tried!\n \n                 let infcx = self.selcx.infcx();\n-                let replaced =\n+                let (data, mapped_regions, mapped_types, mapped_consts) =\n                     BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n-                if let Some((data, mapped_regions, mapped_types, mapped_consts)) = replaced {\n-                    let normalized_ty = opt_normalize_projection_type(\n-                        self.selcx,\n-                        self.param_env,\n-                        data,\n-                        self.cause.clone(),\n-                        self.depth,\n-                        &mut self.obligations,\n-                    )\n-                    .ok()\n-                    .flatten()\n-                    .unwrap_or_else(|| ty);\n-\n-                    let normalized_ty = PlaceholderReplacer::replace_placeholders(\n-                        infcx,\n-                        mapped_regions,\n-                        mapped_types,\n-                        mapped_consts,\n-                        &self.universes,\n-                        normalized_ty,\n-                    );\n-                    debug!(\n-                        ?self.depth,\n-                        ?ty,\n-                        ?normalized_ty,\n-                        obligations.len = ?self.obligations.len(),\n-                        \"AssocTypeNormalizer: normalized type\"\n-                    );\n-                    normalized_ty\n-                } else {\n-                    ty\n-                }\n+                let normalized_ty = opt_normalize_projection_type(\n+                    self.selcx,\n+                    self.param_env,\n+                    data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                )\n+                .ok()\n+                .flatten()\n+                .unwrap_or_else(|| ty);\n+\n+                let normalized_ty = PlaceholderReplacer::replace_placeholders(\n+                    infcx,\n+                    mapped_regions,\n+                    mapped_types,\n+                    mapped_consts,\n+                    &self.universes,\n+                    normalized_ty,\n+                );\n+                debug!(\n+                    ?self.depth,\n+                    ?ty,\n+                    ?normalized_ty,\n+                    obligations.len = ?self.obligations.len(),\n+                    \"AssocTypeNormalizer: normalized type\"\n+                );\n+                normalized_ty\n             }\n \n             _ => ty,\n@@ -491,14 +489,6 @@ pub struct BoundVarReplacer<'me, 'tcx> {\n     // The `UniverseIndex` of the binding levels above us. These are optional, since we are lazy:\n     // we don't actually create a universe until we see a bound var we have to replace.\n     universe_indices: &'me mut Vec<Option<ty::UniverseIndex>>,\n-    // FIXME: So, this is a less-than-ideal solution to a problem we want to solve eventually. Ideally, we\n-    // shouldn't need to worry about bound vars for which we haven't passed (`self.current_index`)\n-    // or that we don't explicitly know about (`self.universe_indices`). This is true for\n-    // `AssocTypeNormalizer` but not `QueryNormalizer` currently. When we can always know about\n-    // any binding levels above us, we can remove this. (The alternative would be\n-    // `outer_exclusive_binder`, but that only exists on `Ty`. Otherwise, we would have to visit\n-    // through the `T`, which we specifically want to avoid not being lazy.)\n-    failed: bool,\n }\n \n impl<'me, 'tcx> BoundVarReplacer<'me, 'tcx> {\n@@ -508,12 +498,12 @@ impl<'me, 'tcx> BoundVarReplacer<'me, 'tcx> {\n         infcx: &'me InferCtxt<'me, 'tcx>,\n         universe_indices: &'me mut Vec<Option<ty::UniverseIndex>>,\n         value: T,\n-    ) -> Option<(\n+    ) -> (\n         T,\n         BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n         BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n         BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n-    )> {\n+    ) {\n         let mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion> = BTreeMap::new();\n         let mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy> = BTreeMap::new();\n         let mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar> = BTreeMap::new();\n@@ -525,14 +515,24 @@ impl<'me, 'tcx> BoundVarReplacer<'me, 'tcx> {\n             mapped_consts,\n             current_index: ty::INNERMOST,\n             universe_indices,\n-            failed: false,\n         };\n \n         let value = value.super_fold_with(&mut replacer);\n \n-        (!replacer.failed).then(|| {\n-            (value, replacer.mapped_regions, replacer.mapped_types, replacer.mapped_consts)\n-        })\n+        (value, replacer.mapped_regions, replacer.mapped_types, replacer.mapped_consts)\n+    }\n+\n+    fn universe_for(&mut self, debruijn: ty::DebruijnIndex) -> ty::UniverseIndex {\n+        let infcx = self.infcx;\n+        let index =\n+            self.universe_indices.len() - debruijn.as_usize() + self.current_index.as_usize() - 1;\n+        let universe = self.universe_indices[index].unwrap_or_else(|| {\n+            for i in self.universe_indices.iter_mut().take(index + 1) {\n+                *i = i.or_else(|| Some(infcx.create_next_universe()))\n+            }\n+            self.universe_indices[index].unwrap()\n+        });\n+        universe\n     }\n }\n \n@@ -557,20 +557,10 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                 if debruijn.as_usize() + 1\n                     > self.current_index.as_usize() + self.universe_indices.len() =>\n             {\n-                self.failed = true;\n-                r\n+                bug!(\"Bound vars outside of `self.universe_indices`\");\n             }\n             ty::ReLateBound(debruijn, br) if debruijn >= self.current_index => {\n-                let infcx = self.infcx;\n-                let index = self.universe_indices.len() - debruijn.as_usize()\n-                    + self.current_index.as_usize()\n-                    - 1;\n-                let universe = self.universe_indices[index].unwrap_or_else(|| {\n-                    for i in self.universe_indices.iter_mut().take(index + 1) {\n-                        *i = i.or_else(|| Some(infcx.create_next_universe()))\n-                    }\n-                    self.universe_indices[index].unwrap()\n-                });\n+                let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderRegion { universe, name: br.kind };\n                 self.mapped_regions.insert(p.clone(), br);\n                 self.infcx.tcx.mk_region(ty::RePlaceholder(p))\n@@ -585,20 +575,10 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                 if debruijn.as_usize() + 1\n                     > self.current_index.as_usize() + self.universe_indices.len() =>\n             {\n-                self.failed = true;\n-                t\n+                bug!(\"Bound vars outside of `self.universe_indices`\");\n             }\n             ty::Bound(debruijn, bound_ty) if debruijn >= self.current_index => {\n-                let infcx = self.infcx;\n-                let index = self.universe_indices.len() - debruijn.as_usize()\n-                    + self.current_index.as_usize()\n-                    - 1;\n-                let universe = self.universe_indices[index].unwrap_or_else(|| {\n-                    for i in self.universe_indices.iter_mut().take(index + 1) {\n-                        *i = i.or_else(|| Some(infcx.create_next_universe()))\n-                    }\n-                    self.universe_indices[index].unwrap()\n-                });\n+                let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderType { universe, name: bound_ty.var };\n                 self.mapped_types.insert(p.clone(), bound_ty);\n                 self.infcx.tcx.mk_ty(ty::Placeholder(p))\n@@ -614,22 +594,12 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n                 if debruijn.as_usize() + 1\n                     > self.current_index.as_usize() + self.universe_indices.len() =>\n             {\n-                self.failed = true;\n-                ct\n+                bug!(\"Bound vars outside of `self.universe_indices`\");\n             }\n             ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty }\n                 if debruijn >= self.current_index =>\n             {\n-                let infcx = self.infcx;\n-                let index = self.universe_indices.len() - debruijn.as_usize()\n-                    + self.current_index.as_usize()\n-                    - 1;\n-                let universe = self.universe_indices[index].unwrap_or_else(|| {\n-                    for i in self.universe_indices.iter_mut().take(index + 1) {\n-                        *i = i.or_else(|| Some(infcx.create_next_universe()))\n-                    }\n-                    self.universe_indices[index].unwrap()\n-                });\n+                let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderConst {\n                     universe,\n                     name: ty::BoundConst { var: bound_const, ty },"}, {"sha": "94539eda0f89eff70bad2efe1e5ca8ef1f54f6e0", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cf001dc8894ae726de96f4db032f11c22f24c393/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf001dc8894ae726de96f4db032f11c22f24c393/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=cf001dc8894ae726de96f4db032f11c22f24c393", "patch": "@@ -226,21 +226,21 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // to return `ty` because there are bound vars that we aren't yet handling in a more\n                 // complete way.\n \n+                // `BoundVarReplacer` can't handle escaping bound vars. Ideally, we want this before even calling\n+                // `QueryNormalizer`, but some const-generics tests pass escaping bound vars.\n+                // Also, use `ty` so we get that sweet `outer_exclusive_binder` optimization\n+                assert!(!ty.has_vars_bound_at_or_above(ty::DebruijnIndex::from_usize(\n+                    self.universes.len()\n+                )));\n+\n                 let tcx = self.infcx.tcx;\n                 let infcx = self.infcx;\n-                let replaced = crate::traits::project::BoundVarReplacer::replace_bound_vars(\n-                    infcx,\n-                    &mut self.universes,\n-                    data,\n-                );\n-                let (data, mapped_regions, mapped_types, mapped_consts) = match replaced {\n-                    Some(r) => r,\n-                    None => {\n-                        bug!(\"{:?} {:?}\", data, self.universes);\n-                        //self.error = true;\n-                        //return ty.super_fold_with(self);\n-                    }\n-                };\n+                let (data, mapped_regions, mapped_types, mapped_consts) =\n+                    crate::traits::project::BoundVarReplacer::replace_bound_vars(\n+                        infcx,\n+                        &mut self.universes,\n+                        data,\n+                    );\n                 let data = data.super_fold_with(self);\n \n                 let mut orig_values = OriginalQueryValues::default();"}]}