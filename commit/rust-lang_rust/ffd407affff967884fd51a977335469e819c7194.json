{"sha": "ffd407affff967884fd51a977335469e819c7194", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZDQwN2FmZmZmOTY3ODg0ZmQ1MWE5NzczMzU0NjllODE5YzcxOTQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-10T20:15:41Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-10T20:15:41Z"}, "message": "Merge #778\n\n778: Glob imports r=matklad a=flodiebold\n\nThis implements glob imports, completing #231 :)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "de0f95ec9e49ee97148047622e333353f24c1433", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de0f95ec9e49ee97148047622e333353f24c1433"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffd407affff967884fd51a977335469e819c7194", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffd407affff967884fd51a977335469e819c7194", "html_url": "https://github.com/rust-lang/rust/commit/ffd407affff967884fd51a977335469e819c7194", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffd407affff967884fd51a977335469e819c7194/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "b952c270ee87cc36500b3bb03bab9268f2184d1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b952c270ee87cc36500b3bb03bab9268f2184d1a", "html_url": "https://github.com/rust-lang/rust/commit/b952c270ee87cc36500b3bb03bab9268f2184d1a"}, {"sha": "2f24e740db3365afac56aad3e8a533340369ef7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f24e740db3365afac56aad3e8a533340369ef7d", "html_url": "https://github.com/rust-lang/rust/commit/2f24e740db3365afac56aad3e8a533340369ef7d"}], "stats": {"total": 253, "additions": 240, "deletions": 13}, "files": [{"sha": "94a08aa63c68ca59e416bc0b02735beb09b31b6c", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ffd407affff967884fd51a977335469e819c7194/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd407affff967884fd51a977335469e819c7194/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=ffd407affff967884fd51a977335469e819c7194", "patch": "@@ -327,7 +327,7 @@ impl Enum {\n         db.enum_data(*self).name.clone()\n     }\n \n-    pub fn variants(&self, db: &impl HirDatabase) -> Vec<EnumVariant> {\n+    pub fn variants(&self, db: &impl PersistentHirDatabase) -> Vec<EnumVariant> {\n         db.enum_data(*self)\n             .variants\n             .iter()\n@@ -389,7 +389,7 @@ impl EnumVariant {\n         self.parent\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n+    pub fn name(&self, db: &impl PersistentHirDatabase) -> Option<Name> {\n         db.enum_data(self.parent).variants[self.id].name.clone()\n     }\n "}, {"sha": "50d4e824cd797299edc5af3f1637829fe05fff8a", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffd407affff967884fd51a977335469e819c7194/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd407affff967884fd51a977335469e819c7194/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=ffd407affff967884fd51a977335469e819c7194", "patch": "@@ -4,4 +4,6 @@ test_utils::marks!(\n     type_var_cycles_resolve_completely\n     type_var_cycles_resolve_as_possible\n     type_var_resolves_to_int_var\n+    glob_enum\n+    glob_across_crates\n );"}, {"sha": "94f7db0241df8674fc23d1db0229162e45f89baa", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 116, "deletions": 11, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/ffd407affff967884fd51a977335469e819c7194/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd407affff967884fd51a977335469e819c7194/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=ffd407affff967884fd51a977335469e819c7194", "patch": "@@ -61,7 +61,7 @@ impl ModuleScope {\n \n /// `Resolution` is basically `DefId` atm, but it should account for stuff like\n /// multiple namespaces, ambiguity and errors.\n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, PartialEq, Eq, Default)]\n pub struct Resolution {\n     /// None for unresolved\n     pub def: PerNs<ModuleDef>,\n@@ -154,6 +154,8 @@ struct Resolver<'a, DB> {\n     krate: Crate,\n     module_tree: Arc<ModuleTree>,\n     processed_imports: FxHashSet<(ModuleId, ImportId)>,\n+    /// If module `a` has `use b::*`, then this contains the mapping b -> a (and the import)\n+    glob_imports: FxHashMap<ModuleId, Vec<(ModuleId, ImportId)>>,\n     result: ItemMap,\n }\n \n@@ -173,6 +175,7 @@ where\n             krate,\n             module_tree,\n             processed_imports: FxHashSet::default(),\n+            glob_imports: FxHashMap::default(),\n             result: ItemMap::default(),\n         }\n     }\n@@ -264,14 +267,72 @@ where\n         import: &ImportData,\n     ) -> ReachedFixedPoint {\n         log::debug!(\"resolving import: {:?}\", import);\n-        if import.is_glob {\n-            return ReachedFixedPoint::Yes;\n-        };\n         let original_module = Module { krate: self.krate, module_id };\n         let (def, reached_fixedpoint) =\n             self.result.resolve_path_fp(self.db, original_module, &import.path);\n \n-        if reached_fixedpoint == ReachedFixedPoint::Yes {\n+        if reached_fixedpoint != ReachedFixedPoint::Yes {\n+            return reached_fixedpoint;\n+        }\n+\n+        if import.is_glob {\n+            log::debug!(\"glob import: {:?}\", import);\n+            match def.take_types() {\n+                Some(ModuleDef::Module(m)) => {\n+                    if m.krate != self.krate {\n+                        tested_by!(glob_across_crates);\n+                        // glob import from other crate => we can just import everything once\n+                        let item_map = self.db.item_map(m.krate);\n+                        let scope = &item_map[m.module_id];\n+                        let items = scope\n+                            .items\n+                            .iter()\n+                            .map(|(name, res)| (name.clone(), res.clone()))\n+                            .collect::<Vec<_>>();\n+                        self.update(module_id, Some(import_id), &items);\n+                    } else {\n+                        // glob import from same crate => we do an initial\n+                        // import, and then need to propagate any further\n+                        // additions\n+                        let scope = &self.result[m.module_id];\n+                        let items = scope\n+                            .items\n+                            .iter()\n+                            .map(|(name, res)| (name.clone(), res.clone()))\n+                            .collect::<Vec<_>>();\n+                        self.update(module_id, Some(import_id), &items);\n+                        // record the glob import in case we add further items\n+                        self.glob_imports\n+                            .entry(m.module_id)\n+                            .or_default()\n+                            .push((module_id, import_id));\n+                    }\n+                }\n+                Some(ModuleDef::Enum(e)) => {\n+                    tested_by!(glob_enum);\n+                    // glob import from enum => just import all the variants\n+                    let variants = e.variants(self.db);\n+                    let resolutions = variants\n+                        .into_iter()\n+                        .filter_map(|variant| {\n+                            let res = Resolution {\n+                                def: PerNs::both(variant.into(), e.into()),\n+                                import: Some(import_id),\n+                            };\n+                            let name = variant.name(self.db)?;\n+                            Some((name, res))\n+                        })\n+                        .collect::<Vec<_>>();\n+                    self.update(module_id, Some(import_id), &resolutions);\n+                }\n+                Some(d) => {\n+                    log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n+                }\n+                None => {\n+                    log::debug!(\"glob import {:?} didn't resolve as type\", import);\n+                }\n+            }\n+        } else {\n             let last_segment = import.path.segments.last().unwrap();\n             let name = import.alias.clone().unwrap_or_else(|| last_segment.name.clone());\n             log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n@@ -284,17 +345,61 @@ where\n                     }\n                 }\n             }\n-            self.update(module_id, |items| {\n-                let res = Resolution { def, import: Some(import_id) };\n-                items.items.insert(name, res);\n-            });\n+            let resolution = Resolution { def, import: Some(import_id) };\n+            self.update(module_id, None, &[(name, resolution)]);\n         }\n         reached_fixedpoint\n     }\n \n-    fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {\n+    fn update(\n+        &mut self,\n+        module_id: ModuleId,\n+        import: Option<ImportId>,\n+        resolutions: &[(Name, Resolution)],\n+    ) {\n+        self.update_recursive(module_id, import, resolutions, 0)\n+    }\n+\n+    fn update_recursive(\n+        &mut self,\n+        module_id: ModuleId,\n+        import: Option<ImportId>,\n+        resolutions: &[(Name, Resolution)],\n+        depth: usize,\n+    ) {\n+        if depth > 100 {\n+            // prevent stack overflows (but this shouldn't be possible)\n+            panic!(\"infinite recursion in glob imports!\");\n+        }\n         let module_items = self.result.per_module.get_mut(module_id).unwrap();\n-        f(module_items)\n+        let mut changed = false;\n+        for (name, res) in resolutions {\n+            let existing = module_items.items.entry(name.clone()).or_default();\n+            if existing.def.types.is_none() && res.def.types.is_some() {\n+                existing.def.types = res.def.types;\n+                existing.import = import.or(res.import);\n+                changed = true;\n+            }\n+            if existing.def.values.is_none() && res.def.values.is_some() {\n+                existing.def.values = res.def.values;\n+                existing.import = import.or(res.import);\n+                changed = true;\n+            }\n+        }\n+        if !changed {\n+            return;\n+        }\n+        let glob_imports = self\n+            .glob_imports\n+            .get(&module_id)\n+            .into_iter()\n+            .flat_map(|v| v.iter())\n+            .cloned()\n+            .collect::<Vec<_>>();\n+        for (glob_importing_module, glob_import) in glob_imports {\n+            // We pass the glob import so that the tracked import in those modules is that glob import\n+            self.update_recursive(glob_importing_module, Some(glob_import), resolutions, depth + 1);\n+        }\n     }\n }\n "}, {"sha": "9c0e4ef29368473c2afe53cefd38f59e6ee22155", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/ffd407affff967884fd51a977335469e819c7194/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd407affff967884fd51a977335469e819c7194/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=ffd407affff967884fd51a977335469e819c7194", "patch": "@@ -164,6 +164,126 @@ fn re_exports() {\n     );\n }\n \n+#[test]\n+fn glob_1() {\n+    let (item_map, module_id) = item_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        use foo::*;\n+        <|>\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        pub use self::bar::Baz;\n+        pub struct Foo;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+    \",\n+    );\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+            foo: t\n+        \",\n+    );\n+}\n+\n+#[test]\n+fn glob_2() {\n+    let (item_map, module_id) = item_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        use foo::*;\n+        <|>\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        pub use self::bar::*;\n+        pub struct Foo;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        pub use super::*;\n+    \",\n+    );\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            Baz: t v\n+            Foo: t v\n+            bar: t\n+            foo: t\n+        \",\n+    );\n+}\n+\n+#[test]\n+fn glob_enum() {\n+    covers!(glob_enum);\n+    let (item_map, module_id) = item_map(\n+        \"\n+        //- /lib.rs\n+        enum Foo {\n+            Bar, Baz\n+        }\n+        use self::Foo::*;\n+        <|>\n+    \",\n+    );\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            Bar: t v\n+            Baz: t v\n+            Foo: t\n+        \",\n+    );\n+}\n+\n+#[test]\n+fn glob_across_crates() {\n+    covers!(glob_across_crates);\n+    let (mut db, sr) = MockDatabase::with_files(\n+        \"\n+        //- /main.rs\n+        use test_crate::*;\n+\n+        //- /lib.rs\n+        pub struct Baz;\n+    \",\n+    );\n+    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n+    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n+\n+    let mut crate_graph = CrateGraph::default();\n+    let main_crate = crate_graph.add_crate_root(main_id);\n+    let lib_crate = crate_graph.add_crate_root(lib_id);\n+    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate).unwrap();\n+\n+    db.set_crate_graph(Arc::new(crate_graph));\n+\n+    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate);\n+\n+    check_module_item_map(\n+        &item_map,\n+        module.module_id,\n+        \"\n+            Baz: t v\n+        \",\n+    );\n+}\n+\n #[test]\n fn module_resolution_works_for_non_standard_filenames() {\n     let (item_map, module_id) = item_map_custom_crate_root("}]}