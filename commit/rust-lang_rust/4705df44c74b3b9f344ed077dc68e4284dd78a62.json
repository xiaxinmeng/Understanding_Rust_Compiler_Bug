{"sha": "4705df44c74b3b9f344ed077dc68e4284dd78a62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MDVkZjQ0Yzc0YjNiOWYzNDRlZDA3N2RjNjhlNDI4NGRkNzhhNjI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-20T16:06:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-20T16:06:37Z"}, "message": "Merge #9637\n\n9637: Overhaul doc_links testing infra r=Veykril a=Veykril\n\nand fix several issues with current implementation.\r\n\r\nFixes #9617\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "00f36fd10102385fda042735ba2ad3561da26b5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00f36fd10102385fda042735ba2ad3561da26b5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4705df44c74b3b9f344ed077dc68e4284dd78a62", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg9vSNCRBK7hj4Ov3rIwAAdhkIACS5tKBFHRuiIqM/1vuh5AMU\n4P/n+FxbTALx64QjaxZnO/zOxAxOweiYteWxRsTouTe1kRAW2oloVgMXMCJ+KUVA\n1Rh4DeyTBy/OTt7LGOw5efhsqgIz2x8t6/JAKkn+nZMdrRV26QpD9xve1BW9YeS7\nbuYA2FK3uWTL/WQ/yerwqx04Q/5qZr1g+keqheSgT98Mdz5XrbGLQHvgxC3eG6wa\nF/ebplnU0q9Qo3L7T3oC+3w42CKSg+GJC7+fUKrPkNRJmTZpyAHRaYJFVwuA0U90\n3R7SEpUl6Sj5rFdeE7FedeArVDoo3XEUR+wHRlY+4EMqX2zgtzpNCv8mf4Rgt58=\n=mpzG\n-----END PGP SIGNATURE-----\n", "payload": "tree 00f36fd10102385fda042735ba2ad3561da26b5b\nparent ea71e5770514f54a488866d9972ae5f29986480c\nparent 2e39d4757b239490269f37d6c975da83add042e2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1626797197 +0000\ncommitter GitHub <noreply@github.com> 1626797197 +0000\n\nMerge #9637\n\n9637: Overhaul doc_links testing infra r=Veykril a=Veykril\n\nand fix several issues with current implementation.\r\n\r\nFixes #9617\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4705df44c74b3b9f344ed077dc68e4284dd78a62", "html_url": "https://github.com/rust-lang/rust/commit/4705df44c74b3b9f344ed077dc68e4284dd78a62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4705df44c74b3b9f344ed077dc68e4284dd78a62/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea71e5770514f54a488866d9972ae5f29986480c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea71e5770514f54a488866d9972ae5f29986480c", "html_url": "https://github.com/rust-lang/rust/commit/ea71e5770514f54a488866d9972ae5f29986480c"}, {"sha": "2e39d4757b239490269f37d6c975da83add042e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e39d4757b239490269f37d6c975da83add042e2", "html_url": "https://github.com/rust-lang/rust/commit/2e39d4757b239490269f37d6c975da83add042e2"}], "stats": {"total": 1345, "additions": 600, "deletions": 745}, "files": [{"sha": "859dcfc1c79113a1de0fb40d96b4d19fb7706edd", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=4705df44c74b3b9f344ed077dc68e4284dd78a62", "patch": "@@ -114,16 +114,15 @@ fn resolve_doc_path(\n     let path = ast::Path::parse(link).ok()?;\n     let modpath = ModPath::from_src(db.upcast(), path, &Hygiene::new_unhygienic()).unwrap();\n     let resolved = resolver.resolve_module_path_in_items(db.upcast(), &modpath);\n-    if resolved == PerNs::none() {\n-        if let Some(trait_id) = resolver.resolve_module_path_in_trait_items(db.upcast(), &modpath) {\n-            return Some(ModuleDefId::TraitId(trait_id));\n-        };\n-    }\n-    let def = match ns {\n-        Some(Namespace::Types) => resolved.take_types()?,\n-        Some(Namespace::Values) => resolved.take_values()?,\n-        Some(Namespace::Macros) => return None,\n-        None => resolved.iter_items().find_map(|it| it.as_module_def_id())?,\n+    let resolved = if resolved == PerNs::none() {\n+        resolver.resolve_module_path_in_trait_assoc_items(db.upcast(), &modpath)?\n+    } else {\n+        resolved\n     };\n-    Some(def)\n+    match ns {\n+        Some(Namespace::Types) => resolved.take_types(),\n+        Some(Namespace::Values) => resolved.take_values(),\n+        Some(Namespace::Macros) => None,\n+        None => resolved.iter_items().find_map(|it| it.as_module_def_id()),\n+    }\n }"}, {"sha": "79c67bfc2c47e6f72fd2d17bb8b914145506668f", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=4705df44c74b3b9f344ed077dc68e4284dd78a62", "patch": "@@ -295,12 +295,19 @@ impl ModuleDef {\n     }\n \n     pub fn canonical_path(&self, db: &dyn HirDatabase) -> Option<String> {\n-        let mut segments = vec![self.name(db)?.to_string()];\n+        let mut segments = vec![self.name(db)?];\n         for m in self.module(db)?.path_to_root(db) {\n-            segments.extend(m.name(db).map(|it| it.to_string()))\n+            segments.extend(m.name(db))\n         }\n         segments.reverse();\n-        Some(segments.join(\"::\"))\n+        Some(segments.into_iter().join(\"::\"))\n+    }\n+\n+    pub fn canonical_module_path(\n+        &self,\n+        db: &dyn HirDatabase,\n+    ) -> Option<impl Iterator<Item = Module>> {\n+        self.module(db).map(|it| it.path_to_root(db).into_iter().rev())\n     }\n \n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {"}, {"sha": "123f23ff92cc096cfd78b940188d1308b84c8e2f", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=4705df44c74b3b9f344ed077dc68e4284dd78a62", "patch": "@@ -20,10 +20,10 @@ use crate::{\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n-    AdtId, AssocContainerId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId,\n-    FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, LifetimeParamId, LocalModuleId,\n-    Lookup, ModuleDefId, ModuleId, StaticId, StructId, TraitId, TypeAliasId, TypeParamId,\n-    VariantId,\n+    AdtId, AssocContainerId, AssocItemId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n+    EnumVariantId, FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, LifetimeParamId,\n+    LocalModuleId, Lookup, ModuleDefId, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n+    TypeParamId, VariantId,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -144,15 +144,28 @@ impl Resolver {\n         self.resolve_module_path(db, path, BuiltinShadowMode::Module)\n     }\n \n-    pub fn resolve_module_path_in_trait_items(\n+    pub fn resolve_module_path_in_trait_assoc_items(\n         &self,\n         db: &dyn DefDatabase,\n         path: &ModPath,\n-    ) -> Option<TraitId> {\n+    ) -> Option<PerNs> {\n         let (item_map, module) = self.module_scope()?;\n-        let (module_res, ..) = item_map.resolve_path(db, module, path, BuiltinShadowMode::Module);\n+        let (module_res, idx) = item_map.resolve_path(db, module, path, BuiltinShadowMode::Module);\n         match module_res.take_types()? {\n-            ModuleDefId::TraitId(it) => Some(it),\n+            ModuleDefId::TraitId(it) => {\n+                let idx = idx?;\n+                let unresolved = &path.segments()[idx..];\n+                let assoc = match unresolved {\n+                    [it] => it,\n+                    _ => return None,\n+                };\n+                let &(_, assoc) = db.trait_data(it).items.iter().find(|(n, _)| n == assoc)?;\n+                Some(match assoc {\n+                    AssocItemId::FunctionId(it) => PerNs::values(it.into(), Visibility::Public),\n+                    AssocItemId::ConstId(it) => PerNs::values(it.into(), Visibility::Public),\n+                    AssocItemId::TypeAliasId(it) => PerNs::types(it.into(), Visibility::Public),\n+                })\n+            }\n             _ => None,\n         }\n     }"}, {"sha": "8cab677f5aefbab858617e5abde6e57acdc8ec43", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 430, "deletions": 286, "changes": 716, "blob_url": "https://github.com/rust-lang/rust/blob/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=4705df44c74b3b9f344ed077dc68e4284dd78a62", "patch": "@@ -1,18 +1,16 @@\n //! Extracts, resolves and rewrites links and intra-doc links in markdown documentation.\n \n-use std::{\n-    convert::{TryFrom, TryInto},\n-    iter::once,\n-};\n+mod intra_doc_links;\n+\n+use std::convert::{TryFrom, TryInto};\n \n-use itertools::Itertools;\n use pulldown_cmark::{BrokenLink, CowStr, Event, InlineStr, LinkType, Options, Parser, Tag};\n use pulldown_cmark_to_cmark::{cmark_with_options, Options as CmarkOptions};\n+use stdx::format_to;\n use url::Url;\n \n use hir::{\n-    db::{DefDatabase, HirDatabase},\n-    Adt, AsAssocItem, AssocItem, AssocItemContainer, Crate, Field, HasAttrs, ItemInNs, ModuleDef,\n+    db::HirDatabase, Adt, AsAssocItem, AssocItem, AssocItemContainer, Crate, HasAttrs, ModuleDef,\n };\n use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n@@ -21,17 +19,20 @@ use ide_db::{\n };\n use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxNode, TextRange, T};\n \n-use crate::{FilePosition, Semantics};\n+use crate::{\n+    doc_links::intra_doc_links::{parse_intra_doc_link, strip_prefixes_suffixes},\n+    FilePosition, Semantics,\n+};\n \n pub(crate) type DocumentationLink = String;\n \n /// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)\n-pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> String {\n+pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: Definition) -> String {\n     let mut cb = broken_link_clone_cb;\n     let doc =\n         Parser::new_with_broken_link_callback(markdown, Options::ENABLE_TASKLISTS, Some(&mut cb));\n \n-    let doc = map_links(doc, |target, title: &str| {\n+    let doc = map_links(doc, |target, title| {\n         // This check is imperfect, there's some overlap between valid intra-doc links\n         // and valid URLs so we choose to be too eager to try to resolve what might be\n         // a URL.\n@@ -41,10 +42,10 @@ pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Defi\n             // Two possibilities:\n             // * path-based links: `../../module/struct.MyStruct.html`\n             // * module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n-            if let Some(rewritten) = rewrite_intra_doc_link(db, *definition, target, title) {\n+            if let Some(rewritten) = rewrite_intra_doc_link(db, definition, target, title) {\n                 return rewritten;\n             }\n-            if let Definition::ModuleDef(def) = *definition {\n+            if let Definition::ModuleDef(def) = definition {\n                 if let Some(target) = rewrite_url_link(db, def, target) {\n                     return (target, title.to_string());\n                 }\n@@ -54,9 +55,13 @@ pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Defi\n         }\n     });\n     let mut out = String::new();\n-    let mut options = CmarkOptions::default();\n-    options.code_block_backticks = 3;\n-    cmark_with_options(doc, &mut out, None, options).ok();\n+    cmark_with_options(\n+        doc,\n+        &mut out,\n+        None,\n+        CmarkOptions { code_block_backticks: 3, ..Default::default() },\n+    )\n+    .ok();\n     out\n }\n \n@@ -72,9 +77,9 @@ pub(crate) fn remove_links(markdown: &str) -> String {\n     };\n     let doc = Parser::new_with_broken_link_callback(markdown, opts, Some(&mut cb));\n     let doc = doc.filter_map(move |evt| match evt {\n-        Event::Start(Tag::Link(link_type, ref target, ref title)) => {\n+        Event::Start(Tag::Link(link_type, target, title)) => {\n             if link_type == LinkType::Inline && target.contains(\"://\") {\n-                Some(Event::Start(Tag::Link(link_type, target.clone(), title.clone())))\n+                Some(Event::Start(Tag::Link(link_type, target, title)))\n             } else {\n                 drop_link = true;\n                 None\n@@ -88,9 +93,13 @@ pub(crate) fn remove_links(markdown: &str) -> String {\n     });\n \n     let mut out = String::new();\n-    let mut options = CmarkOptions::default();\n-    options.code_block_backticks = 3;\n-    cmark_with_options(doc, &mut out, None, options).ok();\n+    cmark_with_options(\n+        doc,\n+        &mut out,\n+        None,\n+        CmarkOptions { code_block_backticks: 3, ..Default::default() },\n+    )\n+    .ok();\n     out\n }\n \n@@ -99,10 +108,10 @@ pub(crate) fn external_docs(\n     db: &RootDatabase,\n     position: &FilePosition,\n ) -> Option<DocumentationLink> {\n-    let sema = Semantics::new(db);\n+    let sema = &Semantics::new(db);\n     let file = sema.parse(position.file_id).syntax().clone();\n     let token = pick_best_token(file.token_at_offset(position.offset), |kind| match kind {\n-        IDENT | INT_NUMBER => 3,\n+        IDENT | INT_NUMBER | T![self] => 3,\n         T!['('] | T![')'] => 2,\n         kind if kind.is_trivia() => 0,\n         _ => 1,\n@@ -112,13 +121,13 @@ pub(crate) fn external_docs(\n     let node = token.parent()?;\n     let definition = match_ast! {\n         match node {\n-            ast::NameRef(name_ref) => match NameRefClass::classify(&sema, &name_ref)? {\n+            ast::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref)? {\n                 NameRefClass::Definition(def) => def,\n                 NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n                     Definition::Field(field_ref)\n                 }\n             },\n-            ast::Name(name) => match NameClass::classify(&sema, &name)? {\n+            ast::Name(name) => match NameClass::classify(sema, &name)? {\n                 NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n                 NameClass::PatFieldShorthand { local_def: _, field_ref } => Definition::Field(field_ref),\n             },\n@@ -129,28 +138,27 @@ pub(crate) fn external_docs(\n     get_doc_link(db, definition)\n }\n \n-/// Extracts all links from a given markdown text.\n-pub(crate) fn extract_definitions_from_markdown(\n-    markdown: &str,\n+/// Extracts all links from a given markdown text returning the definition text range, link-text\n+/// and the namespace if known.\n+pub(crate) fn extract_definitions_from_docs(\n+    docs: &hir::Documentation,\n ) -> Vec<(TextRange, String, Option<hir::Namespace>)> {\n     Parser::new_with_broken_link_callback(\n-        markdown,\n+        docs.as_str(),\n         Options::ENABLE_TASKLISTS,\n         Some(&mut broken_link_clone_cb),\n     )\n     .into_offset_iter()\n-    .filter_map(|(event, range)| {\n-        if let Event::Start(Tag::Link(_, target, title)) = event {\n-            let link = if target.is_empty() { title } else { target };\n-            let (link, ns) = parse_intra_doc_link(&link);\n+    .filter_map(|(event, range)| match event {\n+        Event::Start(Tag::Link(_, target, _)) => {\n+            let (link, ns) = parse_intra_doc_link(&target);\n             Some((\n                 TextRange::new(range.start.try_into().ok()?, range.end.try_into().ok()?),\n                 link.to_string(),\n                 ns,\n             ))\n-        } else {\n-            None\n         }\n+        _ => None,\n     })\n     .collect()\n }\n@@ -226,83 +234,45 @@ fn broken_link_clone_cb<'a, 'b>(link: BrokenLink<'a>) -> Option<(CowStr<'b>, Cow\n // This should cease to be a problem if RFC2988 (Stable Rustdoc URLs) is implemented\n // https://github.com/rust-lang/rfcs/pull/2988\n fn get_doc_link(db: &RootDatabase, definition: Definition) -> Option<String> {\n-    // Get the outermost definition for the module def. This is used to resolve the public path to the type,\n-    // then we can join the method, field, etc onto it if required.\n-    let target_def: ModuleDef = match definition {\n-        Definition::ModuleDef(def) => match def {\n-            ModuleDef::Function(f) => f\n-                .as_assoc_item(db)\n-                .and_then(|assoc| match assoc.container(db) {\n-                    AssocItemContainer::Trait(t) => Some(t.into()),\n-                    AssocItemContainer::Impl(impl_) => {\n-                        impl_.self_ty(db).as_adt().map(|adt| adt.into())\n-                    }\n-                })\n-                .unwrap_or_else(|| def),\n-            def => def,\n-        },\n-        Definition::Field(f) => f.parent_def(db).into(),\n-        // FIXME: Handle macros\n-        _ => return None,\n+    let (target, frag) = match definition {\n+        Definition::ModuleDef(def) => {\n+            if let Some(assoc_item) = def.as_assoc_item(db) {\n+                let def = match assoc_item.container(db) {\n+                    AssocItemContainer::Trait(t) => t.into(),\n+                    AssocItemContainer::Impl(i) => i.self_ty(db).as_adt()?.into(),\n+                };\n+                let frag = get_assoc_item_fragment(db, assoc_item)?;\n+                (def, Some(frag))\n+            } else {\n+                (def, None)\n+            }\n+        }\n+        Definition::Field(field) => {\n+            let def = match field.parent_def(db) {\n+                hir::VariantDef::Struct(it) => it.into(),\n+                hir::VariantDef::Union(it) => it.into(),\n+                hir::VariantDef::Variant(it) => it.into(),\n+            };\n+            (def, Some(format!(\"structfield.{}\", field.name(db))))\n+        }\n+        // FIXME macros\n+        Definition::Macro(_) => return None,\n+        // FIXME impls\n+        Definition::SelfType(_) => return None,\n+        Definition::Local(_) | Definition::GenericParam(_) | Definition::Label(_) => return None,\n     };\n \n-    let ns = ItemInNs::from(target_def);\n+    let krate = crate_of_def(db, target)?;\n+    let mut url = get_doc_base_url(db, &krate)?;\n \n-    let krate = match definition {\n-        // Definition::module gives back the parent module, we don't want that as it fails for root modules\n-        Definition::ModuleDef(ModuleDef::Module(module)) => module.krate(),\n-        _ => definition.module(db)?.krate(),\n-    };\n-    // FIXME: using import map doesn't make sense here. What we want here is\n-    // canonical path. What import map returns is the shortest path suitable for\n-    // import. See this test:\n-    cov_mark::hit!(test_reexport_order);\n-    let import_map = db.import_map(krate.into());\n-\n-    let mut base = krate.display_name(db)?.to_string();\n-    let is_root_module = matches!(\n-        definition,\n-        Definition::ModuleDef(ModuleDef::Module(module)) if krate.root_module(db) == module\n-    );\n-    if !is_root_module {\n-        base = once(base)\n-            .chain(import_map.path_of(ns)?.segments.iter().map(|name| name.to_string()))\n-            .join(\"/\");\n+    if let Some(path) = mod_path_of_def(db, target) {\n+        url = url.join(&path).ok()?;\n     }\n-    base += \"/\";\n \n-    let filename = get_symbol_filename(db, &target_def);\n-    let fragment = match definition {\n-        Definition::ModuleDef(def) => match def {\n-            ModuleDef::Function(f) => {\n-                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::Function(f)))\n-            }\n-            ModuleDef::Const(c) => {\n-                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::Const(c)))\n-            }\n-            ModuleDef::TypeAlias(ty) => {\n-                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::TypeAlias(ty)))\n-            }\n-            _ => None,\n-        },\n-        Definition::Field(field) => get_symbol_fragment(db, &FieldOrAssocItem::Field(field)),\n-        _ => None,\n-    };\n+    url = url.join(&get_symbol_filename(db, &target)?).ok()?;\n+    url.set_fragment(frag.as_deref());\n \n-    get_doc_url(db, &krate)?\n-        .join(&base)\n-        .ok()\n-        .and_then(|mut url| {\n-            if !matches!(definition, Definition::ModuleDef(ModuleDef::Module(..))) {\n-                url.path_segments_mut().ok()?.pop();\n-            };\n-            Some(url)\n-        })\n-        .and_then(|url| url.join(filename.as_deref()?).ok())\n-        .and_then(\n-            |url| if let Some(fragment) = fragment { url.join(&fragment).ok() } else { Some(url) },\n-        )\n-        .map(|url| url.into())\n+    Some(url.into())\n }\n \n fn rewrite_intra_doc_link(\n@@ -311,37 +281,30 @@ fn rewrite_intra_doc_link(\n     target: &str,\n     title: &str,\n ) -> Option<(String, String)> {\n-    let link = if target.is_empty() { title } else { target };\n-    let (link, ns) = parse_intra_doc_link(link);\n+    let (link, ns) = parse_intra_doc_link(target);\n+\n     let resolved = resolve_doc_path_for_def(db, def, link, ns)?;\n-    let krate = resolved.module(db)?.krate();\n-    let canonical_path = resolved.canonical_path(db)?;\n-    let mut new_url = get_doc_url(db, &krate)?\n-        .join(&format!(\"{}/\", krate.display_name(db)?))\n-        .ok()?\n-        .join(&canonical_path.replace(\"::\", \"/\"))\n-        .ok()?\n-        .join(&get_symbol_filename(db, &resolved)?)\n-        .ok()?;\n-\n-    if let ModuleDef::Trait(t) = resolved {\n-        if let Some(assoc_item) = t.items(db).into_iter().find_map(|assoc_item| {\n-            if let Some(name) = assoc_item.name(db) {\n-                if *link == format!(\"{}::{}\", canonical_path, name) {\n-                    return Some(assoc_item);\n-                }\n-            }\n-            None\n-        }) {\n-            if let Some(fragment) =\n-                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(assoc_item))\n-            {\n-                new_url = new_url.join(&fragment).ok()?;\n-            }\n-        };\n+    let krate = crate_of_def(db, resolved)?;\n+    let mut url = get_doc_base_url(db, &krate)?;\n+\n+    if let Some(path) = mod_path_of_def(db, resolved) {\n+        url = url.join(&path).ok()?;\n     }\n \n-    Some((new_url.into(), strip_prefixes_suffixes(title).to_string()))\n+    let (resolved, frag) = if let Some(assoc_item) = resolved.as_assoc_item(db) {\n+        let resolved = match assoc_item.container(db) {\n+            AssocItemContainer::Trait(t) => t.into(),\n+            AssocItemContainer::Impl(i) => i.self_ty(db).as_adt()?.into(),\n+        };\n+        let frag = get_assoc_item_fragment(db, assoc_item)?;\n+        (resolved, Some(frag))\n+    } else {\n+        (resolved, None)\n+    };\n+    url = url.join(&get_symbol_filename(db, &resolved)?).ok()?;\n+    url.set_fragment(frag.as_deref());\n+\n+    Some((url.into(), strip_prefixes_suffixes(title).to_string()))\n }\n \n /// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n@@ -350,18 +313,32 @@ fn rewrite_url_link(db: &RootDatabase, def: ModuleDef, target: &str) -> Option<S\n         return None;\n     }\n \n-    let module = def.module(db)?;\n-    let krate = module.krate();\n-    let canonical_path = def.canonical_path(db)?;\n-    let base = format!(\"{}/{}\", krate.display_name(db)?, canonical_path.replace(\"::\", \"/\"));\n+    let krate = crate_of_def(db, def)?;\n+    let mut url = get_doc_base_url(db, &krate)?;\n \n-    get_doc_url(db, &krate)\n-        .and_then(|url| url.join(&base).ok())\n-        .and_then(|url| {\n-            get_symbol_filename(db, &def).as_deref().map(|f| url.join(f).ok()).flatten()\n-        })\n-        .and_then(|url| url.join(target).ok())\n-        .map(|url| url.into())\n+    if let Some(path) = mod_path_of_def(db, def) {\n+        url = url.join(&path).ok()?;\n+    }\n+\n+    url = url.join(&get_symbol_filename(db, &def)?).ok()?;\n+    url.join(target).ok().map(Into::into)\n+}\n+\n+fn crate_of_def(db: &RootDatabase, def: ModuleDef) -> Option<Crate> {\n+    let krate = match def {\n+        // Definition::module gives back the parent module, we don't want that as it fails for root modules\n+        ModuleDef::Module(module) => module.krate(),\n+        _ => def.module(db)?.krate(),\n+    };\n+    Some(krate)\n+}\n+\n+fn mod_path_of_def(db: &RootDatabase, def: ModuleDef) -> Option<String> {\n+    def.canonical_module_path(db).map(|it| {\n+        let mut path = String::new();\n+        it.flat_map(|it| it.name(db)).for_each(|name| format_to!(path, \"{}/\", name));\n+        path\n+    })\n }\n \n /// Rewrites a markdown document, applying 'callback' to each link.\n@@ -373,14 +350,18 @@ fn map_links<'e>(\n     let mut link_target: Option<CowStr> = None;\n \n     events.map(move |evt| match evt {\n-        Event::Start(Tag::Link(_link_type, ref target, _)) => {\n+        Event::Start(Tag::Link(_, ref target, _)) => {\n             in_link = true;\n             link_target = Some(target.clone());\n             evt\n         }\n-        Event::End(Tag::Link(link_type, _target, _)) => {\n+        Event::End(Tag::Link(link_type, target, _)) => {\n             in_link = false;\n-            Event::End(Tag::Link(link_type, link_target.take().unwrap(), CowStr::Borrowed(\"\")))\n+            Event::End(Tag::Link(\n+                link_type,\n+                link_target.take().unwrap_or(target),\n+                CowStr::Borrowed(\"\"),\n+            ))\n         }\n         Event::Text(s) if in_link => {\n             let (link_target_s, link_name) = callback(&link_target.take().unwrap(), &s);\n@@ -396,70 +377,14 @@ fn map_links<'e>(\n     })\n }\n \n-const TYPES: ([&str; 9], [&str; 0]) =\n-    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\", \"prim\", \"primitive\"], []);\n-const VALUES: ([&str; 8], [&str; 1]) =\n-    ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n-const MACROS: ([&str; 2], [&str; 1]) = ([\"macro\", \"derive\"], [\"!\"]);\n-\n-/// Extract the specified namespace from an intra-doc-link if one exists.\n-///\n-/// # Examples\n-///\n-/// * `struct MyStruct` -> (\"MyStruct\", `Namespace::Types`)\n-/// * `panic!` -> (\"panic\", `Namespace::Macros`)\n-/// * `fn@from_intra_spec` -> (\"from_intra_spec\", `Namespace::Values`)\n-fn parse_intra_doc_link(s: &str) -> (&str, Option<hir::Namespace>) {\n-    let s = s.trim_matches('`');\n-\n-    [\n-        (hir::Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n-        (hir::Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n-        (hir::Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n-    ]\n-    .iter()\n-    .cloned()\n-    .find_map(|(ns, (mut prefixes, mut suffixes))| {\n-        if let Some(prefix) = prefixes.find(|&&prefix| {\n-            s.starts_with(prefix)\n-                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n-        }) {\n-            Some((&s[prefix.len() + 1..], ns))\n-        } else {\n-            suffixes.find_map(|&suffix| s.strip_suffix(suffix).zip(Some(ns)))\n-        }\n-    })\n-    .map_or((s, None), |(s, ns)| (s, Some(ns)))\n-}\n-\n-fn strip_prefixes_suffixes(s: &str) -> &str {\n-    [\n-        (TYPES.0.iter(), TYPES.1.iter()),\n-        (VALUES.0.iter(), VALUES.1.iter()),\n-        (MACROS.0.iter(), MACROS.1.iter()),\n-    ]\n-    .iter()\n-    .cloned()\n-    .find_map(|(mut prefixes, mut suffixes)| {\n-        if let Some(prefix) = prefixes.find(|&&prefix| {\n-            s.starts_with(prefix)\n-                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n-        }) {\n-            Some(&s[prefix.len() + 1..])\n-        } else {\n-            suffixes.find_map(|&suffix| s.strip_suffix(suffix))\n-        }\n-    })\n-    .unwrap_or(s)\n-}\n-\n /// Get the root URL for the documentation of a crate.\n ///\n-/// ```\n+/// ```ignore\n /// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n /// ^^^^^^^^^^^^^^^^^^^^^^^^^^\n /// ```\n-fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n+fn get_doc_base_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n+    let display_name = krate.display_name(db)?;\n     krate\n         .get_html_root_url(db)\n         .or_else(|| {\n@@ -468,14 +393,14 @@ fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n             //\n             // FIXME: clicking on the link should just open the file in the editor,\n             // instead of falling back to external urls.\n-            Some(format!(\"https://docs.rs/{}/*/\", krate.display_name(db)?))\n+            Some(format!(\"https://docs.rs/{krate}/*/\", krate = display_name))\n         })\n-        .and_then(|s| Url::parse(&s).ok())\n+        .and_then(|s| Url::parse(&s).ok()?.join(&format!(\"{}/\", display_name)).ok())\n }\n \n /// Get the filename and extension generated for a symbol by rustdoc.\n ///\n-/// ```\n+/// ```ignore\n /// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n ///                                    ^^^^^^^^^^^^^^^^^^^\n /// ```\n@@ -486,7 +411,10 @@ fn get_symbol_filename(db: &dyn HirDatabase, definition: &ModuleDef) -> Option<S\n             Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n             Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n         },\n-        ModuleDef::Module(_) => \"index.html\".to_string(),\n+        ModuleDef::Module(m) => match m.name(db) {\n+            Some(name) => format!(\"{}/index.html\", name),\n+            None => String::from(\"index.html\"),\n+        },\n         ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n         ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n         ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t.name()),\n@@ -499,57 +427,44 @@ fn get_symbol_filename(db: &dyn HirDatabase, definition: &ModuleDef) -> Option<S\n     })\n }\n \n-enum FieldOrAssocItem {\n-    Field(Field),\n-    AssocItem(AssocItem),\n-}\n-\n /// Get the fragment required to link to a specific field, method, associated type, or associated constant.\n ///\n-/// ```\n+/// ```ignore\n /// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n ///                                                       ^^^^^^^^^^^^^^\n /// ```\n-fn get_symbol_fragment(db: &dyn HirDatabase, field_or_assoc: &FieldOrAssocItem) -> Option<String> {\n-    Some(match field_or_assoc {\n-        FieldOrAssocItem::Field(field) => format!(\"#structfield.{}\", field.name(db)),\n-        FieldOrAssocItem::AssocItem(assoc) => match assoc {\n-            AssocItem::Function(function) => {\n-                let is_trait_method = function\n-                    .as_assoc_item(db)\n-                    .and_then(|assoc| assoc.containing_trait(db))\n-                    .is_some();\n-                // This distinction may get more complicated when specialization is available.\n-                // Rustdoc makes this decision based on whether a method 'has defaultness'.\n-                // Currently this is only the case for provided trait methods.\n-                if is_trait_method && !function.has_body(db) {\n-                    format!(\"#tymethod.{}\", function.name(db))\n-                } else {\n-                    format!(\"#method.{}\", function.name(db))\n-                }\n+fn get_assoc_item_fragment(db: &dyn HirDatabase, assoc_item: hir::AssocItem) -> Option<String> {\n+    Some(match assoc_item {\n+        AssocItem::Function(function) => {\n+            let is_trait_method =\n+                function.as_assoc_item(db).and_then(|assoc| assoc.containing_trait(db)).is_some();\n+            // This distinction may get more complicated when specialization is available.\n+            // Rustdoc makes this decision based on whether a method 'has defaultness'.\n+            // Currently this is only the case for provided trait methods.\n+            if is_trait_method && !function.has_body(db) {\n+                format!(\"tymethod.{}\", function.name(db))\n+            } else {\n+                format!(\"method.{}\", function.name(db))\n             }\n-            AssocItem::Const(constant) => format!(\"#associatedconstant.{}\", constant.name(db)?),\n-            AssocItem::TypeAlias(ty) => format!(\"#associatedtype.{}\", ty.name(db)),\n-        },\n+        }\n+        AssocItem::Const(constant) => format!(\"associatedconstant.{}\", constant.name(db)?),\n+        AssocItem::TypeAlias(ty) => format!(\"associatedtype.{}\", ty.name(db)),\n     })\n }\n \n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n+    use ide_db::base_db::FileRange;\n+    use itertools::Itertools;\n \n-    use crate::fixture;\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let (analysis, position) = fixture::position(ra_fixture);\n-        let url = analysis.external_docs(position).unwrap().expect(\"could not find url for symbol\");\n+    use crate::{display::TryToNav, fixture};\n \n-        expect.assert_eq(&url)\n-    }\n+    use super::*;\n \n     #[test]\n-    fn test_doc_url_crate() {\n-        check(\n+    fn external_docs_doc_url_crate() {\n+        check_external_docs(\n             r#\"\n //- /main.rs crate:main deps:test\n use test$0::Foo;\n@@ -561,8 +476,8 @@ pub struct Foo;\n     }\n \n     #[test]\n-    fn test_doc_url_struct() {\n-        check(\n+    fn external_docs_doc_url_struct() {\n+        check_external_docs(\n             r#\"\n pub struct Fo$0o;\n \"#,\n@@ -571,91 +486,142 @@ pub struct Fo$0o;\n     }\n \n     #[test]\n-    fn test_doc_url_fn() {\n-        check(\n+    fn external_docs_doc_url_struct_field() {\n+        check_external_docs(\n+            r#\"\n+pub struct Foo {\n+    field$0: ()\n+}\n+\"#,\n+            expect![[r##\"https://docs.rs/test/*/test/struct.Foo.html#structfield.field\"##]],\n+        );\n+    }\n+\n+    #[test]\n+    fn external_docs_doc_url_fn() {\n+        check_external_docs(\n             r#\"\n pub fn fo$0o() {}\n \"#,\n-            expect![[r##\"https://docs.rs/test/*/test/fn.foo.html#method.foo\"##]],\n+            expect![[r##\"https://docs.rs/test/*/test/fn.foo.html\"##]],\n         );\n     }\n \n     #[test]\n-    fn test_doc_url_inherent_method() {\n-        check(\n+    fn external_docs_doc_url_impl_assoc() {\n+        check_external_docs(\n             r#\"\n pub struct Foo;\n-\n impl Foo {\n-    pub fn met$0hod() {}\n+    pub fn method$0() {}\n }\n-\n \"#,\n             expect![[r##\"https://docs.rs/test/*/test/struct.Foo.html#method.method\"##]],\n         );\n+        check_external_docs(\n+            r#\"\n+pub struct Foo;\n+impl Foo {\n+    const CONST$0: () = ();\n+}\n+\"#,\n+            expect![[r##\"https://docs.rs/test/*/test/struct.Foo.html#associatedconstant.CONST\"##]],\n+        );\n     }\n \n     #[test]\n-    fn test_doc_url_trait_provided_method() {\n-        check(\n+    fn external_docs_doc_url_impl_trait_assoc() {\n+        check_external_docs(\n             r#\"\n-pub trait Bar {\n-    fn met$0hod() {}\n+pub struct Foo;\n+pub trait Trait {\n+    fn method() {}\n+}\n+impl Trait for Foo {\n+    pub fn method$0() {}\n+}\n+\"#,\n+            expect![[r##\"https://docs.rs/test/*/test/struct.Foo.html#method.method\"##]],\n+        );\n+        check_external_docs(\n+            r#\"\n+pub struct Foo;\n+pub trait Trait {\n+    const CONST: () = ();\n+}\n+impl Trait for Foo {\n+    const CONST$0: () = ();\n+}\n+\"#,\n+            expect![[r##\"https://docs.rs/test/*/test/struct.Foo.html#associatedconstant.CONST\"##]],\n+        );\n+        check_external_docs(\n+            r#\"\n+pub struct Foo;\n+pub trait Trait {\n+    type Type;\n+}\n+impl Trait for Foo {\n+    type Type$0 = ();\n }\n-\n \"#,\n-            expect![[r##\"https://docs.rs/test/*/test/trait.Bar.html#method.method\"##]],\n+            expect![[r##\"https://docs.rs/test/*/test/struct.Foo.html#associatedtype.Type\"##]],\n         );\n     }\n \n     #[test]\n-    fn test_doc_url_trait_required_method() {\n-        check(\n+    fn external_docs_doc_url_trait_assoc() {\n+        check_external_docs(\n             r#\"\n pub trait Foo {\n-    fn met$0hod();\n+    fn method$0();\n }\n-\n \"#,\n             expect![[r##\"https://docs.rs/test/*/test/trait.Foo.html#tymethod.method\"##]],\n         );\n+        check_external_docs(\n+            r#\"\n+pub trait Foo {\n+    const CONST$0: ();\n+}\n+\"#,\n+            expect![[r##\"https://docs.rs/test/*/test/trait.Foo.html#associatedconstant.CONST\"##]],\n+        );\n+        check_external_docs(\n+            r#\"\n+pub trait Foo {\n+    type Type$0;\n+}\n+\"#,\n+            expect![[r##\"https://docs.rs/test/*/test/trait.Foo.html#associatedtype.Type\"##]],\n+        );\n     }\n \n     #[test]\n-    fn test_doc_url_field() {\n-        check(\n+    fn external_docs_trait() {\n+        check_external_docs(\n             r#\"\n-pub struct Foo {\n-    pub fie$0ld: ()\n-}\n-\n+trait Trait$0 {}\n \"#,\n-            expect![[r##\"https://docs.rs/test/*/test/struct.Foo.html#structfield.field\"##]],\n-        );\n+            expect![[r#\"https://docs.rs/test/*/test/trait.Trait.html\"#]],\n+        )\n     }\n \n     #[test]\n-    fn test_module() {\n-        check(\n+    fn external_docs_module() {\n+        check_external_docs(\n             r#\"\n pub mod foo {\n     pub mod ba$0r {}\n }\n-        \"#,\n+\"#,\n             expect![[r#\"https://docs.rs/test/*/test/foo/bar/index.html\"#]],\n         )\n     }\n \n     #[test]\n-    fn test_reexport_order() {\n-        cov_mark::check!(test_reexport_order);\n-        // FIXME: This should return\n-        //\n-        //    https://docs.rs/test/*/test/wrapper/modulestruct.Item.html\n-        //\n-        // That is, we should point inside the module, rather than at the\n-        // re-export.\n-        check(\n+    fn external_docs_reexport_order() {\n+        check_external_docs(\n             r#\"\n pub mod wrapper {\n     pub use module::Item;\n@@ -669,7 +635,185 @@ fn foo() {\n     let bar: wrapper::It$0em;\n }\n         \"#,\n-            expect![[r#\"https://docs.rs/test/*/test/wrapper/struct.Item.html\"#]],\n+            expect![[r#\"https://docs.rs/test/*/test/wrapper/module/struct.Item.html\"#]],\n         )\n     }\n+\n+    #[test]\n+    fn test_trait_items() {\n+        check_doc_links(\n+            r#\"\n+/// [`Trait`]\n+/// [`Trait::Type`]\n+/// [`Trait::CONST`]\n+/// [`Trait::func`]\n+trait Trait$0 {\n+   // ^^^^^ Trait\n+    type Type;\n+      // ^^^^ Trait::Type\n+    const CONST: usize;\n+       // ^^^^^ Trait::CONST\n+    fn func();\n+    // ^^^^ Trait::func\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn rewrite_html_root_url() {\n+        check_rewrite(\n+            r#\"\n+#![doc(arbitrary_attribute = \"test\", html_root_url = \"https:/example.com\", arbitrary_attribute2)]\n+\n+pub mod foo {\n+    pub struct Foo;\n+}\n+/// [Foo](foo::Foo)\n+pub struct B$0ar\n+\"#,\n+            expect![[r#\"[Foo](https://example.com/test/foo/struct.Foo.html)\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn rewrite_on_field() {\n+        // FIXME: Should be\n+        //  [Foo](https://docs.rs/test/*/test/struct.Foo.html)\n+        check_rewrite(\n+            r#\"\n+pub struct Foo {\n+    /// [Foo](struct.Foo.html)\n+    fie$0ld: ()\n+}\n+\"#,\n+            expect![[r#\"[Foo](struct.Foo.html)\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn rewrite_struct() {\n+        check_rewrite(\n+            r#\"\n+/// [Foo]\n+pub struct $0Foo;\n+\"#,\n+            expect![[r#\"[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"#]],\n+        );\n+        check_rewrite(\n+            r#\"\n+/// [`Foo`]\n+pub struct $0Foo;\n+\"#,\n+            expect![[r#\"[`Foo`](https://docs.rs/test/*/test/struct.Foo.html)\"#]],\n+        );\n+        check_rewrite(\n+            r#\"\n+/// [Foo](struct.Foo.html)\n+pub struct $0Foo;\n+\"#,\n+            expect![[r#\"[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"#]],\n+        );\n+        check_rewrite(\n+            r#\"\n+/// [struct Foo](struct.Foo.html)\n+pub struct $0Foo;\n+\"#,\n+            expect![[r#\"[struct Foo](https://docs.rs/test/*/test/struct.Foo.html)\"#]],\n+        );\n+        check_rewrite(\n+            r#\"\n+/// [my Foo][foo]\n+///\n+/// [foo]: Foo\n+pub struct $0Foo;\n+\"#,\n+            expect![[r#\"[my Foo](https://docs.rs/test/*/test/struct.Foo.html)\"#]],\n+        );\n+    }\n+\n+    fn check_external_docs(ra_fixture: &str, expect: Expect) {\n+        let (analysis, position) = fixture::position(ra_fixture);\n+        let url = analysis.external_docs(position).unwrap().expect(\"could not find url for symbol\");\n+\n+        expect.assert_eq(&url)\n+    }\n+\n+    fn check_rewrite(ra_fixture: &str, expect: Expect) {\n+        let (analysis, position) = fixture::position(ra_fixture);\n+        let sema = &Semantics::new(&*analysis.db);\n+        let (cursor_def, docs) = def_under_cursor(sema, &position);\n+        let res = rewrite_links(sema.db, docs.as_str(), cursor_def);\n+        expect.assert_eq(&res)\n+    }\n+\n+    fn check_doc_links(ra_fixture: &str) {\n+        let key_fn = |&(FileRange { file_id, range }, _): &_| (file_id, range.start());\n+\n+        let (analysis, position, mut expected) = fixture::annotations(ra_fixture);\n+        expected.sort_by_key(key_fn);\n+        let sema = &Semantics::new(&*analysis.db);\n+        let (cursor_def, docs) = def_under_cursor(sema, &position);\n+        let defs = extract_definitions_from_docs(&docs);\n+        let actual: Vec<_> = defs\n+            .into_iter()\n+            .map(|(_, link, ns)| {\n+                let def = resolve_doc_path_for_def(sema.db, cursor_def, &link, ns)\n+                    .unwrap_or_else(|| panic!(\"Failed to resolve {}\", link));\n+                let nav_target = def.try_to_nav(sema.db).unwrap();\n+                let range = FileRange {\n+                    file_id: nav_target.file_id,\n+                    range: nav_target.focus_or_full_range(),\n+                };\n+                (range, link)\n+            })\n+            .sorted_by_key(key_fn)\n+            .collect();\n+        assert_eq!(expected, actual);\n+    }\n+\n+    fn def_under_cursor(\n+        sema: &Semantics<RootDatabase>,\n+        position: &FilePosition,\n+    ) -> (Definition, hir::Documentation) {\n+        let (docs, def) = sema\n+            .parse(position.file_id)\n+            .syntax()\n+            .token_at_offset(position.offset)\n+            .next()\n+            .unwrap()\n+            .ancestors()\n+            .find_map(|it| node_to_def(sema, &it))\n+            .expect(\"no def found\")\n+            .unwrap();\n+        let docs = docs.expect(\"no docs found for cursor def\");\n+        (def, docs)\n+    }\n+\n+    fn node_to_def(\n+        sema: &Semantics<RootDatabase>,\n+        node: &SyntaxNode,\n+    ) -> Option<Option<(Option<hir::Documentation>, Definition)>> {\n+        Some(match_ast! {\n+            match node {\n+                ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+                ast::Module(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+                ast::Fn(it)          => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n+                ast::Struct(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n+                ast::Union(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n+                ast::Enum(it)        => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n+                ast::Variant(it)     => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n+                ast::Trait(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n+                ast::Static(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n+                ast::Const(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n+                ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n+                ast::Impl(it)        => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::SelfType(def))),\n+                ast::RecordField(it) => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Field(def))),\n+                ast::TupleField(it)  => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Field(def))),\n+                ast::Macro(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Macro(def))),\n+                // ast::Use(it) => sema.to_def(&it).map(|def| (Box::new(it) as _, def.attrs(sema.db))),\n+                _ => return None,\n+            }\n+        })\n+    }\n }"}, {"sha": "d94999dddd3f3b09fccbd2f3af87d68518192d3b", "filename": "crates/ide/src/doc_links/intra_doc_links.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links%2Fintra_doc_links.rs?ref=4705df44c74b3b9f344ed077dc68e4284dd78a62", "patch": "@@ -0,0 +1,79 @@\n+//! Helper tools for intra doc links.\n+\n+const TYPES: ([&str; 9], [&str; 0]) =\n+    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\", \"prim\", \"primitive\"], []);\n+const VALUES: ([&str; 8], [&str; 1]) =\n+    ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n+const MACROS: ([&str; 2], [&str; 1]) = ([\"macro\", \"derive\"], [\"!\"]);\n+\n+/// Extract the specified namespace from an intra-doc-link if one exists.\n+///\n+/// # Examples\n+///\n+/// * `struct MyStruct` -> (\"MyStruct\", `Namespace::Types`)\n+/// * `panic!` -> (\"panic\", `Namespace::Macros`)\n+/// * `fn@from_intra_spec` -> (\"from_intra_spec\", `Namespace::Values`)\n+pub(super) fn parse_intra_doc_link(s: &str) -> (&str, Option<hir::Namespace>) {\n+    let s = s.trim_matches('`');\n+\n+    [\n+        (hir::Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n+        (hir::Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n+        (hir::Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n+    ]\n+    .iter()\n+    .cloned()\n+    .find_map(|(ns, (mut prefixes, mut suffixes))| {\n+        if let Some(prefix) = prefixes.find(|&&prefix| {\n+            s.starts_with(prefix)\n+                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n+        }) {\n+            Some((&s[prefix.len() + 1..], ns))\n+        } else {\n+            suffixes.find_map(|&suffix| s.strip_suffix(suffix).zip(Some(ns)))\n+        }\n+    })\n+    .map_or((s, None), |(s, ns)| (s, Some(ns)))\n+}\n+\n+pub(super) fn strip_prefixes_suffixes(s: &str) -> &str {\n+    [\n+        (TYPES.0.iter(), TYPES.1.iter()),\n+        (VALUES.0.iter(), VALUES.1.iter()),\n+        (MACROS.0.iter(), MACROS.1.iter()),\n+    ]\n+    .iter()\n+    .cloned()\n+    .find_map(|(mut prefixes, mut suffixes)| {\n+        if let Some(prefix) = prefixes.find(|&&prefix| {\n+            s.starts_with(prefix)\n+                && s.chars().nth(prefix.len()).map_or(false, |c| c == '@' || c == ' ')\n+        }) {\n+            Some(&s[prefix.len() + 1..])\n+        } else {\n+            suffixes.find_map(|&suffix| s.strip_suffix(suffix))\n+        }\n+    })\n+    .unwrap_or(s)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{expect, Expect};\n+\n+    use super::*;\n+\n+    fn check(link: &str, expected: Expect) {\n+        let (l, a) = parse_intra_doc_link(link);\n+        let a = a.map_or_else(String::new, |a| format!(\" ({:?})\", a));\n+        expected.assert_eq(&format!(\"{}{}\", l, a));\n+    }\n+\n+    #[test]\n+    fn test_name() {\n+        check(\"foo\", expect![[r#\"foo\"#]]);\n+        check(\"struct Struct\", expect![[r#\"Struct (Types)\"#]]);\n+        check(\"makro!\", expect![[r#\"makro (Macros)\"#]]);\n+        check(\"fn@function\", expect![[r#\"function (Values)\"#]]);\n+    }\n+}"}, {"sha": "4a0290727418bc482e8cfa76fea4a400d4653c75", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=4705df44c74b3b9f344ed077dc68e4284dd78a62", "patch": "@@ -12,7 +12,7 @@ use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, Text\n \n use crate::{\n     display::{ToNav, TryToNav},\n-    doc_links::{doc_attributes, extract_definitions_from_markdown, resolve_doc_path_for_def},\n+    doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n \n@@ -46,7 +46,7 @@ pub(crate) fn goto_definition(\n \n         let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n         let (_, link, ns) =\n-            extract_definitions_from_markdown(docs.as_str()).into_iter().find(|(range, ..)| {\n+            extract_definitions_from_docs(&docs).into_iter().find(|(range, ..)| {\n                 doc_mapping.map(*range).map_or(false, |InFile { file_id, value: range }| {\n                     file_id == position.file_id.into() && range.contains(position.offset)\n                 })"}, {"sha": "653833dd346d03f910f07b1fd124f00a6cc5764d", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 3, "deletions": 385, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=4705df44c74b3b9f344ed077dc68e4284dd78a62", "patch": "@@ -19,7 +19,7 @@ use syntax::{\n use crate::{\n     display::{macro_label, TryToNav},\n     doc_links::{\n-        doc_attributes, extract_definitions_from_markdown, remove_links, resolve_doc_path_for_def,\n+        doc_attributes, extract_definitions_from_docs, remove_links, resolve_doc_path_for_def,\n         rewrite_links,\n     },\n     markdown_remove::remove_markdown,\n@@ -119,7 +119,7 @@ pub(crate) fn hover(\n                     let (attributes, def) = doc_attributes(&sema, &node)?;\n                     let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n                     let (idl_range, link, ns) =\n-                        extract_definitions_from_markdown(docs.as_str()).into_iter().find_map(|(range, link, ns)| {\n+                        extract_definitions_from_docs(&docs).into_iter().find_map(|(range, link, ns)| {\n                             let hir::InFile { file_id, value: range } = doc_mapping.map(range)?;\n                             if file_id == position.file_id.into() && range.contains(position.offset) {\n                                 Some((range, link, ns))\n@@ -369,7 +369,7 @@ fn process_markup(\n     let markup = if !config.markdown() {\n         remove_markdown(markup)\n     } else if config.links_in_hover {\n-        rewrite_links(db, markup, &def)\n+        rewrite_links(db, markup, def)\n     } else {\n         remove_links(markup)\n     };\n@@ -1779,334 +1779,6 @@ fn foo() { let bar = Ba$0r; }\n         );\n     }\n \n-    #[test]\n-    fn test_hover_path_link() {\n-        check(\n-            r#\"\n-pub struct Foo;\n-/// [Foo](struct.Foo.html)\n-pub struct B$0ar\n-\"#,\n-            expect![[r#\"\n-                *Bar*\n-\n-                ```rust\n-                test\n-                ```\n-\n-                ```rust\n-                pub struct Bar\n-                ```\n-\n-                ---\n-\n-                [Foo](https://docs.rs/test/*/test/struct.Foo.html)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_hover_path_link_no_strip() {\n-        check(\n-            r#\"\n-pub struct Foo;\n-/// [struct Foo](struct.Foo.html)\n-pub struct B$0ar\n-\"#,\n-            expect![[r#\"\n-                *Bar*\n-\n-                ```rust\n-                test\n-                ```\n-\n-                ```rust\n-                pub struct Bar\n-                ```\n-\n-                ---\n-\n-                [struct Foo](https://docs.rs/test/*/test/struct.Foo.html)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_hover_path_link_field() {\n-        // FIXME: Should be\n-        //  [Foo](https://docs.rs/test/*/test/struct.Foo.html)\n-        check(\n-            r#\"\n-pub struct Foo;\n-pub struct Bar {\n-    /// [Foo](struct.Foo.html)\n-    fie$0ld: ()\n-}\n-\"#,\n-            expect![[r#\"\n-                *field*\n-\n-                ```rust\n-                test::Bar\n-                ```\n-\n-                ```rust\n-                field: ()\n-                ```\n-\n-                ---\n-\n-                [Foo](struct.Foo.html)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_hover_intra_link() {\n-        check(\n-            r#\"\n-pub mod foo {\n-    pub struct Foo;\n-}\n-/// [Foo](foo::Foo)\n-pub struct B$0ar\n-\"#,\n-            expect![[r#\"\n-                *Bar*\n-\n-                ```rust\n-                test\n-                ```\n-\n-                ```rust\n-                pub struct Bar\n-                ```\n-\n-                ---\n-\n-                [Foo](https://docs.rs/test/*/test/foo/struct.Foo.html)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_hover_intra_link_html_root_url() {\n-        check(\n-            r#\"\n-#![doc(arbitrary_attribute = \"test\", html_root_url = \"https:/example.com\", arbitrary_attribute2)]\n-\n-pub mod foo {\n-    pub struct Foo;\n-}\n-/// [Foo](foo::Foo)\n-pub struct B$0ar\n-\"#,\n-            expect![[r#\"\n-                *Bar*\n-\n-                ```rust\n-                test\n-                ```\n-\n-                ```rust\n-                pub struct Bar\n-                ```\n-\n-                ---\n-\n-                [Foo](https://example.com/test/foo/struct.Foo.html)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_hover_intra_link_shortlink() {\n-        check(\n-            r#\"\n-pub struct Foo;\n-/// [Foo]\n-pub struct B$0ar\n-\"#,\n-            expect![[r#\"\n-                *Bar*\n-\n-                ```rust\n-                test\n-                ```\n-\n-                ```rust\n-                pub struct Bar\n-                ```\n-\n-                ---\n-\n-                [Foo](https://docs.rs/test/*/test/struct.Foo.html)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_hover_intra_link_shortlink_code() {\n-        check(\n-            r#\"\n-pub struct Foo;\n-/// [`Foo`]\n-pub struct B$0ar\n-\"#,\n-            expect![[r#\"\n-                *Bar*\n-\n-                ```rust\n-                test\n-                ```\n-\n-                ```rust\n-                pub struct Bar\n-                ```\n-\n-                ---\n-\n-                [`Foo`](https://docs.rs/test/*/test/struct.Foo.html)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_hover_intra_link_namespaced() {\n-        check(\n-            r#\"\n-pub struct Foo;\n-fn Foo() {}\n-/// [Foo()]\n-pub struct B$0ar\n-\"#,\n-            expect![[r#\"\n-                *Bar*\n-\n-                ```rust\n-                test\n-                ```\n-\n-                ```rust\n-                pub struct Bar\n-                ```\n-\n-                ---\n-\n-                [Foo](https://docs.rs/test/*/test/struct.Foo.html)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_hover_intra_link_shortlink_namspaced_code() {\n-        check(\n-            r#\"\n-pub struct Foo;\n-/// [`struct Foo`]\n-pub struct B$0ar\n-\"#,\n-            expect![[r#\"\n-                *Bar*\n-\n-                ```rust\n-                test\n-                ```\n-\n-                ```rust\n-                pub struct Bar\n-                ```\n-\n-                ---\n-\n-                [`Foo`](https://docs.rs/test/*/test/struct.Foo.html)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_hover_intra_link_shortlink_namspaced_code_with_at() {\n-        check(\n-            r#\"\n-pub struct Foo;\n-/// [`struct@Foo`]\n-pub struct B$0ar\n-\"#,\n-            expect![[r#\"\n-                *Bar*\n-\n-                ```rust\n-                test\n-                ```\n-\n-                ```rust\n-                pub struct Bar\n-                ```\n-\n-                ---\n-\n-                [`Foo`](https://docs.rs/test/*/test/struct.Foo.html)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_hover_intra_link_reference() {\n-        check(\n-            r#\"\n-pub struct Foo;\n-/// [my Foo][foo]\n-///\n-/// [foo]: Foo\n-pub struct B$0ar\n-\"#,\n-            expect![[r#\"\n-                *Bar*\n-\n-                ```rust\n-                test\n-                ```\n-\n-                ```rust\n-                pub struct Bar\n-                ```\n-\n-                ---\n-\n-                [my Foo](https://docs.rs/test/*/test/struct.Foo.html)\n-            \"#]],\n-        );\n-    }\n-    #[test]\n-    fn test_hover_intra_link_reference_to_trait_method() {\n-        check(\n-            r#\"\n-pub trait Foo {\n-    fn buzz() -> usize;\n-}\n-/// [Foo][buzz]\n-///\n-/// [buzz]: Foo::buzz\n-pub struct B$0ar\n-\"#,\n-            expect![[r#\"\n-                *Bar*\n-\n-                ```rust\n-                test\n-                ```\n-\n-                ```rust\n-                pub struct Bar\n-                ```\n-\n-                ---\n-\n-                [Foo](https://docs.rs/test/*/test/trait.Foo.html#tymethod.buzz)\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn test_hover_external_url() {\n         check(\n@@ -2160,60 +1832,6 @@ pub struct B$0ar\n         );\n     }\n \n-    #[test]\n-    fn test_doc_links_enum_variant() {\n-        check(\n-            r#\"\n-enum E {\n-    /// [E]\n-    V$0 { field: i32 }\n-}\n-\"#,\n-            expect![[r#\"\n-                *V*\n-\n-                ```rust\n-                test::E\n-                ```\n-\n-                ```rust\n-                V { field: i32 }\n-                ```\n-\n-                ---\n-\n-                [E](https://docs.rs/test/*/test/enum.E.html)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_doc_links_field() {\n-        check(\n-            r#\"\n-struct S {\n-    /// [`S`]\n-    field$0: i32\n-}\n-\"#,\n-            expect![[r#\"\n-                *field*\n-\n-                ```rust\n-                test::S\n-                ```\n-\n-                ```rust\n-                field: i32\n-                ```\n-\n-                ---\n-\n-                [`S`](https://docs.rs/test/*/test/struct.S.html)\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn test_hover_no_links() {\n         check_hover_no_links("}, {"sha": "2cf801751ca7a50f995d20850608c79e9a57ef85", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 43, "deletions": 48, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=4705df44c74b3b9f344ed077dc68e4284dd78a62", "patch": "@@ -157,7 +157,7 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n                 hir::ModuleDef::Function(it) => runnable_fn(&sema, it),\n                 _ => None,\n             };\n-            add_opt(runnable.or_else(|| module_def_doctest(&sema, def)), Some(def));\n+            add_opt(runnable.or_else(|| module_def_doctest(sema.db, def)), Some(def));\n         }\n         Either::Right(impl_) => {\n             add_opt(runnable_impl(&sema, &impl_), None);\n@@ -168,9 +168,9 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n                     (\n                         match assoc {\n                             hir::AssocItem::Function(it) => runnable_fn(&sema, it)\n-                                .or_else(|| module_def_doctest(&sema, it.into())),\n-                            hir::AssocItem::Const(it) => module_def_doctest(&sema, it.into()),\n-                            hir::AssocItem::TypeAlias(it) => module_def_doctest(&sema, it.into()),\n+                                .or_else(|| module_def_doctest(sema.db, it.into())),\n+                            hir::AssocItem::Const(it) => module_def_doctest(sema.db, it.into()),\n+                            hir::AssocItem::TypeAlias(it) => module_def_doctest(sema.db, it.into()),\n                         },\n                         assoc,\n                     )\n@@ -382,61 +382,56 @@ fn runnable_mod_outline_definition(\n     }\n }\n \n-fn module_def_doctest(sema: &Semantics<RootDatabase>, def: hir::ModuleDef) -> Option<Runnable> {\n+fn module_def_doctest(db: &RootDatabase, def: hir::ModuleDef) -> Option<Runnable> {\n     let attrs = match def {\n-        hir::ModuleDef::Module(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Function(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Adt(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Variant(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Const(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Static(it) => it.attrs(sema.db),\n-        hir::ModuleDef::Trait(it) => it.attrs(sema.db),\n-        hir::ModuleDef::TypeAlias(it) => it.attrs(sema.db),\n+        hir::ModuleDef::Module(it) => it.attrs(db),\n+        hir::ModuleDef::Function(it) => it.attrs(db),\n+        hir::ModuleDef::Adt(it) => it.attrs(db),\n+        hir::ModuleDef::Variant(it) => it.attrs(db),\n+        hir::ModuleDef::Const(it) => it.attrs(db),\n+        hir::ModuleDef::Static(it) => it.attrs(db),\n+        hir::ModuleDef::Trait(it) => it.attrs(db),\n+        hir::ModuleDef::TypeAlias(it) => it.attrs(db),\n         hir::ModuleDef::BuiltinType(_) => return None,\n     };\n     if !has_runnable_doc_test(&attrs) {\n         return None;\n     }\n-    let def_name = def.name(sema.db).map(|it| it.to_string());\n-    let test_id = def\n-        .canonical_path(sema.db)\n-        // This probably belongs to canonical path?\n-        .map(|path| {\n-            let assoc_def = match def {\n-                hir::ModuleDef::Function(it) => it.as_assoc_item(sema.db),\n-                hir::ModuleDef::Const(it) => it.as_assoc_item(sema.db),\n-                hir::ModuleDef::TypeAlias(it) => it.as_assoc_item(sema.db),\n-                _ => None,\n-            };\n-            // FIXME: this also looks very wrong\n-            if let Some(assoc_def) = assoc_def {\n-                if let hir::AssocItemContainer::Impl(imp) = assoc_def.container(sema.db) {\n-                    let ty = imp.self_ty(sema.db);\n-                    if let Some(adt) = ty.as_adt() {\n-                        let name = adt.name(sema.db);\n-                        let idx = path.rfind(':').map_or(0, |idx| idx + 1);\n-                        let (prefix, suffix) = path.split_at(idx);\n-                        let mut ty_args = ty.type_arguments().peekable();\n-                        let params = if ty_args.peek().is_some() {\n-                            format!(\n-                                \"<{}>\",\n-                                ty_args.format_with(\", \", |ty, cb| cb(&ty.display(sema.db)))\n-                            )\n-                        } else {\n-                            String::new()\n-                        };\n-                        return format!(\"{}{}{}::{}\", prefix, name, params, suffix);\n+    let def_name = def.name(db)?;\n+    let path = (|| {\n+        let mut path = String::new();\n+        def.canonical_module_path(db)?\n+            .flat_map(|it| it.name(db))\n+            .for_each(|name| format_to!(path, \"{}::\", name));\n+        // This probably belongs to canonical_path?\n+        if let Some(assoc_item) = def.as_assoc_item(db) {\n+            if let hir::AssocItemContainer::Impl(imp) = assoc_item.container(db) {\n+                let ty = imp.self_ty(db);\n+                if let Some(adt) = ty.as_adt() {\n+                    let name = adt.name(db);\n+                    let mut ty_args = ty.type_arguments().peekable();\n+                    format_to!(path, \"{}\", name);\n+                    if ty_args.peek().is_some() {\n+                        format_to!(\n+                            path,\n+                            \"<{}>\",\n+                            ty_args.format_with(\", \", |ty, cb| cb(&ty.display(db)))\n+                        );\n                     }\n+                    format_to!(path, \"::{}\", def_name);\n+                    return Some(path);\n                 }\n             }\n-            path\n-        })\n-        .map(TestId::Path)\n-        .or_else(|| def_name.clone().map(TestId::Name))?;\n+        }\n+        format_to!(path, \"{}\", def_name);\n+        Some(path)\n+    })();\n+\n+    let test_id = path.map_or_else(|| TestId::Name(def_name.to_string()), TestId::Path);\n \n     let mut nav = match def {\n-        hir::ModuleDef::Module(def) => NavigationTarget::from_module_to_decl(sema.db, def),\n-        def => def.try_to_nav(sema.db)?,\n+        hir::ModuleDef::Module(def) => NavigationTarget::from_module_to_decl(db, def),\n+        def => def.try_to_nav(db)?,\n     };\n     nav.focus_range = None;\n     nav.description = None;"}, {"sha": "72da4bc0f1f6ac203f4ab7acdd5008e1473f3731", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4705df44c74b3b9f344ed077dc68e4284dd78a62/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=4705df44c74b3b9f344ed077dc68e4284dd78a62", "patch": "@@ -11,7 +11,7 @@ use syntax::{\n };\n \n use crate::{\n-    doc_links::{doc_attributes, extract_definitions_from_markdown, resolve_doc_path_for_def},\n+    doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n     Analysis, HlMod, HlRange, HlTag, RootDatabase,\n };\n \n@@ -104,7 +104,7 @@ pub(super) fn doc_comment(\n     let mut string;\n \n     if let Some((docs, doc_mapping)) = attributes.docs_with_rangemap(sema.db) {\n-        extract_definitions_from_markdown(docs.as_str())\n+        extract_definitions_from_docs(&docs)\n             .into_iter()\n             .filter_map(|(range, link, ns)| {\n                 let def = resolve_doc_path_for_def(sema.db, def, &link, ns)?;"}]}