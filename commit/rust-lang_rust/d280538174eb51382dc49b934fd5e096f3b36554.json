{"sha": "d280538174eb51382dc49b934fd5e096f3b36554", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyODA1MzgxNzRlYjUxMzgyZGM0OWI5MzRmZDVlMDk2ZjNiMzY1NTQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-06T18:51:21Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-06T19:10:22Z"}, "message": "Clean up Chalk mapping a bit", "tree": {"sha": "78d09c5fb00dfcaa5e99ff4a7a21d799fe544018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78d09c5fb00dfcaa5e99ff4a7a21d799fe544018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d280538174eb51382dc49b934fd5e096f3b36554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d280538174eb51382dc49b934fd5e096f3b36554", "html_url": "https://github.com/rust-lang/rust/commit/d280538174eb51382dc49b934fd5e096f3b36554", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d280538174eb51382dc49b934fd5e096f3b36554/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5df65e5066a534cfb1e0d5ff494b1cd775d5dd90", "url": "https://api.github.com/repos/rust-lang/rust/commits/5df65e5066a534cfb1e0d5ff494b1cd775d5dd90", "html_url": "https://github.com/rust-lang/rust/commit/5df65e5066a534cfb1e0d5ff494b1cd775d5dd90"}], "stats": {"total": 106, "additions": 37, "deletions": 69}, "files": [{"sha": "0536b934e7e3c234e62afc0f595e5733de27ae17", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 37, "deletions": 69, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d280538174eb51382dc49b934fd5e096f3b36554/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d280538174eb51382dc49b934fd5e096f3b36554/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=d280538174eb51382dc49b934fd5e096f3b36554", "patch": "@@ -10,10 +10,9 @@ use base_db::salsa::InternKey;\n use hir_def::{GenericDefId, TypeAliasId};\n \n use crate::{\n-    chalk_ext::ProjectionTyExt, db::HirDatabase, dummy_usize_const, static_lifetime, AliasTy,\n-    CallableDefId, Canonical, Const, DomainGoal, FnPointer, GenericArg, InEnvironment, Lifetime,\n-    OpaqueTy, ProjectionTy, QuantifiedWhereClause, Substitution, TraitRef, Ty, TypeWalk,\n-    WhereClause,\n+    chalk_ext::ProjectionTyExt, db::HirDatabase, static_lifetime, AliasTy, CallableDefId,\n+    Canonical, DomainGoal, FnPointer, GenericArg, InEnvironment, OpaqueTy, ProjectionTy,\n+    QuantifiedWhereClause, Substitution, TraitRef, Ty, TypeWalk, WhereClause,\n };\n \n use super::interner::*;\n@@ -23,16 +22,16 @@ impl ToChalk for Ty {\n     type Chalk = chalk_ir::Ty<Interner>;\n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n         match self.into_inner() {\n-            TyKind::Ref(m, lt, ty) => ref_to_chalk(db, m, lt, ty),\n-            TyKind::Array(ty, size) => array_to_chalk(db, ty, size),\n-            TyKind::Function(FnPointer { sig, substitution: substs, .. }) => {\n+            TyKind::Ref(m, lt, ty) => {\n+                chalk_ir::TyKind::Ref(m, lt, ty.to_chalk(db)).intern(&Interner)\n+            }\n+            TyKind::Array(ty, size) => {\n+                chalk_ir::TyKind::Array(ty.to_chalk(db), size).intern(&Interner)\n+            }\n+            TyKind::Function(FnPointer { sig, substitution: substs, num_binders }) => {\n                 let substitution = chalk_ir::FnSubst(substs.0.to_chalk(db));\n-                chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n-                    num_binders: 0,\n-                    sig,\n-                    substitution,\n-                })\n-                .intern(&Interner)\n+                chalk_ir::TyKind::Function(chalk_ir::FnPointer { num_binders, sig, substitution })\n+                    .intern(&Interner)\n             }\n             TyKind::AssociatedType(assoc_type_id, substs) => {\n                 let substitution = substs.to_chalk(db);\n@@ -74,22 +73,13 @@ impl ToChalk for Ty {\n                 chalk_ir::TyKind::Adt(adt_id, substitution).intern(&Interner)\n             }\n             TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n-                let associated_ty_id = proj_ty.associated_ty_id;\n-                let substitution = proj_ty.substitution.to_chalk(db);\n-                chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n-                    associated_ty_id,\n-                    substitution,\n-                })\n-                .cast(&Interner)\n-                .intern(&Interner)\n-            }\n-            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n-                let opaque_ty_id = opaque_ty.opaque_ty_id;\n-                let substitution = opaque_ty.substitution.to_chalk(db);\n-                chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy { opaque_ty_id, substitution })\n+                chalk_ir::AliasTy::Projection(proj_ty.to_chalk(db))\n                     .cast(&Interner)\n                     .intern(&Interner)\n             }\n+            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n+                chalk_ir::AliasTy::Opaque(opaque_ty.to_chalk(db)).cast(&Interner).intern(&Interner)\n+            }\n             TyKind::Placeholder(idx) => idx.to_ty::<Interner>(&Interner),\n             TyKind::BoundVar(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n             TyKind::InferenceVar(..) => panic!(\"uncanonicalized infer ty\"),\n@@ -101,7 +91,7 @@ impl ToChalk for Ty {\n                 );\n                 let bounded_ty = chalk_ir::DynTy {\n                     bounds: chalk_ir::Binders::new(binders, where_clauses),\n-                    lifetime: static_lifetime(),\n+                    lifetime: dyn_ty.lifetime,\n                 };\n                 chalk_ir::TyKind::Dyn(bounded_ty).intern(&Interner)\n             }\n@@ -114,17 +104,10 @@ impl ToChalk for Ty {\n             chalk_ir::TyKind::Array(ty, size) => TyKind::Array(from_chalk(db, ty), size),\n             chalk_ir::TyKind::Placeholder(idx) => TyKind::Placeholder(idx),\n             chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Projection(proj)) => {\n-                let associated_ty = proj.associated_ty_id;\n-                let parameters = from_chalk(db, proj.substitution);\n-                TyKind::Alias(AliasTy::Projection(ProjectionTy {\n-                    associated_ty_id: associated_ty,\n-                    substitution: parameters,\n-                }))\n+                TyKind::Alias(AliasTy::Projection(from_chalk(db, proj)))\n             }\n             chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(opaque_ty)) => {\n-                let opaque_ty_id = opaque_ty.opaque_ty_id;\n-                let parameters = from_chalk(db, opaque_ty.substitution);\n-                TyKind::Alias(AliasTy::Opaque(OpaqueTy { opaque_ty_id, substitution: parameters }))\n+                TyKind::Alias(AliasTy::Opaque(from_chalk(db, opaque_ty)))\n             }\n             chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                 num_binders,\n@@ -138,18 +121,19 @@ impl ToChalk for Ty {\n             }\n             chalk_ir::TyKind::BoundVar(idx) => TyKind::BoundVar(idx),\n             chalk_ir::TyKind::InferenceVar(_iv, _kind) => TyKind::Error,\n-            chalk_ir::TyKind::Dyn(where_clauses) => {\n-                assert_eq!(where_clauses.bounds.binders.len(&Interner), 1);\n-                let bounds = where_clauses\n-                    .bounds\n-                    .skip_binders()\n-                    .iter(&Interner)\n-                    .map(|c| from_chalk(db, c.clone()));\n+            chalk_ir::TyKind::Dyn(dyn_ty) => {\n+                assert_eq!(dyn_ty.bounds.binders.len(&Interner), 1);\n+                let (bounds, binders) = dyn_ty.bounds.into_value_and_skipped_binders();\n+                let where_clauses = crate::QuantifiedWhereClauses::from_iter(\n+                    &Interner,\n+                    bounds.interned().iter().cloned().map(|p| from_chalk(db, p)),\n+                );\n                 TyKind::Dyn(crate::DynTy {\n-                    bounds: crate::Binders::new(\n-                        where_clauses.bounds.binders.clone(),\n-                        crate::QuantifiedWhereClauses::from_iter(&Interner, bounds),\n-                    ),\n+                    bounds: crate::Binders::new(binders, where_clauses),\n+                    // HACK: we sometimes get lifetime variables back in solutions\n+                    // from Chalk, and don't have the infrastructure to substitute\n+                    // them yet. So for now we just turn them into 'static right\n+                    // when we get them\n                     lifetime: static_lifetime(),\n                 })\n             }\n@@ -169,8 +153,12 @@ impl ToChalk for Ty {\n             }\n             chalk_ir::TyKind::Raw(mutability, ty) => TyKind::Raw(mutability, from_chalk(db, ty)),\n             chalk_ir::TyKind::Slice(ty) => TyKind::Slice(from_chalk(db, ty)),\n-            chalk_ir::TyKind::Ref(mutability, lifetime, ty) => {\n-                TyKind::Ref(mutability, lifetime, from_chalk(db, ty))\n+            chalk_ir::TyKind::Ref(mutability, _lifetime, ty) => {\n+                // HACK: we sometimes get lifetime variables back in solutions\n+                // from Chalk, and don't have the infrastructure to substitute\n+                // them yet. So for now we just turn them into 'static right\n+                // when we get them\n+                TyKind::Ref(mutability, static_lifetime(), from_chalk(db, ty))\n             }\n             chalk_ir::TyKind::Str => TyKind::Str,\n             chalk_ir::TyKind::Never => TyKind::Never,\n@@ -189,26 +177,6 @@ impl ToChalk for Ty {\n     }\n }\n \n-/// We currently don't model lifetimes, but Chalk does. So, we have to insert a\n-/// fake lifetime here, because Chalks built-in logic may expect it to be there.\n-fn ref_to_chalk(\n-    db: &dyn HirDatabase,\n-    mutability: chalk_ir::Mutability,\n-    _lifetime: Lifetime,\n-    ty: Ty,\n-) -> chalk_ir::Ty<Interner> {\n-    let arg = ty.to_chalk(db);\n-    let lifetime = static_lifetime();\n-    chalk_ir::TyKind::Ref(mutability, lifetime, arg).intern(&Interner)\n-}\n-\n-/// We currently don't model constants, but Chalk does. So, we have to insert a\n-/// fake constant here, because Chalks built-in logic may expect it to be there.\n-fn array_to_chalk(db: &dyn HirDatabase, ty: Ty, _: Const) -> chalk_ir::Ty<Interner> {\n-    let arg = ty.to_chalk(db);\n-    chalk_ir::TyKind::Array(arg, dummy_usize_const()).intern(&Interner)\n-}\n-\n impl ToChalk for GenericArg {\n     type Chalk = chalk_ir::GenericArg<Interner>;\n "}]}