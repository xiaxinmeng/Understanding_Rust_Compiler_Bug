{"sha": "d6bdf296a42caec8711adc075782e0b8c920aa1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YmRmMjk2YTQyY2FlYzg3MTFhZGMwNzU3ODJlMGI4YzkyMGFhMWY=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-01-29T05:12:09Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-02-17T15:10:40Z"}, "message": "Change ast::Visibility to Spanned type", "tree": {"sha": "c3a47e92b222f4c5bafbc4ad890e82d7e4af4506", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3a47e92b222f4c5bafbc4ad890e82d7e4af4506"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6bdf296a42caec8711adc075782e0b8c920aa1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6bdf296a42caec8711adc075782e0b8c920aa1f", "html_url": "https://github.com/rust-lang/rust/commit/d6bdf296a42caec8711adc075782e0b8c920aa1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6bdf296a42caec8711adc075782e0b8c920aa1f/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bddba9248674fe9fde68d3e31fcc9afee7b505c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bddba9248674fe9fde68d3e31fcc9afee7b505c", "html_url": "https://github.com/rust-lang/rust/commit/0bddba9248674fe9fde68d3e31fcc9afee7b505c"}], "stats": {"total": 280, "additions": 153, "deletions": 127}, "files": [{"sha": "e3af285053805e68c768e80a5ff92431eb4d6589", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -3362,10 +3362,10 @@ impl<'a> LoweringContext<'a> {\n                         v: &Visibility,\n                         explicit_owner: Option<NodeId>)\n                         -> hir::Visibility {\n-        match *v {\n-            Visibility::Public => hir::Public,\n-            Visibility::Crate(..) => hir::Visibility::Crate,\n-            Visibility::Restricted { ref path, id, .. } => {\n+        match v.node {\n+            VisibilityKind::Public => hir::Public,\n+            VisibilityKind::Crate(..) => hir::Visibility::Crate,\n+            VisibilityKind::Restricted { ref path, id, .. } => {\n                 hir::Visibility::Restricted {\n                     path: P(self.lower_path(id, path, ParamMode::Explicit, true)),\n                     id: if let Some(owner) = explicit_owner {\n@@ -3375,7 +3375,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n             }\n-            Visibility::Inherited => hir::Inherited,\n+            VisibilityKind::Inherited => hir::Inherited,\n         }\n     }\n "}, {"sha": "951c2280f76f9681a9ab62bb67c7aac8339c2cf1", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -13,7 +13,7 @@ use rustc_errors;\n use syntax::abi::Abi;\n use syntax::ast::{Crate, Attribute, LitKind, StrStyle, ExprKind};\n use syntax::ast::{Unsafety, Constness, Generics, Mutability, Ty, Mac, Arg};\n-use syntax::ast::{self, Ident, Item, ItemKind, TyKind, Visibility, Expr};\n+use syntax::ast::{self, Ident, Item, ItemKind, TyKind, VisibilityKind, Expr};\n use syntax::attr;\n use syntax::codemap::dummy_spanned;\n use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n@@ -97,7 +97,7 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n         ]);\n         let mut items = vec![\n             f.cx.item_extern_crate(f.span, f.alloc),\n-            f.cx.item_use_simple(f.span, Visibility::Inherited, super_path),\n+            f.cx.item_use_simple(f.span, dummy_spanned(VisibilityKind::Inherited), super_path),\n         ];\n         for method in ALLOCATOR_METHODS {\n             items.push(f.allocator_fn(method));"}, {"sha": "3e5ba4851cd00ccd774a391716007b3e3f8ede4d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -34,6 +34,7 @@ use std::rc::Rc;\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::codemap;\n use syntax::ext::base::SyntaxExtension;\n use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n@@ -496,7 +497,7 @@ impl CrateStore for cstore::CStore {\n                 tokens: body.into(),\n                 legacy: def.legacy,\n             }),\n-            vis: ast::Visibility::Inherited,\n+            vis: codemap::dummy_spanned(ast::VisibilityKind::Inherited),\n             tokens: None,\n         })\n     }"}, {"sha": "bb6dbe632e3168d1f57317f019ab4a508ac37d3c", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -58,14 +58,14 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn invalid_visibility(&self, vis: &Visibility, span: Span, note: Option<&str>) {\n-        if vis != &Visibility::Inherited {\n+    fn invalid_visibility(&self, vis: &Visibility, note: Option<&str>) {\n+        if vis.node != VisibilityKind::Inherited {\n             let mut err = struct_span_err!(self.session,\n-                                           span,\n+                                           vis.span,\n                                            E0449,\n                                            \"unnecessary visibility qualifier\");\n-            if vis == &Visibility::Public {\n-                err.span_label(span, \"`pub` not needed here\");\n+            if vis.node == VisibilityKind::Public {\n+                err.span_label(vis.span, \"`pub` not needed here\");\n             }\n             if let Some(note) = note {\n                 err.note(note);\n@@ -216,7 +216,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_item(&mut self, item: &'a Item) {\n         match item.node {\n             ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n-                self.invalid_visibility(&item.vis, item.span, None);\n+                self.invalid_visibility(&item.vis, None);\n                 if ty.node == TyKind::Err {\n                     self.err_handler()\n                         .struct_span_err(item.span, \"`impl Trait for .. {}` is an obsolete syntax\")\n@@ -226,15 +226,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     span_err!(self.session, item.span, E0198, \"negative impls cannot be unsafe\");\n                 }\n                 for impl_item in impl_items {\n-                    self.invalid_visibility(&impl_item.vis, impl_item.span, None);\n+                    self.invalid_visibility(&impl_item.vis, None);\n                     if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         self.check_trait_fn_not_const(sig.constness);\n                     }\n                 }\n             }\n             ItemKind::Impl(unsafety, polarity, defaultness, _, None, _, _) => {\n                 self.invalid_visibility(&item.vis,\n-                                        item.span,\n                                         Some(\"place qualifiers on individual impl items instead\"));\n                 if unsafety == Unsafety::Unsafe {\n                     span_err!(self.session, item.span, E0197, \"inherent impls cannot be unsafe\");\n@@ -247,16 +246,16 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n             }\n             ItemKind::ForeignMod(..) => {\n-                self.invalid_visibility(&item.vis,\n-                                        item.span,\n-                                        Some(\"place qualifiers on individual foreign items \\\n-                                              instead\"));\n+                self.invalid_visibility(\n+                    &item.vis,\n+                    Some(\"place qualifiers on individual foreign items instead\"),\n+                );\n             }\n             ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n                     self.invalid_non_exhaustive_attribute(variant);\n                     for field in variant.node.data.fields() {\n-                        self.invalid_visibility(&field.vis, field.span, None);\n+                        self.invalid_visibility(&field.vis, None);\n                     }\n                 }\n             }\n@@ -359,8 +358,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_vis(&mut self, vis: &'a Visibility) {\n-        match *vis {\n-            Visibility::Restricted { ref path, .. } => {\n+        match vis.node {\n+            VisibilityKind::Restricted { ref path, .. } => {\n                 path.segments.iter().find(|segment| segment.parameters.is_some()).map(|segment| {\n                     self.err_handler().span_err(segment.parameters.as_ref().unwrap().span(),\n                                                 \"generic arguments in visibility path\");"}, {"sha": "865c6b422f3d4750c32aea44abc7782e413250c3", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n         if let ast::ItemKind::Use(..) = item.node {\n-            if item.vis == ast::Visibility::Public || item.span.source_equal(&DUMMY_SP) {\n+            if item.vis.node == ast::VisibilityKind::Public || item.span.source_equal(&DUMMY_SP) {\n                 return;\n             }\n         }"}, {"sha": "facca445b9785c623597445b189b76a9714476dd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -3796,13 +3796,15 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n-        match *vis {\n-            ast::Visibility::Public => ty::Visibility::Public,\n-            ast::Visibility::Crate(..) => ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n-            ast::Visibility::Inherited => {\n+        match vis.node {\n+            ast::VisibilityKind::Public => ty::Visibility::Public,\n+            ast::VisibilityKind::Crate(..) => {\n+                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+            }\n+            ast::VisibilityKind::Inherited => {\n                 ty::Visibility::Restricted(self.current_module.normal_ancestor_id)\n             }\n-            ast::Visibility::Restricted { ref path, id, .. } => {\n+            ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 let def = self.smart_resolve_path(id, None, path,\n                                                   PathSource::Visibility).base_def();\n                 if def == Def::Err {"}, {"sha": "c9c905723b2bbff74a7c3083aaebed0dd43e6c2e", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -43,7 +43,7 @@ use syntax::print::pprust::{\n     ty_to_string\n };\n use syntax::ptr::P;\n-use syntax::codemap::{Spanned, DUMMY_SP};\n+use syntax::codemap::{Spanned, DUMMY_SP, dummy_spanned};\n use syntax_pos::*;\n \n use {escape, generated_code, lower_attributes, PathCollector, SaveContext};\n@@ -65,12 +65,19 @@ macro_rules! down_cast_data {\n }\n \n macro_rules! access_from {\n+    ($save_ctxt:expr, $vis:expr, $id:expr) => {\n+        Access {\n+            public: $vis.node == ast::VisibilityKind::Public,\n+            reachable: $save_ctxt.analysis.access_levels.is_reachable($id),\n+        }\n+    };\n+\n     ($save_ctxt:expr, $item:expr) => {\n         Access {\n-            public: $item.vis == ast::Visibility::Public,\n+            public: $item.vis.node == ast::VisibilityKind::Public,\n             reachable: $save_ctxt.analysis.access_levels.is_reachable($item.id),\n         }\n-    }\n+    };\n }\n \n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> {\n@@ -405,12 +412,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n             method_data.value = sig_str;\n             method_data.sig = sig::method_signature(id, name, generics, sig, &self.save_ctxt);\n-            self.dumper.dump_def(\n-                &Access {\n-                    public: vis == ast::Visibility::Public,\n-                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(id),\n-                },\n-                method_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, vis, id), method_data);\n         }\n \n         // walk arg and return types\n@@ -543,10 +545,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n             self.dumper.dump_def(\n-                &Access {\n-                    public: vis == ast::Visibility::Public,\n-                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(id),\n-                },\n+                &access_from!(self.save_ctxt, vis, id),\n                 Def {\n                     kind: DefKind::Const,\n                     id: ::id_from_node_id(id, &self.save_ctxt),\n@@ -597,7 +596,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     .iter()\n                     .enumerate()\n                     .filter_map(|(i, f)| {\n-                        if include_priv_fields || f.vis == ast::Visibility::Public {\n+                        if include_priv_fields || f.vis.node == ast::VisibilityKind::Public {\n                             f.ident\n                                 .map(|i| i.to_string())\n                                 .or_else(|| Some(i.to_string()))\n@@ -1144,7 +1143,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     &ty,\n                     expr.as_ref().map(|e| &**e),\n                     trait_id,\n-                    ast::Visibility::Public,\n+                    dummy_spanned(ast::VisibilityKind::Public),\n                     &trait_item.attrs,\n                 );\n             }\n@@ -1155,7 +1154,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     trait_item.id,\n                     trait_item.ident,\n                     &trait_item.generics,\n-                    ast::Visibility::Public,\n+                    dummy_spanned(ast::VisibilityKind::Public),\n                     trait_item.span,\n                 );\n             }\n@@ -1259,10 +1258,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n         // The access is calculated using the current tree ID, but with the root tree's visibility\n         // (since nested trees don't have their own visibility).\n-        let access = Access {\n-            public: root_item.vis == ast::Visibility::Public,\n-            reachable: self.save_ctxt.analysis.access_levels.is_reachable(id),\n-        };\n+        let access = access_from!(self.save_ctxt, root_item.vis, id);\n \n         // The parent def id of a given use tree is always the enclosing item.\n         let parent = self.save_ctxt.tcx.hir.opt_local_def_id(id)"}, {"sha": "c5a383bfa2ff5769d25cca89d6290d97475fd7a7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -1937,11 +1937,13 @@ pub enum CrateSugar {\n     JustCrate,\n }\n \n+pub type Visibility = Spanned<VisibilityKind>;\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Visibility {\n+pub enum VisibilityKind {\n     Public,\n-    Crate(Span, CrateSugar),\n-    Restricted { path: P<Path>, id: NodeId, span: Span },\n+    Crate(CrateSugar),\n+    Restricted { path: P<Path>, id: NodeId },\n     Inherited,\n }\n "}, {"sha": "6eaeec99b17ca7f8014d7141f931852531bc524f", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -14,6 +14,7 @@ use std::env;\n \n use ast;\n use ast::{Ident, Name};\n+use codemap;\n use syntax_pos::Span;\n use ext::base::{ExtCtxt, MacEager, MacResult};\n use ext::build::AstBuilder;\n@@ -234,7 +235,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                 ty,\n                 expr,\n             ),\n-            vis: ast::Visibility::Public,\n+            vis: codemap::dummy_spanned(ast::VisibilityKind::Public),\n             span,\n             tokens: None,\n         })"}, {"sha": "2de4643aef927a488f8fb84471cab4523e5bf381", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -987,7 +987,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             attrs,\n             id: ast::DUMMY_NODE_ID,\n             node,\n-            vis: ast::Visibility::Inherited,\n+            vis: dummy_spanned(ast::VisibilityKind::Inherited),\n             span,\n             tokens: None,\n         })\n@@ -1033,7 +1033,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 span: ty.span,\n                 ty,\n                 ident: None,\n-                vis: ast::Visibility::Inherited,\n+                vis: dummy_spanned(ast::VisibilityKind::Inherited),\n                 attrs: Vec::new(),\n                 id: ast::DUMMY_NODE_ID,\n             }"}, {"sha": "9c0a7e9516615f4f76a9cec7c45c4f412212f23f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -11,7 +11,7 @@\n use ast::{self, Block, Ident, NodeId, PatKind, Path};\n use ast::{MacStmtStyle, StmtKind, ItemKind};\n use attr::{self, HasAttrs};\n-use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute, dummy_spanned};\n+use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute, dummy_spanned, respan};\n use config::{is_test_or_bench, StripUnconfigured};\n use errors::FatalError;\n use ext::base::*;\n@@ -238,7 +238,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             node: ast::ItemKind::Mod(krate.module),\n             ident: keywords::Invalid.ident(),\n             id: ast::DUMMY_NODE_ID,\n-            vis: ast::Visibility::Public,\n+            vis: dummy_spanned(ast::VisibilityKind::Public),\n             tokens: None,\n         })));\n \n@@ -1022,7 +1022,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             // Ensure that test functions are accessible from the test harness.\n             ast::ItemKind::Fn(..) if self.cx.ecfg.should_test => {\n                 if item.attrs.iter().any(|attr| is_test_or_bench(attr)) {\n-                    item = item.map(|mut item| { item.vis = ast::Visibility::Public; item });\n+                    item = item.map(|mut item| {\n+                        item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n+                        item\n+                    });\n                 }\n                 noop_fold_item(item, self)\n             }"}, {"sha": "9c2c22476e9d9f598edf2e6358f134cdaeb661a7", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -33,7 +33,7 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     let ident = keywords::Invalid.ident();\n     let attrs = Vec::new();\n     let generics = ast::Generics::default();\n-    let vis = ast::Visibility::Inherited;\n+    let vis = dummy_spanned(ast::VisibilityKind::Inherited);\n     let span = DUMMY_SP;\n     let expr_placeholder = || P(ast::Expr {\n         id, span,"}, {"sha": "b4c005e77a355cd120b62bc3e16e929ac4c628b4", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use ast::{self, Arg, Arm, Block, Expr, Item, Pat, Stmt, Ty};\n+use codemap::dummy_spanned;\n use syntax_pos::Span;\n use ext::base::ExtCtxt;\n use ext::base;\n@@ -855,7 +856,12 @@ fn expand_wrapper(cx: &ExtCtxt,\n     let mut stmts = imports.iter().map(|path| {\n         // make item: `use ...;`\n         let path = path.iter().map(|s| s.to_string()).collect();\n-        cx.stmt_item(sp, cx.item_use_glob(sp, ast::Visibility::Inherited, ids_ext(path)))\n+        let use_item = cx.item_use_glob(\n+            sp,\n+            dummy_spanned(ast::VisibilityKind::Inherited),\n+            ids_ext(path),\n+        );\n+        cx.stmt_item(sp, use_item)\n     }).chain(Some(stmt_let_ext_cx)).collect::<Vec<_>>();\n     stmts.push(cx.stmt_expr(expr));\n "}, {"sha": "c0fde71d086f4a717d701a506379c573296d6e1b", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -1816,8 +1816,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n-        if let ast::Visibility::Crate(span, ast::CrateSugar::JustCrate) = *vis {\n-            gate_feature_post!(&self, crate_visibility_modifier, span,\n+        if let ast::VisibilityKind::Crate(ast::CrateSugar::JustCrate) = vis.node {\n+            gate_feature_post!(&self, crate_visibility_modifier, vis.span,\n                                \"`crate` visibility modifier is experimental\");\n         }\n         visit::walk_vis(self, vis);"}, {"sha": "670492818a62b1637dbf321bcee89e11103010dd", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -21,7 +21,7 @@\n use ast::*;\n use ast;\n use syntax_pos::Span;\n-use codemap::{Spanned, respan};\n+use codemap::{Spanned, respan, dummy_spanned};\n use parse::token::{self, Token};\n use ptr::P;\n use symbol::keywords;\n@@ -1018,7 +1018,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, span}: Crate,\n         ident: keywords::Invalid.ident(),\n         attrs,\n         id: ast::DUMMY_NODE_ID,\n-        vis: ast::Visibility::Public,\n+        vis: dummy_spanned(ast::VisibilityKind::Public),\n         span,\n         node: ast::ItemKind::Mod(module),\n         tokens: None,\n@@ -1367,12 +1367,13 @@ pub fn noop_fold_stmt_kind<T: Folder>(node: StmtKind, folder: &mut T) -> SmallVe\n }\n \n pub fn noop_fold_vis<T: Folder>(vis: Visibility, folder: &mut T) -> Visibility {\n-    match vis {\n-        Visibility::Restricted { path, id, span } => Visibility::Restricted {\n-            path: path.map(|path| folder.fold_path(path)),\n-            id: folder.new_id(id),\n-            span: folder.new_span(span),\n-        },\n+    match vis.node {\n+        VisibilityKind::Restricted { path, id } => {\n+            respan(vis.span, VisibilityKind::Restricted {\n+                path: path.map(|path| folder.fold_path(path)),\n+                id: folder.new_id(id),\n+            })\n+        }\n         _ => vis,\n     }\n }"}, {"sha": "5ab9a484eb79350980f792db41fd8cf341eef75d", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -932,7 +932,7 @@ mod tests {\n                                         span: sp(15,21),\n                                         recovered: false,\n                                     })),\n-                            vis: ast::Visibility::Inherited,\n+                            vis: codemap::dummy_spanned(ast::VisibilityKind::Inherited),\n                             span: sp(0,21)})));\n     }\n "}, {"sha": "573de215a5ec5d63f16b04f4db87ce6d59542203", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -36,7 +36,7 @@ use ast::StrStyle;\n use ast::SelfKind;\n use ast::{TraitItem, TraitRef, TraitObjectSyntax};\n use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n-use ast::{Visibility, WhereClause, CrateSugar};\n+use ast::{Visibility, VisibilityKind, WhereClause, CrateSugar};\n use ast::{UseTree, UseTreeKind};\n use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n@@ -4132,7 +4132,7 @@ impl<'a> Parser<'a> {\n             token::Ident(ident) if ident.name == \"macro_rules\" &&\n                                    self.look_ahead(1, |t| *t == token::Not) => {\n                 let prev_span = self.prev_span;\n-                self.complain_if_pub_macro(vis, prev_span);\n+                self.complain_if_pub_macro(&vis.node, prev_span);\n                 self.bump();\n                 self.bump();\n \n@@ -4169,7 +4169,11 @@ impl<'a> Parser<'a> {\n                 node: StmtKind::Local(self.parse_local(attrs.into())?),\n                 span: lo.to(self.prev_span),\n             }\n-        } else if let Some(macro_def) = self.eat_macro_def(&attrs, &Visibility::Inherited, lo)? {\n+        } else if let Some(macro_def) = self.eat_macro_def(\n+            &attrs,\n+            &codemap::respan(lo, VisibilityKind::Inherited),\n+            lo,\n+        )? {\n             Stmt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: StmtKind::Item(macro_def),\n@@ -4296,7 +4300,7 @@ impl<'a> Parser<'a> {\n                         self.mk_item(\n                             span, id /*id is good here*/,\n                             ItemKind::Mac(respan(span, Mac_ { path: pth, tts: tts })),\n-                            Visibility::Inherited,\n+                            respan(lo, VisibilityKind::Inherited),\n                             attrs)\n                     }),\n                 }\n@@ -5213,15 +5217,15 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn complain_if_pub_macro(&mut self, vis: &Visibility, sp: Span) {\n+    fn complain_if_pub_macro(&mut self, vis: &VisibilityKind, sp: Span) {\n         if let Err(mut err) = self.complain_if_pub_macro_diag(vis, sp) {\n             err.emit();\n         }\n     }\n \n-    fn complain_if_pub_macro_diag(&mut self, vis: &Visibility, sp: Span) -> PResult<'a, ()> {\n+    fn complain_if_pub_macro_diag(&mut self, vis: &VisibilityKind, sp: Span) -> PResult<'a, ()> {\n         match *vis {\n-            Visibility::Inherited => Ok(()),\n+            VisibilityKind::Inherited => Ok(()),\n             _ => {\n                 let is_macro_rules: bool = match self.token {\n                     token::Ident(sid) => sid.name == Symbol::intern(\"macro_rules\"),\n@@ -5283,7 +5287,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Not)?;\n             }\n \n-            self.complain_if_pub_macro(vis, prev_span);\n+            self.complain_if_pub_macro(&vis.node, prev_span);\n \n             // eat a matched-delimiter token tree:\n             *at_end = true;\n@@ -5686,12 +5690,13 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.push(TokenType::Keyword(keywords::Crate));\n         if self.is_crate_vis() {\n             self.bump(); // `crate`\n-            return Ok(Visibility::Crate(self.prev_span, CrateSugar::JustCrate));\n+            return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n         }\n \n         if !self.eat_keyword(keywords::Pub) {\n-            return Ok(Visibility::Inherited)\n+            return Ok(respan(self.prev_span, VisibilityKind::Inherited))\n         }\n+        let lo = self.prev_span;\n \n         if self.check(&token::OpenDelim(token::Paren)) {\n             // We don't `self.bump()` the `(` yet because this might be a struct definition where\n@@ -5703,19 +5708,21 @@ impl<'a> Parser<'a> {\n                 self.bump(); // `(`\n                 self.bump(); // `crate`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = Visibility::Crate(self.prev_span, CrateSugar::PubCrate);\n+                let vis = respan(\n+                    lo.to(self.prev_span),\n+                    VisibilityKind::Crate(CrateSugar::PubCrate),\n+                );\n                 return Ok(vis)\n             } else if self.look_ahead(1, |t| t.is_keyword(keywords::In)) {\n                 // `pub(in path)`\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n                 let path = self.parse_path(PathStyle::Mod)?.default_to_global(); // `path`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = Visibility::Restricted {\n+                let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n                     path: P(path),\n                     id: ast::DUMMY_NODE_ID,\n-                    span: self.prev_span,\n-                };\n+                });\n                 return Ok(vis)\n             } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n                       self.look_ahead(1, |t| t.is_keyword(keywords::Super) ||\n@@ -5725,11 +5732,10 @@ impl<'a> Parser<'a> {\n                 self.bump(); // `(`\n                 let path = self.parse_path(PathStyle::Mod)?.default_to_global(); // `super`/`self`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = Visibility::Restricted {\n+                let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n                     path: P(path),\n                     id: ast::DUMMY_NODE_ID,\n-                    span: self.prev_span,\n-                };\n+                });\n                 return Ok(vis)\n             } else if !can_take_tuple {  // Provide this diagnostic if this is not a tuple struct\n                 // `pub(something) fn ...` or `struct X { pub(something) y: Z }`\n@@ -5749,7 +5755,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        Ok(Visibility::Public)\n+        Ok(respan(lo, VisibilityKind::Public))\n     }\n \n     /// Parse defaultness: `default` or nothing.\n@@ -6582,7 +6588,7 @@ impl<'a> Parser<'a> {\n \n         // Verify wether we have encountered a struct or method definition where the user forgot to\n         // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n-        if visibility == Visibility::Public &&\n+        if visibility.node == VisibilityKind::Public &&\n             self.check_ident() &&\n             self.look_ahead(1, |t| *t != token::Not)\n         {\n@@ -6690,7 +6696,7 @@ impl<'a> Parser<'a> {\n             // MACRO INVOCATION ITEM\n \n             let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&visibility, prev_span);\n+            self.complain_if_pub_macro(&visibility.node, prev_span);\n \n             let mac_lo = self.span;\n \n@@ -6724,8 +6730,8 @@ impl<'a> Parser<'a> {\n         }\n \n         // FAILURE TO PARSE ITEM\n-        match visibility {\n-            Visibility::Inherited => {}\n+        match visibility.node {\n+            VisibilityKind::Inherited => {}\n             _ => {\n                 return Err(self.span_fatal(self.prev_span, \"unmatched visibility `pub`\"));\n             }"}, {"sha": "34499839fb03126b6a7f2a0a412f53eb516df962", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -377,7 +377,7 @@ pub fn fun_to_string(decl: &ast::FnDecl,\n     to_string(|s| {\n         s.head(\"\")?;\n         s.print_fn(decl, unsafety, constness, Abi::Rust, Some(name),\n-                   generics, &ast::Visibility::Inherited)?;\n+                   generics, &codemap::dummy_spanned(ast::VisibilityKind::Inherited))?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -1458,21 +1458,21 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_visibility(&mut self, vis: &ast::Visibility) -> io::Result<()> {\n-        match *vis {\n-            ast::Visibility::Public => self.word_nbsp(\"pub\"),\n-            ast::Visibility::Crate(_, sugar) => match sugar {\n+        match vis.node {\n+            ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n+            ast::VisibilityKind::Crate(sugar) => match sugar {\n                 ast::CrateSugar::PubCrate => self.word_nbsp(\"pub(crate)\"),\n                 ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\")\n             }\n-            ast::Visibility::Restricted { ref path, .. } => {\n+            ast::VisibilityKind::Restricted { ref path, .. } => {\n                 let path = to_string(|s| s.print_path(path, false, 0, true));\n                 if path == \"self\" || path == \"super\" {\n                     self.word_nbsp(&format!(\"pub({})\", path))\n                 } else {\n                     self.word_nbsp(&format!(\"pub(in {})\", path))\n                 }\n             }\n-            ast::Visibility::Inherited => Ok(())\n+            ast::VisibilityKind::Inherited => Ok(())\n         }\n     }\n \n@@ -1569,15 +1569,23 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&ti.attrs)?;\n         match ti.node {\n             ast::TraitItemKind::Const(ref ty, ref default) => {\n-                self.print_associated_const(ti.ident, ty,\n-                                            default.as_ref().map(|expr| &**expr),\n-                                            &ast::Visibility::Inherited)?;\n+                self.print_associated_const(\n+                    ti.ident,\n+                    ty,\n+                    default.as_ref().map(|expr| &**expr),\n+                    &codemap::dummy_spanned(ast::VisibilityKind::Inherited),\n+                )?;\n             }\n             ast::TraitItemKind::Method(ref sig, ref body) => {\n                 if body.is_some() {\n                     self.head(\"\")?;\n                 }\n-                self.print_method_sig(ti.ident, &ti.generics, sig, &ast::Visibility::Inherited)?;\n+                self.print_method_sig(\n+                    ti.ident,\n+                    &ti.generics,\n+                    sig,\n+                    &codemap::dummy_spanned(ast::VisibilityKind::Inherited),\n+                )?;\n                 if let Some(ref body) = *body {\n                     self.nbsp()?;\n                     self.print_block_with_attrs(body, &ti.attrs)?;\n@@ -3055,7 +3063,7 @@ impl<'a> State<'a> {\n                       abi,\n                       name,\n                       &generics,\n-                      &ast::Visibility::Inherited)?;\n+                      &codemap::dummy_spanned(ast::VisibilityKind::Inherited))?;\n         self.end()\n     }\n "}, {"sha": "ab42cfeb66bae454a44baefd693a40e09326a825", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -14,7 +14,7 @@ use std::cell::Cell;\n use ext::hygiene::{Mark, SyntaxContext};\n use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n-use codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n+use codemap::{ExpnInfo, NameAndSpan, MacroAttribute, dummy_spanned};\n use ptr::P;\n use tokenstream::TokenStream;\n \n@@ -60,7 +60,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n         attrs: vec![attr::mk_attr_outer(DUMMY_SP,\n                                         attr::mk_attr_id(),\n                                         attr::mk_word_item(Symbol::intern(\"macro_use\")))],\n-        vis: ast::Visibility::Inherited,\n+        vis: dummy_spanned(ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::ExternCrate(Some(crate_name)),\n         ident: ast::Ident::from_str(name),\n         id: ast::DUMMY_NODE_ID,\n@@ -78,7 +78,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n             is_sugared_doc: false,\n             span,\n         }],\n-        vis: ast::Visibility::Inherited,\n+        vis: dummy_spanned(ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n                 segments: [\"{{root}}\", name, \"prelude\", \"v1\"].into_iter().map(|name| {"}, {"sha": "7b119c576db5821e33e7d42642bda77e29c09944", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -233,11 +233,11 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n     let super_ = Ident::from_str(\"super\");\n \n     let items = tests.into_iter().map(|r| {\n-        cx.ext_cx.item_use_simple(DUMMY_SP, ast::Visibility::Public,\n+        cx.ext_cx.item_use_simple(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),\n                                   cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n     }).chain(tested_submods.into_iter().map(|(r, sym)| {\n         let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n-        cx.ext_cx.item_use_simple_(DUMMY_SP, ast::Visibility::Public, r, path)\n+        cx.ext_cx.item_use_simple_(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public), r, path)\n     })).collect();\n \n     let reexport_mod = ast::Mod {\n@@ -253,7 +253,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ItemKind::Mod(reexport_mod),\n-        vis: ast::Visibility::Public,\n+        vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: DUMMY_SP,\n         tokens: None,\n     })).pop().unwrap();\n@@ -462,16 +462,16 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n             prefix: path_node(vec![id_test]),\n             kind: ast::UseTreeKind::Simple(id_test),\n         })),\n-         ast::Visibility::Public, keywords::Invalid.ident())\n+         ast::VisibilityKind::Public, keywords::Invalid.ident())\n     } else {\n-        (ast::ItemKind::ExternCrate(None), ast::Visibility::Inherited, id_test)\n+        (ast::ItemKind::ExternCrate(None), ast::VisibilityKind::Inherited, id_test)\n     };\n     P(ast::Item {\n         id: ast::DUMMY_NODE_ID,\n         ident,\n         node: vi,\n         attrs: vec![],\n-        vis,\n+        vis: dummy_spanned(vis),\n         span: sp,\n         tokens: None,\n     })\n@@ -513,7 +513,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n-        vis: ast::Visibility::Public,\n+        vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: sp,\n         tokens: None,\n     })\n@@ -543,7 +543,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         ident: mod_ident,\n         attrs: vec![],\n         node: item_,\n-        vis: ast::Visibility::Public,\n+        vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: DUMMY_SP,\n         tokens: None,\n     })).pop().unwrap();\n@@ -562,7 +562,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n             ident: keywords::Invalid.ident(),\n             attrs: vec![],\n             node: ast::ItemKind::Use(P(use_path)),\n-            vis: ast::Visibility::Inherited,\n+            vis: dummy_spanned(ast::VisibilityKind::Inherited),\n             span: DUMMY_SP,\n             tokens: None,\n         })).pop().unwrap()"}, {"sha": "4691ddafa36e8480f2463ad81caffe85245bf214", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -811,7 +811,7 @@ pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n }\n \n pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n-    if let Visibility::Restricted { ref path, id, .. } = *vis {\n+    if let VisibilityKind::Restricted { ref path, id } = vis.node {\n         visitor.visit_path(path, id);\n     }\n }"}, {"sha": "6ba633eb87bc9ebdc26e1f6765b326a3612713a6", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -530,7 +530,7 @@ impl<'a> TraitDef<'a> {\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.span,\n                 ident,\n-                vis: ast::Visibility::Inherited,\n+                vis: dummy_spanned(ast::VisibilityKind::Inherited),\n                 defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n                 generics: Generics::default(),\n@@ -977,7 +977,7 @@ impl<'a> MethodDef<'a> {\n             attrs: self.attributes.clone(),\n             generics: fn_generics,\n             span: trait_.span,\n-            vis: ast::Visibility::Inherited,\n+            vis: dummy_spanned(ast::VisibilityKind::Inherited),\n             defaultness: ast::Defaultness::Final,\n             ident: method_ident,\n             node: ast::ImplItemKind::Method(ast::MethodSig {"}, {"sha": "dd882d7abdf91aec61e3dc94fd366455a29767be", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -19,6 +19,7 @@\n /// therefore apply.\n \n use syntax::ast;\n+use syntax::codemap::dummy_spanned;\n use syntax::ext::base;\n use syntax::ext::base::*;\n use syntax::feature_gate;\n@@ -59,7 +60,7 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt,\n             asm,\n             ctxt: cx.backtrace(),\n         })),\n-        vis: ast::Visibility::Inherited,\n+        vis: dummy_spanned(ast::VisibilityKind::Inherited),\n         span: sp,\n         tokens: None,\n     })))"}, {"sha": "e623779ce63ba732eade30cca564e192939fd63c", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bdf296a42caec8711adc075782e0b8c920aa1f/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=d6bdf296a42caec8711adc075782e0b8c920aa1f", "patch": "@@ -14,7 +14,7 @@ use errors;\n \n use syntax::ast::{self, Ident, NodeId};\n use syntax::attr;\n-use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n+use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute, respan};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n@@ -103,7 +103,7 @@ impl<'a> CollectProcMacros<'a> {\n     fn check_not_pub_in_root(&self, vis: &ast::Visibility, sp: Span) {\n         if self.is_proc_macro_crate &&\n            self.in_root &&\n-           *vis == ast::Visibility::Public {\n+           vis.node == ast::VisibilityKind::Public {\n             self.handler.span_err(sp,\n                                   \"`proc-macro` crate types cannot \\\n                                    export any items other than functions \\\n@@ -181,7 +181,7 @@ impl<'a> CollectProcMacros<'a> {\n             Vec::new()\n         };\n \n-        if self.in_root && item.vis == ast::Visibility::Public {\n+        if self.in_root && item.vis.node == ast::VisibilityKind::Public {\n             self.derives.push(ProcMacroDerive {\n                 span: item.span,\n                 trait_name,\n@@ -206,7 +206,7 @@ impl<'a> CollectProcMacros<'a> {\n             return;\n         }\n \n-        if self.in_root && item.vis == ast::Visibility::Public {\n+        if self.in_root && item.vis.node == ast::VisibilityKind::Public {\n             self.attr_macros.push(ProcMacroDef {\n                 span: item.span,\n                 function_name: item.ident,\n@@ -229,7 +229,7 @@ impl<'a> CollectProcMacros<'a> {\n             return;\n         }\n \n-        if self.in_root && item.vis == ast::Visibility::Public {\n+        if self.in_root && item.vis.node == ast::VisibilityKind::Public {\n             self.bang_macros.push(ProcMacroDef {\n                 span: item.span,\n                 function_name: item.ident,\n@@ -439,12 +439,12 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let derive_registrar = cx.attribute(span, derive_registrar);\n     let func = func.map(|mut i| {\n         i.attrs.push(derive_registrar);\n-        i.vis = ast::Visibility::Public;\n+        i.vis = respan(span, ast::VisibilityKind::Public);\n         i\n     });\n     let ident = ast::Ident::with_empty_ctxt(Symbol::gensym(\"registrar\"));\n     let module = cx.item_mod(span, span, ident, Vec::new(), vec![krate, func]).map(|mut i| {\n-        i.vis = ast::Visibility::Public;\n+        i.vis = respan(span, ast::VisibilityKind::Public);\n         i\n     });\n "}]}