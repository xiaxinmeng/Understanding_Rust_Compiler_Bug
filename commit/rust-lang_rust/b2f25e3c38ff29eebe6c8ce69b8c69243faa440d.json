{"sha": "b2f25e3c38ff29eebe6c8ce69b8c69243faa440d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZjI1ZTNjMzhmZjI5ZWViZTZjOGNlNjliOGM2OTI0M2ZhYTQ0MGQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-21T10:42:49Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-21T10:54:10Z"}, "message": "Compress `Liveness` data some more.\n\nProfiling shows that the `(reader, writer, used)` triples used by\nliveness analysis almost always have invalid `reader` and `writer`\nfields. We can take advantage of this knowledge to use a compressed\nrepresentation for them, falling back to a secondary table for the\nuncommon cases.\n\nThis change reduces instruction counts on numerous benchmarks, the best\nby 16%. It also reduces max-rss on numerous benchmarks, the best by 38%.\n\nThe patch also renames these triples from `Users` to `RWU`, because it's\nconfusing having a type whose name is plural and then used within\nvectors whose names are also plural.", "tree": {"sha": "1f6257400c9be4e0b27a82bf9632ded55b22752d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f6257400c9be4e0b27a82bf9632ded55b22752d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2f25e3c38ff29eebe6c8ce69b8c69243faa440d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f25e3c38ff29eebe6c8ce69b8c69243faa440d", "html_url": "https://github.com/rust-lang/rust/commit/b2f25e3c38ff29eebe6c8ce69b8c69243faa440d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2f25e3c38ff29eebe6c8ce69b8c69243faa440d/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d33aedaa928cc92d58c0bfe7ff433714ff52976", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d33aedaa928cc92d58c0bfe7ff433714ff52976", "html_url": "https://github.com/rust-lang/rust/commit/1d33aedaa928cc92d58c0bfe7ff433714ff52976"}], "stats": {"total": 207, "additions": 149, "deletions": 58}, "files": [{"sha": "0d70a64123bf364903fa7e328d4133d3872881aa", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 149, "deletions": 58, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/b2f25e3c38ff29eebe6c8ce69b8c69243faa440d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f25e3c38ff29eebe6c8ce69b8c69243faa440d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b2f25e3c38ff29eebe6c8ce69b8c69243faa440d", "patch": "@@ -64,10 +64,10 @@\n //! methods.  It effectively does a reverse walk of the AST; whenever we\n //! reach a loop node, we iterate until a fixed point is reached.\n //!\n-//! ## The `users_*` fields\n+//! ## The `RWU` struct\n //!\n //! At each live node `N`, we track three pieces of information for each\n-//! variable `V` (these are in the `users_*` fields):\n+//! variable `V` (these are encapsulated in the `RWU` struct):\n //!\n //! - `reader`: the `LiveNode` ID of some node which will read the value\n //!    that `V` holds on entry to `N`.  Formally: a node `M` such\n@@ -536,6 +536,112 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n // Actually we compute just a bit more than just liveness, but we use\n // the same basic propagation framework in all cases.\n \n+#[derive(Clone, Copy)]\n+struct RWU {\n+    reader: LiveNode,\n+    writer: LiveNode,\n+    used: bool\n+}\n+\n+/// Conceptually, this is like a `Vec<RWU>`. But the number of `RWU`s can get\n+/// very large, so it uses a more compact representation that takes advantage\n+/// of the fact that when the number of `RWU`s is large, most of them have an\n+/// invalid reader and an invalid writer.\n+struct RWUTable {\n+    /// Each entry in `packed_rwus` is either INV_INV_FALSE, INV_INV_TRUE, or\n+    /// an index into `unpacked_rwus`. In the common cases, this compacts the\n+    /// 65 bits of data into 32; in the uncommon cases, it expands the 65 bits\n+    /// in 96.\n+    ///\n+    /// More compact representations are possible -- e.g. use only 2 bits per\n+    /// packed `RWU` and make the secondary table a HashMap that maps from\n+    /// indices to `RWU`s -- but this one strikes a good balance between size\n+    /// and speed.\n+    packed_rwus: Vec<u32>,\n+    unpacked_rwus: Vec<RWU>,\n+}\n+\n+// A constant representing `RWU { reader: invalid_node(); writer: invalid_node(); used: false }`.\n+const INV_INV_FALSE: u32 = u32::MAX;\n+\n+// A constant representing `RWU { reader: invalid_node(); writer: invalid_node(); used: true }`.\n+const INV_INV_TRUE: u32 = u32::MAX - 1;\n+\n+impl RWUTable {\n+    fn new(num_rwus: usize) -> RWUTable {\n+        Self {\n+            packed_rwus: vec![INV_INV_FALSE; num_rwus],\n+            unpacked_rwus: vec![],\n+        }\n+    }\n+\n+    fn get(&self, idx: usize) -> RWU {\n+        let packed_rwu = self.packed_rwus[idx];\n+        match packed_rwu {\n+            INV_INV_FALSE => RWU { reader: invalid_node(), writer: invalid_node(), used: false },\n+            INV_INV_TRUE => RWU { reader: invalid_node(), writer: invalid_node(), used: true },\n+            _ => self.unpacked_rwus[packed_rwu as usize],\n+        }\n+    }\n+\n+    fn get_reader(&self, idx: usize) -> LiveNode {\n+        let packed_rwu = self.packed_rwus[idx];\n+        match packed_rwu {\n+            INV_INV_FALSE | INV_INV_TRUE => invalid_node(),\n+            _ => self.unpacked_rwus[packed_rwu as usize].reader,\n+        }\n+    }\n+\n+    fn get_writer(&self, idx: usize) -> LiveNode {\n+        let packed_rwu = self.packed_rwus[idx];\n+        match packed_rwu {\n+            INV_INV_FALSE | INV_INV_TRUE => invalid_node(),\n+            _ => self.unpacked_rwus[packed_rwu as usize].writer,\n+        }\n+    }\n+\n+    fn get_used(&self, idx: usize) -> bool {\n+        let packed_rwu = self.packed_rwus[idx];\n+        match packed_rwu {\n+            INV_INV_FALSE => false,\n+            INV_INV_TRUE => true,\n+            _ => self.unpacked_rwus[packed_rwu as usize].used,\n+        }\n+    }\n+\n+    #[inline]\n+    fn copy_packed(&mut self, dst_idx: usize, src_idx: usize) {\n+        self.packed_rwus[dst_idx] = self.packed_rwus[src_idx];\n+    }\n+\n+    fn assign_unpacked(&mut self, idx: usize, rwu: RWU) {\n+        if rwu.reader == invalid_node() && rwu.writer == invalid_node() {\n+            // When we overwrite an indexing entry in `self.packed_rwus` with\n+            // `INV_INV_{TRUE,FALSE}` we don't remove the corresponding entry\n+            // from `self.unpacked_rwus`; it's not worth the effort, and we\n+            // can't have entries shifting around anyway.\n+            self.packed_rwus[idx] = if rwu.used {\n+                INV_INV_TRUE\n+            } else {\n+                INV_INV_FALSE\n+            }\n+        } else {\n+            // Add a new RWU to `unpacked_rwus` and make `packed_rwus[idx]`\n+            // point to it.\n+            self.packed_rwus[idx] = self.unpacked_rwus.len() as u32;\n+            self.unpacked_rwus.push(rwu);\n+        }\n+    }\n+\n+    fn assign_inv_inv(&mut self, idx: usize) {\n+        self.packed_rwus[idx] = if self.get_used(idx) {\n+            INV_INV_TRUE\n+        } else {\n+            INV_INV_FALSE\n+        };\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n struct Specials {\n     exit_ln: LiveNode,\n@@ -552,14 +658,7 @@ struct Liveness<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n-\n-    // We used to have a single `users: Vec<Users>` field here, where `Users`\n-    // had `reader`, `writer` and `used` fields. But the number of users can\n-    // get very large, and it's more compact to store the data in three\n-    // separate `Vec`s so that no space is wasted for padding.\n-    users_reader: Vec<LiveNode>,\n-    users_writer: Vec<LiveNode>,\n-    users_used: Vec<bool>,\n+    rwu_table: RWUTable,\n \n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n@@ -584,16 +683,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let num_live_nodes = ir.num_live_nodes;\n         let num_vars = ir.num_vars;\n-        let num_users = num_live_nodes * num_vars;\n \n         Liveness {\n             ir,\n             tables,\n             s: specials,\n             successors: vec![invalid_node(); num_live_nodes],\n-            users_reader: vec![invalid_node(); num_users],\n-            users_writer: vec![invalid_node(); num_users],\n-            users_used: vec![false; num_users],\n+            rwu_table: RWUTable::new(num_live_nodes * num_vars),\n             break_ln: NodeMap(),\n             cont_ln: NodeMap(),\n         }\n@@ -657,16 +753,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         ln.get() * self.ir.num_vars + var.get()\n     }\n \n-    fn live_on_entry(&self, ln: LiveNode, var: Variable)\n-                      -> Option<LiveNodeKind> {\n+    fn live_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let reader = self.users_reader[self.idx(ln, var)];\n-        if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n+        let reader = self.rwu_table.get_reader(self.idx(ln, var));\n+        if reader.is_valid() { Some(self.ir.lnk(reader)) } else { None }\n     }\n \n-    /*\n-    Is this variable live on entry to any of its successor nodes?\n-    */\n+    // Is this variable live on entry to any of its successor nodes?\n     fn live_on_exit(&self, ln: LiveNode, var: Variable)\n                     -> Option<LiveNodeKind> {\n         let successor = self.successors[ln.get()];\n@@ -675,14 +768,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert!(ln.is_valid());\n-        self.users_used[self.idx(ln, var)]\n+        self.rwu_table.get_used(self.idx(ln, var))\n     }\n \n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n                          -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let writer = self.users_writer[self.idx(ln, var)];\n-        if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n+        let writer = self.rwu_table.get_writer(self.idx(ln, var));\n+        if writer.is_valid() { Some(self.ir.lnk(writer)) } else { None }\n     }\n \n     fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n@@ -725,9 +818,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         {\n             let wr = &mut wr as &mut dyn Write;\n             write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n-            self.write_vars(wr, ln, |idx| self.users_reader[idx]);\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx));\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.users_writer[idx]);\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx));\n             write!(wr, \"  precedes {:?}]\", self.successors[ln.get()]);\n         }\n         String::from_utf8(wr).unwrap()\n@@ -736,26 +829,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         self.successors[ln.get()] = succ_ln;\n \n-        // It is not necessary to initialize the\n-        // values to empty because this is the value\n-        // they have when they are created, and the sets\n-        // only grow during iterations.\n-        //\n-        // self.indices(ln) { |idx|\n-        //     self.users_reader[idx] = invalid_node();\n-        //     self.users_writer[idx] = invalid_node();\n-        //     self.users_used[idx] = false;\n-        // }\n+        // It is not necessary to initialize the RWUs here because they are all\n+        // set to INV_INV_FALSE when they are created, and the sets only grow\n+        // during iterations.\n     }\n \n     fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n         self.successors[ln.get()] = succ_ln;\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            this.users_reader[idx] = this.users_reader[succ_idx];\n-            this.users_writer[idx] = this.users_writer[succ_idx];\n-            this.users_used[idx] = this.users_used[succ_idx];\n+            this.rwu_table.copy_packed(idx, succ_idx);\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n@@ -770,35 +854,39 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let mut changed = false;\n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            changed |= copy_if_invalid(this.users_reader[succ_idx], &mut this.users_reader[idx]);\n-            changed |= copy_if_invalid(this.users_writer[succ_idx], &mut this.users_writer[idx]);\n-            if this.users_used[succ_idx] && !this.users_used[idx] {\n-                this.users_used[idx] = true;\n+            let mut rwu = this.rwu_table.get(idx);\n+            let succ_rwu = this.rwu_table.get(succ_idx);\n+            if succ_rwu.reader.is_valid() && !rwu.reader.is_valid() {\n+                rwu.reader = succ_rwu.reader;\n+                changed = true\n+            }\n+\n+            if succ_rwu.writer.is_valid() && !rwu.writer.is_valid() {\n+                rwu.writer = succ_rwu.writer;\n+                changed = true\n+            }\n+\n+            if succ_rwu.used && !rwu.used {\n+                rwu.used = true;\n                 changed = true;\n             }\n+\n+            if changed {\n+                this.rwu_table.assign_unpacked(idx, rwu);\n+            }\n         });\n \n         debug!(\"merge_from_succ(ln={:?}, succ={}, first_merge={}, changed={})\",\n                ln, self.ln_str(succ_ln), first_merge, changed);\n         return changed;\n-\n-        fn copy_if_invalid(src: LiveNode, dst: &mut LiveNode) -> bool {\n-            if src.is_valid() && !dst.is_valid() {\n-                *dst = src;\n-                true\n-            } else {\n-                false\n-            }\n-        }\n     }\n \n     // Indicates that a local variable was *defined*; we know that no\n     // uses of the variable can precede the definition (resolve checks\n     // this) so we just clear out all the data.\n     fn define(&mut self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n-        self.users_reader[idx] = invalid_node();\n-        self.users_writer[idx] = invalid_node();\n+        self.rwu_table.assign_inv_inv(idx);\n \n         debug!(\"{:?} defines {:?} (idx={}): {}\", writer, var,\n                idx, self.ln_str(writer));\n@@ -810,21 +898,24 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                ln, acc, var, self.ln_str(ln));\n \n         let idx = self.idx(ln, var);\n+        let mut rwu = self.rwu_table.get(idx);\n \n         if (acc & ACC_WRITE) != 0 {\n-            self.users_reader[idx] = invalid_node();\n-            self.users_writer[idx] = ln;\n+            rwu.reader = invalid_node();\n+            rwu.writer = ln;\n         }\n \n         // Important: if we both read/write, must do read second\n         // or else the write will override.\n         if (acc & ACC_READ) != 0 {\n-            self.users_reader[idx] = ln;\n+            rwu.reader = ln;\n         }\n \n         if (acc & ACC_USE) != 0 {\n-            self.users_used[idx] = true;\n+            rwu.used = true;\n         }\n+\n+        self.rwu_table.assign_unpacked(idx, rwu);\n     }\n \n     // _______________________________________________________________________"}]}