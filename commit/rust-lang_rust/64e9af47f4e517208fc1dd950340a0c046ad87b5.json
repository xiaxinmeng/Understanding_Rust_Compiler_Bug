{"sha": "64e9af47f4e517208fc1dd950340a0c046ad87b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZTlhZjQ3ZjRlNTE3MjA4ZmMxZGQ5NTAzNDBhMGMwNDZhZDg3YjU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-11T10:58:19Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-24T21:05:52Z"}, "message": "Allow declarative macros 2.0 and `use` macro imports to shadow builtin macros.", "tree": {"sha": "558061f649bb1c9a654cc081b39186df6a829352", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/558061f649bb1c9a654cc081b39186df6a829352"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64e9af47f4e517208fc1dd950340a0c046ad87b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64e9af47f4e517208fc1dd950340a0c046ad87b5", "html_url": "https://github.com/rust-lang/rust/commit/64e9af47f4e517208fc1dd950340a0c046ad87b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64e9af47f4e517208fc1dd950340a0c046ad87b5/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2036c7be4e783f459d1f9a712c5a7b3ef6679bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2036c7be4e783f459d1f9a712c5a7b3ef6679bd", "html_url": "https://github.com/rust-lang/rust/commit/f2036c7be4e783f459d1f9a712c5a7b3ef6679bd"}], "stats": {"total": 222, "additions": 163, "deletions": 59}, "files": [{"sha": "be8513c94d03de0193695e80c1c1e921e9249cfa", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/64e9af47f4e517208fc1dd950340a0c046ad87b5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64e9af47f4e517208fc1dd950340a0c046ad87b5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=64e9af47f4e517208fc1dd950340a0c046ad87b5", "patch": "@@ -75,7 +75,7 @@ use std::mem::replace;\n use std::rc::Rc;\n \n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding, LegacyScope};\n+use macros::{InvocationData, LegacyBinding, LegacyScope, MacroBinding};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -2566,6 +2566,7 @@ impl<'a> Resolver<'a> {\n                 self.resolve_ident_in_module(module, ident, ns, false, record_used)\n             } else if opt_ns == Some(MacroNS) {\n                 self.resolve_lexical_macro_path_segment(ident, ns, record_used)\n+                    .map(MacroBinding::binding)\n             } else {\n                 match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n@@ -3223,7 +3224,7 @@ impl<'a> Resolver<'a> {\n             };\n             let msg1 = format!(\"`{}` could refer to the name {} here\", name, participle(b1));\n             let msg2 = format!(\"`{}` could also refer to the name {} here\", name, participle(b2));\n-            let note = if !lexical && b1.is_glob_import() {\n+            let note = if b1.expansion == Mark::root() || !lexical && b1.is_glob_import() {\n                 format!(\"consider adding an explicit import of `{}` to disambiguate\", name)\n             } else if let Def::Macro(..) = b1.def() {\n                 format!(\"macro-expanded {} do not shadow\",\n@@ -3243,11 +3244,15 @@ impl<'a> Resolver<'a> {\n                 let msg = format!(\"`{}` is ambiguous\", name);\n                 self.session.add_lint(lint::builtin::LEGACY_IMPORTS, id, span, msg);\n             } else {\n-                self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n-                    .span_note(b1.span, &msg1)\n-                    .span_note(b2.span, &msg2)\n-                    .note(&note)\n-                    .emit();\n+                let mut err =\n+                    self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name));\n+                err.span_note(b1.span, &msg1);\n+                match b2.def() {\n+                    Def::Macro(..) if b2.span == DUMMY_SP =>\n+                        err.note(&format!(\"`{}` is also a builtin macro\", name)),\n+                    _ => err.span_note(b2.span, &msg2),\n+                };\n+                err.note(&note).emit();\n             }\n         }\n \n@@ -3361,22 +3366,21 @@ impl<'a> Resolver<'a> {\n         if self.proc_macro_enabled { return; }\n \n         for attr in attrs {\n-            let name = unwrap_or!(attr.name(), continue);\n-            let maybe_binding = self.builtin_macros.get(&name).cloned().or_else(|| {\n-                let ident = Ident::with_empty_ctxt(name);\n-                self.resolve_lexical_macro_path_segment(ident, MacroNS, None).ok()\n-            });\n-\n-            if let Some(binding) = maybe_binding {\n-                if let SyntaxExtension::AttrProcMacro(..) = *binding.get_macro(self) {\n+            if attr.path.segments.len() > 1 {\n+                continue\n+            }\n+            let ident = attr.path.segments[0].identifier;\n+            let result = self.resolve_lexical_macro_path_segment(ident, MacroNS, None);\n+            if let Ok(binding) = result {\n+                if let SyntaxExtension::AttrProcMacro(..) = *binding.binding().get_macro(self) {\n                     attr::mark_known(attr);\n \n                     let msg = \"attribute procedural macros are experimental\";\n                     let feature = \"proc_macro\";\n \n                     feature_err(&self.session.parse_sess, feature,\n                                 attr.span, GateIssue::Language, msg)\n-                        .span_note(binding.span, \"procedural macro imported here\")\n+                        .span_note(binding.span(), \"procedural macro imported here\")\n                         .emit();\n                 }\n             }"}, {"sha": "9af921a84459e37a3566261d598d89036181db8c", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 64, "deletions": 38, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/64e9af47f4e517208fc1dd950340a0c046ad87b5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64e9af47f4e517208fc1dd950340a0c046ad87b5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=64e9af47f4e517208fc1dd950340a0c046ad87b5", "patch": "@@ -81,11 +81,29 @@ pub struct LegacyBinding<'a> {\n     pub span: Span,\n }\n \n+#[derive(Copy, Clone)]\n pub enum MacroBinding<'a> {\n     Legacy(&'a LegacyBinding<'a>),\n+    Builtin(&'a NameBinding<'a>),\n     Modern(&'a NameBinding<'a>),\n }\n \n+impl<'a> MacroBinding<'a> {\n+    pub fn span(self) -> Span {\n+        match self {\n+            MacroBinding::Legacy(binding) => binding.span,\n+            MacroBinding::Builtin(binding) | MacroBinding::Modern(binding) => binding.span,\n+        }\n+    }\n+\n+    pub fn binding(self) -> &'a NameBinding<'a> {\n+        match self {\n+            MacroBinding::Builtin(binding) | MacroBinding::Modern(binding) => binding,\n+            MacroBinding::Legacy(_) => panic!(\"unexpected MacroBinding::Legacy\"),\n+        }\n+    }\n+}\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -378,18 +396,18 @@ impl<'a> Resolver<'a> {\n         }\n \n         let name = path[0].name;\n-        let result = match self.resolve_legacy_scope(&invocation.legacy_scope, name, false) {\n-            Some(MacroBinding::Legacy(binding)) => Ok(Def::Macro(binding.def_id, MacroKind::Bang)),\n-            Some(MacroBinding::Modern(binding)) => Ok(binding.def_ignoring_ambiguity()),\n-            None => match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n-                Ok(binding) => Ok(binding.def_ignoring_ambiguity()),\n-                Err(Determinacy::Undetermined) if !force =>\n-                    return Err(Determinacy::Undetermined),\n+        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, name, false);\n+        let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n+            Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n+        } else {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n+                Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n+                Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 Err(_) => {\n                     self.found_unresolved_macro = true;\n                     Err(Determinacy::Determined)\n                 }\n-            },\n+            }\n         };\n \n         self.current_module.legacy_macro_resolutions.borrow_mut()\n@@ -403,42 +421,56 @@ impl<'a> Resolver<'a> {\n                                               ident: Ident,\n                                               ns: Namespace,\n                                               record_used: Option<Span>)\n-                                              -> Result<&'a NameBinding<'a>, Determinacy> {\n-        let mut module = self.current_module;\n-        let mut potential_expanded_shadower: Option<&NameBinding> = None;\n+                                              -> Result<MacroBinding<'a>, Determinacy> {\n+        let mut module = Some(self.current_module);\n+        let mut potential_illegal_shadower = Err(Determinacy::Determined);\n+        let determinacy =\n+            if record_used.is_some() { Determinacy::Determined } else { Determinacy::Undetermined };\n         loop {\n-            // Since expanded macros may not shadow the lexical scope (enforced below),\n-            // we can ignore unresolved invocations (indicated by the penultimate argument).\n-            match self.resolve_ident_in_module(module, ident, ns, true, record_used) {\n+            let result = if let Some(module) = module {\n+                // Since expanded macros may not shadow the lexical scope and\n+                // globs may not shadow builtin macros (both enforced below),\n+                // we resolve with restricted shadowing (indicated by the penultimate argument).\n+                self.resolve_ident_in_module(module, ident, ns, true, record_used)\n+                    .map(MacroBinding::Modern)\n+            } else {\n+                self.builtin_macros.get(&ident.name).cloned().ok_or(determinacy)\n+                    .map(MacroBinding::Builtin)\n+            };\n+\n+            match result.map(MacroBinding::binding) {\n                 Ok(binding) => {\n                     let span = match record_used {\n                         Some(span) => span,\n-                        None => return Ok(binding),\n+                        None => return result,\n                     };\n-                    match potential_expanded_shadower {\n-                        Some(shadower) if shadower.def() != binding.def() => {\n+                    if let Ok(MacroBinding::Modern(shadower)) = potential_illegal_shadower {\n+                        if shadower.def() != binding.def() {\n                             let name = ident.name;\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 span: span, name: name, b1: shadower, b2: binding, lexical: true,\n                                 legacy: false,\n                             });\n-                            return Ok(shadower);\n+                            return potential_illegal_shadower;\n                         }\n-                        _ if binding.expansion == Mark::root() => return Ok(binding),\n-                        _ => potential_expanded_shadower = Some(binding),\n+                    }\n+                    if binding.expansion != Mark::root() ||\n+                       (binding.is_glob_import() && module.unwrap().def().is_some()) {\n+                        potential_illegal_shadower = result;\n+                    } else {\n+                        return result;\n                     }\n                 },\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n                 Err(Determinacy::Determined) => {}\n             }\n \n-            match module.kind {\n-                ModuleKind::Block(..) => module = module.parent.unwrap(),\n-                ModuleKind::Def(..) => return match potential_expanded_shadower {\n-                    Some(binding) => Ok(binding),\n-                    None if record_used.is_some() => Err(Determinacy::Determined),\n-                    None => Err(Determinacy::Undetermined),\n+            module = match module {\n+                Some(module) => match module.kind {\n+                    ModuleKind::Block(..) => module.parent,\n+                    ModuleKind::Def(..) => None,\n                 },\n+                None => return potential_illegal_shadower,\n             }\n         }\n     }\n@@ -492,7 +524,7 @@ impl<'a> Resolver<'a> {\n             if !self.use_extern_macros {\n                 self.record_use(Ident::with_empty_ctxt(name), MacroNS, binding, DUMMY_SP);\n             }\n-            MacroBinding::Modern(binding)\n+            MacroBinding::Builtin(binding)\n         } else {\n             return None;\n         };\n@@ -524,21 +556,15 @@ impl<'a> Resolver<'a> {\n             let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n             let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n             match (legacy_resolution, resolution) {\n-                (Some(legacy_resolution), Ok(resolution)) => {\n-                    let (legacy_span, participle) = match legacy_resolution {\n-                        MacroBinding::Modern(binding)\n-                            if binding.def() == resolution.def() => continue,\n-                        MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n-                        MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n-                    };\n-                    let msg1 = format!(\"`{}` could refer to the macro {} here\", ident, participle);\n+                (Some(MacroBinding::Legacy(legacy_binding)), Ok(MacroBinding::Modern(binding))) => {\n+                    let msg1 = format!(\"`{}` could refer to the macro defined here\", ident);\n                     let msg2 = format!(\"`{}` could also refer to the macro imported here\", ident);\n                     self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n-                        .span_note(legacy_span, &msg1)\n-                        .span_note(resolution.span, &msg2)\n+                        .span_note(legacy_binding.span, &msg1)\n+                        .span_note(binding.span, &msg2)\n                         .emit();\n                 },\n-                (Some(MacroBinding::Modern(binding)), Err(_)) => {\n+                (Some(MacroBinding::Builtin(binding)), Ok(MacroBinding::Builtin(_))) => {\n                     self.record_use(ident, MacroNS, binding, span);\n                     self.err_if_macro_use_proc_macro(ident.name, span, binding);\n                 },"}, {"sha": "43654c8ce6f6875b13aa5009fabec257024ae784", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/64e9af47f4e517208fc1dd950340a0c046ad87b5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64e9af47f4e517208fc1dd950340a0c046ad87b5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=64e9af47f4e517208fc1dd950340a0c046ad87b5", "patch": "@@ -145,7 +145,7 @@ impl<'a> Resolver<'a> {\n                                    module: Module<'a>,\n                                    ident: Ident,\n                                    ns: Namespace,\n-                                   ignore_unresolved_invocations: bool,\n+                                   restricted_shadowing: bool,\n                                    record_used: Option<Span>)\n                                    -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.populate_module_if_necessary(module);\n@@ -158,9 +158,8 @@ impl<'a> Resolver<'a> {\n             if let Some(binding) = resolution.binding {\n                 if let Some(shadowed_glob) = resolution.shadows_glob {\n                     let name = ident.name;\n-                    // If we ignore unresolved invocations, we must forbid\n-                    // expanded shadowing to avoid time travel.\n-                    if ignore_unresolved_invocations &&\n+                    // Forbid expanded shadowing to avoid time travel.\n+                    if restricted_shadowing &&\n                        binding.expansion != Mark::root() &&\n                        ns != MacroNS && // In MacroNS, `try_define` always forbids this shadowing\n                        binding.def() != shadowed_glob.def() {\n@@ -215,7 +214,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let no_unresolved_invocations =\n-            ignore_unresolved_invocations || module.unresolved_invocations.borrow().is_empty();\n+            restricted_shadowing || module.unresolved_invocations.borrow().is_empty();\n         match resolution.binding {\n             // In `MacroNS`, expanded bindings do not shadow (enforced in `try_define`).\n             Some(binding) if no_unresolved_invocations || ns == MacroNS =>\n@@ -225,6 +224,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Check if the globs are determined\n+        if restricted_shadowing && module.def().is_some() {\n+            return Err(Determined);\n+        }\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {"}, {"sha": "2b3ba1b4aa7a79f0e58ec079996732b04c886e64", "filename": "src/test/compile-fail/imports/shadow_builtin_macros.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/64e9af47f4e517208fc1dd950340a0c046ad87b5/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64e9af47f4e517208fc1dd950340a0c046ad87b5/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs?ref=64e9af47f4e517208fc1dd950340a0c046ad87b5", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+\n+#![feature(use_extern_macros)]\n+\n+mod foo {\n+    extern crate two_macros;\n+    pub use self::two_macros::m as panic;\n+}\n+\n+mod m1 {\n+    use foo::panic; // ok\n+    fn f() { panic!(); }\n+}\n+\n+mod m2 {\n+    use foo::*; //~ NOTE `panic` could refer to the name imported here\n+    fn f() { panic!(); } //~ ERROR ambiguous\n+    //~| NOTE `panic` is also a builtin macro\n+    //~| NOTE consider adding an explicit import of `panic` to disambiguate\n+}\n+\n+mod m3 {\n+    ::two_macros::m!(use foo::panic;); //~ NOTE `panic` could refer to the name imported here\n+    //~| NOTE in this expansion\n+    fn f() { panic!(); } //~ ERROR ambiguous\n+    //~| NOTE `panic` is also a builtin macro\n+    //~| NOTE macro-expanded macro imports do not shadow\n+}\n+\n+mod m4 {\n+    macro_rules! panic { () => {} } // ok\n+    panic!();\n+}\n+\n+mod m5 {\n+    macro_rules! m { () => {\n+        macro_rules! panic { () => {} } //~ ERROR `panic` is already in scope\n+        //~| NOTE macro-expanded `macro_rules!`s may not shadow existing macros\n+    } }\n+    m!(); //~ NOTE in this expansion\n+    //~| NOTE in this expansion\n+    panic!();\n+}\n+\n+#[macro_use(n)] //~ NOTE `n` could also refer to the name imported here\n+extern crate two_macros;\n+mod bar {\n+    pub use two_macros::m as n;\n+}\n+\n+mod m6 {\n+    use bar::n; // ok\n+    n!();\n+}\n+\n+mod m7 {\n+    use bar::*; //~ NOTE `n` could refer to the name imported here\n+    n!(); //~ ERROR ambiguous\n+    //~| NOTE consider adding an explicit import of `n` to disambiguate\n+}\n+\n+fn main() {}"}]}