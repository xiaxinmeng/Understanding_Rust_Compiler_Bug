{"sha": "f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NzdiMGVmNmU2MzdhYjdhNjA5NWNkZmUwYjUxZmEzZmFmOTcwNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-03T13:21:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-03T13:21:03Z"}, "message": "Auto merge of #66982 - Centril:rollup-yq2281i, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #66148 (Show the sign for signed ops on `exact_div`)\n - #66651 (Add `enclosing scope` parameter to `rustc_on_unimplemented`)\n - #66904 (Adding docs for keyword match, move)\n - #66935 (syntax: Unify macro and attribute arguments in AST)\n - #66941 (Remove `ord` lang item)\n - #66967 (Remove hack for top-level or-patterns in match checking)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3acfc5e36ad8991bf613d5b85e3274c816a8b970", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3acfc5e36ad8991bf613d5b85e3274c816a8b970"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "html_url": "https://github.com/rust-lang/rust/commit/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d808659cdc6c979a992fe3db345c0cfb53d973e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d808659cdc6c979a992fe3db345c0cfb53d973e", "html_url": "https://github.com/rust-lang/rust/commit/7d808659cdc6c979a992fe3db345c0cfb53d973e"}, {"sha": "bce77980a2611da10b42dbd8a672c8cd17f79a94", "url": "https://api.github.com/repos/rust-lang/rust/commits/bce77980a2611da10b42dbd8a672c8cd17f79a94", "html_url": "https://github.com/rust-lang/rust/commit/bce77980a2611da10b42dbd8a672c8cd17f79a94"}], "stats": {"total": 1647, "additions": 1096, "deletions": 551}, "files": [{"sha": "a5f355cd9a73ec333c51d2deea214324f6bade77", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -534,7 +534,6 @@ impl<T: Ord> Ord for Reverse<T> {\n ///     }\n /// }\n /// ```\n-#[lang = \"ord\"]\n #[doc(alias = \"<\")]\n #[doc(alias = \">\")]\n #[doc(alias = \"<=\")]"}, {"sha": "a748ee87ef99aa7ff915a872092522b2a7c35d33", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -5,19 +5,20 @@\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n-#[rustc_on_unimplemented(\n+#[cfg_attr(not(bootstrap), rustc_on_unimplemented(\n on(all(\n any(from_method=\"from_error\", from_method=\"from_ok\"),\n from_desugaring=\"QuestionMark\"),\n message=\"the `?` operator can only be used in {ItemContext} \\\n                that returns `Result` or `Option` \\\n                (or another type that implements `{Try}`)\",\n-label=\"cannot use the `?` operator in {ItemContext} that returns `{Self}`\"),\n+label=\"cannot use the `?` operator in {ItemContext} that returns `{Self}`\",\n+enclosing_scope=\"this function should return `Result` or `Option` to accept `?`\"),\n on(all(from_method=\"into_result\", from_desugaring=\"QuestionMark\"),\n message=\"the `?` operator can only be applied to values \\\n                that implement `{Try}`\",\n label=\"the `?` operator cannot be applied to type `{Self}`\")\n-)]\n+))]\n #[doc(alias = \"?\")]\n pub trait Try {\n     /// The type of this value when viewed as successful."}, {"sha": "e13f6cabb5296296b8d3106e73ae17b20094fb55", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -1003,7 +1003,7 @@ impl<'a> LoweringContext<'a> {\n             AttrKind::Normal(ref item) => {\n                 AttrKind::Normal(AttrItem {\n                     path: item.path.clone(),\n-                    tokens: self.lower_token_stream(item.tokens.clone()),\n+                    args: self.lower_mac_args(&item.args),\n                 })\n             }\n             AttrKind::DocComment(comment) => AttrKind::DocComment(comment)\n@@ -1017,6 +1017,16 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn lower_mac_args(&mut self, args: &MacArgs) -> MacArgs {\n+        match *args {\n+            MacArgs::Empty => MacArgs::Empty,\n+            MacArgs::Delimited(dspan, delim, ref tokens) =>\n+                MacArgs::Delimited(dspan, delim, self.lower_token_stream(tokens.clone())),\n+            MacArgs::Eq(eq_span, ref tokens) =>\n+                MacArgs::Eq(eq_span, self.lower_token_stream(tokens.clone())),\n+        }\n+    }\n+\n     fn lower_token_stream(&mut self, tokens: TokenStream) -> TokenStream {\n         tokens\n             .into_trees()"}, {"sha": "ff9d8c85df8b9dd3661df2d3092faf3bb354d3ab", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -233,7 +233,7 @@ impl LoweringContext<'_> {\n \n         if let ItemKind::MacroDef(ref def) = i.kind {\n             if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n-                let body = self.lower_token_stream(def.stream());\n+                let body = self.lower_token_stream(def.body.inner_tokens());\n                 let hir_id = self.lower_node_id(i.id);\n                 self.exported_macros.push(hir::MacroDef {\n                     name: ident.name,"}, {"sha": "6f7a022eccfb843538a55875ee37b93aca02be27", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -358,7 +358,6 @@ language_item_table! {\n     // Don't be fooled by the naming here: this lang item denotes `PartialEq`, not `Eq`.\n     EqTraitLangItem,             \"eq\",                 eq_trait,                Target::Trait;\n     PartialOrdTraitLangItem,     \"partial_ord\",        partial_ord_trait,       Target::Trait;\n-    OrdTraitLangItem,            \"ord\",                ord_trait,               Target::Trait;\n \n     // A number of panic-related lang items. The `panic` item corresponds to\n     // divide-by-zero and various panic cases with `match`. The"}, {"sha": "ba44c6c3b9a1f27cd993131bd1fb6e6a29ad6276", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -521,7 +521,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ) {\n             command.evaluate(self.tcx, trait_ref, &flags[..])\n         } else {\n-            OnUnimplementedNote::empty()\n+            OnUnimplementedNote::default()\n         }\n     }\n \n@@ -697,6 +697,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         fallback_has_occurred: bool,\n         points_at_arg: bool,\n     ) {\n+        let tcx = self.tcx;\n         let span = obligation.cause.span;\n \n         let mut err = match *error {\n@@ -732,6 +733,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             message,\n                             label,\n                             note,\n+                            enclosing_scope,\n                         } = self.on_unimplemented_note(trait_ref, obligation);\n                         let have_alt_message = message.is_some() || label.is_some();\n                         let is_try = self.tcx.sess.source_map().span_to_snippet(span)\n@@ -798,6 +800,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n                             err.note(s.as_str());\n                         }\n+                        if let Some(ref s) = enclosing_scope {\n+                            let enclosing_scope_span = tcx.def_span(\n+                                tcx.hir()\n+                                    .opt_local_def_id(obligation.cause.body_id)\n+                                    .unwrap_or_else(|| {\n+                                        tcx.hir().body_owner_def_id(hir::BodyId {\n+                                            hir_id: obligation.cause.body_id,\n+                                        })\n+                                    }),\n+                            );\n+\n+                            err.span_label(enclosing_scope_span, s.as_str());\n+                        }\n \n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n                         self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);"}, {"sha": "604f39dcf293b3503a82355461208a10251be27b", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -22,18 +22,15 @@ pub struct OnUnimplementedDirective {\n     pub message: Option<OnUnimplementedFormatString>,\n     pub label: Option<OnUnimplementedFormatString>,\n     pub note: Option<OnUnimplementedFormatString>,\n+    pub enclosing_scope: Option<OnUnimplementedFormatString>,\n }\n \n+#[derive(Default)]\n pub struct OnUnimplementedNote {\n     pub message: Option<String>,\n     pub label: Option<String>,\n     pub note: Option<String>,\n-}\n-\n-impl OnUnimplementedNote {\n-    pub fn empty() -> Self {\n-        OnUnimplementedNote { message: None, label: None, note: None }\n-    }\n+    pub enclosing_scope: Option<String>,\n }\n \n fn parse_error(\n@@ -85,24 +82,33 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut message = None;\n         let mut label = None;\n         let mut note = None;\n+        let mut enclosing_scope = None;\n         let mut subcommands = vec![];\n+\n+        let parse_value = |value_str| {\n+                OnUnimplementedFormatString::try_parse(tcx, trait_def_id, value_str, span)\n+                    .map(Some)\n+            };\n+\n         for item in item_iter {\n             if item.check_name(sym::message) && message.is_none() {\n                 if let Some(message_) = item.value_str() {\n-                    message = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, message_, span)?);\n+                    message = parse_value(message_)?;\n                     continue;\n                 }\n             } else if item.check_name(sym::label) && label.is_none() {\n                 if let Some(label_) = item.value_str() {\n-                    label = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, label_, span)?);\n+                    label = parse_value(label_)?;\n                     continue;\n                 }\n             } else if item.check_name(sym::note) && note.is_none() {\n                 if let Some(note_) = item.value_str() {\n-                    note = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, note_, span)?);\n+                    note = parse_value(note_)?;\n+                    continue;\n+                }\n+            } else if item.check_name(sym::enclosing_scope) && enclosing_scope.is_none() {\n+                if let Some(enclosing_scope_) = item.value_str() {\n+                    enclosing_scope = parse_value(enclosing_scope_)?;\n                     continue;\n                 }\n             } else if item.check_name(sym::on) && is_root &&\n@@ -130,7 +136,14 @@ impl<'tcx> OnUnimplementedDirective {\n         if errored {\n             Err(ErrorReported)\n         } else {\n-            Ok(OnUnimplementedDirective { condition, message, label, subcommands, note })\n+            Ok(OnUnimplementedDirective {\n+                condition,\n+                subcommands,\n+                message,\n+                label,\n+                note,\n+                enclosing_scope\n+            })\n         }\n     }\n \n@@ -157,6 +170,7 @@ impl<'tcx> OnUnimplementedDirective {\n                 label: Some(OnUnimplementedFormatString::try_parse(\n                     tcx, trait_def_id, value, attr.span)?),\n                 note: None,\n+                enclosing_scope: None,\n             }))\n         } else {\n             return Err(ErrorReported);\n@@ -174,6 +188,7 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut message = None;\n         let mut label = None;\n         let mut note = None;\n+        let mut enclosing_scope = None;\n         info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\", self, trait_ref, options);\n \n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n@@ -202,6 +217,10 @@ impl<'tcx> OnUnimplementedDirective {\n             if let Some(ref note_) = command.note {\n                 note = Some(note_.clone());\n             }\n+\n+            if let Some(ref enclosing_scope_) = command.enclosing_scope {\n+                enclosing_scope = Some(enclosing_scope_.clone());\n+            }\n         }\n \n         let options: FxHashMap<Symbol, String> = options.into_iter()\n@@ -211,6 +230,7 @@ impl<'tcx> OnUnimplementedDirective {\n             label: label.map(|l| l.format(tcx, trait_ref, &options)),\n             message: message.map(|m| m.format(tcx, trait_ref, &options)),\n             note: note.map(|n| n.format(tcx, trait_ref, &options)),\n+            enclosing_scope: enclosing_scope.map(|e_s| e_s.format(tcx, trait_ref, &options)),\n         }\n     }\n }"}, {"sha": "0fd7145f425d3027cf58e59594035682aec631dc", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -1450,10 +1450,10 @@ impl KeywordIdents {\n \n impl EarlyLintPass for KeywordIdents {\n     fn check_mac_def(&mut self, cx: &EarlyContext<'_>, mac_def: &ast::MacroDef, _id: ast::NodeId) {\n-        self.check_tokens(cx, mac_def.stream());\n+        self.check_tokens(cx, mac_def.body.inner_tokens());\n     }\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::Mac) {\n-        self.check_tokens(cx, mac.tts.clone().into());\n+        self.check_tokens(cx, mac.args.inner_tokens());\n     }\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: ast::Ident) {\n         self.check_ident_token(cx, UnderMacro(false), ident);"}, {"sha": "13db9a6fef9ca83b1cf5a6c808726f61c4a4517a", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -32,6 +32,8 @@ use syntax::source_map;\n use syntax::source_map::Spanned;\n use syntax::symbol::Symbol;\n use syntax::expand::allocator::AllocatorKind;\n+use syntax::ptr::P;\n+use syntax::tokenstream::DelimSpan;\n use syntax_pos::{Span, FileName};\n \n macro_rules! provide {\n@@ -427,6 +429,7 @@ impl CStore {\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n         let local_span = Span::with_root_ctxt(source_file.start_pos, source_file.end_pos);\n+        let dspan = DelimSpan::from_single(local_span);\n         let (body, mut errors) = source_file_to_stream(&sess.parse_sess, source_file, None);\n         emit_unclosed_delims(&mut errors, &sess.parse_sess);\n \n@@ -448,7 +451,7 @@ impl CStore {\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),\n             kind: ast::ItemKind::MacroDef(ast::MacroDef {\n-                tokens: body.into(),\n+                body: P(ast::MacArgs::Delimited(dspan, ast::MacDelimiter::Brace, body)),\n                 legacy: def.legacy,\n             }),\n             vis: source_map::respan(local_span.shrink_to_lo(), ast::VisibilityKind::Inherited),"}, {"sha": "37a9381271a8cd6bcee2459257ed8fcc53252ad3", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 56, "deletions": 49, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -425,16 +425,12 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     }\n \n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n-    fn specialize_constructor<'a, 'q>(\n+    fn specialize_constructor(\n         &self,\n-        cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &[&'q Pat<'tcx>],\n-    ) -> Option<PatStack<'q, 'tcx>>\n-    where\n-        'a: 'q,\n-        'p: 'q,\n-    {\n+        ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+    ) -> Option<PatStack<'p, 'tcx>> {\n         let new_heads = specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns);\n         new_heads.map(|mut new_head| {\n             new_head.0.extend_from_slice(&self.0[1..]);\n@@ -459,6 +455,7 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n }\n \n /// A 2D matrix.\n+#[derive(Clone)]\n pub struct Matrix<'p, 'tcx>(Vec<PatStack<'p, 'tcx>>);\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n@@ -486,16 +483,12 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     }\n \n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n-    fn specialize_constructor<'a, 'q>(\n+    fn specialize_constructor(\n         &self,\n-        cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &[&'q Pat<'tcx>],\n-    ) -> Matrix<'q, 'tcx>\n-    where\n-        'a: 'q,\n-        'p: 'q,\n-    {\n+        ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+    ) -> Matrix<'p, 'tcx> {\n         self.0\n             .iter()\n             .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n@@ -1033,17 +1026,19 @@ impl<'tcx> Constructor<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub enum Usefulness<'tcx> {\n-    Useful,\n+pub enum Usefulness<'tcx, 'p> {\n+    /// Carries a list of unreachable subpatterns. Used only in the presence of or-patterns.\n+    Useful(Vec<&'p Pat<'tcx>>),\n+    /// Carries a list of witnesses of non-exhaustiveness.\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n     NotUseful,\n }\n \n-impl<'tcx> Usefulness<'tcx> {\n+impl<'tcx, 'p> Usefulness<'tcx, 'p> {\n     fn new_useful(preference: WitnessPreference) -> Self {\n         match preference {\n             ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n-            LeaveOutWitness => Useful,\n+            LeaveOutWitness => Useful(vec![]),\n         }\n     }\n \n@@ -1604,13 +1599,13 @@ impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n /// relation to preceding patterns, it is not reachable) and exhaustiveness\n /// checking (if a wildcard pattern is useful in relation to a matrix, the\n /// matrix isn't exhaustive).\n-pub fn is_useful<'p, 'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+pub fn is_useful<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n-    v: &PatStack<'_, 'tcx>,\n+    v: &PatStack<'p, 'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n-) -> Usefulness<'tcx> {\n+) -> Usefulness<'tcx, 'p> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n \n@@ -1631,11 +1626,26 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n     // If the first pattern is an or-pattern, expand it.\n     if let Some(vs) = v.expand_or_pat() {\n-        return vs\n-            .into_iter()\n-            .map(|v| is_useful(cx, matrix, &v, witness_preference, hir_id))\n-            .find(|result| result.is_useful())\n-            .unwrap_or(NotUseful);\n+        // We need to push the already-seen patterns into the matrix in order to detect redundant\n+        // branches like `Some(_) | Some(0)`. We also keep track of the unreachable subpatterns.\n+        let mut matrix = matrix.clone();\n+        let mut unreachable_pats = Vec::new();\n+        let mut any_is_useful = false;\n+        for v in vs {\n+            let res = is_useful(cx, &matrix, &v, witness_preference, hir_id);\n+            match res {\n+                Useful(pats) => {\n+                    any_is_useful = true;\n+                    unreachable_pats.extend(pats);\n+                }\n+                NotUseful => unreachable_pats.push(v.head()),\n+                UsefulWithWitness(_) => {\n+                    bug!(\"Encountered or-pat in `v` during exhaustiveness checking\")\n+                }\n+            }\n+            matrix.push(v);\n+        }\n+        return if any_is_useful { Useful(unreachable_pats) } else { NotUseful };\n     }\n \n     let (ty, span) = matrix\n@@ -1768,21 +1778,21 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n /// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e., `is_useful` applied\n /// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n-fn is_useful_specialized<'p, 'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+fn is_useful_specialized<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n-    v: &PatStack<'_, 'tcx>,\n+    v: &PatStack<'p, 'tcx>,\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n-) -> Usefulness<'tcx> {\n+) -> Usefulness<'tcx, 'p> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n \n-    let ctor_wild_subpatterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty);\n-    let ctor_wild_subpatterns: Vec<_> = ctor_wild_subpatterns_owned.iter().collect();\n-    let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n-    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n+    let ctor_wild_subpatterns =\n+        cx.pattern_arena.alloc_from_iter(ctor.wildcard_subpatterns(cx, lty));\n+    let matrix = matrix.specialize_constructor(cx, &ctor, ctor_wild_subpatterns);\n+    v.specialize_constructor(cx, &ctor, ctor_wild_subpatterns)\n         .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id))\n         .map(|u| u.apply_constructor(cx, &ctor, lty))\n         .unwrap_or(NotUseful)\n@@ -2250,13 +2260,13 @@ fn constructor_covered_by_range<'tcx>(\n     if intersects { Some(()) } else { None }\n }\n \n-fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+fn patterns_for_variant<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     subpatterns: &'p [FieldPat<'tcx>],\n-    ctor_wild_subpatterns: &[&'p Pat<'tcx>],\n+    ctor_wild_subpatterns: &'p [Pat<'tcx>],\n     is_non_exhaustive: bool,\n ) -> PatStack<'p, 'tcx> {\n-    let mut result = SmallVec::from_slice(ctor_wild_subpatterns);\n+    let mut result: SmallVec<_> = ctor_wild_subpatterns.iter().collect();\n \n     for subpat in subpatterns {\n         if !is_non_exhaustive || !cx.is_uninhabited(subpat.pattern.ty) {\n@@ -2280,11 +2290,11 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    pat: &'q Pat<'tcx>,\n+fn specialize_one_pattern<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+    pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n-    ctor_wild_subpatterns: &[&'p Pat<'tcx>],\n+    ctor_wild_subpatterns: &'p [Pat<'tcx>],\n ) -> Option<PatStack<'p, 'tcx>> {\n     if let NonExhaustive = constructor {\n         // Only a wildcard pattern can match the special extra constructor\n@@ -2294,9 +2304,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n     let result = match *pat.kind {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n \n-        PatKind::Binding { .. } | PatKind::Wild => {\n-            Some(PatStack::from_slice(ctor_wild_subpatterns))\n-        }\n+        PatKind::Binding { .. } | PatKind::Wild => Some(ctor_wild_subpatterns.iter().collect()),\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n@@ -2406,7 +2414,6 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n                                 .chain(\n                                     ctor_wild_subpatterns\n                                         .iter()\n-                                        .map(|p| *p)\n                                         .skip(prefix.len())\n                                         .take(slice_count)\n                                         .chain(suffix.iter()),"}, {"sha": "737af3e1358f4593924610c8f8b7f50b6f64b67e", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 102, "deletions": 118, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -139,39 +139,22 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n-            let inlined_arms: Vec<(Vec<_>, _)> = arms\n+            let inlined_arms: Vec<_> = arms\n                 .iter()\n                 .map(|arm| {\n-                    (\n-                        // HACK(or_patterns; Centril | dlrobertson): Remove this and\n-                        // correctly handle exhaustiveness checking for nested or-patterns.\n-                        match &arm.pat.kind {\n-                            hir::PatKind::Or(pats) => pats,\n-                            _ => std::slice::from_ref(&arm.pat),\n-                        }\n-                        .iter()\n-                        .map(|pat| {\n-                            let mut patcx = PatCtxt::new(\n-                                self.tcx,\n-                                self.param_env.and(self.identity_substs),\n-                                self.tables,\n-                            );\n-                            patcx.include_lint_checks();\n-                            let pattern = cx\n-                                .pattern_arena\n-                                .alloc(expand_pattern(cx, patcx.lower_pattern(&pat)))\n-                                as &_;\n-                            if !patcx.errors.is_empty() {\n-                                patcx.report_inlining_errors(pat.span);\n-                                have_errors = true;\n-                            }\n-                            (pattern, &**pat)\n-                        })\n-                        .collect(),\n-                        arm.guard.as_ref().map(|g| match g {\n-                            hir::Guard::If(ref e) => &**e,\n-                        }),\n-                    )\n+                    let mut patcx = PatCtxt::new(\n+                        self.tcx,\n+                        self.param_env.and(self.identity_substs),\n+                        self.tables,\n+                    );\n+                    patcx.include_lint_checks();\n+                    let pattern: &_ =\n+                        cx.pattern_arena.alloc(expand_pattern(cx, patcx.lower_pattern(&arm.pat)));\n+                    if !patcx.errors.is_empty() {\n+                        patcx.report_inlining_errors(arm.pat.span);\n+                        have_errors = true;\n+                    }\n+                    (pattern, &*arm.pat, arm.guard.is_some())\n                 })\n                 .collect();\n \n@@ -181,7 +164,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, &inlined_arms, source);\n+            let matrix = check_arms(cx, &inlined_arms, source);\n \n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n@@ -248,12 +231,6 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 return;\n             }\n \n-            let matrix: Matrix<'_, '_> = inlined_arms\n-                .iter()\n-                .filter(|&&(_, guard)| guard.is_none())\n-                .flat_map(|arm| &arm.0)\n-                .map(|pat| PatStack::from_pattern(pat.0))\n-                .collect();\n             let scrut_ty = self.tables.node_type(scrut.hir_id);\n             check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id);\n         })\n@@ -267,8 +244,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             patcx.include_lint_checks();\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;\n-            let pattern = expand_pattern(cx, pattern);\n-            let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(&pattern)].into_iter().collect();\n+            let pattern = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n+            let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n \n             let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n                 Ok(_) => return,\n@@ -403,113 +380,120 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n }\n \n // Check for unreachable patterns\n-fn check_arms<'tcx>(\n-    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n-    arms: &[(Vec<(&super::Pat<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n+fn check_arms<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+    arms: &[(&'p super::Pat<'tcx>, &hir::Pat, bool)],\n     source: hir::MatchSource,\n-) {\n+) -> Matrix<'p, 'tcx> {\n     let mut seen = Matrix::empty();\n     let mut catchall = None;\n-    for (arm_index, &(ref pats, guard)) in arms.iter().enumerate() {\n-        for &(pat, hir_pat) in pats {\n-            let v = PatStack::from_pattern(pat);\n-\n-            match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n-                NotUseful => {\n-                    match source {\n-                        hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => {\n-                            bug!()\n-                        }\n-                        hir::MatchSource::IfLetDesugar { .. } => {\n-                            cx.tcx.lint_hir(\n-                                lint::builtin::IRREFUTABLE_LET_PATTERNS,\n-                                hir_pat.hir_id,\n-                                pat.span,\n-                                \"irrefutable if-let pattern\",\n-                            );\n-                        }\n-\n-                        hir::MatchSource::WhileLetDesugar => {\n-                            // check which arm we're on.\n-                            match arm_index {\n-                                // The arm with the user-specified pattern.\n-                                0 => {\n-                                    cx.tcx.lint_hir(\n-                                        lint::builtin::UNREACHABLE_PATTERNS,\n-                                        hir_pat.hir_id,\n-                                        pat.span,\n-                                        \"unreachable pattern\",\n-                                    );\n-                                }\n-                                // The arm with the wildcard pattern.\n-                                1 => {\n-                                    cx.tcx.lint_hir(\n-                                        lint::builtin::IRREFUTABLE_LET_PATTERNS,\n-                                        hir_pat.hir_id,\n-                                        pat.span,\n-                                        \"irrefutable while-let pattern\",\n-                                    );\n-                                }\n-                                _ => bug!(),\n+    for (arm_index, (pat, hir_pat, has_guard)) in arms.iter().enumerate() {\n+        let v = PatStack::from_pattern(pat);\n+\n+        match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n+            NotUseful => {\n+                match source {\n+                    hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => bug!(),\n+\n+                    hir::MatchSource::IfLetDesugar { .. } | hir::MatchSource::WhileLetDesugar => {\n+                        // check which arm we're on.\n+                        match arm_index {\n+                            // The arm with the user-specified pattern.\n+                            0 => {\n+                                cx.tcx.lint_hir(\n+                                    lint::builtin::UNREACHABLE_PATTERNS,\n+                                    hir_pat.hir_id,\n+                                    pat.span,\n+                                    \"unreachable pattern\",\n+                                );\n                             }\n-                        }\n-\n-                        hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                            let mut err = cx.tcx.struct_span_lint_hir(\n-                                lint::builtin::UNREACHABLE_PATTERNS,\n-                                hir_pat.hir_id,\n-                                pat.span,\n-                                \"unreachable pattern\",\n-                            );\n-                            // if we had a catchall pattern, hint at that\n-                            if let Some(catchall) = catchall {\n-                                err.span_label(pat.span, \"unreachable pattern\");\n-                                err.span_label(catchall, \"matches any value\");\n+                            // The arm with the wildcard pattern.\n+                            1 => {\n+                                let msg = match source {\n+                                    hir::MatchSource::IfLetDesugar { .. } => {\n+                                        \"irrefutable if-let pattern\"\n+                                    }\n+                                    hir::MatchSource::WhileLetDesugar => {\n+                                        \"irrefutable while-let pattern\"\n+                                    }\n+                                    _ => bug!(),\n+                                };\n+                                cx.tcx.lint_hir(\n+                                    lint::builtin::IRREFUTABLE_LET_PATTERNS,\n+                                    hir_pat.hir_id,\n+                                    pat.span,\n+                                    msg,\n+                                );\n                             }\n-                            err.emit();\n+                            _ => bug!(),\n                         }\n+                    }\n \n-                        // Unreachable patterns in try and await expressions occur when one of\n-                        // the arms are an uninhabited type. Which is OK.\n-                        hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n+                    hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n+                        let mut err = cx.tcx.struct_span_lint_hir(\n+                            lint::builtin::UNREACHABLE_PATTERNS,\n+                            hir_pat.hir_id,\n+                            pat.span,\n+                            \"unreachable pattern\",\n+                        );\n+                        // if we had a catchall pattern, hint at that\n+                        if let Some(catchall) = catchall {\n+                            err.span_label(pat.span, \"unreachable pattern\");\n+                            err.span_label(catchall, \"matches any value\");\n+                        }\n+                        err.emit();\n                     }\n+\n+                    // Unreachable patterns in try and await expressions occur when one of\n+                    // the arms are an uninhabited type. Which is OK.\n+                    hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n                 }\n-                Useful => (),\n-                UsefulWithWitness(_) => bug!(),\n             }\n-            if guard.is_none() {\n-                seen.push(v);\n-                if catchall.is_none() && pat_is_catchall(hir_pat) {\n-                    catchall = Some(pat.span);\n+            Useful(unreachable_subpatterns) => {\n+                for pat in unreachable_subpatterns {\n+                    cx.tcx.lint_hir(\n+                        lint::builtin::UNREACHABLE_PATTERNS,\n+                        hir_pat.hir_id,\n+                        pat.span,\n+                        \"unreachable pattern\",\n+                    );\n                 }\n             }\n+            UsefulWithWitness(_) => bug!(),\n+        }\n+        if !has_guard {\n+            seen.push(v);\n+            if catchall.is_none() && pat_is_catchall(hir_pat) {\n+                catchall = Some(pat.span);\n+            }\n         }\n     }\n+    seen\n }\n \n-fn check_not_useful(\n-    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+fn check_not_useful<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     ty: Ty<'tcx>,\n-    matrix: &Matrix<'_, 'tcx>,\n+    matrix: &Matrix<'p, 'tcx>,\n     hir_id: HirId,\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n-    let wild_pattern = super::Pat::wildcard_from_ty(ty);\n-    match is_useful(cx, matrix, &PatStack::from_pattern(&wild_pattern), ConstructWitness, hir_id) {\n+    let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(ty));\n+    match is_useful(cx, matrix, &PatStack::from_pattern(wild_pattern), ConstructWitness, hir_id) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n-            vec![wild_pattern]\n+            bug!(\"Exhaustiveness check returned no witnesses\")\n         } else {\n             pats.into_iter().map(|w| w.single_pattern()).collect()\n         }),\n-        Useful => bug!(),\n+        Useful(_) => bug!(),\n     }\n }\n \n-fn check_exhaustive<'tcx>(\n-    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+fn check_exhaustive<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n-    matrix: &Matrix<'_, 'tcx>,\n+    matrix: &Matrix<'p, 'tcx>,\n     hir_id: HirId,\n ) {\n     let witnesses = match check_not_useful(cx, scrut_ty, matrix, hir_id) {"}, {"sha": "75fc6b389e85e55276d5654fce5c515fc1b9ae5d", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -424,13 +424,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if self.binary_op(BinOp::Rem, a, b)?.to_bits()? != 0 {\n             // Then, check if `b` is -1, which is the \"min_value / -1\" case.\n             let minus1 = Scalar::from_int(-1, dest.layout.size);\n-            let b = b.to_scalar().unwrap();\n-            if b == minus1 {\n+            let b_scalar = b.to_scalar().unwrap();\n+            if b_scalar == minus1 {\n                 throw_ub_format!(\"exact_div: result of dividing MIN by -1 cannot be represented\")\n             } else {\n                 throw_ub_format!(\n                     \"exact_div: {} cannot be divided by {} without remainder\",\n-                    a.to_scalar().unwrap(),\n+                    a,\n                     b,\n                 )\n             }"}, {"sha": "48e7193ec39d4358bdbccf20c852164f5829fcd0", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -19,6 +19,7 @@ use super::{\n };\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n use rustc_macros::HashStable;\n+use syntax::ast;\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n ///\n@@ -100,6 +101,42 @@ pub struct ImmTy<'tcx, Tag=()> {\n     pub layout: TyLayout<'tcx>,\n }\n \n+// `Tag: Copy` because some methods on `Scalar` consume them by value\n+impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match &self.imm {\n+            Immediate::Scalar(ScalarMaybeUndef::Scalar(s)) => match s.to_bits(self.layout.size) {\n+                Ok(s) => {\n+                    match self.layout.ty.kind {\n+                        ty::Int(_) => return write!(\n+                            fmt, \"{}\",\n+                            super::sign_extend(s, self.layout.size) as i128,\n+                        ),\n+                        ty::Uint(_) => return write!(fmt, \"{}\", s),\n+                        ty::Bool if s == 0 => return fmt.write_str(\"false\"),\n+                        ty::Bool if s == 1 => return fmt.write_str(\"true\"),\n+                        ty::Char => if let Some(c) =\n+                            u32::try_from(s).ok().and_then(std::char::from_u32) {\n+                            return write!(fmt, \"{}\", c);\n+                        },\n+                        ty::Float(ast::FloatTy::F32) => if let Ok(u) = u32::try_from(s) {\n+                            return write!(fmt, \"{}\", f32::from_bits(u));\n+                        },\n+                        ty::Float(ast::FloatTy::F64) => if let Ok(u) = u64::try_from(s) {\n+                            return write!(fmt, \"{}\", f64::from_bits(u));\n+                        },\n+                        _ => {},\n+                    }\n+                    write!(fmt, \"{:x}\", s)\n+                },\n+                Err(_) => fmt.write_str(\"{pointer}\"),\n+            },\n+            Immediate::Scalar(ScalarMaybeUndef::Undef) => fmt.write_str(\"{undef}\"),\n+            Immediate::ScalarPair(..) => fmt.write_str(\"{wide pointer or tuple}\"),\n+        }\n+    }\n+}\n+\n impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n     type Target = Immediate<Tag>;\n     #[inline(always)]"}, {"sha": "1bf6e9ecbc060ec8868bd2bff9134b71c8ef8817", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -101,7 +101,7 @@ impl<'a> StripUnconfigured<'a> {\n         if !attr.has_name(sym::cfg_attr) {\n             return vec![attr];\n         }\n-        if attr.get_normal_item().tokens.is_empty() {\n+        if let ast::MacArgs::Empty = attr.get_normal_item().args {\n             self.sess.span_diagnostic\n                 .struct_span_err(\n                     attr.span,"}, {"sha": "a22b383e5f39166dc0b558f843bfed5571c23832", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -277,7 +277,9 @@ pub fn parse_in_attr<'a, T>(\n ) -> PResult<'a, T> {\n     let mut parser = Parser::new(\n         sess,\n-        attr.get_normal_item().tokens.clone(),\n+        // FIXME(#66940, Centril | petrochenkov): refactor this function so it doesn't\n+        // require reconstructing and immediately re-parsing delimiters.\n+        attr.get_normal_item().args.outer_tokens(),\n         None,\n         false,\n         false,\n@@ -409,7 +411,7 @@ fn prepend_attrs(\n             brackets.push(stream);\n         }\n \n-        brackets.push(item.tokens.clone());\n+        brackets.push(item.args.outer_tokens());\n \n         // The span we list here for `#` and for `[ ... ]` are both wrong in\n         // that it encompasses more than each token, but it hopefully is \"good"}, {"sha": "c7261404f54efda0dede24beb4e011e53703b1df", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -2,8 +2,7 @@ use super::{SeqSep, Parser, TokenType, PathStyle};\n use syntax::attr;\n use syntax::ast;\n use syntax::util::comments;\n-use syntax::token::{self, Nonterminal, DelimToken};\n-use syntax::tokenstream::{TokenStream, TokenTree};\n+use syntax::token::{self, Nonterminal};\n use syntax_pos::{Span, Symbol};\n use errors::PResult;\n \n@@ -181,31 +180,8 @@ impl<'a> Parser<'a> {\n             item\n         } else {\n             let path = self.parse_path(PathStyle::Mod)?;\n-            let tokens = if self.check(&token::OpenDelim(DelimToken::Paren)) ||\n-               self.check(&token::OpenDelim(DelimToken::Bracket)) ||\n-               self.check(&token::OpenDelim(DelimToken::Brace)) {\n-                   self.parse_token_tree().into()\n-            } else if self.eat(&token::Eq) {\n-                let eq = TokenTree::token(token::Eq, self.prev_span);\n-                let mut is_interpolated_expr = false;\n-                if let token::Interpolated(nt) = &self.token.kind {\n-                    if let token::NtExpr(..) = **nt {\n-                        is_interpolated_expr = true;\n-                    }\n-                }\n-                let token_tree = if is_interpolated_expr {\n-                    // We need to accept arbitrary interpolated expressions to continue\n-                    // supporting things like `doc = $expr` that work on stable.\n-                    // Non-literal interpolated expressions are rejected after expansion.\n-                    self.parse_token_tree()\n-                } else {\n-                    self.parse_unsuffixed_lit()?.token_tree()\n-                };\n-                TokenStream::new(vec![eq.into(), token_tree.into()])\n-            } else {\n-                TokenStream::default()\n-            };\n-            ast::AttrItem { path, tokens }\n+            let args = self.parse_attr_args()?;\n+            ast::AttrItem { path, args }\n         })\n     }\n \n@@ -244,7 +220,7 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n+    pub(super) fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n         let lit = self.parse_lit()?;\n         debug!(\"checking if {:?} is unusuffixed\", lit);\n "}, {"sha": "1112274dc46a511524ba2ce1cf181fa285c01d59", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -922,13 +922,11 @@ impl<'a> Parser<'a> {\n                     // `!`, as an operator, is prefix, so we know this isn't that.\n                     if self.eat(&token::Not) {\n                         // MACRO INVOCATION expression\n-                        let (delim, tts) = self.expect_delimited_token_tree()?;\n+                        let args = self.parse_mac_args()?;\n                         hi = self.prev_span;\n                         ex = ExprKind::Mac(Mac {\n                             path,\n-                            tts,\n-                            delim,\n-                            span: lo.to(hi),\n+                            args,\n                             prior_type_ascription: self.last_type_ascription,\n                         });\n                     } else if self.check(&token::OpenDelim(token::Brace)) {"}, {"sha": "46addba57c628eb5c5c1724fdb9d59b713377036", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -8,12 +8,12 @@ use syntax::ast::{ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind, Us\n use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness, Extern, StrLit};\n use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n use syntax::ast::{Ty, TyKind, Generics, TraitRef, EnumDef, Variant, VariantData, StructField};\n-use syntax::ast::{Mac, MacDelimiter, Block, BindingMode, FnDecl, FnSig, SelfKind, Param};\n+use syntax::ast::{Mac, MacArgs, MacDelimiter, Block, BindingMode, FnDecl, FnSig, SelfKind, Param};\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::ThinVec;\n use syntax::token;\n-use syntax::tokenstream::{TokenTree, TokenStream};\n+use syntax::tokenstream::{DelimSpan, TokenTree, TokenStream};\n use syntax::source_map::{self, respan, Span};\n use syntax::struct_span_err;\n use syntax_pos::BytePos;\n@@ -432,22 +432,18 @@ impl<'a> Parser<'a> {\n             let prev_span = self.prev_span;\n             self.complain_if_pub_macro(&visibility.node, prev_span);\n \n-            let mac_lo = self.token.span;\n-\n             // Item macro\n             let path = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n-            let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+            let args = self.parse_mac_args()?;\n+            if args.need_semicolon() && !self.eat(&token::Semi) {\n                 self.report_invalid_macro_expansion_item();\n             }\n \n             let hi = self.prev_span;\n             let mac = Mac {\n                 path,\n-                tts,\n-                delim,\n-                span: mac_lo.to(hi),\n+                args,\n                 prior_type_ascription: self.last_type_ascription,\n             };\n             let item =\n@@ -500,7 +496,6 @@ impl<'a> Parser<'a> {\n         if self.token.is_path_start() &&\n                 !(self.is_async_fn() && self.token.span.rust_2015()) {\n             let prev_span = self.prev_span;\n-            let lo = self.token.span;\n             let path = self.parse_path(PathStyle::Mod)?;\n \n             if path.segments.len() == 1 {\n@@ -518,16 +513,14 @@ impl<'a> Parser<'a> {\n             *at_end = true;\n \n             // eat a matched-delimiter token tree:\n-            let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != MacDelimiter::Brace {\n+            let args = self.parse_mac_args()?;\n+            if args.need_semicolon() {\n                 self.expect_semi()?;\n             }\n \n             Ok(Some(Mac {\n                 path,\n-                tts,\n-                delim,\n-                span: lo.to(self.prev_span),\n+                args,\n                 prior_type_ascription: self.last_type_ascription,\n             }))\n         } else {\n@@ -1624,33 +1617,31 @@ impl<'a> Parser<'a> {\n         vis: &Visibility,\n         lo: Span\n     ) -> PResult<'a, Option<P<Item>>> {\n-        let token_lo = self.token.span;\n         let (ident, def) = if self.eat_keyword(kw::Macro) {\n             let ident = self.parse_ident()?;\n-            let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n-                match self.parse_token_tree() {\n-                    TokenTree::Delimited(_, _, tts) => tts,\n-                    _ => unreachable!(),\n-                }\n+            let body = if self.check(&token::OpenDelim(token::Brace)) {\n+                self.parse_mac_args()?\n             } else if self.check(&token::OpenDelim(token::Paren)) {\n-                let args = self.parse_token_tree();\n+                let params = self.parse_token_tree();\n+                let pspan = params.span();\n                 let body = if self.check(&token::OpenDelim(token::Brace)) {\n                     self.parse_token_tree()\n                 } else {\n-                    self.unexpected()?;\n-                    unreachable!()\n+                    return self.unexpected();\n                 };\n-                TokenStream::new(vec![\n-                    args.into(),\n-                    TokenTree::token(token::FatArrow, token_lo.to(self.prev_span)).into(),\n+                let bspan = body.span();\n+                let tokens = TokenStream::new(vec![\n+                    params.into(),\n+                    TokenTree::token(token::FatArrow, pspan.between(bspan)).into(),\n                     body.into(),\n-                ])\n+                ]);\n+                let dspan = DelimSpan::from_pair(pspan.shrink_to_lo(), bspan.shrink_to_hi());\n+                P(MacArgs::Delimited(dspan, MacDelimiter::Brace, tokens))\n             } else {\n-                self.unexpected()?;\n-                unreachable!()\n+                return self.unexpected();\n             };\n \n-            (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n+            (ident, ast::MacroDef { body, legacy: false })\n         } else if self.check_keyword(sym::macro_rules) &&\n                   self.look_ahead(1, |t| *t == token::Not) &&\n                   self.look_ahead(2, |t| t.is_ident()) {\n@@ -1660,12 +1651,12 @@ impl<'a> Parser<'a> {\n             self.bump();\n \n             let ident = self.parse_ident()?;\n-            let (delim, tokens) = self.expect_delimited_token_tree()?;\n-            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+            let body = self.parse_mac_args()?;\n+            if body.need_semicolon() && !self.eat(&token::Semi) {\n                 self.report_invalid_macro_expansion_item();\n             }\n \n-            (ident, ast::MacroDef { tokens, legacy: true })\n+            (ident, ast::MacroDef { body, legacy: true })\n         } else {\n             return Ok(None);\n         };"}, {"sha": "28689720044e8e702f6d80fd08e912f71a2212ae", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -16,7 +16,7 @@ use crate::lexer::UnmatchedBrace;\n \n use syntax::ast::{\n     self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Extern, Ident, StrLit,\n-    IsAsync, MacDelimiter, Mutability, Visibility, VisibilityKind, Unsafety,\n+    IsAsync, MacArgs, MacDelimiter, Mutability, Visibility, VisibilityKind, Unsafety,\n };\n \n use syntax::print::pprust;\n@@ -1010,27 +1010,49 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn expect_delimited_token_tree(&mut self) -> PResult<'a, (MacDelimiter, TokenStream)> {\n-        let delim = match self.token.kind {\n-            token::OpenDelim(delim) => delim,\n-            _ => {\n-                let msg = \"expected open delimiter\";\n-                let mut err = self.fatal(msg);\n-                err.span_label(self.token.span, msg);\n-                return Err(err)\n+    fn parse_mac_args(&mut self) -> PResult<'a, P<MacArgs>> {\n+        self.parse_mac_args_common(true).map(P)\n+    }\n+\n+    fn parse_attr_args(&mut self) -> PResult<'a, MacArgs> {\n+        self.parse_mac_args_common(false)\n+    }\n+\n+    fn parse_mac_args_common(&mut self, delimited_only: bool) -> PResult<'a, MacArgs> {\n+        Ok(if self.check(&token::OpenDelim(DelimToken::Paren)) ||\n+                       self.check(&token::OpenDelim(DelimToken::Bracket)) ||\n+                       self.check(&token::OpenDelim(DelimToken::Brace)) {\n+            match self.parse_token_tree() {\n+                TokenTree::Delimited(dspan, delim, tokens) =>\n+                    // We've confirmed above that there is a delimiter so unwrapping is OK.\n+                    MacArgs::Delimited(dspan, MacDelimiter::from_token(delim).unwrap(), tokens),\n+                _ => unreachable!(),\n             }\n-        };\n-        let tts = match self.parse_token_tree() {\n-            TokenTree::Delimited(_, _, tts) => tts,\n-            _ => unreachable!(),\n-        };\n-        let delim = match delim {\n-            token::Paren => MacDelimiter::Parenthesis,\n-            token::Bracket => MacDelimiter::Bracket,\n-            token::Brace => MacDelimiter::Brace,\n-            token::NoDelim => self.bug(\"unexpected no delimiter\"),\n-        };\n-        Ok((delim, tts.into()))\n+        } else if !delimited_only {\n+            if self.eat(&token::Eq) {\n+                let eq_span = self.prev_span;\n+                let mut is_interpolated_expr = false;\n+                if let token::Interpolated(nt) = &self.token.kind {\n+                    if let token::NtExpr(..) = **nt {\n+                        is_interpolated_expr = true;\n+                    }\n+                }\n+                let token_tree = if is_interpolated_expr {\n+                    // We need to accept arbitrary interpolated expressions to continue\n+                    // supporting things like `doc = $expr` that work on stable.\n+                    // Non-literal interpolated expressions are rejected after expansion.\n+                    self.parse_token_tree()\n+                } else {\n+                    self.parse_unsuffixed_lit()?.token_tree()\n+                };\n+\n+                MacArgs::Eq(eq_span, token_tree.into())\n+            } else {\n+                MacArgs::Empty\n+            }\n+        } else {\n+            return self.unexpected();\n+        })\n     }\n \n     fn parse_or_use_outer_attributes("}, {"sha": "1127c4b2d5f88c0bb65725f789db5ff1164d7ea7", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -338,7 +338,7 @@ impl<'a> Parser<'a> {\n                     (None, self.parse_path(PathStyle::Expr)?)\n                 };\n                 match self.token.kind {\n-                    token::Not if qself.is_none() => self.parse_pat_mac_invoc(lo, path)?,\n+                    token::Not if qself.is_none() => self.parse_pat_mac_invoc(path)?,\n                     token::DotDotDot | token::DotDotEq | token::DotDot => {\n                         self.parse_pat_range_starting_with_path(lo, qself, path)?\n                     }\n@@ -593,14 +593,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse macro invocation\n-    fn parse_pat_mac_invoc(&mut self, lo: Span, path: Path) -> PResult<'a, PatKind> {\n+    fn parse_pat_mac_invoc(&mut self, path: Path) -> PResult<'a, PatKind> {\n         self.bump();\n-        let (delim, tts) = self.expect_delimited_token_tree()?;\n+        let args = self.parse_mac_args()?;\n         let mac = Mac {\n             path,\n-            tts,\n-            delim,\n-            span: lo.to(self.prev_span),\n+            args,\n             prior_type_ascription: self.last_type_ascription,\n         };\n         Ok(PatKind::Mac(mac))"}, {"sha": "75bb67d47bc48cfc96044828e932866802387416", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -2,6 +2,7 @@ use super::{Parser, TokenType};\n use crate::maybe_whole;\n use syntax::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, AngleBracketedArgs};\n use syntax::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n+use syntax::ast::MacArgs;\n use syntax::ThinVec;\n use syntax::token::{self, Token};\n use syntax::source_map::{Span, BytePos};\n@@ -114,9 +115,9 @@ impl<'a> Parser<'a> {\n     fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, Path> {\n         let meta_ident = match self.token.kind {\n             token::Interpolated(ref nt) => match **nt {\n-                token::NtMeta(ref item) => match item.tokens.is_empty() {\n-                    true => Some(item.path.clone()),\n-                    false => None,\n+                token::NtMeta(ref item) => match item.args {\n+                    MacArgs::Empty => Some(item.path.clone()),\n+                    _ => None,\n                 },\n                 _ => None,\n             },"}, {"sha": "b952e8814a361adec72a9e3fec9ad9b7dccd3d48", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -10,7 +10,7 @@ use syntax::ThinVec;\n use syntax::ptr::P;\n use syntax::ast;\n use syntax::ast::{DUMMY_NODE_ID, Stmt, StmtKind, Local, Block, BlockCheckMode, Expr, ExprKind};\n-use syntax::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac, MacDelimiter};\n+use syntax::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac};\n use syntax::util::classify;\n use syntax::token;\n use syntax::source_map::{respan, Span};\n@@ -93,23 +93,22 @@ impl<'a> Parser<'a> {\n                 }));\n             }\n \n-            let (delim, tts) = self.expect_delimited_token_tree()?;\n+            let args = self.parse_mac_args()?;\n+            let delim = args.delim();\n             let hi = self.prev_span;\n \n-            let style = if delim == MacDelimiter::Brace {\n+            let style = if delim == token::Brace {\n                 MacStmtStyle::Braces\n             } else {\n                 MacStmtStyle::NoBraces\n             };\n \n             let mac = Mac {\n                 path,\n-                tts,\n-                delim,\n-                span: lo.to(hi),\n+                args,\n                 prior_type_ascription: self.last_type_ascription,\n             };\n-            let kind = if delim == MacDelimiter::Brace ||\n+            let kind = if delim == token::Brace ||\n                           self.token == token::Semi || self.token == token::Eof {\n                 StmtKind::Mac(P((mac, style, attrs.into())))\n             }\n@@ -130,7 +129,7 @@ impl<'a> Parser<'a> {\n                 self.warn_missing_semicolon();\n                 StmtKind::Mac(P((mac, style, attrs.into())))\n             } else {\n-                let e = self.mk_expr(mac.span, ExprKind::Mac(mac), ThinVec::new());\n+                let e = self.mk_expr(lo.to(hi), ExprKind::Mac(mac), ThinVec::new());\n                 let e = self.maybe_recover_from_bad_qpath(e, true)?;\n                 let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n                 let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;"}, {"sha": "321427969051c54c24f464334a4d8235cd0a4039", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -177,12 +177,10 @@ impl<'a> Parser<'a> {\n             let path = self.parse_path(PathStyle::Type)?;\n             if self.eat(&token::Not) {\n                 // Macro invocation in type position\n-                let (delim, tts) = self.expect_delimited_token_tree()?;\n+                let args = self.parse_mac_args()?;\n                 let mac = Mac {\n                     path,\n-                    tts,\n-                    delim,\n-                    span: lo.to(self.prev_span),\n+                    args,\n                     prior_type_ascription: self.last_type_ascription,\n                 };\n                 TyKind::Mac(mac)"}, {"sha": "0fb348efece58e2f477e44b1e19457fa7035b264", "filename": "src/librustc_parse/validate_attr.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_parse%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fvalidate_attr.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -2,11 +2,9 @@\n \n use errors::{PResult, Applicability};\n use rustc_feature::{AttributeTemplate, BUILTIN_ATTRIBUTE_MAP};\n-use syntax::ast::{self, Attribute, AttrKind, Ident, MetaItem, MetaItemKind};\n+use syntax::ast::{self, Attribute, AttrKind, Ident, MacArgs, MetaItem, MetaItemKind};\n use syntax::attr::mk_name_value_item_str;\n use syntax::early_buffered_lints::BufferedEarlyLintId;\n-use syntax::token;\n-use syntax::tokenstream::TokenTree;\n use syntax::sess::ParseSess;\n use syntax_pos::{Symbol, sym};\n \n@@ -19,11 +17,9 @@ pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n         // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n         Some((name, _, template, _)) if name != sym::rustc_dummy =>\n             check_builtin_attribute(sess, attr, name, template),\n-        _ => if let Some(TokenTree::Token(token)) = attr.get_normal_item().tokens.trees().next() {\n-            if token == token::Eq {\n-                // All key-value attributes are restricted to meta-item syntax.\n-                parse_meta(sess, attr).map_err(|mut err| err.emit()).ok();\n-            }\n+        _ => if let MacArgs::Eq(..) = attr.get_normal_item().args {\n+            // All key-value attributes are restricted to meta-item syntax.\n+            parse_meta(sess, attr).map_err(|mut err| err.emit()).ok();\n         }\n     }\n }"}, {"sha": "29cfee8408f30d209f21333bd24010b116e61090", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -737,14 +737,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             |this| visit::walk_enum_def(this, enum_definition, generics, item_id))\n     }\n \n-    fn visit_mac(&mut self, mac: &Mac) {\n-        // when a new macro kind is added but the author forgets to set it up for expansion\n-        // because that's the only part that won't cause a compiler error\n-        self.session.diagnostic()\n-            .span_bug(mac.span, \"macro invocation missed in expansion; did you forget to override \\\n-                                 the relevant `fold_*()` method in `PlaceholderExpander`?\");\n-    }\n-\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         if let ImplItemKind::Method(ref sig, _) = ii.kind {\n             self.check_fn_decl(&sig.decl);"}, {"sha": "396d948433961ddbb013b8f8fca4660e60bd0a27", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -1515,14 +1515,6 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn visit_mac(&mut self, mac: &'l ast::Mac) {\n-        // These shouldn't exist in the AST at this point, log a span bug.\n-        span_bug!(\n-            mac.span,\n-            \"macro invocation should have been expanded out of AST\"\n-        );\n-    }\n-\n     fn visit_pat(&mut self, p: &'l ast::Pat) {\n         self.process_macro_use(p.span);\n         self.process_pat(p);"}, {"sha": "7ee1054dc4846886fd6c177fdb98bc91a776145d", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -482,7 +482,7 @@ fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemE\n     match cx.enter_resolver(|r| r.cstore().load_macro_untracked(did, cx.sess())) {\n         LoadedMacro::MacroDef(def, _) => {\n             let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.kind {\n-                let tts: Vec<_> = def.stream().into_trees().collect();\n+                let tts: Vec<_> = def.body.inner_tokens().into_trees().collect();\n                 tts.chunks(4).map(|arm| arm[0].span()).collect()\n             } else {\n                 unreachable!()"}, {"sha": "5b7bef930d1d937ea303923e33a0236ec9956e34", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 71, "deletions": 5, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -812,9 +812,50 @@ mod loop_keyword { }\n //\n /// Control flow based on pattern matching.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// `match` can be used to run code conditionally. Every pattern must\n+/// be handled exhaustively either explicitly or by using wildcards like\n+/// `_` in the `match`. Since `match` is an expression, values can also be\n+/// returned.\n ///\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// ```rust\n+/// let opt = Option::None::<usize>;\n+/// let x = match opt {\n+///     Some(int) => int,\n+///     None => 10,\n+/// };\n+/// assert_eq!(x, 10);\n+///\n+/// let a_number = Option::Some(10);\n+/// match a_number {\n+///     Some(x) if x <= 5 => println!(\"0 to 5 num = {}\", x),\n+///     Some(x @ 6..=10) => println!(\"6 to 10 num = {}\", x),\n+///     None => panic!(),\n+///     // all other numbers\n+///     _ => panic!(),\n+/// }\n+/// ```\n+///\n+/// `match` can be used to gain access to the inner members of an enum\n+/// and use them directly.\n+///\n+/// ```rust\n+/// enum Outer {\n+///     Double(Option<u8>, Option<String>),\n+///     Single(Option<u8>),\n+///     Empty\n+/// }\n+///\n+/// let get_inner = Outer::Double(None, Some(String::new()));\n+/// match get_inner {\n+///     Outer::Double(None, Some(st)) => println!(\"{}\", st),\n+///     Outer::Single(opt) => println!(\"{:?}\", opt),\n+///     _ => panic!(),\n+/// }\n+/// ```\n+///\n+/// For more information on `match` and matching in general, see the [Reference].\n+///\n+/// [Reference]: ../reference/expressions/match-expr.html\n mod match_keyword { }\n \n #[doc(keyword = \"mod\")]\n@@ -831,10 +872,35 @@ mod mod_keyword { }\n //\n /// Capture a [closure]'s environment by value.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// `move` converts any variables captured by reference or mutable reference\n+/// to owned by value variables. The three [`Fn` trait]'s mirror the ways to capture\n+/// variables, when `move` is used, the closures is represented by the `FnOnce` trait.\n ///\n-/// [closure]: ../book/second-edition/ch13-01-closures.html\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// ```rust\n+/// let capture = \"hello\";\n+/// let closure = move || {\n+///     println!(\"rust says {}\", capture);\n+/// };\n+/// ```\n+///\n+/// `move` is often used when [threads] are involved.\n+///\n+/// ```rust\n+/// let x = 5;\n+///\n+/// std::thread::spawn(move || {\n+///     println!(\"captured {} by value\", x)\n+/// }).join().unwrap();\n+///\n+/// // x is no longer available\n+/// ```\n+///\n+/// For more information on the `move` keyword, see the [closure]'s section\n+/// of the Rust book or the [threads] section\n+///\n+/// [`Fn` trait]: ../std/ops/trait.Fn.html\n+/// [closure]: ../book/ch13-01-closures.html\n+/// [threads]: ../book/ch16-01-threads.html#using-move-closures-with-threads\n mod move_keyword { }\n \n #[doc(keyword = \"mut\")]"}, {"sha": "8018e005b12d72ee6c1e4da30dc2c4d49a8ef6a4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 84, "deletions": 25, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -27,7 +27,7 @@ pub use syntax_pos::symbol::{Ident, Symbol as Name};\n use crate::ptr::P;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n use crate::token::{self, DelimToken};\n-use crate::tokenstream::TokenStream;\n+use crate::tokenstream::{TokenStream, TokenTree, DelimSpan};\n \n use syntax_pos::symbol::{kw, sym, Symbol};\n use syntax_pos::{Span, DUMMY_SP, ExpnId};\n@@ -40,6 +40,7 @@ use rustc_index::vec::Idx;\n use rustc_serialize::{self, Decoder, Encoder};\n use rustc_macros::HashStable_Generic;\n \n+use std::iter;\n use std::fmt;\n \n #[cfg(test)]\n@@ -1372,34 +1373,89 @@ pub enum Movability {\n     Movable,\n }\n \n-/// Represents a macro invocation. The `Path` indicates which macro\n-/// is being invoked, and the vector of token-trees contains the source\n-/// of the macro invocation.\n-///\n-/// N.B., the additional ident for a `macro_rules`-style macro is actually\n-/// stored in the enclosing item.\n+/// Represents a macro invocation. The `path` indicates which macro\n+/// is being invoked, and the `args` are arguments passed to it.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Mac {\n     pub path: Path,\n-    pub delim: MacDelimiter,\n-    pub tts: TokenStream,\n-    pub span: Span,\n+    pub args: P<MacArgs>,\n     pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+impl Mac {\n+    pub fn span(&self) -> Span {\n+        self.path.span.to(self.args.span().unwrap_or(self.path.span))\n+    }\n+}\n+\n+/// Arguments passed to an attribute or a function-like macro.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+pub enum MacArgs {\n+    /// No arguments - `#[attr]`.\n+    Empty,\n+    /// Delimited arguments - `#[attr()/[]/{}]` or `mac!()/[]/{}`.\n+    Delimited(DelimSpan, MacDelimiter, TokenStream),\n+    /// Arguments of a key-value attribute - `#[attr = \"value\"]`.\n+    Eq(\n+        /// Span of the `=` token.\n+        Span,\n+        /// Token stream of the \"value\".\n+        TokenStream,\n+    ),\n+}\n+\n+impl MacArgs {\n+    pub fn delim(&self) -> DelimToken {\n+        match self {\n+            MacArgs::Delimited(_, delim, _) => delim.to_token(),\n+            MacArgs::Empty | MacArgs::Eq(..) => token::NoDelim,\n+        }\n+    }\n+\n+    pub fn span(&self) -> Option<Span> {\n+        match *self {\n+            MacArgs::Empty => None,\n+            MacArgs::Delimited(dspan, ..) => Some(dspan.entire()),\n+            MacArgs::Eq(eq_span, ref tokens) => Some(eq_span.to(tokens.span().unwrap_or(eq_span))),\n+        }\n+    }\n+\n+    /// Tokens inside the delimiters or after `=`.\n+    /// Proc macros see these tokens, for example.\n+    pub fn inner_tokens(&self) -> TokenStream {\n+        match self {\n+            MacArgs::Empty => TokenStream::default(),\n+            MacArgs::Delimited(.., tokens) |\n+            MacArgs::Eq(.., tokens) => tokens.clone(),\n+        }\n+    }\n+\n+    /// Tokens together with the delimiters or `=`.\n+    /// Use of this method generally means that something suboptimal or hacky is happening.\n+    pub fn outer_tokens(&self) -> TokenStream {\n+        match *self {\n+            MacArgs::Empty => TokenStream::default(),\n+            MacArgs::Delimited(dspan, delim, ref tokens) =>\n+                TokenTree::Delimited(dspan, delim.to_token(), tokens.clone()).into(),\n+            MacArgs::Eq(eq_span, ref tokens) => iter::once(TokenTree::token(token::Eq, eq_span))\n+                                                .chain(tokens.trees()).collect(),\n+        }\n+    }\n+\n+    /// Whether a macro with these arguments needs a semicolon\n+    /// when used as a standalone item or statement.\n+    pub fn need_semicolon(&self) -> bool {\n+        !matches!(self, MacArgs::Delimited(_, MacDelimiter::Brace ,_))\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum MacDelimiter {\n     Parenthesis,\n     Bracket,\n     Brace,\n }\n \n-impl Mac {\n-    pub fn stream(&self) -> TokenStream {\n-        self.tts.clone()\n-    }\n-}\n-\n impl MacDelimiter {\n     crate fn to_token(self) -> DelimToken {\n         match self {\n@@ -1408,22 +1464,25 @@ impl MacDelimiter {\n             MacDelimiter::Brace => DelimToken::Brace,\n         }\n     }\n+\n+    pub fn from_token(delim: DelimToken) -> Option<MacDelimiter> {\n+        match delim {\n+            token::Paren => Some(MacDelimiter::Parenthesis),\n+            token::Bracket => Some(MacDelimiter::Bracket),\n+            token::Brace => Some(MacDelimiter::Brace),\n+            token::NoDelim => None,\n+        }\n+    }\n }\n \n /// Represents a macro definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct MacroDef {\n-    pub tokens: TokenStream,\n+    pub body: P<MacArgs>,\n     /// `true` if macro was defined with `macro_rules`.\n     pub legacy: bool,\n }\n \n-impl MacroDef {\n-    pub fn stream(&self) -> TokenStream {\n-        self.tokens.clone().into()\n-    }\n-}\n-\n // Clippy uses Hash and PartialEq\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq, HashStable_Generic)]\n pub enum StrStyle {\n@@ -2323,7 +2382,7 @@ impl rustc_serialize::Decodable for AttrId {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct AttrItem {\n     pub path: Path,\n-    pub tokens: TokenStream,\n+    pub args: MacArgs,\n }\n \n /// Metadata associated with an item."}, {"sha": "079a0f6fafa2cba57e357162d9e0216cd0f026df", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 70, "deletions": 43, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -10,7 +10,7 @@ pub use crate::ast::Attribute;\n \n use crate::ast;\n use crate::ast::{AttrItem, AttrId, AttrKind, AttrStyle, Name, Ident, Path, PathSegment};\n-use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n+use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n use crate::source_map::{BytePos, Spanned};\n@@ -198,7 +198,7 @@ impl Attribute {\n \n     pub fn is_word(&self) -> bool {\n         if let AttrKind::Normal(item) = &self.kind {\n-            item.tokens.is_empty()\n+            matches!(item.args, MacArgs::Empty)\n         } else {\n             false\n         }\n@@ -278,17 +278,9 @@ impl MetaItem {\n \n impl AttrItem {\n     pub fn meta(&self, span: Span) -> Option<MetaItem> {\n-        let mut tokens = self.tokens.trees().peekable();\n         Some(MetaItem {\n             path: self.path.clone(),\n-            kind: if let Some(kind) = MetaItemKind::from_tokens(&mut tokens) {\n-                if tokens.peek().is_some() {\n-                    return None;\n-                }\n-                kind\n-            } else {\n-                return None;\n-            },\n+            kind: MetaItemKind::from_mac_args(&self.args)?,\n             span,\n         })\n     }\n@@ -362,8 +354,8 @@ crate fn mk_attr_id() -> AttrId {\n     AttrId(id)\n }\n \n-pub fn mk_attr(style: AttrStyle, path: Path, tokens: TokenStream, span: Span) -> Attribute {\n-    mk_attr_from_item(style, AttrItem { path, tokens }, span)\n+pub fn mk_attr(style: AttrStyle, path: Path, args: MacArgs, span: Span) -> Attribute {\n+    mk_attr_from_item(style, AttrItem { path, args }, span)\n }\n \n pub fn mk_attr_from_item(style: AttrStyle, item: AttrItem, span: Span) -> Attribute {\n@@ -377,12 +369,12 @@ pub fn mk_attr_from_item(style: AttrStyle, item: AttrItem, span: Span) -> Attrib\n \n /// Returns an inner attribute with the given value and span.\n pub fn mk_attr_inner(item: MetaItem) -> Attribute {\n-    mk_attr(AttrStyle::Inner, item.path, item.kind.tokens(item.span), item.span)\n+    mk_attr(AttrStyle::Inner, item.path, item.kind.mac_args(item.span), item.span)\n }\n \n /// Returns an outer attribute with the given value and span.\n pub fn mk_attr_outer(item: MetaItem) -> Attribute {\n-    mk_attr(AttrStyle::Outer, item.path, item.kind.tokens(item.span), item.span)\n+    mk_attr(AttrStyle::Outer, item.path, item.kind.mac_args(item.span), item.span)\n }\n \n pub fn mk_doc_comment(style: AttrStyle, comment: Symbol, span: Span) -> Attribute {\n@@ -520,7 +512,26 @@ impl MetaItem {\n }\n \n impl MetaItemKind {\n-    pub fn token_trees_and_joints(&self, span: Span) -> Vec<TreeAndJoint> {\n+    pub fn mac_args(&self, span: Span) -> MacArgs {\n+        match self {\n+            MetaItemKind::Word => MacArgs::Empty,\n+            MetaItemKind::NameValue(lit) => MacArgs::Eq(span, lit.token_tree().into()),\n+            MetaItemKind::List(list) => {\n+                let mut tts = Vec::new();\n+                for (i, item) in list.iter().enumerate() {\n+                    if i > 0 {\n+                        tts.push(TokenTree::token(token::Comma, span).into());\n+                    }\n+                    tts.extend(item.token_trees_and_joints())\n+                }\n+                MacArgs::Delimited(\n+                    DelimSpan::from_single(span), MacDelimiter::Parenthesis, TokenStream::new(tts)\n+                )\n+            }\n+        }\n+    }\n+\n+    fn token_trees_and_joints(&self, span: Span) -> Vec<TreeAndJoint> {\n         match *self {\n             MetaItemKind::Word => vec![],\n             MetaItemKind::NameValue(ref lit) => {\n@@ -548,33 +559,8 @@ impl MetaItemKind {\n         }\n     }\n \n-    // Premature conversions of `TokenTree`s to `TokenStream`s can hurt\n-    // performance. Do not use this function if `token_trees_and_joints()` can\n-    // be used instead.\n-    pub fn tokens(&self, span: Span) -> TokenStream {\n-        TokenStream::new(self.token_trees_and_joints(span))\n-    }\n-\n-    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItemKind>\n-        where I: Iterator<Item = TokenTree>,\n-    {\n-        let delimited = match tokens.peek().cloned() {\n-            Some(TokenTree::Token(token)) if token == token::Eq => {\n-                tokens.next();\n-                return if let Some(TokenTree::Token(token)) = tokens.next() {\n-                    Lit::from_token(&token).ok().map(MetaItemKind::NameValue)\n-                } else {\n-                    None\n-                };\n-            }\n-            Some(TokenTree::Delimited(_, delim, ref tts)) if delim == token::Paren => {\n-                tokens.next();\n-                tts.clone()\n-            }\n-            _ => return Some(MetaItemKind::Word),\n-        };\n-\n-        let mut tokens = delimited.into_trees().peekable();\n+    fn list_from_tokens(tokens: TokenStream) -> Option<MetaItemKind> {\n+        let mut tokens = tokens.into_trees().peekable();\n         let mut result = Vec::new();\n         while let Some(..) = tokens.peek() {\n             let item = NestedMetaItem::from_tokens(&mut tokens)?;\n@@ -586,6 +572,47 @@ impl MetaItemKind {\n         }\n         Some(MetaItemKind::List(result))\n     }\n+\n+    fn name_value_from_tokens(\n+        tokens: &mut impl Iterator<Item = TokenTree>,\n+    ) -> Option<MetaItemKind> {\n+        match tokens.next() {\n+            Some(TokenTree::Token(token)) =>\n+                Lit::from_token(&token).ok().map(MetaItemKind::NameValue),\n+            _ => None,\n+        }\n+    }\n+\n+    fn from_mac_args(args: &MacArgs) -> Option<MetaItemKind> {\n+        match args {\n+            MacArgs::Delimited(_, MacDelimiter::Parenthesis, tokens) =>\n+                MetaItemKind::list_from_tokens(tokens.clone()),\n+            MacArgs::Delimited(..) => None,\n+            MacArgs::Eq(_, tokens) => {\n+                assert!(tokens.len() == 1);\n+                MetaItemKind::name_value_from_tokens(&mut tokens.trees())\n+            }\n+            MacArgs::Empty => Some(MetaItemKind::Word),\n+        }\n+    }\n+\n+    fn from_tokens(\n+        tokens: &mut iter::Peekable<impl Iterator<Item = TokenTree>>,\n+    ) -> Option<MetaItemKind> {\n+        match tokens.peek() {\n+            Some(TokenTree::Delimited(_, token::Paren, inner_tokens)) => {\n+                let inner_tokens = inner_tokens.clone();\n+                tokens.next();\n+                MetaItemKind::list_from_tokens(inner_tokens)\n+            }\n+            Some(TokenTree::Delimited(..)) => None,\n+            Some(TokenTree::Token(Token { kind: token::Eq, .. })) => {\n+                tokens.next();\n+                MetaItemKind::name_value_from_tokens(tokens)\n+            }\n+            _ => Some(MetaItemKind::Word),\n+        }\n+    }\n }\n \n impl NestedMetaItem {"}, {"sha": "3dcdd4db6377a2b8173f5d7a2e5c5e68026c80f5", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -12,6 +12,7 @@\n #![feature(const_transmute)]\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n+#![feature(matches_macro)]\n #![feature(nll)]\n #![feature(try_trait)]\n #![feature(slice_patterns)]"}, {"sha": "8889e5df26c528b22dc46a90b4ff9add78e0d068", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -359,6 +359,26 @@ pub fn visit_fn_sig<T: MutVisitor>(FnSig { header, decl }: &mut FnSig, vis: &mut\n     vis.visit_fn_decl(decl);\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_mac_args<T: MutVisitor>(args: &mut MacArgs, vis: &mut T) {\n+    match args {\n+        MacArgs::Empty => {}\n+        MacArgs::Delimited(dspan, _delim, tokens) => {\n+            visit_delim_span(dspan, vis);\n+            vis.visit_tts(tokens);\n+        }\n+        MacArgs::Eq(eq_span, tokens) => {\n+            vis.visit_span(eq_span);\n+            vis.visit_tts(tokens);\n+        }\n+    }\n+}\n+\n+pub fn visit_delim_span<T: MutVisitor>(dspan: &mut DelimSpan, vis: &mut T) {\n+    vis.visit_span(&mut dspan.open);\n+    vis.visit_span(&mut dspan.close);\n+}\n+\n pub fn noop_flat_map_field_pattern<T: MutVisitor>(\n     mut fp: FieldPat,\n     vis: &mut T,\n@@ -550,25 +570,24 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n     let Attribute { kind, id: _, style: _, span } = attr;\n     match kind {\n-        AttrKind::Normal(AttrItem { path, tokens }) => {\n+        AttrKind::Normal(AttrItem { path, args }) => {\n             vis.visit_path(path);\n-            vis.visit_tts(tokens);\n+            visit_mac_args(args, vis);\n         }\n         AttrKind::DocComment(_) => {}\n     }\n     vis.visit_span(span);\n }\n \n pub fn noop_visit_mac<T: MutVisitor>(mac: &mut Mac, vis: &mut T) {\n-    let Mac { path, delim: _, tts, span, prior_type_ascription: _ } = mac;\n+    let Mac { path, args, prior_type_ascription: _ } = mac;\n     vis.visit_path(path);\n-    vis.visit_tts(tts);\n-    vis.visit_span(span);\n+    visit_mac_args(args, vis);\n }\n \n pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T) {\n-    let MacroDef { tokens, legacy: _ } = macro_def;\n-    vis.visit_tts(tokens);\n+    let MacroDef { body, legacy: _ } = macro_def;\n+    visit_mac_args(body, vis);\n }\n \n pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &mut T) {\n@@ -682,9 +701,9 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n         token::NtIdent(ident, _is_raw) => vis.visit_ident(ident),\n         token::NtLifetime(ident) => vis.visit_ident(ident),\n         token::NtLiteral(expr) => vis.visit_expr(expr),\n-        token::NtMeta(AttrItem { path, tokens }) => {\n+        token::NtMeta(AttrItem { path, args }) => {\n             vis.visit_path(path);\n-            vis.visit_tts(tokens);\n+            visit_mac_args(args, vis);\n         }\n         token::NtPath(path) => vis.visit_path(path),\n         token::NtTT(tt) => vis.visit_tt(tt),"}, {"sha": "4821bbd9ec6e2a63eb548f4936d05a1db3fee2c4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -1,6 +1,6 @@\n use crate::ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use crate::ast::{SelfKind, GenericBound, TraitBoundModifier};\n-use crate::ast::{Attribute, MacDelimiter, GenericArg};\n+use crate::ast::{Attribute, GenericArg, MacArgs};\n use crate::util::parser::{self, AssocOp, Fixity};\n use crate::util::comments;\n use crate::attr;\n@@ -639,17 +639,22 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n \n     fn print_attr_item(&mut self, item: &ast::AttrItem, span: Span) {\n         self.ibox(0);\n-        match item.tokens.trees().next() {\n-            Some(TokenTree::Delimited(_, delim, tts)) => {\n-                self.print_mac_common(\n-                    Some(MacHeader::Path(&item.path)), false, None, delim, tts, true, span\n-                );\n-            }\n-            tree => {\n+        match &item.args {\n+            MacArgs::Delimited(_, delim, tokens) => self.print_mac_common(\n+                Some(MacHeader::Path(&item.path)),\n+                false,\n+                None,\n+                delim.to_token(),\n+                tokens.clone(),\n+                true,\n+                span,\n+            ),\n+            MacArgs::Empty | MacArgs::Eq(..) => {\n                 self.print_path(&item.path, false, 0);\n-                if tree.is_some() {\n+                if let MacArgs::Eq(_, tokens) = &item.args {\n                     self.space();\n-                    self.print_tts(item.tokens.clone(), true);\n+                    self.word_space(\"=\");\n+                    self.print_tts(tokens.clone(), true);\n                 }\n             }\n         }\n@@ -1097,9 +1102,8 @@ impl<'a> State<'a> {\n             }\n             ast::ForeignItemKind::Macro(ref m) => {\n                 self.print_mac(m);\n-                match m.delim {\n-                    MacDelimiter::Brace => {},\n-                    _ => self.s.word(\";\")\n+                if m.args.need_semicolon() {\n+                    self.s.word(\";\");\n                 }\n             }\n         }\n@@ -1361,9 +1365,8 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::Mac(ref mac) => {\n                 self.print_mac(mac);\n-                match mac.delim {\n-                    MacDelimiter::Brace => {}\n-                    _ => self.s.word(\";\"),\n+                if mac.args.need_semicolon() {\n+                    self.s.word(\";\");\n                 }\n             }\n             ast::ItemKind::MacroDef(ref macro_def) => {\n@@ -1377,8 +1380,8 @@ impl<'a> State<'a> {\n                     Some(MacHeader::Keyword(kw)),\n                     has_bang,\n                     Some(item.ident),\n-                    DelimToken::Brace,\n-                    macro_def.stream(),\n+                    macro_def.body.delim(),\n+                    macro_def.body.inner_tokens(),\n                     true,\n                     item.span,\n                 );\n@@ -1578,9 +1581,8 @@ impl<'a> State<'a> {\n             }\n             ast::TraitItemKind::Macro(ref mac) => {\n                 self.print_mac(mac);\n-                match mac.delim {\n-                    MacDelimiter::Brace => {}\n-                    _ => self.s.word(\";\"),\n+                if mac.args.need_semicolon() {\n+                    self.s.word(\";\");\n                 }\n             }\n         }\n@@ -1608,9 +1610,8 @@ impl<'a> State<'a> {\n             }\n             ast::ImplItemKind::Macro(ref mac) => {\n                 self.print_mac(mac);\n-                match mac.delim {\n-                    MacDelimiter::Brace => {}\n-                    _ => self.s.word(\";\"),\n+                if mac.args.need_semicolon() {\n+                    self.s.word(\";\");\n                 }\n             }\n         }\n@@ -1775,10 +1776,10 @@ impl<'a> State<'a> {\n             Some(MacHeader::Path(&m.path)),\n             true,\n             None,\n-            m.delim.to_token(),\n-            m.stream(),\n+            m.args.delim(),\n+            m.args.inner_tokens(),\n             true,\n-            m.span,\n+            m.span(),\n         );\n     }\n "}, {"sha": "491b9a9ade47ac933e6187fd66a66ad00ee624fc", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -225,6 +225,14 @@ impl TokenStream {\n         self.0.len()\n     }\n \n+    pub fn span(&self) -> Option<Span> {\n+        match &**self.0 {\n+            [] => None,\n+            [(tt, _)] => Some(tt.span()),\n+            [(tt_start, _), .., (tt_end, _)] => Some(tt_start.span().to(tt_end.span())),\n+        }\n+    }\n+\n     pub fn from_streams(mut streams: SmallVec<[TokenStream; 2]>) -> TokenStream {\n         match streams.len() {\n             0 => TokenStream::default(),"}, {"sha": "4ee09b4b87afac146575b0d9ee10bb7f4fda96a5", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -841,11 +841,19 @@ pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n \n pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n     match attr.kind {\n-        AttrKind::Normal(ref item) => visitor.visit_tts(item.tokens.clone()),\n+        AttrKind::Normal(ref item) => walk_mac_args(visitor, &item.args),\n         AttrKind::DocComment(_) => {}\n     }\n }\n \n+pub fn walk_mac_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a MacArgs) {\n+    match args {\n+        MacArgs::Empty => {}\n+        MacArgs::Delimited(_dspan, _delim, tokens) => visitor.visit_tts(tokens.clone()),\n+        MacArgs::Eq(_eq_span, tokens) => visitor.visit_tts(tokens.clone()),\n+    }\n+}\n+\n pub fn walk_tt<'a, V: Visitor<'a>>(visitor: &mut V, tt: TokenTree) {\n     match tt {\n         TokenTree::Token(token) => visitor.visit_token(token),"}, {"sha": "9bfedb3b6174edf5eca8b32bb38dfa50a5e75af1", "filename": "src/libsyntax_expand/expand.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fexpand.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -11,7 +11,7 @@ use rustc_parse::DirectoryOwnership;\n use rustc_parse::parser::Parser;\n use rustc_parse::validate_attr;\n use syntax::ast::{self, AttrItem, Block, Ident, LitKind, NodeId, PatKind, Path};\n-use syntax::ast::{MacStmtStyle, StmtKind, ItemKind};\n+use syntax::ast::{MacArgs, MacStmtStyle, StmtKind, ItemKind};\n use syntax::attr::{self, HasAttrs, is_builtin_attr};\n use syntax::source_map::respan;\n use syntax::feature_gate::{self, feature_err};\n@@ -597,13 +597,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n                     self.gate_proc_macro_expansion_kind(span, fragment_kind);\n-                    let tok_result = expander.expand(self.cx, span, mac.stream());\n+                    let tok_result = expander.expand(self.cx, span, mac.args.inner_tokens());\n                     self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n                     let prev = self.cx.current_expansion.prior_type_ascription;\n                     self.cx.current_expansion.prior_type_ascription = mac.prior_type_ascription;\n-                    let tok_result = expander.expand(self.cx, span, mac.stream());\n+                    let tok_result = expander.expand(self.cx, span, mac.args.inner_tokens());\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n@@ -642,8 +642,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             => panic!(\"unexpected annotatable\"),\n                     })), DUMMY_SP).into();\n                     let item = attr.unwrap_normal_item();\n-                    let input = self.extract_proc_macro_attr_input(item.tokens, span);\n-                    let tok_result = expander.expand(self.cx, span, input, item_tok);\n+                    if let MacArgs::Eq(..) = item.args {\n+                        self.cx.span_err(span, \"key-value macro attributes are not supported\");\n+                    }\n+                    let tok_result =\n+                        expander.expand(self.cx, span, item.args.inner_tokens(), item_tok);\n                     self.parse_ast_fragment(tok_result, fragment_kind, &item.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n@@ -687,23 +690,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn extract_proc_macro_attr_input(&self, tokens: TokenStream, span: Span) -> TokenStream {\n-        let mut trees = tokens.trees();\n-        match trees.next() {\n-            Some(TokenTree::Delimited(_, _, tts)) => {\n-                if trees.next().is_none() {\n-                    return tts.into()\n-                }\n-            }\n-            Some(TokenTree::Token(..)) => {}\n-            None => return TokenStream::default(),\n-        }\n-        self.cx.span_err(span, \"custom attribute invocations must be \\\n-            of the form `#[foo]` or `#[foo(..)]`, the macro name must only be \\\n-            followed by a delimiter token\");\n-        TokenStream::default()\n-    }\n-\n     fn gate_proc_macro_attr_item(&self, span: Span, item: &Annotatable) {\n         let kind = match item {\n             Annotatable::Item(item) => match &item.kind {\n@@ -1560,7 +1546,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             let meta = attr::mk_list_item(Ident::with_dummy_span(sym::doc), items);\n             *at = attr::Attribute {\n                 kind: ast::AttrKind::Normal(\n-                    AttrItem { path: meta.path, tokens: meta.kind.tokens(meta.span) },\n+                    AttrItem { path: meta.path, args: meta.kind.mac_args(meta.span) },\n                 ),\n                 span: at.span,\n                 id: at.id,"}, {"sha": "e3c3655bcf882c634d7d136dfef275db18339955", "filename": "src/libsyntax_expand/mbe/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -318,8 +318,8 @@ pub fn compile_declarative_macro(\n     let tt_spec = ast::Ident::new(sym::tt, def.span);\n \n     // Parse the macro_rules! invocation\n-    let body = match def.kind {\n-        ast::ItemKind::MacroDef(ref body) => body,\n+    let (is_legacy, body) = match &def.kind {\n+        ast::ItemKind::MacroDef(macro_def) => (macro_def.legacy, macro_def.body.inner_tokens()),\n         _ => unreachable!(),\n     };\n \n@@ -338,7 +338,7 @@ pub fn compile_declarative_macro(\n                     mbe::TokenTree::MetaVarDecl(def.span, rhs_nm, tt_spec),\n                 ],\n                 separator: Some(Token::new(\n-                    if body.legacy { token::Semi } else { token::Comma },\n+                    if is_legacy { token::Semi } else { token::Comma },\n                     def.span,\n                 )),\n                 kleene: mbe::KleeneToken::new(mbe::KleeneOp::OneOrMore, def.span),\n@@ -350,7 +350,7 @@ pub fn compile_declarative_macro(\n             DelimSpan::dummy(),\n             Lrc::new(mbe::SequenceRepetition {\n                 tts: vec![mbe::TokenTree::token(\n-                    if body.legacy { token::Semi } else { token::Comma },\n+                    if is_legacy { token::Semi } else { token::Comma },\n                     def.span,\n                 )],\n                 separator: None,\n@@ -360,7 +360,7 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let argument_map = match parse(sess, body.stream(), &argument_gram, None, true) {\n+    let argument_map = match parse(sess, body, &argument_gram, None, true) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n@@ -435,7 +435,7 @@ pub fn compile_declarative_macro(\n     // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n     valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n \n-    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, body.legacy);\n+    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, is_legacy);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) =>\n             diag.span_err(span, &format!(\"unknown macro transparency: `{}`\", value)),"}, {"sha": "a1157667df1b438fd192bc47a0efaf58023ee570", "filename": "src/libsyntax_expand/mbe/transcribe.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe%2Ftranscribe.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -30,13 +30,6 @@ impl MutVisitor for Marker {\n     }\n }\n \n-impl Marker {\n-    fn visit_delim_span(&mut self, dspan: &mut DelimSpan) {\n-        self.visit_span(&mut dspan.open);\n-        self.visit_span(&mut dspan.close);\n-    }\n-}\n-\n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n     Delimited { forest: Lrc<mbe::Delimited>, idx: usize, span: DelimSpan },\n@@ -271,7 +264,7 @@ pub(super) fn transcribe(\n             // jump back out of the Delimited, pop the result_stack and add the new results back to\n             // the previous results (from outside the Delimited).\n             mbe::TokenTree::Delimited(mut span, delimited) => {\n-                marker.visit_delim_span(&mut span);\n+                mut_visit::visit_delim_span(&mut span, &mut marker);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span });\n                 result_stack.push(mem::take(&mut result));\n             }"}, {"sha": "30e83c151e255f347503b5e9edafb6ab3e0b5b44", "filename": "src/libsyntax_expand/parse/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fparse%2Ftests.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -272,7 +272,7 @@ fn ttdelim_span() {\n             \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n \n         let tts: Vec<_> = match expr.kind {\n-            ast::ExprKind::Mac(ref mac) => mac.stream().trees().collect(),\n+            ast::ExprKind::Mac(ref mac) => mac.args.inner_tokens().trees().collect(),\n             _ => panic!(\"not a macro\"),\n         };\n "}, {"sha": "74ade1de20e2a355cab5236db0b5d2982a0a828b", "filename": "src/libsyntax_expand/placeholders.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fplaceholders.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -3,7 +3,6 @@ use crate::expand::{AstFragment, AstFragmentKind};\n \n use syntax::ast;\n use syntax::source_map::{DUMMY_SP, dummy_spanned};\n-use syntax::tokenstream::TokenStream;\n use syntax::mut_visit::*;\n use syntax::ptr::P;\n use syntax::ThinVec;\n@@ -17,9 +16,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId, vis: Option<ast::Visi\n     fn mac_placeholder() -> ast::Mac {\n         ast::Mac {\n             path: ast::Path { span: DUMMY_SP, segments: Vec::new() },\n-            tts: TokenStream::default().into(),\n-            delim: ast::MacDelimiter::Brace,\n-            span: DUMMY_SP,\n+            args: P(ast::MacArgs::Empty),\n             prior_type_ascription: None,\n         }\n     }"}, {"sha": "8e56e2bb00b4b19b0b4be46370a197e5bdc23b6f", "filename": "src/libsyntax_expand/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fproc_macro.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -1,7 +1,7 @@\n use crate::base::{self, *};\n use crate::proc_macro_server;\n \n-use syntax::ast::{self, ItemKind};\n+use syntax::ast::{self, ItemKind, MacArgs};\n use syntax::errors::{Applicability, FatalError};\n use syntax::symbol::sym;\n use syntax::token;\n@@ -183,7 +183,7 @@ crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>)\n         }\n \n         let parse_derive_paths = |attr: &ast::Attribute| {\n-            if attr.get_normal_item().tokens.is_empty() {\n+            if let MacArgs::Empty = attr.get_normal_item().args {\n                 return Ok(Vec::new());\n             }\n             rustc_parse::parse_in_attr(cx.parse_sess, attr, |p| p.parse_derive_paths())"}, {"sha": "c788d062994050d04edc15e51305494601c1524a", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -6,7 +6,7 @@ use syntax::token::{self, TokenKind};\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::symbol::{sym, Symbol};\n-use syntax::tokenstream::{TokenStream, TokenTree};\n+use syntax::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use syntax_expand::base::*;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -26,19 +26,19 @@ pub fn expand_assert<'cx>(\n     // `core::panic` and `std::panic` are different macros, so we use call-site\n     // context to pick up whichever is currently in scope.\n     let sp = cx.with_call_site_ctxt(sp);\n+    let tokens = custom_message.unwrap_or_else(|| {\n+        TokenStream::from(TokenTree::token(\n+            TokenKind::lit(token::Str, Symbol::intern(&format!(\n+                \"assertion failed: {}\",\n+                pprust::expr_to_string(&cond_expr).escape_debug()\n+            )), None),\n+            DUMMY_SP,\n+        ))\n+    });\n+    let args = P(MacArgs::Delimited(DelimSpan::from_single(sp), MacDelimiter::Parenthesis, tokens));\n     let panic_call = Mac {\n         path: Path::from_ident(Ident::new(sym::panic, sp)),\n-        tts: custom_message.unwrap_or_else(|| {\n-            TokenStream::from(TokenTree::token(\n-                TokenKind::lit(token::Str, Symbol::intern(&format!(\n-                    \"assertion failed: {}\",\n-                    pprust::expr_to_string(&cond_expr).escape_debug()\n-                )), None),\n-                DUMMY_SP,\n-            ))\n-        }).into(),\n-        delim: MacDelimiter::Parenthesis,\n-        span: sp,\n+        args,\n         prior_type_ascription: None,\n     };\n     let if_expr = cx.expr_if("}, {"sha": "98cf8a34742e57c140f2f330587b8a9c6fabf198", "filename": "src/libsyntax_ext/cmdline_attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_ext%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_ext%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcmdline_attrs.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -16,15 +16,15 @@ pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -\n         );\n \n         let start_span = parser.token.span;\n-        let AttrItem { path, tokens } = panictry!(parser.parse_attr_item());\n+        let AttrItem { path, args } = panictry!(parser.parse_attr_item());\n         let end_span = parser.token.span;\n         if parser.token != token::Eof {\n             parse_sess.span_diagnostic\n                 .span_err(start_span.to(end_span), \"invalid crate attribute\");\n             continue;\n         }\n \n-        krate.attrs.push(mk_attr(AttrStyle::Inner, path, tokens, start_span.to(end_span)));\n+        krate.attrs.push(mk_attr(AttrStyle::Inner, path, args, start_span.to(end_span)));\n     }\n \n     krate"}, {"sha": "5bd84b43a7801bd14d99dc5bd13739cb7fc14a96", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -340,14 +340,12 @@ pub fn combine_substructure(f: CombineSubstructureFunc<'_>)\n fn find_type_parameters(\n     ty: &ast::Ty,\n     ty_param_names: &[ast::Name],\n-    span: Span,\n     cx: &ExtCtxt<'_>,\n ) -> Vec<P<ast::Ty>> {\n     use syntax::visit;\n \n     struct Visitor<'a, 'b> {\n         cx: &'a ExtCtxt<'b>,\n-        span: Span,\n         ty_param_names: &'a [ast::Name],\n         types: Vec<P<ast::Ty>>,\n     }\n@@ -366,18 +364,11 @@ fn find_type_parameters(\n         }\n \n         fn visit_mac(&mut self, mac: &ast::Mac) {\n-            let span = mac.span.with_ctxt(self.span.ctxt());\n-            self.cx.span_err(span, \"`derive` cannot be used on items with type macros\");\n+            self.cx.span_err(mac.span(), \"`derive` cannot be used on items with type macros\");\n         }\n     }\n \n-    let mut visitor = Visitor {\n-        ty_param_names,\n-        types: Vec::new(),\n-        span,\n-        cx,\n-    };\n-\n+    let mut visitor = Visitor { cx, ty_param_names, types: Vec::new() };\n     visit::Visitor::visit_ty(&mut visitor, ty);\n \n     visitor.types\n@@ -605,7 +596,7 @@ impl<'a> TraitDef<'a> {\n                     .collect();\n \n                 for field_ty in field_tys {\n-                    let tys = find_type_parameters(&field_ty, &ty_param_names, self.span, cx);\n+                    let tys = find_type_parameters(&field_ty, &ty_param_names, cx);\n \n                     for ty in tys {\n                         // if we have already handled this type, skip it"}, {"sha": "88a325112ac6c7867f5a6bf844fcc9f782216a18", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -280,6 +280,7 @@ symbols! {\n         Err,\n         Eq,\n         Equal,\n+        enclosing_scope,\n         except,\n         exclusive_range_pattern,\n         exhaustive_integer_patterns,"}, {"sha": "46f8f41076bf59679b368ed13f7fb3aabc136b6f", "filename": "src/test/ui/async-await/try-on-option-in-async.stderr", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -1,26 +1,44 @@\n error[E0277]: the `?` operator can only be used in an async block that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n   --> $DIR/try-on-option-in-async.rs:8:9\n    |\n-LL |         x?;\n-   |         ^^ cannot use the `?` operator in an async block that returns `{integer}`\n+LL |       async {\n+   |  ___________-\n+LL | |         let x: Option<u32> = None;\n+LL | |         x?;\n+   | |         ^^ cannot use the `?` operator in an async block that returns `{integer}`\n+LL | |         22\n+LL | |     }.await\n+   | |_____- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `{integer}`\n    = note: required by `std::ops::Try::from_error`\n \n error[E0277]: the `?` operator can only be used in an async closure that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n   --> $DIR/try-on-option-in-async.rs:16:9\n    |\n-LL |         x?;\n-   |         ^^ cannot use the `?` operator in an async closure that returns `u32`\n+LL |       let async_closure = async || {\n+   |  __________________________________-\n+LL | |         let x: Option<u32> = None;\n+LL | |         x?;\n+   | |         ^^ cannot use the `?` operator in an async closure that returns `u32`\n+LL | |         22_u32\n+LL | |     };\n+   | |_____- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `u32`\n    = note: required by `std::ops::Try::from_error`\n \n error[E0277]: the `?` operator can only be used in an async function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n   --> $DIR/try-on-option-in-async.rs:25:5\n    |\n-LL |     x?;\n-   |     ^^ cannot use the `?` operator in an async function that returns `u32`\n+LL |   async fn an_async_function() -> u32 {\n+   |  _____________________________________-\n+LL | |     let x: Option<u32> = None;\n+LL | |     x?;\n+   | |     ^^ cannot use the `?` operator in an async function that returns `u32`\n+LL | |     22\n+LL | | }\n+   | |_- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `u32`\n    = note: required by `std::ops::Try::from_error`"}, {"sha": "f536d8f940a93871936a4b9172cb0ea5d38b6710", "filename": "src/test/ui/issues/issue-10536.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -11,9 +11,9 @@ macro_rules! foo{\n pub fn main() {\n     foo!();\n \n-    assert!({one! two()}); //~ ERROR expected open delimiter\n+    assert!({one! two()}); //~ ERROR expected one of `(`, `[`, or `{`, found `two`\n \n     // regardless of whether nested macro_rules works, the following should at\n     // least throw a conventional error.\n-    assert!({one! two}); //~ ERROR expected open delimiter\n+    assert!({one! two}); //~ ERROR expected one of `(`, `[`, or `{`, found `two`\n }"}, {"sha": "cc048445871a4bb0a8624250ed5cdaddf8e7755b", "filename": "src/test/ui/issues/issue-10536.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -1,14 +1,14 @@\n-error: expected open delimiter\n+error: expected one of `(`, `[`, or `{`, found `two`\n   --> $DIR/issue-10536.rs:14:19\n    |\n LL |     assert!({one! two()});\n-   |                   ^^^ expected open delimiter\n+   |                   ^^^ expected one of `(`, `[`, or `{`\n \n-error: expected open delimiter\n+error: expected one of `(`, `[`, or `{`, found `two`\n   --> $DIR/issue-10536.rs:18:19\n    |\n LL |     assert!({one! two});\n-   |                   ^^^ expected open delimiter\n+   |                   ^^^ expected one of `(`, `[`, or `{`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "881bff63f5f63974cebc462cf46fc7e6eafae95e", "filename": "src/test/ui/on-unimplemented/enclosing-scope.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fon-unimplemented%2Fenclosing-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fon-unimplemented%2Fenclosing-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fenclosing-scope.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -0,0 +1,27 @@\n+// Test scope annotations from `enclosing_scope` parameter\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_on_unimplemented(enclosing_scope=\"in this scope\")]\n+trait Trait{}\n+\n+struct Foo;\n+\n+fn f<T: Trait>(x: T) {}\n+\n+fn main() {\n+    let x = || {\n+        f(Foo{}); //~ ERROR the trait bound `Foo: Trait` is not satisfied\n+        let y = || {\n+            f(Foo{}); //~ ERROR the trait bound `Foo: Trait` is not satisfied\n+        };\n+    };\n+\n+    {\n+        {\n+            f(Foo{}); //~ ERROR the trait bound `Foo: Trait` is not satisfied\n+        }\n+    }\n+\n+    f(Foo{}); //~ ERROR the trait bound `Foo: Trait` is not satisfied\n+}"}, {"sha": "092e560330b4c55b40bd48da96989a528212ed80", "filename": "src/test/ui/on-unimplemented/enclosing-scope.stderr", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fon-unimplemented%2Fenclosing-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fon-unimplemented%2Fenclosing-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fenclosing-scope.stderr?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -0,0 +1,66 @@\n+error[E0277]: the trait bound `Foo: Trait` is not satisfied\n+  --> $DIR/enclosing-scope.rs:14:11\n+   |\n+LL |   fn f<T: Trait>(x: T) {}\n+   |      -    ----- required by this bound in `f`\n+...\n+LL |       let x = || {\n+   |  _____________-\n+LL | |         f(Foo{});\n+   | |           ^^^^^ the trait `Trait` is not implemented for `Foo`\n+LL | |         let y = || {\n+LL | |             f(Foo{});\n+LL | |         };\n+LL | |     };\n+   | |_____- in this scope\n+\n+error[E0277]: the trait bound `Foo: Trait` is not satisfied\n+  --> $DIR/enclosing-scope.rs:16:15\n+   |\n+LL |   fn f<T: Trait>(x: T) {}\n+   |      -    ----- required by this bound in `f`\n+...\n+LL |           let y = || {\n+   |  _________________-\n+LL | |             f(Foo{});\n+   | |               ^^^^^ the trait `Trait` is not implemented for `Foo`\n+LL | |         };\n+   | |_________- in this scope\n+\n+error[E0277]: the trait bound `Foo: Trait` is not satisfied\n+  --> $DIR/enclosing-scope.rs:22:15\n+   |\n+LL |   fn f<T: Trait>(x: T) {}\n+   |      -    ----- required by this bound in `f`\n+LL | \n+LL | / fn main() {\n+LL | |     let x = || {\n+LL | |         f(Foo{});\n+LL | |         let y = || {\n+...  |\n+LL | |             f(Foo{});\n+   | |               ^^^^^ the trait `Trait` is not implemented for `Foo`\n+...  |\n+LL | |     f(Foo{});\n+LL | | }\n+   | |_- in this scope\n+\n+error[E0277]: the trait bound `Foo: Trait` is not satisfied\n+  --> $DIR/enclosing-scope.rs:26:7\n+   |\n+LL |   fn f<T: Trait>(x: T) {}\n+   |      -    ----- required by this bound in `f`\n+LL | \n+LL | / fn main() {\n+LL | |     let x = || {\n+LL | |         f(Foo{});\n+LL | |         let y = || {\n+...  |\n+LL | |     f(Foo{});\n+   | |       ^^^^^ the trait `Trait` is not implemented for `Foo`\n+LL | | }\n+   | |_- in this scope\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "ce0fe6fc2a3751e05559b1d7b167e1f39c1cbcfd", "filename": "src/test/ui/or-patterns/exhaustiveness-pass.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -6,35 +6,40 @@\n // We wrap patterns in a tuple because top-level or-patterns are special-cased for now.\n fn main() {\n     // Get the fatal error out of the way\n-    match (0u8,) {\n+    match (0,) {\n         (0 | _,) => {}\n         //~^ ERROR or-patterns are not fully implemented yet\n     }\n \n-    match (0u8,) {\n+    match (0,) {\n         (1 | 2,) => {}\n         _ => {}\n     }\n \n-    match (0u8,) {\n-        (1 | 1,) => {} // FIXME(or_patterns): redundancy not detected for now.\n-        _ => {}\n-    }\n-    match (0u8, 0u8) {\n+    match (0, 0) {\n         (1 | 2, 3 | 4) => {}\n         (1, 2) => {}\n-        (2, 1) => {}\n+        (3, 1) => {}\n         _ => {}\n     }\n     match (Some(0u8),) {\n         (None | Some(0 | 1),) => {}\n         (Some(2..=255),) => {}\n     }\n-    match ((0u8,),) {\n+    match ((0,),) {\n         ((0 | 1,) | (2 | 3,),) => {},\n         ((_,),) => {},\n     }\n     match (&[0u8][..],) {\n         ([] | [0 | 1..=255] | [_, ..],) => {},\n     }\n+\n+    match ((0, 0),) {\n+        ((0, 0) | (0, 1),) => {}\n+        _ => {}\n+    }\n+    match ((0, 0),) {\n+        ((0, 0) | (1, 0),) => {}\n+        _ => {}\n+    }\n }"}, {"sha": "860c7a1bde5fbb6740b68a82b061d90d017edc6f", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -48,4 +48,32 @@ fn main() {\n         ((1..=4,),) => {}, //~ ERROR unreachable pattern\n         _ => {},\n     }\n+\n+    match (0,) {\n+        (1\n+         | 1,) => {} //~ ERROR unreachable\n+        _ => {}\n+    }\n+    match [0; 2] {\n+        [0\n+            | 0 //~ ERROR unreachable\n+        , 0\n+            | 0] => {} //~ ERROR unreachable\n+        _ => {}\n+    }\n+    match &[][..] {\n+        [0] => {}\n+        [0, _] => {}\n+        [0, _, _] => {}\n+        [1, ..] => {}\n+        [1 //~ ERROR unreachable\n+            | 2, ..] => {}\n+        _ => {}\n+    }\n+    match Some(0) {\n+        Some(0) => {}\n+        Some(0 //~ ERROR unreachable\n+             | 1) => {}\n+        _ => {}\n+    }\n }"}, {"sha": "87f69a484bbbcf89319a1471c7b2407cd1ec6f01", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -70,11 +70,41 @@ error: unreachable pattern\n LL |         ((1..=4,),) => {},\n    |         ^^^^^^^^^^^\n \n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:54:12\n+   |\n+LL |          | 1,) => {}\n+   |            ^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:61:15\n+   |\n+LL |             | 0] => {}\n+   |               ^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:59:15\n+   |\n+LL |             | 0\n+   |               ^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:69:10\n+   |\n+LL |         [1\n+   |          ^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:75:14\n+   |\n+LL |         Some(0\n+   |              ^\n+\n error: or-patterns are not fully implemented yet\n   --> $DIR/exhaustiveness-unreachable-pattern.rs:10:10\n    |\n LL |         (0 | _,) => {}\n    |          ^^^^^\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "f461f06b4dca6d9ff15cf5039f6207cb99ecaf63", "filename": "src/test/ui/parser/macro-bad-delimiter-ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -1,3 +1,3 @@\n fn main() {\n-    foo! bar < //~ ERROR expected open delimiter\n+    foo! bar < //~ ERROR expected one of `(`, `[`, or `{`, found `bar`\n }"}, {"sha": "f2365fed273b19dbaab6e7e9e91422350302c65d", "filename": "src/test/ui/parser/macro-bad-delimiter-ident.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.stderr?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -1,8 +1,8 @@\n-error: expected open delimiter\n+error: expected one of `(`, `[`, or `{`, found `bar`\n   --> $DIR/macro-bad-delimiter-ident.rs:2:10\n    |\n LL |     foo! bar <\n-   |          ^^^ expected open delimiter\n+   |          ^^^ expected one of `(`, `[`, or `{`\n \n error: aborting due to previous error\n "}, {"sha": "4b47b978930f30c6e6c21d2f734ccf35296fb912", "filename": "src/test/ui/pattern/usefulness/top-level-alternation.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -0,0 +1,56 @@\n+#![deny(unreachable_patterns)]\n+\n+fn main() {\n+    while let 0..=2 | 1 = 0 {} //~ ERROR unreachable pattern\n+    if let 0..=2 | 1 = 0 {} //~ ERROR unreachable pattern\n+\n+    match 0u8 {\n+        0\n+            | 0 => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+    match Some(0u8) {\n+        Some(0)\n+            | Some(0) => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+    match (0u8, 0u8) {\n+        (0, _) | (_, 0) => {}\n+        (0, 0) => {} //~ ERROR unreachable pattern\n+        (1, 1) => {}\n+        _ => {}\n+    }\n+    match (0u8, 0u8) {\n+        (0, 1) | (2, 3) => {}\n+        (0, 3) => {}\n+        (2, 1) => {}\n+        _ => {}\n+    }\n+    match (0u8, 0u8) {\n+        (_, 0) | (_, 1) => {}\n+        _ => {}\n+    }\n+    match (0u8, 0u8) {\n+        (0, _) | (1, _) => {}\n+        _ => {}\n+    }\n+    match Some(0u8) {\n+        None | Some(_) => {}\n+        _ => {} //~ ERROR unreachable pattern\n+    }\n+    match Some(0u8) {\n+        None | Some(_) => {}\n+        Some(_) => {} //~ ERROR unreachable pattern\n+        None => {} //~ ERROR unreachable pattern\n+    }\n+    match Some(0u8) {\n+        Some(_) => {}\n+        None => {}\n+        None | Some(_) => {} //~ ERROR unreachable pattern\n+    }\n+    match 0u8 {\n+        1 | 2 => {},\n+        1..=2 => {}, //~ ERROR unreachable pattern\n+        _ => {},\n+    }\n+}"}, {"sha": "7c7c4fc4eba28ae65112190ace97a72bfa523515", "filename": "src/test/ui/pattern/usefulness/top-level-alternation.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -0,0 +1,68 @@\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:4:23\n+   |\n+LL |     while let 0..=2 | 1 = 0 {}\n+   |                       ^\n+   |\n+note: lint level defined here\n+  --> $DIR/top-level-alternation.rs:1:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:5:20\n+   |\n+LL |     if let 0..=2 | 1 = 0 {}\n+   |                    ^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:9:15\n+   |\n+LL |             | 0 => {}\n+   |               ^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:14:15\n+   |\n+LL |             | Some(0) => {}\n+   |               ^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:19:9\n+   |\n+LL |         (0, 0) => {}\n+   |         ^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:39:9\n+   |\n+LL |         _ => {}\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:43:9\n+   |\n+LL |         Some(_) => {}\n+   |         ^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:44:9\n+   |\n+LL |         None => {}\n+   |         ^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:49:9\n+   |\n+LL |         None | Some(_) => {}\n+   |         ^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:53:9\n+   |\n+LL |         1..=2 => {},\n+   |         ^^^^^\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "591c1e039bd7579b8406ed0bf2f5bba7aafb1eea", "filename": "src/test/ui/proc-macro/proc-macro-gates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -18,7 +18,7 @@ mod _test2_inner {\n           //~| ERROR: non-builtin inner attributes are unstable\n }\n \n-#[empty_attr = \"y\"] //~ ERROR: must only be followed by a delimiter token\n+#[empty_attr = \"y\"] //~ ERROR: key-value macro attributes are not supported\n fn _test3() {}\n \n fn attrs() {"}, {"sha": "e939434243b6a1d6c31c1feec1e440cbe614ff49", "filename": "src/test/ui/proc-macro/proc-macro-gates.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -34,7 +34,7 @@ LL |     #![empty_attr]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n \n-error: custom attribute invocations must be of the form `#[foo]` or `#[foo(..)]`, the macro name must only be followed by a delimiter token\n+error: key-value macro attributes are not supported\n   --> $DIR/proc-macro-gates.rs:21:1\n    |\n LL | #[empty_attr = \"y\"]"}, {"sha": "1143bddfe45a35c60734c265b32b46484d28ec1b", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -575,8 +575,17 @@ LL |     if (let 0 = 0)? {}\n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n   --> $DIR/disallowed-positions.rs:46:8\n    |\n-LL |     if (let 0 = 0)? {}\n-   |        ^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`\n+LL | / fn nested_within_if_expr() {\n+LL | |     if &let 0 = 0 {}\n+LL | |\n+LL | |\n+...  |\n+LL | |     if (let 0 = 0)? {}\n+   | |        ^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`\n+...  |\n+LL | |     if let true = let true = true {}\n+LL | | }\n+   | |_- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `()`\n    = note: required by `std::ops::Try::from_error`\n@@ -754,8 +763,17 @@ LL |     while (let 0 = 0)? {}\n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n   --> $DIR/disallowed-positions.rs:110:11\n    |\n-LL |     while (let 0 = 0)? {}\n-   |           ^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`\n+LL | / fn nested_within_while_expr() {\n+LL | |     while &let 0 = 0 {}\n+LL | |\n+LL | |\n+...  |\n+LL | |     while (let 0 = 0)? {}\n+   | |           ^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`\n+...  |\n+LL | |     while let true = let true = true {}\n+LL | | }\n+   | |_- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `()`\n    = note: required by `std::ops::Try::from_error`\n@@ -924,8 +942,17 @@ LL |     (let 0 = 0)?;\n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n   --> $DIR/disallowed-positions.rs:183:5\n    |\n-LL |     (let 0 = 0)?;\n-   |     ^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`\n+LL | / fn outside_if_and_while_expr() {\n+LL | |     &let 0 = 0;\n+LL | |\n+LL | |     !let 0 = 0;\n+...  |\n+LL | |     (let 0 = 0)?;\n+   | |     ^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`\n+...  |\n+LL | |\n+LL | | }\n+   | |_- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `()`\n    = note: required by `std::ops::Try::from_error`"}, {"sha": "ce3aca39fb8fb453184f075721c6604faeece6ed", "filename": "src/test/ui/try-on-option-diagnostics.stderr", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Ftry-on-option-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Ftry-on-option-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-on-option-diagnostics.stderr?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -1,17 +1,28 @@\n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n   --> $DIR/try-on-option-diagnostics.rs:7:5\n    |\n-LL |     x?;\n-   |     ^^ cannot use the `?` operator in a function that returns `u32`\n+LL | / fn a_function() -> u32 {\n+LL | |     let x: Option<u32> = None;\n+LL | |     x?;\n+   | |     ^^ cannot use the `?` operator in a function that returns `u32`\n+LL | |     22\n+LL | | }\n+   | |_- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `u32`\n    = note: required by `std::ops::Try::from_error`\n \n error[E0277]: the `?` operator can only be used in a closure that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n   --> $DIR/try-on-option-diagnostics.rs:14:9\n    |\n-LL |         x?;\n-   |         ^^ cannot use the `?` operator in a closure that returns `{integer}`\n+LL |       let a_closure = || {\n+   |  _____________________-\n+LL | |         let x: Option<u32> = None;\n+LL | |         x?;\n+   | |         ^^ cannot use the `?` operator in a closure that returns `{integer}`\n+LL | |         22\n+LL | |     };\n+   | |_____- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `{integer}`\n    = note: required by `std::ops::Try::from_error`"}, {"sha": "07615b52a48a5c77a0a9e6530ae0caae5817e1f2", "filename": "src/test/ui/try-on-option.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Ftry-on-option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Ftry-on-option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-on-option.stderr?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -10,8 +10,13 @@ LL |     x?;\n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n   --> $DIR/try-on-option.rs:13:5\n    |\n-LL |     x?;\n-   |     ^^ cannot use the `?` operator in a function that returns `u32`\n+LL | / fn bar() -> u32 {\n+LL | |     let x: Option<u32> = None;\n+LL | |     x?;\n+   | |     ^^ cannot use the `?` operator in a function that returns `u32`\n+LL | |     22\n+LL | | }\n+   | |_- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `u32`\n    = note: required by `std::ops::Try::from_error`"}, {"sha": "d8ba264583e45b56b8381f606787207cc53c3f30", "filename": "src/test/ui/try-operator-on-main.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Ftry-operator-on-main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050/src%2Ftest%2Fui%2Ftry-operator-on-main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-operator-on-main.stderr?ref=f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "patch": "@@ -1,8 +1,15 @@\n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n   --> $DIR/try-operator-on-main.rs:9:5\n    |\n-LL |     std::fs::File::open(\"foo\")?;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`\n+LL | / fn main() {\n+LL | |     // error for a `Try` type on a non-`Try` fn\n+LL | |     std::fs::File::open(\"foo\")?;\n+   | |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`\n+LL | |\n+...  |\n+LL | |     try_trait_generic::<()>();\n+LL | | }\n+   | |_- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `()`\n    = note: required by `std::ops::Try::from_error`"}]}