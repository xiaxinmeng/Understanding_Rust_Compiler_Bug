{"sha": "2fee28e7138d8753487ed8895ce0f5f2e643ffad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZWUyOGU3MTM4ZDg3NTM0ODdlZDg4OTVjZTBmNWYyZTY0M2ZmYWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-12-13T00:47:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-12-13T00:51:25Z"}, "message": "std: Implement `LineWriter::write_vectored`\n\nThis commit implements the `write_vectored` method of the `LineWriter`\ntype. First discovered in bytecodealliance/wasmtime#629 the\n`write_vectored` method of `Stdout` bottoms out here but only ends up\nwriting the first buffer due to the default implementation of\n`write_vectored`.\n\nLike `BufWriter`, however, `LineWriter` can have a non-default\nimplementation of `write_vectored` which tries to preserve the\nvectored-ness as much as possible. Namely we can have a vectored write\nfor everything before the newline and everything after the newline if\nall the stars align well.\n\nAlso like `BufWriter`, though, special care is taken to ensure that\nwhenever bytes are written we're sure to signal success since that\nrepresents a \"commit\" of writing bytes.", "tree": {"sha": "ee10ae4040b5ac9c602e070c3a61dbd607c75f38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee10ae4040b5ac9c602e070c3a61dbd607c75f38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fee28e7138d8753487ed8895ce0f5f2e643ffad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fee28e7138d8753487ed8895ce0f5f2e643ffad", "html_url": "https://github.com/rust-lang/rust/commit/2fee28e7138d8753487ed8895ce0f5f2e643ffad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fee28e7138d8753487ed8895ce0f5f2e643ffad/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9469a6aec2f49fa1e2ae670649f293866932253", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9469a6aec2f49fa1e2ae670649f293866932253", "html_url": "https://github.com/rust-lang/rust/commit/e9469a6aec2f49fa1e2ae670649f293866932253"}], "stats": {"total": 172, "additions": 171, "deletions": 1}, "files": [{"sha": "df259dc2f56d7cf9587dec57160da47a99d1fb48", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 171, "deletions": 1, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/2fee28e7138d8753487ed8895ce0f5f2e643ffad/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fee28e7138d8753487ed8895ce0f5f2e643ffad/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=2fee28e7138d8753487ed8895ce0f5f2e643ffad", "patch": "@@ -989,6 +989,68 @@ impl<W: Write> Write for LineWriter<W> {\n         }\n     }\n \n+    // Vectored writes are very similar to the writes above, but adjusted for\n+    // the list of buffers that we have to write.\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        if self.need_flush {\n+            self.flush()?;\n+        }\n+\n+        // Find the last newline, and failing that write the whole buffer\n+        let last_newline = bufs\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .filter_map(|(i, buf)| {\n+                let pos = memchr::memrchr(b'\\n', buf)?;\n+                Some((i, pos))\n+            })\n+            .next();\n+        let (i, j) = match last_newline {\n+            Some(pair) => pair,\n+            None => return self.inner.write_vectored(bufs),\n+        };\n+        let (prefix, suffix) = bufs.split_at(i);\n+        let (buf, suffix) = suffix.split_at(1);\n+        let buf = &buf[0];\n+\n+        // Write everything up to the last newline, flushing afterwards. Note\n+        // that only if we finished our entire `write_vectored` do we try the\n+        // subsequent\n+        // `write`\n+        let mut n = 0;\n+        let prefix_amt = prefix.iter().map(|i| i.len()).sum();\n+        if prefix_amt > 0 {\n+            n += self.inner.write_vectored(prefix)?;\n+            self.need_flush = true;\n+        }\n+        if n == prefix_amt {\n+            match self.inner.write(&buf[..=j]) {\n+                Ok(m) => n += m,\n+                Err(e) if n == 0 => return Err(e),\n+                Err(_) => return Ok(n),\n+            }\n+            self.need_flush = true;\n+        }\n+        if self.flush().is_err() || n != j + 1 + prefix_amt {\n+            return Ok(n);\n+        }\n+\n+        // ... and now write out everything remaining\n+        match self.inner.write(&buf[j + 1..]) {\n+            Ok(i) => n += i,\n+            Err(_) => return Ok(n),\n+        }\n+\n+        if suffix.iter().map(|s| s.len()).sum::<usize>() == 0 {\n+            return Ok(n)\n+        }\n+        match self.inner.write_vectored(suffix) {\n+            Ok(i) => Ok(n + i),\n+            Err(_) => Ok(n),\n+        }\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> {\n         self.inner.flush()?;\n         self.need_flush = false;\n@@ -1015,7 +1077,7 @@ where\n #[cfg(test)]\n mod tests {\n     use crate::io::prelude::*;\n-    use crate::io::{self, BufReader, BufWriter, LineWriter, SeekFrom};\n+    use crate::io::{self, BufReader, BufWriter, LineWriter, SeekFrom, IoSlice};\n     use crate::sync::atomic::{AtomicUsize, Ordering};\n     use crate::thread;\n \n@@ -1483,4 +1545,112 @@ mod tests {\n \n         assert_eq!(l.write(b\"a\").unwrap_err().kind(), io::ErrorKind::Other)\n     }\n+\n+    #[test]\n+    fn line_vectored() {\n+        let mut a = LineWriter::new(Vec::new());\n+        assert_eq!(\n+            a.write_vectored(&[\n+                IoSlice::new(&[]),\n+                IoSlice::new(b\"\\n\"),\n+                IoSlice::new(&[]),\n+                IoSlice::new(b\"a\"),\n+            ])\n+            .unwrap(),\n+            2,\n+        );\n+        assert_eq!(a.get_ref(), b\"\\n\");\n+\n+        assert_eq!(\n+            a.write_vectored(&[\n+                IoSlice::new(&[]),\n+                IoSlice::new(b\"b\"),\n+                IoSlice::new(&[]),\n+                IoSlice::new(b\"a\"),\n+                IoSlice::new(&[]),\n+                IoSlice::new(b\"c\"),\n+            ])\n+            .unwrap(),\n+            3,\n+        );\n+        assert_eq!(a.get_ref(), b\"\\n\");\n+        a.flush().unwrap();\n+        assert_eq!(a.get_ref(), b\"\\nabac\");\n+        assert_eq!(a.write_vectored(&[]).unwrap(), 0);\n+        assert_eq!(\n+            a.write_vectored(&[\n+                IoSlice::new(&[]),\n+                IoSlice::new(&[]),\n+                IoSlice::new(&[]),\n+                IoSlice::new(&[]),\n+            ])\n+            .unwrap(),\n+            0,\n+        );\n+        assert_eq!(a.write_vectored(&[IoSlice::new(b\"a\\nb\"),]).unwrap(), 3);\n+        assert_eq!(a.get_ref(), b\"\\nabaca\\n\");\n+    }\n+\n+    #[test]\n+    fn line_vectored_partial_and_errors() {\n+        enum Call {\n+            Write { inputs: Vec<&'static [u8]>, output: io::Result<usize> },\n+            Flush { output: io::Result<()> },\n+        }\n+        struct Writer {\n+            calls: Vec<Call>,\n+        }\n+\n+        impl Write for Writer {\n+            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+                self.write_vectored(&[IoSlice::new(buf)])\n+            }\n+\n+            fn write_vectored(&mut self, buf: &[IoSlice<'_>]) -> io::Result<usize> {\n+                match self.calls.pop().unwrap() {\n+                    Call::Write { inputs, output } => {\n+                        assert_eq!(inputs, buf.iter().map(|b| &**b).collect::<Vec<_>>());\n+                        output\n+                    }\n+                    _ => panic!(\"unexpected call to write\"),\n+                }\n+            }\n+\n+            fn flush(&mut self) -> io::Result<()> {\n+                match self.calls.pop().unwrap() {\n+                    Call::Flush { output } => output,\n+                    _ => panic!(\"unexpected call to flush\"),\n+                }\n+            }\n+        }\n+\n+        impl Drop for Writer {\n+            fn drop(&mut self) {\n+                if !thread::panicking() {\n+                    assert_eq!(self.calls.len(), 0);\n+                }\n+            }\n+        }\n+\n+        // partial writes keep going\n+        let mut a = LineWriter::new(Writer { calls: Vec::new() });\n+        a.write_vectored(&[IoSlice::new(&[]), IoSlice::new(b\"abc\")]).unwrap();\n+        a.get_mut().calls.push(Call::Flush { output: Ok(()) });\n+        a.get_mut().calls.push(Call::Write { inputs: vec![b\"bcx\\n\"], output: Ok(4) });\n+        a.get_mut().calls.push(Call::Write { inputs: vec![b\"abcx\\n\"], output: Ok(1) });\n+        a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\n\")]).unwrap();\n+        a.get_mut().calls.push(Call::Flush { output: Ok(()) });\n+        a.flush().unwrap();\n+\n+        // erroneous writes stop and don't write more\n+        a.get_mut().calls.push(Call::Write { inputs: vec![b\"x\\n\"], output: Err(err()) });\n+        assert_eq!(a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\na\")]).unwrap(), 2);\n+        a.get_mut().calls.push(Call::Flush { output: Ok(()) });\n+        a.get_mut().calls.push(Call::Write { inputs: vec![b\"x\\n\"], output: Ok(2) });\n+        a.flush().unwrap();\n+\n+        fn err() -> io::Error {\n+            io::Error::new(io::ErrorKind::Other, \"x\")\n+        }\n+    }\n }"}]}