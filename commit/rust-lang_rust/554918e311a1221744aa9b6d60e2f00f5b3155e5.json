{"sha": "554918e311a1221744aa9b6d60e2f00f5b3155e5", "node_id": "C_kwDOAAsO6NoAKDU1NDkxOGUzMTFhMTIyMTc0NGFhOWI2ZDYwZTJmMDBmNWIzMTU1ZTU", "commit": {"author": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2021-08-08T08:04:33Z"}, "committer": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2022-02-05T02:47:29Z"}, "message": "Hide Repr details from io::Error, and rework `io::Error::new_const`.", "tree": {"sha": "e8affa7ee0e7729cf05633c7b7989aaaa96bdd8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8affa7ee0e7729cf05633c7b7989aaaa96bdd8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/554918e311a1221744aa9b6d60e2f00f5b3155e5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0+qV0hta6XFe2D54u/UMJ4RyKgFAmH95UEACgkQ4u/UMJ4R\nyKgTAQ//RHKVk/qT3vEK/sK9Skval5kSlFDARsW8dhjaOIgfxlzWwtbM8Lsb4Ug0\nN8cJ2cq/0d1osrAgNbTMtkm+6jf47Qn32WYmYdIChcBQzhg8U1A5dvWSkt9vXCan\nMhXKzfOkP/EtwgLuQ0djCZwdPI6vi390OLYMSYoUs45lowIqz+vFgYFbYYVBP/6X\n3bA7/zbZ+PXb0hWdOf5LXltdqn1P+WdoKIpPB8r5YSfW3JQg3AvSyAh3Dc9LtIsQ\nwWXItyVE7fa4nlAj1FKjfOISmav7N5AN1bZOhaL0Vw0mksgX62/yjucD8gdfddiI\nD+ZI563t2i5YkeusXr+byVm0G0+QezsxLWVijZuRAyaiYJdch3abggfZBv9DKDYq\nb7I0EUJeDhTN8+TAKBSXzz+MSmFuhy8lPS41LgAvW9jhXEuL+RZ2aFrPoizkzGaj\niR64Uq5NFC/3cpvG02CQgPQSSVt+REWujQAOF5DIglaoNAsw7lQZgUBbR4EmukY/\nxw1Q6ikE3M8KtRg11SefjtYRTuOZ8a3Ps8ISRaZtWiDeEjPvndb9Eec3tBKcMrk1\nVxwEdtXsmgZE403tnCTyLNg09TcNBx+sB3hFrUQpIkp50Xd5i40gHawubjKOVeck\ndQXJwjzbhtMI82Ptn2jvFc82ASSmY+RBGKB9jIaPVIbQHeMWpEM=\n=h/YZ\n-----END PGP SIGNATURE-----", "payload": "tree e8affa7ee0e7729cf05633c7b7989aaaa96bdd8c\nparent 71226d717a1fb57122e47e63b97295e703319cb0\nauthor Thom Chiovoloni <chiovolonit@gmail.com> 1628409873 -0700\ncommitter Thom Chiovoloni <chiovolonit@gmail.com> 1644029249 -0800\n\nHide Repr details from io::Error, and rework `io::Error::new_const`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/554918e311a1221744aa9b6d60e2f00f5b3155e5", "html_url": "https://github.com/rust-lang/rust/commit/554918e311a1221744aa9b6d60e2f00f5b3155e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/554918e311a1221744aa9b6d60e2f00f5b3155e5/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71226d717a1fb57122e47e63b97295e703319cb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/71226d717a1fb57122e47e63b97295e703319cb0", "html_url": "https://github.com/rust-lang/rust/commit/71226d717a1fb57122e47e63b97295e703319cb0"}], "stats": {"total": 614, "additions": 345, "deletions": 269}, "files": [{"sha": "f747325deafbe632d3f7eb4fba6e36016f9a0952", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -1077,7 +1077,7 @@ impl fmt::Display for NulError {\n impl From<NulError> for io::Error {\n     /// Converts a [`NulError`] into a [`io::Error`].\n     fn from(_: NulError) -> io::Error {\n-        io::Error::new_const(io::ErrorKind::InvalidInput, &\"data provided contains a nul byte\")\n+        io::const_io_error!(io::ErrorKind::InvalidInput, \"data provided contains a nul byte\")\n     }\n }\n "}, {"sha": "95e9064442634b53b510ee545b69b5df11e89850", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -2263,9 +2263,9 @@ impl DirBuilder {\n         match path.parent() {\n             Some(p) => self.create_dir_all(p)?,\n             None => {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::Uncategorized,\n-                    &\"failed to create whole tree\",\n+                    \"failed to create whole tree\",\n                 ));\n             }\n         }"}, {"sha": "e7eee4436249b5073e76038d84c1f7be60ba27b9", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -357,9 +357,9 @@ impl<R: Read> Read for BufReader<R> {\n             let mut bytes = Vec::new();\n             self.read_to_end(&mut bytes)?;\n             let string = crate::str::from_utf8(&bytes).map_err(|_| {\n-                io::Error::new_const(\n+                io::const_io_error!(\n                     io::ErrorKind::InvalidData,\n-                    &\"stream did not contain valid UTF-8\",\n+                    \"stream did not contain valid UTF-8\",\n                 )\n             })?;\n             *buf += string;"}, {"sha": "2d3a0f37b4c2a56cf1bf56784e0252a1823cb9bf", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -1,7 +1,7 @@\n use crate::error;\n use crate::fmt;\n use crate::io::{\n-    self, Error, ErrorKind, IntoInnerError, IoSlice, Seek, SeekFrom, Write, DEFAULT_BUF_SIZE,\n+    self, ErrorKind, IntoInnerError, IoSlice, Seek, SeekFrom, Write, DEFAULT_BUF_SIZE,\n };\n use crate::mem;\n use crate::ptr;\n@@ -168,9 +168,9 @@ impl<W: Write> BufWriter<W> {\n \n             match r {\n                 Ok(0) => {\n-                    return Err(Error::new_const(\n+                    return Err(io::const_io_error!(\n                         ErrorKind::WriteZero,\n-                        &\"failed to write the buffered data\",\n+                        \"failed to write the buffered data\",\n                     ));\n                 }\n                 Ok(n) => guard.consume(n),"}, {"sha": "fc19704becee2e53d01c5d28ff742412a126a39a", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -4,7 +4,7 @@ mod tests;\n use crate::io::prelude::*;\n \n use crate::cmp;\n-use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n \n use core::convert::TryInto;\n \n@@ -297,9 +297,9 @@ where\n                 self.pos = n;\n                 Ok(self.pos)\n             }\n-            None => Err(Error::new_const(\n+            None => Err(io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"invalid seek to a negative or overflowing position\",\n+                \"invalid seek to a negative or overflowing position\",\n             )),\n         }\n     }\n@@ -400,9 +400,9 @@ fn slice_write_vectored(\n // Resizing write implementation\n fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usize> {\n     let pos: usize = (*pos_mut).try_into().map_err(|_| {\n-        Error::new_const(\n+        io::const_io_error!(\n             ErrorKind::InvalidInput,\n-            &\"cursor position exceeds maximum possible vector length\",\n+            \"cursor position exceeds maximum possible vector length\",\n         )\n     })?;\n     // Make sure the internal buffer is as least as big as where we"}, {"sha": "67526090e5830c90e97408ec9fb3c3b1a1911a63", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 95, "deletions": 65, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -1,6 +1,9 @@\n #[cfg(test)]\n mod tests;\n \n+mod repr_unpacked;\n+use repr_unpacked::Repr;\n+\n use crate::convert::From;\n use crate::error;\n use crate::fmt;\n@@ -66,15 +69,38 @@ impl fmt::Debug for Error {\n     }\n }\n \n-enum Repr {\n+enum ErrorData<C> {\n     Os(i32),\n     Simple(ErrorKind),\n-    // &str is a fat pointer, but &&str is a thin pointer.\n-    SimpleMessage(ErrorKind, &'static &'static str),\n-    Custom(Box<Custom>),\n+    SimpleMessage(&'static SimpleMessage),\n+    Custom(C),\n+}\n+\n+#[repr(align(4))]\n+#[doc(hidden)]\n+pub(crate) struct SimpleMessage {\n+    kind: ErrorKind,\n+    message: &'static str,\n+}\n+\n+impl SimpleMessage {\n+    pub(crate) const fn new(kind: ErrorKind, message: &'static str) -> Self {\n+        Self { kind, message }\n+    }\n+}\n+\n+/// Create and return an `io::Error` for a given `ErrorKind` and constant\n+/// message. This doesn't allocate.\n+pub(crate) macro const_io_error($kind:expr, $message:expr $(,)?) {\n+    $crate::io::error::Error::from_static_message({\n+        const MESSAGE_DATA: $crate::io::error::SimpleMessage =\n+            $crate::io::error::SimpleMessage::new($kind, $message);\n+        &MESSAGE_DATA\n+    })\n }\n \n #[derive(Debug)]\n+#[repr(align(4))]\n struct Custom {\n     kind: ErrorKind,\n     error: Box<dyn error::Error + Send + Sync>,\n@@ -396,7 +422,7 @@ impl From<ErrorKind> for Error {\n     /// ```\n     #[inline]\n     fn from(kind: ErrorKind) -> Error {\n-        Error { repr: Repr::Simple(kind) }\n+        Error { repr: Repr::new_simple(kind) }\n     }\n }\n \n@@ -461,20 +487,22 @@ impl Error {\n     }\n \n     fn _new(kind: ErrorKind, error: Box<dyn error::Error + Send + Sync>) -> Error {\n-        Error { repr: Repr::Custom(Box::new(Custom { kind, error })) }\n+        Error { repr: Repr::new_custom(Box::new(Custom { kind, error })) }\n     }\n \n-    /// Creates a new I/O error from a known kind of error as well as a\n-    /// constant message.\n+    /// Creates a new I/O error from a known kind of error as well as a constant\n+    /// message.\n     ///\n     /// This function does not allocate.\n     ///\n-    /// This function should maybe change to\n-    /// `new_const<const MSG: &'static str>(kind: ErrorKind)`\n-    /// in the future, when const generics allow that.\n+    /// You should not use this directly, and instead use the `const_io_error!`\n+    /// macro: `io::const_io_error!(ErrorKind::Something, \"some_message\")`.\n+    ///\n+    /// This function should maybe change to `from_static_message<const MSG: &'static\n+    /// str>(kind: ErrorKind)` in the future, when const generics allow that.\n     #[inline]\n-    pub(crate) const fn new_const(kind: ErrorKind, message: &'static &'static str) -> Error {\n-        Self { repr: Repr::SimpleMessage(kind, message) }\n+    pub(crate) const fn from_static_message(msg: &'static SimpleMessage) -> Error {\n+        Self { repr: Repr::new_simple_message(msg) }\n     }\n \n     /// Returns an error representing the last OS error which occurred.\n@@ -532,7 +560,7 @@ impl Error {\n     #[must_use]\n     #[inline]\n     pub fn from_raw_os_error(code: i32) -> Error {\n-        Error { repr: Repr::Os(code) }\n+        Error { repr: Repr::new_os(code) }\n     }\n \n     /// Returns the OS error that this error represents (if any).\n@@ -568,11 +596,11 @@ impl Error {\n     #[must_use]\n     #[inline]\n     pub fn raw_os_error(&self) -> Option<i32> {\n-        match self.repr {\n-            Repr::Os(i) => Some(i),\n-            Repr::Custom(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n+        match self.repr.data() {\n+            ErrorData::Os(i) => Some(i),\n+            ErrorData::Custom(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n         }\n     }\n \n@@ -607,11 +635,11 @@ impl Error {\n     #[must_use]\n     #[inline]\n     pub fn get_ref(&self) -> Option<&(dyn error::Error + Send + Sync + 'static)> {\n-        match self.repr {\n-            Repr::Os(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n-            Repr::Custom(ref c) => Some(&*c.error),\n+        match self.repr.data() {\n+            ErrorData::Os(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n+            ErrorData::Custom(c) => Some(&*c.error),\n         }\n     }\n \n@@ -681,11 +709,11 @@ impl Error {\n     #[must_use]\n     #[inline]\n     pub fn get_mut(&mut self) -> Option<&mut (dyn error::Error + Send + Sync + 'static)> {\n-        match self.repr {\n-            Repr::Os(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n-            Repr::Custom(ref mut c) => Some(&mut *c.error),\n+        match self.repr.data_mut() {\n+            ErrorData::Os(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n+            ErrorData::Custom(c) => Some(&mut *c.error),\n         }\n     }\n \n@@ -720,11 +748,11 @@ impl Error {\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n     pub fn into_inner(self) -> Option<Box<dyn error::Error + Send + Sync>> {\n-        match self.repr {\n-            Repr::Os(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n-            Repr::Custom(c) => Some(c.error),\n+        match self.repr.into_data() {\n+            ErrorData::Os(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n+            ErrorData::Custom(c) => Some(c.error),\n         }\n     }\n \n@@ -750,44 +778,46 @@ impl Error {\n     #[must_use]\n     #[inline]\n     pub fn kind(&self) -> ErrorKind {\n-        match self.repr {\n-            Repr::Os(code) => sys::decode_error_kind(code),\n-            Repr::Custom(ref c) => c.kind,\n-            Repr::Simple(kind) => kind,\n-            Repr::SimpleMessage(kind, _) => kind,\n+        match self.repr.data() {\n+            ErrorData::Os(code) => sys::decode_error_kind(code),\n+            ErrorData::Custom(ref c) => c.kind,\n+            ErrorData::Simple(kind) => kind,\n+            ErrorData::SimpleMessage(m) => m.kind,\n         }\n     }\n }\n \n impl fmt::Debug for Repr {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Repr::Os(code) => fmt\n+        match self.data() {\n+            ErrorData::Os(code) => fmt\n                 .debug_struct(\"Os\")\n                 .field(\"code\", &code)\n                 .field(\"kind\", &sys::decode_error_kind(code))\n                 .field(\"message\", &sys::os::error_string(code))\n                 .finish(),\n-            Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),\n-            Repr::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n-            Repr::SimpleMessage(kind, &message) => {\n-                fmt.debug_struct(\"Error\").field(\"kind\", &kind).field(\"message\", &message).finish()\n-            }\n+            ErrorData::Custom(c) => fmt::Debug::fmt(&c, fmt),\n+            ErrorData::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n+            ErrorData::SimpleMessage(msg) => fmt\n+                .debug_struct(\"Error\")\n+                .field(\"kind\", &msg.kind)\n+                .field(\"message\", &msg.message)\n+                .finish(),\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Error {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.repr {\n-            Repr::Os(code) => {\n+        match self.repr.data() {\n+            ErrorData::Os(code) => {\n                 let detail = sys::os::error_string(code);\n                 write!(fmt, \"{} (os error {})\", detail, code)\n             }\n-            Repr::Custom(ref c) => c.error.fmt(fmt),\n-            Repr::Simple(kind) => write!(fmt, \"{}\", kind.as_str()),\n-            Repr::SimpleMessage(_, &msg) => msg.fmt(fmt),\n+            ErrorData::Custom(ref c) => c.error.fmt(fmt),\n+            ErrorData::Simple(kind) => write!(fmt, \"{}\", kind.as_str()),\n+            ErrorData::SimpleMessage(msg) => msg.message.fmt(fmt),\n         }\n     }\n }\n@@ -796,29 +826,29 @@ impl fmt::Display for Error {\n impl error::Error for Error {\n     #[allow(deprecated, deprecated_in_future)]\n     fn description(&self) -> &str {\n-        match self.repr {\n-            Repr::Os(..) | Repr::Simple(..) => self.kind().as_str(),\n-            Repr::SimpleMessage(_, &msg) => msg,\n-            Repr::Custom(ref c) => c.error.description(),\n+        match self.repr.data() {\n+            ErrorData::Os(..) | ErrorData::Simple(..) => self.kind().as_str(),\n+            ErrorData::SimpleMessage(msg) => msg.message,\n+            ErrorData::Custom(ref c) => c.error.description(),\n         }\n     }\n \n     #[allow(deprecated)]\n     fn cause(&self) -> Option<&dyn error::Error> {\n-        match self.repr {\n-            Repr::Os(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n-            Repr::Custom(ref c) => c.error.cause(),\n+        match self.repr.data() {\n+            ErrorData::Os(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n+            ErrorData::Custom(ref c) => c.error.cause(),\n         }\n     }\n \n     fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n-        match self.repr {\n-            Repr::Os(..) => None,\n-            Repr::Simple(..) => None,\n-            Repr::SimpleMessage(..) => None,\n-            Repr::Custom(ref c) => c.error.source(),\n+        match self.repr.data() {\n+            ErrorData::Os(..) => None,\n+            ErrorData::Simple(..) => None,\n+            ErrorData::SimpleMessage(..) => None,\n+            ErrorData::Custom(ref c) => c.error.source(),\n         }\n     }\n }"}, {"sha": "3729c039c42d70553482fe6a74511d60017547c1", "filename": "library/std/src/io/error/repr_unpacked.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_unpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_unpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_unpacked.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -0,0 +1,50 @@\n+//! This is a fairly simple unpacked error representation that's used on\n+//! non-64bit targets, where the packed 64 bit representation wouldn't work, and\n+//! would have no benefit.\n+\n+use super::{Custom, ErrorData, ErrorKind, SimpleMessage};\n+use alloc::boxed::Box;\n+\n+type Inner = ErrorData<Box<Custom>>;\n+\n+pub(super) struct Repr(Inner);\n+\n+impl Repr {\n+    pub(super) fn new_custom(b: Box<Custom>) -> Self {\n+        Self(Inner::Custom(b))\n+    }\n+    #[inline]\n+    pub(super) fn new_os(code: i32) -> Self {\n+        Self(Inner::Os(code))\n+    }\n+    #[inline]\n+    pub(super) fn new_simple(kind: ErrorKind) -> Self {\n+        Self(Inner::Simple(kind))\n+    }\n+    #[inline]\n+    pub(super) const fn new_simple_message(m: &'static SimpleMessage) -> Self {\n+        Self(Inner::SimpleMessage(m))\n+    }\n+    #[inline]\n+    pub(super) fn into_data(self) -> ErrorData<Box<Custom>> {\n+        self.0\n+    }\n+    #[inline]\n+    pub(super) fn data(&self) -> ErrorData<&Custom> {\n+        match &self.0 {\n+            Inner::Os(c) => ErrorData::Os(*c),\n+            Inner::Simple(k) => ErrorData::Simple(*k),\n+            Inner::SimpleMessage(m) => ErrorData::SimpleMessage(*m),\n+            Inner::Custom(m) => ErrorData::Custom(&*m),\n+        }\n+    }\n+    #[inline]\n+    pub(super) fn data_mut(&mut self) -> ErrorData<&mut Custom> {\n+        match &mut self.0 {\n+            Inner::Os(c) => ErrorData::Os(*c),\n+            Inner::Simple(k) => ErrorData::Simple(*k),\n+            Inner::SimpleMessage(m) => ErrorData::SimpleMessage(*m),\n+            Inner::Custom(m) => ErrorData::Custom(&mut *m),\n+        }\n+    }\n+}"}, {"sha": "5d9290f4ac4bbcd405da8abb4ab80933f3407ca0", "filename": "library/std/src/io/error/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -1,4 +1,4 @@\n-use super::{Custom, Error, ErrorKind, Repr};\n+use super::{const_io_error, Custom, Error, ErrorKind, Repr};\n use crate::error;\n use crate::fmt;\n use crate::mem::size_of;\n@@ -16,9 +16,9 @@ fn test_debug_error() {\n     let msg = error_string(code);\n     let kind = decode_error_kind(code);\n     let err = Error {\n-        repr: Repr::Custom(box Custom {\n+        repr: Repr::new_custom(box Custom {\n             kind: ErrorKind::InvalidInput,\n-            error: box Error { repr: super::Repr::Os(code) },\n+            error: box Error { repr: super::Repr::new_os(code) },\n         }),\n     };\n     let expected = format!(\n@@ -60,7 +60,7 @@ fn test_downcasting() {\n \n #[test]\n fn test_const() {\n-    const E: Error = Error::new_const(ErrorKind::NotFound, &\"hello\");\n+    const E: Error = const_io_error!(ErrorKind::NotFound, \"hello\");\n \n     assert_eq!(E.kind(), ErrorKind::NotFound);\n     assert_eq!(E.to_string(), \"hello\");"}, {"sha": "64d2457bce1596b28c2d619e3ca40b2fb142f93b", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -5,7 +5,7 @@ use crate::alloc::Allocator;\n use crate::cmp;\n use crate::fmt;\n use crate::io::{\n-    self, BufRead, Error, ErrorKind, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, Write,\n+    self, BufRead, ErrorKind, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, Write,\n };\n use crate::mem;\n \n@@ -279,7 +279,10 @@ impl Read for &[u8] {\n     #[inline]\n     fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n         if buf.len() > self.len() {\n-            return Err(Error::new_const(ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"));\n+            return Err(io::const_io_error!(\n+                ErrorKind::UnexpectedEof,\n+                \"failed to fill whole buffer\"\n+            ));\n         }\n         let (a, b) = self.split_at(buf.len());\n \n@@ -361,7 +364,7 @@ impl Write for &mut [u8] {\n         if self.write(data)? == data.len() {\n             Ok(())\n         } else {\n-            Err(Error::new_const(ErrorKind::WriteZero, &\"failed to write whole buffer\"))\n+            Err(io::const_io_error!(ErrorKind::WriteZero, \"failed to write whole buffer\"))\n         }\n     }\n "}, {"sha": "71a59fb58032115e17e61ff233003068ad7887da", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -282,6 +282,7 @@ pub use self::{\n \n #[unstable(feature = \"read_buf\", issue = \"78485\")]\n pub use self::readbuf::ReadBuf;\n+pub(crate) use error::const_io_error;\n \n mod buffered;\n pub(crate) mod copy;\n@@ -337,7 +338,10 @@ where\n     let ret = f(g.buf);\n     if str::from_utf8(&g.buf[g.len..]).is_err() {\n         ret.and_then(|_| {\n-            Err(Error::new_const(ErrorKind::InvalidData, &\"stream did not contain valid UTF-8\"))\n+            Err(error::const_io_error!(\n+                ErrorKind::InvalidData,\n+                \"stream did not contain valid UTF-8\"\n+            ))\n         })\n     } else {\n         g.len = g.buf.len();\n@@ -454,7 +458,7 @@ pub(crate) fn default_read_exact<R: Read + ?Sized>(this: &mut R, mut buf: &mut [\n         }\n     }\n     if !buf.is_empty() {\n-        Err(Error::new_const(ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"))\n+        Err(error::const_io_error!(ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n     } else {\n         Ok(())\n     }\n@@ -1512,9 +1516,9 @@ pub trait Write {\n         while !buf.is_empty() {\n             match self.write(buf) {\n                 Ok(0) => {\n-                    return Err(Error::new_const(\n+                    return Err(error::const_io_error!(\n                         ErrorKind::WriteZero,\n-                        &\"failed to write whole buffer\",\n+                        \"failed to write whole buffer\",\n                     ));\n                 }\n                 Ok(n) => buf = &buf[n..],\n@@ -1580,9 +1584,9 @@ pub trait Write {\n         while !bufs.is_empty() {\n             match self.write_vectored(bufs) {\n                 Ok(0) => {\n-                    return Err(Error::new_const(\n+                    return Err(error::const_io_error!(\n                         ErrorKind::WriteZero,\n-                        &\"failed to write whole buffer\",\n+                        \"failed to write whole buffer\",\n                     ));\n                 }\n                 Ok(n) => IoSlice::advance_slices(&mut bufs, n),\n@@ -1657,7 +1661,7 @@ pub trait Write {\n                 if output.error.is_err() {\n                     output.error\n                 } else {\n-                    Err(Error::new_const(ErrorKind::Uncategorized, &\"formatter error\"))\n+                    Err(error::const_io_error!(ErrorKind::Uncategorized, \"formatter error\"))\n                 }\n             }\n         }"}, {"sha": "eb62634856462aa874bc26ab64a9d3381df7a116", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -185,12 +185,12 @@ fn take_eof() {\n \n     impl Read for R {\n         fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n-            Err(io::Error::new_const(io::ErrorKind::Other, &\"\"))\n+            Err(io::const_io_error!(io::ErrorKind::Other, \"\"))\n         }\n     }\n     impl BufRead for R {\n         fn fill_buf(&mut self) -> io::Result<&[u8]> {\n-            Err(io::Error::new_const(io::ErrorKind::Other, &\"\"))\n+            Err(io::const_io_error!(io::ErrorKind::Other, \"\"))\n         }\n         fn consume(&mut self, _amt: usize) {}\n     }"}, {"sha": "f676e0a04f000883760a3a141da84018273b1b18", "filename": "library/std/src/net/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -17,7 +17,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::io::{self, Error, ErrorKind};\n+use crate::io::{self, ErrorKind};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::addr::{SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n@@ -90,6 +90,6 @@ where\n         }\n     }\n     Err(last_err.unwrap_or_else(|| {\n-        Error::new_const(ErrorKind::InvalidInput, &\"could not resolve to any addresses\")\n+        io::const_io_error!(ErrorKind::InvalidInput, \"could not resolve to any addresses\")\n     }))\n }"}, {"sha": "11a696e92c82565725411e01b018e8d1bf61c5fd", "filename": "library/std/src/net/udp.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -2,7 +2,7 @@\n mod tests;\n \n use crate::fmt;\n-use crate::io::{self, Error, ErrorKind};\n+use crate::io::{self, ErrorKind};\n use crate::net::{Ipv4Addr, Ipv6Addr, SocketAddr, ToSocketAddrs};\n use crate::sys_common::net as net_imp;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -175,7 +175,9 @@ impl UdpSocket {\n     pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A) -> io::Result<usize> {\n         match addr.to_socket_addrs()?.next() {\n             Some(addr) => self.0.send_to(buf, &addr),\n-            None => Err(Error::new_const(ErrorKind::InvalidInput, &\"no addresses to send data to\")),\n+            None => {\n+                Err(io::const_io_error!(ErrorKind::InvalidInput, \"no addresses to send data to\"))\n+            }\n         }\n     }\n "}, {"sha": "b53c3e79b0fe6e7a9046a434ef3623ec313baa31", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -93,9 +93,9 @@ impl OwnedFd {\n \n     #[cfg(target_os = \"wasi\")]\n     pub fn try_clone(&self) -> crate::io::Result<Self> {\n-        Err(crate::io::Error::new_const(\n+        Err(crate::io::const_io_error!(\n             crate::io::ErrorKind::Unsupported,\n-            &\"operation not supported on WASI yet\",\n+            \"operation not supported on WASI yet\",\n         ))\n     }\n }"}, {"sha": "db7edcd057432563b925d1118690ab7a5817b459", "filename": "library/std/src/os/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -114,7 +114,7 @@ pub trait FileExt {\n             }\n         }\n         if !buf.is_empty() {\n-            Err(io::Error::new_const(io::ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"))\n+            Err(io::const_io_error!(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\",))\n         } else {\n             Ok(())\n         }\n@@ -196,9 +196,9 @@ pub trait FileExt {\n         while !buf.is_empty() {\n             match self.write_at(buf, offset) {\n                 Ok(0) => {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::WriteZero,\n-                        &\"failed to write whole buffer\",\n+                        \"failed to write whole buffer\",\n                     ));\n                 }\n                 Ok(n) => {"}, {"sha": "034fa301ba1ead4c434edf14adb9a41886f22844", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -30,16 +30,16 @@ pub(super) fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::s\n     let bytes = path.as_os_str().as_bytes();\n \n     if bytes.contains(&0) {\n-        return Err(io::Error::new_const(\n+        return Err(io::const_io_error!(\n             io::ErrorKind::InvalidInput,\n-            &\"paths must not contain interior null bytes\",\n+            \"paths must not contain interior null bytes\",\n         ));\n     }\n \n     if bytes.len() >= addr.sun_path.len() {\n-        return Err(io::Error::new_const(\n+        return Err(io::const_io_error!(\n             io::ErrorKind::InvalidInput,\n-            &\"path must be shorter than SUN_LEN\",\n+            \"path must be shorter than SUN_LEN\",\n         ));\n     }\n     // SAFETY: `bytes` and `addr.sun_path` are not overlapping and\n@@ -121,9 +121,9 @@ impl SocketAddr {\n             // linux returns zero bytes of address\n             len = sun_path_offset(&addr) as libc::socklen_t; // i.e., zero-length address\n         } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"file descriptor did not correspond to a Unix socket\",\n+                \"file descriptor did not correspond to a Unix socket\",\n             ));\n         }\n \n@@ -323,9 +323,9 @@ impl SocketAddr {\n             addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n \n             if namespace.len() + 1 > addr.sun_path.len() {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidInput,\n-                    &\"namespace must be shorter than SUN_LEN\",\n+                    \"namespace must be shorter than SUN_LEN\",\n                 ));\n             }\n "}, {"sha": "160c8f1eca251a01fe4286ed7a23269226c8e6ae", "filename": "library/std/src/os/wasi/fs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Ffs.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -87,7 +87,7 @@ pub trait FileExt {\n             }\n         }\n         if !buf.is_empty() {\n-            Err(io::Error::new_const(io::ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"))\n+            Err(io::const_io_error!(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n         } else {\n             Ok(())\n         }\n@@ -153,9 +153,9 @@ pub trait FileExt {\n         while !buf.is_empty() {\n             match self.write_at(buf, offset) {\n                 Ok(0) => {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::WriteZero,\n-                        &\"failed to write whole buffer\",\n+                        \"failed to write whole buffer\",\n                     ));\n                 }\n                 Ok(n) => {\n@@ -258,9 +258,9 @@ impl FileExt for fs::File {\n             a if a == wasi::ADVICE_DONTNEED.raw() => wasi::ADVICE_DONTNEED,\n             a if a == wasi::ADVICE_NOREUSE.raw() => wasi::ADVICE_NOREUSE,\n             _ => {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidInput,\n-                    &\"invalid parameter 'advice'\",\n+                    \"invalid parameter 'advice'\",\n                 ));\n             }\n         };\n@@ -554,5 +554,5 @@ pub fn symlink_path<P: AsRef<Path>, U: AsRef<Path>>(old_path: P, new_path: U) ->\n \n fn osstr2str(f: &OsStr) -> io::Result<&str> {\n     f.to_str()\n-        .ok_or_else(|| io::Error::new_const(io::ErrorKind::Uncategorized, &\"input must be utf-8\"))\n+        .ok_or_else(|| io::const_io_error!(io::ErrorKind::Uncategorized, \"input must be utf-8\"))\n }"}, {"sha": "d3a5b6dcc76c6847125ac630d2e04a036e928b21", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -135,7 +135,7 @@ impl OwnedSocket {\n \n     #[cfg(target_vendor = \"uwp\")]\n     pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n-        Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"Unavailable on UWP\"))\n+        Err(io::const_io_error!(io::ErrorKind::Unsupported, \"Unavailable on UWP\"))\n     }\n }\n "}, {"sha": "fa9a7fb19e4631fcab9c7d99de57a78857256559", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -226,7 +226,7 @@ impl OpenOptions {\n             (false, _, true) => Ok(O_WRONLY | O_APPEND),\n             (true, _, true) => Ok(O_RDWR | O_APPEND),\n             (false, false, false) => {\n-                Err(io::Error::new_const(ErrorKind::InvalidInput, &\"invalid access mode\"))\n+                Err(io::const_io_error!(ErrorKind::InvalidInput, \"invalid access mode\"))\n             }\n         }\n     }\n@@ -236,17 +236,17 @@ impl OpenOptions {\n             (true, false) => {}\n             (false, false) => {\n                 if self.truncate || self.create || self.create_new {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         ErrorKind::InvalidInput,\n-                        &\"invalid creation mode\",\n+                        \"invalid creation mode\",\n                     ));\n                 }\n             }\n             (_, true) => {\n                 if self.truncate && !self.create_new {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         ErrorKind::InvalidInput,\n-                        &\"invalid creation mode\",\n+                        \"invalid creation mode\",\n                     ));\n                 }\n             }"}, {"sha": "b798c97448b8f541aa68c19076e7736d0b6217ce", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -58,9 +58,9 @@ pub fn unsupported<T>() -> crate::io::Result<T> {\n }\n \n pub fn unsupported_err() -> crate::io::Error {\n-    crate::io::Error::new_const(\n+    crate::io::const_io_error!(\n         crate::io::ErrorKind::Unsupported,\n-        &\"operation not supported on HermitCore yet\",\n+        \"operation not supported on HermitCore yet\",\n     )\n }\n "}, {"sha": "f65fd8e53bdc999a26998c5093124b0b2bba7ee6", "filename": "library/std/src/sys/hermit/net.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -14,9 +14,9 @@ use crate::time::Duration;\n /// if not, starts it.\n pub fn init() -> io::Result<()> {\n     if abi::network_init() < 0 {\n-        return Err(io::Error::new_const(\n+        return Err(io::const_io_error!(\n             ErrorKind::Uncategorized,\n-            &\"Unable to initialize network interface\",\n+            \"Unable to initialize network interface\",\n         ));\n     }\n \n@@ -50,9 +50,9 @@ impl TcpStream {\n \n         match abi::tcpstream::connect(addr.ip().to_string().as_bytes(), addr.port(), None) {\n             Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n-            _ => Err(io::Error::new_const(\n+            _ => Err(io::const_io_error!(\n                 ErrorKind::Uncategorized,\n-                &\"Unable to initiate a connection on a socket\",\n+                \"Unable to initiate a connection on a socket\",\n             )),\n         }\n     }\n@@ -64,17 +64,17 @@ impl TcpStream {\n             Some(duration.as_millis() as u64),\n         ) {\n             Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n-            _ => Err(io::Error::new_const(\n+            _ => Err(io::const_io_error!(\n                 ErrorKind::Uncategorized,\n-                &\"Unable to initiate a connection on a socket\",\n+                \"Unable to initiate a connection on a socket\",\n             )),\n         }\n     }\n \n     pub fn set_read_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n         abi::tcpstream::set_read_timeout(*self.0.as_inner(), duration.map(|d| d.as_millis() as u64))\n             .map_err(|_| {\n-                io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to set timeout value\")\n+                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to set timeout value\")\n             })\n     }\n \n@@ -83,28 +83,28 @@ impl TcpStream {\n             *self.0.as_inner(),\n             duration.map(|d| d.as_millis() as u64),\n         )\n-        .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to set timeout value\"))\n+        .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"Unable to set timeout value\"))\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         let duration = abi::tcpstream::get_read_timeout(*self.0.as_inner()).map_err(|_| {\n-            io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to determine timeout value\")\n+            io::const_io_error!(ErrorKind::Uncategorized, \"Unable to determine timeout value\")\n         })?;\n \n         Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         let duration = abi::tcpstream::get_write_timeout(*self.0.as_inner()).map_err(|_| {\n-            io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to determine timeout value\")\n+            io::const_io_error!(ErrorKind::Uncategorized, \"Unable to determine timeout value\")\n         })?;\n \n         Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n         abi::tcpstream::peek(*self.0.as_inner(), buf)\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"peek failed\"))\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"peek failed\"))\n     }\n \n     pub fn read(&self, buffer: &mut [u8]) -> io::Result<usize> {\n@@ -116,7 +116,7 @@ impl TcpStream {\n \n         for i in ioslice.iter_mut() {\n             let ret = abi::tcpstream::read(*self.0.as_inner(), &mut i[0..]).map_err(|_| {\n-                io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to read on socket\")\n+                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to read on socket\")\n             })?;\n \n             if ret != 0 {\n@@ -141,7 +141,7 @@ impl TcpStream {\n \n         for i in ioslice.iter() {\n             size += abi::tcpstream::write(*self.0.as_inner(), i).map_err(|_| {\n-                io::Error::new_const(ErrorKind::Uncategorized, &\"Unable to write on socket\")\n+                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to write on socket\")\n             })?;\n         }\n \n@@ -155,13 +155,13 @@ impl TcpStream {\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         let (ipaddr, port) = abi::tcpstream::peer_addr(*self.0.as_inner())\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"peer_addr failed\"))?;\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"peer_addr failed\"))?;\n \n         let saddr = match ipaddr {\n             Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n             Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n             _ => {\n-                return Err(io::Error::new_const(ErrorKind::Uncategorized, &\"peer_addr failed\"));\n+                return Err(io::const_io_error!(ErrorKind::Uncategorized, \"peer_addr failed\"));\n             }\n         };\n \n@@ -173,9 +173,8 @@ impl TcpStream {\n     }\n \n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        abi::tcpstream::shutdown(*self.0.as_inner(), how as i32).map_err(|_| {\n-            io::Error::new_const(ErrorKind::Uncategorized, &\"unable to shutdown socket\")\n-        })\n+        abi::tcpstream::shutdown(*self.0.as_inner(), how as i32)\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to shutdown socket\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpStream> {\n@@ -192,22 +191,22 @@ impl TcpStream {\n \n     pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n         abi::tcpstream::set_nodelay(*self.0.as_inner(), mode)\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"set_nodelay failed\"))\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"set_nodelay failed\"))\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n         abi::tcpstream::nodelay(*self.0.as_inner())\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"nodelay failed\"))\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"nodelay failed\"))\n     }\n \n     pub fn set_ttl(&self, tll: u32) -> io::Result<()> {\n         abi::tcpstream::set_tll(*self.0.as_inner(), tll)\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"unable to set TTL\"))\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to set TTL\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n         abi::tcpstream::get_tll(*self.0.as_inner())\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"unable to get TTL\"))\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to get TTL\"))\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n@@ -216,7 +215,7 @@ impl TcpStream {\n \n     pub fn set_nonblocking(&self, mode: bool) -> io::Result<()> {\n         abi::tcpstream::set_nonblocking(*self.0.as_inner(), mode).map_err(|_| {\n-            io::Error::new_const(ErrorKind::Uncategorized, &\"unable to set blocking mode\")\n+            io::const_io_error!(ErrorKind::Uncategorized, \"unable to set blocking mode\")\n         })\n     }\n }\n@@ -243,12 +242,12 @@ impl TcpListener {\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n         let (handle, ipaddr, port) = abi::tcplistener::accept(self.0.port())\n-            .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"accept failed\"))?;\n+            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"accept failed\"))?;\n         let saddr = match ipaddr {\n             Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n             Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n             _ => {\n-                return Err(io::Error::new_const(ErrorKind::Uncategorized, &\"accept failed\"));\n+                return Err(io::const_io_error!(ErrorKind::Uncategorized, \"accept failed\"));\n             }\n         };\n "}, {"sha": "514de1df6f9c33bc32f0ca34b0bd29ee6523c6c8", "filename": "library/std/src/sys/hermit/stdio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstdio.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -40,7 +40,7 @@ impl io::Write for Stdout {\n         unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"Stdout is not able to print\"))\n+            Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"Stdout is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }\n@@ -52,7 +52,7 @@ impl io::Write for Stdout {\n         unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"Stdout is not able to print\"))\n+            Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"Stdout is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }\n@@ -81,7 +81,7 @@ impl io::Write for Stderr {\n         unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"Stderr is not able to print\"))\n+            Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"Stderr is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }\n@@ -93,7 +93,7 @@ impl io::Write for Stderr {\n         unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"Stderr is not able to print\"))\n+            Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"Stderr is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }"}, {"sha": "e53a1fea6a0dca8b4a6e49aeecd49839e6efbe25", "filename": "library/std/src/sys/hermit/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -39,7 +39,7 @@ impl Thread {\n             // The thread failed to start and as a result p was not consumed. Therefore, it is\n             // safe to reconstruct the box so that it gets deallocated.\n             drop(Box::from_raw(p));\n-            Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"Unable to create thread!\"))\n+            Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"Unable to create thread!\"))\n         } else {\n             Ok(Thread { tid: tid })\n         };"}, {"sha": "158c92e7a77d42ccf08c79e23ca576852885967d", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -58,7 +58,7 @@ pub fn unsupported<T>() -> crate::io::Result<T> {\n }\n \n pub fn unsupported_err() -> crate::io::Error {\n-    crate::io::Error::new_const(ErrorKind::Unsupported, &\"operation not supported on SGX yet\")\n+    crate::io::const_io_error!(ErrorKind::Unsupported, \"operation not supported on SGX yet\")\n }\n \n /// This function is used to implement various functions that doesn't exist,\n@@ -69,9 +69,9 @@ pub fn unsupported_err() -> crate::io::Error {\n pub fn sgx_ineffective<T>(v: T) -> crate::io::Result<T> {\n     static SGX_INEFFECTIVE_ERROR: AtomicBool = AtomicBool::new(false);\n     if SGX_INEFFECTIVE_ERROR.load(Ordering::Relaxed) {\n-        Err(crate::io::Error::new_const(\n+        Err(crate::io::const_io_error!(\n             ErrorKind::Uncategorized,\n-            &\"operation can't be trusted to have any effect on SGX\",\n+            \"operation can't be trusted to have any effect on SGX\",\n         ))\n     } else {\n         Ok(v)"}, {"sha": "d14990c6877af6384dfc4385d2bd2c4702523109", "filename": "library/std/src/sys/sgx/net.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -97,9 +97,9 @@ impl TcpStream {\n \n     pub fn connect_timeout(addr: &SocketAddr, dur: Duration) -> io::Result<TcpStream> {\n         if dur == Duration::default() {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"cannot set a 0 duration timeout\",\n+                \"cannot set a 0 duration timeout\",\n             ));\n         }\n         Self::connect(Ok(addr)) // FIXME: ignoring timeout\n@@ -108,9 +108,9 @@ impl TcpStream {\n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         match dur {\n             Some(dur) if dur == Duration::default() => {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidInput,\n-                    &\"cannot set a 0 duration timeout\",\n+                    \"cannot set a 0 duration timeout\",\n                 ));\n             }\n             _ => sgx_ineffective(()),\n@@ -120,9 +120,9 @@ impl TcpStream {\n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         match dur {\n             Some(dur) if dur == Duration::default() => {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidInput,\n-                    &\"cannot set a 0 duration timeout\",\n+                    \"cannot set a 0 duration timeout\",\n                 ));\n             }\n             _ => sgx_ineffective(()),"}, {"sha": "a6ed10f7789d26ffdd1e90a55c24243d7106b47b", "filename": "library/std/src/sys/solid/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -461,7 +461,7 @@ impl fmt::Debug for File {\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n     if stat(p)?.file_type().is_dir() {\n-        Err(io::Error::new_const(io::ErrorKind::IsADirectory, &\"is a directory\"))\n+        Err(io::const_io_error!(io::ErrorKind::IsADirectory, \"is a directory\"))\n     } else {\n         error::SolidError::err_if_negative(unsafe { abi::SOLID_FS_Unlink(cstr(p)?.as_ptr()) })\n             .map_err(|e| e.as_io_error())?;\n@@ -491,7 +491,7 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n             .map_err(|e| e.as_io_error())?;\n         Ok(())\n     } else {\n-        Err(io::Error::new_const(io::ErrorKind::NotADirectory, &\"not a directory\"))\n+        Err(io::const_io_error!(io::ErrorKind::NotADirectory, \"not a directory\"))\n     }\n }\n \n@@ -511,7 +511,7 @@ pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     // This target doesn't support symlinks\n     stat(p)?;\n-    Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"not a symbolic link\"))\n+    Err(io::const_io_error!(io::ErrorKind::InvalidInput, \"not a symbolic link\"))\n }\n \n pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {"}, {"sha": "2082c9401535e8d1f4dd67a535f03eda626286bf", "filename": "library/std/src/sys/solid/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -57,9 +57,9 @@ pub fn unsupported<T>() -> crate::io::Result<T> {\n }\n \n pub fn unsupported_err() -> crate::io::Error {\n-    crate::io::Error::new_const(\n+    crate::io::const_io_error!(\n         crate::io::ErrorKind::Unsupported,\n-        &\"operation not supported on this platform\",\n+        \"operation not supported on this platform\",\n     )\n }\n "}, {"sha": "a43407bd0f8652a767cef42a221a33c83d26fd13", "filename": "library/std/src/sys/solid/net.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -243,9 +243,9 @@ impl Socket {\n         }\n \n         if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"cannot set a 0 duration timeout\",\n+                \"cannot set a 0 duration timeout\",\n             ));\n         }\n \n@@ -271,7 +271,7 @@ impl Socket {\n         };\n \n         match n {\n-            0 => Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\")),\n+            0 => Err(io::const_io_error!(io::ErrorKind::TimedOut, \"connection timed out\")),\n             _ => {\n                 let can_write = writefds.num_fds != 0;\n                 if !can_write {\n@@ -364,9 +364,9 @@ impl Socket {\n         let timeout = match dur {\n             Some(dur) => {\n                 if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::InvalidInput,\n-                        &\"cannot set a 0 duration timeout\",\n+                        \"cannot set a 0 duration timeout\",\n                     ));\n                 }\n "}, {"sha": "22239e1fa8ebc1944be2e0ae43e8f13b92b90a34", "filename": "library/std/src/sys/solid/os.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -173,11 +173,7 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n /// In kmclib, `setenv` and `unsetenv` don't always set `errno`, so this\n /// function just returns a generic error.\n fn cvt_env(t: c_int) -> io::Result<c_int> {\n-    if t == -1 {\n-        Err(io::Error::new_const(io::ErrorKind::Uncategorized, &\"failure\"))\n-    } else {\n-        Ok(t)\n-    }\n+    if t == -1 { Err(io::const_io_error!(io::ErrorKind::Uncategorized, \"failure\")) } else { Ok(t) }\n }\n \n pub fn temp_dir() -> PathBuf {"}, {"sha": "8bd0b9b14afedb4cb14c7b23eb1abee90ffecaf2", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -387,17 +387,17 @@ impl FileAttr {\n                         tv_nsec: ext.stx_btime.tv_nsec as _,\n                     }))\n                 } else {\n-                    Err(io::Error::new_const(\n+                    Err(io::const_io_error!(\n                         io::ErrorKind::Uncategorized,\n-                        &\"creation time is not available for the filesystem\",\n+                        \"creation time is not available for the filesystem\",\n                     ))\n                 };\n             }\n         }\n \n-        Err(io::Error::new_const(\n+        Err(io::const_io_error!(\n             io::ErrorKind::Unsupported,\n-            &\"creation time is not available on this platform \\\n+            \"creation time is not available on this platform \\\n                             currently\",\n         ))\n     }"}, {"sha": "d13e1ecbbfed4c8627a1f9ecf2ae91a5878c0a14", "filename": "library/std/src/sys/unix/l4re.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -1,8 +1,8 @@\n macro_rules! unimpl {\n     () => {\n-        return Err(io::Error::new_const(\n+        return Err(io::const_io_error!(\n             io::ErrorKind::Unsupported,\n-            &\"No networking available on L4Re.\",\n+            \"No networking available on L4Re.\",\n         ));\n     };\n }"}, {"sha": "6382354eb6ebd050e218a059eb786d24a807020b", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -322,9 +322,6 @@ mod unsupported {\n     }\n \n     pub fn unsupported_err() -> io::Error {\n-        io::Error::new_const(\n-            io::ErrorKind::Unsupported,\n-            &\"operation not supported on this platform\",\n-        )\n+        io::const_io_error!(io::ErrorKind::Unsupported, \"operation not supported on this platform\",)\n     }\n }"}, {"sha": "61c15ecd85de3ce0a80355126d86fa899671cdb3", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -154,9 +154,9 @@ impl Socket {\n         let mut pollfd = libc::pollfd { fd: self.as_raw_fd(), events: libc::POLLOUT, revents: 0 };\n \n         if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"cannot set a 0 duration timeout\",\n+                \"cannot set a 0 duration timeout\",\n             ));\n         }\n \n@@ -165,7 +165,7 @@ impl Socket {\n         loop {\n             let elapsed = start.elapsed();\n             if elapsed >= timeout {\n-                return Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\"));\n+                return Err(io::const_io_error!(io::ErrorKind::TimedOut, \"connection timed out\"));\n             }\n \n             let timeout = timeout - elapsed;\n@@ -192,9 +192,9 @@ impl Socket {\n                     // for POLLHUP rather than read readiness\n                     if pollfd.revents & libc::POLLHUP != 0 {\n                         let e = self.take_error()?.unwrap_or_else(|| {\n-                            io::Error::new_const(\n+                            io::const_io_error!(\n                                 io::ErrorKind::Uncategorized,\n-                                &\"no error set after POLLHUP\",\n+                                \"no error set after POLLHUP\",\n                             )\n                         });\n                         return Err(e);\n@@ -338,9 +338,9 @@ impl Socket {\n         let timeout = match dur {\n             Some(dur) => {\n                 if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::InvalidInput,\n-                        &\"cannot set a 0 duration timeout\",\n+                        \"cannot set a 0 duration timeout\",\n                     ));\n                 }\n "}, {"sha": "b268ef5c36400ba3c2aa97cc97f61792d2e83c4c", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -294,9 +294,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n                 0,\n             ))?;\n             if path_len <= 1 {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::Uncategorized,\n-                    &\"KERN_PROC_PATHNAME sysctl returned zero-length string\",\n+                    \"KERN_PROC_PATHNAME sysctl returned zero-length string\",\n                 ));\n             }\n             let mut path: Vec<u8> = Vec::with_capacity(path_len);\n@@ -317,9 +317,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         if curproc_exe.is_file() {\n             return crate::fs::read_link(curproc_exe);\n         }\n-        Err(io::Error::new_const(\n+        Err(io::const_io_error!(\n             io::ErrorKind::Uncategorized,\n-            &\"/proc/curproc/exe doesn't point to regular file.\",\n+            \"/proc/curproc/exe doesn't point to regular file.\",\n         ))\n     }\n     sysctl().or_else(|_| procfs())\n@@ -336,9 +336,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _, &mut argv_len, ptr::null_mut(), 0))?;\n         argv.set_len(argv_len as usize);\n         if argv[0].is_null() {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::Uncategorized,\n-                &\"no current exe available\",\n+                \"no current exe available\",\n             ));\n         }\n         let argv0 = CStr::from_ptr(argv[0]).to_bytes();\n@@ -353,9 +353,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n #[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"emscripten\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     match crate::fs::read_link(\"/proc/self/exe\") {\n-        Err(ref e) if e.kind() == io::ErrorKind::NotFound => Err(io::Error::new_const(\n+        Err(ref e) if e.kind() == io::ErrorKind::NotFound => Err(io::const_io_error!(\n             io::ErrorKind::Uncategorized,\n-            &\"no /proc/self/exe available. Is /proc mounted?\",\n+            \"no /proc/self/exe available. Is /proc mounted?\",\n         )),\n         other => other,\n     }\n@@ -417,7 +417,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         );\n         if result != 0 {\n             use crate::io::ErrorKind;\n-            Err(io::Error::new_const(ErrorKind::Uncategorized, &\"Error getting executable path\"))\n+            Err(io::const_io_error!(ErrorKind::Uncategorized, \"Error getting executable path\"))\n         } else {\n             let name = CStr::from_ptr((*info.as_ptr()).name.as_ptr()).to_bytes();\n             Ok(PathBuf::from(OsStr::from_bytes(name)))\n@@ -433,7 +433,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n #[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     use crate::io::ErrorKind;\n-    Err(io::Error::new_const(ErrorKind::Unsupported, &\"Not yet implemented!\"))\n+    Err(io::const_io_error!(ErrorKind::Unsupported, \"Not yet implemented!\"))\n }\n \n #[cfg(target_os = \"vxworks\")]"}, {"sha": "09bfd9680f5b2c50841d9ee9b9267c1a62e6e7a7", "filename": "library/std/src/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -23,9 +23,9 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"nul byte found in provided data\",\n+                \"nul byte found in provided data\",\n             ));\n         }\n \n@@ -38,9 +38,9 @@ impl Command {\n \n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n         if self.saw_nul() {\n-            return io::Error::new_const(\n+            return io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n-                &\"nul byte found in provided data\",\n+                \"nul byte found in provided data\",\n             );\n         }\n \n@@ -186,9 +186,9 @@ impl Process {\n             ))?;\n         }\n         if actual != 1 {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidData,\n-                &\"Failed to get exit status of process\",\n+                \"Failed to get exit status of process\",\n             ));\n         }\n         Ok(ExitStatus(proc_info.return_code))\n@@ -224,9 +224,9 @@ impl Process {\n             ))?;\n         }\n         if actual != 1 {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidData,\n-                &\"Failed to get exit status of process\",\n+                \"Failed to get exit status of process\",\n             ));\n         }\n         Ok(Some(ExitStatus(proc_info.return_code)))"}, {"sha": "9fc2d9fce4dc41b5df8c5fe2b0a5762a03b1bb24", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -44,9 +44,9 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"nul byte found in provided data\",\n+                \"nul byte found in provided data\",\n             ));\n         }\n \n@@ -222,10 +222,7 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return io::Error::new_const(\n-                ErrorKind::InvalidInput,\n-                &\"nul byte found in provided data\",\n-            );\n+            return io::const_io_error!(ErrorKind::InvalidInput, \"nul byte found in provided data\",);\n         }\n \n         match self.setup_io(default, true) {\n@@ -581,9 +578,9 @@ impl Process {\n         // and used for another process, and we probably shouldn't be killing\n         // random processes, so just return an error.\n         if self.status.is_some() {\n-            Err(Error::new_const(\n+            Err(io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"invalid argument: can't kill an exited process\",\n+                \"invalid argument: can't kill an exited process\",\n             ))\n         } else {\n             cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(drop)"}, {"sha": "c6714d3aae246ffb8d640b8cb34106dfcfc31d8b", "filename": "library/std/src/sys/unix/process/process_vxworks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -24,9 +24,9 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"nul byte found in provided data\",\n+                \"nul byte found in provided data\",\n             ));\n         }\n         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n@@ -142,9 +142,9 @@ impl Process {\n         // and used for another process, and we probably shouldn't be killing\n         // random processes, so just return an error.\n         if self.status.is_some() {\n-            Err(Error::new_const(\n+            Err(io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"invalid argument: can't kill an exited process\",\n+                \"invalid argument: can't kill an exited process\",\n             ))\n         } else {\n             cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(drop)"}, {"sha": "cf8cf5ad49f73d03f3122f7a81a318928d8e23d5", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -287,7 +287,7 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n             }\n             match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n                 -1 => Err(io::Error::last_os_error()),\n-                0 => Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\")),\n+                0 => Err(io::const_io_error!(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\")),\n                 cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) }),\n             }\n         } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n@@ -318,7 +318,7 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n                 if res == -1 {\n                     return Err(io::Error::last_os_error());\n                 } else if cpus == 0 {\n-                    return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n+                    return Err(io::const_io_error!(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n                 }\n             }\n             Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n@@ -344,7 +344,7 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n             if res == -1 {\n                 return Err(io::Error::last_os_error());\n             } else if cpus == 0 {\n-                return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n+                return Err(io::const_io_error!(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n             }\n \n             Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n@@ -356,14 +356,14 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n                 let res = libc::get_system_info(&mut sinfo);\n \n                 if res != libc::B_OK {\n-                    return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n+                    return Err(io::const_io_error!(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n                 }\n \n                 Ok(NonZeroUsize::new_unchecked(sinfo.cpu_count as usize))\n             }\n         } else {\n             // FIXME: implement on vxWorks, Redox, l4re\n-            Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"Getting the number of hardware threads is not supported on the target platform\"))\n+            Err(io::const_io_error!(io::ErrorKind::Unsupported, \"Getting the number of hardware threads is not supported on the target platform\"))\n         }\n     }\n }"}, {"sha": "5274f53a7dbdb5be7fdcf270c4526d269885b681", "filename": "library/std/src/sys/unsupported/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -21,9 +21,9 @@ pub fn unsupported<T>() -> std_io::Result<T> {\n }\n \n pub fn unsupported_err() -> std_io::Error {\n-    std_io::Error::new_const(\n+    std_io::const_io_error!(\n         std_io::ErrorKind::Unsupported,\n-        &\"operation not supported on this platform\",\n+        \"operation not supported on this platform\",\n     )\n }\n "}, {"sha": "e150ae143ad99b271338186ba51110a55e2cfd97", "filename": "library/std/src/sys/unsupported/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fos.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -81,11 +81,11 @@ pub fn getenv(_: &OsStr) -> Option<OsString> {\n }\n \n pub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {\n-    Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"cannot set env vars on this platform\"))\n+    Err(io::const_io_error!(io::ErrorKind::Unsupported, \"cannot set env vars on this platform\"))\n }\n \n pub fn unsetenv(_: &OsStr) -> io::Result<()> {\n-    Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"cannot unset env vars on this platform\"))\n+    Err(io::const_io_error!(io::ErrorKind::Unsupported, \"cannot unset env vars on this platform\"))\n }\n \n pub fn temp_dir() -> PathBuf {"}, {"sha": "cd6815bfc2136786e36a73b6225852782535453d", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -711,7 +711,7 @@ fn open_parent(p: &Path) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n \n pub fn osstr2str(f: &OsStr) -> io::Result<&str> {\n     f.to_str()\n-        .ok_or_else(|| io::Error::new_const(io::ErrorKind::Uncategorized, &\"input must be utf-8\"))\n+        .ok_or_else(|| io::const_io_error!(io::ErrorKind::Uncategorized, \"input must be utf-8\"))\n }\n \n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n@@ -757,7 +757,7 @@ fn remove_dir_all_recursive(parent: &WasiFd, path: &Path) -> io::Result<()> {\n     for entry in ReadDir::new(fd, dummy_root) {\n         let entry = entry?;\n         let path = crate::str::from_utf8(&entry.name).map_err(|_| {\n-            io::Error::new_const(io::ErrorKind::Uncategorized, &\"invalid utf-8 file name found\")\n+            io::const_io_error!(io::ErrorKind::Uncategorized, \"invalid utf-8 file name found\")\n         })?;\n \n         if entry.file_type()?.is_dir() {"}, {"sha": "fed655af87e635070d077b36734205205c98d40e", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -511,9 +511,9 @@ impl File {\n                     )\n                 }\n                 _ => {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::Uncategorized,\n-                        &\"Unsupported reparse point type\",\n+                        \"Unsupported reparse point type\",\n                     ));\n                 }\n             };\n@@ -1124,9 +1124,9 @@ pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n \n #[cfg(target_vendor = \"uwp\")]\n pub fn link(_original: &Path, _link: &Path) -> io::Result<()> {\n-    return Err(io::Error::new_const(\n+    return Err(io::const_io_error!(\n         io::ErrorKind::Unsupported,\n-        &\"hard link are not supported on UWP\",\n+        \"hard link are not supported on UWP\",\n     ));\n }\n "}, {"sha": "c70f254cf39f8d734354a11c5400f864bb117f4d", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -160,9 +160,9 @@ pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> crate::io::Result<Vec<u16>> {\n     fn inner(s: &OsStr) -> crate::io::Result<Vec<u16>> {\n         let mut maybe_result: Vec<u16> = s.encode_wide().collect();\n         if unrolled_find_u16s(0, &maybe_result).is_some() {\n-            return Err(crate::io::Error::new_const(\n+            return Err(crate::io::const_io_error!(\n                 ErrorKind::InvalidInput,\n-                &\"strings passed to WinAPI cannot contain NULs\",\n+                \"strings passed to WinAPI cannot contain NULs\",\n             ));\n         }\n         maybe_result.push(0);"}, {"sha": "aa6400aeefa0ddb2cb186c36f8e3ef3c636b2c5e", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -152,9 +152,9 @@ impl Socket {\n         match result {\n             Err(ref error) if error.kind() == io::ErrorKind::WouldBlock => {\n                 if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::InvalidInput,\n-                        &\"cannot set a 0 duration timeout\",\n+                        \"cannot set a 0 duration timeout\",\n                     ));\n                 }\n \n@@ -185,9 +185,7 @@ impl Socket {\n                 };\n \n                 match count {\n-                    0 => {\n-                        Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\"))\n-                    }\n+                    0 => Err(io::const_io_error!(io::ErrorKind::TimedOut, \"connection timed out\")),\n                     _ => {\n                         if writefds.fd_count != 1 {\n                             if let Some(e) = self.take_error()? {\n@@ -353,9 +351,9 @@ impl Socket {\n             Some(dur) => {\n                 let timeout = sys::dur2timeout(dur);\n                 if timeout == 0 {\n-                    return Err(io::Error::new_const(\n+                    return Err(io::const_io_error!(\n                         io::ErrorKind::InvalidInput,\n-                        &\"cannot set a 0 duration timeout\",\n+                        \"cannot set a 0 duration timeout\",\n                     ));\n                 }\n                 timeout"}, {"sha": "c6f641d0932bf4bb0aeaa514c8d718a4176b6d7c", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -149,7 +149,7 @@ impl AsRef<OsStr> for EnvKey {\n \n fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n     if str.as_ref().encode_wide().any(|b| b == 0) {\n-        Err(io::Error::new_const(ErrorKind::InvalidInput, &\"nul byte found in provided data\"))\n+        Err(io::const_io_error!(ErrorKind::InvalidInput, \"nul byte found in provided data\"))\n     } else {\n         Ok(str)\n     }\n@@ -369,9 +369,9 @@ fn resolve_exe<'a>(\n ) -> io::Result<PathBuf> {\n     // Early return if there is no filename.\n     if exe_path.is_empty() || path::has_trailing_slash(exe_path) {\n-        return Err(io::Error::new_const(\n+        return Err(io::const_io_error!(\n             io::ErrorKind::InvalidInput,\n-            &\"program path has no file name\",\n+            \"program path has no file name\",\n         ));\n     }\n     // Test if the file name has the `exe` extension.\n@@ -422,7 +422,7 @@ fn resolve_exe<'a>(\n         }\n     }\n     // If we get here then the executable cannot be found.\n-    Err(io::Error::new_const(io::ErrorKind::NotFound, &\"program not found\"))\n+    Err(io::const_io_error!(io::ErrorKind::NotFound, \"program not found\"))\n }\n \n // Calls `f` for every path that should be used to find an executable."}, {"sha": "a001d6b9858234a79bce1044e4d8c7e49bcf02b6", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -110,9 +110,9 @@ fn write(\n         if data[0] >> 6 != 0b10 {\n             // not a continuation byte - reject\n             incomplete_utf8.len = 0;\n-            return Err(io::Error::new_const(\n+            return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidData,\n-                &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n+                \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n             ));\n         }\n         incomplete_utf8.bytes[incomplete_utf8.len as usize] = data[0];\n@@ -132,9 +132,9 @@ fn write(\n                 return Ok(1);\n             }\n             Err(_) => {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidData,\n-                    &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n+                    \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n                 ));\n             }\n         }\n@@ -156,9 +156,9 @@ fn write(\n                 incomplete_utf8.len = 1;\n                 return Ok(1);\n             } else {\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidData,\n-                    &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n+                    \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n                 ));\n             }\n         }\n@@ -364,9 +364,9 @@ fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n             }\n             Err(_) => {\n                 // We can't really do any better than forget all data and return an error.\n-                return Err(io::Error::new_const(\n+                return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidData,\n-                    &\"Windows stdin in console mode does not support non-UTF-16 input; \\\n+                    \"Windows stdin in console mode does not support non-UTF-16 input; \\\n                      encountered unpaired surrogate\",\n                 ));\n             }"}, {"sha": "e4bba9255d23e774849196a88f09ee882638be2c", "filename": "library/std/src/sys/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -107,9 +107,9 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n         sysinfo.dwNumberOfProcessors as usize\n     };\n     match res {\n-        0 => Err(io::Error::new_const(\n+        0 => Err(io::const_io_error!(\n             io::ErrorKind::NotFound,\n-            &\"The number of hardware threads is not known for the target platform\",\n+            \"The number of hardware threads is not known for the target platform\",\n         )),\n         cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus) }),\n     }"}, {"sha": "617ac52e51ca81aeb24b4ddcc289cc31acacbcee", "filename": "library/std/src/sys_common/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -4,9 +4,9 @@ use crate::fs;\n use crate::io::{self, Error, ErrorKind};\n use crate::path::Path;\n \n-pub(crate) const NOT_FILE_ERROR: Error = Error::new_const(\n+pub(crate) const NOT_FILE_ERROR: Error = io::const_io_error!(\n     ErrorKind::InvalidInput,\n-    &\"the source path is neither a regular file nor a symlink to a regular file\",\n+    \"the source path is neither a regular file nor a symlink to a regular file\",\n );\n \n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {"}, {"sha": "70b29d4a92ed56f64b837474229fd208ee577d52", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/554918e311a1221744aa9b6d60e2f00f5b3155e5/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=554918e311a1221744aa9b6d60e2f00f5b3155e5", "patch": "@@ -5,7 +5,7 @@ use crate::cmp;\n use crate::convert::{TryFrom, TryInto};\n use crate::ffi::CString;\n use crate::fmt;\n-use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut};\n+use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::ptr;\n@@ -102,7 +102,7 @@ pub fn sockaddr_to_addr(storage: &c::sockaddr_storage, len: usize) -> io::Result\n                 *(storage as *const _ as *const c::sockaddr_in6)\n             })))\n         }\n-        _ => Err(Error::new_const(ErrorKind::InvalidInput, &\"invalid argument\")),\n+        _ => Err(io::const_io_error!(ErrorKind::InvalidInput, \"invalid argument\")),\n     }\n }\n \n@@ -165,7 +165,7 @@ impl TryFrom<&str> for LookupHost {\n             ($e:expr, $msg:expr) => {\n                 match $e {\n                     Some(r) => r,\n-                    None => return Err(io::Error::new_const(io::ErrorKind::InvalidInput, &$msg)),\n+                    None => return Err(io::const_io_error!(io::ErrorKind::InvalidInput, $msg)),\n                 }\n             };\n         }"}]}