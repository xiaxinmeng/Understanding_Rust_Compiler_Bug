{"sha": "02654a0844f5c8d29bac318c3c6c666da3d8543d", "node_id": "C_kwDOAAsO6NoAKDAyNjU0YTA4NDRmNWM4ZDI5YmFjMzE4YzNjNmM2NjZkYTNkODU0M2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-30T20:39:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-30T20:39:01Z"}, "message": "Auto merge of #98919 - 5225225:stricter-invalid-value, r=RalfJung\n\nStrengthen invalid_value lint to forbid uninit primitives, adjust docs to say that's UB\n\nFor context: https://github.com/rust-lang/rust/issues/66151#issuecomment-1174477404=\n\nThis does not make it a FCW, but it does explicitly state in the docs that uninit integers are UB.\n\nThis also doesn't affect any runtime behavior, uninit u32's will still successfully be created through mem::uninitialized.", "tree": {"sha": "e1d36bde13846d5c72ad483b3b42e040641adf70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1d36bde13846d5c72ad483b3b42e040641adf70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02654a0844f5c8d29bac318c3c6c666da3d8543d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02654a0844f5c8d29bac318c3c6c666da3d8543d", "html_url": "https://github.com/rust-lang/rust/commit/02654a0844f5c8d29bac318c3c6c666da3d8543d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02654a0844f5c8d29bac318c3c6c666da3d8543d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "350cca3b6a89d08fe2a3309be5233e7c8a2274c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/350cca3b6a89d08fe2a3309be5233e7c8a2274c9", "html_url": "https://github.com/rust-lang/rust/commit/350cca3b6a89d08fe2a3309be5233e7c8a2274c9"}, {"sha": "be324607ea90340001b00b4554502c8ec937313d", "url": "https://api.github.com/repos/rust-lang/rust/commits/be324607ea90340001b00b4554502c8ec937313d", "html_url": "https://github.com/rust-lang/rust/commit/be324607ea90340001b00b4554502c8ec937313d"}], "stats": {"total": 100, "additions": 81, "deletions": 19}, "files": [{"sha": "868555a72b0d1284f94982c90cc8dcd600a9f486", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02654a0844f5c8d29bac318c3c6c666da3d8543d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02654a0844f5c8d29bac318c3c6c666da3d8543d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=02654a0844f5c8d29bac318c3c6c666da3d8543d", "patch": "@@ -2469,6 +2469,15 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 Char if init == InitKind::Uninit => {\n                     Some((\"characters must be a valid Unicode codepoint\".to_string(), None))\n                 }\n+                Int(_) | Uint(_) if init == InitKind::Uninit => {\n+                    Some((\"integers must not be uninitialized\".to_string(), None))\n+                }\n+                Float(_) if init == InitKind::Uninit => {\n+                    Some((\"floats must not be uninitialized\".to_string(), None))\n+                }\n+                RawPtr(_) if init == InitKind::Uninit => {\n+                    Some((\"raw pointers must not be uninitialized\".to_string(), None))\n+                }\n                 // Recurse and checks for some compound types.\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n                     // First check if this ADT has a layout attribute (like `NonNull` and friends)."}, {"sha": "2490c07679dd0f60940898a1d806c1ef08714a81", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02654a0844f5c8d29bac318c3c6c666da3d8543d/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02654a0844f5c8d29bac318c3c6c666da3d8543d/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=02654a0844f5c8d29bac318c3c6c666da3d8543d", "patch": "@@ -54,9 +54,6 @@ use crate::slice;\n /// // The equivalent code with `MaybeUninit<i32>`:\n /// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! \u26a0\ufe0f\n /// ```\n-/// (Notice that the rules around uninitialized integers are not finalized yet, but\n-/// until they are, it is advisable to avoid them.)\n-///\n /// On top of that, remember that most types have additional invariants beyond merely\n /// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n /// is considered initialized (under the current implementation; this does not constitute"}, {"sha": "d2dd2941d590f42c08f65e0a1a7a81a55c8e9c1b", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02654a0844f5c8d29bac318c3c6c666da3d8543d/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02654a0844f5c8d29bac318c3c6c666da3d8543d/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=02654a0844f5c8d29bac318c3c6c666da3d8543d", "patch": "@@ -665,14 +665,14 @@ pub unsafe fn zeroed<T>() -> T {\n /// correctly: it has the same effect as [`MaybeUninit::uninit().assume_init()`][uninit].\n /// As the [`assume_init` documentation][assume_init] explains,\n /// [the Rust compiler assumes][inv] that values are properly initialized.\n-/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n-/// undefined behavior for returning a `bool` that is not definitely either `true`\n-/// or `false`. Worse, truly uninitialized memory like what gets returned here\n+///\n+/// Truly uninitialized memory like what gets returned here\n /// is special in that the compiler knows that it does not have a fixed value.\n /// This makes it undefined behavior to have uninitialized data in a variable even\n /// if that variable has an integer type.\n-/// (Notice that the rules around uninitialized integers are not finalized yet, but\n-/// until they are, it is advisable to avoid them.)\n+///\n+/// Therefore, it is immediate undefined behavior to call this function on nearly all types,\n+/// including integer types and arrays of integer types, and even if the result is unused.\n ///\n /// [uninit]: MaybeUninit::uninit\n /// [assume_init]: MaybeUninit::assume_init"}, {"sha": "dae258407ebb0801cbf888343495196370ff1ca4", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/02654a0844f5c8d29bac318c3c6c666da3d8543d/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02654a0844f5c8d29bac318c3c6c666da3d8543d/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=02654a0844f5c8d29bac318c3c6c666da3d8543d", "patch": "@@ -100,6 +100,18 @@ fn main() {\n         let _val: [bool; 2] = mem::zeroed();\n         let _val: [bool; 2] = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: i32 = mem::zeroed();\n+        let _val: i32 = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: f32 = mem::zeroed();\n+        let _val: f32 = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: *const () = mem::zeroed();\n+        let _val: *const () = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: *const [()] = mem::zeroed();\n+        let _val: *const [()] = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Transmute-from-0\n         let _val: &'static i32 = mem::transmute(0usize); //~ ERROR: does not permit zero-initialization\n         let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n@@ -114,13 +126,12 @@ fn main() {\n         let _val: Option<&'static i32> = mem::zeroed();\n         let _val: Option<fn()> = mem::zeroed();\n         let _val: MaybeUninit<&'static i32> = mem::zeroed();\n-        let _val: i32 = mem::zeroed();\n         let _val: bool = MaybeUninit::zeroed().assume_init();\n         let _val: [bool; 0] = MaybeUninit::uninit().assume_init();\n         let _val: [!; 0] = MaybeUninit::zeroed().assume_init();\n+\n         // Some things that happen to work due to rustc implementation details,\n         // but are not guaranteed to keep working.\n-        let _val: i32 = mem::uninitialized();\n         let _val: OneFruit = mem::uninitialized();\n     }\n }"}, {"sha": "b46042e7be43f8100e3ea3f68426ba2bb53ad051", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/02654a0844f5c8d29bac318c3c6c666da3d8543d/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02654a0844f5c8d29bac318c3c6c666da3d8543d/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=02654a0844f5c8d29bac318c3c6c666da3d8543d", "patch": "@@ -97,7 +97,7 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              this code causes undefined behavior when executed\n    |                              help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: the `!` type has no valid value\n+   = note: integers must not be uninitialized\n \n error: the type `Void` does not permit zero-initialization\n   --> $DIR/uninitialized-zeroed.rs:57:26\n@@ -414,8 +414,52 @@ LL |         let _val: [bool; 2] = mem::uninitialized();\n    |\n    = note: booleans must be either `true` or `false`\n \n+error: the type `i32` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:104:25\n+   |\n+LL |         let _val: i32 = mem::uninitialized();\n+   |                         ^^^^^^^^^^^^^^^^^^^^\n+   |                         |\n+   |                         this code causes undefined behavior when executed\n+   |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: integers must not be uninitialized\n+\n+error: the type `f32` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:107:25\n+   |\n+LL |         let _val: f32 = mem::uninitialized();\n+   |                         ^^^^^^^^^^^^^^^^^^^^\n+   |                         |\n+   |                         this code causes undefined behavior when executed\n+   |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: floats must not be uninitialized\n+\n+error: the type `*const ()` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:110:31\n+   |\n+LL |         let _val: *const () = mem::uninitialized();\n+   |                               ^^^^^^^^^^^^^^^^^^^^\n+   |                               |\n+   |                               this code causes undefined behavior when executed\n+   |                               help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: raw pointers must not be uninitialized\n+\n+error: the type `*const [()]` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:113:33\n+   |\n+LL |         let _val: *const [()] = mem::uninitialized();\n+   |                                 ^^^^^^^^^^^^^^^^^^^^\n+   |                                 |\n+   |                                 this code causes undefined behavior when executed\n+   |                                 help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: raw pointers must not be uninitialized\n+\n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:104:34\n+  --> $DIR/uninitialized-zeroed.rs:116:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -426,7 +470,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    = note: references must be non-null\n \n error: the type `&[i32]` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:105:36\n+  --> $DIR/uninitialized-zeroed.rs:117:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -437,7 +481,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    = note: references must be non-null\n \n error: the type `NonZeroU32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:106:32\n+  --> $DIR/uninitialized-zeroed.rs:118:32\n    |\n LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n@@ -448,7 +492,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:109:34\n+  --> $DIR/uninitialized-zeroed.rs:121:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -459,7 +503,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:110:34\n+  --> $DIR/uninitialized-zeroed.rs:122:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -470,7 +514,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:111:26\n+  --> $DIR/uninitialized-zeroed.rs:123:26\n    |\n LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -480,5 +524,5 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |\n    = note: booleans must be either `true` or `false`\n \n-error: aborting due to 39 previous errors\n+error: aborting due to 43 previous errors\n "}, {"sha": "adda51f6be0ecb97eddee6bae8a86136153594ce", "filename": "src/test/ui/sanitize/memory.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02654a0844f5c8d29bac318c3c6c666da3d8543d/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02654a0844f5c8d29bac318c3c6c666da3d8543d/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fmemory.rs?ref=02654a0844f5c8d29bac318c3c6c666da3d8543d", "patch": "@@ -14,6 +14,7 @@\n #![feature(core_intrinsics)]\n #![feature(start)]\n #![feature(bench_black_box)]\n+#![allow(invalid_value)]\n \n use std::hint::black_box;\n use std::mem::MaybeUninit;"}, {"sha": "2113173170868409b861f0eaa34fc54ec27a34de", "filename": "src/tools/clippy/tests/ui/uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02654a0844f5c8d29bac318c3c6c666da3d8543d/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02654a0844f5c8d29bac318c3c6c666da3d8543d/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit.rs?ref=02654a0844f5c8d29bac318c3c6c666da3d8543d", "patch": "@@ -1,5 +1,5 @@\n #![feature(stmt_expr_attributes)]\n-#![allow(clippy::let_unit_value)]\n+#![allow(clippy::let_unit_value, invalid_value)]\n \n use std::mem::{self, MaybeUninit};\n "}]}