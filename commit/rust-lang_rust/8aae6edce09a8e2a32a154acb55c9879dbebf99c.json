{"sha": "8aae6edce09a8e2a32a154acb55c9879dbebf99c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYWU2ZWRjZTA5YThlMmEzMmExNTRhY2I1NWM5ODc5ZGJlYmY5OWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-20T16:10:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-20T16:10:34Z"}, "message": "auto merge of #7710 : michaelwoerister/rust/WP4, r=jdm\n\nThis pull request includes various improvements:\r\n\r\n+ Composite types (structs, tuples, boxes, etc) are now handled more cleanly by debuginfo generation. Most notably, field offsets are now extracted directly from LLVM types, as opposed to trying to reconstruct them. This leads to more stable handling of edge cases (e.g. packed structs or structs implementing drop).\r\n\r\n+ `debuginfo.rs` in general has seen a major cleanup. This includes better formatting, more readable variable and function names, removal of dead code, and better factoring of functionality.\r\n\r\n+ Handling of `VariantInfo` in `ty.rs` has been improved. That is, the `type VariantInfo = @VariantInfo_` typedef has been replaced with explicit uses of @VariantInfo, and the duplicated logic for creating VariantInfo instances in `ty::enum_variants()` and `typeck::check::mod::check_enum_variants()` has been unified into a single constructor function. Both function now look nicer too :)\r\n\r\n+ Debug info generation for enum types is now mostly supported. This includes:\r\n  + Good support for C-style enums. Both DWARF and `gdb` know how to handle them.\r\n  + Proper description of tuple- and struct-style enum variants as unions of structs.\r\n  + Proper handling of univariant enums without discriminator field.\r\n  + Unfortunately `gdb` always prints all possible interpretations of a union, so debug output of enums is verbose and unintuitive. Neither `LLVM` nor `gdb` support DWARF's `DW_TAG_variant` which allows to properly describe tagged unions. Adding support for this to `LLVM` seems doable. `gdb` however is another story. In the future we might be able to use `gdb`'s Python scripting support to alleviate this problem. In agreement with @jdm this is not a high priority for now.\r\n\r\n+ The debuginfo test suite has been extended with 14 test files including tests for packed structs (with Drop), boxed structs, boxed vecs, vec slices, c-style enums (standalone and embedded), empty enums, tuple- and struct-style enums, and various pointer types to the above.\r\n\r\n~~What is not yet included is DI support for some enum edge-cases represented as described in `trans::adt::NullablePointer`.~~\r\n\r\nCheers,\r\nMichael\r\n\r\nPS: closes #7819,  fixes #7712", "tree": {"sha": "d77d6659847631f404dcf08529e3b3bd0b7fa4e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d77d6659847631f404dcf08529e3b3bd0b7fa4e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8aae6edce09a8e2a32a154acb55c9879dbebf99c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8aae6edce09a8e2a32a154acb55c9879dbebf99c", "html_url": "https://github.com/rust-lang/rust/commit/8aae6edce09a8e2a32a154acb55c9879dbebf99c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8aae6edce09a8e2a32a154acb55c9879dbebf99c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a1db2d1e631feede472396fced1806dfd3cf677", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a1db2d1e631feede472396fced1806dfd3cf677", "html_url": "https://github.com/rust-lang/rust/commit/3a1db2d1e631feede472396fced1806dfd3cf677"}, {"sha": "a1303cc81565a019d59be28940a94caf0f9329bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1303cc81565a019d59be28940a94caf0f9329bf", "html_url": "https://github.com/rust-lang/rust/commit/a1303cc81565a019d59be28940a94caf0f9329bf"}], "stats": {"total": 3469, "additions": 2728, "deletions": 741}, "files": [{"sha": "7acd9545efdd016f734a8584ed13b6b2822f2473", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -1635,6 +1635,14 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMABIAlignmentOfType(TD: TargetDataRef,\n                                   Ty: TypeRef) -> c_uint;\n+\n+        /** Computes the byte offset of the indexed struct element for a target. */\n+        #[fast_ffi]\n+        pub unsafe fn LLVMOffsetOfElement(TD: TargetDataRef,\n+                                          StructTy: TypeRef,\n+                                          Element: c_uint)\n+                                       -> c_ulonglong;\n+\n         /**\n          * Returns the minimum alignment of a type when part of a call frame.\n          */\n@@ -2089,6 +2097,37 @@ pub mod llvm {\n             Val: ValueRef,\n             VarInfo: DIVariable,\n             InsertBefore: ValueRef) -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateEnumerator(\n+            Builder: DIBuilderRef,\n+            Name: *c_char,\n+            Val: c_ulonglong) -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateEnumerationType(\n+            Builder: DIBuilderRef,\n+            Scope: ValueRef,\n+            Name: *c_char,\n+            File: ValueRef,\n+            LineNumber: c_uint,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Elements: ValueRef,\n+            ClassType: ValueRef) -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateUnionType(\n+            Builder: DIBuilderRef,\n+            Scope: ValueRef,\n+            Name: *c_char,\n+            File: ValueRef,\n+            LineNumber: c_uint,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Flags: c_uint ,\n+            Elements: ValueRef,\n+            RunTimeLang: c_uint) -> ValueRef;\n     }\n }\n "}, {"sha": "6fd0ca0647427670c1e3f1211d13aa6134d9752b", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -90,7 +90,7 @@ pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::def_id,\n }\n \n pub fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n-                      -> ~[ty::VariantInfo] {\n+                      -> ~[@ty::VariantInfo] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)"}, {"sha": "15ffccfe70dba83cd692ef151d2e950442ec1239", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -737,11 +737,11 @@ pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n }\n \n pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n-                     tcx: ty::ctxt) -> ~[ty::VariantInfo] {\n+                     tcx: ty::ctxt) -> ~[@ty::VariantInfo] {\n     let data = cdata.data;\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n-    let mut infos: ~[ty::VariantInfo] = ~[];\n+    let mut infos: ~[@ty::VariantInfo] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n     for variant_ids.iter().advance |did| {\n@@ -757,11 +757,16 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n           Some(val) => { disr_val = val; }\n           _         => { /* empty */ }\n         }\n-        infos.push(@ty::VariantInfo_{args: arg_tys,\n-                       ctor_ty: ctor_ty, name: name,\n-                  // I'm not even sure if we encode visibility\n-                  // for variants -- TEST -- tjc\n-                  id: *did, disr_val: disr_val, vis: ast::inherited});\n+        infos.push(@ty::VariantInfo{\n+            args: arg_tys,\n+            arg_names: None,\n+            ctor_ty: ctor_ty,\n+            name: name,\n+            // I'm not even sure if we encode visibility\n+            // for variants -- TEST -- tjc\n+            id: *did,\n+            disr_val: disr_val,\n+            vis: ast::inherited});\n         disr_val += 1;\n     }\n     return infos;"}, {"sha": "fd38ec39bb1bba0d312cb5949fca12765c5184e4", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -94,7 +94,7 @@ pub enum Repr {\n }\n \n /// For structs, and struct-like parts of anything fancier.\n-struct Struct {\n+pub struct Struct {\n     size: u64,\n     align: u64,\n     packed: bool,"}, {"sha": "cd07453a60bac64f4f03e33bb92aa1b3c36ca24e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -670,7 +670,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     let _icx = push_ctxt(\"iter_structural_ty\");\n \n     fn iter_variant(cx: block, repr: &adt::Repr, av: ValueRef,\n-                    variant: ty::VariantInfo,\n+                    variant: @ty::VariantInfo,\n                     tps: &[ty::t], f: val_and_ty_fn) -> block {\n         let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n@@ -1141,7 +1141,7 @@ pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n                     bcx = init_local(bcx, *local);\n                     if cx.sess().opts.extra_debuginfo\n                         && fcx_has_nonzero_span(bcx.fcx) {\n-                        debuginfo::create_local_var(bcx, *local);\n+                        debuginfo::create_local_var_metadata(bcx, *local);\n                     }\n                 }\n                 ast::decl_item(i) => trans_item(cx.fcx.ccx, i)\n@@ -1773,7 +1773,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         bcx = _match::store_arg(bcx, args[arg_n].pat, llarg);\n \n         if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n-            debuginfo::create_arg(bcx, &args[arg_n], args[arg_n].ty.span);\n+            debuginfo::create_argument_metadata(bcx, &args[arg_n], args[arg_n].ty.span);\n         }\n     }\n \n@@ -1947,7 +1947,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                   |fcx| {\n                       if ccx.sess.opts.extra_debuginfo\n                           && fcx_has_nonzero_span(fcx) {\n-                          debuginfo::create_function(fcx);\n+                          debuginfo::create_function_metadata(fcx);\n                       }\n                   },\n                   |_bcx| { });\n@@ -2109,7 +2109,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n }\n \n pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n-                      id: ast::node_id, vi: @~[ty::VariantInfo],\n+                      id: ast::node_id, vi: @~[@ty::VariantInfo],\n                       i: &mut uint) {\n     for enum_definition.variants.iter().advance |variant| {\n         let disr_val = vi[*i].disr_val;"}, {"sha": "0e75e4e85c2f2f9f61d19830a4ae9aa5efb02b03", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 870, "deletions": 446, "changes": 1316, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -27,11 +27,18 @@ where possible. This will hopefully ease the adaption of this module to future L\n \n The public API of the module is a set of functions that will insert the correct metadata into the\n LLVM IR when called with the right parameters. The module is thus driven from an outside client with\n-functions like `debuginfo::create_local_var(bcx: block, local: @ast::local)`.\n+functions like `debuginfo::local_var_metadata(bcx: block, local: &ast::local)`.\n \n-Internally the module will try to reuse already created metadata by utilizing a cache. All private\n-state used by the module is stored within a DebugContext struct, which in turn is contained in the\n-CrateContext.\n+Internally the module will try to reuse already created metadata by utilizing a cache. The way to\n+get a shared metadata node when needed is thus to just call the corresponding function in this\n+module:\n+\n+    let file_metadata = file_metadata(crate_context, path);\n+\n+The function will take care of probing the cache for an existing node for that exact file path.\n+\n+All private state used by the module is stored within a DebugContext struct, which in turn is\n+contained in the CrateContext.\n \n \n This file consists of three conceptual sections:\n@@ -44,31 +51,29 @@ This file consists of three conceptual sections:\n \n use driver::session;\n use lib::llvm::llvm;\n-use lib::llvm::{ValueRef, ModuleRef, ContextRef};\n+use lib::llvm::{ModuleRef, ContextRef};\n use lib::llvm::debuginfo::*;\n use middle::trans::common::*;\n use middle::trans::machine;\n use middle::trans::type_of;\n+use middle::trans::type_::Type;\n+use middle::trans::adt;\n use middle::trans;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n use std::hashmap::HashMap;\n-use std::libc;\n-use std::libc::{c_uint, c_ulonglong};\n-use std::cmp;\n+use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::str::as_c_str;\n-use std::sys;\n use std::vec;\n use syntax::codemap::span;\n use syntax::{ast, codemap, ast_util, ast_map};\n-use syntax::parse::token;\n \n static DW_LANG_RUST: int = 0x9000;\n \n-static AutoVariableTag: int = 256;\n-static ArgVariableTag: int = 257;\n+static DW_TAG_auto_variable: int = 0x100;\n+static DW_TAG_arg_variable: int = 0x101;\n \n static DW_ATE_boolean: int = 0x02;\n static DW_ATE_float: int = 0x04;\n@@ -118,7 +123,7 @@ impl DebugContext {\n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: @mut CrateContext) {\n     debug!(\"finalize\");\n-    create_compile_unit(cx);\n+    compile_unit_metadata(cx);\n     unsafe {\n         llvm::LLVMDIBuilderFinalize(DIB(cx));\n         llvm::LLVMDIBuilderDispose(DIB(cx));\n@@ -129,7 +134,7 @@ pub fn finalize(cx: @mut CrateContext) {\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n+pub fn create_local_var_metadata(bcx: block, local: @ast::local) -> DIVariable {\n     let cx = bcx.ccx();\n \n     let ident = match local.node.pat.node {\n@@ -140,24 +145,35 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n         return ptr::null();\n       }\n     };\n+\n     let name: &str = cx.sess.str_of(ident);\n-    debug!(\"create_local_var: %s\", name);\n+    debug!(\"create_local_var_metadata: %s\", name);\n \n     let loc = span_start(cx, local.span);\n     let ty = node_id_type(bcx, local.node.id);\n-    let tymd = create_ty(cx, ty, local.node.ty.span);\n-    let filemd = create_file(cx, loc.file.name);\n+    let type_metadata = type_metadata(cx, ty, local.node.ty.span);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n+\n     let context = match bcx.parent {\n-        None => create_function(bcx.fcx),\n-        Some(_) => create_block(bcx)\n+        None => create_function_metadata(bcx.fcx),\n+        Some(_) => lexical_block_metadata(bcx)\n     };\n \n-    let var_md = do as_c_str(name) |name| { unsafe {\n-        llvm::LLVMDIBuilderCreateLocalVariable(\n-            DIB(cx), AutoVariableTag as u32,\n-            context, name, filemd,\n-            loc.line as c_uint, tymd, false, 0, 0)\n-        }};\n+    let var_metadata = do as_c_str(name) |name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateLocalVariable(\n+                DIB(cx),\n+                DW_TAG_auto_variable as u32,\n+                context,\n+                name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                type_metadata,\n+                false,\n+                0,\n+                0)\n+        }\n+    };\n \n     // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n     let llptr = match bcx.fcx.lllocals.find_copy(&local.node.pat.id) {\n@@ -169,24 +185,25 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n         }\n     };\n \n-    set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+    set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n     unsafe {\n-        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_md, bcx.llbb);\n+        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_metadata, bcx.llbb);\n         llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n     }\n \n-    return var_md;\n+    return var_metadata;\n }\n \n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_arg(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable> {\n-    debug!(\"create_arg\");\n+pub fn create_argument_metadata(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable> {\n+    debug!(\"create_argument_metadata\");\n     if true {\n-        // XXX create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n-        // up: \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n+        // XXX create_argument_metadata disabled for now because \"node_id_type(bcx, arg.id)\" below\n+        // blows up:\n+        // \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n         return None;\n     }\n \n@@ -199,38 +216,40 @@ pub fn create_arg(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable>\n     }\n \n     let ty = node_id_type(bcx, arg.id);\n-    let tymd = create_ty(cx, ty, arg.ty.span);\n-    let filemd = create_file(cx, loc.file.name);\n-    let context = create_function(fcx);\n+    let type_metadata = type_metadata(cx, ty, arg.ty.span);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n+    let context = create_function_metadata(fcx);\n \n     match arg.pat.node {\n         ast::pat_ident(_, ref path, _) => {\n             // XXX: This is wrong; it should work for multiple bindings.\n             let ident = path.idents.last();\n             let name: &str = cx.sess.str_of(*ident);\n-            let mdnode = do as_c_str(name) |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(\n-                    DIB(cx),\n-                    ArgVariableTag as u32,\n-                    context,\n-                    name,\n-                    filemd,\n-                    loc.line as c_uint,\n-                    tymd,\n-                    false,\n-                    0,\n-                    0)\n+            let var_metadata = do as_c_str(name) |name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateLocalVariable(\n+                        DIB(cx),\n+                        DW_TAG_arg_variable as u32,\n+                        context,\n+                        name,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        type_metadata,\n+                        false,\n+                        0,\n+                        0)\n                     // XXX need to pass in a real argument number\n-            }};\n+                }\n+            };\n \n             let llptr = fcx.llargs.get_copy(&arg.id);\n-            set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+            set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n             unsafe {\n                 let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                        DIB(cx), llptr, mdnode, bcx.llbb);\n+                        DIB(cx), llptr, var_metadata, bcx.llbb);\n                 llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n             }\n-            return Some(mdnode);\n+            return Some(var_metadata);\n         }\n         _ => {\n             return None;\n@@ -247,59 +266,81 @@ pub fn update_source_pos(bcx: block, span: span) {\n     }\n     debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n     let loc = span_start(bcx.ccx(), span);\n-    set_debug_location(bcx.ccx(), create_block(bcx), loc.line, loc.col.to_uint())\n+    set_debug_location(bcx.ccx(), lexical_block_metadata(bcx), loc.line, loc.col.to_uint())\n }\n \n /// Creates debug information for the given function.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n+pub fn create_function_metadata(fcx: fn_ctxt) -> DISubprogram {\n     let cx = fcx.ccx;\n     let fcx = &mut *fcx;\n     let span = fcx.span.get();\n \n     let fnitem = cx.tcx.items.get_copy(&fcx.id);\n     let (ident, ret_ty, id) = match fnitem {\n-      ast_map::node_item(ref item, _) => {\n-        match item.node {\n-          ast::item_fn(ast::fn_decl { output: ref ty, _}, _, _, _, _) => {\n-            (item.ident, ty, item.id)\n-          }\n-          _ => fcx.ccx.sess.span_bug(item.span, \"create_function: item bound to non-function\")\n+        ast_map::node_item(ref item, _) => {\n+            match item.node {\n+                ast::item_fn(ast::fn_decl { output: ref ty, _}, _, _, _, _) => {\n+                    (item.ident, ty, item.id)\n+                }\n+                _ => fcx.ccx.sess.span_bug(item.span,\n+                                           \"create_function_metadata: item bound to non-function\")\n+            }\n         }\n-      }\n-      ast_map::node_method(@ast::method { decl: ast::fn_decl { output: ref ty, _ },\n-                           id: id, ident: ident, _}, _, _) => {\n-          (ident, ty, id)\n-      }\n-      ast_map::node_expr(ref expr) => {\n-        match expr.node {\n-          ast::expr_fn_block(ref decl, _) => {\n-            let name = gensym_name(\"fn\");\n-            (name, &decl.output, expr.id)\n-          }\n-          _ => fcx.ccx.sess.span_bug(expr.span,\n-                  \"create_function: expected an expr_fn_block here\")\n+        ast_map::node_method(\n+            @ast::method {\n+                decl: ast::fn_decl { output: ref ty, _ },\n+                id: id,\n+                ident: ident,\n+                _\n+            },\n+            _,\n+            _) => {\n+            (ident, ty, id)\n         }\n-      }\n-      _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n+        ast_map::node_expr(ref expr) => {\n+            match expr.node {\n+                ast::expr_fn_block(ref decl, _) => {\n+                    let name = gensym_name(\"fn\");\n+                    (name, &decl.output, expr.id)\n+                }\n+                _ => fcx.ccx.sess.span_bug(expr.span,\n+                        \"create_function_metadata: expected an expr_fn_block here\")\n+            }\n+        }\n+        ast_map::node_trait_method(\n+            @ast::provided(\n+                @ast::method {\n+                    decl: ast::fn_decl { output: ref ty, _ },\n+                    id: id,\n+                    ident: ident,\n+                    _\n+                }),\n+            _,\n+            _) => {\n+            (ident, ty, id)\n+        }\n+        _ => fcx.ccx.sess.bug(\"create_function_metadata: unexpected sort of node\")\n     };\n \n     match dbg_cx(cx).created_functions.find(&id) {\n-        Some(fn_md) => return *fn_md,\n+        Some(fn_metadata) => return *fn_metadata,\n         None => ()\n     }\n \n-    debug!(\"create_function: %s, %s\", cx.sess.str_of(ident), cx.sess.codemap.span_to_str(span));\n+    debug!(\"create_function_metadata: %s, %s\",\n+           cx.sess.str_of(ident),\n+           cx.sess.codemap.span_to_str(span));\n \n     let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n+    let return_type_metadata = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n           ast::ty_nil => ptr::null(),\n-          _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n+          _ => type_metadata(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n         }\n     } else {\n         ptr::null()\n@@ -308,33 +349,35 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     let fn_ty = unsafe {\n         llvm::LLVMDIBuilderCreateSubroutineType(\n             DIB(cx),\n-            file_md,\n-            create_DIArray(DIB(cx), [ret_ty_md]))\n+            file_metadata,\n+            create_DIArray(DIB(cx), [return_type_metadata]))\n     };\n \n-    let fn_md =\n+    let fn_metadata =\n         do as_c_str(cx.sess.str_of(ident)) |name| {\n-        do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n-            llvm::LLVMDIBuilderCreateFunction(\n-                DIB(cx),\n-                file_md,\n-                name,\n-                linkage,\n-                file_md,\n-                loc.line as c_uint,\n-                fn_ty,\n-                false,\n-                true,\n-                loc.line as c_uint,\n-                FlagPrototyped as c_uint,\n-                cx.sess.opts.optimize != session::No,\n-                fcx.llfn,\n-                ptr::null(),\n-                ptr::null())\n-            }}};\n+        do as_c_str(cx.sess.str_of(ident)) |linkage| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateFunction(\n+                    DIB(cx),\n+                    file_metadata,\n+                    name,\n+                    linkage,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    fn_ty,\n+                    false,\n+                    true,\n+                    loc.line as c_uint,\n+                    FlagPrototyped as c_uint,\n+                    cx.sess.opts.optimize != session::No,\n+                    fcx.llfn,\n+                    ptr::null(),\n+                    ptr::null())\n+            }\n+        }};\n \n-    dbg_cx(cx).created_functions.insert(id, fn_md);\n-    return fn_md;\n+    dbg_cx(cx).created_functions.insert(id, fn_metadata);\n+    return fn_metadata;\n }\n \n \n@@ -350,11 +393,11 @@ fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     };\n }\n \n-fn create_compile_unit(cx: @mut CrateContext) {\n+fn compile_unit_metadata(cx: @mut CrateContext) {\n     let dcx = dbg_cx(cx);\n     let crate_name: &str = dcx.crate_file;\n \n-    debug!(\"create_compile_unit: %?\", crate_name);\n+    debug!(\"compile_unit_metadata: %?\", crate_name);\n \n     let work_dir = cx.sess.working_dir.to_str();\n     let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n@@ -363,21 +406,23 @@ fn create_compile_unit(cx: @mut CrateContext) {\n     do as_c_str(work_dir) |work_dir| {\n     do as_c_str(producer) |producer| {\n     do as_c_str(\"\") |flags| {\n-    do as_c_str(\"\") |split_name| { unsafe {\n-        llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n-            DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n-            cx.sess.opts.optimize != session::No,\n-            flags, 0, split_name);\n-    }}}}}};\n+    do as_c_str(\"\") |split_name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n+                DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n+                cx.sess.opts.optimize != session::No,\n+                flags, 0, split_name);\n+        }\n+    }}}}};\n }\n \n-fn create_file(cx: &mut CrateContext, full_path: &str) -> DIFile {\n+fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n     match dbg_cx(cx).created_files.find_equiv(&full_path) {\n-        Some(file_md) => return *file_md,\n+        Some(file_metadata) => return *file_metadata,\n         None => ()\n     }\n \n-    debug!(\"create_file: %s\", full_path);\n+    debug!(\"file_metadata: %s\", full_path);\n \n     let work_dir = cx.sess.working_dir.to_str();\n     let file_name =\n@@ -387,68 +432,67 @@ fn create_file(cx: &mut CrateContext, full_path: &str) -> DIFile {\n             full_path\n         };\n \n-    let file_md =\n+    let file_metadata =\n         do as_c_str(file_name) |file_name| {\n-        do as_c_str(work_dir) |work_dir| { unsafe {\n-            llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n-        }}};\n+        do as_c_str(work_dir) |work_dir| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n+            }\n+        }};\n \n-    dbg_cx(cx).created_files.insert(full_path.to_owned(), file_md);\n-    return file_md;\n+    dbg_cx(cx).created_files.insert(full_path.to_owned(), file_metadata);\n+    return file_metadata;\n }\n \n-\n-\n-fn create_block(bcx: block) -> DILexicalBlock {\n-    let mut bcx = bcx;\n+/// Get or create the lexical block metadata node for the given LLVM basic block.\n+fn lexical_block_metadata(bcx: block) -> DILexicalBlock {\n     let cx = bcx.ccx();\n+    let mut bcx = bcx;\n \n+    // Search up the tree of basic blocks until we find one that knows the containing lexical block.\n     while bcx.node_info.is_none() {\n         match bcx.parent {\n-          Some(b) => bcx = b,\n-          None => fail!()\n+            Some(b) => bcx = b,\n+            None => cx.sess.bug(\"debuginfo: Could not find lexical block for LLVM basic block.\")\n         }\n     }\n+\n     let span = bcx.node_info.get().span;\n     let id = bcx.node_info.get().id;\n \n+    // Check whether we already have a cache entry for this node id\n     match dbg_cx(cx).created_blocks.find(&id) {\n         Some(block) => return *block,\n         None => ()\n     }\n \n-    debug!(\"create_block: %s\", bcx.sess().codemap.span_to_str(span));\n+    debug!(\"lexical_block_metadata: %s\", bcx.sess().codemap.span_to_str(span));\n \n     let parent = match bcx.parent {\n-        None => create_function(bcx.fcx),\n-        Some(b) => create_block(b)\n+        None => create_function_metadata(bcx.fcx),\n+        Some(b) => lexical_block_metadata(b)\n     };\n-    let cx = bcx.ccx();\n+\n     let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let block_md = unsafe {\n+    let lexical_block_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateLexicalBlock(\n             DIB(cx),\n-            parent, file_md,\n-            loc.line as c_uint, loc.col.to_uint() as c_uint)\n+            parent,\n+            file_metadata,\n+            loc.line as c_uint,\n+            loc.col.to_uint() as c_uint)\n     };\n \n-    dbg_cx(cx).created_blocks.insert(id, block_md);\n+    dbg_cx(cx).created_blocks.insert(id, lexical_block_metadata);\n \n-    return block_md;\n+    return lexical_block_metadata;\n }\n \n+fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n-\n-fn create_basic_type(cx: &mut CrateContext, t: ty::t, _span: span) -> DIType {\n-    let ty_id = ty::type_id(t);\n-    match dbg_cx(cx).created_types.find(&ty_id) {\n-        Some(ty_md) => return *ty_md,\n-        None => ()\n-    }\n-\n-    debug!(\"create_basic_type: %?\", ty::get(t));\n+    debug!(\"basic_type_metadata: %?\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n@@ -473,424 +517,805 @@ fn create_basic_type(cx: &mut CrateContext, t: ty::t, _span: span) -> DIType {\n             ast::ty_f32 => (~\"f32\", DW_ATE_float),\n             ast::ty_f64 => (~\"f64\", DW_ATE_float)\n         },\n-        _ => cx.sess.bug(\"debuginfo::create_basic_type - t is invalid type\")\n+        _ => cx.sess.bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n \n-    let (size, align) = size_and_align_of(cx, t);\n-    let ty_md = do as_c_str(name) |name| { unsafe {\n+    let llvm_type = type_of::type_of(cx, t);\n+    let (size, align) = size_and_align_of(cx, llvm_type);\n+    let ty_metadata = do as_c_str(name) |name| {\n+        unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n                 name,\n                 bytes_to_bits(size),\n                 bytes_to_bits(align),\n                 encoding as c_uint)\n-        }};\n+        }\n+    };\n \n-    // One could think that this call is not necessary, as the create_ty() function will insert the\n-    // type descriptor into the cache anyway. Mind, however, that create_basic_type() is also called\n-    // directly from other functions (e.g. create_boxed_type()).\n-    dbg_cx(cx).created_types.insert(ty_id, ty_md);\n-    return ty_md;\n+    return ty_metadata;\n }\n \n-fn create_pointer_type(cx: &mut CrateContext, t: ty::t, _span: span, pointee: DIType) -> DIType {\n-    let (size, align) = size_and_align_of(cx, t);\n-    let name = ty_to_str(cx.tcx, t);\n-    let ptr_md = do as_c_str(name) |name| { unsafe {\n-        llvm::LLVMDIBuilderCreatePointerType(\n-            DIB(cx),\n-            pointee,\n-            bytes_to_bits(size),\n-            bytes_to_bits(align),\n-            name)\n-    }};\n-    return ptr_md;\n+fn pointer_type_metadata(cx: &mut CrateContext,\n+                         pointer_type: ty::t,\n+                         pointee_type_metadata: DIType)\n+                      -> DIType {\n+    let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n+    let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n+    let name = ty_to_str(cx.tcx, pointer_type);\n+    let ptr_metadata = do as_c_str(name) |name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreatePointerType(\n+                DIB(cx),\n+                pointee_type_metadata,\n+                bytes_to_bits(pointer_size),\n+                bytes_to_bits(pointer_align),\n+                name)\n+        }\n+    };\n+    return ptr_metadata;\n }\n \n-struct StructContext {\n-    builder: DIBuilderRef,\n-    file: DIFile,\n-    name: ~str,\n-    line: uint,\n-    members: ~[DIDerivedType],\n-    total_size: uint,\n-    align: uint\n-}\n-\n-impl StructContext {\n-    fn new(cx: &CrateContext, name: ~str, file: DIFile, line: uint) -> StructContext {\n-        debug!(\"StructContext::create: %s\", name);\n-        return StructContext {\n-            builder: DIB(cx),\n-            file: file,\n-            name: name,\n-            line: line,\n-            members: ~[],\n-            total_size: 0,\n-            align: 1\n-        };\n+fn struct_metadata(cx: &mut CrateContext,\n+                   struct_type: ty::t,\n+                   fields: ~[ty::field],\n+                   span: span)\n+                -> DICompositeType {\n+    let struct_name = ty_to_str(cx.tcx, struct_type);\n+    debug!(\"struct_metadata: %s\", struct_name);\n+\n+    let struct_llvm_type = type_of::type_of(cx, struct_type);\n+\n+    let field_llvm_types = do fields.map |field| { type_of::type_of(cx, field.mt.ty) };\n+    let field_names = do fields.map |field| { cx.sess.str_of(field.ident).to_owned() };\n+    let field_types_metadata = do fields.map |field| {\n+        type_metadata(cx, field.mt.ty, span)\n+    };\n+\n+    return composite_type_metadata(\n+        cx,\n+        struct_llvm_type,\n+        struct_name,\n+        field_llvm_types,\n+        field_names,\n+        field_types_metadata,\n+        span);\n+}\n+\n+fn tuple_metadata(cx: &mut CrateContext,\n+                  tuple_type: ty::t,\n+                  component_types: &[ty::t],\n+                  span: span)\n+               -> DICompositeType {\n+\n+    let tuple_name = ty_to_str(cx.tcx, tuple_type);\n+    let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n+\n+    let component_names = do component_types.map |_| { ~\"\" };\n+    let component_llvm_types = do component_types.map |it| { type_of::type_of(cx, *it) };\n+    let component_types_metadata = do component_types.map |it| {\n+        type_metadata(cx, *it, span)\n+    };\n+\n+    return composite_type_metadata(\n+        cx,\n+        tuple_llvm_type,\n+        tuple_name,\n+        component_llvm_types,\n+        component_names,\n+        component_types_metadata,\n+        span);\n+}\n+\n+// The stage0 snapshot does not yet support the fixes from PR #7557, so there are two versions of\n+// following function for now\n+#[cfg(not(stage0))]\n+fn enum_metadata(cx: &mut CrateContext,\n+                 enum_type: ty::t,\n+                 enum_def_id: ast::def_id,\n+                 // _substs is only needed in the other version. Will go away with new snapshot.\n+                 _substs: &ty::substs,\n+                 span: span)\n+              -> DIType {\n+\n+    let enum_name = ty_to_str(cx.tcx, enum_type);\n+\n+    // For empty enums there is an early exit. Just describe it as an empty struct with the\n+    // appropriate type name\n+    if ty::type_is_empty(cx.tcx, enum_type) {\n+        return composite_type_metadata(cx, Type::nil(), enum_name, [], [], [], span);\n     }\n \n-    fn add_member(&mut self, name: &str, line: uint, size: uint, align: uint, ty: DIType) {\n-        let offset = roundup(self.total_size, align);\n+    // Prepare some data (llvm type, size, align, ...) about the discriminant. This data will be\n+    // needed in all of the following cases.\n+    let discriminant_llvm_type = Type::enum_discrim(cx);\n+    let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n \n-        debug!(\"StructContext(%s)::add_member: %s, size=%u, align=%u, offset=%u\",\n-                self.name, name, size, align, offset);\n+    assert!(Type::enum_discrim(cx) == cx.int_type);\n+    let discriminant_type_metadata = type_metadata(cx, ty::mk_int(), span);\n \n-        let mem_t = do as_c_str(name) |name| { unsafe {\n-            llvm::LLVMDIBuilderCreateMemberType(\n-                self.builder,\n-                self.file,\n-                name,\n-                self.file,\n-                line as c_uint,\n-                bytes_to_bits(size),\n-                bytes_to_bits(align),\n-                bytes_to_bits(offset),\n-                0,\n-                ty)\n+    let variants: &[@ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n+\n+    let enumerators_metadata: ~[DIDescriptor] = variants\n+        .iter()\n+        .transform(|v| {\n+            let name: &str = cx.sess.str_of(v.name);\n+            let discriminant_value = v.disr_val as c_ulonglong;\n+\n+            do name.as_c_str |name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateEnumerator(\n+                        DIB(cx),\n+                        name,\n+                        discriminant_value)\n+                }\n+            }\n+        })\n+        .collect();\n+\n+    let loc = span_start(cx, span);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n+\n+    let discriminant_type_metadata = do enum_name.as_c_str |enum_name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateEnumerationType(\n+                DIB(cx),\n+                file_metadata,\n+                enum_name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                bytes_to_bits(discriminant_size),\n+                bytes_to_bits(discriminant_align),\n+                create_DIArray(DIB(cx), enumerators_metadata),\n+                discriminant_type_metadata)\n+        }\n+    };\n+\n+    let type_rep = adt::represent_type(cx, enum_type);\n+\n+    match *type_rep {\n+        adt::CEnum(*) => {\n+            return discriminant_type_metadata;\n+        }\n+        adt::Univariant(ref struct_def, _) => {\n+            assert!(variants.len() == 1);\n+            return adt_struct_metadata(cx, struct_def, variants[0], None, span);\n+        }\n+        adt::General(ref struct_defs) => {\n+            let variants_member_metadata: ~[DIDescriptor] = do struct_defs\n+                .iter()\n+                .enumerate()\n+                .transform |(i, struct_def)| {\n+                    let variant_type_metadata = adt_struct_metadata(\n+                        cx,\n+                        struct_def,\n+                        variants[i],\n+                        Some(discriminant_type_metadata),\n+                        span);\n+\n+                    do \"\".as_c_str |name| {\n+                        unsafe {\n+                            llvm::LLVMDIBuilderCreateMemberType(\n+                                DIB(cx),\n+                                file_metadata,\n+                                name,\n+                                file_metadata,\n+                                loc.line as c_uint,\n+                                bytes_to_bits(struct_def.size as uint),\n+                                bytes_to_bits(struct_def.align as uint),\n+                                bytes_to_bits(0),\n+                                0,\n+                                variant_type_metadata)\n+                        }\n+                    }\n+            }.collect();\n+\n+            let enum_llvm_type = type_of::type_of(cx, enum_type);\n+            let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n+\n+            return do enum_name.as_c_str |enum_name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateUnionType(\n+                    DIB(cx),\n+                    file_metadata,\n+                    enum_name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    bytes_to_bits(enum_type_size),\n+                    bytes_to_bits(enum_type_align),\n+                    0, // Flags\n+                    create_DIArray(DIB(cx), variants_member_metadata),\n+                    0) // RuntimeLang\n             }};\n-        self.members.push(mem_t);\n-        self.total_size = offset + size;\n-        // struct alignment is the max alignment of its' members\n-        self.align = cmp::max(self.align, align);\n+        }\n+        adt::NullablePointer { nonnull: ref struct_def, nndiscr, _ } => {\n+            return adt_struct_metadata(cx, struct_def, variants[nndiscr], None, span);\n+        }\n     }\n \n-    fn get_total_size_with_alignment(&self) -> uint {\n-        roundup(self.total_size, self.align)\n-    }\n+    fn adt_struct_metadata(cx: &mut CrateContext,\n+                                  struct_def: &adt::Struct,\n+                                  variant_info: &ty::VariantInfo,\n+                                  discriminant_type_metadata: Option<DIType>,\n+                                  span: span)\n+                               -> DICompositeType\n+    {\n+        let arg_llvm_types: ~[Type] = do struct_def.fields.map |&ty| { type_of::type_of(cx, ty) };\n+        let arg_metadata: ~[DIType] = do struct_def.fields.iter().enumerate()\n+            .transform |(i, &ty)| {\n+                match discriminant_type_metadata {\n+                    Some(metadata) if i == 0 => metadata,\n+                    _                        => type_metadata(cx, ty, span)\n+                }\n+        }.collect();\n \n-    fn finalize(&self) -> DICompositeType {\n-        debug!(\"StructContext(%s)::finalize: total_size=%u, align=%u\",\n-                self.name, self.total_size, self.align);\n-        let members_md = create_DIArray(self.builder, self.members);\n-\n-        // The size of the struct/tuple must be rounded to the next multiple of its alignment.\n-        // Otherwise gdb has trouble reading the struct correctly when it is embedded into another\n-        // data structure. This is also the value `sizeof` in C would give.\n-        let actual_total_size = self.get_total_size_with_alignment();\n-\n-        let struct_md =\n-            do as_c_str(self.name) |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateStructType(\n-                    self.builder,\n-                    self.file,\n-                    name,\n-                    self.file,\n-                    self.line as c_uint,\n-                    bytes_to_bits(actual_total_size),\n-                    bytes_to_bits(self.align),\n-                    0,\n-                    ptr::null(),\n-                    members_md,\n-                    0,\n-                    ptr::null())\n-            }};\n-        return struct_md;\n+        let mut arg_names = match variant_info.arg_names {\n+            Some(ref names) => do names.map |ident| { cx.sess.str_of(*ident).to_owned() },\n+            None => do variant_info.args.map |_| { ~\"\" }\n+        };\n+\n+        if discriminant_type_metadata.is_some() {\n+            arg_names.insert(0, ~\"\");\n+        }\n+\n+        let variant_llvm_type = Type::struct_(arg_llvm_types, struct_def.packed);\n+        let variant_name: &str = cx.sess.str_of(variant_info.name);\n+\n+        return composite_type_metadata(\n+            cx,\n+            variant_llvm_type,\n+            variant_name,\n+            arg_llvm_types,\n+            arg_names,\n+            arg_metadata,\n+            span);\n     }\n }\n \n-fn create_struct(cx: &mut CrateContext, struct_type: ty::t, fields: ~[ty::field], span: span)\n-                -> DICompositeType {\n-    debug!(\"create_struct: %?\", ty::get(struct_type));\n+#[cfg(stage0)]\n+fn enum_metadata(cx: &mut CrateContext,\n+                 enum_type: ty::t,\n+                 enum_def_id: ast::def_id,\n+                 substs: &ty::substs,\n+                 span: span)\n+              -> DIType {\n+\n+    let enum_name = ty_to_str(cx.tcx, enum_type);\n+\n+    // For empty enums there is an early exit. Just describe it as an empty struct with the\n+    // appropriate type name\n+    if ty::type_is_empty(cx.tcx, enum_type) {\n+        return composite_type_metadata(cx, Type::nil(), enum_name, &[], &[], &[], span);\n+    }\n+\n+    // Prepare some data (llvm type, size, align, ...) about the discriminant. This data will be\n+    // needed in all of the following cases.\n+    let discriminant_llvm_type = Type::enum_discrim(cx);\n+    let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n+\n+    assert!(Type::enum_discrim(cx) == cx.int_type);\n+    let discriminant_type_metadata = type_metadata(cx, ty::mk_int(), span);\n+\n+    let variants: &[@ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n+\n+    let enumerators_metadata: ~[DIDescriptor] = variants\n+        .iter()\n+        .transform(|v| {\n+            let name: &str = cx.sess.str_of(v.name);\n+            let discriminant_value = v.disr_val as c_ulonglong;\n+\n+            do name.as_c_str |name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateEnumerator(\n+                        DIB(cx),\n+                        name,\n+                        discriminant_value)\n+                }\n+            }\n+        })\n+        .collect();\n \n     let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n-\n-    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, struct_type), file_md, loc.line);\n-    for fields.iter().advance |field| {\n-        let field_t = field.mt.ty;\n-        let ty_md = create_ty(cx, field_t, span);\n-        let (size, align) = size_and_align_of(cx, field_t);\n-        scx.add_member(cx.sess.str_of(field.ident), loc.line, size, align, ty_md);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n+\n+    let discriminant_type_metadata = do enum_name.as_c_str |enum_name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateEnumerationType(\n+                DIB(cx),\n+                file_metadata,\n+                enum_name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                bytes_to_bits(discriminant_size),\n+                bytes_to_bits(discriminant_align),\n+                create_DIArray(DIB(cx), enumerators_metadata),\n+                discriminant_type_metadata)\n+        }\n+    };\n+\n+    if ty::type_is_c_like_enum(cx.tcx, enum_type) {\n+        return discriminant_type_metadata;\n     }\n-    return scx.finalize();\n-}\n \n-// returns (void* type as a ValueRef, size in bytes, align in bytes)\n-fn voidptr(cx: &mut CrateContext) -> (DIDerivedType, uint, uint) {\n-    let size = sys::size_of::<ValueRef>();\n-    let align = sys::min_align_of::<ValueRef>();\n-    let vp = do as_c_str(\"*void\") |name| { unsafe {\n-            llvm::LLVMDIBuilderCreatePointerType(\n+    let is_univariant = variants.len() == 1;\n+\n+    let variants_metadata = do variants.map |&vi| {\n+\n+        let raw_types: &[ty::t] = vi.args;\n+        let arg_types = do raw_types.map |&raw_type| { ty::subst(cx.tcx, substs, raw_type) };\n+\n+        let mut arg_llvm_types = do arg_types.map |&ty| { type_of::type_of(cx, ty) };\n+        let mut arg_names = match vi.arg_names {\n+            Some(ref names) => do names.map |ident| { cx.sess.str_of(*ident).to_owned() },\n+            None => do arg_types.map |_| { ~\"\" }\n+        };\n+\n+        let mut arg_metadata = do arg_types.map |&ty| { type_metadata(cx, ty, span) };\n+\n+        if !is_univariant {\n+            arg_llvm_types.insert(0, discriminant_llvm_type);\n+            arg_names.insert(0, ~\"\");\n+            arg_metadata.insert(0, discriminant_type_metadata);\n+        }\n+\n+        let variant_llvm_type = Type::struct_(arg_llvm_types, false);\n+        let (variant_type_size, variant_type_align) = size_and_align_of(cx, variant_llvm_type);\n+\n+        let variant_type_metadata = composite_type_metadata(\n+            cx,\n+            variant_llvm_type,\n+            &\"\",\n+            arg_llvm_types,\n+            arg_names,\n+            arg_metadata,\n+            span);\n+\n+        do \"\".as_c_str |name| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    file_metadata,\n+                    name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    bytes_to_bits(variant_type_size),\n+                    bytes_to_bits(variant_type_align),\n+                    bytes_to_bits(0),\n+                    0,\n+                    variant_type_metadata)\n+            }\n+        }\n+    };\n+\n+    let enum_llvm_type = type_of::type_of(cx, enum_type);\n+    let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n+\n+    return do enum_name.as_c_str |enum_name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateUnionType(\n                 DIB(cx),\n-                ptr::null(),\n-                bytes_to_bits(size),\n-                bytes_to_bits(align),\n-                name)\n-        }};\n-    return (vp, size, align);\n+                file_metadata,\n+                enum_name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                bytes_to_bits(enum_type_size),\n+                bytes_to_bits(enum_type_align),\n+                0, // Flags\n+                create_DIArray(DIB(cx), variants_metadata),\n+                0) // RuntimeLang\n+        }\n+    };\n }\n \n-fn create_tuple(cx: &mut CrateContext, tuple_type: ty::t, elements: &[ty::t], span: span)\n-                -> DICompositeType {\n-    debug!(\"create_tuple: %?\", ty::get(tuple_type));\n+\n+/// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n+///\n+/// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n+fn composite_type_metadata(cx: &mut CrateContext,\n+                           composite_llvm_type: Type,\n+                           composite_type_name: &str,\n+                           member_llvm_types: &[Type],\n+                           member_names: &[~str],\n+                           member_type_metadata: &[DIType],\n+                           span: span)\n+                        -> DICompositeType {\n \n     let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n-\n-    let name = fmt!(\"tuple_%u\", token::gensym(\"tuple\"));\n-    let mut scx = StructContext::new(cx, name, file_md, loc.line);\n-    for elements.iter().advance |element| {\n-        let ty_md = create_ty(cx, *element, span);\n-        let (size, align) = size_and_align_of(cx, *element);\n-        scx.add_member(\"\", loc.line, size, align, ty_md);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n+\n+    let (composite_size, composite_align) = size_and_align_of(cx, composite_llvm_type);\n+\n+    let member_metadata: ~[DIDescriptor] = member_llvm_types\n+        .iter()\n+        .enumerate()\n+        .transform(|(i, &member_llvm_type)| {\n+            let (member_size, member_align) = size_and_align_of(cx, member_llvm_type);\n+            let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n+            let member_name: &str = member_names[i];\n+\n+            do member_name.as_c_str |member_name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateMemberType(\n+                        DIB(cx),\n+                        file_metadata,\n+                        member_name,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        bytes_to_bits(member_size),\n+                        bytes_to_bits(member_align),\n+                        bytes_to_bits(member_offset),\n+                        0,\n+                        member_type_metadata[i])\n+                }\n+            }\n+        })\n+        .collect();\n+\n+    return do composite_type_name.as_c_str |name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateStructType(\n+                DIB(cx),\n+                file_metadata,\n+                name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                bytes_to_bits(composite_size),\n+                bytes_to_bits(composite_align),\n+                0,\n+                ptr::null(),\n+                create_DIArray(DIB(cx), member_metadata),\n+                0,\n+                ptr::null())\n     }\n-    return scx.finalize();\n+    };\n }\n \n-fn create_boxed_type(cx: &mut CrateContext, contents: ty::t,\n-                     span: span, boxed: DIType) -> DICompositeType {\n-    debug!(\"create_boxed_type: %?\", ty::get(contents));\n+fn boxed_type_metadata(cx: &mut CrateContext,\n+                       content_type_name: Option<&str>,\n+                       content_llvm_type: Type,\n+                       content_type_metadata: DIType,\n+                       span: span)\n+                    -> DICompositeType {\n \n-    let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n-    let int_t = ty::mk_int();\n-    let refcount_type = create_basic_type(cx, int_t, span);\n-    let name = ty_to_str(cx.tcx, contents);\n-\n-    let mut scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n-    scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n-               sys::min_align_of::<uint>(), refcount_type);\n-    // the tydesc and other pointers should be irrelevant to the\n-    // debugger, so treat them as void* types\n-    let (vp, vpsize, vpalign) = voidptr(cx);\n-    scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n-    scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n-    scx.add_member(\"next\", 0, vpsize, vpalign, vp);\n-    let (size, align) = size_and_align_of(cx, contents);\n-    scx.add_member(\"boxed\", 0, size, align, boxed);\n-    return scx.finalize();\n-}\n-\n-fn create_fixed_vec(cx: &mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n-                    len: uint, span: span) -> DIType {\n-    debug!(\"create_fixed_vec: %?\", ty::get(_vec_t));\n-\n-    let elem_ty_md = create_ty(cx, elem_t, span);\n-    let (size, align) = size_and_align_of(cx, elem_t);\n+    let box_type_name = match content_type_name {\n+        Some(content_type_name) => fmt!(\"Boxed<%s>\", content_type_name),\n+        None                    => ~\"BoxedType\"\n+    };\n+\n+    let box_llvm_type = Type::box(cx, &content_llvm_type);\n+    let member_llvm_types = box_llvm_type.field_types();\n+    let member_names = [~\"refcnt\", ~\"tydesc\", ~\"prev\", ~\"next\", ~\"val\"];\n+\n+    assert!(box_layout_is_correct(cx, member_llvm_types, content_llvm_type));\n+\n+    let int_type = ty::mk_int();\n+    let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n+\n+    let member_types_metadata = [\n+        type_metadata(cx, int_type, span),\n+        type_metadata(cx, nil_pointer_type, span),\n+        type_metadata(cx, nil_pointer_type, span),\n+        type_metadata(cx, nil_pointer_type, span),\n+        content_type_metadata\n+    ];\n+\n+    return composite_type_metadata(\n+        cx,\n+        box_llvm_type,\n+        box_type_name,\n+        member_llvm_types,\n+        member_names,\n+        member_types_metadata,\n+        span);\n+\n+    // Unfortunately, we cannot assert anything but the correct types here---and not whether the\n+    // 'next' and 'prev' pointers are in the correct order.\n+    fn box_layout_is_correct(cx: &CrateContext,\n+                             member_llvm_types: &[Type],\n+                             content_llvm_type: Type)\n+                          -> bool {\n+        member_llvm_types.len() == 5 &&\n+        member_llvm_types[0] == cx.int_type &&\n+        member_llvm_types[1] == cx.tydesc_type.ptr_to() &&\n+        member_llvm_types[2] == Type::i8().ptr_to() &&\n+        member_llvm_types[3] == Type::i8().ptr_to() &&\n+        member_llvm_types[4] == content_llvm_type\n+    }\n+}\n+\n+fn fixed_vec_metadata(cx: &mut CrateContext,\n+                      element_type: ty::t,\n+                      len: uint,\n+                      span: span)\n+                   -> DIType {\n+    let element_type_metadata = type_metadata(cx, element_type, span);\n+    let element_llvm_type = type_of::type_of(cx, element_type);\n+    let (element_type_size, element_type_align) = size_and_align_of(cx, element_llvm_type);\n \n     let subrange = unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0_i64, len as i64)\n+        llvm::LLVMDIBuilderGetOrCreateSubrange(\n+        DIB(cx),\n+        0,\n+        len as c_longlong)\n     };\n \n     let subscripts = create_DIArray(DIB(cx), [subrange]);\n     return unsafe {\n         llvm::LLVMDIBuilderCreateArrayType(\n             DIB(cx),\n-            bytes_to_bits(size * len),\n-            bytes_to_bits(align),\n-            elem_ty_md,\n+            bytes_to_bits(element_type_size * len),\n+            bytes_to_bits(element_type_align),\n+            element_type_metadata,\n             subscripts)\n     };\n }\n \n-fn create_boxed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n-                    vec_ty_span: span) -> DICompositeType {\n-    debug!(\"create_boxed_vec: %?\", ty::get(vec_t));\n-\n-    let loc = span_start(cx, vec_ty_span);\n-    let file_md = create_file(cx, loc.file.name);\n-    let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n+fn vec_metadata(cx: &mut CrateContext,\n+                element_type: ty::t,\n+                span: span)\n+             -> DICompositeType {\n \n-    let mut vec_scx = StructContext::new(cx, ty_to_str(cx.tcx, vec_t), file_md, 0);\n-    let size_t_type = create_basic_type(cx, ty::mk_uint(), vec_ty_span);\n+    let element_type_metadata = type_metadata(cx, element_type, span);\n+    let element_llvm_type = type_of::type_of(cx, element_type);\n+    let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n-    vec_scx.add_member(\n-        \"fill\",\n-        0,\n-        sys::size_of::<libc::size_t>(),\n-        sys::min_align_of::<libc::size_t>(),\n-        size_t_type);\n-\n-    vec_scx.add_member(\n-        \"alloc\",\n-        0,\n-        sys::size_of::<libc::size_t>(),\n-        sys::min_align_of::<libc::size_t>(),\n-        size_t_type);\n+    let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n+    let vec_type_name: &str = fmt!(\"[%s]\", ty_to_str(cx.tcx, element_type));\n \n-    let subrange = unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0_i64, 0_i64)\n-    };\n-    let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n-    let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n+    let member_llvm_types = vec_llvm_type.field_types();\n+    let member_names = &[~\"fill\", ~\"alloc\", ~\"elements\"];\n \n-    let subscripts = create_DIArray(DIB(cx), [subrange]);\n-    let data_ptr = unsafe {\n+    let int_type_metadata = type_metadata(cx, ty::mk_int(), span);\n+    let array_type_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateArrayType(\n             DIB(cx),\n-            bytes_to_bits(arr_size),\n-            bytes_to_bits(arr_align),\n-            elem_ty_md,\n-            subscripts)\n+            bytes_to_bits(element_size),\n+            bytes_to_bits(element_align),\n+            element_type_metadata,\n+            create_DIArray(DIB(cx), [llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, 0)]))\n     };\n-    vec_scx.add_member(\n-        \"data\",\n-        0,\n-        0, // clang says the size should be 0\n-        sys::min_align_of::<u8>(), data_ptr);\n \n-    let vec_md = vec_scx.finalize();\n+    //                           fill               alloc              elements\n+    let member_type_metadata = &[int_type_metadata, int_type_metadata, array_type_metadata];\n+\n+    return composite_type_metadata(\n+        cx,\n+        vec_llvm_type,\n+        vec_type_name,\n+        member_llvm_types,\n+        member_names,\n+        member_type_metadata,\n+        span);\n+}\n \n-    let mut box_scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n-    let int_t = ty::mk_int();\n-    let refcount_type = create_basic_type(cx, int_t, vec_ty_span);\n+fn boxed_vec_metadata(cx: &mut CrateContext,\n+                      element_type: ty::t,\n+                      span: span)\n+                   -> DICompositeType {\n+\n+    let element_llvm_type = type_of::type_of(cx, element_type);\n+    let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n+    let vec_type_name: &str = fmt!(\"[%s]\", ty_to_str(cx.tcx, element_type));\n+    let vec_metadata = vec_metadata(cx, element_type, span);\n+\n+    return boxed_type_metadata(\n+        cx,\n+        Some(vec_type_name),\n+        vec_llvm_type,\n+        vec_metadata,\n+        span);\n+}\n \n-    box_scx.add_member(\n-        \"refcnt\",\n-        0,\n-        sys::size_of::<uint>(),\n-        sys::min_align_of::<uint>(),\n-        refcount_type);\n-\n-    let (vp, vpsize, vpalign) = voidptr(cx);\n-    box_scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n-    box_scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n-    box_scx.add_member(\"next\", 0, vpsize, vpalign, vp);\n-    let size = 2 * sys::size_of::<int>();\n-    let align = sys::min_align_of::<int>();\n-    box_scx.add_member(\"boxed\", 0, size, align, vec_md);\n-    let mdval = box_scx.finalize();\n-    return mdval;\n-}\n-\n-fn create_vec_slice(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n-                    -> DICompositeType {\n-    debug!(\"create_vec_slice: %?\", ty::get(vec_t));\n+fn vec_slice_metadata(cx: &mut CrateContext,\n+                      vec_type: ty::t,\n+                      element_type: ty::t,\n+                      span: span)\n+                   -> DICompositeType {\n \n-    let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n-    let elem_ty_md = create_ty(cx, elem_t, span);\n-    let uint_type = create_basic_type(cx, ty::mk_uint(), span);\n-    let elem_ptr = create_pointer_type(cx, elem_t, span, elem_ty_md);\n+    debug!(\"vec_slice_metadata: %?\", ty::get(vec_type));\n+\n+    let slice_llvm_type = type_of::type_of(cx, vec_type);\n+    let slice_type_name = ty_to_str(cx.tcx, vec_type);\n+\n+    let member_llvm_types = slice_llvm_type.field_types();\n+    let member_names = &[~\"data_ptr\", ~\"size_in_bytes\"];\n \n-    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, vec_t), file_md, 0);\n-    let (_, ptr_size, ptr_align) = voidptr(cx);\n-    scx.add_member(\"vec\", 0, ptr_size, ptr_align, elem_ptr);\n-    scx.add_member(\"length\", 0, sys::size_of::<uint>(), sys::min_align_of::<uint>(), uint_type);\n-    return scx.finalize();\n+    assert!(slice_layout_is_correct(cx, member_llvm_types, element_type));\n+\n+    let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::m_imm });\n+\n+    let member_type_metadata = &[type_metadata(cx, data_ptr_type, span),\n+                                 type_metadata(cx, ty::mk_uint(), span)];\n+\n+    return composite_type_metadata(\n+        cx,\n+        slice_llvm_type,\n+        slice_type_name,\n+        member_llvm_types,\n+        member_names,\n+        member_type_metadata,\n+        span);\n+\n+    fn slice_layout_is_correct(cx: &mut CrateContext,\n+                               member_llvm_types: &[Type],\n+                               element_type: ty::t)\n+                            -> bool {\n+        member_llvm_types.len() == 2 &&\n+        member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n+        member_llvm_types[1] == cx.int_type\n+    }\n }\n \n-fn create_fn_ty(cx: &mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n-                span: span) -> DICompositeType {\n-    debug!(\"create_fn_ty: %?\", ty::get(_fn_ty));\n+fn bare_fn_metadata(cx: &mut CrateContext,\n+                    _fn_ty: ty::t,\n+                    inputs: ~[ty::t],\n+                    output: ty::t,\n+                    span: span)\n+                 -> DICompositeType {\n+\n+    debug!(\"bare_fn_metadata: %?\", ty::get(_fn_ty));\n \n     let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n-    let (vp, _, _) = voidptr(cx);\n-    let output_md = create_ty(cx, output, span);\n-    let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n-    let inputs_vals = do inputs.map |arg| { create_ty(cx, *arg, span) };\n-    let members = ~[output_ptr_md, vp] + inputs_vals;\n+    let file_metadata = file_metadata(cx, loc.file.name);\n+\n+    let nil_pointer_type_metadata = type_metadata(cx, ty::mk_nil_ptr(cx.tcx), span);\n+    let output_metadata = type_metadata(cx, output, span);\n+    let output_ptr_metadata = pointer_type_metadata(cx, output, output_metadata);\n+\n+    let inputs_vals = do inputs.map |arg| { type_metadata(cx, *arg, span) };\n+    let members = ~[output_ptr_metadata, nil_pointer_type_metadata] + inputs_vals;\n \n     return unsafe {\n         llvm::LLVMDIBuilderCreateSubroutineType(\n             DIB(cx),\n-            file_md,\n+            file_metadata,\n             create_DIArray(DIB(cx), members))\n     };\n }\n \n-fn create_unimpl_ty(cx: &mut CrateContext, t: ty::t) -> DIType {\n-    debug!(\"create_unimpl_ty: %?\", ty::get(t));\n+fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n+    debug!(\"unimplemented_type_metadata: %?\", ty::get(t));\n \n     let name = ty_to_str(cx.tcx, t);\n-    let md = do as_c_str(fmt!(\"NYI<%s>\", name)) |name| { unsafe {\n-        llvm::LLVMDIBuilderCreateBasicType(\n-            DIB(cx),\n-            name,\n-            0_u64,\n-            8_u64,\n-            DW_ATE_unsigned as c_uint)\n-        }};\n-    return md;\n+    let metadata = do as_c_str(fmt!(\"NYI<%s>\", name)) |name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateBasicType(\n+                DIB(cx),\n+                name,\n+                0_u64,\n+                8_u64,\n+                DW_ATE_unsigned as c_uint)\n+            }\n+        };\n+\n+    return metadata;\n }\n \n-fn create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n-    let ty_id = ty::type_id(t);\n-    match dbg_cx(cx).created_types.find(&ty_id) {\n-        Some(ty_md) => return *ty_md,\n+fn type_metadata(cx: &mut CrateContext,\n+                 t: ty::t,\n+                 span: span)\n+              -> DIType {\n+    let type_id = ty::type_id(t);\n+    match dbg_cx(cx).created_types.find(&type_id) {\n+        Some(type_metadata) => return *type_metadata,\n         None => ()\n     }\n \n-    debug!(\"create_ty: %?\", ty::get(t));\n+    fn create_pointer_to_box_metadata(cx: &mut CrateContext,\n+                                      pointer_type: ty::t,\n+                                      type_in_box: ty::t)\n+                                   -> DIType {\n+\n+        let content_type_name: &str = ty_to_str(cx.tcx, type_in_box);\n+        let content_llvm_type = type_of::type_of(cx, type_in_box);\n+        let content_type_metadata = type_metadata(\n+            cx,\n+            type_in_box,\n+            codemap::dummy_sp());\n+\n+        let box_metadata = boxed_type_metadata(\n+            cx,\n+            Some(content_type_name),\n+            content_llvm_type,\n+            content_type_metadata,\n+            codemap::dummy_sp());\n+\n+        pointer_type_metadata(cx, pointer_type, box_metadata)\n+    }\n+\n+    debug!(\"type_metadata: %?\", ty::get(t));\n \n     let sty = &ty::get(t).sty;\n-    let ty_md = match *sty {\n-        ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_)\n-        | ty::ty_float(_) => create_basic_type(cx, t, span),\n+    let type_metadata = match *sty {\n+        ty::ty_nil      |\n+        ty::ty_bot      |\n+        ty::ty_bool     |\n+        ty::ty_int(_)   |\n+        ty::ty_uint(_)  |\n+        ty::ty_float(_) => {\n+            basic_type_metadata(cx, t)\n+        },\n         ty::ty_estr(ref vstore) => {\n             let i8_t = ty::mk_i8();\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec(cx, t, i8_t, len + 1, span)\n+                    fixed_vec_metadata(cx, i8_t, len + 1, span)\n                 },\n-                ty::vstore_uniq | ty::vstore_box => {\n-                    let box_md = create_boxed_vec(cx, t, i8_t, span);\n-                    create_pointer_type(cx, t, span, box_md)\n+                ty::vstore_uniq  => {\n+                    let vec_metadata = vec_metadata(cx, i8_t, span);\n+                    pointer_type_metadata(cx, t, vec_metadata)\n+                }\n+                ty::vstore_box => {\n+                    let boxed_vec_metadata = boxed_vec_metadata(cx, i8_t, span);\n+                    pointer_type_metadata(cx, t, boxed_vec_metadata)\n                 }\n                 ty::vstore_slice(_region) => {\n-                    create_vec_slice(cx, t, i8_t, span)\n+                    vec_slice_metadata(cx, t, i8_t, span)\n                 }\n             }\n         },\n-        ty::ty_enum(_did, ref _substs) => {\n-            cx.sess.span_note(span, \"debuginfo for enum NYI\");\n-            create_unimpl_ty(cx, t)\n-        }\n-        ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => {\n-            let boxed = create_ty(cx, mt.ty, span);\n-            let box_md = create_boxed_type(cx, mt.ty, span, boxed);\n-            create_pointer_type(cx, t, span, box_md)\n+        ty::ty_enum(def_id, ref substs) => {\n+            enum_metadata(cx, t, def_id, substs, span)\n+        },\n+        ty::ty_box(ref mt) => {\n+            create_pointer_to_box_metadata(cx, t, mt.ty)\n         },\n         ty::ty_evec(ref mt, ref vstore) => {\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec(cx, t, mt.ty, len, span)\n-                },\n-                ty::vstore_uniq | ty::vstore_box => {\n-                    let box_md = create_boxed_vec(cx, t, mt.ty, span);\n-                    create_pointer_type(cx, t, span, box_md)\n-                },\n-                ty::vstore_slice(_region) => {\n-                    create_vec_slice(cx, t, mt.ty, span)\n+                    fixed_vec_metadata(cx, mt.ty, len, span)\n+                }\n+                ty::vstore_uniq if ty::type_contents(cx.tcx, mt.ty).contains_managed() => {\n+                    let boxed_vec_metadata = boxed_vec_metadata(cx, mt.ty, span);\n+                    pointer_type_metadata(cx, t, boxed_vec_metadata)\n+                }\n+                ty::vstore_uniq => {\n+                    let vec_metadata = vec_metadata(cx, mt.ty, span);\n+                    pointer_type_metadata(cx, t, vec_metadata)\n+                }\n+                ty::vstore_box => {\n+                    let boxed_vec_metadata = boxed_vec_metadata(cx, mt.ty, span);\n+                    pointer_type_metadata(cx, t, boxed_vec_metadata)\n+                }\n+                ty::vstore_slice(_) => {\n+                    vec_slice_metadata(cx, t, mt.ty, span)\n                 }\n             }\n         },\n-        ty::ty_ptr(ref mt) => {\n-            let pointee = create_ty(cx, mt.ty, span);\n-            create_pointer_type(cx, t, span, pointee)\n+        ty::ty_uniq(ref mt) if ty::type_contents(cx.tcx, mt.ty).contains_managed() => {\n+            create_pointer_to_box_metadata(cx, t, mt.ty)\n         },\n+        ty::ty_uniq(ref mt)    |\n+        ty::ty_ptr(ref mt)     |\n         ty::ty_rptr(_, ref mt) => {\n-            let pointee = create_ty(cx, mt.ty, span);\n-            create_pointer_type(cx, t, span, pointee)\n+            let pointee = type_metadata(cx, mt.ty, span);\n+            pointer_type_metadata(cx, t, pointee)\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n             let inputs = barefnty.sig.inputs.map(|a| *a);\n             let output = barefnty.sig.output;\n-            create_fn_ty(cx, t, inputs, output, span)\n+            bare_fn_metadata(cx, t, inputs, output, span)\n         },\n         ty::ty_closure(ref _closurety) => {\n             cx.sess.span_note(span, \"debuginfo for closure NYI\");\n-            create_unimpl_ty(cx, t)\n+            unimplemented_type_metadata(cx, t)\n         },\n         ty::ty_trait(_did, ref _substs, ref _vstore, _, _bounds) => {\n             cx.sess.span_note(span, \"debuginfo for trait NYI\");\n-            create_unimpl_ty(cx, t)\n+            unimplemented_type_metadata(cx, t)\n         },\n         ty::ty_struct(did, ref substs) => {\n             let fields = ty::struct_fields(cx.tcx, did, substs);\n-            create_struct(cx, t, fields, span)\n+            struct_metadata(cx, t, fields, span)\n         },\n         ty::ty_tup(ref elements) => {\n-            create_tuple(cx, t, *elements, span)\n+            tuple_metadata(cx, t, *elements, span)\n         },\n-        _ => cx.sess.bug(\"debuginfo: unexpected type in create_ty\")\n+        _ => cx.sess.bug(\"debuginfo: unexpected type in type_metadata\")\n     };\n \n-    dbg_cx(cx).created_types.insert(ty_id, ty_md);\n-    return ty_md;\n+    dbg_cx(cx).created_types.insert(type_id, type_metadata);\n+    return type_metadata;\n }\n \n fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: uint) {\n@@ -926,9 +1351,8 @@ fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n     cx.sess.codemap.lookup_char_pos(span.lo)\n }\n \n-fn size_and_align_of(cx: &mut CrateContext, t: ty::t) -> (uint, uint) {\n-    let llty = type_of::type_of(cx, t);\n-    (machine::llsize_of_real(cx, llty), machine::llalign_of_min(cx, llty))\n+fn size_and_align_of(cx: &mut CrateContext, llvm_type: Type) -> (uint, uint) {\n+    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type))\n }\n \n fn bytes_to_bits(bytes: uint) -> c_ulonglong {"}, {"sha": "0bf0a522a655f3c39b81392466e14292848aa4f6", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -113,3 +113,9 @@ pub fn llalign_of(cx: &CrateContext, ty: Type) -> ValueRef {\n             llvm::LLVMAlignOf(ty.to_ref()), cx.int_type.to_ref(), False);\n     }\n }\n+\n+pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: uint) -> uint {\n+    unsafe {\n+        return llvm::LLVMOffsetOfElement(cx.td.lltd, struct_ty.to_ref(), element as u32) as uint;\n+    }\n+}"}, {"sha": "94d872aa132cbf2b0ca94bbd1c1aacc5b465236d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 83, "deletions": 58, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -49,6 +49,8 @@ use syntax::opt_vec;\n use syntax::abi::AbiSet;\n use syntax;\n \n+pub static INITIAL_DISCRIMINANT_VALUE: int = 0;\n+\n // Data types\n \n #[deriving(Eq, IterBytes)]\n@@ -275,7 +277,7 @@ struct ctxt_ {\n     needs_unwind_cleanup_cache: @mut HashMap<t, bool>,\n     tc_cache: @mut HashMap<uint, TypeContents>,\n     ast_ty_to_ty_cache: @mut HashMap<node_id, ast_ty_to_ty_cache_entry>,\n-    enum_var_cache: @mut HashMap<def_id, @~[VariantInfo]>,\n+    enum_var_cache: @mut HashMap<def_id, @~[@VariantInfo]>,\n     ty_param_defs: @mut HashMap<ast::node_id, TypeParameterDef>,\n     adjustments: @mut HashMap<ast::node_id, @AutoAdjustment>,\n     normalized_cache: @mut HashMap<t, t>,\n@@ -3681,28 +3683,81 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n \n // Enum information\n #[deriving(Clone)]\n-pub struct VariantInfo_ {\n+pub struct VariantInfo {\n     args: ~[t],\n+    arg_names: Option<~[ast::ident]>,\n     ctor_ty: t,\n     name: ast::ident,\n     id: ast::def_id,\n     disr_val: int,\n     vis: visibility\n }\n \n-pub type VariantInfo = @VariantInfo_;\n+impl VariantInfo {\n+\n+    /// Creates a new VariantInfo from the corresponding ast representation.\n+    ///\n+    /// Does not do any caching of the value in the type context.\n+    pub fn from_ast_variant(cx: ctxt,\n+                            ast_variant: &ast::variant,\n+                            discriminant: int) -> VariantInfo {\n+\n+        let ctor_ty = node_id_to_type(cx, ast_variant.node.id);\n+\n+        match ast_variant.node.kind {\n+            ast::tuple_variant_kind(ref args) => {\n+                let arg_tys = if args.len() > 0 { ty_fn_args(ctor_ty).map(|a| *a) } else { ~[] };\n+\n+                return VariantInfo {\n+                    args: arg_tys,\n+                    arg_names: None,\n+                    ctor_ty: ctor_ty,\n+                    name: ast_variant.node.name,\n+                    id: ast_util::local_def(ast_variant.node.id),\n+                    disr_val: discriminant,\n+                    vis: ast_variant.node.vis\n+                };\n+            },\n+            ast::struct_variant_kind(ref struct_def) => {\n+\n+                let fields: &[@struct_field] = struct_def.fields;\n+\n+                assert!(fields.len() > 0);\n+\n+                let arg_tys = ty_fn_args(ctor_ty).map(|a| *a);\n+                let arg_names = do fields.map |field| {\n+                    match field.node.kind {\n+                        named_field(ident, _) => ident,\n+                        unnamed_field => cx.sess.bug(\n+                            \"enum_variants: all fields in struct must have a name\")\n+                    }\n+                };\n+\n+                return VariantInfo {\n+                    args: arg_tys,\n+                    arg_names: Some(arg_names),\n+                    ctor_ty: ctor_ty,\n+                    name: ast_variant.node.name,\n+                    id: ast_util::local_def(ast_variant.node.id),\n+                    disr_val: discriminant,\n+                    vis: ast_variant.node.vis\n+                };\n+            }\n+        }\n+    }\n+}\n \n pub fn substd_enum_variants(cx: ctxt,\n                             id: ast::def_id,\n                             substs: &substs)\n-                         -> ~[VariantInfo] {\n+                         -> ~[@VariantInfo] {\n     do enum_variants(cx, id).iter().transform |variant_info| {\n         let substd_args = variant_info.args.iter()\n             .transform(|aty| subst(cx, substs, *aty)).collect();\n \n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n-        @VariantInfo_ {\n+        @VariantInfo {\n             args: substd_args,\n             ctor_ty: substd_ctor_ty,\n             ..(**variant_info).clone()\n@@ -3820,7 +3875,7 @@ pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n      }\n }\n \n-pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n+pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n     match cx.enum_var_cache.find(&id) {\n       Some(&variants) => return variants,\n       _ => { /* fallthrough */ }\n@@ -3839,61 +3894,31 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n                 }, _) => {\n-            let mut disr_val = -1;\n+            let mut last_discriminant: Option<int> = None;\n             @enum_definition.variants.iter().transform(|variant| {\n \n-                let ctor_ty = node_id_to_type(cx, variant.node.id);\n-\n-                match variant.node.kind {\n-                    ast::tuple_variant_kind(ref args) => {\n-                        let arg_tys = if args.len() > 0u {\n-                                ty_fn_args(ctor_ty).map(|a| *a) }\n-                            else {\n-                                ~[]\n-                            };\n-\n-                        match variant.node.disr_expr {\n-                          Some (ex) => {\n-                            disr_val = match const_eval::eval_const_expr(cx,\n-                                                                         ex) {\n-                              const_eval::const_int(val) => val as int,\n-                              _ => cx.sess.bug(\"enum_variants: bad disr expr\")\n-                            }\n-                          }\n-                          _ => disr_val += 1\n+                let mut discriminant = match last_discriminant {\n+                    Some(val) => val + 1,\n+                    None => INITIAL_DISCRIMINANT_VALUE\n+                };\n+\n+                match variant.node.disr_expr {\n+                    Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n+                        Ok(const_eval::const_int(val)) => discriminant = val as int,\n+                        Ok(_) => {\n+                            cx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }\n-                        @VariantInfo_{\n-                            args: arg_tys,\n-                            ctor_ty: ctor_ty,\n-                            name: variant.node.name,\n-                            id: ast_util::local_def(variant.node.id),\n-                            disr_val: disr_val,\n-                            vis: variant.node.vis\n-                         }\n-                    },\n-                    ast::struct_variant_kind(struct_def) => {\n-                        let arg_tys =\n-                            // Is this check needed for structs too, or are they always guaranteed\n-                            // to have a valid constructor function?\n-                            if struct_def.fields.len() > 0 {\n-                                ty_fn_args(ctor_ty).map(|a| *a)\n-                            } else {\n-                                ~[]\n-                            };\n-\n-                        assert!(variant.node.disr_expr.is_none());\n-                        disr_val += 1;\n-\n-                        @VariantInfo_{\n-                            args: arg_tys,\n-                            ctor_ty: ctor_ty,\n-                            name: variant.node.name,\n-                            id: ast_util::local_def(variant.node.id),\n-                            disr_val: disr_val,\n-                            vis: variant.node.vis\n+                        Err(ref err) => {\n+                            cx.sess.span_err(e.span, fmt!(\"expected constant: %s\", (*err)));\n                         }\n-                    }\n-                }\n+                    },\n+                    None => {}\n+                };\n+\n+                let variant_info = @VariantInfo::from_ast_variant(cx, variant, discriminant);\n+                last_discriminant = Some(discriminant);\n+                variant_info\n+\n             }).collect()\n           }\n           _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n@@ -3908,7 +3933,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n pub fn enum_variant_with_id(cx: ctxt,\n                             enum_id: ast::def_id,\n                             variant_id: ast::def_id)\n-                         -> VariantInfo {\n+                         -> @VariantInfo {\n     let variants = enum_variants(cx, enum_id);\n     let mut i = 0;\n     while i < variants.len() {"}, {"sha": "fa24c8c6d0983ab53eafa8ec70bee3aa19293f37", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 48, "deletions": 64, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -81,7 +81,7 @@ use middle::const_eval;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::lint::unreachable_code;\n-use middle::ty::{FnSig, VariantInfo_};\n+use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n use middle::ty::{substs, param_ty, ExprTyProvider};\n use middle::ty;\n@@ -3133,82 +3133,66 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                            vs: &[ast::variant],\n                            id: ast::node_id) {\n     fn do_check(ccx: @mut CrateCtxt,\n-                _sp: span,\n                 vs: &[ast::variant],\n-                id: ast::node_id,\n-                disr_vals: &mut ~[int],\n-                disr_val: &mut int,\n-                variants: &mut ~[ty::VariantInfo]) {\n+                id: ast::node_id)\n+                -> ~[@ty::VariantInfo] {\n+\n         let rty = ty::node_id_to_type(ccx.tcx, id);\n-        for vs.iter().advance |v| {\n-            for v.node.disr_expr.iter().advance |e_ref| {\n-                let e = *e_ref;\n-                debug!(\"disr expr, checking %s\",\n-                       pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n-                let declty = ty::mk_int();\n-                let fcx = blank_fn_ctxt(ccx, rty, e.id);\n-                check_const_with_ty(fcx, e.span, e, declty);\n-                // check_expr (from check_const pass) doesn't guarantee\n-                // that the expression is in an form that eval_const_expr can\n-                // handle, so we may still get an internal compiler error\n-\n-                match const_eval::eval_const_expr_partial(&ccx.tcx, e) {\n-                  Ok(const_eval::const_int(val)) => {\n-                    *disr_val = val as int;\n-                  }\n-                  Ok(_) => {\n-                    ccx.tcx.sess.span_err(e.span, \"expected signed integer \\\n-                                                   constant\");\n-                  }\n-                  Err(ref err) => {\n-                    ccx.tcx.sess.span_err(e.span,\n-                     fmt!(\"expected constant: %s\", (*err)));\n+        let mut variants: ~[@ty::VariantInfo] = ~[];\n+        let mut disr_vals: ~[int] = ~[];\n+        let mut prev_disr_val: Option<int> = None;\n \n-                  }\n-                }\n-            }\n-            if disr_vals.contains(&*disr_val) {\n-                ccx.tcx.sess.span_err(v.span,\n-                                      \"discriminator value already exists\");\n-            }\n-            disr_vals.push(*disr_val);\n-            let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n+        for vs.iter().advance |v| {\n \n-            let this_disr_val = *disr_val;\n-            *disr_val += 1;\n+            // If the discriminant value is specified explicitly in the enum check whether the\n+            // initialization expression is valid, otherwise use the last value plus one.\n+            let mut current_disr_val = match prev_disr_val {\n+                Some(prev_disr_val) => prev_disr_val + 1,\n+                None => ty::INITIAL_DISCRIMINANT_VALUE\n+            };\n \n-            let arg_tys = match v.node.kind {\n-                ast::tuple_variant_kind(ref args) if args.len() > 0u => {\n-                    Some(ty::ty_fn_args(ctor_ty).map(|a| *a))\n-                }\n-                ast::tuple_variant_kind(_) => {\n-                    Some(~[])\n-                }\n-                ast::struct_variant_kind(_) => {\n-                    Some(ty::lookup_struct_fields(\n-                        ccx.tcx, local_def(v.node.id)).map(|cf|\n-                            ty::node_id_to_type(ccx.tcx, cf.id.node)))\n-                }\n+            match v.node.disr_expr {\n+                Some(e) => {\n+                    debug!(\"disr expr, checking %s\", pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n+\n+                    let declty = ty::mk_int();\n+                    let fcx = blank_fn_ctxt(ccx, rty, e.id);\n+                    check_const_with_ty(fcx, e.span, e, declty);\n+                    // check_expr (from check_const pass) doesn't guarantee\n+                    // that the expression is in an form that eval_const_expr can\n+                    // handle, so we may still get an internal compiler error\n+\n+                    match const_eval::eval_const_expr_partial(&ccx.tcx, e) {\n+                        Ok(const_eval::const_int(val)) => current_disr_val = val as int,\n+                        Ok(_) => {\n+                            ccx.tcx.sess.span_err(e.span, \"expected signed integer constant\");\n+                        }\n+                        Err(ref err) => {\n+                            ccx.tcx.sess.span_err(e.span, fmt!(\"expected constant: %s\", (*err)));\n+                        }\n+                    }\n+                },\n+                None => ()\n             };\n \n-            match arg_tys {\n-                None => {}\n-                Some(arg_tys) => {\n-                    variants.push(\n-                        @VariantInfo_{args: arg_tys, ctor_ty: ctor_ty,\n-                          name: v.node.name, id: local_def(v.node.id),\n-                          disr_val: this_disr_val, vis: v.node.vis});\n-                }\n+            // Check for duplicate discriminator values\n+            if disr_vals.contains(&current_disr_val) {\n+                ccx.tcx.sess.span_err(v.span, \"discriminator value already exists\");\n             }\n+            disr_vals.push(current_disr_val);\n+\n+            let variant_info = @VariantInfo::from_ast_variant(ccx.tcx, v, current_disr_val);\n+            prev_disr_val = Some(current_disr_val);\n+\n+            variants.push(variant_info);\n         }\n+\n+        return variants;\n     }\n \n     let rty = ty::node_id_to_type(ccx.tcx, id);\n-    let mut disr_vals: ~[int] = ~[];\n-    let mut disr_val = 0;\n-    let mut variants = ~[];\n \n-    do_check(ccx, sp, vs, id, &mut disr_vals, &mut disr_val, &mut variants);\n+    let variants = do_check(ccx, vs, id);\n \n     // cache so that ty::enum_variants won't repeat this work\n     ccx.tcx.enum_var_cache.insert(local_def(id), @variants);"}, {"sha": "2a1f26bf441086903445fb6d32bd9aa64725049a", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 96, "deletions": 42, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -565,8 +565,8 @@ extern \"C\" bool LLVMRustStartMultithreading() {\n typedef DIBuilder* DIBuilderRef;\n \n template<typename DIT>\n-DIT unwrapDI(LLVMValueRef ref) { \n-    return DIT(ref ? unwrap<MDNode>(ref) : NULL); \n+DIT unwrapDI(LLVMValueRef ref) {\n+    return DIT(ref ? unwrap<MDNode>(ref) : NULL);\n }\n \n extern \"C\" DIBuilderRef LLVMDIBuilderCreate(LLVMModuleRef M) {\n@@ -604,21 +604,21 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateFile(\n \n extern \"C\" LLVMValueRef LLVMDIBuilderCreateSubroutineType(\n     DIBuilderRef Builder,\n-    LLVMValueRef File, \n+    LLVMValueRef File,\n     LLVMValueRef ParameterTypes) {\n     return wrap(Builder->createSubroutineType(\n-        unwrapDI<DIFile>(File), \n+        unwrapDI<DIFile>(File),\n         unwrapDI<DIArray>(ParameterTypes)));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderCreateFunction(\n     DIBuilderRef Builder,\n-    LLVMValueRef Scope, \n+    LLVMValueRef Scope,\n     const char* Name,\n     const char* LinkageName,\n-    LLVMValueRef File,  \n+    LLVMValueRef File,\n     unsigned LineNo,\n-    LLVMValueRef Ty, \n+    LLVMValueRef Ty,\n     bool isLocalToUnit,\n     bool isDefinition,\n     unsigned ScopeLine,\n@@ -628,11 +628,11 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateFunction(\n     LLVMValueRef TParam,\n     LLVMValueRef Decl) {\n     return wrap(Builder->createFunction(\n-        unwrapDI<DIScope>(Scope), Name, LinkageName, \n-        unwrapDI<DIFile>(File), LineNo, \n-        unwrapDI<DIType>(Ty), isLocalToUnit, isDefinition, ScopeLine, \n+        unwrapDI<DIScope>(Scope), Name, LinkageName,\n+        unwrapDI<DIFile>(File), LineNo,\n+        unwrapDI<DIType>(Ty), isLocalToUnit, isDefinition, ScopeLine,\n         Flags, isOptimized,\n-        unwrap<Function>(Fn), \n+        unwrap<Function>(Fn),\n         unwrapDI<MDNode*>(TParam),\n         unwrapDI<MDNode*>(Decl)));\n }\n@@ -644,10 +644,10 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateBasicType(\n     uint64_t AlignInBits,\n     unsigned Encoding) {\n     return wrap(Builder->createBasicType(\n-        Name, SizeInBits, \n+        Name, SizeInBits,\n         AlignInBits, Encoding));\n }\n-    \n+\n extern \"C\" LLVMValueRef LLVMDIBuilderCreatePointerType(\n     DIBuilderRef Builder,\n     LLVMValueRef PointeeTy,\n@@ -672,11 +672,11 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateStructType(\n     unsigned RunTimeLang,\n     LLVMValueRef VTableHolder) {\n     return wrap(Builder->createStructType(\n-        unwrapDI<DIDescriptor>(Scope), Name, \n-        unwrapDI<DIFile>(File), LineNumber, \n-        SizeInBits, AlignInBits, Flags, \n-        unwrapDI<DIType>(DerivedFrom), \n-        unwrapDI<DIArray>(Elements), RunTimeLang, \n+        unwrapDI<DIDescriptor>(Scope), Name,\n+        unwrapDI<DIFile>(File), LineNumber,\n+        SizeInBits, AlignInBits, Flags,\n+        unwrapDI<DIType>(DerivedFrom),\n+        unwrapDI<DIArray>(Elements), RunTimeLang,\n         unwrapDI<MDNode*>(VTableHolder)));\n }\n \n@@ -692,23 +692,23 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateMemberType(\n     unsigned Flags,\n     LLVMValueRef Ty) {\n     return wrap(Builder->createMemberType(\n-        unwrapDI<DIDescriptor>(Scope), Name, \n+        unwrapDI<DIDescriptor>(Scope), Name,\n         unwrapDI<DIFile>(File), LineNo,\n-        SizeInBits, AlignInBits, OffsetInBits, Flags, \n+        SizeInBits, AlignInBits, OffsetInBits, Flags,\n         unwrapDI<DIType>(Ty)));\n }\n-    \n+\n extern \"C\" LLVMValueRef LLVMDIBuilderCreateLexicalBlock(\n     DIBuilderRef Builder,\n     LLVMValueRef Scope,\n     LLVMValueRef File,\n     unsigned Line,\n     unsigned Col) {\n     return wrap(Builder->createLexicalBlock(\n-        unwrapDI<DIDescriptor>(Scope), \n+        unwrapDI<DIDescriptor>(Scope),\n         unwrapDI<DIFile>(File), Line, Col));\n }\n-    \n+\n extern \"C\" LLVMValueRef LLVMDIBuilderCreateLocalVariable(\n     DIBuilderRef Builder,\n     unsigned Tag,\n@@ -720,45 +720,45 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateLocalVariable(\n     bool AlwaysPreserve,\n     unsigned Flags,\n     unsigned ArgNo) {\n-    return wrap(Builder->createLocalVariable(Tag, \n-        unwrapDI<DIDescriptor>(Scope), Name, \n-        unwrapDI<DIFile>(File), \n-        LineNo, \n+    return wrap(Builder->createLocalVariable(Tag,\n+        unwrapDI<DIDescriptor>(Scope), Name,\n+        unwrapDI<DIFile>(File),\n+        LineNo,\n         unwrapDI<DIType>(Ty), AlwaysPreserve, Flags, ArgNo));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderCreateArrayType(\n     DIBuilderRef Builder,\n-    uint64_t Size,  \n-    uint64_t AlignInBits,  \n-    LLVMValueRef Ty, \n+    uint64_t Size,\n+    uint64_t AlignInBits,\n+    LLVMValueRef Ty,\n     LLVMValueRef Subscripts) {\n     return wrap(Builder->createArrayType(Size, AlignInBits,\n-        unwrapDI<DIType>(Ty), \n+        unwrapDI<DIType>(Ty),\n         unwrapDI<DIArray>(Subscripts)));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderCreateVectorType(\n     DIBuilderRef Builder,\n-    uint64_t Size,  \n-    uint64_t AlignInBits,  \n-    LLVMValueRef Ty, \n+    uint64_t Size,\n+    uint64_t AlignInBits,\n+    LLVMValueRef Ty,\n     LLVMValueRef Subscripts) {\n     return wrap(Builder->createVectorType(Size, AlignInBits,\n-        unwrapDI<DIType>(Ty), \n+        unwrapDI<DIType>(Ty),\n         unwrapDI<DIArray>(Subscripts)));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderGetOrCreateSubrange(\n-    DIBuilderRef Builder, \n-    int64_t Lo, \n+    DIBuilderRef Builder,\n+    int64_t Lo,\n     int64_t Count) {\n     return wrap(Builder->getOrCreateSubrange(Lo, Count));\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderGetOrCreateArray(\n     DIBuilderRef Builder,\n-    LLVMValueRef* Ptr, \n+    LLVMValueRef* Ptr,\n     unsigned Count) {\n     return wrap(Builder->getOrCreateArray(\n         ArrayRef<Value*>(reinterpret_cast<Value**>(Ptr), Count)));\n@@ -770,8 +770,8 @@ extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareAtEnd(\n     LLVMValueRef VarInfo,\n     LLVMBasicBlockRef InsertAtEnd) {\n     return wrap(Builder->insertDeclare(\n-        unwrap(Val), \n-        unwrapDI<DIVariable>(VarInfo), \n+        unwrap(Val),\n+        unwrapDI<DIVariable>(VarInfo),\n         unwrap(InsertAtEnd)));\n }\n \n@@ -781,7 +781,61 @@ extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareBefore(\n     LLVMValueRef VarInfo,\n     LLVMValueRef InsertBefore) {\n     return wrap(Builder->insertDeclare(\n-        unwrap(Val), \n-        unwrapDI<DIVariable>(VarInfo), \n+        unwrap(Val),\n+        unwrapDI<DIVariable>(VarInfo),\n         unwrap<Instruction>(InsertBefore)));\n }\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateEnumerator(\n+    DIBuilderRef Builder,\n+    const char* Name,\n+    uint64_t Val)\n+{\n+    return wrap(Builder->createEnumerator(Name, Val));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateEnumerationType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope,\n+    const char* Name,\n+    LLVMValueRef File,\n+    unsigned LineNumber,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    LLVMValueRef Elements,\n+    LLVMValueRef ClassType)\n+{\n+    return wrap(Builder->createEnumerationType(\n+        unwrapDI<DIDescriptor>(Scope),\n+        Name,\n+        unwrapDI<DIFile>(File),\n+        LineNumber,\n+        SizeInBits,\n+        AlignInBits,\n+        unwrapDI<DIArray>(Elements),\n+        unwrapDI<DIType>(ClassType)));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateUnionType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope,\n+    const char* Name,\n+    LLVMValueRef File,\n+    unsigned LineNumber,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    unsigned Flags,\n+    LLVMValueRef Elements,\n+    unsigned RunTimeLang)\n+{\n+    return wrap(Builder->createUnionType(\n+        unwrapDI<DIDescriptor>(Scope),\n+        Name,\n+        unwrapDI<DIFile>(File),\n+        LineNumber,\n+        SizeInBits,\n+        AlignInBits,\n+        Flags,\n+        unwrapDI<DIArray>(Elements),\n+        RunTimeLang));\n+}\n\\ No newline at end of file"}, {"sha": "5b6c3ed2f52f94bb83617c2624705b2934a35c43", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -608,3 +608,6 @@ LLVMDIBuilderCreateSubroutineType\n LLVMDIBuilderGetOrCreateArray\n LLVMDIBuilderInsertDeclareAtEnd\n LLVMDIBuilderInsertDeclareBefore\n+LLVMDIBuilderCreateEnumerator\n+LLVMDIBuilderCreateEnumerationType\n+LLVMDIBuilderCreateUnionType"}, {"sha": "7610301f6f0358baf940d2617d8a8e3f3c03d24b", "filename": "src/test/debug-info/borrowed-basic.rs", "status": "renamed", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-basic.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -10,10 +10,7 @@\n \n // xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n-// Caveats - gdb prints any 8-bit value (meaning rust i8 and u8 values)\n-// as its numerical value along with its associated ASCII char, there\n-// doesn't seem to be any way around this. Also, gdb doesn't know\n-// about UTF-32 character encoding and will print a rust char as only\n+// Gdb doesn't know about UTF-32 character encoding and will print a rust char as only\n // its numerical value.\n \n // compile-flags:-Z extra-debug-info\n@@ -67,49 +64,49 @@\n \n fn main() {\n     let bool_val: bool = true;\n-    let bool_ref : &bool = &bool_val;\n+    let bool_ref: &bool = &bool_val;\n \n     let int_val: int = -1;\n-    let int_ref : &int = &int_val;\n+    let int_ref: &int = &int_val;\n \n     let char_val: char = 'a';\n-    let char_ref : &char = &char_val;\n+    let char_ref: &char = &char_val;\n \n     let i8_val: i8 = 68;\n-    let i8_ref : &i8 = &i8_val;\n+    let i8_ref: &i8 = &i8_val;\n \n     let i16_val: i16 = -16;\n-    let i16_ref : &i16 = &i16_val;\n+    let i16_ref: &i16 = &i16_val;\n \n     let i32_val: i32 = -32;\n-    let i32_ref : &i32 = &i32_val;\n+    let i32_ref: &i32 = &i32_val;\n \n     let uint_val: i64 = -64;\n-    let i64_ref : &i64 = &uint_val;\n+    let i64_ref: &i64 = &uint_val;\n \n     let uint_val: uint = 1;\n-    let uint_ref : &uint = &uint_val;\n+    let uint_ref: &uint = &uint_val;\n \n     let u8_val: u8 = 100;\n-    let u8_ref : &u8 = &u8_val;\n+    let u8_ref: &u8 = &u8_val;\n \n     let u16_val: u16 = 16;\n-    let u16_ref : &u16 = &u16_val;\n+    let u16_ref: &u16 = &u16_val;\n \n     let u32_val: u32 = 32;\n-    let u32_ref : &u32 = &u32_val;\n+    let u32_ref: &u32 = &u32_val;\n \n     let u64_val: u64 = 64;\n-    let u64_ref : &u64 = &u64_val;\n+    let u64_ref: &u64 = &u64_val;\n \n     let float_val: float = 1.5;\n-    let float_ref : &float = &float_val;\n+    let float_ref: &float = &float_val;\n \n     let f32_val: f32 = 2.5;\n-    let f32_ref : &f32 = &f32_val;\n+    let f32_ref: &f32 = &f32_val;\n \n     let f64_val: f64 = 3.5;\n-    let f64_ref : &f64 = &f64_val;\n+    let f64_ref: &f64 = &f64_val;\n     zzz();\n }\n ", "previous_filename": "src/test/debug-info/reference-to-basic.rs"}, {"sha": "70c85258c7921518cafd1d5dbc084472b004d15e", "filename": "src/test/debug-info/borrowed-c-style-enum.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-c-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-c-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-c-style-enum.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print *the_a_ref\n+// check:$1 = TheA\n+\n+// debugger:print *the_b_ref\n+// check:$2 = TheB\n+\n+// debugger:print *the_c_ref\n+// check:$3 = TheC\n+\n+enum ABC { TheA, TheB, TheC }\n+\n+fn main() {\n+    let the_a = TheA;\n+    let the_a_ref: &ABC = &the_a;\n+\n+    let the_b = TheB;\n+    let the_b_ref: &ABC = &the_b;\n+\n+    let the_c = TheC;\n+    let the_c_ref: &ABC = &the_c;\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "38aa9c38810006fd5caf7b9c9d64499c917cb596", "filename": "src/test/debug-info/borrowed-enum.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-enum.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print *the_a_ref\n+// check:$1 = {{TheA, x = 0, y = 8970181431921507452}, {TheA, 0, 2088533116, 2088533116}}\n+\n+// debugger:print *the_b_ref\n+// check:$2 = {{TheB, x = 0, y = 1229782938247303441}, {TheB, 0, 286331153, 286331153}}\n+\n+// debugger:print *univariant_ref\n+// check:$3 = {4820353753753434}\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum ABC {\n+\tTheA { x: i64, y: i64 },\n+\tTheB (i64, i32, i32),\n+}\n+\n+// This is a special case since it does not have the implicit discriminant field.\n+enum Univariant {\n+    TheOnlyCase(i64)\n+}\n+\n+fn main() {\n+\n+\t// 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+\t// 0b01111100011111000111110001111100 = 2088533116\n+\t// 0b0111110001111100 = 31868\n+\t// 0b01111100 = 124\n+    let the_a = TheA { x: 0, y: 8970181431921507452 };\n+    let the_a_ref: &ABC = &the_a;\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let the_b = TheB (0, 286331153, 286331153);\n+    let the_b_ref: &ABC = &the_b;\n+\n+    let univariant = TheOnlyCase(4820353753753434);\n+    let univariant_ref: &Univariant = &univariant;\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "9087bb36fa5d66d9171753bc0c8fbfc6a53403e4", "filename": "src/test/debug-info/borrowed-managed-basic.rs", "status": "renamed", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-managed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-managed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-managed-basic.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -65,49 +65,49 @@\n \n fn main() {\n     let bool_box: @bool = @true;\n-    let bool_ref : &bool = bool_box;\n+    let bool_ref: &bool = bool_box;\n \n     let int_box: @int = @-1;\n-    let int_ref : &int = int_box;\n+    let int_ref: &int = int_box;\n \n     let char_box: @char = @'a';\n-    let char_ref : &char = char_box;\n+    let char_ref: &char = char_box;\n \n     let i8_box: @i8 = @68;\n-    let i8_ref : &i8 = i8_box;\n+    let i8_ref: &i8 = i8_box;\n \n     let i16_box: @i16 = @-16;\n-    let i16_ref : &i16 = i16_box;\n+    let i16_ref: &i16 = i16_box;\n \n     let i32_box: @i32 = @-32;\n-    let i32_ref : &i32 = i32_box;\n+    let i32_ref: &i32 = i32_box;\n \n     let i64_box: @i64 = @-64;\n-    let i64_ref : &i64 = i64_box;\n+    let i64_ref: &i64 = i64_box;\n \n     let uint_box: @uint = @1;\n-    let uint_ref : &uint = uint_box;\n+    let uint_ref: &uint = uint_box;\n \n     let u8_box: @u8 = @100;\n-    let u8_ref : &u8 = u8_box;\n+    let u8_ref: &u8 = u8_box;\n \n     let u16_box: @u16 = @16;\n-    let u16_ref : &u16 = u16_box;\n+    let u16_ref: &u16 = u16_box;\n \n     let u32_box: @u32 = @32;\n-    let u32_ref : &u32 = u32_box;\n+    let u32_ref: &u32 = u32_box;\n \n     let u64_box: @u64 = @64;\n-    let u64_ref : &u64 = u64_box;\n+    let u64_ref: &u64 = u64_box;\n \n     let float_box: @float = @1.5;\n-    let float_ref : &float = float_box;\n+    let float_ref: &float = float_box;\n \n     let f32_box: @f32 = @2.5;\n-    let f32_ref : &f32 = f32_box;\n+    let f32_ref: &f32 = f32_box;\n \n     let f64_box: @f64 = @3.5;\n-    let f64_ref : &f64 = f64_box;\n+    let f64_ref: &f64 = f64_box;\n     zzz();\n }\n ", "previous_filename": "src/test/debug-info/reference-to-managed-basic.rs"}, {"sha": "8b6eca3e37f79d2338c7c66d15a274b304879424", "filename": "src/test/debug-info/borrowed-struct.rs", "status": "renamed", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-struct.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -10,9 +10,6 @@\n \n // xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n-// GDB doesn't know about UTF-32 character encoding and will print a rust char as only its numerical\n-// value.\n-\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n@@ -57,20 +54,20 @@ struct SomeStruct {\n \n fn main() {\n     let stack_val: SomeStruct = SomeStruct { x: 10, y: 23.5 };\n-    let stack_val_ref : &SomeStruct = &stack_val;\n-    let stack_val_interior_ref_1 : &int = &stack_val.x;\n-    let stack_val_interior_ref_2 : &f64 = &stack_val.y;\n-    let ref_to_unnamed : &SomeStruct = &SomeStruct { x: 11, y: 24.5 };\n+    let stack_val_ref: &SomeStruct = &stack_val;\n+    let stack_val_interior_ref_1: &int = &stack_val.x;\n+    let stack_val_interior_ref_2: &f64 = &stack_val.y;\n+    let ref_to_unnamed: &SomeStruct = &SomeStruct { x: 11, y: 24.5 };\n \n     let managed_val = @SomeStruct { x: 12, y: 25.5 };\n-    let managed_val_ref : &SomeStruct = managed_val;\n-    let managed_val_interior_ref_1 : &int = &managed_val.x;\n-    let managed_val_interior_ref_2 : &f64 = &managed_val.y;\n+    let managed_val_ref: &SomeStruct = managed_val;\n+    let managed_val_interior_ref_1: &int = &managed_val.x;\n+    let managed_val_interior_ref_2: &f64 = &managed_val.y;\n \n     let unique_val = ~SomeStruct { x: 13, y: 26.5 };\n-    let unique_val_ref : &SomeStruct = unique_val;\n-    let unique_val_interior_ref_1 : &int = &unique_val.x;\n-    let unique_val_interior_ref_2 : &f64 = &unique_val.y;\n+    let unique_val_ref: &SomeStruct = unique_val;\n+    let unique_val_interior_ref_1: &int = &unique_val.x;\n+    let unique_val_interior_ref_2: &f64 = &unique_val.y;\n \n     zzz();\n }", "previous_filename": "src/test/debug-info/reference-to-struct.rs"}, {"sha": "da199941c841975a8937fb8ef02afa485e6fb797", "filename": "src/test/debug-info/borrowed-tuple.rs", "status": "renamed", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-tuple.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -10,9 +10,6 @@\n \n // xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n-// GDB doesn't know about UTF-32 character encoding and will print a rust char as only its numerical\n-// value.\n-\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n@@ -32,14 +29,14 @@\n \n fn main() {\n     let stack_val: (i16, f32) = (-14, -19f32);\n-    let stack_val_ref : &(i16, f32) = &stack_val;\n-    let ref_to_unnamed : &(i16, f32) = &(-15, -20f32);\n+    let stack_val_ref: &(i16, f32) = &stack_val;\n+    let ref_to_unnamed: &(i16, f32) = &(-15, -20f32);\n \n-    let managed_val : @(i16, f32) = @(-16, -21f32);\n-    let managed_val_ref : &(i16, f32) = managed_val;\n+    let managed_val: @(i16, f32) = @(-16, -21f32);\n+    let managed_val_ref: &(i16, f32) = managed_val;\n \n     let unique_val: ~(i16, f32) = ~(-17, -22f32);\n-    let unique_val_ref : &(i16, f32) = unique_val;\n+    let unique_val_ref: &(i16, f32) = unique_val;\n \n     zzz();\n }", "previous_filename": "src/test/debug-info/reference-to-tuple.rs"}, {"sha": "52f5a2cba1ebe721feeccffb3f23384b939408de", "filename": "src/test/debug-info/borrowed-unique-basic.rs", "status": "renamed", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fborrowed-unique-basic.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -10,8 +10,7 @@\n \n // xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n-// Gdb doesn't know\n-// about UTF-32 character encoding and will print a rust char as only\n+// Gdb doesn't know about UTF-32 character encoding and will print a rust char as only\n // its numerical value.\n \n // compile-flags:-Z extra-debug-info\n@@ -66,49 +65,49 @@\n \n fn main() {\n     let bool_box: ~bool = ~true;\n-    let bool_ref : &bool = bool_box;\n+    let bool_ref: &bool = bool_box;\n \n     let int_box: ~int = ~-1;\n-    let int_ref : &int = int_box;\n+    let int_ref: &int = int_box;\n \n     let char_box: ~char = ~'a';\n-    let char_ref : &char = char_box;\n+    let char_ref: &char = char_box;\n \n     let i8_box: ~i8 = ~68;\n-    let i8_ref : &i8 = i8_box;\n+    let i8_ref: &i8 = i8_box;\n \n     let i16_box: ~i16 = ~-16;\n-    let i16_ref : &i16 = i16_box;\n+    let i16_ref: &i16 = i16_box;\n \n     let i32_box: ~i32 = ~-32;\n-    let i32_ref : &i32 = i32_box;\n+    let i32_ref: &i32 = i32_box;\n \n     let i64_box: ~i64 = ~-64;\n-    let i64_ref : &i64 = i64_box;\n+    let i64_ref: &i64 = i64_box;\n \n     let uint_box: ~uint = ~1;\n-    let uint_ref : &uint = uint_box;\n+    let uint_ref: &uint = uint_box;\n \n     let u8_box: ~u8 = ~100;\n-    let u8_ref : &u8 = u8_box;\n+    let u8_ref: &u8 = u8_box;\n \n     let u16_box: ~u16 = ~16;\n-    let u16_ref : &u16 = u16_box;\n+    let u16_ref: &u16 = u16_box;\n \n     let u32_box: ~u32 = ~32;\n-    let u32_ref : &u32 = u32_box;\n+    let u32_ref: &u32 = u32_box;\n \n     let u64_box: ~u64 = ~64;\n-    let u64_ref : &u64 = u64_box;\n+    let u64_ref: &u64 = u64_box;\n \n     let float_box: ~float = ~1.5;\n-    let float_ref : &float = float_box;\n+    let float_ref: &float = float_box;\n \n     let f32_box: ~f32 = ~2.5;\n-    let f32_ref : &f32 = f32_box;\n+    let f32_ref: &f32 = f32_box;\n \n     let f64_box: ~f64 = ~3.5;\n-    let f64_ref : &f64 = f64_box;\n+    let f64_ref: &f64 = f64_box;\n     zzz();\n }\n ", "previous_filename": "src/test/debug-info/reference-to-unique-basic.rs"}, {"sha": "c63cffd7b74bb7311743f212380ea52b14e3d92b", "filename": "src/test/debug-info/box.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbox.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -8,20 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n // compile-flags:-Z extra-debug-info\n // debugger:set print pretty off\n // debugger:break _zzz\n // debugger:run\n // debugger:finish\n-// debugger:print a->boxed\n+// debugger:print *a\n // check:$1 = 1\n-// debugger:print b->boxed\n+// debugger:print *b\n // check:$2 = {2, 3.5}\n-// debugger:print c->boxed\n+// debugger:print c->val\n // check:$3 = 4\n-// debugger:print d->boxed\n+// debugger:print d->val\n // check:$4 = false\n \n fn main() {"}, {"sha": "86162f0fa04cd4abbf92d09fe68d73363b49d26b", "filename": "src/test/debug-info/boxed-struct.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print *unique\n+// check:$1 = {x = 99, y = 999, z = 9999, w = 99999}\n+\n+// debugger:print managed->val\n+// check:$2 = {x = 88, y = 888, z = 8888, w = 88888}\n+\n+// debugger:print *unique_dtor\n+// check:$3 = {x = 77, y = 777, z = 7777, w = 77777}\n+\n+// debugger:print managed_dtor->val\n+// check:$4 = {x = 33, y = 333, z = 3333, w = 33333}\n+\n+struct StructWithSomePadding {\n+    x: i16,\n+    y: i32,\n+    z: i32,\n+    w: i64\n+}\n+\n+struct StructWithDestructor {\n+    x: i16,\n+    y: i32,\n+    z: i32,\n+    w: i64\n+}\n+\n+impl Drop for StructWithDestructor {\n+    fn drop(&self) {}\n+}\n+\n+fn main() {\n+\n+    let unique = ~StructWithSomePadding { x: 99, y: 999, z: 9999, w: 99999 };\n+    let managed = @StructWithSomePadding { x: 88, y: 888, z: 8888, w: 88888 };\n+\n+    let unique_dtor = ~StructWithDestructor { x: 77, y: 777, z: 7777, w: 77777 };\n+    let managed_dtor = @StructWithDestructor { x: 33, y: 333, z: 3333, w: 33333 };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "8abead6519697305a8148c9d938108235e205ff3", "filename": "src/test/debug-info/boxed-vec.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fboxed-vec.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print managed->val.fill\n+// check:$1 = 24\n+// debugger:print *((uint64_t[3]*)(managed->val.elements))\n+// check:$2 = {7, 8, 9}\n+\n+// debugger:print unique->fill\n+// check:$3 = 32\n+// debugger:print *((uint64_t[4]*)(unique->elements))\n+// check:$4 = {10, 11, 12, 13}\n+\n+fn main() {\n+\n+    let managed: @[i64] = @[7, 8, 9];\n+    let unique: ~[i64] = ~[10, 11, 12, 13];\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "47e433ea814abef3eec95fca5e2c9201e815714a", "filename": "src/test/debug-info/c-style-enum-in-composite.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fc-style-enum-in-composite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fc-style-enum-in-composite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fc-style-enum-in-composite.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print tuple_interior_padding\n+// check:$1 = {0, OneHundred}\n+\n+// debugger:print tuple_padding_at_end\n+// check:$2 = {{1, OneThousand}, 2}\n+\n+// debugger:print tuple_different_enums\n+// check:$3 = {OneThousand, MountainView, OneMillion, Vienna}\n+\n+// debugger:print padded_struct\n+// check:$4 = {a = 3, b = OneMillion, c = 4, d = Toronto, e = 5}\n+\n+// debugger:print packed_struct\n+// check:$5 = {a = 6, b = OneHundred, c = 7, d = Vienna, e = 8}\n+\n+// debugger:print non_padded_struct\n+// check:$6 = {a = OneMillion, b = MountainView, c = OneThousand, d = Toronto}\n+\n+// debugger:print struct_with_drop\n+// check:$7 = {{a = OneHundred, b = Vienna}, 9}\n+\n+enum AnEnum {\n+    OneHundred = 100,\n+    OneThousand = 1000,\n+    OneMillion = 1000000\n+}\n+\n+enum AnotherEnum {\n+    MountainView,\n+    Toronto,\n+    Vienna\n+}\n+\n+struct PaddedStruct {\n+    a: i16,\n+    b: AnEnum,\n+    c: i16,\n+    d: AnotherEnum,\n+    e: i16\n+}\n+\n+#[packed]\n+struct PackedStruct {\n+    a: i16,\n+    b: AnEnum,\n+    c: i16,\n+    d: AnotherEnum,\n+    e: i16\n+}\n+\n+struct NonPaddedStruct {\n+    a: AnEnum,\n+    b: AnotherEnum,\n+    c: AnEnum,\n+    d: AnotherEnum\n+}\n+\n+struct StructWithDrop {\n+    a: AnEnum,\n+    b: AnotherEnum\n+}\n+\n+impl Drop for StructWithDrop {\n+    fn drop(&self) {()}\n+}\n+\n+fn main() {\n+\n+    let tuple_interior_padding = (0_i16, OneHundred);\n+    // It will depend on the machine architecture if any padding is actually involved here\n+    let tuple_padding_at_end = ((1_u64, OneThousand), 2_u64);\n+    let tuple_different_enums = (OneThousand, MountainView, OneMillion, Vienna);\n+\n+    let padded_struct = PaddedStruct {\n+        a: 3,\n+        b: OneMillion,\n+        c: 4,\n+        d: Toronto,\n+        e: 5\n+    };\n+\n+    let packed_struct = PackedStruct {\n+        a: 6,\n+        b: OneHundred,\n+        c: 7,\n+        d: Vienna,\n+        e: 8\n+    };\n+\n+    let non_padded_struct = NonPaddedStruct {\n+        a: OneMillion,\n+        b: MountainView,\n+        c: OneThousand,\n+        d: Toronto\n+    };\n+\n+    let struct_with_drop = (StructWithDrop { a: OneHundred, b: Vienna }, 9_i64);\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "d7cce4e6f3fb54585cc9a0add5ccb94546b82e58", "filename": "src/test/debug-info/c-style-enum.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print auto_one\n+// check:$1 = One\n+\n+// debugger:print auto_two\n+// check:$2 = Two\n+\n+// debugger:print auto_three\n+// check:$3 = Three\n+\n+// debugger:print manual_one_hundred\n+// check:$4 = OneHundred\n+\n+// debugger:print manual_one_thousand\n+// check:$5 = OneThousand\n+\n+// debugger:print manual_one_million\n+// check:$6 = OneMillion\n+\n+// debugger:print single_variant\n+// check:$7 = TheOnlyVariant\n+\n+enum AutoDiscriminant {\n+    One,\n+    Two,\n+    Three\n+}\n+\n+enum ManualDiscriminant {\n+    OneHundred = 100,\n+    OneThousand = 1000,\n+    OneMillion = 1000000\n+}\n+\n+enum SingleVariant {\n+    TheOnlyVariant\n+}\n+\n+fn main() {\n+\n+    let auto_one = One;\n+    let auto_two = Two;\n+    let auto_three = Three;\n+\n+    let manual_one_hundred = OneHundred;\n+    let manual_one_thousand = OneThousand;\n+    let manual_one_million = OneMillion;\n+\n+    let single_variant = TheOnlyVariant;\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "207899fe3b5104976a92b3610a4a176f65ae44f7", "filename": "src/test/debug-info/destructured-local.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -10,9 +10,6 @@\n \n // xfail-test\n \n-// GDB doesn't know about UTF-32 character encoding and will print a rust char as only its numerical\n-// value.\n-\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n@@ -25,7 +22,7 @@\n // check:$2 = false\n \n fn main() {\n-    let (a, b) : (int, bool) = (9898, false);\n+    let (a, b): (int, bool) = (9898, false);\n \n     zzz();\n }"}, {"sha": "7e42690548e70cfaa6ec17b92c3ad32fec961848", "filename": "src/test/debug-info/evec-in-struct.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fevec-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fevec-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fevec-in-struct.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print no_padding1\n+// check:$1 = {x = {0, 1, 2}, y = -3, z = {4.5, 5.5}}\n+// debugger:print no_padding2\n+// check:$2 = {x = {6, 7, 8}, y = {{9, 10}, {11, 12}}}\n+\n+// debugger:print struct_internal_padding\n+// check:$3 = {x = {13, 14}, y = {15, 16}}\n+\n+// debugger:print single_vec\n+// check:$4 = {x = {17, 18, 19, 20, 21}}\n+\n+// debugger:print struct_padded_at_end\n+// check:$5 = {x = {22, 23}, y = {24, 25}}\n+\n+struct NoPadding1 {\n+    x: [u32, ..3],\n+    y: i32,\n+    z: [f32, ..2]\n+}\n+\n+struct NoPadding2 {\n+    x: [u32, ..3],\n+    y: [[u32, ..2], ..2]\n+}\n+\n+struct StructInternalPadding {\n+    x: [i16, ..2],\n+    y: [i64, ..2]\n+}\n+\n+struct SingleVec {\n+    x: [i16, ..5]\n+}\n+\n+struct StructPaddedAtEnd {\n+    x: [i64, ..2],\n+    y: [i16, ..2]\n+}\n+\n+fn main() {\n+\n+    let no_padding1 = NoPadding1 {\n+        x: [0, 1, 2],\n+        y: -3,\n+        z: [4.5, 5.5]\n+    };\n+\n+    let no_padding2 = NoPadding2 {\n+        x: [6, 7, 8],\n+        y: [[9, 10], [11, 12]]\n+    };\n+\n+    let struct_internal_padding = StructInternalPadding {\n+        x: [13, 14],\n+        y: [15, 16]\n+    };\n+\n+    let single_vec = SingleVec {\n+        x: [17, 18, 19, 20, 21]\n+    };\n+\n+    let struct_padded_at_end = StructPaddedAtEnd {\n+        x: [22, 23],\n+        y: [24, 25]\n+    };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "225dfedfec721357361b0ac9f04e6a34d5f773a7", "filename": "src/test/debug-info/function-arguments.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -10,9 +10,6 @@\n \n // xfail-test\n \n-// GDB doesn't know about UTF-32 character encoding and will print a rust char as only its numerical\n-// value.\n-\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run"}, {"sha": "1a3600a7d8cb3a737bcb0e57eb9ce927e120853c", "filename": "src/test/debug-info/managed-enum.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fmanaged-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fmanaged-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmanaged-enum.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print the_a->val\n+// check:$1 = {{TheA, x = 0, y = 8970181431921507452}, {TheA, 0, 2088533116, 2088533116}}\n+\n+// debugger:print the_b->val\n+// check:$2 = {{TheB, x = 0, y = 1229782938247303441}, {TheB, 0, 286331153, 286331153}}\n+\n+// debugger:print univariant->val\n+// check:$3 = {-9747455}\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum ABC {\n+\tTheA { x: i64, y: i64 },\n+\tTheB (i64, i32, i32),\n+}\n+\n+// This is a special case since it does not have the implicit discriminant field.\n+enum Univariant {\n+    TheOnlyCase(i64)\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianess trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+\t// 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+\t// 0b01111100011111000111110001111100 = 2088533116\n+\t// 0b0111110001111100 = 31868\n+\t// 0b01111100 = 124\n+    let the_a = @TheA { x: 0, y: 8970181431921507452 };\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let the_b = @TheB (0, 286331153, 286331153);\n+\n+    let univariant = @TheOnlyCase(-9747455);\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "e42631599a9b93ac82e57ec43b3945a13707f3e1", "filename": "src/test/debug-info/managed-pointer-within-unique-vec.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique-vec.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print unique->val.elements[0]->val\n+// check:$1 = 10\n+\n+// debugger:print unique->val.elements[1]->val\n+// check:$2 = 11\n+\n+// debugger:print unique->val.elements[2]->val\n+// check:$3 = 12\n+\n+// debugger:print unique->val.elements[3]->val\n+// check:$4 = 13\n+\n+fn main() {\n+\n+    let unique: ~[@i64] = ~[@10, @11, @12, @13];\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "3eb1c2ef01e55da2465f4e716842c3de473678c6", "filename": "src/test/debug-info/managed-pointer-within-unique.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print *ordinary_unique\n+// check:$1 = {-1, -2}\n+\n+// debugger:print managed_within_unique.val->x\n+// check:$2 = -3\n+\n+// debugger:print managed_within_unique.val->y->val\n+// check:$3 = -4\n+\n+struct ContainsManaged\n+{\n+\tx: int,\n+\ty: @int\n+}\n+\n+fn main() {\n+\n+\tlet ordinary_unique = ~(-1, -2);\n+\n+\n+\t// This is a special case: Normally values allocated in the exchange heap are not boxed, unless,\n+\t// however, if they contain managed pointers.\n+\t// This test case verifies that both cases are handled correctly.\n+    let managed_within_unique = ~ContainsManaged { x: -3, y: @-4 };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "d3afd4b11f9cd1f5e84e5e477b69fc2018c8bac1", "filename": "src/test/debug-info/nil-enum.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fnil-enum.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print first\n+// check:$1 = {<No data fields>}\n+\n+// debugger:print second\n+// check:$2 = {<No data fields>}\n+\n+enum ANilEnum {}\n+enum AnotherNilEnum {}\n+\n+// I (mw) am not sure this test case makes much sense...\n+// Also, it relies on some implementation details:\n+// 1. That empty enums as well as '()' are represented as empty structs\n+// 2. That gdb prints the string \"{<No data fields>}\" for empty structs (which may change some time)\n+fn main() {\n+    unsafe {\n+        let first: ANilEnum = std::cast::transmute(());\n+        let second: AnotherNilEnum = std::cast::transmute(());\n+\n+        zzz();\n+    }\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "6d3b157d63e802136c322e4c08cf55b9dd444c1e", "filename": "src/test/debug-info/option-like-enum.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print some\n+// check:$1 = {0x12345678}\n+\n+// debugger:print none\n+// check:$2 = {0x0}\n+\n+// debugger:print full\n+// check:$3 = {454545, 0x87654321, 9988}\n+\n+// debugger:print empty\n+// check:$4 = {0, 0x0, 0}\n+\n+// debugger:print droid\n+// check:$5 = {id = 675675, range = 10000001, internals = 0x43218765}\n+\n+// debugger:print void_droid\n+// check:$6 = {id = 0, range = 0, internals = 0x0}\n+\n+\n+// If a struct has exactly two variants, one of them is empty, and the other one\n+// contains a non-nullable pointer, then this value is used as the discriminator.\n+// The test cases in this file make sure that something readable is generated for\n+// this kind of types.\n+\n+enum MoreFields<'self> {\n+    Full(u32, &'self int, i16),\n+    Empty\n+}\n+\n+enum NamedFields<'self> {\n+    Droid { id: i32, range: i64, internals: &'self int },\n+    Void\n+}\n+\n+fn main() {\n+\n+    let some: Option<&u32> = Some(unsafe { std::cast::transmute(0x12345678) });\n+    let none: Option<&u32> = None;\n+\n+    let full = Full(454545, unsafe { std::cast::transmute(0x87654321) }, 9988);\n+\n+    let int_val = 0;\n+    let mut empty = Full(0, &int_val, 0);\n+    empty = Empty;\n+\n+    let droid = Droid { id: 675675, range: 10000001, internals: unsafe { std::cast::transmute(0x43218765) } };\n+\n+    let mut void_droid = Droid { id: 0, range: 0, internals: &int_val };\n+    void_droid = Void;\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "9ff91aa00d1c908a64bcda7ba6a161f9d63f6a5c", "filename": "src/test/debug-info/packed-struct-with-destructor.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fpacked-struct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fpacked-struct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fpacked-struct-with-destructor.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,219 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print packed\n+// check:$1 = {x = 123, y = 234, z = 345}\n+\n+// debugger:print packedInPacked\n+// check:$2 = {a = 1111, b = {x = 2222, y = 3333, z = 4444}, c = 5555, d = {x = 6666, y = 7777, z = 8888}}\n+\n+// debugger:print packedInUnpacked\n+// check:$3 = {a = -1111, b = {x = -2222, y = -3333, z = -4444}, c = -5555, d = {x = -6666, y = -7777, z = -8888}}\n+\n+// debugger:print unpackedInPacked\n+// check:$4 = {a = 987, b = {x = 876, y = 765, z = 654}, c = {x = 543, y = 432, z = 321}, d = 210}\n+\n+\n+// debugger:print packedInPackedWithDrop\n+// check:$5 = {a = 11, b = {x = 22, y = 33, z = 44}, c = 55, d = {x = 66, y = 77, z = 88}}\n+\n+// debugger:print packedInUnpackedWithDrop\n+// check:$6 = {a = -11, b = {x = -22, y = -33, z = -44}, c = -55, d = {x = -66, y = -77, z = -88}}\n+\n+// debugger:print unpackedInPackedWithDrop\n+// check:$7 = {a = 98, b = {x = 87, y = 76, z = 65}, c = {x = 54, y = 43, z = 32}, d = 21}\n+\n+// debugger:print deeplyNested\n+// check:$8 = {a = {a = 1, b = {x = 2, y = 3, z = 4}, c = 5, d = {x = 6, y = 7, z = 8}}, b = {a = 9, b = {x = 10, y = 11, z = 12}, c = {x = 13, y = 14, z = 15}, d = 16}, c = {a = 17, b = {x = 18, y = 19, z = 20}, c = 21, d = {x = 22, y = 23, z = 24}}, d = {a = 25, b = {x = 26, y = 27, z = 28}, c = 29, d = {x = 30, y = 31, z = 32}}, e = {a = 33, b = {x = 34, y = 35, z = 36}, c = {x = 37, y = 38, z = 39}, d = 40}, f = {a = 41, b = {x = 42, y = 43, z = 44}, c = 45, d = {x = 46, y = 47, z = 48}}}\n+\n+#[packed]\n+struct Packed {\n+    x: i16,\n+    y: i32,\n+    z: i64\n+}\n+\n+impl Drop for Packed {\n+    fn drop(&self) {}\n+}\n+\n+#[packed]\n+struct PackedInPacked {\n+    a: i32,\n+    b: Packed,\n+    c: i64,\n+    d: Packed\n+}\n+\n+struct PackedInUnpacked {\n+    a: i32,\n+    b: Packed,\n+    c: i64,\n+    d: Packed\n+}\n+\n+struct Unpacked {\n+    x: i64,\n+    y: i32,\n+    z: i16\n+}\n+\n+impl Drop for Unpacked {\n+    fn drop(&self) {}\n+}\n+\n+#[packed]\n+struct UnpackedInPacked {\n+    a: i16,\n+    b: Unpacked,\n+    c: Unpacked,\n+    d: i64\n+}\n+\n+#[packed]\n+struct PackedInPackedWithDrop {\n+    a: i32,\n+    b: Packed,\n+    c: i64,\n+    d: Packed\n+}\n+\n+impl Drop for PackedInPackedWithDrop {\n+    fn drop(&self) {}\n+}\n+\n+struct PackedInUnpackedWithDrop {\n+    a: i32,\n+    b: Packed,\n+    c: i64,\n+    d: Packed\n+}\n+\n+impl Drop for PackedInUnpackedWithDrop {\n+    fn drop(&self) {}\n+}\n+\n+#[packed]\n+struct UnpackedInPackedWithDrop {\n+    a: i16,\n+    b: Unpacked,\n+    c: Unpacked,\n+    d: i64\n+}\n+\n+impl Drop for UnpackedInPackedWithDrop {\n+    fn drop(&self) {}\n+}\n+\n+struct DeeplyNested {\n+    a: PackedInPacked,\n+    b: UnpackedInPackedWithDrop,\n+    c: PackedInUnpacked,\n+    d: PackedInUnpackedWithDrop,\n+    e: UnpackedInPacked,\n+    f: PackedInPackedWithDrop\n+}\n+\n+fn main() {\n+    let packed = Packed { x: 123, y: 234, z: 345 };\n+\n+    let packedInPacked = PackedInPacked {\n+        a: 1111,\n+        b: Packed { x: 2222, y: 3333, z: 4444 },\n+        c: 5555,\n+        d: Packed { x: 6666, y: 7777, z: 8888 }\n+    };\n+\n+    let packedInUnpacked = PackedInUnpacked {\n+        a: -1111,\n+        b: Packed { x: -2222, y: -3333, z: -4444 },\n+        c: -5555,\n+        d: Packed { x: -6666, y: -7777, z: -8888 }\n+    };\n+\n+    let unpackedInPacked = UnpackedInPacked {\n+        a: 987,\n+        b: Unpacked { x: 876, y: 765, z: 654 },\n+        c: Unpacked { x: 543, y: 432, z: 321 },\n+        d: 210\n+    };\n+\n+    let packedInPackedWithDrop = PackedInPackedWithDrop {\n+        a: 11,\n+        b: Packed { x: 22, y: 33, z: 44 },\n+        c: 55,\n+        d: Packed { x: 66, y: 77, z: 88 }\n+    };\n+\n+    let packedInUnpackedWithDrop = PackedInUnpackedWithDrop {\n+        a: -11,\n+        b: Packed { x: -22, y: -33, z: -44 },\n+        c: -55,\n+        d: Packed { x: -66, y: -77, z: -88 }\n+    };\n+\n+    let unpackedInPackedWithDrop = UnpackedInPackedWithDrop {\n+        a: 98,\n+        b: Unpacked { x: 87, y: 76, z: 65 },\n+        c: Unpacked { x: 54, y: 43, z: 32 },\n+        d: 21\n+    };\n+\n+    let deeplyNested = DeeplyNested {\n+        a: PackedInPacked {\n+            a: 1,\n+            b: Packed { x: 2, y: 3, z: 4 },\n+            c: 5,\n+            d: Packed { x: 6, y: 7, z: 8 }\n+        },\n+        b: UnpackedInPackedWithDrop {\n+            a: 9,\n+            b: Unpacked { x: 10, y: 11, z: 12 },\n+            c: Unpacked { x: 13, y: 14, z: 15 },\n+            d: 16\n+        },\n+        c: PackedInUnpacked {\n+            a: 17,\n+            b: Packed { x: 18, y: 19, z: 20 },\n+            c: 21,\n+            d: Packed { x: 22, y: 23, z: 24 }\n+        },\n+        d: PackedInUnpackedWithDrop {\n+            a: 25,\n+            b: Packed { x: 26, y: 27, z: 28 },\n+            c: 29,\n+            d: Packed { x: 30, y: 31, z: 32 }\n+        },\n+        e: UnpackedInPacked {\n+            a: 33,\n+            b: Unpacked { x: 34, y: 35, z: 36 },\n+            c: Unpacked { x: 37, y: 38, z: 39 },\n+            d: 40\n+        },\n+        f: PackedInPackedWithDrop {\n+            a: 41,\n+            b: Packed { x: 42, y: 43, z: 44 },\n+            c: 45,\n+            d: Packed { x: 46, y: 47, z: 48 }\n+        }\n+    };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "859166cb023a3a6d424a70edd96e6ceac22c101a", "filename": "src/test/debug-info/packed-struct.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fpacked-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fpacked-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fpacked-struct.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print packed\n+// check:$1 = {x = 123, y = 234, z = 345}\n+\n+// debugger:print packedInPacked\n+// check:$2 = {a = 1111, b = {x = 2222, y = 3333, z = 4444}, c = 5555, d = {x = 6666, y = 7777, z = 8888}}\n+\n+// debugger:print packedInUnpacked\n+// check:$3 = {a = -1111, b = {x = -2222, y = -3333, z = -4444}, c = -5555, d = {x = -6666, y = -7777, z = -8888}}\n+\n+// debugger:print unpackedInPacked\n+// check:$4 = {a = 987, b = {x = 876, y = 765, z = 654, w = 543}, c = {x = 432, y = 321, z = 210, w = 109}, d = -98}\n+\n+// debugger:print sizeof(packed)\n+// check:$5 = 14\n+\n+// debugger:print sizeof(packedInPacked)\n+// check:$6 = 40\n+\n+#[packed]\n+struct Packed {\n+    x: i16,\n+    y: i32,\n+    z: i64\n+}\n+\n+#[packed]\n+struct PackedInPacked {\n+    a: i32,\n+    b: Packed,\n+    c: i64,\n+    d: Packed\n+}\n+\n+// layout (64 bit): aaaa bbbb bbbb bbbb bb.. .... cccc cccc dddd dddd dddd dd..\n+struct PackedInUnpacked {\n+    a: i32,\n+    b: Packed,\n+    c: i64,\n+    d: Packed\n+}\n+\n+// layout (64 bit): xx.. yyyy zz.. .... wwww wwww\n+struct Unpacked {\n+    x: i16,\n+    y: i32,\n+    z: i16,\n+    w: i64\n+}\n+\n+// layout (64 bit): aabb bbbb bbbb bbbb bbbb bbbb bbcc cccc cccc cccc cccc cccc ccdd dddd dd\n+#[packed]\n+struct UnpackedInPacked {\n+    a: i16,\n+    b: Unpacked,\n+    c: Unpacked,\n+    d: i64\n+}\n+\n+fn main() {\n+    let packed = Packed { x: 123, y: 234, z: 345 };\n+\n+    let packedInPacked = PackedInPacked {\n+        a: 1111,\n+        b: Packed { x: 2222, y: 3333, z: 4444 },\n+        c: 5555,\n+        d: Packed { x: 6666, y: 7777, z: 8888 }\n+    };\n+\n+    let packedInUnpacked = PackedInUnpacked {\n+        a: -1111,\n+        b: Packed { x: -2222, y: -3333, z: -4444 },\n+        c: -5555,\n+        d: Packed { x: -6666, y: -7777, z: -8888 }\n+    };\n+\n+    let unpackedInPacked = UnpackedInPacked {\n+        a: 987,\n+        b: Unpacked { x: 876, y: 765, z: 654, w: 543 },\n+        c: Unpacked { x: 432, y: 321, z: 210, w: 109 },\n+        d: -98\n+    };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "f45294221af1686a84f4bf383e883ad95417aa3a", "filename": "src/test/debug-info/simple-tuple.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -35,15 +35,15 @@\n \n \n fn main() {\n-    let noPadding8 : (i8, u8) = (-100, 100);\n-    let noPadding16 : (i16, i16, u16) = (0, 1, 2);\n-    let noPadding32 : (i32, f32, u32) = (3, 4.5, 5);\n-    let noPadding64 : (i64, f64, u64) = (6, 7.5, 8);\n+    let noPadding8: (i8, u8) = (-100, 100);\n+    let noPadding16: (i16, i16, u16) = (0, 1, 2);\n+    let noPadding32: (i32, f32, u32) = (3, 4.5, 5);\n+    let noPadding64: (i64, f64, u64) = (6, 7.5, 8);\n \n-    let internalPadding1 : (i16, i32) = (9, 10);\n-    let internalPadding2 : (i16, i32, u32, u64) = (11, 12, 13, 14);\n+    let internalPadding1: (i16, i32) = (9, 10);\n+    let internalPadding2: (i16, i32, u32, u64) = (11, 12, 13, 14);\n \n-    let paddingAtEnd : (i32, i16) = (15, 16);\n+    let paddingAtEnd: (i32, i16) = (15, 16);\n \n     zzz();\n }"}, {"sha": "1002266a1a98539c8cf18ab7b9aefee74233d05c", "filename": "src/test/debug-info/struct-in-enum.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fstruct-in-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fstruct-in-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct-in-enum.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print union on\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print case1\n+// check:$1 = {{Case1, 0, {x = 2088533116, y = 2088533116, z = 31868}}, {Case1, 0, 8970181431921507452, 31868}}\n+\n+// debugger:print case2\n+// check:$2 = {{Case2, 0, {x = 286331153, y = 286331153, z = 4369}}, {Case2, 0, 1229782938247303441, 4369}}\n+\n+// debugger:print univariant\n+// check:$3 = {{x = 123, y = 456, z = 789}}\n+\n+struct Struct {\n+\tx: u32,\n+\ty: i32,\n+\tz: i16\n+}\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular {\n+    Case1(u64, Struct),\n+    Case2(u64, u64, i16)\n+}\n+\n+enum Univariant {\n+\tTheOnlyCase(Struct)\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianess trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1 = Case1(0, Struct { x: 2088533116, y: 2088533116, z: 31868 });\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2 = Case2(0, 1229782938247303441, 4369);\n+\n+    let univariant = TheOnlyCase(Struct { x: 123, y: 456, z: 789 });\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}"}, {"sha": "61bbd2e215ff6933b138f9c40ac4b7a318e40a0e", "filename": "src/test/debug-info/struct-style-enum.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fstruct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fstruct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct-style-enum.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print union on\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print case1\n+// check:$1 = {{Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {Case1, a = 0, b = 2088533116, c = 2088533116}, {Case1, a = 0, b = 8970181431921507452}}\n+\n+// debugger:print case2\n+// check:$2 = {{Case2, a = 0, b = 4369, c = 4369, d = 4369, e = 4369}, {Case2, a = 0, b = 286331153, c = 286331153}, {Case2, a = 0, b = 1229782938247303441}}\n+\n+// debugger:print case3\n+// check:$3 = {{Case3, a = 0, b = 22873, c = 22873, d = 22873, e = 22873}, {Case3, a = 0, b = 1499027801, c = 1499027801}, {Case3, a = 0, b = 6438275382588823897}}\n+\n+// debugger:print univariant\n+// check:$4 = {a = -1}\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular {\n+    Case1 { a: u64, b: u16, c: u16, d: u16, e: u16},\n+    Case2 { a: u64, b: u32, c: u32},\n+    Case3 { a: u64, b: u64 }\n+}\n+\n+enum Univariant {\n+    TheOnlyCase { a: i64 }\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianess trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1 = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 };\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2 = Case2 { a: 0, b: 286331153, c: 286331153 };\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3 = Case3 { a: 0, b: 6438275382588823897 };\n+\n+    let univariant = TheOnlyCase { a: -1 };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "0719f64b2564f03803e711882c625b554b653307", "filename": "src/test/debug-info/struct-with-destructor.rs", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n@@ -23,18 +23,21 @@\n // debugger:print withDestructor\n // check:$3 = {a = {x = 10, y = 20}, guard = -1}\n \n+// debugger:print nested\n+// check:$4 = {a = {a = {x = 7890, y = 9870}}}\n+\n struct NoDestructor {\n-    x : i32,\n-    y : i64\n+    x: i32,\n+    y: i64\n }\n \n struct WithDestructor {\n-    x : i32,\n-    y : i64\n+    x: i32,\n+    y: i64\n }\n \n impl Drop for WithDestructor {\n-    fn finalize(&self) {}\n+    fn drop(&self) {}\n }\n \n struct NoDestructorGuarded {\n@@ -47,6 +50,18 @@ struct WithDestructorGuarded {\n     guard: i64\n }\n \n+struct NestedInner {\n+    a: WithDestructor\n+}\n+\n+impl Drop for NestedInner {\n+    fn drop(&self) {}\n+}\n+\n+struct NestedOuter {\n+    a: NestedInner\n+}\n+\n \n // The compiler adds a 'destructed' boolean field to structs implementing Drop. This field is used\n // at runtime to prevent drop() to be executed more than once (see middle::trans::adt).\n@@ -65,6 +80,8 @@ fn main() {\n     // then the debugger will have an invalid offset for the field 'guard' and thus should not be\n     // able to read its value correctly (dots are padding bytes, D is the boolean destructor flag):\n     //\n+    // 64 bit\n+    //\n     // NoDestructorGuarded = 0000....00000000FFFFFFFF\n     //                       <--------------><------>\n     //                         NoDestructor   guard\n@@ -77,11 +94,31 @@ fn main() {\n     //                         <----------------------><------>  // How it actually is\n     //                              WithDestructor      guard\n     //\n+    // 32 bit\n+    //\n+    // NoDestructorGuarded = 000000000000FFFFFFFF\n+    //                       <----------><------>\n+    //                       NoDestructor guard\n+    //\n+    //\n+    // withDestructorGuarded = 000000000000D...FFFFFFFF\n+    //                         <----------><------>      // How debug info says it is\n+    //                      WithDestructor  guard\n+    //\n+    //                         <--------------><------>  // How it actually is\n+    //                          WithDestructor  guard\n+    //\n     let withDestructor = WithDestructorGuarded {\n         a: WithDestructor { x: 10, y: 20 },\n         guard: -1\n     };\n \n+    // expected layout (64 bit) = xxxx....yyyyyyyyD.......D...\n+    //                            <--WithDestructor------>\n+    //                            <-------NestedInner-------->\n+    //                            <-------NestedOuter-------->\n+    let nested = NestedOuter { a: NestedInner { a: WithDestructor { x: 7890, y: 9870 } } };\n+\n     zzz();\n }\n "}, {"sha": "9c6805dae67d37721390fbf53ae8f0d7cf8d8265", "filename": "src/test/debug-info/tuple-in-tuple.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Ftuple-in-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Ftuple-in-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftuple-in-tuple.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -34,15 +34,15 @@\n // check:$7 = {{21, 22}, 23}\n \n fn main() {\n-    let no_padding1 : ((u32, u32), u32, u32) = ((0, 1), 2, 3);\n-    let no_padding2 : (u32, (u32, u32), u32) = (4, (5, 6), 7);\n-    let no_padding3 : (u32, u32, (u32, u32)) = (8, 9, (10, 11));\n+    let no_padding1: ((u32, u32), u32, u32) = ((0, 1), 2, 3);\n+    let no_padding2: (u32, (u32, u32), u32) = (4, (5, 6), 7);\n+    let no_padding3: (u32, u32, (u32, u32)) = (8, 9, (10, 11));\n \n-    let internal_padding1 : (i16, (i32, i32)) = (12, (13, 14));\n-    let internal_padding2 : (i16, (i16, i32)) = (15, (16, 17));\n+    let internal_padding1: (i16, (i32, i32)) = (12, (13, 14));\n+    let internal_padding2: (i16, (i16, i32)) = (15, (16, 17));\n \n-    let padding_at_end1 : (i32, (i32, i16)) = (18, (19, 20));\n-    let padding_at_end2 : ((i32, i16), i32) = ((21, 22), 23);\n+    let padding_at_end1: (i32, (i32, i16)) = (18, (19, 20));\n+    let padding_at_end2: ((i32, i16), i32) = ((21, 22), 23);\n \n     zzz();\n }"}, {"sha": "ba1d02bb62a3c6cbcbf7417a0af3057496750eb6", "filename": "src/test/debug-info/tuple-style-enum.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Ftuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Ftuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftuple-style-enum.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print union on\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print case1\n+// check:$1 = {{Case1, 0, 31868, 31868, 31868, 31868}, {Case1, 0, 2088533116, 2088533116}, {Case1, 0, 8970181431921507452}}\n+\n+// debugger:print case2\n+// check:$2 = {{Case2, 0, 4369, 4369, 4369, 4369}, {Case2, 0, 286331153, 286331153}, {Case2, 0, 1229782938247303441}}\n+\n+// debugger:print case3\n+// check:$3 = {{Case3, 0, 22873, 22873, 22873, 22873}, {Case3, 0, 1499027801, 1499027801}, {Case3, 0, 6438275382588823897}}\n+\n+// debugger:print univariant\n+// check:$4 = {-1}\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular {\n+    Case1(u64, u16, u16, u16, u16),\n+    Case2(u64, u32, u32),\n+    Case3(u64, u64)\n+}\n+\n+enum Univariant {\n+\tTheOnlyCase(i64)\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianess trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1 = Case1(0, 31868, 31868, 31868, 31868);\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2 = Case2(0, 286331153, 286331153);\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3 = Case3(0, 6438275382588823897);\n+\n+    let univariant = TheOnlyCase(-1);\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "443f641a858592d10773597f7582b92f7b6a9dc3", "filename": "src/test/debug-info/unique-enum.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Funique-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Funique-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Funique-enum.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print *the_a\n+// check:$1 = {{TheA, x = 0, y = 8970181431921507452}, {TheA, 0, 2088533116, 2088533116}}\n+\n+// debugger:print *the_b\n+// check:$2 = {{TheB, x = 0, y = 1229782938247303441}, {TheB, 0, 286331153, 286331153}}\n+\n+// debugger:print *univariant\n+// check:$3 = {123234}\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum ABC {\n+\tTheA { x: i64, y: i64 },\n+\tTheB (i64, i32, i32),\n+}\n+\n+// This is a special case since it does not have the implicit discriminant field.\n+enum Univariant {\n+    TheOnlyCase(i64)\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianess trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+\t// 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+\t// 0b01111100011111000111110001111100 = 2088533116\n+\t// 0b0111110001111100 = 31868\n+\t// 0b01111100 = 124\n+    let the_a = ~TheA { x: 0, y: 8970181431921507452 };\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let the_b = ~TheB (0, 286331153, 286331153);\n+\n+    let univariant = ~TheOnlyCase(123234);\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "4691de049172136c9313c43dbb13ab7f2c2a5fe3", "filename": "src/test/debug-info/vec-slices.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvec-slices.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+// debugger:print empty.size_in_bytes\n+// check:$1 = 0\n+\n+// debugger:print singleton.size_in_bytes\n+// check:$2 = 8\n+// debugger:print *((int64_t[1]*)(singleton.data_ptr))\n+// check:$3 = {1}\n+\n+// debugger:print multiple.size_in_bytes\n+// check:$4 = 32\n+// debugger:print *((int64_t[4]*)(multiple.data_ptr))\n+// check:$5 = {2, 3, 4, 5}\n+\n+// debugger:print slice_of_slice.size_in_bytes\n+// check:$6 = 16\n+// debugger:print *((int64_t[2]*)(slice_of_slice.data_ptr))\n+// check:$7 = {3, 4}\n+\n+// debugger:print padded_tuple.size_in_bytes\n+// check:$8 = 16\n+// debugger:print padded_tuple.data_ptr[0]\n+// check:$9 = {6, 7}\n+// debugger:print padded_tuple.data_ptr[1]\n+// check:$10 = {8, 9}\n+\n+// debugger:print padded_struct.size_in_bytes\n+// check:$11 = 24\n+// debugger:print padded_struct.data_ptr[0]\n+// check:$12 = {x = 10, y = 11, z = 12}\n+// debugger:print padded_struct.data_ptr[1]\n+// check:$13 = {x = 13, y = 14, z = 15}\n+\n+struct AStruct {\n+    x: i16,\n+    y: i32,\n+    z: i16\n+}\n+\n+fn main() {\n+    let empty: &[i64] = &[];\n+    let singleton: &[i64] = &[1];\n+    let multiple: &[i64] = &[2, 3, 4, 5];\n+    let slice_of_slice = multiple.slice(1,3);\n+\n+    let padded_tuple: &[(i32, i16)] = &[(6, 7), (8, 9)];\n+\n+    let padded_struct: &[AStruct] = &[\n+        AStruct { x: 10, y: 11, z: 12 },\n+        AStruct { x: 13, y: 14, z: 15 }\n+    ];\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}"}, {"sha": "57130b45eae303be66e0f13aee07517150ff46fb", "filename": "src/test/debug-info/vec.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Fdebug-info%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvec.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -8,28 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n // compile-flags:-Z extra-debug-info\n // debugger:set print pretty off\n-// debugger:break _zzz\n+// debugger:break zzz\n // debugger:run\n // debugger:finish\n // debugger:print a\n // check:$1 = {1, 2, 3}\n-// debugger:print b.vec[0]\n-// check:$2 = 4\n-// debugger:print c->boxed.data[1]\n-// check:$3 = 8\n-// debugger:print d->boxed.data[2]\n-// check:$4 = 12\n \n fn main() {\n     let a = [1, 2, 3];\n-    let b = &[4, 5, 6];\n-    let c = @[7, 8, 9];\n-    let d = ~[10, 11, 12];\n-    _zzz();\n+\n+    zzz();\n }\n \n-fn _zzz() {()}\n+fn zzz() {()}"}, {"sha": "d4faae415d2021e0ee17157644e601df0351fcc1", "filename": "src/test/run-pass/issue-7712.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Frun-pass%2Fissue-7712.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aae6edce09a8e2a32a154acb55c9879dbebf99c/src%2Ftest%2Frun-pass%2Fissue-7712.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7712.rs?ref=8aae6edce09a8e2a32a154acb55c9879dbebf99c", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z debug-info\n+\n+#[allow(default_methods)];\n+\n+pub trait TraitWithDefaultMethod {\n+    pub fn method(self) {\n+        ()\n+    }\n+}\n+\n+struct MyStruct;\n+\n+impl TraitWithDefaultMethod for MyStruct { }\n+\n+fn main() {\n+    MyStruct.method();\n+}\n\\ No newline at end of file"}]}