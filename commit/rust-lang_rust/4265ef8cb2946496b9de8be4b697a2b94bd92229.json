{"sha": "4265ef8cb2946496b9de8be4b697a2b94bd92229", "node_id": "C_kwDOAAsO6NoAKDQyNjVlZjhjYjI5NDY0OTZiOWRlOGJlNGI2OTdhMmI5NGJkOTIyMjk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-31T04:41:16Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-09T01:31:44Z"}, "message": "Implement projection for ImplTraitPlaceholder", "tree": {"sha": "a94e6c4a7001fb2e1cfdf57778c122f241ee9c42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a94e6c4a7001fb2e1cfdf57778c122f241ee9c42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4265ef8cb2946496b9de8be4b697a2b94bd92229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4265ef8cb2946496b9de8be4b697a2b94bd92229", "html_url": "https://github.com/rust-lang/rust/commit/4265ef8cb2946496b9de8be4b697a2b94bd92229", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4265ef8cb2946496b9de8be4b697a2b94bd92229/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d34cb98fb0bbaf86860b4ad5ff0c3d79b077f565", "url": "https://api.github.com/repos/rust-lang/rust/commits/d34cb98fb0bbaf86860b4ad5ff0c3d79b077f565", "html_url": "https://github.com/rust-lang/rust/commit/d34cb98fb0bbaf86860b4ad5ff0c3d79b077f565"}], "stats": {"total": 121, "additions": 120, "deletions": 1}, "files": [{"sha": "3657fb2134048b3d305f3e7290c5095f2ecc351f", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4265ef8cb2946496b9de8be4b697a2b94bd92229/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4265ef8cb2946496b9de8be4b697a2b94bd92229/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=4265ef8cb2946496b9de8be4b697a2b94bd92229", "patch": "@@ -2038,7 +2038,9 @@ fn local_visibility(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Visibility {\n                 //   Visibility on them should have no effect, but to avoid the visibility\n                 //   query failing on some items, we provide it for opaque types as well.\n                 | Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Use(_, hir::UseKind::ListStem) | hir::ItemKind::OpaqueTy(..),\n+                    kind: hir::ItemKind::Use(_, hir::UseKind::ListStem)\n+                        | hir::ItemKind::OpaqueTy(..)\n+                        | hir::ItemKind::ImplTraitPlaceholder(..),\n                     ..\n                 }) => ty::Visibility::Restricted(tcx.parent_module(hir_id)),\n                 // Visibilities of trait impl items are inherited from their traits"}, {"sha": "6ccb91c8cab692448184cc013725f71de10cac36", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/4265ef8cb2946496b9de8be4b697a2b94bd92229/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4265ef8cb2946496b9de8be4b697a2b94bd92229/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=4265ef8cb2946496b9de8be4b697a2b94bd92229", "patch": "@@ -32,6 +32,7 @@ use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::visit::{MaxUniverse, TypeVisitable};\n+use rustc_middle::ty::DefIdTree;\n use rustc_middle::ty::{self, Term, ToPredicate, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n \n@@ -70,6 +71,8 @@ enum ProjectionCandidate<'tcx> {\n \n     /// From an \"impl\" (or a \"pseudo-impl\" returned by select)\n     Select(Selection<'tcx>),\n+\n+    ImplTraitInTrait(ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>>),\n }\n \n enum ProjectionCandidateSet<'tcx> {\n@@ -1265,6 +1268,8 @@ fn project<'cx, 'tcx>(\n \n     let mut candidates = ProjectionCandidateSet::None;\n \n+    assemble_candidate_for_impl_trait_in_trait(selcx, obligation, &mut candidates);\n+\n     // Make sure that the following procedures are kept in order. ParamEnv\n     // needs to be first because it has highest priority, and Select checks\n     // the return value of push_candidate which assumes it's ran at last.\n@@ -1303,6 +1308,48 @@ fn project<'cx, 'tcx>(\n     }\n }\n \n+/// The first thing we have to do is scan through the parameter\n+/// environment to see whether there are any projection predicates\n+/// there that can answer this question.\n+fn assemble_candidate_for_impl_trait_in_trait<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    candidate_set: &mut ProjectionCandidateSet<'tcx>,\n+) {\n+    let tcx = selcx.tcx();\n+    if tcx.def_kind(obligation.predicate.item_def_id) == DefKind::ImplTraitPlaceholder {\n+        let trait_fn_def_id = tcx.parent(obligation.predicate.item_def_id);\n+        let trait_def_id = tcx.parent(trait_fn_def_id);\n+        let trait_substs =\n+            obligation.predicate.substs.truncate_to(tcx, tcx.generics_of(trait_def_id));\n+        // FIXME(named-returns): Binders\n+        let trait_predicate =\n+            ty::Binder::dummy(ty::TraitRef { def_id: trait_def_id, substs: trait_substs })\n+                .to_poly_trait_predicate();\n+\n+        let _ =\n+            selcx.infcx().commit_if_ok(|_| match selcx.select(&obligation.with(trait_predicate)) {\n+                Ok(Some(super::ImplSource::UserDefined(data))) => {\n+                    candidate_set.push_candidate(ProjectionCandidate::ImplTraitInTrait(data));\n+                    Ok(())\n+                }\n+                Ok(None) => {\n+                    candidate_set.mark_ambiguous();\n+                    return Err(());\n+                }\n+                Ok(Some(_)) => {\n+                    // Don't know enough about the impl to provide a useful signature\n+                    return Err(());\n+                }\n+                Err(e) => {\n+                    debug!(error = ?e, \"selection error\");\n+                    candidate_set.mark_error(e);\n+                    return Err(());\n+                }\n+            });\n+    }\n+}\n+\n /// The first thing we have to do is scan through the parameter\n /// environment to see whether there are any projection predicates\n /// there that can answer this question.\n@@ -1745,6 +1792,9 @@ fn confirm_candidate<'cx, 'tcx>(\n         ProjectionCandidate::Select(impl_source) => {\n             confirm_select_candidate(selcx, obligation, impl_source)\n         }\n+        ProjectionCandidate::ImplTraitInTrait(data) => {\n+            confirm_impl_trait_in_trait_candidate(selcx, obligation, data)\n+        }\n     };\n \n     // When checking for cycle during evaluation, we compare predicates with\n@@ -2107,6 +2157,73 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     }\n }\n \n+fn confirm_impl_trait_in_trait_candidate<'tcx>(\n+    selcx: &mut SelectionContext<'_, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    data: ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n+    let tcx = selcx.tcx();\n+    let mut obligations = data.nested;\n+\n+    let trait_fn_def_id = tcx.parent(obligation.predicate.item_def_id);\n+    let Ok(leaf_def) = assoc_def(selcx, data.impl_def_id, trait_fn_def_id) else {\n+        return Progress { term: tcx.ty_error().into(), obligations };\n+    };\n+    if !leaf_def.item.defaultness(tcx).has_value() {\n+        return Progress { term: tcx.ty_error().into(), obligations };\n+    }\n+\n+    let impl_fn_def_id = leaf_def.item.def_id;\n+    let impl_fn_substs = obligation.predicate.substs.rebase_onto(tcx, trait_fn_def_id, data.substs);\n+\n+    let sig = tcx\n+        .bound_fn_sig(impl_fn_def_id)\n+        .map_bound(|fn_sig| tcx.liberate_late_bound_regions(impl_fn_def_id, fn_sig))\n+        .subst(tcx, impl_fn_substs);\n+\n+    let cause = ObligationCause::new(\n+        obligation.cause.span,\n+        obligation.cause.body_id,\n+        super::ItemObligation(impl_fn_def_id),\n+    );\n+    let predicates = normalize_with_depth_to(\n+        selcx,\n+        obligation.param_env,\n+        cause.clone(),\n+        obligation.recursion_depth + 1,\n+        tcx.predicates_of(impl_fn_def_id).instantiate(tcx, impl_fn_substs),\n+        &mut obligations,\n+    );\n+    obligations.extend(std::iter::zip(predicates.predicates, predicates.spans).map(\n+        |(pred, span)| {\n+            Obligation::with_depth(\n+                ObligationCause::new(\n+                    obligation.cause.span,\n+                    obligation.cause.body_id,\n+                    if span.is_dummy() {\n+                        super::ItemObligation(impl_fn_def_id)\n+                    } else {\n+                        super::BindingObligation(impl_fn_def_id, span)\n+                    },\n+                ),\n+                obligation.recursion_depth + 1,\n+                obligation.param_env,\n+                pred,\n+            )\n+        },\n+    ));\n+\n+    let ty = super::normalize_to(\n+        selcx,\n+        obligation.param_env,\n+        cause.clone(),\n+        sig.output(),\n+        &mut obligations,\n+    );\n+\n+    Progress { term: ty.into(), obligations }\n+}\n+\n // Get obligations corresponding to the predicates from the where-clause of the\n // associated type itself.\n // Note: `feature(generic_associated_types)` is required to write such"}]}