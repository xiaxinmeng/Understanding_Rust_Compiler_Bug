{"sha": "7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNmViNjdmMGQ1Y2NkZmYzZGM5OGE1YzY3ZWIwYWM3Yjk4YTNhYTE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-10T12:39:56Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-10T12:39:56Z"}, "message": "Substitute generic types in inline_call", "tree": {"sha": "a713388586398da81d01eb7f5526ec0a916a38ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a713388586398da81d01eb7f5526ec0a916a38ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1", "html_url": "https://github.com/rust-lang/rust/commit/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2246fecef40fb86806fbe440df3b1eeb19a0f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2246fecef40fb86806fbe440df3b1eeb19a0f34", "html_url": "https://github.com/rust-lang/rust/commit/f2246fecef40fb86806fbe440df3b1eeb19a0f34"}], "stats": {"total": 154, "additions": 115, "deletions": 39}, "files": [{"sha": "90d83501f2ca486d73155e74d4b24729f4d8bd60", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1", "patch": "@@ -1,6 +1,6 @@\n use ast::make;\n use hir::{HasSource, PathResolution, TypeInfo};\n-use ide_db::{defs::Definition, search::FileReference};\n+use ide_db::{defs::Definition, path_transform::PathTransform, search::FileReference};\n use itertools::izip;\n use syntax::{\n     ast::{self, edit::AstNodeEdit, ArgListOwner},\n@@ -34,7 +34,7 @@ use crate::{\n // }\n // ```\n pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let (label, function, arguments, expr) =\n+    let (label, function, arguments, generic_arg_list, expr) =\n         if let Some(path_expr) = ctx.find_node_at_offset::<ast::PathExpr>() {\n             let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n             let path = path_expr.path()?;\n@@ -48,6 +48,7 @@ pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n                 format!(\"Inline `{}`\", path),\n                 function,\n                 call.arg_list()?.args().collect(),\n+                path.segment().and_then(|it| it.generic_arg_list()),\n                 ast::Expr::CallExpr(call),\n             )\n         } else {\n@@ -57,10 +58,16 @@ pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n             let function = ctx.sema.resolve_method_call(&call)?;\n             let mut arguments = vec![receiver];\n             arguments.extend(call.arg_list()?.args());\n-            (format!(\"Inline `{}`\", name_ref), function, arguments, ast::Expr::MethodCallExpr(call))\n+            (\n+                format!(\"Inline `{}`\", name_ref),\n+                function,\n+                arguments,\n+                call.generic_arg_list(),\n+                ast::Expr::MethodCallExpr(call),\n+            )\n         };\n \n-    inline_(acc, ctx, label, function, arguments, expr)\n+    inline_(acc, ctx, label, function, arguments, expr, generic_arg_list)\n }\n \n pub(crate) fn inline_(\n@@ -70,6 +77,7 @@ pub(crate) fn inline_(\n     function: hir::Function,\n     arg_list: Vec<ast::Expr>,\n     expr: ast::Expr,\n+    generic_arg_list: Option<ast::GenericArgList>,\n ) -> Option<()> {\n     let hir::InFile { value: function_source, file_id } = function.source(ctx.db())?;\n     let param_list = function_source.param_list()?;\n@@ -100,14 +108,14 @@ pub(crate) fn inline_(\n         return None;\n     }\n \n-    let body = function_source.body()?;\n+    let fn_body = function_source.body()?;\n \n     acc.add(\n         AssistId(\"inline_call\", AssistKind::RefactorInline),\n         label,\n         expr.syntax().text_range(),\n         |builder| {\n-            let body = body.clone_for_update();\n+            let body = fn_body.clone_for_update();\n \n             let file_id = file_id.original_file(ctx.sema.db);\n             let usages_for_locals = |local| {\n@@ -198,6 +206,15 @@ pub(crate) fn inline_(\n                     }\n                 }\n             }\n+            if let Some(generic_arg_list) = generic_arg_list {\n+                PathTransform::function_call(\n+                    &ctx.sema.scope(expr.syntax()),\n+                    &ctx.sema.scope(fn_body.syntax()),\n+                    function,\n+                    generic_arg_list,\n+                )\n+                .apply(body.syntax());\n+            }\n \n             let original_indentation = expr.indent_level();\n             let replacement = body.reset_indent().indent(original_indentation);\n@@ -644,6 +661,36 @@ fn main() {\n         x as u32\n     };\n }\n+\"#,\n+        );\n+    }\n+\n+    // FIXME: const generics aren't being substituted, this is blocked on better support for them\n+    #[test]\n+    fn inline_substitutes_generics() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+fn foo<T, const N: usize>() {\n+    bar::<T, N>()\n+}\n+\n+fn bar<U, const M: usize>() {}\n+\n+fn main() {\n+    foo::<usize, {0}>$0();\n+}\n+\"#,\n+            r#\"\n+fn foo<T, const N: usize>() {\n+    bar::<T, N>()\n+}\n+\n+fn bar<U, const M: usize>() {}\n+\n+fn main() {\n+    bar::<usize, N>();\n+}\n \"#,\n         );\n     }"}, {"sha": "a4e4a00f78d3d4a1916dfa738d0ea146fff24593", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1", "patch": "@@ -129,15 +129,11 @@ pub fn add_trait_assoc_items_to_impl(\n ) -> (ast::Impl, ast::AssocItem) {\n     let source_scope = sema.scope_for_def(trait_);\n \n-    let transform = PathTransform {\n-        subst: (trait_, impl_.clone()),\n-        source_scope: &source_scope,\n-        target_scope: &target_scope,\n-    };\n+    let transform = PathTransform::trait_impl(&target_scope, &source_scope, trait_, impl_.clone());\n \n     let items = items.into_iter().map(|assoc_item| {\n         let assoc_item = assoc_item.clone_for_update();\n-        transform.apply(assoc_item.clone());\n+        transform.apply(assoc_item.syntax());\n         edit::remove_attrs_and_docs(&assoc_item).clone_subtree().clone_for_update()\n     });\n "}, {"sha": "75b02583bf211aa5eb17202f393c243755a95f3f", "filename": "crates/ide_completion/src/completions/trait_impl.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1", "patch": "@@ -186,13 +186,14 @@ fn get_transformed_assoc_item(\n     let trait_ = impl_def.trait_(ctx.db)?;\n     let source_scope = &ctx.sema.scope_for_def(trait_);\n     let target_scope = &ctx.sema.scope(impl_def.source(ctx.db)?.syntax().value);\n-    let transform = PathTransform {\n-        subst: (trait_, impl_def.source(ctx.db)?.value),\n-        source_scope,\n+    let transform = PathTransform::trait_impl(\n         target_scope,\n-    };\n+        source_scope,\n+        trait_,\n+        impl_def.source(ctx.db)?.value,\n+    );\n \n-    transform.apply(assoc_item.clone());\n+    transform.apply(assoc_item.syntax());\n     Some(match assoc_item {\n         ast::AssocItem::Fn(func) => ast::AssocItem::Fn(edit::remove_attrs_and_docs(&func)),\n         _ => assoc_item,"}, {"sha": "b8b1307a3c09c5443e90f829e8985d80bbee99ef", "filename": "crates/ide_db/src/path_transform.rs", "status": "modified", "additions": 54, "deletions": 22, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fpath_transform.rs?ref=7e6eb67f0d5ccdff3dc98a5c67eb0ac7b98a3aa1", "patch": "@@ -5,7 +5,7 @@ use hir::{HirDisplay, SemanticsScope};\n use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, AstNode},\n-    ted,\n+    ted, SyntaxNode,\n };\n \n /// `PathTransform` substitutes path in SyntaxNodes in bulk.\n@@ -32,38 +32,70 @@ use syntax::{\n /// }\n /// ```\n pub struct PathTransform<'a> {\n-    pub subst: (hir::Trait, ast::Impl),\n-    pub target_scope: &'a SemanticsScope<'a>,\n-    pub source_scope: &'a SemanticsScope<'a>,\n+    generic_def: hir::GenericDef,\n+    substs: Vec<ast::Type>,\n+    target_scope: &'a SemanticsScope<'a>,\n+    source_scope: &'a SemanticsScope<'a>,\n }\n \n impl<'a> PathTransform<'a> {\n-    pub fn apply(&self, item: ast::AssocItem) {\n+    pub fn trait_impl(\n+        target_scope: &'a SemanticsScope<'a>,\n+        source_scope: &'a SemanticsScope<'a>,\n+        trait_: hir::Trait,\n+        impl_: ast::Impl,\n+    ) -> PathTransform<'a> {\n+        PathTransform {\n+            source_scope,\n+            target_scope,\n+            generic_def: trait_.into(),\n+            substs: get_syntactic_substs(impl_).unwrap_or_default(),\n+        }\n+    }\n+\n+    pub fn function_call(\n+        target_scope: &'a SemanticsScope<'a>,\n+        source_scope: &'a SemanticsScope<'a>,\n+        function: hir::Function,\n+        generic_arg_list: ast::GenericArgList,\n+    ) -> PathTransform<'a> {\n+        PathTransform {\n+            source_scope,\n+            target_scope,\n+            generic_def: function.into(),\n+            substs: get_type_args_from_arg_list(generic_arg_list).unwrap_or_default(),\n+        }\n+    }\n+\n+    pub fn apply(&self, syntax: &SyntaxNode) {\n         if let Some(ctx) = self.build_ctx() {\n-            ctx.apply(item)\n+            ctx.apply(syntax)\n         }\n     }\n+\n     fn build_ctx(&self) -> Option<Ctx<'a>> {\n         let db = self.source_scope.db;\n         let target_module = self.target_scope.module()?;\n         let source_module = self.source_scope.module()?;\n-\n-        let substs = get_syntactic_substs(self.subst.1.clone()).unwrap_or_default();\n-        let generic_def: hir::GenericDef = self.subst.0.into();\n-        let substs_by_param: FxHashMap<_, _> = generic_def\n+        let skip = match self.generic_def {\n+            // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n+            hir::GenericDef::Trait(_) => 1,\n+            _ => 0,\n+        };\n+        let substs_by_param: FxHashMap<_, _> = self\n+            .generic_def\n             .type_params(db)\n             .into_iter()\n-            // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n-            .skip(1)\n+            .skip(skip)\n             // The actual list of trait type parameters may be longer than the one\n             // used in the `impl` block due to trailing default type parameters.\n             // For that case we extend the `substs` with an empty iterator so we\n             // can still hit those trailing values and check if they actually have\n             // a default type. If they do, go for that type from `hir` to `ast` so\n             // the resulting change can be applied correctly.\n-            .zip(substs.into_iter().map(Some).chain(std::iter::repeat(None)))\n+            .zip(self.substs.iter().map(Some).chain(std::iter::repeat(None)))\n             .filter_map(|(k, v)| match v {\n-                Some(v) => Some((k, v)),\n+                Some(v) => Some((k, v.clone())),\n                 None => {\n                     let default = k.default(db)?;\n                     Some((\n@@ -73,7 +105,6 @@ impl<'a> PathTransform<'a> {\n                 }\n             })\n             .collect();\n-\n         let res = Ctx { substs: substs_by_param, target_module, source_scope: self.source_scope };\n         Some(res)\n     }\n@@ -86,8 +117,8 @@ struct Ctx<'a> {\n }\n \n impl<'a> Ctx<'a> {\n-    fn apply(&self, item: ast::AssocItem) {\n-        for event in item.syntax().preorder() {\n+    fn apply(&self, item: &SyntaxNode) {\n+        for event in item.preorder() {\n             let node = match event {\n                 syntax::WalkEvent::Enter(_) => continue,\n                 syntax::WalkEvent::Leave(it) => it,\n@@ -149,13 +180,14 @@ fn get_syntactic_substs(impl_def: ast::Impl) -> Option<Vec<ast::Type>> {\n     };\n     let generic_arg_list = path_type.path()?.segment()?.generic_arg_list()?;\n \n+    get_type_args_from_arg_list(generic_arg_list)\n+}\n+\n+fn get_type_args_from_arg_list(generic_arg_list: ast::GenericArgList) -> Option<Vec<ast::Type>> {\n     let mut result = Vec::new();\n     for generic_arg in generic_arg_list.generic_args() {\n-        match generic_arg {\n-            ast::GenericArg::TypeArg(type_arg) => result.push(type_arg.ty()?),\n-            ast::GenericArg::AssocTypeArg(_)\n-            | ast::GenericArg::LifetimeArg(_)\n-            | ast::GenericArg::ConstArg(_) => (),\n+        if let ast::GenericArg::TypeArg(type_arg) = generic_arg {\n+            result.push(type_arg.ty()?)\n         }\n     }\n "}]}