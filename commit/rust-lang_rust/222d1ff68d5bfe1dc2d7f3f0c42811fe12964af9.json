{"sha": "222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "node_id": "C_kwDOAAsO6NoAKDIyMmQxZmY2OGQ1YmZlMWRjMmQ3ZjNmMGM0MjgxMWZlMTI5NjRhZjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-12T13:59:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-12T13:59:30Z"}, "message": "Auto merge of #105603 - oli-obk:non_repeatable_queries, r=petrochenkov\n\nHarden the pre-tyctxt query system against accidental recomputation\n\nWhile the current compiler has no issues where we `take` and then compute the query again, in https://github.com/rust-lang/rust/pull/105462 I accidentally introduced such a case.\n\nI also took the opportunity to remove `peek_mut`, which is only ever used for `global_tcx` to then invoke `enter`. I added an `enter` method directly on the query.", "tree": {"sha": "1a75241d0b3c0600dcb76bd03d07d9fad8f31062", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a75241d0b3c0600dcb76bd03d07d9fad8f31062"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "html_url": "https://github.com/rust-lang/rust/commit/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "606c3907251397a42e23d3e60de31be9d32525d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/606c3907251397a42e23d3e60de31be9d32525d5", "html_url": "https://github.com/rust-lang/rust/commit/606c3907251397a42e23d3e60de31be9d32525d5"}, {"sha": "58782a8842bdd74e3304092251a1d06e5b6b550b", "url": "https://api.github.com/repos/rust-lang/rust/commits/58782a8842bdd74e3304092251a1d06e5b6b550b", "html_url": "https://github.com/rust-lang/rust/commit/58782a8842bdd74e3304092251a1d06e5b6b550b"}], "stats": {"total": 141, "additions": 78, "deletions": 63}, "files": [{"sha": "9a0fd52677d13ff10e50e6f73c0e8b3f964f76ca", "filename": "compiler/rustc_data_structures/src/steal.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs?ref=222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "patch": "@@ -40,6 +40,11 @@ impl<T> Steal<T> {\n         ReadGuard::map(borrow, |opt| opt.as_ref().unwrap())\n     }\n \n+    #[track_caller]\n+    pub fn get_mut(&mut self) -> &mut T {\n+        self.value.get_mut().as_mut().expect(\"attempt to read from stolen value\")\n+    }\n+\n     #[track_caller]\n     pub fn steal(&self) -> T {\n         let value_ref = &mut *self.value.try_write().expect(\"stealing value which is locked\");"}, {"sha": "16f64235562f119d3f020e487e51a5f5b3c046fd", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "patch": "@@ -309,8 +309,8 @@ fn run_compiler(\n \n             if let Some(ppm) = &sess.opts.pretty {\n                 if ppm.needs_ast_map() {\n-                    let expanded_crate = queries.expansion()?.peek().0.clone();\n-                    queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+                    let expanded_crate = queries.expansion()?.borrow().0.clone();\n+                    queries.global_ctxt()?.enter(|tcx| {\n                         pretty::print_after_hir_lowering(\n                             tcx,\n                             compiler.input(),\n@@ -321,7 +321,7 @@ fn run_compiler(\n                         Ok(())\n                     })?;\n                 } else {\n-                    let krate = queries.parse()?.take();\n+                    let krate = queries.parse()?.steal();\n                     pretty::print_after_parsing(\n                         sess,\n                         compiler.input(),\n@@ -343,7 +343,8 @@ fn run_compiler(\n             }\n \n             {\n-                let (_, lint_store) = &*queries.register_plugins()?.peek();\n+                let plugins = queries.register_plugins()?;\n+                let (_, lint_store) = &*plugins.borrow();\n \n                 // Lint plugins are registered; now we can process command line flags.\n                 if sess.opts.describe_lints {\n@@ -371,7 +372,7 @@ fn run_compiler(\n                 return early_exit();\n             }\n \n-            queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+            queries.global_ctxt()?.enter(|tcx| {\n                 let result = tcx.analysis(());\n                 if sess.opts.unstable_opts.save_analysis {\n                     let crate_name = tcx.crate_name(LOCAL_CRATE);"}, {"sha": "041bb9eb7a1cbcd58b9239fa432b9784334fbc99", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 60, "deletions": 48, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "patch": "@@ -5,6 +5,7 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_hir::def_id::LOCAL_CRATE;\n@@ -19,43 +20,53 @@ use rustc_session::{output::find_crate_name, Session};\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n use std::any::Any;\n-use std::cell::{Ref, RefCell, RefMut};\n+use std::cell::{RefCell, RefMut};\n use std::rc::Rc;\n use std::sync::Arc;\n \n /// Represent the result of a query.\n ///\n-/// This result can be stolen with the [`take`] method and generated with the [`compute`] method.\n+/// This result can be stolen once with the [`steal`] method and generated with the [`compute`] method.\n ///\n-/// [`take`]: Self::take\n+/// [`steal`]: Steal::steal\n /// [`compute`]: Self::compute\n pub struct Query<T> {\n-    result: RefCell<Option<Result<T>>>,\n+    /// `None` means no value has been computed yet.\n+    result: RefCell<Option<Result<Steal<T>>>>,\n }\n \n impl<T> Query<T> {\n-    fn compute<F: FnOnce() -> Result<T>>(&self, f: F) -> Result<&Query<T>> {\n-        self.result.borrow_mut().get_or_insert_with(f).as_ref().map(|_| self).map_err(|&err| err)\n+    fn compute<F: FnOnce() -> Result<T>>(&self, f: F) -> Result<QueryResult<'_, T>> {\n+        RefMut::filter_map(\n+            self.result.borrow_mut(),\n+            |r: &mut Option<Result<Steal<T>>>| -> Option<&mut Steal<T>> {\n+                r.get_or_insert_with(|| f().map(Steal::new)).as_mut().ok()\n+            },\n+        )\n+        .map_err(|r| *r.as_ref().unwrap().as_ref().map(|_| ()).unwrap_err())\n+        .map(QueryResult)\n     }\n+}\n+\n+pub struct QueryResult<'a, T>(RefMut<'a, Steal<T>>);\n+\n+impl<'a, T> std::ops::Deref for QueryResult<'a, T> {\n+    type Target = RefMut<'a, Steal<T>>;\n \n-    /// Takes ownership of the query result. Further attempts to take or peek the query\n-    /// result will panic unless it is generated by calling the `compute` method.\n-    pub fn take(&self) -> T {\n-        self.result.borrow_mut().take().expect(\"missing query result\").unwrap()\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n     }\n+}\n \n-    /// Borrows the query result using the RefCell. Panics if the result is stolen.\n-    pub fn peek(&self) -> Ref<'_, T> {\n-        Ref::map(self.result.borrow(), |r| {\n-            r.as_ref().unwrap().as_ref().expect(\"missing query result\")\n-        })\n+impl<'a, T> std::ops::DerefMut for QueryResult<'a, T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n     }\n+}\n \n-    /// Mutably borrows the query result using the RefCell. Panics if the result is stolen.\n-    pub fn peek_mut(&self) -> RefMut<'_, T> {\n-        RefMut::map(self.result.borrow_mut(), |r| {\n-            r.as_mut().unwrap().as_mut().expect(\"missing query result\")\n-        })\n+impl<'a, 'tcx> QueryResult<'a, QueryContext<'tcx>> {\n+    pub fn enter<T>(mut self, f: impl FnOnce(TyCtxt<'tcx>) -> T) -> T {\n+        (*self.0).get_mut().enter(f)\n     }\n }\n \n@@ -111,24 +122,24 @@ impl<'tcx> Queries<'tcx> {\n         self.compiler.codegen_backend()\n     }\n \n-    fn dep_graph_future(&self) -> Result<&Query<Option<DepGraphFuture>>> {\n+    fn dep_graph_future(&self) -> Result<QueryResult<'_, Option<DepGraphFuture>>> {\n         self.dep_graph_future.compute(|| {\n             let sess = self.session();\n             Ok(sess.opts.build_dep_graph().then(|| rustc_incremental::load_dep_graph(sess)))\n         })\n     }\n \n-    pub fn parse(&self) -> Result<&Query<ast::Crate>> {\n+    pub fn parse(&self) -> Result<QueryResult<'_, ast::Crate>> {\n         self.parse.compute(|| {\n             passes::parse(self.session(), &self.compiler.input)\n                 .map_err(|mut parse_error| parse_error.emit())\n         })\n     }\n \n-    pub fn register_plugins(&self) -> Result<&Query<(ast::Crate, Lrc<LintStore>)>> {\n+    pub fn register_plugins(&self) -> Result<QueryResult<'_, (ast::Crate, Lrc<LintStore>)>> {\n         self.register_plugins.compute(|| {\n-            let crate_name = *self.crate_name()?.peek();\n-            let krate = self.parse()?.take();\n+            let crate_name = *self.crate_name()?.borrow();\n+            let krate = self.parse()?.steal();\n \n             let empty: &(dyn Fn(&Session, &mut LintStore) + Sync + Send) = &|_, _| {};\n             let (krate, lint_store) = passes::register_plugins(\n@@ -150,11 +161,11 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn crate_name(&self) -> Result<&Query<Symbol>> {\n+    pub fn crate_name(&self) -> Result<QueryResult<'_, Symbol>> {\n         self.crate_name.compute(|| {\n             Ok({\n                 let parse_result = self.parse()?;\n-                let krate = parse_result.peek();\n+                let krate = parse_result.borrow();\n                 // parse `#[crate_name]` even if `--crate-name` was passed, to make sure it matches.\n                 find_crate_name(self.session(), &krate.attrs, &self.compiler.input)\n             })\n@@ -163,11 +174,12 @@ impl<'tcx> Queries<'tcx> {\n \n     pub fn expansion(\n         &self,\n-    ) -> Result<&Query<(Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>> {\n+    ) -> Result<QueryResult<'_, (Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>>\n+    {\n         trace!(\"expansion\");\n         self.expansion.compute(|| {\n-            let crate_name = *self.crate_name()?.peek();\n-            let (krate, lint_store) = self.register_plugins()?.take();\n+            let crate_name = *self.crate_name()?.borrow();\n+            let (krate, lint_store) = self.register_plugins()?.steal();\n             let _timer = self.session().timer(\"configure_and_expand\");\n             let sess = self.session();\n             let mut resolver = passes::create_resolver(\n@@ -183,10 +195,10 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    fn dep_graph(&self) -> Result<&Query<DepGraph>> {\n+    fn dep_graph(&self) -> Result<QueryResult<'_, DepGraph>> {\n         self.dep_graph.compute(|| {\n             let sess = self.session();\n-            let future_opt = self.dep_graph_future()?.take();\n+            let future_opt = self.dep_graph_future()?.steal();\n             let dep_graph = future_opt\n                 .and_then(|future| {\n                     let (prev_graph, prev_work_products) =\n@@ -199,10 +211,11 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n+    pub fn prepare_outputs(&self) -> Result<QueryResult<'_, OutputFilenames>> {\n         self.prepare_outputs.compute(|| {\n-            let (krate, boxed_resolver, _) = &*self.expansion()?.peek();\n-            let crate_name = *self.crate_name()?.peek();\n+            let expansion = self.expansion()?;\n+            let (krate, boxed_resolver, _) = &*expansion.borrow();\n+            let crate_name = *self.crate_name()?.borrow();\n             passes::prepare_outputs(\n                 self.session(),\n                 self.compiler,\n@@ -213,12 +226,12 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn global_ctxt(&'tcx self) -> Result<&Query<QueryContext<'tcx>>> {\n+    pub fn global_ctxt(&'tcx self) -> Result<QueryResult<'_, QueryContext<'tcx>>> {\n         self.global_ctxt.compute(|| {\n-            let crate_name = *self.crate_name()?.peek();\n-            let outputs = self.prepare_outputs()?.take();\n-            let dep_graph = self.dep_graph()?.peek().clone();\n-            let (krate, resolver, lint_store) = self.expansion()?.take();\n+            let crate_name = *self.crate_name()?.borrow();\n+            let outputs = self.prepare_outputs()?.steal();\n+            let dep_graph = self.dep_graph()?.borrow().clone();\n+            let (krate, resolver, lint_store) = self.expansion()?.steal();\n             Ok(passes::create_global_ctxt(\n                 self.compiler,\n                 lint_store,\n@@ -235,9 +248,9 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn ongoing_codegen(&'tcx self) -> Result<&Query<Box<dyn Any>>> {\n+    pub fn ongoing_codegen(&'tcx self) -> Result<QueryResult<'_, Box<dyn Any>>> {\n         self.ongoing_codegen.compute(|| {\n-            self.global_ctxt()?.peek_mut().enter(|tcx| {\n+            self.global_ctxt()?.enter(|tcx| {\n                 tcx.analysis(()).ok();\n \n                 // Don't do code generation if there were any errors\n@@ -293,12 +306,10 @@ impl<'tcx> Queries<'tcx> {\n         let sess = self.session().clone();\n         let codegen_backend = self.codegen_backend().clone();\n \n-        let dep_graph = self.dep_graph()?.peek().clone();\n-        let (crate_hash, prepare_outputs) = self\n-            .global_ctxt()?\n-            .peek_mut()\n-            .enter(|tcx| (tcx.crate_hash(LOCAL_CRATE), tcx.output_filenames(()).clone()));\n-        let ongoing_codegen = self.ongoing_codegen()?.take();\n+        let (crate_hash, prepare_outputs, dep_graph) = self.global_ctxt()?.enter(|tcx| {\n+            (tcx.crate_hash(LOCAL_CRATE), tcx.output_filenames(()).clone(), tcx.dep_graph.clone())\n+        });\n+        let ongoing_codegen = self.ongoing_codegen()?.steal();\n \n         Ok(Linker {\n             sess,\n@@ -382,6 +393,7 @@ impl Compiler {\n         // NOTE: intentionally does not compute the global context if it hasn't been built yet,\n         // since that likely means there was a parse error.\n         if let Some(Ok(gcx)) = &mut *queries.global_ctxt.result.borrow_mut() {\n+            let gcx = gcx.get_mut();\n             // We assume that no queries are run past here. If there are new queries\n             // after this point, they'll show up as \"<unknown>\" in self-profiling data.\n             {"}, {"sha": "5f8c777f32a5c5a064a4a5cdbb9564c1aa3cfdcb", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "patch": "@@ -115,9 +115,7 @@ pub(crate) fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n     let (tests, unused_extern_reports, compiling_test_count) =\n         interface::run_compiler(config, |compiler| {\n             compiler.enter(|queries| {\n-                let mut global_ctxt = queries.global_ctxt()?.take();\n-\n-                let collector = global_ctxt.enter(|tcx| {\n+                let collector = queries.global_ctxt()?.enter(|tcx| {\n                     let crate_attrs = tcx.hir().attrs(CRATE_HIR_ID);\n \n                     let opts = scrape_test_config(crate_attrs);\n@@ -156,9 +154,7 @@ pub(crate) fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n \n                 let unused_extern_reports = collector.unused_extern_reports.clone();\n                 let compiling_test_count = collector.compiling_test_count.load(Ordering::SeqCst);\n-                let ret: Result<_, ErrorGuaranteed> =\n-                    Ok((collector.tests, unused_extern_reports, compiling_test_count));\n-                ret\n+                Ok((collector.tests, unused_extern_reports, compiling_test_count))\n             })\n         })?;\n "}, {"sha": "ed77de200a9b7ac21bba20ada87ed9e654e054b0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "patch": "@@ -800,7 +800,8 @@ fn main_args(at_args: &[String]) -> MainResult {\n             // FIXME(#83761): Resolver cloning can lead to inconsistencies between data in the\n             // two copies because one of the copies can be modified after `TyCtxt` construction.\n             let (resolver, resolver_caches) = {\n-                let (krate, resolver, _) = &*abort_on_err(queries.expansion(), sess).peek();\n+                let expansion = abort_on_err(queries.expansion(), sess);\n+                let (krate, resolver, _) = &*expansion.borrow();\n                 let resolver_caches = resolver.borrow_mut().access(|resolver| {\n                     collect_intra_doc_links::early_resolve_intra_doc_links(\n                         resolver,\n@@ -817,7 +818,7 @@ fn main_args(at_args: &[String]) -> MainResult {\n                 sess.fatal(\"Compilation failed, aborting rustdoc\");\n             }\n \n-            let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).peek_mut();\n+            let global_ctxt = abort_on_err(queries.global_ctxt(), sess);\n \n             global_ctxt.enter(|tcx| {\n                 let (krate, render_opts, mut cache) = sess.time(\"run_global_ctxt\", || {"}, {"sha": "6a147de3be2eac3acd613f75eecc4d41c90e49c9", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "patch": "@@ -61,7 +61,7 @@ impl rustc_driver::Callbacks for MiriCompilerCalls {\n     ) -> Compilation {\n         compiler.session().abort_if_errors();\n \n-        queries.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n+        queries.global_ctxt().unwrap().enter(|tcx| {\n             init_late_loggers(tcx);\n             if !tcx.sess.crate_types().contains(&CrateType::Executable) {\n                 tcx.sess.fatal(\"miri only makes sense on bin crates\");"}, {"sha": "9cd504f004dec402ef5b8f85c7dfabba2ef0234b", "filename": "tests/run-make-fulldeps/obtain-borrowck/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/tests%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9/tests%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs?ref=222d1ff68d5bfe1dc2d7f3f0c42811fe12964af9", "patch": "@@ -62,7 +62,7 @@ impl rustc_driver::Callbacks for CompilerCalls {\n         queries: &'tcx Queries<'tcx>,\n     ) -> Compilation {\n         compiler.session().abort_if_errors();\n-        queries.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n+        queries.global_ctxt().unwrap().enter(|tcx| {\n             // Collect definition ids of MIR bodies.\n             let hir = tcx.hir();\n             let mut bodies = Vec::new();"}]}