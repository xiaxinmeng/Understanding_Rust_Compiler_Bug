{"sha": "b2975ee9742d90a2a005005add4405a8f7156466", "node_id": "C_kwDOAAsO6NoAKGIyOTc1ZWU5NzQyZDkwYTJhMDA1MDA1YWRkNDQwNWE4ZjcxNTY0NjY", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-07-24T19:46:04Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-10-09T13:05:52Z"}, "message": "`for_loop_over_fallibles`: suggest using `?` in some cases", "tree": {"sha": "305e681462fb8b7b0cc173d63c78c682a5a3565d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/305e681462fb8b7b0cc173d63c78c682a5a3565d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2975ee9742d90a2a005005add4405a8f7156466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2975ee9742d90a2a005005add4405a8f7156466", "html_url": "https://github.com/rust-lang/rust/commit/b2975ee9742d90a2a005005add4405a8f7156466", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2975ee9742d90a2a005005add4405a8f7156466/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dcfdbf31e06db2f579f665195cb9471c3d4a629", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dcfdbf31e06db2f579f665195cb9471c3d4a629", "html_url": "https://github.com/rust-lang/rust/commit/5dcfdbf31e06db2f579f665195cb9471c3d4a629"}], "stats": {"total": 68, "additions": 65, "deletions": 3}, "files": [{"sha": "7807fd3a2807a8c608d1005ac12758b347c18552", "filename": "compiler/rustc_lint/src/for_loop_over_fallibles.rs", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b2975ee9742d90a2a005005add4405a8f7156466/compiler%2Frustc_lint%2Fsrc%2Ffor_loop_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2975ee9742d90a2a005005add4405a8f7156466/compiler%2Frustc_lint%2Fsrc%2Ffor_loop_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ffor_loop_over_fallibles.rs?ref=b2975ee9742d90a2a005005add4405a8f7156466", "patch": "@@ -3,8 +3,11 @@ use crate::{LateContext, LateLintPass, LintContext};\n use hir::{Expr, Pat};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_middle::ty;\n-use rustc_span::sym;\n+use rustc_infer::traits::TraitEngine;\n+use rustc_infer::{infer::TyCtxtInferExt, traits::ObligationCause};\n+use rustc_middle::ty::{self, List};\n+use rustc_span::{sym, Span};\n+use rustc_trait_selection::traits::TraitEngineExt;\n \n declare_lint! {\n     /// ### What it does\n@@ -58,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for ForLoopOverFallibles {\n \n         let ty = cx.typeck_results().expr_ty(arg);\n \n-        let ty::Adt(adt, _) = ty.kind() else { return };\n+        let &ty::Adt(adt, substs) = ty.kind() else { return };\n \n         let (article, ty, var) = match adt.did() {\n             did if cx.tcx.is_diagnostic_item(sym::Option, did) => (\"an\", \"Option\", \"Some\"),\n@@ -96,6 +99,15 @@ impl<'tcx> LateLintPass<'tcx> for ForLoopOverFallibles {\n                 );\n             }\n \n+            if suggest_question_mark(cx, adt, substs, expr.span) {\n+                warn.span_suggestion(\n+                    arg.span.shrink_to_hi(),\n+                    \"consider unwrapping the `Result` with `?` to iterate over its contents\",\n+                    \"?\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n             warn.multipart_suggestion_verbose(\n                 \"consider using `if let` to clear intent\",\n                 vec![\n@@ -140,3 +152,53 @@ fn extract_iterator_next_call<'tcx>(\n         return None\n     }\n }\n+\n+fn suggest_question_mark<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    adt: ty::AdtDef<'tcx>,\n+    substs: &List<ty::GenericArg<'tcx>>,\n+    span: Span,\n+) -> bool {\n+    let Some(body_id) = cx.enclosing_body else { return false };\n+    let Some(into_iterator_did) = cx.tcx.get_diagnostic_item(sym::IntoIterator) else { return false };\n+\n+    if !cx.tcx.is_diagnostic_item(sym::Result, adt.did()) {\n+        return false;\n+    }\n+\n+    // Check that the function/closure/constant we are in has a `Result` type.\n+    // Otherwise suggesting using `?` may not be a good idea.\n+    {\n+        let ty = cx.typeck_results().expr_ty(&cx.tcx.hir().body(body_id).value);\n+        let ty::Adt(ret_adt, ..) = ty.kind() else { return false };\n+        if !cx.tcx.is_diagnostic_item(sym::Result, ret_adt.did()) {\n+            return false;\n+        }\n+    }\n+\n+    let ty = substs.type_at(0);\n+    let is_iterator = cx.tcx.infer_ctxt().enter(|infcx| {\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+\n+        let cause = ObligationCause::new(\n+            span,\n+            body_id.hir_id,\n+            rustc_infer::traits::ObligationCauseCode::MiscObligation,\n+        );\n+        fulfill_cx.register_bound(\n+            &infcx,\n+            ty::ParamEnv::empty(),\n+            // Erase any region vids from the type, which may not be resolved\n+            infcx.tcx.erase_regions(ty),\n+            into_iterator_did,\n+            cause,\n+        );\n+\n+        // Select all, including ambiguous predicates\n+        let errors = fulfill_cx.select_all_or_error(&infcx);\n+\n+        errors.is_empty()\n+    });\n+\n+    is_iterator\n+}"}]}