{"sha": "54f4dcd76aafe33c553f6b58fe3e808f055465e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZjRkY2Q3NmFhZmUzM2M1NTNmNmI1OGZlM2U4MDhmMDU1NDY1ZTE=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-10-27T19:12:40Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-10-30T20:19:18Z"}, "message": "Prepared `std::sys` for removal, and made `begin_unwind` simpler\n\n- `begin_unwind` is now generic over any `T: Any + Send`.\n- Every value you fail with gets boxed as an `~Any`.\n- Because of implementation details, `&'static str` and `~str` are still\n  handled specially behind the scenes.\n- Changed the big macro source string in libsyntax to a raw string\n  literal, and enabled doc comments there.", "tree": {"sha": "1a217bcb8ea4d3879dd86ece05468334af1754d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a217bcb8ea4d3879dd86ece05468334af1754d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54f4dcd76aafe33c553f6b58fe3e808f055465e1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54f4dcd76aafe33c553f6b58fe3e808f055465e1", "html_url": "https://github.com/rust-lang/rust/commit/54f4dcd76aafe33c553f6b58fe3e808f055465e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54f4dcd76aafe33c553f6b58fe3e808f055465e1/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42e378f32e212997fc42281112b1c9c4c247de0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42e378f32e212997fc42281112b1c9c4c247de0", "html_url": "https://github.com/rust-lang/rust/commit/e42e378f32e212997fc42281112b1c9c4c247de0"}], "stats": {"total": 416, "additions": 187, "deletions": 229}, "files": [{"sha": "c6fc41e683161ed64d4ef3e0d286cbd16709c7e2", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -118,6 +118,8 @@ pub mod extra {\n     pub use std::clone;\n     pub use std::condition;\n     pub use std::cmp;\n+    // NOTE: Remove import after next snapshot\n+    #[cfg(stage0)]\n     pub use std::sys;\n     pub use std::unstable;\n     pub use std::str;"}, {"sha": "bd528cbe61f06ce012654c5c49229fa3959dcde5", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -65,7 +65,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) ->\n         None => { // not recording borrows\n             let msg = \"borrowed\";\n             do msg.with_c_str |msg_p| {\n-                task::begin_unwind(msg_p, file, line);\n+                task::begin_unwind_raw(msg_p, file, line);\n             }\n         }\n         Some(borrow_list) => { // recording borrows\n@@ -81,7 +81,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) ->\n                 }\n             }\n             do msg.with_c_str |msg_p| {\n-                task::begin_unwind(msg_p, file, line)\n+                task::begin_unwind_raw(msg_p, file, line)\n             }\n         }\n     }\n@@ -180,7 +180,7 @@ pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n             if br.box != a || br.file != file || br.line != line {\n                 let err = format!(\"wrong borrow found, br={:?}\", br);\n                 do err.with_c_str |msg_p| {\n-                    task::begin_unwind(msg_p, file, line)\n+                    task::begin_unwind_raw(msg_p, file, line)\n                 }\n             }\n             borrow_list"}, {"sha": "949421db9fc808a48fa3a93cde76fe68dc6c51f9", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -155,7 +155,7 @@ use cell::Cell;\n use option::{Option, Some, None};\n use prelude::*;\n use rt::task::Task;\n-use rt::task::UnwindReasonLinked;\n+use rt::task::UnwindMessageLinked;\n use rt::task::{UnwindResult, Failure};\n use task::spawn::Taskgroup;\n use to_bytes::IterBytes;\n@@ -597,7 +597,7 @@ impl Death {\n                 }\n \n                 if !success {\n-                    result = Cell::new(Failure(UnwindReasonLinked));\n+                    result = Cell::new(Failure(UnwindMessageLinked));\n                 }\n             }\n             on_exit(result.take());"}, {"sha": "b56dd0809dfd102e7980d07b7d58178d77232e24", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 52, "deletions": 19, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -95,8 +95,8 @@ pub enum UnwindResult {\n     /// The task is ending successfully\n     Success,\n \n-    /// The Task is failing with reason `UnwindReason`\n-    Failure(UnwindReason),\n+    /// The Task is failing with reason `UnwindMessage`\n+    Failure(UnwindMessage),\n }\n \n impl UnwindResult {\n@@ -121,20 +121,25 @@ impl UnwindResult {\n \n /// Represents the cause of a task failure\n #[deriving(ToStr)]\n-pub enum UnwindReason {\n-    /// Failed with a string message\n-    UnwindReasonStr(SendStr),\n+pub enum UnwindMessage {\n+    // FIXME: #9913 - This variant is not neccessary once Any works properly\n+    /// Failed with a static string message\n+    UnwindMessageStrStatic(&'static str),\n+\n+    // FIXME: #9913 - This variant is not neccessary once Any works properly\n+    /// Failed with a owned string message\n+    UnwindMessageStrOwned(~str),\n \n     /// Failed with an `~Any`\n-    UnwindReasonAny(~Any),\n+    UnwindMessageAny(~Any),\n \n     /// Failed because of linked failure\n-    UnwindReasonLinked\n+    UnwindMessageLinked\n }\n \n pub struct Unwinder {\n     unwinding: bool,\n-    cause: Option<UnwindReason>\n+    cause: Option<UnwindMessage>\n }\n \n impl Unwinder {\n@@ -527,7 +532,7 @@ impl Unwinder {\n         }\n     }\n \n-    pub fn begin_unwind(&mut self, cause: UnwindReason) -> ! {\n+    pub fn begin_unwind(&mut self, cause: UnwindMessage) -> ! {\n         #[fixed_stack_segment]; #[inline(never)];\n \n         self.unwinding = true;\n@@ -622,7 +627,7 @@ pub extern \"C\" fn rust_stack_exhausted() {\n /// This is the entry point of unwinding for things like lang items and such.\n /// The arguments are normally generated by the compiler, and need to\n /// have static lifetimes.\n-pub fn begin_unwind(msg: *c_char, file: *c_char, line: size_t) -> ! {\n+pub fn begin_unwind_raw(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     use c_str::CString;\n     use cast::transmute;\n \n@@ -638,11 +643,33 @@ pub fn begin_unwind(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     let msg = static_char_ptr(msg);\n     let file = static_char_ptr(file);\n \n-    begin_unwind_reason(UnwindReasonStr(msg.into_send_str()), file, line as uint)\n+    begin_unwind(msg, file, line as uint)\n }\n \n /// This is the entry point of unwinding for fail!() and assert!().\n-pub fn begin_unwind_reason(reason: UnwindReason, file: &'static str, line: uint) -> ! {\n+pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> ! {\n+    // Wrap the fail message in a `Any` box for uniform representation.\n+    let any = ~msg as ~Any;\n+\n+    // FIXME: #9913 - This can be changed to be internal to begin_unwind_internal\n+    // once Any works properly.\n+    // As a workaround, string types need to be special cased right now\n+    // because `Any` does not support dynamically querying whether the\n+    // type implements a trait yet, so without requiring that every `Any`\n+    // also implements `ToStr` there is no way to get a failure message\n+    // out of it again during unwinding.\n+    let msg = if any.is::<&'static str>() {\n+        UnwindMessageStrStatic(*any.move::<&'static str>().unwrap())\n+    } else if any.is::<~str>() {\n+        UnwindMessageStrOwned(*any.move::<~str>().unwrap())\n+    } else {\n+        UnwindMessageAny(any)\n+    };\n+\n+    begin_unwind_internal(msg, file, line)\n+}\n+\n+fn begin_unwind_internal(msg: UnwindMessage, file: &'static str, line: uint) -> ! {\n     use rt::in_green_task_context;\n     use rt::task::Task;\n     use rt::local::Local;\n@@ -656,15 +683,16 @@ pub fn begin_unwind_reason(reason: UnwindReason, file: &'static str, line: uint)\n         let task: *mut Task;\n \n         {\n-            let msg = match reason {\n-                UnwindReasonStr(ref s) => s.as_slice(),\n-                UnwindReasonAny(_)     => \"~Any\",\n-                UnwindReasonLinked     => \"linked failure\",\n+            let msg_s = match msg {\n+                UnwindMessageAny(_) => \"~Any\",\n+                UnwindMessageLinked => \"linked failure\",\n+                UnwindMessageStrOwned(ref s)  => s.as_slice(),\n+                UnwindMessageStrStatic(ref s) => s.as_slice(),\n             };\n \n             if !in_green_task_context() {\n                 rterrln!(\"failed in non-task context at '{}', {}:{}\",\n-                        msg, file, line);\n+                         msg_s, file, line);\n                 intrinsics::abort();\n             }\n \n@@ -679,19 +707,20 @@ pub fn begin_unwind_reason(reason: UnwindReason, file: &'static str, line: uint)\n             //      due to mismanagment of its own kill flag, so calling our own\n             //      logger in its current state is a bit of a problem.\n \n-            rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg, file, line);\n+            rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg_s, file, line);\n \n             if (*task).unwinder.unwinding {\n                 rtabort!(\"unwinding again\");\n             }\n         }\n \n-        (*task).unwinder.begin_unwind(reason);\n+        (*task).unwinder.begin_unwind(msg);\n     }\n }\n \n #[cfg(test)]\n mod test {\n+    use super::*;\n     use rt::test::*;\n \n     #[test]\n@@ -804,4 +833,8 @@ mod test {\n             a.next = Some(b);\n         }\n     }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_begin_unwind() { begin_unwind(\"cause\", file!(), line!()) }\n }"}, {"sha": "df6c47a8492bea86078dc28589b1bb49692d4dfe", "filename": "src/libstd/std.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -184,6 +184,8 @@ pub mod os;\n pub mod path;\n pub mod rand;\n pub mod run;\n+// NOTE: Remove module after next snapshot\n+#[cfg(stage0)]\n pub mod sys;\n pub mod cast;\n pub mod fmt;\n@@ -226,7 +228,10 @@ mod std {\n     pub use logging;\n     pub use option;\n     pub use os;\n+    pub use rt;\n     pub use str;\n+    // NOTE: Remove import after next snapshot\n+    #[cfg(stage0)]\n     pub use sys;\n     pub use to_bytes;\n     pub use to_str;"}, {"sha": "4216f91b60263993873861ef974220e2c61bcd1c", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 5, "deletions": 84, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -10,99 +10,20 @@\n \n //! Misc low level stuff\n \n+// NOTE: Remove this module after an snapshot\n+\n #[allow(missing_doc)];\n \n use any::Any;\n use kinds::Send;\n-use rt::task::{UnwindReasonStr, UnwindReasonAny};\n use rt::task;\n-use send_str::{SendStr, IntoSendStr};\n \n-/// Trait for initiating task failure with a sendable cause.\n pub trait FailWithCause {\n-    /// Fail the current task with `cause`.\n     fn fail_with(cause: Self, file: &'static str, line: uint) -> !;\n }\n \n-impl FailWithCause for ~str {\n-    fn fail_with(cause: ~str, file: &'static str, line: uint) -> ! {\n-        task::begin_unwind_reason(UnwindReasonStr(cause.into_send_str()), file, line)\n-    }\n-}\n-\n-impl FailWithCause for &'static str {\n-    fn fail_with(cause: &'static str, file: &'static str, line: uint) -> ! {\n-        task::begin_unwind_reason(UnwindReasonStr(cause.into_send_str()), file, line)\n-    }\n-}\n-\n-impl FailWithCause for SendStr {\n-    fn fail_with(cause: SendStr, file: &'static str, line: uint) -> ! {\n-        task::begin_unwind_reason(UnwindReasonStr(cause), file, line)\n-    }\n-}\n-\n-impl FailWithCause for ~Any {\n-    fn fail_with(cause: ~Any, file: &'static str, line: uint) -> ! {\n-        task::begin_unwind_reason(UnwindReasonAny(cause), file, line)\n-    }\n-}\n-\n-impl<T: Any + Send + 'static> FailWithCause for ~T {\n-    fn fail_with(cause: ~T, file: &'static str, line: uint) -> ! {\n-        task::begin_unwind_reason(UnwindReasonAny(cause as ~Any), file, line)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use any::Any;\n-    use cast;\n-    use send_str::IntoSendStr;\n-\n-    #[test]\n-    fn synthesize_closure() {\n-        use unstable::raw::Closure;\n-        unsafe {\n-            let x = 10;\n-            let f: &fn(int) -> int = |y| x + y;\n-\n-            assert_eq!(f(20), 30);\n-\n-            let original_closure: Closure = cast::transmute(f);\n-\n-            let actual_function_pointer = original_closure.code;\n-            let environment = original_closure.env;\n-\n-            let new_closure = Closure {\n-                code: actual_function_pointer,\n-                env: environment\n-            };\n-\n-            let new_f: &fn(int) -> int = cast::transmute(new_closure);\n-            assert_eq!(new_f(20), 30);\n-        }\n+impl<T: Any + Send> FailWithCause for T {\n+    fn fail_with(msg: T, file: &'static str, line: uint) -> ! {\n+        task::begin_unwind(msg, file, line)\n     }\n-\n-    #[test]\n-    #[should_fail]\n-    fn fail_static() { FailWithCause::fail_with(\"cause\", file!(), line!()) }\n-\n-    #[test]\n-    #[should_fail]\n-    fn fail_owned() { FailWithCause::fail_with(~\"cause\", file!(), line!()) }\n-\n-    #[test]\n-    #[should_fail]\n-    fn fail_send() { FailWithCause::fail_with(\"cause\".into_send_str(), file!(), line!()) }\n-\n-    #[test]\n-    #[should_fail]\n-    fn fail_any() { FailWithCause::fail_with(~612_u16 as ~Any, file!(), line!()) }\n-\n-    #[test]\n-    #[should_fail]\n-    fn fail_any_wrap() { FailWithCause::fail_with(~413_u16, file!(), line!()) }\n }"}, {"sha": "cdb70f00dfe57f3c22f33974d8cc5a6085303420", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -60,7 +60,8 @@ use comm::{stream, Chan, GenericChan, GenericPort, Port, Peekable};\n use result::{Result, Ok, Err};\n use rt::in_green_task_context;\n use rt::local::Local;\n-use rt::task::{UnwindReasonAny, UnwindReasonLinked, UnwindReasonStr};\n+use rt::task::{UnwindMessageAny, UnwindMessageLinked};\n+use rt::task::{UnwindMessageStrStatic, UnwindMessageStrOwned};\n use rt::task::{UnwindResult, Success, Failure};\n use send_str::{SendStr, IntoSendStr};\n use unstable::finally::Finally;\n@@ -93,9 +94,10 @@ pub struct LinkedFailure;\n fn wrap_as_any(res: UnwindResult) -> TaskResult {\n     match res {\n         Success => Ok(()),\n-        Failure(UnwindReasonStr(s)) => Err(~s as ~Any),\n-        Failure(UnwindReasonAny(a)) => Err(a),\n-        Failure(UnwindReasonLinked) => Err(~LinkedFailure as ~Any)\n+        Failure(UnwindMessageAny(a)) => Err(a),\n+        Failure(UnwindMessageLinked) => Err(~LinkedFailure as ~Any),\n+        Failure(UnwindMessageStrOwned(s))  => Err(~s as ~Any),\n+        Failure(UnwindMessageStrStatic(s)) => Err(~s as ~Any),\n     }\n }\n \n@@ -1425,38 +1427,52 @@ fn test_indestructible() {\n }\n \n #[test]\n-fn test_try_fail_cause_static_str() {\n+fn test_try_fail_message_static_str() {\n     match do try {\n         fail!(\"static string\");\n     } {\n-        Err(ref e) if e.is::<SendStr>() => {}\n-        Err(_) | Ok(()) => fail!()\n+        Err(e) => {\n+            type T = &'static str;\n+            assert!(e.is::<T>());\n+            assert_eq!(*e.move::<T>().unwrap(), \"static string\");\n+        }\n+        Ok(()) => fail!()\n     }\n }\n \n #[test]\n-fn test_try_fail_cause_owned_str() {\n+fn test_try_fail_message_owned_str() {\n     match do try {\n         fail!(~\"owned string\");\n     } {\n-        Err(ref e) if e.is::<SendStr>() => {}\n-        Err(_) | Ok(()) => fail!()\n+        Err(e) => {\n+            type T = ~str;\n+            assert!(e.is::<T>());\n+            assert_eq!(*e.move::<T>().unwrap(), ~\"owned string\");\n+        }\n+        Ok(()) => fail!()\n     }\n }\n \n #[test]\n-fn test_try_fail_cause_any() {\n+fn test_try_fail_message_any() {\n     match do try {\n         fail!(~413u16 as ~Any);\n     } {\n-        Err(ref e) if e.is::<u16>() => {}\n-        Err(_) | Ok(()) => fail!()\n+        Err(e) => {\n+            type T = ~Any;\n+            assert!(e.is::<T>());\n+            let any = e.move::<T>().unwrap();\n+            assert!(any.is::<u16>());\n+            assert_eq!(*any.move::<u16>().unwrap(), 413u16);\n+        }\n+        Ok(()) => fail!()\n     }\n }\n \n #[ignore(reason = \"linked failure\")]\n #[test]\n-fn test_try_fail_cause_linked() {\n+fn test_try_fail_message_linked() {\n     match do try {\n         do spawn {\n             fail!()\n@@ -1468,11 +1484,11 @@ fn test_try_fail_cause_linked() {\n }\n \n #[test]\n-fn test_try_fail_cause_any_wrapped() {\n+fn test_try_fail_message_unit_struct() {\n     struct Juju;\n \n     match do try {\n-        fail!(~Juju)\n+        fail!(Juju)\n     } {\n         Err(ref e) if e.is::<Juju>() => {}\n         Err(_) | Ok(()) => fail!()"}, {"sha": "4a98e396bbccd7bd316be338d51c2bc1fd25f846", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -83,12 +83,11 @@ use local_data;\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown, TaskFromFriend};\n use rt::task::{Task, Sched};\n-use rt::task::{UnwindReasonLinked, UnwindReasonStr};\n+use rt::task::{UnwindMessageLinked, UnwindMessageStrStatic};\n use rt::task::{UnwindResult, Success, Failure};\n use rt::thread::Thread;\n use rt::work_queue::WorkQueue;\n use rt::{in_green_task_context, new_event_loop, KillHandle};\n-use send_str::IntoSendStr;\n use task::SingleThreaded;\n use task::TaskOpts;\n use task::unkillable;\n@@ -325,7 +324,7 @@ impl Drop for Taskgroup {\n         do RuntimeGlue::with_task_handle_and_failing |me, failing| {\n             if failing {\n                 for x in self.notifier.mut_iter() {\n-                    x.task_result = Some(Failure(UnwindReasonLinked));\n+                    x.task_result = Some(Failure(UnwindMessageLinked));\n                 }\n                 // Take everybody down with us. After this point, every\n                 // other task in the group will see 'tg' as none, which\n@@ -380,7 +379,7 @@ impl AutoNotify {\n             notify_chan: chan,\n \n             // Un-set above when taskgroup successfully made.\n-            task_result: Some(Failure(UnwindReasonStr(\"AutoNotify::new()\".into_send_str())))\n+            task_result: Some(Failure(UnwindMessageStrStatic(\"AutoNotify::new()\")))\n         }\n     }\n }"}, {"sha": "092e9b6d348bc150dcc815b5913e8cc4345cb72a", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -19,7 +19,7 @@ use rt::borrowck;\n #[cold]\n #[lang=\"fail_\"]\n pub fn fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n-    task::begin_unwind(expr, file, line);\n+    task::begin_unwind_raw(expr, file, line);\n }\n \n #[cold]"}, {"sha": "d784c1d38c60fd7193c2c95b1bf691c5b3ee302a", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -62,3 +62,33 @@ impl Repr<*Box<String>> for @str {}\n \n // sure would be nice to have this\n // impl<T> Repr<*Vec<T>> for ~[T] {}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use cast;\n+\n+    #[test]\n+    fn synthesize_closure() {\n+        unsafe {\n+            let x = 10;\n+            let f: &fn(int) -> int = |y| x + y;\n+\n+            assert_eq!(f(20), 30);\n+\n+            let original_closure: Closure = cast::transmute(f);\n+\n+            let actual_function_pointer = original_closure.code;\n+            let environment = original_closure.env;\n+\n+            let new_closure = Closure {\n+                code: actual_function_pointer,\n+                env: environment\n+            };\n+\n+            let new_f: &fn(int) -> int = cast::transmute(new_closure);\n+            assert_eq!(new_f(20), 30);\n+        }\n+    }\n+}"}, {"sha": "76d9f755d3c9f64a86e1f929721846420be6fe21", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -604,9 +604,9 @@ impl AstBuilder for @ExtCtxt {\n             span,\n             ~[\n                 self.ident_of(\"std\"),\n-                self.ident_of(\"sys\"),\n-                self.ident_of(\"FailWithCause\"),\n-                self.ident_of(\"fail_with\"),\n+                self.ident_of(\"rt\"),\n+                self.ident_of(\"task\"),\n+                self.ident_of(\"begin_unwind\"),\n             ],\n             ~[\n                 self.expr_str(span, msg),"}, {"sha": "052b177d4d8d3f4d2f49e02803fddc4334fc4af4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 48, "deletions": 56, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -763,8 +763,7 @@ pub fn new_span(cx: @ExtCtxt, sp: Span) -> Span {\n // syntax elements.\n \n pub fn std_macros() -> @str {\n-    return\n-@\"mod __std_macros {\n+@r#\"mod __std_macros {\n     #[macro_escape];\n     #[doc(hidden)];\n \n@@ -789,31 +788,30 @@ pub fn std_macros() -> @str {\n \n     macro_rules! fail(\n         () => (\n-            fail!(\\\"explicit failure\\\")\n+            fail!(\"explicit failure\")\n         );\n-        ($fmt:expr) => (\n-            ::std::sys::FailWithCause::fail_with($fmt, file!(), line!())\n+        ($msg:expr) => (\n+            ::std::rt::task::begin_unwind($msg, file!(), line!())\n         );\n         ($fmt:expr, $($arg:tt)*) => (\n-            ::std::sys::FailWithCause::fail_with(format!($fmt, $($arg)*), file!(), line!())\n+            ::std::rt::task::begin_unwind(format!($fmt, $($arg)*), file!(), line!())\n         )\n     )\n \n     macro_rules! assert(\n         ($cond:expr) => {\n             if !$cond {\n-                ::std::sys::FailWithCause::fail_with(\n-                    \\\"assertion failed: \\\" + stringify!($cond), file!(), line!())\n+                fail!(\"assertion failed: {:s}\", stringify!($cond))\n             }\n         };\n         ($cond:expr, $msg:expr) => {\n             if !$cond {\n-                ::std::sys::FailWithCause::fail_with($msg, file!(), line!())\n+                fail!($msg)\n             }\n         };\n         ($cond:expr, $( $arg:expr ),+) => {\n             if !$cond {\n-                ::std::sys::FailWithCause::fail_with(format!( $($arg),+ ), file!(), line!())\n+                fail!( $($arg),+ )\n             }\n         }\n     )\n@@ -826,9 +824,8 @@ pub fn std_macros() -> @str {\n                 // check both directions of equality....\n                 if !((*given_val == *expected_val) &&\n                      (*expected_val == *given_val)) {\n-                    fail!(\\\"assertion failed: `(left == right) && (right == \\\n-                             left)` (left: `{:?}`, right: `{:?}`)\\\",\n-                           *given_val, *expected_val);\n+                    fail!(\"assertion failed: `(left == right) && (right == left)` \\\n+                           (left: `{:?}`, right: `{:?}`)\", *given_val, *expected_val)\n                 }\n             }\n         )\n@@ -846,7 +843,7 @@ pub fn std_macros() -> @str {\n                     given_val.approx_eq(&expected_val) &&\n                     expected_val.approx_eq(&given_val)\n                 ) {\n-                    fail!(\\\"left: {:?} does not approximately equal right: {:?}\\\",\n+                    fail!(\"left: {:?} does not approximately equal right: {:?}\",\n                            given_val, expected_val);\n                 }\n             }\n@@ -863,42 +860,37 @@ pub fn std_macros() -> @str {\n                     given_val.approx_eq_eps(&expected_val, &epsilon_val) &&\n                     expected_val.approx_eq_eps(&given_val, &epsilon_val)\n                 ) {\n-                    fail!(\\\"left: {:?} does not approximately equal right: \\\n-                             {:?} with epsilon: {:?}\\\",\n+                    fail!(\"left: {:?} does not approximately equal right: \\\n+                             {:?} with epsilon: {:?}\",\n                           given_val, expected_val, epsilon_val);\n                 }\n             }\n         )\n     )\n \n-    // FIXME(#6266): change the /* to /** when attributes are supported on macros\n-    // (Though even then\u2014is it going to work according to the clear intent here?)\n-    /*\n-    A utility macro for indicating unreachable code. It will fail if\n-    executed. This is occasionally useful to put after loops that never\n-    terminate normally, but instead directly return from a function.\n-\n-    # Example\n-\n-    ```rust\n-    fn choose_weighted_item(v: &[Item]) -> Item {\n-        assert!(!v.is_empty());\n-        let mut so_far = 0u;\n-        for v.each |item| {\n-            so_far += item.weight;\n-            if so_far > 100 {\n-                return item;\n-            }\n-        }\n-        // The above loop always returns, so we must hint to the\n-        // type checker that it isn't possible to get down here\n-        unreachable!();\n-    }\n-    ```\n-\n-    */\n+    /// A utility macro for indicating unreachable code. It will fail if\n+    /// executed. This is occasionally useful to put after loops that never\n+    /// terminate normally, but instead directly return from a function.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// fn choose_weighted_item(v: &[Item]) -> Item {\n+    ///     assert!(!v.is_empty());\n+    ///     let mut so_far = 0u;\n+    ///     for item in v.iter() {\n+    ///         so_far += item.weight;\n+    ///         if so_far > 100 {\n+    ///             return item;\n+    ///         }\n+    ///     }\n+    ///     // The above loop always returns, so we must hint to the\n+    ///     // type checker that it isn't possible to get down here\n+    ///     unreachable!();\n+    /// }\n+    /// ```\n     macro_rules! unreachable (() => (\n-        fail!(\\\"internal error: entered unreachable code\\\");\n+        fail!(\"internal error: entered unreachable code\");\n     ))\n \n     macro_rules! condition (\n@@ -968,18 +960,18 @@ pub fn std_macros() -> @str {\n         )\n     )\n \n-    // externfn! declares a wrapper for an external function.\n-    // It is intended to be used like:\n-    //\n-    // externfn!(#[nolink]\n-    //           fn memcmp(cx: *u8, ct: *u8, n: u32) -> u32)\n-    //\n-    // Due to limitations in the macro parser, this pattern must be\n-    // implemented with 4 distinct patterns (with attrs / without\n-    // attrs CROSS with args / without ARGS).\n-    //\n-    // Also, this macro grammar allows for any number of return types\n-    // because I couldn't figure out the syntax to specify at most one.\n+    /// externfn! declares a wrapper for an external function.\n+    /// It is intended to be used like:\n+    ///\n+    /// externfn!(#[nolink]\n+    ///           fn memcmp(cx: *u8, ct: *u8, n: u32) -> u32)\n+    ///\n+    /// Due to limitations in the macro parser, this pattern must be\n+    /// implemented with 4 distinct patterns (with attrs / without\n+    /// attrs CROSS with args / without ARGS).\n+    ///\n+    /// Also, this macro grammar allows for any number of return types\n+    /// because I couldn't figure out the syntax to specify at most one.\n     macro_rules! externfn(\n         (fn $name:ident () $(-> $ret_ty:ty),*) => (\n             pub unsafe fn $name() $(-> $ret_ty),* {\n@@ -1045,7 +1037,7 @@ pub fn std_macros() -> @str {\n         )\n     )\n \n-}\";\n+}\"#\n }\n \n struct Injector {"}, {"sha": "98270bdc583835e63d9b274d6dd1e3996cdac965", "filename": "src/test/compile-fail/fail-expr.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e42e378f32e212997fc42281112b1c9c4c247de0/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42e378f32e212997fc42281112b1c9c4c247de0/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs?ref=e42e378f32e212997fc42281112b1c9c4c247de0", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:failed to find an implementation of trait std::sys::FailWithCause for int\n-\n-fn main() { fail!(5); }"}, {"sha": "b6755249bcf98108dce766569262e59a522784ff", "filename": "src/test/compile-fail/fail-type-err.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e42e378f32e212997fc42281112b1c9c4c247de0/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42e378f32e212997fc42281112b1c9c4c247de0/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs?ref=e42e378f32e212997fc42281112b1c9c4c247de0", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:failed to find an implementation of trait std::sys::FailWithCause for ~[int]\n-fn main() { fail!(~[0i]); }"}, {"sha": "2047fde150b9a71800a9cdbe91a1c9bd3c1194ea", "filename": "src/test/run-fail/fail-macro-send_str.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e42e378f32e212997fc42281112b1c9c4c247de0/src%2Ftest%2Frun-fail%2Ffail-macro-send_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42e378f32e212997fc42281112b1c9c4c247de0/src%2Ftest%2Frun-fail%2Ffail-macro-send_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-macro-send_str.rs?ref=e42e378f32e212997fc42281112b1c9c4c247de0", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:failed at 'test-fail-send-str'\n-\n-fn main() {\n-    fail!(\"test-fail-send-str\".into_send_str());\n-}"}, {"sha": "5707406de146c4edf822bb23d7989fd84c3ce1fa", "filename": "src/test/run-pass/unit-like-struct-drop-run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f4dcd76aafe33c553f6b58fe3e808f055465e1/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs?ref=54f4dcd76aafe33c553f6b58fe3e808f055465e1", "patch": "@@ -25,6 +25,6 @@ pub fn main() {\n         let _b = Foo;\n     };\n \n-    let s = x.unwrap_err().move::<SendStr>().unwrap();\n+    let s = x.unwrap_err().move::<&'static str>().unwrap();\n     assert_eq!(s.as_slice(), \"This failure should happen.\");\n }"}]}