{"sha": "5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "node_id": "C_kwDOAAsO6NoAKDVjMzBkNjU2ODM4MzkxNmNlOTdjZGYyMGNlYjYxYThiOWU1YmI1YTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-13T00:14:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-13T00:14:52Z"}, "message": "Auto merge of #93670 - erikdesjardins:noundef, r=nikic\n\nApply noundef attribute to &T, &mut T, Box<T>, bool\n\nThis doesn't handle `char` because it's a bit awkward to distinguish it from `u32` at this point in codegen.\n\nNote that this _does not_ change whether or not it is UB for `&`, `&mut`, or `Box` to point to undef. It only applies to the pointer itself, not the pointed-to memory.\n\nFixes (partially) #74378.\n\nr? `@nikic` cc `@RalfJung`", "tree": {"sha": "f46d936ef6bc64bd6f032bca84e9711a0e572d7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f46d936ef6bc64bd6f032bca84e9711a0e572d7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "html_url": "https://github.com/rust-lang/rust/commit/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cfa4def7c87d571bd46d92fed608edf8fad236e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cfa4def7c87d571bd46d92fed608edf8fad236e", "html_url": "https://github.com/rust-lang/rust/commit/3cfa4def7c87d571bd46d92fed608edf8fad236e"}, {"sha": "401307759aaf6f1e49c8a2c840a76ae41ec1f865", "url": "https://api.github.com/repos/rust-lang/rust/commits/401307759aaf6f1e49c8a2c840a76ae41ec1f865", "html_url": "https://github.com/rust-lang/rust/commit/401307759aaf6f1e49c8a2c840a76ae41ec1f865"}], "stats": {"total": 185, "additions": 94, "deletions": 91}, "files": [{"sha": "8a11e3e71bc81253404a427dd4d1b1c814b32339", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -37,7 +37,7 @@ impl ArgAttributeExt for ArgAttribute {\n     where\n         F: FnMut(llvm::Attribute),\n     {\n-        for_each_kind!(self, f, NoAlias, NoCapture, NonNull, ReadOnly, InReg)\n+        for_each_kind!(self, f, NoAlias, NoCapture, NonNull, ReadOnly, InReg, NoUndef)\n     }\n }\n "}, {"sha": "4f62c68556841515af1a8ba33c2dc08c109d5c3f", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -189,6 +189,7 @@ pub enum Attribute {\n     StackProtectReq = 30,\n     StackProtectStrong = 31,\n     StackProtect = 32,\n+    NoUndef = 33,\n }\n \n /// LLVMIntPredicate"}, {"sha": "9e0a9b354e19675ee40eef1290144342d31ac0d3", "filename": "compiler/rustc_llvm/llvm-wrapper/LLVMWrapper.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -82,6 +82,7 @@ enum LLVMRustAttribute {\n   StackProtectReq = 30,\n   StackProtectStrong = 31,\n   StackProtect = 32,\n+  NoUndef = 33,\n };\n \n typedef struct OpaqueRustString *RustStringRef;"}, {"sha": "fb9c5e6a527a76a60b8bad4369347ba726c3a353", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -224,6 +224,8 @@ static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n     return Attribute::StackProtectStrong;\n   case StackProtect:\n     return Attribute::StackProtect;\n+  case NoUndef:\n+    return Attribute::NoUndef;\n   }\n   report_fatal_error(\"bad AttributeKind\");\n }"}, {"sha": "6d4178c3e753f4da570abf69ba9831ca533c6801", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -3051,9 +3051,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                       layout: TyAndLayout<'tcx>,\n                                       offset: Size,\n                                       is_return: bool| {\n-            // Booleans are always an i1 that needs to be zero-extended.\n+            // Booleans are always a noundef i1 that needs to be zero-extended.\n             if scalar.is_bool() {\n                 attrs.ext(ArgExtension::Zext);\n+                attrs.set(ArgAttribute::NoUndef);\n                 return;\n             }\n \n@@ -3078,6 +3079,11 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         _ => pointee.size,\n                     };\n \n+                    // `Box`, `&T`, and `&mut T` cannot be undef.\n+                    // Note that this only applies to the value of the pointer itself;\n+                    // this attribute doesn't make it UB for the pointed-to data to be undef.\n+                    attrs.set(ArgAttribute::NoUndef);\n+\n                     // `Box` pointer parameters never alias because ownership is transferred\n                     // `&mut` pointer parameters never alias other parameters,\n                     // or mutable global data"}, {"sha": "34324a582977db24f1a89692d792d39f67dd63fd", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -74,6 +74,7 @@ mod attr_impl {\n             // or not to actually emit the attribute. It can also be controlled\n             // with the `-Zmutable-noalias` debugging option.\n             const NoAliasMutRef = 1 << 6;\n+            const NoUndef = 1 << 7;\n         }\n     }\n }\n@@ -495,7 +496,11 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n         // program-invisible so can't possibly capture\n-        attrs.set(ArgAttribute::NoAlias).set(ArgAttribute::NoCapture).set(ArgAttribute::NonNull);\n+        attrs\n+            .set(ArgAttribute::NoAlias)\n+            .set(ArgAttribute::NoCapture)\n+            .set(ArgAttribute::NonNull)\n+            .set(ArgAttribute::NoUndef);\n         attrs.pointee_size = layout.size;\n         // FIXME(eddyb) We should be doing this, but at least on\n         // i686-pc-windows-msvc, it results in wrong stack offsets."}, {"sha": "ec7a67915928646f87ebe1bbae7159b7850fc762", "filename": "src/test/codegen/fastcall-inreg.rs", "status": "modified", "additions": 10, "deletions": 45, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -2,52 +2,17 @@\n // as \"inreg\" like the C/C++ compilers for the platforms.\n // x86 only.\n \n-// ignore-aarch64\n-// ignore-aarch64_be\n-// ignore-arm\n-// ignore-armeb\n-// ignore-avr\n-// ignore-bpfel\n-// ignore-bpfeb\n-// ignore-hexagon\n-// ignore-mips\n-// ignore-mips64\n-// ignore-msp430\n-// ignore-powerpc64\n-// ignore-powerpc64le\n-// ignore-powerpc\n-// ignore-r600\n-// ignore-riscv64\n-// ignore-amdgcn\n-// ignore-sparc\n-// ignore-sparc64\n-// ignore-sparcv9\n-// ignore-sparcel\n-// ignore-s390x\n-// ignore-tce\n-// ignore-thumb\n-// ignore-thumbeb\n-// ignore-x86_64\n-// ignore-xcore\n-// ignore-nvptx\n-// ignore-nvptx64\n-// ignore-le32\n-// ignore-le64\n-// ignore-amdil\n-// ignore-amdil64\n-// ignore-hsail\n-// ignore-hsail64\n-// ignore-spir\n-// ignore-spir64\n-// ignore-kalimba\n-// ignore-shave\n-// ignore-wasm32\n-// ignore-wasm64\n-// ignore-emscripten\n-\n-// compile-flags: -C no-prepopulate-passes\n+// compile-flags: --target i686-unknown-linux-gnu -C no-prepopulate-passes\n+// needs-llvm-components: x86\n \n #![crate_type = \"lib\"]\n+#![no_core]\n+#![feature(no_core, lang_items)]\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n \n pub mod tests {\n     // CHECK: @f1(i32 inreg %_1, i32 inreg %_2, i32 %_3)\n@@ -70,7 +35,7 @@ pub mod tests {\n     #[no_mangle]\n     pub extern \"fastcall\" fn f5(_: i64, _: i32) {}\n \n-    // CHECK: @f6(i1 inreg zeroext %_1, i32 inreg %_2, i32 %_3)\n+    // CHECK: @f6(i1 inreg noundef zeroext %_1, i32 inreg %_2, i32 %_3)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f6(_: bool, _: i32, _: i32) {}\n }"}, {"sha": "17b54d86cb09f057696093415c7086c5dc2a84e7", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -3,6 +3,8 @@\n #![crate_type = \"lib\"]\n #![feature(rustc_attrs)]\n \n+use std::mem::MaybeUninit;\n+\n pub struct S {\n   _field: [i32; 8],\n }\n@@ -11,68 +13,79 @@ pub struct UnsafeInner {\n   _field: std::cell::UnsafeCell<i16>,\n }\n \n-// CHECK: zeroext i1 @boolean(i1 zeroext %x)\n+// CHECK: noundef zeroext i1 @boolean(i1 noundef zeroext %x)\n #[no_mangle]\n pub fn boolean(x: bool) -> bool {\n   x\n }\n \n-// CHECK: @readonly_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n+// CHECK: i8 @maybeuninit_boolean(i8 %x)\n+#[no_mangle]\n+pub fn maybeuninit_boolean(x: MaybeUninit<bool>) -> MaybeUninit<bool> {\n+  x\n+}\n+\n+// CHECK: @readonly_borrow(i32* noalias noundef readonly align 4 dereferenceable(4) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn readonly_borrow(_: &i32) {\n }\n \n-// CHECK: @static_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n+// CHECK: @static_borrow(i32* noalias noundef readonly align 4 dereferenceable(4) %_1)\n // static borrow may be captured\n #[no_mangle]\n pub fn static_borrow(_: &'static i32) {\n }\n \n-// CHECK: @named_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n+// CHECK: @named_borrow(i32* noalias noundef readonly align 4 dereferenceable(4) %_1)\n // borrow with named lifetime may be captured\n #[no_mangle]\n pub fn named_borrow<'r>(_: &'r i32) {\n }\n \n-// CHECK: @unsafe_borrow(i16* align 2 dereferenceable(2) %_1)\n+// CHECK: @unsafe_borrow(i16* noundef align 2 dereferenceable(2) %_1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_borrow(_: &UnsafeInner) {\n }\n \n-// CHECK: @mutable_unsafe_borrow(i16* noalias align 2 dereferenceable(2) %_1)\n+// CHECK: @mutable_unsafe_borrow(i16* noalias noundef align 2 dereferenceable(2) %_1)\n // ... unless this is a mutable borrow, those never alias\n #[no_mangle]\n pub fn mutable_unsafe_borrow(_: &mut UnsafeInner) {\n }\n \n-// CHECK: @mutable_borrow(i32* noalias align 4 dereferenceable(4) %_1)\n+// CHECK: @mutable_borrow(i32* noalias noundef align 4 dereferenceable(4) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_borrow(_: &mut i32) {\n }\n \n-// CHECK: @indirect_struct(%S* noalias nocapture dereferenceable(32) %_1)\n+// CHECK: @indirect_struct(%S* noalias nocapture noundef dereferenceable(32) %_1)\n #[no_mangle]\n pub fn indirect_struct(_: S) {\n }\n \n-// CHECK: @borrowed_struct(%S* noalias readonly align 4 dereferenceable(32) %_1)\n+// CHECK: @borrowed_struct(%S* noalias noundef readonly align 4 dereferenceable(32) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn borrowed_struct(_: &S) {\n }\n \n+// CHECK: @raw_struct(%S* %_1)\n+#[no_mangle]\n+pub fn raw_struct(_: *const S) {\n+}\n+\n // `Box` can get deallocated during execution of the function, so it should\n // not get `dereferenceable`.\n-// CHECK: noalias nonnull align 4 i32* @_box(i32* noalias nonnull align 4 %x)\n+// CHECK: noalias noundef nonnull align 4 i32* @_box(i32* noalias noundef nonnull align 4 %x)\n #[no_mangle]\n pub fn _box(x: Box<i32>) -> Box<i32> {\n   x\n }\n \n-// CHECK: @struct_return(%S* noalias nocapture sret(%S) dereferenceable(32){{( %0)?}})\n+// CHECK: @struct_return(%S* noalias nocapture noundef sret(%S) dereferenceable(32){{( %0)?}})\n #[no_mangle]\n pub fn struct_return() -> S {\n   S {\n@@ -86,48 +99,58 @@ pub fn struct_return() -> S {\n pub fn helper(_: usize) {\n }\n \n-// CHECK: @slice([0 x i8]* noalias nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n+// CHECK: @slice([0 x i8]* noalias noundef nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn slice(_: &[u8]) {\n }\n \n-// CHECK: @mutable_slice([0 x i8]* noalias nonnull align 1 %_1.0, [[USIZE]] %_1.1)\n+// CHECK: @mutable_slice([0 x i8]* noalias noundef nonnull align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_slice(_: &mut [u8]) {\n }\n \n-// CHECK: @unsafe_slice([0 x i16]* nonnull align 2 %_1.0, [[USIZE]] %_1.1)\n+// CHECK: @unsafe_slice([0 x i16]* noundef nonnull align 2 %_1.0, [[USIZE]] %_1.1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_slice(_: &[UnsafeInner]) {\n }\n \n-// CHECK: @str([0 x i8]* noalias nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n+// CHECK: @raw_slice([0 x i8]* %_1.0, [[USIZE]] %_1.1)\n+#[no_mangle]\n+pub fn raw_slice(_: *const [u8]) {\n+}\n+\n+// CHECK: @str([0 x i8]* noalias noundef nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow({}* nonnull align 1 %_1.0, [3 x [[USIZE]]]* noalias readonly align {{.*}} dereferenceable({{.*}}) %_1.1)\n+// CHECK: @trait_borrow({}* noundef nonnull align 1 %_1.0, [3 x [[USIZE]]]* noalias noundef readonly align {{.*}} dereferenceable({{.*}}) %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn trait_borrow(_: &Drop) {\n }\n \n-// CHECK: @trait_box({}* noalias nonnull align 1{{( %0)?}}, [3 x [[USIZE]]]* noalias readonly align {{.*}} dereferenceable({{.*}}){{( %1)?}})\n+// CHECK: @trait_raw({}* %_1.0, [3 x [[USIZE]]]* noalias noundef readonly align {{.*}} dereferenceable({{.*}}) %_1.1)\n+#[no_mangle]\n+pub fn trait_raw(_: *const Drop) {\n+}\n+\n+// CHECK: @trait_box({}* noalias noundef nonnull align 1{{( %0)?}}, [3 x [[USIZE]]]* noalias noundef readonly align {{.*}} dereferenceable({{.*}}){{( %1)?}})\n #[no_mangle]\n pub fn trait_box(_: Box<Drop>) {\n }\n \n-// CHECK: { i8*, i8* } @trait_option(i8* noalias align 1 %x.0, i8* %x.1)\n+// CHECK: { i8*, i8* } @trait_option(i8* noalias noundef align 1 %x.0, i8* %x.1)\n #[no_mangle]\n pub fn trait_option(x: Option<Box<Drop>>) -> Option<Box<Drop>> {\n   x\n }\n \n-// CHECK: { [0 x i16]*, [[USIZE]] } @return_slice([0 x i16]* noalias nonnull readonly align 2 %x.0, [[USIZE]] %x.1)\n+// CHECK: { [0 x i16]*, [[USIZE]] } @return_slice([0 x i16]* noalias noundef nonnull readonly align 2 %x.0, [[USIZE]] %x.1)\n #[no_mangle]\n pub fn return_slice(x: &[u16]) -> &[u16] {\n   x\n@@ -139,7 +162,7 @@ pub fn enum_id_1(x: Option<Result<u16, u16>>) -> Option<Result<u16, u16>> {\n   x\n }\n \n-// CHECK: { i8, i8 } @enum_id_2(i1 zeroext %x.0, i8 %x.1)\n+// CHECK: { i8, i8 } @enum_id_2(i1 noundef zeroext %x.0, i8 %x.1)\n #[no_mangle]\n pub fn enum_id_2(x: Option<u8>) -> Option<u8> {\n   x"}, {"sha": "5d1fb80ec0051bb5c5ed435deea192fc5ab41029", "filename": "src/test/codegen/packed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpacked.rs?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -52,7 +52,7 @@ pub struct BigPacked2 {\n #[no_mangle]\n pub fn call_pkd1(f: fn() -> Array) -> BigPacked1 {\n // CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n-// CHECK: call void %{{.*}}(%Array* noalias nocapture sret{{.*}} dereferenceable(32) [[ALLOCA]])\n+// CHECK: call void %{{.*}}(%Array* noalias nocapture noundef sret{{.*}} dereferenceable(32) [[ALLOCA]])\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 %{{.*}}, i8* align 4 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n     // check that calls whose destination is a field of a packed struct\n     // go through an alloca rather than calling the function with an\n@@ -64,7 +64,7 @@ pub fn call_pkd1(f: fn() -> Array) -> BigPacked1 {\n #[no_mangle]\n pub fn call_pkd2(f: fn() -> Array) -> BigPacked2 {\n // CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n-// CHECK: call void %{{.*}}(%Array* noalias nocapture sret{{.*}} dereferenceable(32) [[ALLOCA]])\n+// CHECK: call void %{{.*}}(%Array* noalias nocapture noundef sret{{.*}} dereferenceable(32) [[ALLOCA]])\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* align 2 %{{.*}}, i8* align 4 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n     // check that calls whose destination is a field of a packed struct\n     // go through an alloca rather than calling the function with an"}, {"sha": "c67406ea69338b1242040abe534e6057ce0edc6c", "filename": "src/test/codegen/riscv-abi/riscv64-lp64-lp64f-lp64d-abi.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64-lp64f-lp64d-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64-lp64f-lp64d-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64-lp64f-lp64d-abi.rs?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -1,15 +1,21 @@\n-//\n-// compile-flags: -C no-prepopulate-passes\n-// only-riscv64\n-// only-linux\n+// compile-flags: --target riscv64gc-unknown-linux-gnu -C no-prepopulate-passes\n+// needs-llvm-components: riscv\n+\n #![crate_type = \"lib\"]\n+#![no_core]\n+#![feature(no_core, lang_items)]\n #![allow(improper_ctypes)]\n \n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n // CHECK: define void @f_void()\n #[no_mangle]\n pub extern \"C\" fn f_void() {}\n \n-// CHECK: define zeroext i1 @f_scalar_0(i1 zeroext %a)\n+// CHECK: define noundef zeroext i1 @f_scalar_0(i1 noundef zeroext %a)\n #[no_mangle]\n pub extern \"C\" fn f_scalar_0(a: bool) -> bool {\n     a\n@@ -70,8 +76,6 @@ pub struct Tiny {\n // CHECK: define void @f_agg_tiny(i64 %0)\n #[no_mangle]\n pub extern \"C\" fn f_agg_tiny(mut e: Tiny) {\n-    e.a += e.b;\n-    e.c += e.d;\n }\n \n // CHECK: define i64 @f_agg_tiny_ret()\n@@ -89,14 +93,12 @@ pub struct Small {\n // CHECK: define void @f_agg_small([2 x i64] %0)\n #[no_mangle]\n pub extern \"C\" fn f_agg_small(mut x: Small) {\n-    x.a += unsafe { *x.b };\n-    x.b = &mut x.a;\n }\n \n // CHECK: define [2 x i64] @f_agg_small_ret()\n #[no_mangle]\n pub extern \"C\" fn f_agg_small_ret() -> Small {\n-    Small { a: 1, b: core::ptr::null_mut() }\n+    Small { a: 1, b: 0 as *mut _ }\n }\n \n #[repr(C)]\n@@ -107,7 +109,6 @@ pub struct SmallAligned {\n // CHECK: define void @f_agg_small_aligned(i128 %0)\n #[no_mangle]\n pub extern \"C\" fn f_agg_small_aligned(mut x: SmallAligned) {\n-    x.a += x.a;\n }\n \n #[repr(C)]\n@@ -121,7 +122,6 @@ pub struct Large {\n // CHECK: define void @f_agg_large(%Large* {{.*}}%x)\n #[no_mangle]\n pub extern \"C\" fn f_agg_large(mut x: Large) {\n-    x.a = x.b + x.c + x.d;\n }\n \n // CHECK: define void @f_agg_large_ret(%Large* {{.*}}sret{{.*}}, i32 signext %i, i8 signext %j)\n@@ -172,7 +172,7 @@ pub unsafe extern \"C\" fn f_va_caller() {\n         4.0f64,\n         5.0f64,\n         Tiny { a: 1, b: 2, c: 3, d: 4 },\n-        Small { a: 10, b: core::ptr::null_mut() },\n+        Small { a: 10, b: 0 as *mut _ },\n         SmallAligned { a: 11 },\n         Large { a: 12, b: 13, c: 14, d: 15 },\n     );"}, {"sha": "264f28fdb5feea5e115473b341f18a52eec08de5", "filename": "src/test/codegen/scalar-pair-bool.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -2,25 +2,25 @@\n \n #![crate_type = \"lib\"]\n \n-// CHECK: define{{.*}}{ i8, i8 } @pair_bool_bool(i1 zeroext %pair.0, i1 zeroext %pair.1)\n+// CHECK: define{{.*}}{ i8, i8 } @pair_bool_bool(i1 noundef zeroext %pair.0, i1 noundef zeroext %pair.1)\n #[no_mangle]\n pub fn pair_bool_bool(pair: (bool, bool)) -> (bool, bool) {\n     pair\n }\n \n-// CHECK: define{{.*}}{ i8, i32 } @pair_bool_i32(i1 zeroext %pair.0, i32 %pair.1)\n+// CHECK: define{{.*}}{ i8, i32 } @pair_bool_i32(i1 noundef zeroext %pair.0, i32 %pair.1)\n #[no_mangle]\n pub fn pair_bool_i32(pair: (bool, i32)) -> (bool, i32) {\n     pair\n }\n \n-// CHECK: define{{.*}}{ i32, i8 } @pair_i32_bool(i32 %pair.0, i1 zeroext %pair.1)\n+// CHECK: define{{.*}}{ i32, i8 } @pair_i32_bool(i32 %pair.0, i1 noundef zeroext %pair.1)\n #[no_mangle]\n pub fn pair_i32_bool(pair: (i32, bool)) -> (i32, bool) {\n     pair\n }\n \n-// CHECK: define{{.*}}{ i8, i8 } @pair_and_or(i1 zeroext %_1.0, i1 zeroext %_1.1)\n+// CHECK: define{{.*}}{ i8, i8 } @pair_and_or(i1 noundef zeroext %_1.0, i1 noundef zeroext %_1.1)\n #[no_mangle]\n pub fn pair_and_or((a, b): (bool, bool)) -> (bool, bool) {\n     // Make sure it can operate directly on the unpacked args\n@@ -30,7 +30,7 @@ pub fn pair_and_or((a, b): (bool, bool)) -> (bool, bool) {\n     (a && b, a || b)\n }\n \n-// CHECK: define{{.*}}void @pair_branches(i1 zeroext %_1.0, i1 zeroext %_1.1)\n+// CHECK: define{{.*}}void @pair_branches(i1 noundef zeroext %_1.0, i1 noundef zeroext %_1.1)\n #[no_mangle]\n pub fn pair_branches((a, b): (bool, bool)) {\n     // Make sure it can branch directly on the unpacked bool args"}, {"sha": "a5aeb80de85c33d42f421b95477e458592850d35", "filename": "src/test/codegen/transmute-scalar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Ftransmute-scalar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Ftransmute-scalar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ftransmute-scalar.rs?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -15,7 +15,7 @@ pub fn f32_to_bits(x: f32) -> u32 {\n     unsafe { std::mem::transmute(x) }\n }\n \n-// CHECK-LABEL: define{{.*}}i8 @bool_to_byte(i1 zeroext %b)\n+// CHECK-LABEL: define{{.*}}i8 @bool_to_byte(i1 noundef zeroext %b)\n // CHECK: %1 = zext i1 %b to i8\n // CHECK-NEXT: store i8 %1, i8* %0\n // CHECK-NEXT: %2 = load i8, i8* %0\n@@ -25,7 +25,7 @@ pub fn bool_to_byte(b: bool) -> u8 {\n     unsafe { std::mem::transmute(b) }\n }\n \n-// CHECK-LABEL: define{{.*}}zeroext i1 @byte_to_bool(i8 %byte)\n+// CHECK-LABEL: define{{.*}}noundef zeroext i1 @byte_to_bool(i8 %byte)\n // CHECK: %1 = trunc i8 %byte to i1\n // CHECK-NEXT: %2 = zext i1 %1 to i8\n // CHECK-NEXT: store i8 %2, i8* %0"}, {"sha": "bb87d263bdf3d2f1e6b9daf97d701e309c009134", "filename": "src/test/codegen/union-abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Funion-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8/src%2Ftest%2Fcodegen%2Funion-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funion-abi.rs?ref=5c30d6568383916ce97cdf20ceb61a8b9e5bb5a8", "patch": "@@ -75,7 +75,7 @@ pub union CUnionU128x2{a:(u128, u128)}\n pub fn test_CUnionU128x2(_: CUnionU128x2) { loop {} }\n \n pub union UnionBool { b:bool }\n-// CHECK: define zeroext i1 @test_UnionBool(i8 %b)\n+// CHECK: define noundef zeroext i1 @test_UnionBool(i8 %b)\n #[no_mangle]\n pub fn test_UnionBool(b: UnionBool) -> bool { unsafe { b.b }  }\n // CHECK: %0 = trunc i8 %b to i1"}]}