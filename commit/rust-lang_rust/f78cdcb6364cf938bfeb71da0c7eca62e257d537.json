{"sha": "f78cdcb6364cf938bfeb71da0c7eca62e257d537", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3OGNkY2I2MzY0Y2Y5MzhiZmViNzFkYTBjN2VjYTYyZTI1N2Q1Mzc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-02T18:37:37Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-02T21:31:39Z"}, "message": "Removing explicit uses of + mode\n\nThis removes most explicit uses of the + argument mode. Pending a\nsnapshot, I had to remove the forbid(deprecated_modes) pragma from\na bunch of files. I'll put it back!\n\n+ mode still has to be used in a few places for functions that get\nmoved (see task.rs)\n\nThe changes outside core and std are due to the to_bytes trait and\nmaking the compiler (with legacy modes on) agree with the libraries\n(with legacy modes off) about modes.", "tree": {"sha": "cb3f93224e4757b5f77709e576ca6f24ce0981ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb3f93224e4757b5f77709e576ca6f24ce0981ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f78cdcb6364cf938bfeb71da0c7eca62e257d537", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f78cdcb6364cf938bfeb71da0c7eca62e257d537", "html_url": "https://github.com/rust-lang/rust/commit/f78cdcb6364cf938bfeb71da0c7eca62e257d537", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f78cdcb6364cf938bfeb71da0c7eca62e257d537/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5042d58ee86af13b6910fa1884b7c1fe9423ae7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5042d58ee86af13b6910fa1884b7c1fe9423ae7", "html_url": "https://github.com/rust-lang/rust/commit/a5042d58ee86af13b6910fa1884b7c1fe9423ae7"}], "stats": {"total": 558, "additions": 282, "deletions": 276}, "files": [{"sha": "7d410c0337add1532b467aa7d6c5a45d976864d7", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -1,7 +1,7 @@\n //! Managed vectors\n \n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use cast::transmute;\n@@ -48,7 +48,7 @@ pub pure fn capacity<T>(v: @[const T]) -> uint {\n  */\n #[inline(always)]\n pub pure fn build_sized<A>(size: uint,\n-                           builder: &fn(push: pure fn(+v: A))) -> @[A] {\n+                           builder: &fn(push: pure fn(v: A))) -> @[A] {\n     let mut vec: @[const A] = @[];\n     unsafe { raw::reserve(&mut vec, size); }\n     builder(|+x| unsafe { raw::push(&mut vec, move x) });\n@@ -66,7 +66,7 @@ pub pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A>(builder: &fn(push: pure fn(+v: A))) -> @[A] {\n+pub pure fn build<A>(builder: &fn(push: pure fn(v: A))) -> @[A] {\n     build_sized(4, builder)\n }\n \n@@ -83,8 +83,8 @@ pub pure fn build<A>(builder: &fn(push: pure fn(+v: A))) -> @[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized_opt<A>(+size: Option<uint>,\n-                               builder: &fn(push: pure fn(+v: A))) -> @[A] {\n+pub pure fn build_sized_opt<A>(size: Option<uint>,\n+                               builder: &fn(push: pure fn(v: A))) -> @[A] {\n     build_sized(size.get_default(4), builder)\n }\n \n@@ -126,7 +126,7 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pub pure fn from_elem<T: Copy>(n_elts: uint, +t: T) -> @[T] {\n+pub pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(copy t); i += 1u; }\n@@ -166,7 +166,7 @@ pub mod raw {\n     }\n \n     #[inline(always)]\n-    pub unsafe fn push<T>(v: &mut @[const T], +initval: T) {\n+    pub unsafe fn push<T>(v: &mut @[const T], initval: T) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n@@ -178,7 +178,7 @@ pub mod raw {\n     }\n     // This doesn't bother to make sure we have space.\n     #[inline(always)] // really pretty please\n-    pub unsafe fn push_fast<T>(v: &mut @[const T], +initval: T) {\n+    pub unsafe fn push_fast<T>(v: &mut @[const T], initval: T) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n         let fill = (**repr).unboxed.fill;\n         (**repr).unboxed.fill += sys::size_of::<T>();\n@@ -187,7 +187,7 @@ pub mod raw {\n         rusti::move_val_init(*p, move initval);\n     }\n \n-    pub unsafe fn push_slow<T>(v: &mut @[const T], +initval: T) {\n+    pub unsafe fn push_slow<T>(v: &mut @[const T], initval: T) {\n         reserve_at_least(v, v.len() + 1u);\n         push_fast(v, move initval);\n     }"}, {"sha": "f4f0d7b61044c7ad8345825a0cc26ebcfcdd44d3", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -21,15 +21,15 @@ pub unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n  * reinterpret_cast on managed pointer types.\n  */\n #[inline(always)]\n-pub unsafe fn forget<T>(+thing: T) { rusti::forget(move thing); }\n+pub unsafe fn forget<T>(thing: T) { rusti::forget(move thing); }\n \n /**\n  * Force-increment the reference count on a shared box. If used\n  * carelessly, this can leak the box. Use this in conjunction with transmute\n  * and/or reinterpret_cast when such calls would otherwise scramble a box's\n  * reference count\n  */\n-pub unsafe fn bump_box_refcount<T>(+t: @T) { forget(move t); }\n+pub unsafe fn bump_box_refcount<T>(t: @T) { forget(move t); }\n \n /**\n  * Transform a value of one type into a value of another type.\n@@ -40,41 +40,41 @@ pub unsafe fn bump_box_refcount<T>(+t: @T) { forget(move t); }\n  *     assert transmute(\"L\") == ~[76u8, 0u8];\n  */\n #[inline(always)]\n-pub unsafe fn transmute<L, G>(+thing: L) -> G {\n+pub unsafe fn transmute<L, G>(thing: L) -> G {\n     let newthing: G = reinterpret_cast(&thing);\n     forget(move thing);\n     move newthing\n }\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n-pub unsafe fn transmute_mut<T>(+ptr: &a/T) -> &a/mut T { transmute(move ptr) }\n+pub unsafe fn transmute_mut<T>(ptr: &a/T) -> &a/mut T { transmute(move ptr) }\n \n /// Coerce a mutable reference to be immutable.\n #[inline(always)]\n-pub unsafe fn transmute_immut<T>(+ptr: &a/mut T) -> &a/T {\n+pub unsafe fn transmute_immut<T>(ptr: &a/mut T) -> &a/T {\n     transmute(move ptr)\n }\n \n /// Coerce a borrowed pointer to have an arbitrary associated region.\n #[inline(always)]\n-pub unsafe fn transmute_region<T>(+ptr: &a/T) -> &b/T { transmute(move ptr) }\n+pub unsafe fn transmute_region<T>(ptr: &a/T) -> &b/T { transmute(move ptr) }\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n-pub unsafe fn transmute_mut_unsafe<T>(+ptr: *const T) -> *mut T {\n+pub unsafe fn transmute_mut_unsafe<T>(ptr: *const T) -> *mut T {\n     transmute(ptr)\n }\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n-pub unsafe fn transmute_immut_unsafe<T>(+ptr: *const T) -> *T {\n+pub unsafe fn transmute_immut_unsafe<T>(ptr: *const T) -> *T {\n     transmute(ptr)\n }\n \n /// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n #[inline(always)]\n-pub unsafe fn transmute_mut_region<T>(+ptr: &a/mut T) -> &b/mut T {\n+pub unsafe fn transmute_mut_region<T>(ptr: &a/mut T) -> &b/mut T {\n     transmute(move ptr)\n }\n "}, {"sha": "64c38d13e4934b11ee92a7eb0f9dc7a6df8bbd5b", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -32,8 +32,8 @@ will once again be the preferred module for intertask communication.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[warn(deprecated_mode)];\n+// NB: transitionary, de-mode-ing\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use either::Either;\n@@ -75,7 +75,7 @@ pub fn Port<T: Send>() -> Port<T> {\n impl<T: Send> Port<T> {\n \n     fn chan() -> Chan<T> { Chan(self) }\n-    fn send(+v: T) { self.chan().send(move v) }\n+    fn send(v: T) { self.chan().send(move v) }\n     fn recv() -> T { recv(self) }\n     fn peek() -> bool { peek(self) }\n \n@@ -84,7 +84,7 @@ impl<T: Send> Port<T> {\n impl<T: Send> Chan<T> {\n \n     fn chan() -> Chan<T> { self }\n-    fn send(+v: T) { send(self, move v) }\n+    fn send(v: T) { send(self, move v) }\n     fn recv() -> T { recv_chan(self) }\n     fn peek() -> bool { peek_chan(self) }\n \n@@ -174,7 +174,7 @@ pub fn Chan<T: Send>(&&p: Port<T>) -> Chan<T> {\n  * Sends data over a channel. The sent data is moved into the channel,\n  * whereupon the caller loses access to it.\n  */\n-pub fn send<T: Send>(ch: Chan<T>, +data: T) {\n+pub fn send<T: Send>(ch: Chan<T>, data: T) {\n     let Chan_(p) = ch;\n     let data_ptr = ptr::addr_of(&data) as *();\n     let res = rustrt::rust_port_id_send(p, data_ptr);"}, {"sha": "17ddd6ea73b7c6ce260e39f444535703e308d6c1", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -9,7 +9,7 @@ Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n */\n \n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n type DListLink<T> = Option<DListNode<T>>;\n@@ -80,7 +80,7 @@ impl<T> DListNode<T> {\n }\n \n /// Creates a new dlist node with the given data.\n-pure fn new_dlist_node<T>(+data: T) -> DListNode<T> {\n+pure fn new_dlist_node<T>(data: T) -> DListNode<T> {\n     DListNode(@{data: move data, mut linked: false,\n                  mut prev: None, mut next: None})\n }\n@@ -91,13 +91,13 @@ pure fn DList<T>() -> DList<T> {\n }\n \n /// Creates a new dlist with a single element\n-pub pure fn from_elem<T>(+data: T) -> DList<T> {\n+pub pure fn from_elem<T>(data: T) -> DList<T> {\n     let list = DList();\n     unsafe { list.push(move data); }\n     list\n }\n \n-pub fn from_vec<T: Copy>(+vec: &[T]) -> DList<T> {\n+pub fn from_vec<T: Copy>(vec: &[T]) -> DList<T> {\n     do vec::foldl(DList(), vec) |list,data| {\n         list.push(*data); // Iterating left-to-right -- add newly to the tail.\n         list\n@@ -115,7 +115,7 @@ fn concat<T>(lists: DList<DList<T>>) -> DList<T> {\n }\n \n priv impl<T> DList<T> {\n-    pure fn new_link(+data: T) -> DListLink<T> {\n+    pure fn new_link(data: T) -> DListLink<T> {\n         Some(DListNode(@{data: move data, mut linked: true,\n                           mut prev: None, mut next: None}))\n     }\n@@ -142,7 +142,7 @@ priv impl<T> DList<T> {\n     // Link two nodes together. If either of them are 'none', also sets\n     // the head and/or tail pointers appropriately.\n     #[inline(always)]\n-    fn link(+before: DListLink<T>, +after: DListLink<T>) {\n+    fn link(before: DListLink<T>, after: DListLink<T>) {\n         match before {\n             Some(neighbour) => neighbour.next = after,\n             None            => self.hd        = after\n@@ -163,12 +163,12 @@ priv impl<T> DList<T> {\n         self.size -= 1;\n     }\n \n-    fn add_head(+nobe: DListLink<T>) {\n+    fn add_head(nobe: DListLink<T>) {\n         self.link(nobe, self.hd); // Might set tail too.\n         self.hd = nobe;\n         self.size += 1;\n     }\n-    fn add_tail(+nobe: DListLink<T>) {\n+    fn add_tail(nobe: DListLink<T>) {\n         self.link(self.tl, nobe); // Might set head too.\n         self.tl = nobe;\n         self.size += 1;\n@@ -198,27 +198,27 @@ impl<T> DList<T> {\n     pure fn is_not_empty() -> bool { self.len() != 0 }\n \n     /// Add data to the head of the list. O(1).\n-    fn push_head(+data: T) {\n+    fn push_head(data: T) {\n         self.add_head(self.new_link(move data));\n     }\n     /**\n      * Add data to the head of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_head_n(+data: T) -> DListNode<T> {\n+    fn push_head_n(data: T) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.add_head(nobe);\n         option::get(&nobe)\n     }\n     /// Add data to the tail of the list. O(1).\n-    fn push(+data: T) {\n+    fn push(data: T) {\n         self.add_tail(self.new_link(move data));\n     }\n     /**\n      * Add data to the tail of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_n(+data: T) -> DListNode<T> {\n+    fn push_n(data: T) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.add_tail(nobe);\n         option::get(&nobe)\n@@ -227,7 +227,7 @@ impl<T> DList<T> {\n      * Insert data into the middle of the list, left of the given node.\n      * O(1).\n      */\n-    fn insert_before(+data: T, neighbour: DListNode<T>) {\n+    fn insert_before(data: T, neighbour: DListNode<T>) {\n         self.insert_left(self.new_link(move data), neighbour);\n     }\n     /**\n@@ -242,7 +242,7 @@ impl<T> DList<T> {\n      * Insert data in the middle of the list, left of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_before_n(+data: T, neighbour: DListNode<T>) -> DListNode<T> {\n+    fn insert_before_n(data: T, neighbour: DListNode<T>) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.insert_left(nobe, neighbour);\n         option::get(&nobe)\n@@ -251,7 +251,7 @@ impl<T> DList<T> {\n      * Insert data into the middle of the list, right of the given node.\n      * O(1).\n      */\n-    fn insert_after(+data: T, neighbour: DListNode<T>) {\n+    fn insert_after(data: T, neighbour: DListNode<T>) {\n         self.insert_right(neighbour, self.new_link(move data));\n     }\n     /**\n@@ -266,7 +266,7 @@ impl<T> DList<T> {\n      * Insert data in the middle of the list, right of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_after_n(+data: T, neighbour: DListNode<T>) -> DListNode<T> {\n+    fn insert_after_n(data: T, neighbour: DListNode<T>) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.insert_right(neighbour, nobe);\n         option::get(&nobe)"}, {"sha": "a2a709087971f52022720dcddb7903b566157a8d", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -10,7 +10,7 @@ Note that recursive use is not permitted.\n */\n \n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use cast::reinterpret_cast;\n@@ -61,17 +61,17 @@ pub fn DVec<A>() -> DVec<A> {\n }\n \n /// Creates a new dvec with a single element\n-pub fn from_elem<A>(+e: A) -> DVec<A> {\n+pub fn from_elem<A>(e: A) -> DVec<A> {\n     DVec_({mut data: ~[move e]})\n }\n \n /// Creates a new dvec with the contents of a vector\n-pub fn from_vec<A>(+v: ~[A]) -> DVec<A> {\n+pub fn from_vec<A>(v: ~[A]) -> DVec<A> {\n     DVec_({mut data: move v})\n }\n \n /// Consumes the vector and returns its contents\n-pub fn unwrap<A>(+d: DVec<A>) -> ~[A] {\n+pub fn unwrap<A>(d: DVec<A>) -> ~[A] {\n     let DVec_({data: v}) <- d;\n     move v\n }\n@@ -87,7 +87,7 @@ priv impl<A> DVec<A> {\n     }\n \n     #[inline(always)]\n-    fn check_out<B>(f: &fn(+v: ~[A]) -> B) -> B {\n+    fn check_out<B>(f: &fn(v: ~[A]) -> B) -> B {\n         unsafe {\n             let mut data = cast::reinterpret_cast(&null::<()>());\n             data <-> self.data;\n@@ -98,7 +98,7 @@ priv impl<A> DVec<A> {\n     }\n \n     #[inline(always)]\n-    fn give_back(+data: ~[A]) {\n+    fn give_back(data: ~[A]) {\n         unsafe {\n             self.data = move data;\n         }\n@@ -120,7 +120,7 @@ impl<A> DVec<A> {\n      * and return a new vector to replace it with.\n      */\n     #[inline(always)]\n-    fn swap(f: &fn(+v: ~[A]) -> ~[A]) {\n+    fn swap(f: &fn(v: ~[A]) -> ~[A]) {\n         self.check_out(|v| self.give_back(f(move v)))\n     }\n \n@@ -130,7 +130,7 @@ impl<A> DVec<A> {\n      * and return a new vector to replace it with.\n      */\n     #[inline(always)]\n-    fn swap_mut(f: &fn(+v: ~[mut A]) -> ~[mut A]) {\n+    fn swap_mut(f: &fn(v: ~[mut A]) -> ~[mut A]) {\n         do self.swap |v| {\n             vec::from_mut(f(vec::to_mut(move v)))\n         }\n@@ -148,7 +148,7 @@ impl<A> DVec<A> {\n     }\n \n     /// Overwrite the current contents\n-    fn set(+w: ~[A]) {\n+    fn set(w: ~[A]) {\n         self.check_not_borrowed();\n         self.data <- w;\n     }\n@@ -164,7 +164,7 @@ impl<A> DVec<A> {\n     }\n \n     /// Insert a single item at the front of the list\n-    fn unshift(+t: A) {\n+    fn unshift(t: A) {\n         unsafe {\n             let mut data = cast::reinterpret_cast(&null::<()>());\n             data <-> self.data;\n@@ -178,7 +178,7 @@ impl<A> DVec<A> {\n     }\n \n     /// Append a single item to the end of the list\n-    fn push(+t: A) {\n+    fn push(t: A) {\n         self.check_not_borrowed();\n         self.data.push(move t);\n     }\n@@ -295,7 +295,7 @@ impl<A: Copy> DVec<A> {\n     }\n \n     /// Overwrites the contents of the element at `idx` with `a`\n-    fn set_elt(idx: uint, +a: A) {\n+    fn set_elt(idx: uint, a: A) {\n         self.check_not_borrowed();\n         self.data[idx] = a;\n     }\n@@ -305,7 +305,7 @@ impl<A: Copy> DVec<A> {\n      * growing the vector if necessary.  New elements will be initialized\n      * with `initval`\n      */\n-    fn grow_set_elt(idx: uint, initval: &A, +val: A) {\n+    fn grow_set_elt(idx: uint, initval: &A, val: A) {\n         do self.swap |v| {\n             let mut v = move v;\n             v.grow_set(idx, initval, val);\n@@ -354,7 +354,7 @@ impl<A: Copy> DVec<A> {\n }\n \n impl<A:Copy> DVec<A>: Index<uint,A> {\n-    pure fn index(+idx: uint) -> A {\n+    pure fn index(idx: uint) -> A {\n         self.get_elt(idx)\n     }\n }"}, {"sha": "c64cd25e4813a279ea786e8b3d85b4144b1de3cb", "filename": "src/libcore/either.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n //! A type that represents one of two alternatives\n@@ -114,15 +114,16 @@ pub pure fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n     match *eith { Right(_) => true, _ => false }\n }\n \n-pub pure fn unwrap_left<T,U>(+eith: Either<T,U>) -> T {\n+// tjc: fix the next two after a snapshot\n+pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n     //! Retrieves the value in the left branch. Fails if the either is Right.\n \n     match move eith {\n         Left(move x) => move x, Right(_) => fail ~\"either::unwrap_left Right\"\n     }\n }\n \n-pub pure fn unwrap_right<T,U>(+eith: Either<T,U>) -> U {\n+pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     //! Retrieves the value in the right branch. Fails if the either is Left.\n \n     match move eith {"}, {"sha": "e10ff4bac714798b381ede662f028c41700d942d", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -87,7 +87,7 @@ mod ct {\n         let mut pieces: ~[Piece] = ~[];\n         let lim = str::len(s);\n         let mut buf = ~\"\";\n-        fn flush_buf(+buf: ~str, pieces: &mut ~[Piece]) -> ~str {\n+        fn flush_buf(buf: ~str, pieces: &mut ~[Piece]) -> ~str {\n             if buf.len() > 0 {\n                 let piece = PieceString(move buf);\n                 pieces.push(move piece);\n@@ -323,7 +323,7 @@ mod rt {\n         let mut s = str::from_char(c);\n         return unsafe { pad(cv, s, PadNozero) };\n     }\n-    pure fn conv_str(cv: Conv, +s: &str) -> ~str {\n+    pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n@@ -405,7 +405,7 @@ mod rt {\n         pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n     }\n \n-    fn pad(cv: Conv, +s: ~str, mode: PadMode) -> ~str {\n+    fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n         let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n           CountImplied => return s,\n@@ -518,7 +518,7 @@ mod rt2 {\n         let mut s = str::from_char(c);\n         return unsafe { pad(cv, s, PadNozero) };\n     }\n-    pure fn conv_str(cv: Conv, +s: &str) -> ~str {\n+    pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n@@ -600,7 +600,7 @@ mod rt2 {\n         pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n     }\n \n-    fn pad(cv: Conv, +s: ~str, mode: PadMode) -> ~str {\n+    fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n         let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n           CountImplied => return s,"}, {"sha": "11b6a2c01354adc562e11fff55c169a60c7671ef", "filename": "src/libcore/future.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n /*!\n@@ -55,7 +55,7 @@ impl<A> Future<A> {\n     }\n }\n \n-pub fn from_value<A>(+val: A) -> Future<A> {\n+pub fn from_value<A>(val: A) -> Future<A> {\n     /*!\n      * Create a future from a value\n      *\n@@ -66,7 +66,7 @@ pub fn from_value<A>(+val: A) -> Future<A> {\n     Future {state: Forced(~(move val))}\n }\n \n-pub fn from_port<A:Send>(+port: future_pipe::client::waiting<A>) ->\n+pub fn from_port<A:Send>(port: future_pipe::client::waiting<A>) ->\n         Future<A> {\n     /*!\n      * Create a future from a port"}, {"sha": "6942d38d5d3420e3f824902e2bb6b943c0ec4fbb", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use T = inst::T;\n@@ -231,7 +231,7 @@ fn test_to_str() {\n \n #[test]\n fn test_interfaces() {\n-    fn test<U:num::Num cmp::Eq>(+ten: U) {\n+    fn test<U:num::Num cmp::Eq>(ten: U) {\n         assert (ten.to_int() == 10);\n \n         let two: U = from_int(2);"}, {"sha": "2efc96933da85c374ab354344df8d61135afd930", "filename": "src/libcore/io.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -813,7 +813,7 @@ pub mod fsync {\n         }\n     }\n \n-    pub fn Res<t: Copy>(+arg: Arg<t>) -> Res<t>{\n+    pub fn Res<t: Copy>(arg: Arg<t>) -> Res<t>{\n         Res {\n             arg: move arg\n         }\n@@ -822,28 +822,28 @@ pub mod fsync {\n     pub type Arg<t> = {\n         val: t,\n         opt_level: Option<Level>,\n-        fsync_fn: fn@(+f: t, Level) -> int\n+        fsync_fn: fn@(f: t, Level) -> int\n     };\n \n     // fsync file after executing blk\n     // FIXME (#2004) find better way to create resources within lifetime of\n     // outer res\n     pub fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n-                         blk: fn(+v: Res<*libc::FILE>)) {\n+                         blk: fn(v: Res<*libc::FILE>)) {\n         blk(move Res({\n             val: file.f, opt_level: opt_level,\n-            fsync_fn: fn@(+file: *libc::FILE, l: Level) -> int {\n+            fsync_fn: fn@(file: *libc::FILE, l: Level) -> int {\n                 return os::fsync_fd(libc::fileno(file), l) as int;\n             }\n         }));\n     }\n \n     // fsync fd after executing blk\n     pub fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n-                       blk: fn(+v: Res<fd_t>)) {\n+                       blk: fn(v: Res<fd_t>)) {\n         blk(move Res({\n             val: fd.fd, opt_level: opt_level,\n-            fsync_fn: fn@(+fd: fd_t, l: Level) -> int {\n+            fsync_fn: fn@(fd: fd_t, l: Level) -> int {\n                 return os::fsync_fd(fd, l) as int;\n             }\n         }));\n@@ -853,11 +853,11 @@ pub mod fsync {\n     pub trait FSyncable { fn fsync(l: Level) -> int; }\n \n     // Call o.fsync after executing blk\n-    pub fn obj_sync(+o: FSyncable, opt_level: Option<Level>,\n-                    blk: fn(+v: Res<FSyncable>)) {\n+    pub fn obj_sync(o: FSyncable, opt_level: Option<Level>,\n+                    blk: fn(v: Res<FSyncable>)) {\n         blk(Res({\n             val: o, opt_level: opt_level,\n-            fsync_fn: fn@(+o: FSyncable, l: Level) -> int {\n+            fsync_fn: fn@(o: FSyncable, l: Level) -> int {\n                 return o.fsync(l);\n             }\n         }));"}, {"sha": "09bfe2eff36a5470ccd25519815e588cbd7443d6", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -16,7 +16,7 @@ impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n     pure fn eachi(blk: fn(uint, v: &A) -> bool) { iter::eachi(&self, blk) }\n     pure fn all(blk: fn(&A) -> bool) -> bool { iter::all(&self, blk) }\n     pure fn any(blk: fn(&A) -> bool) -> bool { iter::any(&self, blk) }\n-    pure fn foldl<B>(+b0: B, blk: fn(&B, &A) -> B) -> B {\n+    pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B {\n         iter::foldl(&self, move b0, blk)\n     }\n     pure fn position(f: fn(&A) -> bool) -> Option<uint> {\n@@ -30,20 +30,20 @@ impl<A: Eq> IMPL_T<A>: iter::EqIter<A> {\n }\n \n impl<A: Copy> IMPL_T<A>: iter::CopyableIter<A> {\n-    pure fn filter_to_vec(pred: fn(+a: A) -> bool) -> ~[A] {\n+    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A] {\n         iter::filter_to_vec(&self, pred)\n     }\n-    pure fn map_to_vec<B>(op: fn(+v: A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B] {\n         iter::map_to_vec(&self, op)\n     }\n     pure fn to_vec() -> ~[A] { iter::to_vec(&self) }\n \n-    pure fn flat_map_to_vec<B:Copy,IB:BaseIter<B>>(op: fn(+a: A) -> IB)\n+    pure fn flat_map_to_vec<B:Copy,IB:BaseIter<B>>(op: fn(a: A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(&self, op)\n     }\n \n-    pure fn find(p: fn(+a: A) -> bool) -> Option<A> { iter::find(&self, p) }\n+    pure fn find(p: fn(a: A) -> bool) -> Option<A> { iter::find(&self, p) }\n }\n \n impl<A: Copy Ord> IMPL_T<A>: iter::CopyableOrderedIter<A> {"}, {"sha": "bf3e91f7071925b5d87533811323f1fb881880e4", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -18,7 +18,7 @@ pub trait ExtendedIter<A> {\n     pure fn eachi(blk: fn(uint, v: &A) -> bool);\n     pure fn all(blk: fn(&A) -> bool) -> bool;\n     pure fn any(blk: fn(&A) -> bool) -> bool;\n-    pure fn foldl<B>(+b0: B, blk: fn(&B, &A) -> B) -> B;\n+    pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B;\n     pure fn position(f: fn(&A) -> bool) -> Option<uint>;\n }\n \n@@ -36,10 +36,10 @@ pub trait TimesIx{\n }\n \n pub trait CopyableIter<A:Copy> {\n-    pure fn filter_to_vec(pred: fn(+a: A) -> bool) -> ~[A];\n-    pure fn map_to_vec<B>(op: fn(+v: A) -> B) -> ~[B];\n+    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A];\n+    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B];\n     pure fn to_vec() -> ~[A];\n-    pure fn find(p: fn(+a: A) -> bool) -> Option<A>;\n+    pure fn find(p: fn(a: A) -> bool) -> Option<A>;\n }\n \n pub trait CopyableOrderedIter<A:Copy Ord> {\n@@ -64,7 +64,7 @@ pub trait Buildable<A> {\n      *             onto the sequence being constructed.\n      */\n      static pure fn build_sized(size: uint,\n-                                builder: fn(push: pure fn(+v: A))) -> self;\n+                                builder: fn(push: pure fn(v: A))) -> self;\n }\n \n pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n@@ -93,7 +93,7 @@ pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n }\n \n pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n-    self: &IA, prd: fn(+a: A) -> bool) -> ~[A] {\n+    self: &IA, prd: fn(a: A) -> bool) -> ~[A] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n             if prd(*a) { push(*a); }\n@@ -102,7 +102,7 @@ pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n }\n \n pub pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: &IA,\n-                                                op: fn(+v: A) -> B)\n+                                                op: fn(v: A) -> B)\n     -> ~[B] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n@@ -112,8 +112,7 @@ pub pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: &IA,\n }\n \n pub pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n-    self: &IA, op: fn(+a: A) -> IB) -> ~[B] {\n-\n+    self: &IA, op: fn(a: A) -> IB) -> ~[B] {\n     do vec::build |push| {\n         for self.each |a| {\n             for op(*a).each |b| {\n@@ -123,7 +122,7 @@ pub pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n     }\n }\n \n-pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, +b0: B,\n+pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n                                       blk: fn(&B, &A) -> B)\n     -> B {\n     let mut b <- b0;\n@@ -206,7 +205,7 @@ pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n }\n \n pub pure fn find<A: Copy,IA:BaseIter<A>>(self: &IA,\n-                                     p: fn(+a: A) -> bool) -> Option<A> {\n+                                     p: fn(a: A) -> bool) -> Option<A> {\n     for self.each |i| {\n         if p(*i) { return Some(*i) }\n     }\n@@ -226,7 +225,7 @@ pub pure fn find<A: Copy,IA:BaseIter<A>>(self: &IA,\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(+v: A)))\n+pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(v: A)))\n     -> B {\n     build_sized(4, builder)\n }\n@@ -247,7 +246,7 @@ pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(+v: A)))\n #[inline(always)]\n pub pure fn build_sized_opt<A,B: Buildable<A>>(\n     size: Option<uint>,\n-    builder: fn(push: pure fn(+v: A))) -> B {\n+    builder: fn(push: pure fn(v: A))) -> B {\n \n     build_sized(size.get_default(4), builder)\n }\n@@ -285,7 +284,7 @@ pub pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint,\n  * to the value `t`.\n  */\n pub pure fn from_elem<T: Copy,BT: Buildable<T>>(n_elts: uint,\n-                                                +t: T) -> BT {\n+                                                t: T) -> BT {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0;\n         while i < n_elts { push(t); i += 1; }"}, {"sha": "5948c630cd85d6bda9e5e885abc35786b6970bf9", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -8,8 +8,7 @@ dynamic checks: your program will fail if you attempt to perform\n mutation when the data structure should be immutable.\n \n */\n-\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use util::with;\n@@ -24,11 +23,11 @@ struct Data<T> {\n \n pub type Mut<T> = Data<T>;\n \n-pub fn Mut<T>(+t: T) -> Mut<T> {\n+pub fn Mut<T>(t: T) -> Mut<T> {\n     Data {value: t, mode: ReadOnly}\n }\n \n-pub fn unwrap<T>(+m: Mut<T>) -> T {\n+pub fn unwrap<T>(m: Mut<T>) -> T {\n     // Borrowck should prevent us from calling unwrap while the value\n     // is in use, as that would be a move from a borrowed value.\n     assert (m.mode as uint) == (ReadOnly as uint);"}, {"sha": "038c117b8bed7b0a0033c10ac887e23c8be3faa7", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -77,6 +77,6 @@ pub trait Shr<RHS,Result> {\n \n #[lang=\"index\"]\n pub trait Index<Index,Result> {\n-    pure fn index(+index: Index) -> Result;\n+    pure fn index(index: Index) -> Result;\n }\n "}, {"sha": "6bd326186cb4c94cfcad278570f0318dfc30a8e7", "filename": "src/libcore/option.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -49,7 +49,7 @@ pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     }\n }\n \n-pub pure fn expect<T: Copy>(opt: &Option<T>, +reason: ~str) -> T {\n+pub pure fn expect<T: Copy>(opt: &Option<T>, reason: ~str) -> T {\n     /*!\n      * Gets the value out of an option, printing a specified message on\n      * failure\n@@ -67,17 +67,17 @@ pub pure fn map<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n     match *opt { Some(ref x) => Some(f(x)), None => None }\n }\n \n-pub pure fn map_consume<T, U>(+opt: Option<T>,\n-                              f: fn(+v: T) -> U) -> Option<U> {\n+pub pure fn map_consume<T, U>(opt: Option<T>,\n+                              f: fn(v: T) -> U) -> Option<U> {\n     /*!\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n      * copying.\n      */\n     if opt.is_some() { Some(f(option::unwrap(move opt))) } else { None }\n }\n \n-pub pure fn chain<T, U>(+opt: Option<T>,\n-                        f: fn(+t: T) -> Option<U>) -> Option<U> {\n+pub pure fn chain<T, U>(opt: Option<T>,\n+                        f: fn(t: T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content through a\n      * function that returns an option.\n@@ -101,7 +101,7 @@ pub pure fn chain_ref<T, U>(opt: &Option<T>,\n     match *opt { Some(ref x) => f(x), None => None }\n }\n \n-pub pure fn or<T>(+opta: Option<T>, +optb: Option<T>) -> Option<T> {\n+pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n     /*!\n      * Returns the leftmost some() value, or none if both are none.\n      */\n@@ -112,7 +112,7 @@ pub pure fn or<T>(+opta: Option<T>, +optb: Option<T>) -> Option<T> {\n }\n \n #[inline(always)]\n-pub pure fn while_some<T>(+x: Option<T>, blk: fn(+v: T) -> Option<T>) {\n+pub pure fn while_some<T>(x: Option<T>, blk: fn(v: T) -> Option<T>) {\n     //! Applies a function zero or more times until the result is none.\n \n     let mut opt <- x;\n@@ -133,13 +133,13 @@ pub pure fn is_some<T>(opt: &Option<T>) -> bool {\n     !is_none(opt)\n }\n \n-pub pure fn get_default<T: Copy>(opt: &Option<T>, +def: T) -> T {\n+pub pure fn get_default<T: Copy>(opt: &Option<T>, def: T) -> T {\n     //! Returns the contained value or a default\n \n     match *opt { Some(copy x) => x, None => def }\n }\n \n-pub pure fn map_default<T, U>(opt: &Option<T>, +def: U,\n+pub pure fn map_default<T, U>(opt: &Option<T>, def: U,\n                               f: fn(x: &T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n@@ -151,10 +151,8 @@ pub pure fn iter<T>(opt: &Option<T>, f: fn(x: &T)) {\n     match *opt { None => (), Some(ref t) => f(t) }\n }\n \n-// tjc: shouldn't this be - instead of +?\n-// then could get rid of some superfluous moves\n #[inline(always)]\n-pub pure fn unwrap<T>(+opt: Option<T>) -> T {\n+pub pure fn unwrap<T>(opt: Option<T>) -> T {\n     /*!\n      * Moves a value out of an option type and returns it.\n      *\n@@ -174,7 +172,7 @@ pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n     unwrap(util::replace(opt, None))\n }\n \n-pub pure fn unwrap_expect<T>(+opt: Option<T>, reason: &str) -> T {\n+pub pure fn unwrap_expect<T>(opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     if opt.is_none() { fail reason.to_unique(); }\n     unwrap(move opt)\n@@ -197,7 +195,7 @@ impl<T> &Option<T> {\n         chain_ref(self, f)\n     }\n     /// Applies a function to the contained value or returns a default\n-    pure fn map_default<U>(+def: U, f: fn(x: &T) -> U) -> U\n+    pure fn map_default<U>(def: U, f: fn(x: &T) -> U) -> U\n         { map_default(self, move def, f) }\n     /// Performs an operation on the contained value by reference\n     pure fn iter(f: fn(x: &T)) { iter(self, f) }\n@@ -216,7 +214,7 @@ impl<T: Copy> Option<T> {\n      * Fails if the value equals `none`\n      */\n     pure fn get() -> T { get(&self) }\n-    pure fn get_default(+def: T) -> T { get_default(&self, def) }\n+    pure fn get_default(def: T) -> T { get_default(&self, def) }\n     /**\n      * Gets the value out of an option, printing a specified message on\n      * failure\n@@ -225,9 +223,9 @@ impl<T: Copy> Option<T> {\n      *\n      * Fails if the value equals `none`\n      */\n-    pure fn expect(+reason: ~str) -> T { expect(&self, reason) }\n+    pure fn expect(reason: ~str) -> T { expect(&self, reason) }\n     /// Applies a function zero or more times until the result is none.\n-    pure fn while_some(blk: fn(+v: T) -> Option<T>) { while_some(self, blk) }\n+    pure fn while_some(blk: fn(v: T) -> Option<T>) { while_some(self, blk) }\n }\n \n impl<T: Eq> Option<T> : Eq {"}, {"sha": "f178502f6a0096818f07180442eb5bdeb2bea440", "filename": "src/libcore/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid\n #[forbid(deprecated_pattern)];\n \n /*!\n@@ -768,7 +768,7 @@ struct OverriddenArgs {\n     val: ~[~str]\n }\n \n-fn overridden_arg_key(+_v: @OverriddenArgs) {}\n+fn overridden_arg_key(_v: @OverriddenArgs) {}\n \n pub fn args() -> ~[~str] {\n     unsafe {\n@@ -779,7 +779,7 @@ pub fn args() -> ~[~str] {\n     }\n }\n \n-pub fn set_args(+new_args: ~[~str]) {\n+pub fn set_args(new_args: ~[~str]) {\n     unsafe {\n         let overridden_args = @OverriddenArgs { val: copy new_args };\n         task::local_data::local_data_set(overridden_arg_key, overridden_args);"}, {"sha": "e34c0db35e9d59133ea6fc94d286160ab45da7a2", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -73,7 +73,7 @@ bounded and unbounded protocols allows for less code duplication.\n */\n \n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use cmp::Eq;\n@@ -169,7 +169,7 @@ impl PacketHeader {\n         reinterpret_cast(&self.buffer)\n     }\n \n-    fn set_buffer<T: Send>(+b: ~Buffer<T>) unsafe {\n+    fn set_buffer<T: Send>(b: ~Buffer<T>) unsafe {\n         self.buffer = reinterpret_cast(&b);\n     }\n }\n@@ -227,7 +227,7 @@ pub fn packet<T: Send>() -> *Packet<T> {\n \n #[doc(hidden)]\n pub fn entangle_buffer<T: Send, Tstart: Send>(\n-    +buffer: ~Buffer<T>,\n+    buffer: ~Buffer<T>,\n     init: fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n {\n@@ -239,12 +239,12 @@ pub fn entangle_buffer<T: Send, Tstart: Send>(\n #[abi = \"rust-intrinsic\"]\n #[doc(hidden)]\n extern mod rusti {\n-    fn atomic_xchg(dst: &mut int, +src: int) -> int;\n-    fn atomic_xchg_acq(dst: &mut int, +src: int) -> int;\n-    fn atomic_xchg_rel(dst: &mut int, +src: int) -> int;\n+    fn atomic_xchg(dst: &mut int, src: int) -> int;\n+    fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n+    fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n \n-    fn atomic_xadd_acq(dst: &mut int, +src: int) -> int;\n-    fn atomic_xsub_rel(dst: &mut int, +src: int) -> int;\n+    fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n+    fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n }\n \n // If I call the rusti versions directly from a polymorphic function,\n@@ -265,7 +265,7 @@ pub fn atomic_sub_rel(dst: &mut int, src: int) -> int {\n }\n \n #[doc(hidden)]\n-pub fn swap_task(+dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n+pub fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n     // It might be worth making both acquire and release versions of\n     // this.\n     unsafe {\n@@ -304,14 +304,14 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n }\n \n #[doc(hidden)]\n-fn swap_state_acq(+dst: &mut State, src: State) -> State {\n+fn swap_state_acq(dst: &mut State, src: State) -> State {\n     unsafe {\n         transmute(rusti::atomic_xchg_acq(transmute(move dst), src as int))\n     }\n }\n \n #[doc(hidden)]\n-fn swap_state_rel(+dst: &mut State, src: State) -> State {\n+fn swap_state_rel(dst: &mut State, src: State) -> State {\n     unsafe {\n         transmute(rusti::atomic_xchg_rel(transmute(move dst), src as int))\n     }\n@@ -343,7 +343,7 @@ struct BufferResource<T: Send> {\n     }\n }\n \n-fn BufferResource<T: Send>(+b: ~Buffer<T>) -> BufferResource<T> {\n+fn BufferResource<T: Send>(b: ~Buffer<T>) -> BufferResource<T> {\n     //let p = ptr::addr_of(*b);\n     //error!(\"take %?\", p);\n     atomic_add_acq(&mut b.header.ref_count, 1);\n@@ -354,8 +354,8 @@ fn BufferResource<T: Send>(+b: ~Buffer<T>) -> BufferResource<T> {\n }\n \n #[doc(hidden)]\n-pub fn send<T: Send, Tbuffer: Send>(+p: SendPacketBuffered<T, Tbuffer>,\n-                                    +payload: T) -> bool {\n+pub fn send<T: Send, Tbuffer: Send>(p: SendPacketBuffered<T, Tbuffer>,\n+                                    payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n@@ -398,7 +398,7 @@ pub fn send<T: Send, Tbuffer: Send>(+p: SendPacketBuffered<T, Tbuffer>,\n Fails if the sender closes the connection.\n \n */\n-pub fn recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>) -> T {\n+pub fn recv<T: Send, Tbuffer: Send>(p: RecvPacketBuffered<T, Tbuffer>) -> T {\n     option::unwrap_expect(try_recv(move p), \"connection closed\")\n }\n \n@@ -408,7 +408,7 @@ Returns `none` if the sender has closed the connection without sending\n a message, or `Some(T)` if a message was received.\n \n */\n-pub fn try_recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>)\n+pub fn try_recv<T: Send, Tbuffer: Send>(p: RecvPacketBuffered<T, Tbuffer>)\n     -> Option<T>\n {\n     let p_ = p.unwrap();\n@@ -655,8 +655,8 @@ this case, `select2` may return either `left` or `right`.\n \n */\n pub fn select2<A: Send, Ab: Send, B: Send, Bb: Send>(\n-    +a: RecvPacketBuffered<A, Ab>,\n-    +b: RecvPacketBuffered<B, Bb>)\n+    a: RecvPacketBuffered<A, Ab>,\n+    b: RecvPacketBuffered<B, Bb>)\n     -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n               (RecvPacketBuffered<A, Ab>, Option<B>)>\n {\n@@ -697,7 +697,7 @@ pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n  list of the remaining endpoints.\n \n */\n-pub fn select<T: Send, Tb: Send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n+pub fn select<T: Send, Tb: Send>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n     -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n@@ -859,7 +859,7 @@ endpoint is passed to the new task.\n pub fn spawn_service<T: Send, Tb: Send>(\n     init: extern fn() -> (SendPacketBuffered<T, Tb>,\n                           RecvPacketBuffered<T, Tb>),\n-    +service: fn~(+v: RecvPacketBuffered<T, Tb>))\n+    +service: fn~(v: RecvPacketBuffered<T, Tb>))\n     -> SendPacketBuffered<T, Tb>\n {\n     let (client, server) = init();\n@@ -883,7 +883,7 @@ receive state.\n pub fn spawn_service_recv<T: Send, Tb: Send>(\n     init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n                           SendPacketBuffered<T, Tb>),\n-    +service: fn~(+v: SendPacketBuffered<T, Tb>))\n+    +service: fn~(v: SendPacketBuffered<T, Tb>))\n     -> RecvPacketBuffered<T, Tb>\n {\n     let (client, server) = init();\n@@ -914,10 +914,10 @@ pub trait Channel<T: Send> {\n     // built in send kind.\n \n     /// Sends a message.\n-    fn send(+x: T);\n+    fn send(x: T);\n \n     /// Sends a message, or report if the receiver has closed the connection.\n-    fn try_send(+x: T) -> bool;\n+    fn try_send(x: T) -> bool;\n }\n \n /// A trait for things that can receive multiple messages.\n@@ -966,14 +966,14 @@ pub fn stream<T:Send>() -> (Chan<T>, Port<T>) {\n }\n \n impl<T: Send> Chan<T>: Channel<T> {\n-    fn send(+x: T) {\n+    fn send(x: T) {\n         let mut endp = None;\n         endp <-> self.endp;\n         self.endp = Some(\n             streamp::client::data(unwrap(move endp), move x))\n     }\n \n-    fn try_send(+x: T) -> bool {\n+    fn try_send(x: T) -> bool {\n         let mut endp = None;\n         endp <-> self.endp;\n         match move streamp::client::try_data(unwrap(move endp), move x) {\n@@ -1041,7 +1041,7 @@ pub fn PortSet<T: Send>() -> PortSet<T>{\n \n impl<T: Send> PortSet<T> : Recv<T> {\n \n-    fn add(+port: pipes::Port<T>) {\n+    fn add(port: pipes::Port<T>) {\n         self.ports.push(move port)\n     }\n \n@@ -1091,7 +1091,7 @@ impl<T: Send> PortSet<T> : Recv<T> {\n pub type SharedChan<T: Send> = private::Exclusive<Chan<T>>;\n \n impl<T: Send> SharedChan<T>: Channel<T> {\n-    fn send(+x: T) {\n+    fn send(x: T) {\n         let mut xx = Some(move x);\n         do self.with_imm |chan| {\n             let mut x = None;\n@@ -1100,7 +1100,7 @@ impl<T: Send> SharedChan<T>: Channel<T> {\n         }\n     }\n \n-    fn try_send(+x: T) -> bool {\n+    fn try_send(x: T) -> bool {\n         let mut xx = Some(move x);\n         do self.with_imm |chan| {\n             let mut x = None;\n@@ -1111,7 +1111,7 @@ impl<T: Send> SharedChan<T>: Channel<T> {\n }\n \n /// Converts a `chan` into a `shared_chan`.\n-pub fn SharedChan<T:Send>(+c: Chan<T>) -> SharedChan<T> {\n+pub fn SharedChan<T:Send>(c: Chan<T>) -> SharedChan<T> {\n     private::exclusive(move c)\n }\n \n@@ -1165,13 +1165,13 @@ pub fn oneshot<T: Send>() -> (ChanOne<T>, PortOne<T>) {\n  * Receive a message from a oneshot pipe, failing if the connection was\n  * closed.\n  */\n-pub fn recv_one<T: Send>(+port: PortOne<T>) -> T {\n+pub fn recv_one<T: Send>(port: PortOne<T>) -> T {\n     let oneshot::send(message) = recv(move port);\n     move message\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n-pub fn try_recv_one<T: Send> (+port: PortOne<T>) -> Option<T> {\n+pub fn try_recv_one<T: Send> (port: PortOne<T>) -> Option<T> {\n     let message = try_recv(move port);\n \n     if message.is_none() { None }\n@@ -1182,23 +1182,23 @@ pub fn try_recv_one<T: Send> (+port: PortOne<T>) -> Option<T> {\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n-pub fn send_one<T: Send>(+chan: ChanOne<T>, +data: T) {\n+pub fn send_one<T: Send>(chan: ChanOne<T>, data: T) {\n     oneshot::client::send(move chan, move data);\n }\n \n /**\n  * Send a message on a oneshot pipe, or return false if the connection was\n  * closed.\n  */\n-pub fn try_send_one<T: Send>(+chan: ChanOne<T>, +data: T)\n+pub fn try_send_one<T: Send>(chan: ChanOne<T>, data: T)\n         -> bool {\n     oneshot::client::try_send(move chan, move data).is_some()\n }\n \n pub mod rt {\n     // These are used to hide the option constructors from the\n     // compiler because their names are changing\n-    pub fn make_some<T>(+val: T) -> Option<T> { Some(move val) }\n+    pub fn make_some<T>(val: T) -> Option<T> { Some(move val) }\n     pub fn make_none<T>() -> Option<T> { None }\n }\n "}, {"sha": "c1b2b32edafc6530db483e929ededcd749d65f66", "filename": "src/libcore/private.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n #[doc(hidden)];\n@@ -340,7 +340,7 @@ fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n     }\n }\n \n-pub unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n+pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n         mut ptr:      Option<~ArcData<T>>,\n@@ -413,7 +413,7 @@ pub unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n  */\n pub type SharedMutableState<T: Send> = ArcDestruct<T>;\n \n-pub unsafe fn shared_mutable_state<T: Send>(+data: T) ->\n+pub unsafe fn shared_mutable_state<T: Send>(data: T) ->\n         SharedMutableState<T> {\n     let data = ~ArcData { count: 1, unwrapper: 0, data: Some(move data) };\n     unsafe {\n@@ -502,7 +502,7 @@ struct ExData<T: Send> { lock: LittleLock, mut failed: bool, mut data: T, }\n  */\n pub struct Exclusive<T: Send> { x: SharedMutableState<ExData<T>> }\n \n-pub fn exclusive<T:Send >(+user_data: T) -> Exclusive<T> {\n+pub fn exclusive<T:Send >(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n         lock: LittleLock(), mut failed: false, mut data: user_data\n     };\n@@ -544,7 +544,7 @@ impl<T: Send> Exclusive<T> {\n }\n \n // FIXME(#2585) make this a by-move method on the exclusive\n-pub fn unwrap_exclusive<T: Send>(+arc: Exclusive<T>) -> T {\n+pub fn unwrap_exclusive<T: Send>(arc: Exclusive<T>) -> T {\n     let Exclusive { x: x } <- arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let ExData { data: data, _ } <- inner;"}, {"sha": "41006e1dfb5e6c3437815528006435e2db66f933", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -27,7 +27,7 @@ fn align(size: uint, align: uint) -> uint {\n struct MovePtrAdaptor<V: TyVisitor MovePtr> {\n     inner: V\n }\n-pub fn MovePtrAdaptor<V: TyVisitor MovePtr>(+v: V) -> MovePtrAdaptor<V> {\n+pub fn MovePtrAdaptor<V: TyVisitor MovePtr>(v: V) -> MovePtrAdaptor<V> {\n     MovePtrAdaptor { inner: move v }\n }\n "}, {"sha": "e61690d5b2c0e0acc7258170277fac8f5e21cd26", "filename": "src/libcore/result.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -1,7 +1,7 @@\n //! A type representing either success or failure\n \n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use cmp::Eq;\n@@ -102,7 +102,7 @@ pub pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>)\n  *         ok(parse_bytes(buf))\n  *     }\n  */\n-pub fn chain<T, U: Copy, V: Copy>(+res: Result<T, V>, op: fn(+t: T)\n+pub fn chain<T, U: Copy, V: Copy>(res: Result<T, V>, op: fn(t: T)\n     -> Result<U, V>) -> Result<U, V> {\n     // XXX: Should be writable with move + match\n     if res.is_ok() {\n@@ -121,8 +121,8 @@ pub fn chain<T, U: Copy, V: Copy>(+res: Result<T, V>, op: fn(+t: T)\n  * successful result while handling an error.\n  */\n pub fn chain_err<T: Copy, U: Copy, V: Copy>(\n-    +res: Result<T, V>,\n-    op: fn(+t: V) -> Result<T, U>)\n+    res: Result<T, V>,\n+    op: fn(t: V) -> Result<T, U>)\n     -> Result<T, U> {\n     match move res {\n       Ok(move t) => Ok(t),\n@@ -247,12 +247,12 @@ impl<T, E: Copy> Result<T, E> {\n }\n \n impl<T: Copy, E: Copy> Result<T, E> {\n-    fn chain<U:Copy>(op: fn(+t: T) -> Result<U,E>) -> Result<U,E> {\n+    fn chain<U:Copy>(op: fn(t: T) -> Result<U,E>) -> Result<U,E> {\n         // XXX: Bad copy\n         chain(copy self, op)\n     }\n \n-    fn chain_err<F:Copy>(op: fn(+t: E) -> Result<T,F>) -> Result<T,F> {\n+    fn chain_err<F:Copy>(op: fn(t: E) -> Result<T,F>) -> Result<T,F> {\n         // XXX: Bad copy\n         chain_err(copy self, op)\n     }\n@@ -348,15 +348,15 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n }\n \n /// Unwraps a result, assuming it is an `ok(T)`\n-pub fn unwrap<T, U>(+res: Result<T, U>) -> T {\n+pub fn unwrap<T, U>(res: Result<T, U>) -> T {\n     match move res {\n       Ok(move t) => move t,\n       Err(_) => fail ~\"unwrap called on an err result\"\n     }\n }\n \n /// Unwraps a result, assuming it is an `err(U)`\n-pub fn unwrap_err<T, U>(+res: Result<T, U>) -> U {\n+pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n     match move res {\n       Err(move u) => move u,\n       Ok(_) => fail ~\"unwrap called on an ok result\"\n@@ -389,7 +389,7 @@ mod tests {\n     #[legacy_exports];\n     fn op1() -> result::Result<int, ~str> { result::Ok(666) }\n \n-    fn op2(+i: int) -> result::Result<uint, ~str> {\n+    fn op2(i: int) -> result::Result<uint, ~str> {\n         result::Ok(i as uint + 1u)\n     }\n "}, {"sha": "f3e98f6ba8272b6b6f8f83dc41eefd760fca374f", "filename": "src/libcore/run.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n //! Process spawning\n@@ -224,7 +224,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n         drop { destroy_repr(&self.r); }\n     }\n \n-    fn ProgRes(+r: ProgRepr) -> ProgRes {\n+    fn ProgRes(r: ProgRepr) -> ProgRes {\n         ProgRes {\n             r: r\n         }\n@@ -328,7 +328,7 @@ pub fn program_output(prog: &str, args: &[~str]) ->\n     return {status: status, out: move outs, err: move errs};\n }\n \n-fn writeclose(fd: c_int, +s: ~str) {\n+fn writeclose(fd: c_int, s: ~str) {\n     use io::WriterUtil;\n \n     error!(\"writeclose %d, %s\", fd as int, s);"}, {"sha": "4a56ee5b896800809e5c3ddbb80278141e05b156", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -15,7 +15,7 @@ use to_bytes::IterBytes;\n pub trait SendMap<K:Eq Hash, V: Copy> {\n     // FIXME(#3148)  ^^^^ once find_ref() works, we can drop V:copy\n \n-    fn insert(&mut self, +k: K, +v: V) -> bool;\n+    fn insert(&mut self, k: K, +v: V) -> bool;\n     fn remove(&mut self, k: &K) -> bool;\n     fn clear(&mut self);\n     pure fn len(&const self) -> uint;\n@@ -161,7 +161,7 @@ pub mod linear {\n             }\n         }\n \n-        fn insert_opt_bucket(&mut self, +bucket: Option<Bucket<K,V>>) {\n+        fn insert_opt_bucket(&mut self, bucket: Option<Bucket<K,V>>) {\n             match move bucket {\n                 Some(Bucket {hash: move hash,\n                              key: move key,\n@@ -175,7 +175,7 @@ pub mod linear {\n         /// Inserts the key value pair into the buckets.\n         /// Assumes that there will be a bucket.\n         /// True if there was no previous entry with that key\n-        fn insert_internal(&mut self, hash: uint, +k: K, +v: V) -> bool {\n+        fn insert_internal(&mut self, hash: uint, k: K, v: V) -> bool {\n             match self.bucket_for_key_with_hash(self.buckets, hash, &k) {\n                 TableFull => { fail ~\"Internal logic error\"; }\n                 FoundHole(idx) => {\n@@ -206,7 +206,7 @@ pub mod linear {\n     }\n \n     impl<K:Hash IterBytes Eq,V> LinearMap<K,V> {\n-        fn insert(&mut self, +k: K, +v: V) -> bool {\n+        fn insert(&mut self, k: K, v: V) -> bool {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n                 // that we do not resize if this call to insert is"}, {"sha": "09973148c8c8106ab08cac4ce312a4863a6e7494", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -1,5 +1,7 @@\n #[doc(hidden)]; // FIXME #3538\n \n+#[legacy_modes]; // tjc: remove after snapshot\n+\n // NB: transitionary, de-mode-ing.\n // XXX: Can't do this because frame_address needs a deprecated mode.\n //#[forbid(deprecated_mode)];"}, {"sha": "cf996a8b254ca1efbb174d562365e7c8e63d0e75", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -175,7 +175,7 @@ pub fn push_str(lhs: &const ~str, rhs: &str) {\n \n /// Concatenate two strings together\n #[inline(always)]\n-pub pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n+pub pure fn append(lhs: ~str, rhs: &str) -> ~str {\n     let mut v <- lhs;\n     unsafe {\n         push_str_no_overallocate(&mut v, rhs);"}, {"sha": "12329616fbf9fd13f1c0dad0b817acd96467e068", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -83,7 +83,7 @@ pub pure fn pref_align_of<T>() -> uint {\n \n /// Returns the refcount of a shared box (as just before calling this)\n #[inline(always)]\n-pub pure fn refcount<T>(+t: @T) -> uint {\n+pub pure fn refcount<T>(t: @T) -> uint {\n     unsafe {\n         let ref_ptr: *uint = cast::reinterpret_cast(&t);\n         *ref_ptr - 1"}, {"sha": "5ca35a7f56230e334cf1e52710a323ef82457bd3", "filename": "src/libcore/task.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n /*!\n@@ -232,7 +232,7 @@ pub enum TaskBuilder = {\n pub fn task() -> TaskBuilder {\n     TaskBuilder({\n         opts: default_task_opts(),\n-        gen_body: |body| move body, // Identity function\n+        gen_body: |+body| move body, // Identity function\n         can_not_copy: None,\n         mut consumed: false,\n     })\n@@ -347,7 +347,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn future_result(blk: fn(+v: future::Future<TaskResult>)) -> TaskBuilder {\n+    fn future_result(blk: fn(v: future::Future<TaskResult>)) -> TaskBuilder {\n         // FIXME (#1087, #1857): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -459,9 +459,9 @@ impl TaskBuilder {\n         spawn::spawn_raw(move opts, x.gen_body(move f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A: Send>(+arg: A, +f: fn~(+v: A)) {\n+    fn spawn_with<A: Send>(arg: A, +f: fn~(+v: A)) {\n         let arg = ~mut Some(move arg);\n-        do self.spawn |move arg, move f|{\n+        do self.spawn |move arg, move f| {\n             f(option::swap_unwrap(arg))\n         }\n     }\n@@ -473,7 +473,7 @@ impl TaskBuilder {\n      * child task, passes the port to child's body, and returns a channel\n      * linked to the port to the parent.\n      *\n-     * This encapsulates Some boilerplate handshaking logic that would\n+     * This encapsulates some boilerplate handshaking logic that would\n      * otherwise be required to establish communication from the parent\n      * to the child.\n      */\n@@ -1149,7 +1149,7 @@ fn test_avoid_copying_the_body_spawn() {\n \n #[test]\n fn test_avoid_copying_the_body_spawn_listener() {\n-    do avoid_copying_the_body |f| {\n+    do avoid_copying_the_body |+f| {\n         spawn_listener(fn~(move f, _po: comm::Port<int>) {\n             f();\n         });\n@@ -1167,7 +1167,7 @@ fn test_avoid_copying_the_body_task_spawn() {\n \n #[test]\n fn test_avoid_copying_the_body_spawn_listener_1() {\n-    do avoid_copying_the_body |f| {\n+    do avoid_copying_the_body |+f| {\n         task().spawn_listener(fn~(move f, _po: comm::Port<int>) {\n             f();\n         });"}, {"sha": "2130354229a24250d9fe6c33d20d3568241813ea", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -37,7 +37,7 @@ use local_data_priv::{\n  *\n  * These two cases aside, the interface is safe.\n  */\n-pub type LocalDataKey<T: Owned> = &fn(+v: @T);\n+pub type LocalDataKey<T: Owned> = &fn(v: @T);\n \n /**\n  * Remove a task-local data value from the table, returning the\n@@ -62,7 +62,7 @@ pub unsafe fn local_data_get<T: Owned>(\n  * that value is overwritten (and its destructor is run).\n  */\n pub unsafe fn local_data_set<T: Owned>(\n-    key: LocalDataKey<T>, +data: @T) {\n+    key: LocalDataKey<T>, data: @T) {\n \n     local_set(rt::rust_get_task(), key, data)\n }\n@@ -79,7 +79,7 @@ pub unsafe fn local_data_modify<T: Owned>(\n \n #[test]\n pub fn test_tls_multitask() unsafe {\n-    fn my_key(+_x: @~str) { }\n+    fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"parent data\");\n     do task::spawn unsafe {\n         assert local_data_get(my_key).is_none(); // TLS shouldn't carry over.\n@@ -95,15 +95,15 @@ pub fn test_tls_multitask() unsafe {\n \n #[test]\n pub fn test_tls_overwrite() unsafe {\n-    fn my_key(+_x: @~str) { }\n+    fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"first data\");\n     local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n     assert *(local_data_get(my_key).get()) == ~\"next data\";\n }\n \n #[test]\n pub fn test_tls_pop() unsafe {\n-    fn my_key(+_x: @~str) { }\n+    fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"weasel\");\n     assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n     // Pop must remove the data from the map.\n@@ -112,7 +112,7 @@ pub fn test_tls_pop() unsafe {\n \n #[test]\n pub fn test_tls_modify() unsafe {\n-    fn my_key(+_x: @~str) { }\n+    fn my_key(_x: @~str) { }\n     local_data_modify(my_key, |data| {\n         match data {\n             Some(@ref val) => fail ~\"unwelcome value: \" + *val,\n@@ -136,17 +136,17 @@ pub fn test_tls_crust_automorestack_memorial_bug() unsafe {\n     // jump over to the rust stack, which causes next_c_sp to get recorded as\n     // Something within a rust stack segment. Then a subsequent upcall (esp.\n     // for logging, think vsnprintf) would run on a stack smaller than 1 MB.\n-    fn my_key(+_x: @~str) { }\n+    fn my_key(_x: @~str) { }\n     do task::spawn {\n         unsafe { local_data_set(my_key, @~\"hax\"); }\n     }\n }\n \n #[test]\n pub fn test_tls_multiple_types() unsafe {\n-    fn str_key(+_x: @~str) { }\n-    fn box_key(+_x: @@()) { }\n-    fn int_key(+_x: @int) { }\n+    fn str_key(_x: @~str) { }\n+    fn box_key(_x: @@()) { }\n+    fn int_key(_x: @int) { }\n     do task::spawn unsafe {\n         local_data_set(str_key, @~\"string data\");\n         local_data_set(box_key, @@());\n@@ -156,9 +156,9 @@ pub fn test_tls_multiple_types() unsafe {\n \n #[test]\n pub fn test_tls_overwrite_multiple_types() {\n-    fn str_key(+_x: @~str) { }\n-    fn box_key(+_x: @@()) { }\n-    fn int_key(+_x: @int) { }\n+    fn str_key(_x: @~str) { }\n+    fn box_key(_x: @@()) { }\n+    fn int_key(_x: @int) { }\n     do task::spawn unsafe {\n         local_data_set(str_key, @~\"string data\");\n         local_data_set(int_key, @42);\n@@ -172,9 +172,9 @@ pub fn test_tls_overwrite_multiple_types() {\n #[should_fail]\n #[ignore(cfg(windows))]\n pub fn test_tls_cleanup_on_failure() unsafe {\n-    fn str_key(+_x: @~str) { }\n-    fn box_key(+_x: @@()) { }\n-    fn int_key(+_x: @int) { }\n+    fn str_key(_x: @~str) { }\n+    fn box_key(_x: @@()) { }\n+    fn int_key(_x: @int) { }\n     local_data_set(str_key, @~\"parent data\");\n     local_data_set(box_key, @@());\n     do task::spawn unsafe { // spawn_linked"}, {"sha": "499dd0730603d38e5f6e7de53f4f0502808e5524", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -117,7 +117,7 @@ unsafe fn local_get<T: Owned>(\n }\n \n unsafe fn local_set<T: Owned>(\n-    task: *rust_task, key: LocalDataKey<T>, +data: @T) {\n+    task: *rust_task, key: LocalDataKey<T>, data: @T) {\n \n     let map = get_task_local_map(task);\n     // Store key+data as *voids. Data is invisibly referenced once; key isn't."}, {"sha": "786255fe7fa2917b7d41bc0fdc7a797d902bf38b", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -82,7 +82,7 @@ fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n     assert was_present;\n }\n-fn taskset_each(tasks: &TaskSet, blk: fn(+v: *rust_task) -> bool) {\n+fn taskset_each(tasks: &TaskSet, blk: fn(v: *rust_task) -> bool) {\n     tasks.each_key(|k| blk(*k))\n }\n \n@@ -303,8 +303,8 @@ struct TCB {\n     }\n }\n \n-fn TCB(me: *rust_task, +tasks: TaskGroupArc, +ancestors: AncestorList,\n-       is_main: bool, +notifier: Option<AutoNotify>) -> TCB {\n+fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n+       is_main: bool, notifier: Option<AutoNotify>) -> TCB {\n \n     let notifier = move notifier;\n     notifier.iter(|x| { x.failed = false; });\n@@ -327,7 +327,7 @@ struct AutoNotify {\n     }\n }\n \n-fn AutoNotify(+chan: Chan<Notification>) -> AutoNotify {\n+fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n     AutoNotify {\n         notify_chan: chan,\n         failed: true // Un-set above when taskgroup successfully made.\n@@ -377,13 +377,13 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n     // see 'None' if Somebody already failed and we got a kill signal.)\n     if newstate.is_some() {\n         let group = option::unwrap(move newstate);\n-        for taskset_each(&group.members) |+sibling| {\n+        for taskset_each(&group.members) |sibling| {\n             // Skip self - killing ourself won't do much good.\n             if sibling != me {\n                 rt::rust_task_kill_other(sibling);\n             }\n         }\n-        for taskset_each(&group.descendants) |+child| {\n+        for taskset_each(&group.descendants) |child| {\n             assert child != me;\n             rt::rust_task_kill_other(child);\n         }\n@@ -486,7 +486,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     }\n }\n \n-fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n+fn spawn_raw(opts: TaskOpts, +f: fn~()) {\n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n@@ -528,9 +528,9 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n     // (3a) If any of those fails, it leaves all groups, and does nothing.\n     // (3b) Otherwise it builds a task control structure and puts it in TLS,\n     // (4) ...and runs the provided body function.\n-    fn make_child_wrapper(child: *rust_task, +child_arc: TaskGroupArc,\n-                          +ancestors: AncestorList, is_main: bool,\n-                          +notify_chan: Option<Chan<Notification>>,\n+    fn make_child_wrapper(child: *rust_task, child_arc: TaskGroupArc,\n+                          ancestors: AncestorList, is_main: bool,\n+                          notify_chan: Option<Chan<Notification>>,\n                           +f: fn~()) -> fn~() {\n         let child_data = ~mut Some((move child_arc, move ancestors));\n         return fn~(move notify_chan, move child_data, move f) {"}, {"sha": "aa1fe14ba88279b13cab470008207c970625081b", "filename": "src/libcore/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -5,25 +5,25 @@ Miscellaneous helpers for common patterns.\n */\n \n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use cmp::Eq;\n \n /// The identity function.\n #[inline(always)]\n-pub pure fn id<T>(+x: T) -> T { move x }\n+pub pure fn id<T>(x: T) -> T { move x }\n \n /// Ignores a value.\n #[inline(always)]\n-pub pure fn ignore<T>(+_x: T) { }\n+pub pure fn ignore<T>(_x: T) { }\n \n /// Sets `*ptr` to `new_value`, invokes `op()`, and then restores the\n /// original value of `*ptr`.\n #[inline(always)]\n pub fn with<T: Copy, R>(\n     ptr: &mut T,\n-    +new_value: T,\n+    new_value: T,\n     op: &fn() -> R) -> R\n {\n     // NDM: if swap operator were defined somewhat differently,\n@@ -50,7 +50,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n  * value, without deinitialising or copying either one.\n  */\n #[inline(always)]\n-pub fn replace<T>(dest: &mut T, +src: T) -> T {\n+pub fn replace<T>(dest: &mut T, src: T) -> T {\n     let mut tmp <- src;\n     swap(dest, &mut tmp);\n     move tmp"}, {"sha": "0c822bd0a031d991bea961b0ff4ff9f832c87a3b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -47,7 +47,7 @@ pub pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n  * * v - A vector\n  * * n - The number of elements to reserve space for\n  */\n-pub fn reserve<T>(+v: &mut ~[T], +n: uint) {\n+pub fn reserve<T>(v: &mut ~[T], n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n     if capacity(v) < n {\n         unsafe {\n@@ -119,7 +119,7 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pub pure fn from_elem<T: Copy>(n_elts: uint, +t: T) -> ~[T] {\n+pub pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> ~[T] {\n     from_fn(n_elts, |_i| copy t)\n }\n \n@@ -148,9 +148,9 @@ pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n  */\n #[inline(always)]\n pub pure fn build_sized<A>(size: uint,\n-                       builder: fn(push: pure fn(+v: A))) -> ~[A] {\n+                       builder: fn(push: pure fn(v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n-    builder(|+x| unsafe { vec.push(move x) });\n+    builder(|x| unsafe { vec.push(move x) });\n     move vec\n }\n \n@@ -165,7 +165,7 @@ pub pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A>(builder: fn(push: pure fn(+v: A))) -> ~[A] {\n+pub pure fn build<A>(builder: fn(push: pure fn(v: A))) -> ~[A] {\n     build_sized(4, builder)\n }\n \n@@ -183,17 +183,17 @@ pub pure fn build<A>(builder: fn(push: pure fn(+v: A))) -> ~[A] {\n  */\n #[inline(always)]\n pub pure fn build_sized_opt<A>(size: Option<uint>,\n-                           builder: fn(push: pure fn(+v: A))) -> ~[A] {\n+                           builder: fn(push: pure fn(v: A))) -> ~[A] {\n     build_sized(size.get_default(4), builder)\n }\n \n /// Produces a mut vector from an immutable vector.\n-pub pure fn to_mut<T>(+v: ~[T]) -> ~[mut T] {\n+pub pure fn to_mut<T>(v: ~[T]) -> ~[mut T] {\n     unsafe { ::cast::transmute(move v) }\n }\n \n /// Produces an immutable vector from a mut vector.\n-pub pure fn from_mut<T>(+v: ~[mut T]) -> ~[T] {\n+pub pure fn from_mut<T>(v: ~[mut T]) -> ~[T] {\n     unsafe { ::cast::transmute(move v) }\n }\n \n@@ -412,13 +412,13 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n }\n \n /// Prepend an element to the vector\n-pub fn unshift<T>(v: &mut ~[T], +x: T) {\n+pub fn unshift<T>(v: &mut ~[T], x: T) {\n     let mut vv = ~[move x];\n     *v <-> vv;\n     v.push_all_move(vv);\n }\n \n-pub fn consume<T>(+v: ~[T], f: fn(uint, +v: T)) unsafe {\n+pub fn consume<T>(v: ~[T], f: fn(uint, v: T)) unsafe {\n     let mut v = move v; // FIXME(#3488)\n \n     do as_imm_buf(v) |p, ln| {\n@@ -431,7 +431,7 @@ pub fn consume<T>(+v: ~[T], f: fn(uint, +v: T)) unsafe {\n     raw::set_len(&mut v, 0);\n }\n \n-pub fn consume_mut<T>(+v: ~[mut T], f: fn(uint, +v: T)) {\n+pub fn consume_mut<T>(v: ~[mut T], f: fn(uint, v: T)) {\n     consume(vec::from_mut(v), f)\n }\n \n@@ -468,7 +468,7 @@ pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n \n /// Append an element to a vector\n #[inline(always)]\n-pub fn push<T>(v: &mut ~[T], +initval: T) {\n+pub fn push<T>(v: &mut ~[T], initval: T) {\n     unsafe {\n         let repr: **raw::VecRepr = ::cast::transmute(copy v);\n         let fill = (**repr).unboxed.fill;\n@@ -483,7 +483,7 @@ pub fn push<T>(v: &mut ~[T], +initval: T) {\n \n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n-unsafe fn push_fast<T>(+v: &mut ~[T], +initval: T) {\n+unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n     let repr: **raw::VecRepr = ::cast::transmute(v);\n     let fill = (**repr).unboxed.fill;\n     (**repr).unboxed.fill += sys::size_of::<T>();\n@@ -493,13 +493,13 @@ unsafe fn push_fast<T>(+v: &mut ~[T], +initval: T) {\n }\n \n #[inline(never)]\n-fn push_slow<T>(+v: &mut ~[T], +initval: T) {\n+fn push_slow<T>(v: &mut ~[T], initval: T) {\n     reserve_at_least(v, v.len() + 1u);\n     unsafe { push_fast(v, move initval) }\n }\n \n #[inline(always)]\n-pub fn push_all<T: Copy>(+v: &mut ~[T], rhs: &[const T]) {\n+pub fn push_all<T: Copy>(v: &mut ~[T], rhs: &[const T]) {\n     reserve(v, v.len() + rhs.len());\n \n     for uint::range(0u, rhs.len()) |i| {\n@@ -508,7 +508,7 @@ pub fn push_all<T: Copy>(+v: &mut ~[T], rhs: &[const T]) {\n }\n \n #[inline(always)]\n-pub fn push_all_move<T>(v: &mut ~[T], +rhs: ~[T]) {\n+pub fn push_all_move<T>(v: &mut ~[T], rhs: ~[T]) {\n     let mut rhs = move rhs; // FIXME(#3488)\n     reserve(v, v.len() + rhs.len());\n     unsafe {\n@@ -573,7 +573,7 @@ pub fn dedup<T: Eq>(v: &mut ~[T]) unsafe {\n \n // Appending\n #[inline(always)]\n-pub pure fn append<T: Copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n+pub pure fn append<T: Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n     let mut v <- lhs;\n     unsafe {\n         v.push_all(rhs);\n@@ -582,14 +582,14 @@ pub pure fn append<T: Copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n }\n \n #[inline(always)]\n-pub pure fn append_one<T>(+lhs: ~[T], +x: T) -> ~[T] {\n+pub pure fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n     let mut v <- lhs;\n     unsafe { v.push(move x); }\n     move v\n }\n \n #[inline(always)]\n-pure fn append_mut<T: Copy>(+lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n+pure fn append_mut<T: Copy>(lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n     to_mut(append(from_mut(lhs), rhs))\n }\n \n@@ -642,7 +642,7 @@ pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n  * of the vector, expands the vector by replicating `initval` to fill the\n  * intervening space.\n  */\n-pub fn grow_set<T: Copy>(v: &mut ~[T], index: uint, initval: &T, +val: T) {\n+pub fn grow_set<T: Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n     let l = v.len();\n     if index >= l { grow(v, index - l + 1u, initval); }\n     v[index] = move val;\n@@ -661,7 +661,7 @@ pub pure fn map<T, U>(v: &[T], f: fn(t: &T) -> U) -> ~[U] {\n     move result\n }\n \n-pub fn map_consume<T, U>(+v: ~[T], f: fn(+v: T) -> U) -> ~[U] {\n+pub fn map_consume<T, U>(v: ~[T], f: fn(v: T) -> U) -> ~[U] {\n     let mut result = ~[];\n     do consume(move v) |_i, x| {\n         result.push(f(move x));\n@@ -758,7 +758,7 @@ pub pure fn connect<T: Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n }\n \n /// Reduce a vector from left to right\n-pub pure fn foldl<T: Copy, U>(+z: T, v: &[U], p: fn(+t: T, u: &U) -> T) -> T {\n+pub pure fn foldl<T: Copy, U>(z: T, v: &[U], p: fn(t: T, u: &U) -> T) -> T {\n     let mut accum = z;\n     for each(v) |elt| {\n         // it should be possible to move accum in, but the liveness analysis\n@@ -769,7 +769,7 @@ pub pure fn foldl<T: Copy, U>(+z: T, v: &[U], p: fn(+t: T, u: &U) -> T) -> T {\n }\n \n /// Reduce a vector from right to left\n-pub pure fn foldr<T, U: Copy>(v: &[T], +z: U, p: fn(t: &T, +u: U) -> U) -> U {\n+pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(t: &T, u: U) -> U) -> U {\n     let mut accum = z;\n     for rev_each(v) |elt| {\n         accum = p(elt, accum);\n@@ -992,7 +992,7 @@ pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n  * and the i-th element of the second vector contains the second element\n  * of the i-th tuple of the input vector.\n  */\n-pub pure fn unzip<T,U>(+v: ~[(T, U)]) -> (~[T], ~[U]) {\n+pub pure fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     unsafe {\n         do consume(move v) |_i, p| {\n@@ -1023,7 +1023,7 @@ pub pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n  * Returns a vector of tuples, where the i-th tuple contains contains the\n  * i-th elements from each of the input vectors.\n  */\n-pub pure fn zip<T, U>(+v: ~[T], +u: ~[U]) -> ~[(T, U)] {\n+pub pure fn zip<T, U>(v: ~[T], u: ~[U]) -> ~[(T, U)] {\n     let mut v = move v, u = move u; // FIXME(#3488)\n     let mut i = len(v);\n     assert i == len(u);\n@@ -1190,7 +1190,7 @@ pub fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  */\n-pure fn each_permutation<T: Copy>(+v: &[T], put: fn(ts: &[T]) -> bool) {\n+pure fn each_permutation<T: Copy>(v: &[T], put: fn(ts: &[T]) -> bool) {\n     let ln = len(v);\n     if ln <= 1 {\n         put(v);\n@@ -1435,7 +1435,7 @@ impl<T: Copy> &[const T]: CopyableVector<T> {\n \n pub trait ImmutableVector<T> {\n     pure fn view(start: uint, end: uint) -> &self/[T];\n-    pure fn foldr<U: Copy>(+z: U, p: fn(t: &T, +u: U) -> U) -> U;\n+    pure fn foldr<U: Copy>(z: U, p: fn(t: &T, u: U) -> U) -> U;\n     pure fn map<U>(f: fn(t: &T) -> U) -> ~[U];\n     pure fn mapi<U>(f: fn(uint, t: &T) -> U) -> ~[U];\n     fn map_r<U>(f: fn(x: &T) -> U) -> ~[U];\n@@ -1459,7 +1459,7 @@ impl<T> &[T]: ImmutableVector<T> {\n     }\n     /// Reduce a vector from right to left\n     #[inline]\n-    pure fn foldr<U: Copy>(+z: U, p: fn(t: &T, +u: U) -> U) -> U {\n+    pure fn foldr<U: Copy>(z: U, p: fn(t: &T, u: U) -> U) -> U {\n         foldr(self, z, p)\n     }\n     /// Apply a function to each element of a vector and return the results\n@@ -1582,11 +1582,11 @@ impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n }\n \n pub trait MutableVector<T> {\n-    fn push(&mut self, +t: T);\n-    fn push_all_move(&mut self, +rhs: ~[T]);\n+    fn push(&mut self, t: T);\n+    fn push_all_move(&mut self, rhs: ~[T]);\n     fn pop(&mut self) -> T;\n     fn shift(&mut self) -> T;\n-    fn unshift(&mut self, +x: T);\n+    fn unshift(&mut self, x: T);\n     fn swap_remove(&mut self, index: uint) -> T;\n     fn truncate(&mut self, newlen: uint);\n }\n@@ -1595,19 +1595,19 @@ pub trait MutableCopyableVector<T: Copy> {\n     fn push_all(&mut self, rhs: &[const T]);\n     fn grow(&mut self, n: uint, initval: &T);\n     fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>);\n-    fn grow_set(&mut self, index: uint, initval: &T, +val: T);\n+    fn grow_set(&mut self, index: uint, initval: &T, val: T);\n }\n \n trait MutableEqVector<T: Eq> {\n     fn dedup(&mut self);\n }\n \n impl<T> ~[T]: MutableVector<T> {\n-    fn push(&mut self, +t: T) {\n+    fn push(&mut self, t: T) {\n         push(self, move t);\n     }\n \n-    fn push_all_move(&mut self, +rhs: ~[T]) {\n+    fn push_all_move(&mut self, rhs: ~[T]) {\n         push_all_move(self, move rhs);\n     }\n \n@@ -1619,7 +1619,7 @@ impl<T> ~[T]: MutableVector<T> {\n         shift(self)\n     }\n \n-    fn unshift(&mut self, +x: T) {\n+    fn unshift(&mut self, x: T) {\n         unshift(self, x)\n     }\n \n@@ -1645,7 +1645,7 @@ impl<T: Copy> ~[T]: MutableCopyableVector<T> {\n         grow_fn(self, n, op);\n     }\n \n-    fn grow_set(&mut self, index: uint, initval: &T, +val: T) {\n+    fn grow_set(&mut self, index: uint, initval: &T, val: T) {\n         grow_set(self, index, initval, val);\n     }\n }\n@@ -1717,21 +1717,21 @@ pub mod raw {\n      * would also make any pointers to it invalid.\n      */\n     #[inline(always)]\n-    pub unsafe fn to_ptr<T>(+v: &[T]) -> *T {\n+    pub unsafe fn to_ptr<T>(v: &[T]) -> *T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    pub unsafe fn to_const_ptr<T>(+v: &[const T]) -> *const T {\n+    pub unsafe fn to_const_ptr<T>(v: &[const T]) -> *const T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    pub unsafe fn to_mut_ptr<T>(+v: &[mut T]) -> *mut T {\n+    pub unsafe fn to_mut_ptr<T>(v: &[mut T]) -> *mut T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n@@ -1764,7 +1764,7 @@ pub mod raw {\n      * is newly allocated.\n      */\n     #[inline(always)]\n-    pub unsafe fn init_elem<T>(v: &[mut T], i: uint, +val: T) {\n+    pub unsafe fn init_elem<T>(v: &[mut T], i: uint, val: T) {\n         let mut box = Some(move val);\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n@@ -1896,7 +1896,7 @@ impl<A> &[A]: iter::ExtendedIter<A> {\n     }\n     pub pure fn all(blk: fn(&A) -> bool) -> bool { iter::all(&self, blk) }\n     pub pure fn any(blk: fn(&A) -> bool) -> bool { iter::any(&self, blk) }\n-    pub pure fn foldl<B>(+b0: B, blk: fn(&B, &A) -> B) -> B {\n+    pub pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B {\n         iter::foldl(&self, move b0, blk)\n     }\n     pub pure fn position(f: fn(&A) -> bool) -> Option<uint> {\n@@ -1910,10 +1910,10 @@ impl<A: Eq> &[A]: iter::EqIter<A> {\n }\n \n impl<A: Copy> &[A]: iter::CopyableIter<A> {\n-    pure fn filter_to_vec(pred: fn(+a: A) -> bool) -> ~[A] {\n+    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A] {\n         iter::filter_to_vec(&self, pred)\n     }\n-    pure fn map_to_vec<B>(op: fn(+v: A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B] {\n         iter::map_to_vec(&self, op)\n     }\n     pure fn to_vec() -> ~[A] { iter::to_vec(&self) }\n@@ -1923,7 +1923,7 @@ impl<A: Copy> &[A]: iter::CopyableIter<A> {\n     //     iter::flat_map_to_vec(self, op)\n     // }\n \n-    pub pure fn find(p: fn(+a: A) -> bool) -> Option<A> {\n+    pub pure fn find(p: fn(a: A) -> bool) -> Option<A> {\n         iter::find(&self, p)\n     }\n }\n@@ -1951,7 +1951,7 @@ mod tests {\n         return if *n % 2u == 1u { Some(*n * *n) } else { None };\n     }\n \n-    fn add(+x: uint, y: &uint) -> uint { return x + *y; }\n+    fn add(x: uint, y: &uint) -> uint { return x + *y; }\n \n     #[test]\n     fn test_unsafe_ptrs() {\n@@ -2193,7 +2193,7 @@ mod tests {\n \n     #[test]\n     fn test_dedup() {\n-        fn case(+a: ~[uint], +b: ~[uint]) {\n+        fn case(a: ~[uint], b: ~[uint]) {\n             let mut v = a;\n             v.dedup();\n             assert(v == b);\n@@ -2323,7 +2323,7 @@ mod tests {\n \n     #[test]\n     fn test_foldl2() {\n-        fn sub(+a: int, b: &int) -> int {\n+        fn sub(a: int, b: &int) -> int {\n             a - *b\n         }\n         let mut v = ~[1, 2, 3, 4];\n@@ -2333,7 +2333,7 @@ mod tests {\n \n     #[test]\n     fn test_foldr() {\n-        fn sub(a: &int, +b: int) -> int {\n+        fn sub(a: &int, b: int) -> int {\n             *a - b\n         }\n         let mut v = ~[1, 2, 3, 4];"}, {"sha": "67bbff7fb6a38a88d3c6e5788192dbca8a851fe2", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -232,7 +232,7 @@ type Result = result::Result<Matches, Fail_>;\n  */\n fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n     let n_opts = vec::len::<Opt>(opts);\n-    fn f(_x: uint) -> ~[Optval] { return ~[]; }\n+    fn f(+_x: uint) -> ~[Optval] { return ~[]; }\n     let vals = vec::to_mut(vec::from_fn(n_opts, f));\n     let mut free: ~[~str] = ~[];\n     let l = vec::len(args);"}, {"sha": "59cb0d36f7759da8f9064afbbc55046b47e76349", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -763,7 +763,7 @@ impl TcpSocket {\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n impl TcpSocketBuf: io::Reader {\n-    fn read(buf: &[mut u8], len: uint) -> uint {\n+    fn read(buf: &[mut u8], +len: uint) -> uint {\n         // Loop until our buffer has enough data in it for us to read from.\n         while self.data.buf.len() < len {\n             let read_result = read(&self.data.sock, 0u);\n@@ -799,13 +799,13 @@ impl TcpSocketBuf: io::Reader {\n         let mut bytes = ~[0];\n         if self.read(bytes, 1u) == 0 { fail } else { bytes[0] as int }\n     }\n-    fn unread_byte(amt: int) {\n+    fn unread_byte(+amt: int) {\n         self.data.buf.unshift(amt as u8);\n     }\n     fn eof() -> bool {\n         false // noop\n     }\n-    fn seek(dist: int, seek: io::SeekStyle) {\n+    fn seek(+dist: int, +seek: io::SeekStyle) {\n         log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n         // noop\n     }\n@@ -827,7 +827,7 @@ impl TcpSocketBuf: io::Writer {\n                              err_data.err_name, err_data.err_msg));\n         }\n     }\n-    fn seek(dist: int, seek: io::SeekStyle) {\n+    fn seek(+dist: int, +seek: io::SeekStyle) {\n       log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n         // noop\n     }"}, {"sha": "920751d690fa3f20aacbdc7d2ce4605a748e5b56", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -735,7 +735,7 @@ impl Url : Eq {\n }\n \n impl Url: IterBytes {\n-    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         unsafe { self.to_str() }.iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "d14a4854555ae56455d0f3971841c39cc91a8926", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -379,7 +379,7 @@ Section: Iterating\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pub fn loop_chars(rope: Rope, it: fn(char) -> bool) -> bool {\n+pub fn loop_chars(rope: Rope, it: fn(+c: char) -> bool) -> bool {\n    match (rope) {\n       node::Empty => return true,\n       node::Content(x) => return node::loop_chars(x, it)\n@@ -1037,7 +1037,7 @@ mod node {\n         return result;\n     }\n \n-    pub fn loop_chars(node: @Node, it: fn(char) -> bool) -> bool {\n+    pub fn loop_chars(node: @Node, it: fn(+c: char) -> bool) -> bool {\n         return loop_leaves(node,|leaf| {\n             str::all_between(*leaf.content,\n                              leaf.byte_offset,"}, {"sha": "95af018e35aac6c03de4daf03181ab3bcf1fdd8a", "filename": "src/libstd/std.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -18,6 +18,9 @@ not required in or otherwise suitable for the core library.\n \n #[no_core];\n \n+// tjc: Added legacy_modes back in because it still uses + mode.\n+// Remove once + mode gets expunged from std.\n+#[legacy_modes];\n #[legacy_exports];\n \n #[allow(vecs_implicitly_copyable)];"}, {"sha": "0f31f2056a14abdf2244975837fb08d69d627b2a", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -683,8 +683,12 @@ fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n                        mode_to_str(arg_ast.mode));\n                 match arg_ast.mode {\n                     ast::expl(ast::by_copy) => {\n-                        // This should warn, but we can't yet\n-                        // since it's still used. -- tjc\n+                        if !tcx.legacy_modes {\n+                            tcx.sess.span_lint(\n+                                deprecated_mode, id, id, span,\n+                                fmt!(\"argument %d uses by-copy mode\",\n+                                     counter));\n+                        }\n                     }\n \n                     ast::expl(_) => {"}, {"sha": "f35a3ce735fee877b6d492a26bc2bbf21898d8b3", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78cdcb6364cf938bfeb71da0c7eca62e257d537/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=f78cdcb6364cf938bfeb71da0c7eca62e257d537", "patch": "@@ -251,7 +251,7 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         colors = do par::mapi_factory(*color_vec) {\n             let colors = arc::clone(&color);\n             let graph = arc::clone(&graph);\n-            fn~(+i: uint, +c: color) -> color {\n+            fn~(i: uint, c: color) -> color {\n                 let c : color = c;\n                 let colors = arc::get(&colors);\n                 let graph = arc::get(&graph);"}]}