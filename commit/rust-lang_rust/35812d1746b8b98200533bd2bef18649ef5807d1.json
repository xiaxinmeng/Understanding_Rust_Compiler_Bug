{"sha": "35812d1746b8b98200533bd2bef18649ef5807d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ODEyZDE3NDZiOGI5ODIwMDUzM2JkMmJlZjE4NjQ5ZWY1ODA3ZDE=", "commit": {"author": {"name": "achernyak", "email": "artemchernyak@gmail.com", "date": "2017-05-09T19:40:42Z"}, "committer": {"name": "achernyak", "email": "artemchernyak@gmail.com", "date": "2017-05-09T22:23:41Z"}, "message": "resolved merge conflicts", "tree": {"sha": "7fa9c1b6863a7d995f7058993894b0ccb6012f11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fa9c1b6863a7d995f7058993894b0ccb6012f11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35812d1746b8b98200533bd2bef18649ef5807d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35812d1746b8b98200533bd2bef18649ef5807d1", "html_url": "https://github.com/rust-lang/rust/commit/35812d1746b8b98200533bd2bef18649ef5807d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35812d1746b8b98200533bd2bef18649ef5807d1/comments", "author": {"login": "hackeryarn", "id": 827709, "node_id": "MDQ6VXNlcjgyNzcwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/827709?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hackeryarn", "html_url": "https://github.com/hackeryarn", "followers_url": "https://api.github.com/users/hackeryarn/followers", "following_url": "https://api.github.com/users/hackeryarn/following{/other_user}", "gists_url": "https://api.github.com/users/hackeryarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/hackeryarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hackeryarn/subscriptions", "organizations_url": "https://api.github.com/users/hackeryarn/orgs", "repos_url": "https://api.github.com/users/hackeryarn/repos", "events_url": "https://api.github.com/users/hackeryarn/events{/privacy}", "received_events_url": "https://api.github.com/users/hackeryarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hackeryarn", "id": 827709, "node_id": "MDQ6VXNlcjgyNzcwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/827709?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hackeryarn", "html_url": "https://github.com/hackeryarn", "followers_url": "https://api.github.com/users/hackeryarn/followers", "following_url": "https://api.github.com/users/hackeryarn/following{/other_user}", "gists_url": "https://api.github.com/users/hackeryarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/hackeryarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hackeryarn/subscriptions", "organizations_url": "https://api.github.com/users/hackeryarn/orgs", "repos_url": "https://api.github.com/users/hackeryarn/repos", "events_url": "https://api.github.com/users/hackeryarn/events{/privacy}", "received_events_url": "https://api.github.com/users/hackeryarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfb740f83ca1d6f2056f5cf8de1adbe81b973438", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfb740f83ca1d6f2056f5cf8de1adbe81b973438", "html_url": "https://github.com/rust-lang/rust/commit/dfb740f83ca1d6f2056f5cf8de1adbe81b973438"}, {"sha": "f3fc547194d22dc673274ac20e9a7b1e607cb862", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fc547194d22dc673274ac20e9a7b1e607cb862", "html_url": "https://github.com/rust-lang/rust/commit/f3fc547194d22dc673274ac20e9a7b1e607cb862"}], "stats": {"total": 14112, "additions": 11479, "deletions": 2633}, "files": [{"sha": "ee5b6f257b555ec4d9f4a551544f6a27ad356aeb", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -139,6 +139,7 @@ Margaret Meyerhofer <mmeyerho@andrew.cmu.edu> <mmeyerho@andrew>\n Mark Sinclair <mark.edward.x@gmail.com>\n Mark Sinclair <mark.edward.x@gmail.com> =Mark Sinclair <=125axel125@gmail.com>\n Markus Westerlind <marwes91@gmail.com> Markus <marwes91@gmail.com>\n+Martin Hafskjold Thoresen <martinhath@gmail.com>\n Matej Lach <matej.lach@gmail.com> Matej \u013dach <matej.lach@gmail.com>\n Matt Brubeck <mbrubeck@limpet.net> <mbrubeck@cs.hmc.edu>\n Matthew Auld <matthew.auld@intel.com>"}, {"sha": "4fcf6f02defc4bd4666574d5247fc6a69d16f92d", "filename": ".travis.yml", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -95,7 +95,10 @@ matrix:\n         MACOSX_DEPLOYMENT_TARGET=10.7\n       os: osx\n       osx_image: xcode7\n-      install: *osx_install_sccache\n+      install:\n+        - travis_retry brew update\n+        - travis_retry brew install xz\n+        - *osx_install_sccache\n     - env: >\n         RUST_CHECK_TARGET=dist\n         RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-extended --enable-sanitizers\"\n@@ -106,7 +109,10 @@ matrix:\n         MACOSX_DEPLOYMENT_TARGET=10.7\n       os: osx\n       osx_image: xcode7\n-      install: *osx_install_sccache\n+      install:\n+        - travis_retry brew update\n+        - travis_retry brew install xz\n+        - *osx_install_sccache\n \n     # \"alternate\" deployments, these are \"nightlies\" but don't have assertions\n     # turned on, they're deployed to a different location primarily for projects\n@@ -123,7 +129,10 @@ matrix:\n         MACOSX_DEPLOYMENT_TARGET=10.7\n       os: osx\n       osx_image: xcode7\n-      install: *osx_install_sccache\n+      install:\n+        - travis_retry brew update\n+        - travis_retry brew install xz\n+        - *osx_install_sccache\n \n env:\n   global:\n@@ -185,7 +194,7 @@ after_failure:\n \n # Save tagged docker images we created and load them if they're available\n # Travis saves caches whether the build failed or not, nuke rustsrc if\n-# the failure was while updating it (as it may be in an bad state)\n+# the failure was while updating it (as it may be in a bad state)\n # https://github.com/travis-ci/travis-ci/issues/4472\n before_cache:\n   - docker history -q rust-ci |"}, {"sha": "db41f0dfb94f388be9b8c405fa34def58bf29b62", "filename": "configure", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/configure", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -510,7 +510,6 @@ valopt default-ar     \"ar\" \"the default ar\"\n opt_nosave manage-submodules 1 \"let the build manage the git submodules\"\n opt_nosave clang 0 \"prefer clang to gcc for building the runtime\"\n opt_nosave jemalloc 1 \"build liballoc with jemalloc\"\n-opt elf-tls 1 \"elf thread local storage on platforms where supported\"\n opt full-bootstrap 0 \"build three compilers instead of two\"\n opt extended 0 \"build an extended rust tool set\"\n "}, {"sha": "3dd8231a49f69acb68ec78dc5bbaccf25b18e49e", "filename": "src/Cargo.lock", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -411,16 +411,16 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"rls-data\"\n-version = \"0.1.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rls-span 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rls-span\"\n-version = \"0.1.0\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -719,10 +719,11 @@ name = \"rustc_save_analysis\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-span 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_typeck 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -793,6 +794,7 @@ dependencies = [\n  \"rustc_metadata 0.0.0\",\n  \"rustc_resolve 0.0.0\",\n  \"rustc_trans 0.0.0\",\n+ \"rustc_typeck 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -858,8 +860,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"syntax\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_bitflags 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -1019,8 +1021,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0aad603e8d7fb67da22dbdf1f4b826ce8829e406124109e73cf1b2454b93a71c\"\n \"checksum regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4278c17d0f6d62dfef0ab00028feb45bd7d2102843f80763474eeb1be8a10c01\"\n \"checksum regex-syntax 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9191b1f57603095f105d317e375d19b1c9c5c3185ea9633a99a6dcbed04457\"\n-\"checksum rls-data 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"af1dfff00189fd7b78edb9af131b0de703676c04fa8126aed77fd2c586775a4d\"\n-\"checksum rls-span 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8656f7b850ac85fb204ef94318c641bbb15a32766e12f9a589a23e4c0fbc38db\"\n+\"checksum rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fc4277ce3c57f456b11fe3145b181a844a25201bab5cbaa1978457e6e2f27d47\"\n+\"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n \"checksum rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\" = \"684ce48436d6465300c9ea783b6b14c4361d6b8dcbb1375b486a69cc19e2dfb0\"\n \"checksum serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a702319c807c016e51f672e5c77d6f0b46afddd744b5e437d6b8436b888b458f\"\n \"checksum serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbc45439552eb8fb86907a2c41c1fd0ef97458efb87ff7f878db466eb581824e\""}, {"sha": "d24bb074cd374d13bb50ad7cc8ce670f090e65c6", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -529,7 +529,7 @@ fn find_tests(dir: &Path,\n     }\n }\n \n-pub fn emulator_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n+pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n     if !build.remote_tested(target) {\n         return\n     }"}, {"sha": "970c0bc565d864c533c255483c8a0e63a1d12d8c", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -307,7 +307,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n                  .dep(|s| s.name(\"libtest\"))\n                  .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n                  .dep(|s| s.name(\"test-helpers\"))\n-                 .dep(|s| s.name(\"emulator-copy-libs\"))\n+                 .dep(|s| s.name(\"remote-copy-libs\"))\n                  .default(mode != \"pretty\") // pretty tests don't run everywhere\n                  .run(move |s| {\n                      check::compiletest(build, &s.compiler(), s.target, mode, dir)\n@@ -346,7 +346,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n              .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n              .dep(|s| s.name(\"test-helpers\"))\n              .dep(|s| s.name(\"debugger-scripts\"))\n-             .dep(|s| s.name(\"emulator-copy-libs\"))\n+             .dep(|s| s.name(\"remote-copy-libs\"))\n              .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n                                          \"debuginfo-gdb\", \"debuginfo\"));\n         let mut rule = rules.test(\"check-debuginfo\", \"src/test/debuginfo\");\n@@ -400,14 +400,14 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     for (krate, path, _default) in krates(\"std\") {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"emulator-copy-libs\"))\n+             .dep(|s| s.name(\"remote-copy-libs\"))\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Libstd, TestKind::Test,\n                                         Some(&krate.name)));\n     }\n     rules.test(\"check-std-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n-         .dep(|s| s.name(\"emulator-copy-libs\"))\n+         .dep(|s| s.name(\"remote-copy-libs\"))\n          .default(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                     Mode::Libstd, TestKind::Test, None));\n@@ -416,44 +416,44 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     for (krate, path, _default) in krates(\"std\") {\n         rules.bench(&krate.bench_step, path)\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"emulator-copy-libs\"))\n+             .dep(|s| s.name(\"remote-copy-libs\"))\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Libstd, TestKind::Bench,\n                                         Some(&krate.name)));\n     }\n     rules.bench(\"bench-std-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n-         .dep(|s| s.name(\"emulator-copy-libs\"))\n+         .dep(|s| s.name(\"remote-copy-libs\"))\n          .default(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                     Mode::Libstd, TestKind::Bench, None));\n \n     for (krate, path, _default) in krates(\"test\") {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"emulator-copy-libs\"))\n+             .dep(|s| s.name(\"remote-copy-libs\"))\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Libtest, TestKind::Test,\n                                         Some(&krate.name)));\n     }\n     rules.test(\"check-test-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n-         .dep(|s| s.name(\"emulator-copy-libs\"))\n+         .dep(|s| s.name(\"remote-copy-libs\"))\n          .default(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                     Mode::Libtest, TestKind::Test, None));\n     for (krate, path, _default) in krates(\"rustc-main\") {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"librustc\"))\n-             .dep(|s| s.name(\"emulator-copy-libs\"))\n+             .dep(|s| s.name(\"remote-copy-libs\"))\n              .host(true)\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Librustc, TestKind::Test,\n                                         Some(&krate.name)));\n     }\n     rules.test(\"check-rustc-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"librustc\"))\n-         .dep(|s| s.name(\"emulator-copy-libs\"))\n+         .dep(|s| s.name(\"remote-copy-libs\"))\n          .default(true)\n          .host(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n@@ -500,17 +500,17 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.build(\"openssl\", \"path/to/nowhere\")\n          .run(move |s| native::openssl(build, s.target));\n \n-    // Some test suites are run inside emulators, and most of our test binaries\n-    // are linked dynamically which means we need to ship the standard library\n-    // and such to the emulator ahead of time. This step represents this and is\n-    // a dependency of all test suites.\n+    // Some test suites are run inside emulators or on remote devices, and most\n+    // of our test binaries are linked dynamically which means we need to ship\n+    // the standard library and such to the emulator ahead of time. This step\n+    // represents this and is a dependency of all test suites.\n     //\n     // Most of the time this step is a noop (the `check::emulator_copy_libs`\n     // only does work if necessary). For some steps such as shipping data to\n     // QEMU we have to build our own tools so we've got conditional dependencies\n-    // on those programs as well. Note that the QEMU client is built for the\n-    // build target (us) and the server is built for the target.\n-    rules.test(\"emulator-copy-libs\", \"path/to/nowhere\")\n+    // on those programs as well. Note that the remote test client is built for\n+    // the build target (us) and the server is built for the target.\n+    rules.test(\"remote-copy-libs\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n          .dep(move |s| {\n              if build.remote_tested(s.target) {\n@@ -526,7 +526,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n                  Step::noop()\n              }\n          })\n-         .run(move |s| check::emulator_copy_libs(build, &s.compiler(), s.target));\n+         .run(move |s| check::remote_copy_libs(build, &s.compiler(), s.target));\n \n     rules.test(\"check-bootstrap\", \"src/bootstrap\")\n          .default(true)"}, {"sha": "6fa139b1630a9bb95dcd60cfc90aff9c19e54580", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -1 +1 @@\n-Subproject commit 616b98444ff4eb5260deee95ee3e090dfd98b947\n+Subproject commit 6fa139b1630a9bb95dcd60cfc90aff9c19e54580"}, {"sha": "323d49e46912001c9610ddf3357e1acb80a057e3", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -1,14 +1,14 @@\n % Rustc UX guidelines\n \n Don't forget the user. Whether human or another program, such as an IDE, a\n-good user experience with the compiler goes a long way into making developer\n-lives better. We don't want users to be baffled by compiler output or\n+good user experience with the compiler goes a long way toward making developers'\n+lives better. We do not want users to be baffled by compiler output or\n learn arcane patterns to compile their program.\n \n ## Error, Warning, Help, Note Messages\n \n-When the compiler detects a problem, it can emit either an error, warning,\n-note, or help message.\n+When the compiler detects a problem, it can emit one of the following: an error, a warning,\n+a note, or a help message.\n \n An `error` is emitted when the compiler detects a problem that makes it unable\n  to compile the program, either because the program is invalid or the\n@@ -17,11 +17,11 @@ An `error` is emitted when the compiler detects a problem that makes it unable\n A `warning` is emitted when the compiler detects something odd about a\n program. For instance, dead code and unused `Result` values.\n \n-A `help` is emitted following either an `error` or `warning` giving extra\n+A `help` message is emitted following an `error` or `warning` to give additional\n information to the user about how to solve their problem.\n \n-A `note` is for identifying additional circumstances and parts of the code\n-that lead to a warning or error. For example, the borrow checker will note any\n+A `note` is emitted to identify additional circumstances and parts of the code\n+that caused the warning or error. For example, the borrow checker will note any\n previous conflicting borrows.\n \n * Write in plain simple English. If your message, when shown on a \u2013 possibly\n@@ -56,18 +56,22 @@ Error explanations are long form descriptions of error messages provided with\n the compiler. They are accessible via the `--explain` flag. Each explanation\n comes with an example of how to trigger it and advice on how to fix it.\n \n+Please read [RFC 1567](https://github.com/rust-lang/rfcs/blob/master/text/1567-long-error-codes-explanation-normalization.md)\n+for details on how to format and write long error codes.\n+\n * All of them are accessible [online](http://doc.rust-lang.org/error-index.html),\n   which are auto-generated from rustc source code in different places:\n   [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/diagnostics.rs),\n+  [libsyntax](https://github.com/rust-lang/rust/blob/master/src/libsyntax/diagnostics.rs),\n   [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/diagnostics.rs),\n   [librustc_const_eval](https://github.com/rust-lang/rust/blob/master/src/librustc_const_eval/diagnostics.rs),\n-  [librustc_lint](https://github.com/rust-lang/rust/blob/master/src/librustc_lint/types.rs),\n   [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/diagnostics.rs),\n   [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/diagnostics.rs),\n   [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/diagnostics.rs),\n   [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/diagnostics.rs),\n   [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/diagnostics.rs),\n   [librustc_trans](https://github.com/rust-lang/rust/blob/master/src/librustc_trans/diagnostics.rs),\n+  [librustc_plugin](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/diagnostics.rs),\n   [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/diagnostics.rs).\n * Explanations have full markdown support. Use it, especially to highlight\n code with backticks.\n@@ -79,7 +83,7 @@ code with backticks.\n * Flags should be orthogonal to each other. For example, if we'd have a\n json-emitting variant of multiple actions `foo` and `bar`, an additional\n --json flag is better than adding `--foo-json` and `--bar-json`.\n-* Always give options a long descriptive name, if only for better\n+* Always give options a long descriptive name, if only for more\n understandable compiler scripts.\n * The `--verbose` flag is for adding verbose information to `rustc` output\n when not compiling a program. For example, using it with the `--version` flag"}, {"sha": "a1897e6bf6100bd692a34e7f9899bdf5eee9afc6", "filename": "src/etc/platform-intrinsics/hexagon/hvx_v60.json", "status": "added", "additions": 1326, "deletions": 0, "changes": 1326, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fetc%2Fplatform-intrinsics%2Fhexagon%2Fhvx_v60.json", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fetc%2Fplatform-intrinsics%2Fhexagon%2Fhvx_v60.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fhexagon%2Fhvx_v60.json?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,1326 @@\n+{\n+    \"platform\": \"Q6_\",\n+    \"intrinsic_prefix\": \"\",\n+    \"llvm_prefix\": \"llvm.hexagon.V6.\",\n+    \"number_info\": {\n+        \"signed\": {\n+            \"kind\": \"s\",\n+            \"data_type\": { \"8\": \"b\", \"16\": \"h\", \"32\": \"w\" },\n+            \"data_type_plain\": { \"8\": \"b\", \"16\": \"h\", \"32\": \"w\" }\n+        },\n+        \"unsigned\": {\n+            \"kind\": \"u\",\n+            \"data_type\": { \"8\": \"ub\", \"16\": \"uh\", \"32\": \"uw\" },\n+            \"data_type_plain\": { \"8\": \"b\", \"16\": \"h\", \"32\": \"w\" }\n+        },\n+        \"float\": {\n+            \"kind\": \"f\",\n+            \"data_type\": { \"8\": \"b\", \"16\": \"h\", \"32\": \"w\" },\n+            \"data_type_plain\": { \"8\": \"b\", \"16\": \"h\", \"32\": \"w\" }\n+        }\n+    },\n+    \"width_info\": {\n+        \"64\": { \"width_b\": \"64\", \"width_suffix\": \"\" },\n+        \"128\": { \"width_b\": \"128\", \"width_suffix\": \".128B\" },\n+        \"512\": { \"width_b\": \"64\", \"width_suffix\": \"\" },\n+        \"1024\": { \"widthd_b\": \"64\", \"width_b\": \"128\", \"width_suffix\": \".128B\",  \"widthd_suffix\": \"\" },\n+        \"2048\": { \"widthd_b\": \"128\", \"widthd_suffix\": \".128B\" }\n+    },\n+    \"intrinsics\": [\n+        {\n+            \"intrinsic\": \"R_vextract{1.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"extractw{1.width_suffix}\",\n+            \"ret\": \"U32\",\n+            \"args\": [\"u32\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_lo{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"lo{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0d\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_hi{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"hi{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0d\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vsplat_R{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"lvsplat{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0S\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_and_QQ{0.width_b}\",\n+            \"width\": [64, 128],\n+            \"llvm\": \"pred.and{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_not_Q{0.width_b}\",\n+            \"width\": [64, 128],\n+            \"llvm\": \"pred.not{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_or_QQ{0.width_b}\",\n+            \"width\": [64, 128],\n+            \"llvm\": \"pred.or{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_xor_QQ{0.width_b}\",\n+            \"width\": [64, 128],\n+            \"llvm\": \"pred.xor{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vabsdiff_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vabsdiff{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"u(8-16)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vabsdiff_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vabsdiff{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"u(16-32)\",\n+            \"args\": [\"0s\", \"0s\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vabs_V{1.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vabs{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vabs_V{1.data_type}_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vabs{1.data_type}.sat{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vadd_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vadd{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(8-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vadd_V{1.data_type}V{2.data_type}_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vadd{0.data_type}sat{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vadd_V{1.data_type}V{2.data_type}_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vadd{0.data_type}sat{0.width_suffix}\",\n+            \"ret\": \"u(8-16)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vadd_W{1.data_type}W{2.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vadd{0.data_type}.dv{0.widthd_suffix}\",\n+            \"ret\": \"s(8-32)d\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vadd_W{1.data_type}W{2.data_type}_sat{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vadd{0.data_type}sat.dv{0.widthd_suffix}\",\n+            \"ret\": \"s(16-32)d\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vadd_W{1.data_type}W{2.data_type}_sat{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vadd{0.data_type}sat.dv{0.widthd_suffix}\",\n+            \"ret\": \"u(8-16)d\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_valign_VVR{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"valignb{0.width_suffix}\",\n+            \"ret\": \"u8\",\n+            \"args\": [\"0\", \"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_valign_VVI{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"valignbi{0.width_suffix}\",\n+            \"ret\": \"u8\",\n+            \"args\": [\"0\", \"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vlalign_VVR{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vlalignb{0.width_suffix}\",\n+            \"ret\": \"u8\",\n+            \"args\": [\"0\", \"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vlalign_VVI{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vlalignbi{0.width_suffix}\",\n+            \"ret\": \"u8\",\n+            \"args\": [\"0\", \"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vand_VV{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vand{0.width_suffix}\",\n+            \"ret\": \"u16\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vand_QR{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vandqrt{0.width_suffix}\",\n+            \"ret\": \"u8\",\n+            \"args\": [\"u32hhh\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vandor_VQR{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vandqrt.acc{0.width_suffix}\",\n+            \"ret\": \"u8\",\n+            \"args\": [\"0\", \"u32hhh\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vand_VR{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vandvrt{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"u8\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vandor_QVR{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vandvrt{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"0\", \"u8\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vasl_V{1.data_type}R{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vasl{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vasl_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vasl{0.data_type}v{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vaslacc_V{1.data_type}V{2.data_type}R{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vasl{0.data_type}.acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vasr_V{1.data_type}R{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vasr{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vasr_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vasr{0.data_type}v{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vasracc_V{1.data_type}V{2.data_type}R{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vasr{0.data_type}.acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vasr_V{1.data_type}V{2.data_type}R{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vasr{0.data_type}{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"0hw\", \"0hw\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vasr_V{1.data_type}V{2.data_type}R_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vasr{1.data_type}{0.data_type_plain}sat{0.width_suffix}\",\n+            \"ret\": \"i(8-16)\",\n+            \"args\": [\"0hws\", \"0hws\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vasr_V{1.data_type}V{2.data_type}R_rnd_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vasr{1.data_type}{0.data_type_plain}rndsat{0.width_suffix}\",\n+            \"ret\": \"i(8-16)\",\n+            \"args\": [\"0hws\", \"0hws\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_equals_V{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vassign{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W_equals_W{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vassignp{0.widthd_suffix}\",\n+            \"ret\": \"u32d\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vavg_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vavg{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vavg_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vavg{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"u(8-16)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vavg_V{1.data_type}V{2.data_type}_rnd{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vavgrnd{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vavg_V{1.data_type}V{2.data_type}_rnd{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vavgrnd{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"u(8-16)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vcl0_V{1.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vcl0{0.data_type_plain}{0.width_suffix}\",\n+            \"ret\": \"u(16-32)\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W_vcombine_VV{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vcombine{0.widthd_suffix}\",\n+            \"ret\": \"u8d\",\n+            \"args\": [\"0h\", \"0h\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vzero{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vd0{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdeal_V{1.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdeal{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(8-16)\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdeale_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdeal{1.data_type}4w{0.width_suffix}\",\n+            \"ret\": \"s8\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W_vdeal_VVR{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdealvdd{0.widthd_suffix}\",\n+            \"ret\": \"u8d\",\n+            \"args\": [\"0h\", \"0h\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vdelta_VV{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdelta{0.width_suffix}\",\n+            \"ret\": \"u8\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpy_V{1.data_type}Rb{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpybus{0.width_suffix}\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"u8\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpyacc_V{1.data_type}V{2.data_type}Rb{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpybus.acc{0.width_suffix}\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"s16\", \"u8\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vdmpy_W{1.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpybus.dv{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vdmpyacc_W{1.data_type}W{2.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpybus.dv.acc{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"s16d\", \"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpy_V{1.data_type}Rb{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhb{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"s16\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpyacc_V{1.data_type}V{2.data_type}Rb{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhb.acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"s32\", \"s16\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vdmpy_W{1.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhb.dv{0.widthd_suffix}\",\n+            \"ret\": \"s32d\",\n+            \"args\": [\"s16d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vdmpyacc_W{1.data_type}W{2.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhb.dv.acc{0.widthd_suffix}\",\n+            \"ret\": \"s32d\",\n+            \"args\": [\"s32d\", \"s16d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpy_W{1.data_type}Rh_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhisat{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpy_V{1.data_type}Rh_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhsat{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"s16\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpy_W{1.data_type}Ruh_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhsuisat{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"s16d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpy_V{1.data_type}Ruh_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhsusat{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"s16\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpy_V{1.data_type}V{2.data_type}_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhvsat{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"s16\", \"s16\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpyacc_V{1.data_type}W{2.data_type}Rh_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhisat_acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vdsad_W{1.data_type}Ruh{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdsaduh{0.widthd_suffix}\",\n+            \"ret\": \"u32d\",\n+            \"args\": [\"u16d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vdsadacc_W{1.data_type}W{2.data_type}Ruh{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdsaduh.acc{0.widthd_suffix}\",\n+            \"ret\": \"u32d\",\n+            \"args\": [\"0\", \"u16d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpyacc_V{1.data_type}V{2.data_type}Rh_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhsat_acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"s16\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpyacc_V{1.data_type}W{2.data_type}Ruh_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhsuisat_acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"s16d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpyacc_V{1.data_type}V{2.data_type}Ruh_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhsusat_acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"s16\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vdmpyacc_V{1.data_type}V{2.data_type}V{3.data_type}_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vdmpyhvsat_acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"s16\", \"s16\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_eq_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"veq{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"s(8-32)\", \"1\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_eqand_QV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"veq{2.data_type}.and{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"0\", \"s(8-32)\", \"2\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_eqor_QV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"veq{2.data_type}.or{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"0\", \"s(8-32)\", \"2\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_eqxacc_QV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"veq{2.data_type}.xor{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"0\", \"s(8-32)\", \"2\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_gt_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vgt{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"s(8-32)\", \"1\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_gt_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vgt{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"u(8-16)\", \"1\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_gtand_QV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vgt{2.data_type}.and{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"0\", \"s(8-32)\", \"2\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_gtand_QV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vgt{2.data_type}.and{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"0\", \"u(8-16)\", \"2\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_gtor_QV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vgt{2.data_type}.or{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"0\", \"s(8-32)\", \"2\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_gtor_QV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vgt{2.data_type}.or{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"0\", \"u(8-16)\", \"2\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_gtxacc_QV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vgt{2.data_type}.xor{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"0\", \"s(8-32)\", \"2\"]\n+        },\n+        {\n+            \"intrinsic\": \"Q_vcmp_gtxacc_QV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vgt{2.data_type}.xor{0.width_suffix}\",\n+            \"ret\": \"u32hhh\",\n+            \"args\": [\"0\", \"u(8-16)\", \"2\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vinsert_V{1.data_type}R{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vinsertwr{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"S32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vlsr_V{1.data_type}R{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vlsr{0.data_type_plain}{0.width_suffix}\",\n+            \"ret\": \"u(16-32)\",\n+            \"args\": [\"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vlsr_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vlsr{0.data_type}v{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vlut32_V{1.data_type}V{2.data_type}R{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vlutvv{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s8\",\n+            \"args\": [\"0\", \"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vlut16_V{1.data_type}V{2.data_type}R{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vlutvw{0.data_type}{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"s8\", \"s16\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vlut32or_V{1.data_type}V{2.data_type}V{3.data_type}R{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vlutvv{0.data_type}.oracc{0.width_suffix}\",\n+            \"ret\": \"s8\",\n+            \"args\": [\"0\", \"0\", \"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vlut16or_W{1.data_type}V{2.data_type}V{3.data_type}R{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vlutvw{0.data_type}.oracc{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"0\", \"s8\", \"s16\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmax_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmax{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmax_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmax{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"u(8-16)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmin_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmin{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmin_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmin{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"u(8-16)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpa_W{1.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpabus{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpaacc_W{1.data_type}W{2.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpabus.acc{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"0\", \"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpa_W{1.data_type}W{2.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpab{1.kind}{2.kind}v{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"u8d\", \"i8d\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpa_W{1.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpahb{0.widthd_suffix}\",\n+            \"ret\": \"s32d\",\n+            \"args\": [\"s16d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpaacc_W{1.data_type}W{2.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpahb.acc{0.widthd_suffix}\",\n+            \"ret\": \"s32d\",\n+            \"args\": [\"0\", \"s16d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpy_V{1.data_type}V{2.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpy{1.data_type}us{0.widthd_suffix}\",\n+            \"ret\": \"s(16-32)d\",\n+            \"args\": [\"0n\", \"0nu\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpyacc_W{1.data_type}V{2.data_type}V{3.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpy{2.data_type}us.acc{0.widthd_suffix}\",\n+            \"ret\": \"s(16-32)d\",\n+            \"args\": [\"0\", \"0n\", \"0nu\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpy_V{1.data_type}V{2.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpybusv{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"u8\", \"s8\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpyacc_W{1.data_type}V{2.data_type}V{3.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpybusv.acc{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"0\", \"0nu\", \"0n\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpy_V{1.data_type}V{2.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpy{1.data_type}v{0.widthd_suffix}\",\n+            \"ret\": \"i(16-32)d\",\n+            \"args\": [\"0n\", \"0n\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpyacc_W{1.data_type}V{2.data_type}V{3.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpy{2.data_type}v.acc{0.widthd_suffix}\",\n+            \"ret\": \"i(16-32)d\",\n+            \"args\": [\"0\", \"0n\", \"0n\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpye_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyewuh{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"s32\", \"u16\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpy_V{1.data_type}R{1.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpy{1.data_type}{0.widthd_suffix}\",\n+            \"ret\": \"i32d\",\n+            \"args\": [\"0n\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpyacc_W{1.data_type}V{2.data_type}R{2.data_type}_sat{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpy{2.data_type}sat.acc{0.widthd_suffix}\",\n+            \"ret\": \"s32d\",\n+            \"args\": [\"0\", \"0n\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpy_V{1.data_type}R{1.data_type}_s1_rnd_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpy{1.data_type}srs{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0nd\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpy_V{1.data_type}R{1.data_type}_s1_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpy{1.data_type}ss{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0nd\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpy_V{1.data_type}V{2.data_type}_s1_rnd_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpy{1.data_type}vsrs{0.width_suffix}\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyieo_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyieo{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0nd\", \"0nd\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyieacc_V{1.data_type}V{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyie{2.data_type}{3.data_type}.acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0\", \"i16\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyie_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyie{1.data_type}{2.data_type}{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"u16\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyi_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyi{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyiacc_V{1.data_type}V{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyi{1.data_type}.acc{0.width_suffix}\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"0\", \"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyi_V{1.data_type}Rb{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyi{1.data_type}b{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyiacc_V{1.data_type}V{2.data_type}Rb{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyi{1.data_type}b.acc{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyi_V{1.data_type}Rh{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyi{1.data_type}h{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyiacc_V{1.data_type}V{2.data_type}Rh{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyi{1.data_type}h.acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyi_V{1.data_type}Rub{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyi{1.data_type}ub{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyiacc_V{1.data_type}V{2.data_type}Rub{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyi{1.data_type}ub.acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyo_V{1.data_type}V{2.data_type}_s1_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyo{1.data_type}{2.data_type}{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0nd\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyo_V{1.data_type}V{2.data_type}_s1_rnd_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyo{1.data_type}{2.data_type}.rnd{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0nd\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyo_V{1.data_type}V{2.data_type}_s1_rnd_sat_shift{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyo{1.data_type}{2.data_type}.rnd.sacc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0nd\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyo_V{1.data_type}V{2.data_type}_s1_sat_shift{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyo{1.data_type}{2.data_type}.sacc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0nd\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmpyio_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpyio{1.data_type}{2.data_type}{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0nd\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpy_V{1.data_type}R{1.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpy{1.data_type}{0.widthd_suffix}\",\n+            \"ret\": \"u16d\",\n+            \"args\": [\"0n\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vmpyacc_W{1.data_type}V{2.data_type}R{2.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmpy{2.data_type}.acc{0.widthd_suffix}\",\n+            \"ret\": \"u(16-32)d\",\n+            \"args\": [\"0\", \"0n\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vmux_QVV{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vmux{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0hhh\", \"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vnavg_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vnavg{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"i(16-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vnavg_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vnavg{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"u8\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vnormamt_V{1.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vnormamt{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vnot_VV{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vnot{0.width_suffix}\",\n+            \"ret\": \"u16\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vor_VV{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vor{0.width_suffix}\",\n+            \"ret\": \"u16\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vpacke_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vpack{1.data_type}e{0.width_suffix}\",\n+            \"ret\": \"s(8-16)\",\n+            \"args\": [\"0hw\", \"0hw\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vpacko_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vpack{1.data_type}o{0.width_suffix}\",\n+            \"ret\": \"s(8-16)\",\n+            \"args\": [\"0hw\", \"0hw\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vpack_V{1.data_type}V{2.data_type}_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vpack{1.data_type}{0.data_type}.sat{0.width_suffix}\",\n+            \"ret\": \"i(8-16)\",\n+            \"args\": [\"0hws\", \"0hws\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vpopcount_V{1.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vpopcount{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vrdelta_VV{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrdelta{0.width_suffix}\",\n+            \"ret\": \"u8\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vrmpy_V{1.data_type}Rb{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpybus{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"u8\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vrmpyacc_V{1.data_type}V{2.data_type}Rb{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpybus.acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"u8\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vrmpy_W{1.data_type}RbI{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpybusi{0.widthd_suffix}\",\n+            \"ret\": \"s32d\",\n+            \"args\": [\"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vrmpyacc_W{1.data_type}W{2.data_type}RbI{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpybusi.acc{0.widthd_suffix}\",\n+            \"ret\": \"s32d\",\n+            \"args\": [\"0\", \"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vrmpy_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpybusv{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"u8\", \"s8\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vrmpyacc_V{1.data_type}V{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpybusv.acc{0.width_suffix}\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"u8\", \"s8\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vrmpy_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpy{1.data_type}v{0.width_suffix}\",\n+            \"ret\": \"i32\",\n+            \"args\": [\"0nndd\", \"0nndd\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vrmpyacc_V{1.data_type}V{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpy{1.data_type}v.acc{0.width_suffix}\",\n+            \"ret\": \"i32\",\n+            \"args\": [\"0\", \"0nndd\", \"0nndd\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vrmpy_V{1.data_type}Rub{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpyub{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"u8\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vrmpyacc_V{1.data_type}V{2.data_type}Rub{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpyub.acc{0.width_suffix}\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0\", \"u8\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vrmpy_W{1.data_type}RubI{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpyubi{0.widthd_suffix}\",\n+            \"ret\": \"u32d\",\n+            \"args\": [\"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vrmpyacc_W{1.data_type}W{2.data_type}RubI{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrmpyubi.acc{0.widthd_suffix}\",\n+            \"ret\": \"u32d\",\n+            \"args\": [\"0\", \"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vror_VR{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vror{0.width_suffix}\",\n+            \"ret\": \"u8\",\n+            \"args\": [\"0\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vround_V{1.data_type}V{2.data_type}_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vround{1.data_type}{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"i(8-16)\",\n+            \"args\": [\"0hws\", \"0hws\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vrsad_W{1.data_type}RubI{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrsadubi{0.widthd_suffix}\",\n+            \"ret\": \"u32d\",\n+            \"args\": [\"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vrsadacc_W{1.data_type}W{2.data_type}RubI{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vrsadubi.acc{0.widthd_suffix}\",\n+            \"ret\": \"u32d\",\n+            \"args\": [\"0\", \"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vsat_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vsat{1.data_type}{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"u8\",\n+            \"args\": [\"0hws\", \"0hws\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vsat_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vsat{1.data_type}{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"0hw\", \"0hw\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vsxt_V{1.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vs{1.data_type}{0.widthd_suffix}\",\n+            \"ret\": \"s(16-32)d\",\n+            \"args\": [\"0n\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vzxt_V{1.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vz{1.data_type_plain}{0.widthd_suffix}\",\n+            \"ret\": \"u(16-32)d\",\n+            \"args\": [\"0n\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_condacc_QV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vadd{0.data_type}q{0.width_suffix}\",\n+            \"ret\": \"s(8-32)\",\n+            \"args\": [\"u32hhh\", \"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_condacc_QnV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vadd{0.data_type}nq{0.width_suffix}\",\n+            \"ret\": \"s(8-32)\",\n+            \"args\": [\"u32hhh\", \"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_condnac_QV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vsub{0.data_type}q{0.width_suffix}\",\n+            \"ret\": \"s(8-32)\",\n+            \"args\": [\"u32hhh\", \"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_condnac_QnV{2.data_type}V{3.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vsub{0.data_type}nq{0.width_suffix}\",\n+            \"ret\": \"s(8-32)\",\n+            \"args\": [\"u32hhh\", \"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vshuffe_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vshufe{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vshuffo_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vshufo{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vshuff_V{1.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vshuff{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(8-16)\",\n+            \"args\": [\"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vshuffe_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vshuffe{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"s8\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vshuffo_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vshuffo{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"s8\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vshuffoe_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vshuffoe{1.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(8-16)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W_vshuff_VVR{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vshufvvd{0.widthd_suffix}\",\n+            \"ret\": \"u8d\",\n+            \"args\": [\"0h\", \"0h\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vsub_V{1.data_type}V{2.data_type}{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vsub{0.data_type}{0.width_suffix}\",\n+            \"ret\": \"s(8-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vsub_V{1.data_type}V{2.data_type}_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vsub{0.data_type}sat{0.width_suffix}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"V{0.data_type}_vsub_V{1.data_type}V{2.data_type}_sat{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vsub{0.data_type}sat{0.width_suffix}\",\n+            \"ret\": \"u(8-16)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vsub_W{1.data_type}W{2.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vsub{0.data_type}.dv{0.widthd_suffix}\",\n+            \"ret\": \"s(8-32)d\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vsub_W{1.data_type}W{2.data_type}_sat{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vsub{0.data_type}sat.dv{0.widthd_suffix}\",\n+            \"ret\": \"s(16-32)d\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vsub_W{1.data_type}W{2.data_type}_sat{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vsub{0.data_type}sat.dv{0.widthd_suffix}\",\n+            \"ret\": \"u(8-16)d\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"W_vswap_QVV{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vswap{0.widthd_suffix}\",\n+            \"ret\": \"u8d\",\n+            \"args\": [\"u32hhh\", \"0h\", \"0h\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vtmpy_W{1.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vtmpyb{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"0nd\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vtmpyacc_W{1.data_type}W{2.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vtmpyb.acc{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"0\", \"0nd\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vtmpy_W{1.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vtmpybus{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vtmpyacc_W{1.data_type}W{2.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vtmpybus.acc{0.widthd_suffix}\",\n+            \"ret\": \"s16d\",\n+            \"args\": [\"0\", \"u8d\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vtmpy_W{1.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vtmpyhb{0.widthd_suffix}\",\n+            \"ret\": \"s32d\",\n+            \"args\": [\"0nd\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vunpack_V{1.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vunpack{1.data_type}{0.widthd_suffix}\",\n+            \"ret\": \"i(16-32)d\",\n+            \"args\": [\"0n\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vunpackoor_W{1.data_type}V{2.data_type}{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vunpacko{2.data_type}{0.widthd_suffix}\",\n+            \"ret\": \"s(16-32)d\",\n+            \"args\": [\"0\", \"0n\"]\n+        },\n+        {\n+            \"intrinsic\": \"W{0.data_type}_vtmpyacc_W{1.data_type}W{2.data_type}Rb{0.widthd_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vtmpyhb.acc{0.widthd_suffix}\",\n+            \"ret\": \"s32d\",\n+            \"args\": [\"0\", \"0nd\", \"U32\"]\n+        },\n+        {\n+            \"intrinsic\": \"V_vxor_VV{0.width_b}\",\n+            \"width\": [512, 1024],\n+            \"llvm\": \"vxor{0.width_suffix}\",\n+            \"ret\": \"u16\",\n+            \"args\": [\"0\", \"0\"]\n+        }\n+    ]\n+}"}, {"sha": "3e4498759434f92723f6a9665fb1fa7bc6d9997c", "filename": "src/grammar/.gitignore", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2F.gitignore?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,3 @@\n+*.class\n+*.java\n+*.tokens"}, {"sha": "77737c99496f34757127d29e0040da0ff7f4fa56", "filename": "src/grammar/lexer.l", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,343 @@\n+%{\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <stdio.h>\n+#include <ctype.h>\n+\n+static int num_hashes;\n+static int end_hashes;\n+static int saw_non_hash;\n+\n+%}\n+\n+%option stack\n+%option yylineno\n+\n+%x str\n+%x rawstr\n+%x rawstr_esc_begin\n+%x rawstr_esc_body\n+%x rawstr_esc_end\n+%x byte\n+%x bytestr\n+%x rawbytestr\n+%x rawbytestr_nohash\n+%x pound\n+%x shebang_or_attr\n+%x ltorchar\n+%x linecomment\n+%x doc_line\n+%x blockcomment\n+%x doc_block\n+%x suffix\n+\n+ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n+\n+%%\n+\n+<suffix>{ident}            { BEGIN(INITIAL); }\n+<suffix>(.|\\n)  { yyless(0); BEGIN(INITIAL); }\n+\n+[ \\n\\t\\r]             { }\n+\n+\\xef\\xbb\\xbf {\n+  // UTF-8 byte order mark (BOM), ignore if in line 1, error otherwise\n+  if (yyget_lineno() != 1) {\n+    return -1;\n+  }\n+}\n+\n+\\/\\/(\\/|\\!)           { BEGIN(doc_line); yymore(); }\n+<doc_line>\\n          { BEGIN(INITIAL);\n+                        yyleng--;\n+                        yytext[yyleng] = 0;\n+                        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n+                      }\n+<doc_line>[^\\n]*      { yymore(); }\n+\n+\\/\\/|\\/\\/\\/\\/         { BEGIN(linecomment); }\n+<linecomment>\\n       { BEGIN(INITIAL); }\n+<linecomment>[^\\n]*   { }\n+\n+\\/\\*(\\*|\\!)[^*]       { yy_push_state(INITIAL); yy_push_state(doc_block); yymore(); }\n+<doc_block>\\/\\*       { yy_push_state(doc_block); yymore(); }\n+<doc_block>\\*\\/       {\n+    yy_pop_state();\n+    if (yy_top_state() == doc_block) {\n+        yymore();\n+    } else {\n+        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n+    }\n+}\n+<doc_block>(.|\\n)     { yymore(); }\n+\n+\\/\\*                  { yy_push_state(blockcomment); }\n+<blockcomment>\\/\\*    { yy_push_state(blockcomment); }\n+<blockcomment>\\*\\/    { yy_pop_state(); }\n+<blockcomment>(.|\\n)   { }\n+\n+_        { return UNDERSCORE; }\n+as       { return AS; }\n+box      { return BOX; }\n+break    { return BREAK; }\n+const    { return CONST; }\n+continue { return CONTINUE; }\n+crate    { return CRATE; }\n+else     { return ELSE; }\n+enum     { return ENUM; }\n+extern   { return EXTERN; }\n+false    { return FALSE; }\n+fn       { return FN; }\n+for      { return FOR; }\n+if       { return IF; }\n+impl     { return IMPL; }\n+in       { return IN; }\n+let      { return LET; }\n+loop     { return LOOP; }\n+match    { return MATCH; }\n+mod      { return MOD; }\n+move     { return MOVE; }\n+mut      { return MUT; }\n+priv     { return PRIV; }\n+proc     { return PROC; }\n+pub      { return PUB; }\n+ref      { return REF; }\n+return   { return RETURN; }\n+self     { return SELF; }\n+static   { return STATIC; }\n+struct   { return STRUCT; }\n+trait    { return TRAIT; }\n+true     { return TRUE; }\n+type     { return TYPE; }\n+typeof   { return TYPEOF; }\n+unsafe   { return UNSAFE; }\n+use      { return USE; }\n+where    { return WHERE; }\n+while    { return WHILE; }\n+\n+{ident}  { return IDENT; }\n+\n+0x[0-9a-fA-F_]+                                    { BEGIN(suffix); return LIT_INTEGER; }\n+0o[0-8_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\n+0b[01_]+                                           { BEGIN(suffix); return LIT_INTEGER; }\n+[0-9][0-9_]*                                       { BEGIN(suffix); return LIT_INTEGER; }\n+[0-9][0-9_]*\\.(\\.|[a-zA-Z])    { yyless(yyleng - 2); BEGIN(suffix); return LIT_INTEGER; }\n+\n+[0-9][0-9_]*\\.[0-9_]*([eE][-\\+]?[0-9_]+)?          { BEGIN(suffix); return LIT_FLOAT; }\n+[0-9][0-9_]*(\\.[0-9_]*)?[eE][-\\+]?[0-9_]+          { BEGIN(suffix); return LIT_FLOAT; }\n+\n+;      { return ';'; }\n+,      { return ','; }\n+\\.\\.\\. { return DOTDOTDOT; }\n+\\.\\.   { return DOTDOT; }\n+\\.     { return '.'; }\n+\\(     { return '('; }\n+\\)     { return ')'; }\n+\\{     { return '{'; }\n+\\}     { return '}'; }\n+\\[     { return '['; }\n+\\]     { return ']'; }\n+@      { return '@'; }\n+#      { BEGIN(pound); yymore(); }\n+<pound>\\! { BEGIN(shebang_or_attr); yymore(); }\n+<shebang_or_attr>\\[ {\n+  BEGIN(INITIAL);\n+  yyless(2);\n+  return SHEBANG;\n+}\n+<shebang_or_attr>[^\\[\\n]*\\n {\n+  // Since the \\n was eaten as part of the token, yylineno will have\n+  // been incremented to the value 2 if the shebang was on the first\n+  // line. This yyless undoes that, setting yylineno back to 1.\n+  yyless(yyleng - 1);\n+  if (yyget_lineno() == 1) {\n+    BEGIN(INITIAL);\n+    return SHEBANG_LINE;\n+  } else {\n+    BEGIN(INITIAL);\n+    yyless(2);\n+    return SHEBANG;\n+  }\n+}\n+<pound>. { BEGIN(INITIAL); yyless(1); return '#'; }\n+\n+\\~     { return '~'; }\n+::     { return MOD_SEP; }\n+:      { return ':'; }\n+\\$     { return '$'; }\n+\\?     { return '?'; }\n+\n+==    { return EQEQ; }\n+=>    { return FAT_ARROW; }\n+=     { return '='; }\n+\\!=   { return NE; }\n+\\!    { return '!'; }\n+\\<=   { return LE; }\n+\\<\\<  { return SHL; }\n+\\<\\<= { return SHLEQ; }\n+\\<    { return '<'; }\n+\\>=   { return GE; }\n+\\>\\>  { return SHR; }\n+\\>\\>= { return SHREQ; }\n+\\>    { return '>'; }\n+\n+\\x27                                  { BEGIN(ltorchar); yymore(); }\n+<ltorchar>static                      { BEGIN(INITIAL); return STATIC_LIFETIME; }\n+<ltorchar>{ident}                     { BEGIN(INITIAL); return LIFETIME; }\n+<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27      { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27       { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\u\\{[0-9a-fA-F]?{6}\\}\\x27  { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>.\\x27                       { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>[\\x80-\\xff]{2,4}\\x27        { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar><<EOF>>                     { BEGIN(INITIAL); return -1; }\n+\n+b\\x22              { BEGIN(bytestr); yymore(); }\n+<bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\n+\n+<bytestr><<EOF>>                { return -1; }\n+<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]   { yymore(); }\n+<bytestr>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n+<bytestr>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n+<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n+<bytestr>(.|\\n)                 { yymore(); }\n+\n+br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n+<rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\n+<rawbytestr_nohash>(.|\\n)   { yymore(); }\n+<rawbytestr_nohash><<EOF>>  { return -1; }\n+\n+br/# {\n+    BEGIN(rawbytestr);\n+    yymore();\n+    num_hashes = 0;\n+    saw_non_hash = 0;\n+    end_hashes = 0;\n+}\n+<rawbytestr># {\n+    if (!saw_non_hash) {\n+        num_hashes++;\n+    } else if (end_hashes != 0) {\n+        end_hashes++;\n+        if (end_hashes == num_hashes) {\n+            BEGIN(INITIAL);\n+            return LIT_BYTE_STR_RAW;\n+        }\n+    }\n+    yymore();\n+}\n+<rawbytestr>\\x22# {\n+    end_hashes = 1;\n+    if (end_hashes == num_hashes) {\n+        BEGIN(INITIAL);\n+        return LIT_BYTE_STR_RAW;\n+    }\n+    yymore();\n+}\n+<rawbytestr>(.|\\n) {\n+    if (!saw_non_hash) {\n+        saw_non_hash = 1;\n+    }\n+    if (end_hashes != 0) {\n+        end_hashes = 0;\n+    }\n+    yymore();\n+}\n+<rawbytestr><<EOF>> { return -1; }\n+\n+b\\x27                        { BEGIN(byte); yymore(); }\n+<byte>\\\\[nrt\\\\\\x27\\x220]\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\x[0-9a-fA-F]{2}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\u[0-9a-fA-F]{4}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\U[0-9a-fA-F]{8}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>.\\x27                  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte><<EOF>>                { BEGIN(INITIAL); return -1; }\n+\n+r\\x22           { BEGIN(rawstr); yymore(); }\n+<rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\n+<rawstr>(.|\\n)  { yymore(); }\n+<rawstr><<EOF>> { return -1; }\n+\n+r/#             {\n+    BEGIN(rawstr_esc_begin);\n+    yymore();\n+    num_hashes = 0;\n+    saw_non_hash = 0;\n+    end_hashes = 0;\n+}\n+\n+<rawstr_esc_begin># {\n+    num_hashes++;\n+    yymore();\n+}\n+<rawstr_esc_begin>\\x22 {\n+    BEGIN(rawstr_esc_body);\n+    yymore();\n+}\n+<rawstr_esc_begin>(.|\\n) { return -1; }\n+\n+<rawstr_esc_body>\\x22/# {\n+  BEGIN(rawstr_esc_end);\n+  yymore();\n+ }\n+<rawstr_esc_body>(.|\\n) {\n+  yymore();\n+ }\n+\n+<rawstr_esc_end># {\n+  end_hashes++;\n+  if (end_hashes == num_hashes) {\n+    BEGIN(INITIAL);\n+    return LIT_STR_RAW;\n+  }\n+  yymore();\n+ }\n+<rawstr_esc_end>[^#] {\n+  end_hashes = 0;\n+  BEGIN(rawstr_esc_body);\n+  yymore();\n+ }\n+\n+<rawstr_esc_begin,rawstr_esc_body,rawstr_esc_end><<EOF>> { return -1; }\n+\n+\\x22                     { BEGIN(str); yymore(); }\n+<str>\\x22                { BEGIN(suffix); return LIT_STR; }\n+\n+<str><<EOF>>                { return -1; }\n+<str>\\\\[n\\nr\\rt\\\\\\x27\\x220] { yymore(); }\n+<str>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n+<str>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n+<str>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n+<str>(.|\\n)                 { yymore(); }\n+\n+\\<-  { return LARROW; }\n+-\\>  { return RARROW; }\n+-    { return '-'; }\n+-=   { return MINUSEQ; }\n+&&   { return ANDAND; }\n+&    { return '&'; }\n+&=   { return ANDEQ; }\n+\\|\\| { return OROR; }\n+\\|   { return '|'; }\n+\\|=  { return OREQ; }\n+\\+   { return '+'; }\n+\\+=  { return PLUSEQ; }\n+\\*   { return '*'; }\n+\\*=  { return STAREQ; }\n+\\/   { return '/'; }\n+\\/=  { return SLASHEQ; }\n+\\^   { return '^'; }\n+\\^=  { return CARETEQ; }\n+%    { return '%'; }\n+%=   { return PERCENTEQ; }\n+\n+<<EOF>> { return 0; }\n+\n+%%"}, {"sha": "db88a1f2999aa56a8fdac9d26472e20c3b9c824f", "filename": "src/grammar/parser-lalr-main.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Fparser-lalr-main.c", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Fparser-lalr-main.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr-main.c?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,203 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+extern int yylex();\n+extern int rsparse();\n+\n+#define PUSHBACK_LEN 4\n+\n+static char pushback[PUSHBACK_LEN];\n+static int verbose;\n+\n+void print(const char* format, ...) {\n+  va_list args;\n+  va_start(args, format);\n+  if (verbose) {\n+    vprintf(format, args);\n+  }\n+  va_end(args);\n+}\n+\n+// If there is a non-null char at the head of the pushback queue,\n+// dequeue it and shift the rest of the queue forwards. Otherwise,\n+// return the token from calling yylex.\n+int rslex() {\n+  if (pushback[0] == '\\0') {\n+    return yylex();\n+  } else {\n+    char c = pushback[0];\n+    memmove(pushback, pushback + 1, PUSHBACK_LEN - 1);\n+    pushback[PUSHBACK_LEN - 1] = '\\0';\n+    return c;\n+  }\n+}\n+\n+// Note: this does nothing if the pushback queue is full. As long as\n+// there aren't more than PUSHBACK_LEN consecutive calls to push_back\n+// in an action, this shouldn't be a problem.\n+void push_back(char c) {\n+  for (int i = 0; i < PUSHBACK_LEN; ++i) {\n+    if (pushback[i] == '\\0') {\n+      pushback[i] = c;\n+      break;\n+    }\n+  }\n+}\n+\n+extern int rsdebug;\n+\n+struct node {\n+  struct node *next;\n+  struct node *prev;\n+  int own_string;\n+  char const *name;\n+  int n_elems;\n+  struct node *elems[];\n+};\n+\n+struct node *nodes = NULL;\n+int n_nodes;\n+\n+struct node *mk_node(char const *name, int n, ...) {\n+  va_list ap;\n+  int i = 0;\n+  unsigned sz = sizeof(struct node) + (n * sizeof(struct node *));\n+  struct node *nn, *nd = (struct node *)malloc(sz);\n+\n+  print(\"# New %d-ary node: %s = %p\\n\", n, name, nd);\n+\n+  nd->own_string = 0;\n+  nd->prev = NULL;\n+  nd->next = nodes;\n+  if (nodes) {\n+    nodes->prev = nd;\n+  }\n+  nodes = nd;\n+\n+  nd->name = name;\n+  nd->n_elems = n;\n+\n+  va_start(ap, n);\n+  while (i < n) {\n+    nn = va_arg(ap, struct node *);\n+    print(\"#   arg[%d]: %p\\n\", i, nn);\n+    print(\"#            (%s ...)\\n\", nn->name);\n+    nd->elems[i++] = nn;\n+  }\n+  va_end(ap);\n+  n_nodes++;\n+  return nd;\n+}\n+\n+struct node *mk_atom(char *name) {\n+  struct node *nd = mk_node((char const *)strdup(name), 0);\n+  nd->own_string = 1;\n+  return nd;\n+}\n+\n+struct node *mk_none() {\n+  return mk_atom(\"<none>\");\n+}\n+\n+struct node *ext_node(struct node *nd, int n, ...) {\n+  va_list ap;\n+  int i = 0, c = nd->n_elems + n;\n+  unsigned sz = sizeof(struct node) + (c * sizeof(struct node *));\n+  struct node *nn;\n+\n+  print(\"# Extending %d-ary node by %d nodes: %s = %p\",\n+        nd->n_elems, c, nd->name, nd);\n+\n+  if (nd->next) {\n+    nd->next->prev = nd->prev;\n+  }\n+  if (nd->prev) {\n+    nd->prev->next = nd->next;\n+  }\n+  nd = realloc(nd, sz);\n+  nd->prev = NULL;\n+  nd->next = nodes;\n+  nodes->prev = nd;\n+  nodes = nd;\n+\n+  print(\" ==> %p\\n\", nd);\n+\n+  va_start(ap, n);\n+  while (i < n) {\n+    nn = va_arg(ap, struct node *);\n+    print(\"#   arg[%d]: %p\\n\", i, nn);\n+    print(\"#            (%s ...)\\n\", nn->name);\n+    nd->elems[nd->n_elems++] = nn;\n+    ++i;\n+  }\n+  va_end(ap);\n+  return nd;\n+}\n+\n+int const indent_step = 4;\n+\n+void print_indent(int depth) {\n+  while (depth) {\n+    if (depth-- % indent_step == 0) {\n+      print(\"|\");\n+    } else {\n+      print(\" \");\n+    }\n+  }\n+}\n+\n+void print_node(struct node *n, int depth) {\n+  int i = 0;\n+  print_indent(depth);\n+  if (n->n_elems == 0) {\n+    print(\"%s\\n\", n->name);\n+  } else {\n+    print(\"(%s\\n\", n->name);\n+    for (i = 0; i < n->n_elems; ++i) {\n+      print_node(n->elems[i], depth + indent_step);\n+    }\n+    print_indent(depth);\n+    print(\")\\n\");\n+  }\n+}\n+\n+int main(int argc, char **argv) {\n+  if (argc == 2 && strcmp(argv[1], \"-v\") == 0) {\n+    verbose = 1;\n+  } else {\n+    verbose = 0;\n+  }\n+  int ret = 0;\n+  struct node *tmp;\n+  memset(pushback, '\\0', PUSHBACK_LEN);\n+  ret = rsparse();\n+  print(\"--- PARSE COMPLETE: ret:%d, n_nodes:%d ---\\n\", ret, n_nodes);\n+  if (nodes) {\n+    print_node(nodes, 0);\n+  }\n+  while (nodes) {\n+    tmp = nodes;\n+    nodes = tmp->next;\n+    if (tmp->own_string) {\n+      free((void*)tmp->name);\n+    }\n+    free(tmp);\n+  }\n+  return ret;\n+}\n+\n+void rserror(char const *s) {\n+  fprintf(stderr, \"%s\\n\", s);\n+}"}, {"sha": "c9fcdf7647b9cfa79e42164ca858d728a7685dd7", "filename": "src/grammar/parser-lalr.y", "status": "added", "additions": 1945, "deletions": 0, "changes": 1945, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,1945 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+%{\n+#define YYERROR_VERBOSE\n+#define YYSTYPE struct node *\n+struct node;\n+extern int yylex();\n+extern void yyerror(char const *s);\n+extern struct node *mk_node(char const *name, int n, ...);\n+extern struct node *mk_atom(char *text);\n+extern struct node *mk_none();\n+extern struct node *ext_node(struct node *nd, int n, ...);\n+extern void push_back(char c);\n+extern char *yytext;\n+%}\n+%debug\n+\n+%token SHL\n+%token SHR\n+%token LE\n+%token EQEQ\n+%token NE\n+%token GE\n+%token ANDAND\n+%token OROR\n+%token SHLEQ\n+%token SHREQ\n+%token MINUSEQ\n+%token ANDEQ\n+%token OREQ\n+%token PLUSEQ\n+%token STAREQ\n+%token SLASHEQ\n+%token CARETEQ\n+%token PERCENTEQ\n+%token DOTDOT\n+%token DOTDOTDOT\n+%token MOD_SEP\n+%token RARROW\n+%token LARROW\n+%token FAT_ARROW\n+%token LIT_BYTE\n+%token LIT_CHAR\n+%token LIT_INTEGER\n+%token LIT_FLOAT\n+%token LIT_STR\n+%token LIT_STR_RAW\n+%token LIT_BYTE_STR\n+%token LIT_BYTE_STR_RAW\n+%token IDENT\n+%token UNDERSCORE\n+%token LIFETIME\n+\n+// keywords\n+%token SELF\n+%token STATIC\n+%token AS\n+%token BREAK\n+%token CRATE\n+%token ELSE\n+%token ENUM\n+%token EXTERN\n+%token FALSE\n+%token FN\n+%token FOR\n+%token IF\n+%token IMPL\n+%token IN\n+%token LET\n+%token LOOP\n+%token MATCH\n+%token MOD\n+%token MOVE\n+%token MUT\n+%token PRIV\n+%token PUB\n+%token REF\n+%token RETURN\n+%token STRUCT\n+%token TRUE\n+%token TRAIT\n+%token TYPE\n+%token UNSAFE\n+%token DEFAULT\n+%token USE\n+%token WHILE\n+%token CONTINUE\n+%token PROC\n+%token BOX\n+%token CONST\n+%token WHERE\n+%token TYPEOF\n+%token INNER_DOC_COMMENT\n+%token OUTER_DOC_COMMENT\n+\n+%token SHEBANG\n+%token SHEBANG_LINE\n+%token STATIC_LIFETIME\n+\n+ /*\n+   Quoting from the Bison manual:\n+\n+   \"Finally, the resolution of conflicts works by comparing the precedence\n+   of the rule being considered with that of the lookahead token. If the\n+   token's precedence is higher, the choice is to shift. If the rule's\n+   precedence is higher, the choice is to reduce. If they have equal\n+   precedence, the choice is made based on the associativity of that\n+   precedence level. The verbose output file made by \u2018-v\u2019 (see Invoking\n+   Bison) says how each conflict was resolved\"\n+ */\n+\n+// We expect no shift/reduce or reduce/reduce conflicts in this grammar;\n+// all potential ambiguities are scrutinized and eliminated manually.\n+%expect 0\n+\n+// fake-precedence symbol to cause '|' bars in lambda context to parse\n+// at low precedence, permit things like |x| foo = bar, where '=' is\n+// otherwise lower-precedence than '|'. Also used for proc() to cause\n+// things like proc() a + b to parse as proc() { a + b }.\n+%precedence LAMBDA\n+\n+%precedence SELF\n+\n+// MUT should be lower precedence than IDENT so that in the pat rule,\n+// \"& MUT pat\" has higher precedence than \"binding_mode ident [@ pat]\"\n+%precedence MUT\n+\n+// IDENT needs to be lower than '{' so that 'foo {' is shifted when\n+// trying to decide if we've got a struct-construction expr (esp. in\n+// contexts like 'if foo { .')\n+//\n+// IDENT also needs to be lower precedence than '<' so that '<' in\n+// 'foo:bar . <' is shifted (in a trait reference occurring in a\n+// bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\n+%precedence IDENT\n+\n+// A couple fake-precedence symbols to use in rules associated with +\n+// and < in trailing type contexts. These come up when you have a type\n+// in the RHS of operator-AS, such as \"foo as bar<baz>\". The \"<\" there\n+// has to be shifted so the parser keeps trying to parse a type, even\n+// though it might well consider reducing the type \"bar\" and then\n+// going on to \"<\" as a subsequent binop. The \"+\" case is with\n+// trailing type-bounds (\"foo as bar:A+B\"), for the same reason.\n+%precedence SHIFTPLUS\n+\n+%precedence MOD_SEP\n+%precedence RARROW ':'\n+\n+// In where clauses, \"for\" should have greater precedence when used as\n+// a higher ranked constraint than when used as the beginning of a\n+// for_in_type (which is a ty)\n+%precedence FORTYPE\n+%precedence FOR\n+\n+// Binops & unops, and their precedences\n+%precedence BOX\n+%precedence BOXPLACE\n+%nonassoc DOTDOT\n+\n+// RETURN needs to be lower-precedence than tokens that start\n+// prefix_exprs\n+%precedence RETURN\n+\n+%right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n+%right LARROW\n+%left OROR\n+%left ANDAND\n+%left EQEQ NE\n+%left '<' '>' LE GE\n+%left '|'\n+%left '^'\n+%left '&'\n+%left SHL SHR\n+%left '+' '-'\n+%precedence AS\n+%left '*' '/' '%'\n+%precedence '!'\n+\n+%precedence '{' '[' '(' '.'\n+\n+%precedence RANGE\n+\n+%start crate\n+\n+%%\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 1: Items and attributes\n+////////////////////////////////////////////////////////////////////////\n+\n+crate\n+: maybe_shebang inner_attrs maybe_mod_items  { mk_node(\"crate\", 2, $2, $3); }\n+| maybe_shebang maybe_mod_items  { mk_node(\"crate\", 1, $2); }\n+;\n+\n+maybe_shebang\n+: SHEBANG_LINE\n+| %empty\n+;\n+\n+maybe_inner_attrs\n+: inner_attrs\n+| %empty                   { $$ = mk_none(); }\n+;\n+\n+inner_attrs\n+: inner_attr               { $$ = mk_node(\"InnerAttrs\", 1, $1); }\n+| inner_attrs inner_attr   { $$ = ext_node($1, 1, $2); }\n+;\n+\n+inner_attr\n+: SHEBANG '[' meta_item ']'   { $$ = mk_node(\"InnerAttr\", 1, $3); }\n+| INNER_DOC_COMMENT           { $$ = mk_node(\"InnerAttr\", 1, mk_node(\"doc-comment\", 1, mk_atom(yytext))); }\n+;\n+\n+maybe_outer_attrs\n+: outer_attrs\n+| %empty                   { $$ = mk_none(); }\n+;\n+\n+outer_attrs\n+: outer_attr               { $$ = mk_node(\"OuterAttrs\", 1, $1); }\n+| outer_attrs outer_attr   { $$ = ext_node($1, 1, $2); }\n+;\n+\n+outer_attr\n+: '#' '[' meta_item ']'    { $$ = $3; }\n+| OUTER_DOC_COMMENT        { $$ = mk_node(\"doc-comment\", 1, mk_atom(yytext)); }\n+;\n+\n+meta_item\n+: ident                      { $$ = mk_node(\"MetaWord\", 1, $1); }\n+| ident '=' lit              { $$ = mk_node(\"MetaNameValue\", 2, $1, $3); }\n+| ident '(' meta_seq ')'     { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n+| ident '(' meta_seq ',' ')' { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n+;\n+\n+meta_seq\n+: %empty                   { $$ = mk_none(); }\n+| meta_item                { $$ = mk_node(\"MetaItems\", 1, $1); }\n+| meta_seq ',' meta_item   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+maybe_mod_items\n+: mod_items\n+| %empty             { $$ = mk_none(); }\n+;\n+\n+mod_items\n+: mod_item                               { $$ = mk_node(\"Items\", 1, $1); }\n+| mod_items mod_item                     { $$ = ext_node($1, 1, $2); }\n+;\n+\n+attrs_and_vis\n+: maybe_outer_attrs visibility           { $$ = mk_node(\"AttrsAndVis\", 2, $1, $2); }\n+;\n+\n+mod_item\n+: attrs_and_vis item    { $$ = mk_node(\"Item\", 2, $1, $2); }\n+;\n+\n+// items that can appear outside of a fn block\n+item\n+: stmt_item\n+| item_macro\n+;\n+\n+// items that can appear in \"stmts\"\n+stmt_item\n+: item_static\n+| item_const\n+| item_type\n+| block_item\n+| view_item\n+;\n+\n+item_static\n+: STATIC ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $2, $4, $6); }\n+| STATIC MUT ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $3, $5, $7); }\n+;\n+\n+item_const\n+: CONST ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemConst\", 3, $2, $4, $6); }\n+;\n+\n+item_macro\n+: path_expr '!' maybe_ident parens_delimited_token_trees ';'  { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n+| path_expr '!' maybe_ident braces_delimited_token_trees      { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n+| path_expr '!' maybe_ident brackets_delimited_token_trees ';'{ $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n+;\n+\n+view_item\n+: use_item\n+| extern_fn_item\n+| EXTERN CRATE ident ';'                      { $$ = mk_node(\"ViewItemExternCrate\", 1, $3); }\n+| EXTERN CRATE ident AS ident ';'             { $$ = mk_node(\"ViewItemExternCrate\", 2, $3, $5); }\n+;\n+\n+extern_fn_item\n+: EXTERN maybe_abi item_fn                    { $$ = mk_node(\"ViewItemExternFn\", 2, $2, $3); }\n+;\n+\n+use_item\n+: USE view_path ';'                           { $$ = mk_node(\"ViewItemUse\", 1, $2); }\n+;\n+\n+view_path\n+: path_no_types_allowed                                    { $$ = mk_node(\"ViewPathSimple\", 1, $1); }\n+| path_no_types_allowed MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, mk_atom(\"ViewPathListEmpty\")); }\n+|                       MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 1, mk_atom(\"ViewPathListEmpty\")); }\n+| path_no_types_allowed MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n+|                       MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $3); }\n+| path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n+|                       MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $3); }\n+| path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(\"ViewPathGlob\", 1, $1); }\n+|                               '{'                '}'     { $$ = mk_atom(\"ViewPathListEmpty\"); }\n+|                               '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $2); }\n+|                               '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $2); }\n+| path_no_types_allowed AS ident                           { $$ = mk_node(\"ViewPathSimple\", 2, $1, $3); }\n+;\n+\n+block_item\n+: item_fn\n+| item_unsafe_fn\n+| item_mod\n+| item_foreign_mod          { $$ = mk_node(\"ItemForeignMod\", 1, $1); }\n+| item_struct\n+| item_enum\n+| item_trait\n+| item_impl\n+;\n+\n+maybe_ty_ascription\n+: ':' ty_sum { $$ = $2; }\n+| %empty { $$ = mk_none(); }\n+;\n+\n+maybe_init_expr\n+: '=' expr { $$ = $2; }\n+| %empty   { $$ = mk_none(); }\n+;\n+\n+// structs\n+item_struct\n+: STRUCT ident generic_params maybe_where_clause struct_decl_args\n+{\n+  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n+}\n+| STRUCT ident generic_params struct_tuple_args maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n+}\n+| STRUCT ident generic_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"ItemStruct\", 3, $2, $3, $4);\n+}\n+;\n+\n+struct_decl_args\n+: '{' struct_decl_fields '}'                  { $$ = $2; }\n+| '{' struct_decl_fields ',' '}'              { $$ = $2; }\n+;\n+\n+struct_tuple_args\n+: '(' struct_tuple_fields ')'                 { $$ = $2; }\n+| '(' struct_tuple_fields ',' ')'             { $$ = $2; }\n+;\n+\n+struct_decl_fields\n+: struct_decl_field                           { $$ = mk_node(\"StructFields\", 1, $1); }\n+| struct_decl_fields ',' struct_decl_field    { $$ = ext_node($1, 1, $3); }\n+| %empty                                      { $$ = mk_none(); }\n+;\n+\n+struct_decl_field\n+: attrs_and_vis ident ':' ty_sum              { $$ = mk_node(\"StructField\", 3, $1, $2, $4); }\n+;\n+\n+struct_tuple_fields\n+: struct_tuple_field                          { $$ = mk_node(\"StructFields\", 1, $1); }\n+| struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\n+;\n+\n+struct_tuple_field\n+: attrs_and_vis ty_sum                    { $$ = mk_node(\"StructField\", 2, $1, $2); }\n+;\n+\n+// enums\n+item_enum\n+: ENUM ident generic_params maybe_where_clause '{' enum_defs '}'     { $$ = mk_node(\"ItemEnum\", 0); }\n+| ENUM ident generic_params maybe_where_clause '{' enum_defs ',' '}' { $$ = mk_node(\"ItemEnum\", 0); }\n+;\n+\n+enum_defs\n+: enum_def               { $$ = mk_node(\"EnumDefs\", 1, $1); }\n+| enum_defs ',' enum_def { $$ = ext_node($1, 1, $3); }\n+| %empty                 { $$ = mk_none(); }\n+;\n+\n+enum_def\n+: attrs_and_vis ident enum_args { $$ = mk_node(\"EnumDef\", 3, $1, $2, $3); }\n+;\n+\n+enum_args\n+: '{' struct_decl_fields '}'     { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| '{' struct_decl_fields ',' '}' { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| '(' maybe_ty_sums ')'          { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| '=' expr                       { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| %empty                         { $$ = mk_none(); }\n+;\n+\n+item_mod\n+: MOD ident ';'                                 { $$ = mk_node(\"ItemMod\", 1, $2); }\n+| MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(\"ItemMod\", 2, $2, $4); }\n+| MOD ident '{' inner_attrs maybe_mod_items '}' { $$ = mk_node(\"ItemMod\", 3, $2, $4, $5); }\n+;\n+\n+item_foreign_mod\n+: EXTERN maybe_abi '{' maybe_foreign_items '}'             { $$ = mk_node(\"ItemForeignMod\", 1, $4); }\n+| EXTERN maybe_abi '{' inner_attrs maybe_foreign_items '}' { $$ = mk_node(\"ItemForeignMod\", 2, $4, $5); }\n+;\n+\n+maybe_abi\n+: str\n+| %empty { $$ = mk_none(); }\n+;\n+\n+maybe_foreign_items\n+: foreign_items\n+| %empty { $$ = mk_none(); }\n+;\n+\n+foreign_items\n+: foreign_item               { $$ = mk_node(\"ForeignItems\", 1, $1); }\n+| foreign_items foreign_item { $$ = ext_node($1, 1, $2); }\n+;\n+\n+foreign_item\n+: attrs_and_vis STATIC item_foreign_static { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n+| attrs_and_vis item_foreign_fn            { $$ = mk_node(\"ForeignItem\", 2, $1, $2); }\n+| attrs_and_vis UNSAFE item_foreign_fn     { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n+;\n+\n+item_foreign_static\n+: maybe_mut ident ':' ty ';'               { $$ = mk_node(\"StaticItem\", 3, $1, $2, $4); }\n+;\n+\n+item_foreign_fn\n+: FN ident generic_params fn_decl_allow_variadic maybe_where_clause ';' { $$ = mk_node(\"ForeignFn\", 4, $2, $3, $4, $5); }\n+;\n+\n+fn_decl_allow_variadic\n+: fn_params_allow_variadic ret_ty { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_params_allow_variadic\n+: '(' ')'                      { $$ = mk_none(); }\n+| '(' params ')'               { $$ = $2; }\n+| '(' params ',' ')'           { $$ = $2; }\n+| '(' params ',' DOTDOTDOT ')' { $$ = $2; }\n+;\n+\n+visibility\n+: PUB      { $$ = mk_atom(\"Public\"); }\n+| %empty   { $$ = mk_atom(\"Inherited\"); }\n+;\n+\n+idents_or_self\n+: ident_or_self                    { $$ = mk_node(\"IdentsOrSelf\", 1, $1); }\n+| ident_or_self AS ident           { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n+| idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ident_or_self\n+: ident\n+| SELF  { $$ = mk_atom(yytext); }\n+;\n+\n+item_type\n+: TYPE ident generic_params maybe_where_clause '=' ty_sum ';'  { $$ = mk_node(\"ItemTy\", 4, $2, $3, $4, $6); }\n+;\n+\n+for_sized\n+: FOR '?' ident { $$ = mk_node(\"ForSized\", 1, $3); }\n+| FOR ident '?' { $$ = mk_node(\"ForSized\", 1, $2); }\n+| %empty        { $$ = mk_none(); }\n+;\n+\n+item_trait\n+: maybe_unsafe TRAIT ident generic_params for_sized maybe_ty_param_bounds maybe_where_clause '{' maybe_trait_items '}'\n+{\n+  $$ = mk_node(\"ItemTrait\", 7, $1, $3, $4, $5, $6, $7, $9);\n+}\n+;\n+\n+maybe_trait_items\n+: trait_items\n+| %empty { $$ = mk_none(); }\n+;\n+\n+trait_items\n+: trait_item               { $$ = mk_node(\"TraitItems\", 1, $1); }\n+| trait_items trait_item   { $$ = ext_node($1, 1, $2); }\n+;\n+\n+trait_item\n+: trait_const\n+| trait_type\n+| trait_method\n+;\n+\n+trait_const\n+: maybe_outer_attrs CONST ident maybe_ty_ascription maybe_const_default ';' { $$ = mk_node(\"ConstTraitItem\", 4, $1, $3, $4, $5); }\n+;\n+\n+maybe_const_default\n+: '=' expr { $$ = mk_node(\"ConstDefault\", 1, $2); }\n+| %empty   { $$ = mk_none(); }\n+;\n+\n+trait_type\n+: maybe_outer_attrs TYPE ty_param ';' { $$ = mk_node(\"TypeTraitItem\", 2, $1, $3); }\n+;\n+\n+maybe_unsafe\n+: UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n+| %empty { $$ = mk_none(); }\n+;\n+\n+maybe_default_maybe_unsafe\n+: DEFAULT UNSAFE { $$ = mk_atom(\"DefaultUnsafe\"); }\n+| DEFAULT        { $$ = mk_atom(\"Default\"); }\n+|         UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n+| %empty { $$ = mk_none(); }\n+\n+trait_method\n+: type_method { $$ = mk_node(\"Required\", 1, $1); }\n+| method      { $$ = mk_node(\"Provided\", 1, $1); }\n+;\n+\n+type_method\n+: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"TypeMethod\", 6, $1, $2, $4, $5, $6, $7);\n+}\n+| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"TypeMethod\", 7, $1, $2, $4, $6, $7, $8, $9);\n+}\n+;\n+\n+method\n+: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n+}\n+| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n+}\n+;\n+\n+impl_method\n+: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n+}\n+| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n+}\n+;\n+\n+// There are two forms of impl:\n+//\n+// impl (<...>)? TY { ... }\n+// impl (<...>)? TRAIT for TY { ... }\n+//\n+// Unfortunately since TY can begin with '<' itself -- as part of a\n+// TyQualifiedPath type -- there's an s/r conflict when we see '<' after IMPL:\n+// should we reduce one of the early rules of TY (such as maybe_once)\n+// or shall we continue shifting into the generic_params list for the\n+// impl?\n+//\n+// The production parser disambiguates a different case here by\n+// permitting / requiring the user to provide parens around types when\n+// they are ambiguous with traits. We do the same here, regrettably,\n+// by splitting ty into ty and ty_prim.\n+item_impl\n+: maybe_default_maybe_unsafe IMPL generic_params ty_prim_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImpl\", 6, $1, $3, $4, $5, $7, $8);\n+}\n+| maybe_default_maybe_unsafe IMPL generic_params '(' ty ')' maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImpl\", 6, $1, $3, 5, $6, $9, $10);\n+}\n+| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImpl\", 6, $3, $4, $6, $7, $9, $10);\n+}\n+| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImplNeg\", 7, $1, $3, $5, $7, $8, $10, $11);\n+}\n+| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR DOTDOT '{' '}'\n+{\n+  $$ = mk_node(\"ItemImplDefault\", 3, $1, $3, $4);\n+}\n+| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR DOTDOT '{' '}'\n+{\n+  $$ = mk_node(\"ItemImplDefaultNeg\", 3, $1, $3, $4);\n+}\n+;\n+\n+maybe_impl_items\n+: impl_items\n+| %empty { $$ = mk_none(); }\n+;\n+\n+impl_items\n+: impl_item               { $$ = mk_node(\"ImplItems\", 1, $1); }\n+| impl_item impl_items    { $$ = ext_node($1, 1, $2); }\n+;\n+\n+impl_item\n+: impl_method\n+| attrs_and_vis item_macro { $$ = mk_node(\"ImplMacroItem\", 2, $1, $2); }\n+| impl_const\n+| impl_type\n+;\n+\n+impl_const\n+: attrs_and_vis item_const { $$ = mk_node(\"ImplConst\", 1, $1, $2); }\n+;\n+\n+impl_type\n+: attrs_and_vis TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 4, $1, $3, $4, $6); }\n+;\n+\n+item_fn\n+: FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemFn\", 5, $2, $3, $4, $5, $6);\n+}\n+;\n+\n+item_unsafe_fn\n+: UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemUnsafeFn\", 5, $3, $4, $5, $6, $7);\n+}\n+| UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemUnsafeFn\", 6, $3, $5, $6, $7, $8, $9);\n+}\n+;\n+\n+fn_decl\n+: fn_params ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_decl_with_self\n+: fn_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_decl_with_self_allow_anon_params\n+: fn_anon_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_params\n+: '(' maybe_params ')'  { $$ = $2; }\n+;\n+\n+fn_anon_params\n+: '(' anon_param anon_params_allow_variadic_tail ')' { $$ = ext_node($2, 1, $3); }\n+| '(' ')'                                            { $$ = mk_none(); }\n+;\n+\n+fn_params_with_self\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n+| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n+| '(' maybe_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n+;\n+\n+fn_anon_params_with_self\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n+| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n+| '(' maybe_anon_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n+;\n+\n+maybe_params\n+: params\n+| params ','\n+| %empty  { $$ = mk_none(); }\n+;\n+\n+params\n+: param                { $$ = mk_node(\"Args\", 1, $1); }\n+| params ',' param     { $$ = ext_node($1, 1, $3); }\n+;\n+\n+param\n+: pat ':' ty_sum   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n+;\n+\n+inferrable_params\n+: inferrable_param                       { $$ = mk_node(\"InferrableParams\", 1, $1); }\n+| inferrable_params ',' inferrable_param { $$ = ext_node($1, 1, $3); }\n+;\n+\n+inferrable_param\n+: pat maybe_ty_ascription { $$ = mk_node(\"InferrableParam\", 2, $1, $2); }\n+;\n+\n+maybe_unboxed_closure_kind\n+: %empty\n+| ':'\n+| '&' maybe_mut ':'\n+;\n+\n+maybe_comma_params\n+: ','            { $$ = mk_none(); }\n+| ',' params     { $$ = $2; }\n+| ',' params ',' { $$ = $2; }\n+| %empty         { $$ = mk_none(); }\n+;\n+\n+maybe_comma_anon_params\n+: ','                 { $$ = mk_none(); }\n+| ',' anon_params     { $$ = $2; }\n+| ',' anon_params ',' { $$ = $2; }\n+| %empty              { $$ = mk_none(); }\n+;\n+\n+maybe_anon_params\n+: anon_params\n+| anon_params ','\n+| %empty      { $$ = mk_none(); }\n+;\n+\n+anon_params\n+: anon_param                 { $$ = mk_node(\"Args\", 1, $1); }\n+| anon_params ',' anon_param { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// anon means it's allowed to be anonymous (type-only), but it can\n+// still have a name\n+anon_param\n+: named_arg ':' ty   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n+| ty\n+;\n+\n+anon_params_allow_variadic_tail\n+: ',' DOTDOTDOT                                  { $$ = mk_none(); }\n+| ',' anon_param anon_params_allow_variadic_tail { $$ = mk_node(\"Args\", 2, $2, $3); }\n+| %empty                                         { $$ = mk_none(); }\n+;\n+\n+named_arg\n+: ident\n+| UNDERSCORE        { $$ = mk_atom(\"PatWild\"); }\n+| '&' ident         { $$ = $2; }\n+| '&' UNDERSCORE    { $$ = mk_atom(\"PatWild\"); }\n+| ANDAND ident      { $$ = $2; }\n+| ANDAND UNDERSCORE { $$ = mk_atom(\"PatWild\"); }\n+| MUT ident         { $$ = $2; }\n+;\n+\n+ret_ty\n+: RARROW '!'         { $$ = mk_none(); }\n+| RARROW ty          { $$ = mk_node(\"ret-ty\", 1, $2); }\n+| %prec IDENT %empty { $$ = mk_none(); }\n+;\n+\n+generic_params\n+: '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes ',' '>'               { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes ',' ty_params '>'     { $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' lifetimes ',' ty_params ',' '>' { $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' lifetimes ',' ty_params SHR     { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' lifetimes ',' ty_params ',' SHR { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' ty_params '>'                   { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| '<' ty_params ',' '>'               { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| '<' ty_params SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| '<' ty_params ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| %empty                              { $$ = mk_none(); }\n+;\n+\n+maybe_where_clause\n+: %empty                              { $$ = mk_none(); }\n+| where_clause\n+;\n+\n+where_clause\n+: WHERE where_predicates              { $$ = mk_node(\"WhereClause\", 1, $2); }\n+| WHERE where_predicates ','          { $$ = mk_node(\"WhereClause\", 1, $2); }\n+;\n+\n+where_predicates\n+: where_predicate                      { $$ = mk_node(\"WherePredicates\", 1, $1); }\n+| where_predicates ',' where_predicate { $$ = ext_node($1, 1, $3); }\n+;\n+\n+where_predicate\n+: maybe_for_lifetimes lifetime ':' bounds    { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n+| maybe_for_lifetimes ty ':' ty_param_bounds { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n+;\n+\n+maybe_for_lifetimes\n+: FOR '<' lifetimes '>' { $$ = mk_none(); }\n+| %prec FORTYPE %empty  { $$ = mk_none(); }\n+\n+ty_params\n+: ty_param               { $$ = mk_node(\"TyParams\", 1, $1); }\n+| ty_params ',' ty_param { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// A path with no type parameters; e.g. `foo::bar::Baz`\n+//\n+// These show up in 'use' view-items, because these are processed\n+// without respect to types.\n+path_no_types_allowed\n+: ident                               { $$ = mk_node(\"ViewPath\", 1, $1); }\n+| MOD_SEP ident                       { $$ = mk_node(\"ViewPath\", 1, $2); }\n+| SELF                                { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n+| MOD_SEP SELF                        { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n+| path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// A path with a lifetime and type parameters, with no double colons\n+// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n+//\n+// These show up in \"trait references\", the components of\n+// type-parameter bounds lists, as well as in the prefix of the\n+// path_generic_args_and_bounds rule, which is the full form of a\n+// named typed expression.\n+//\n+// They do not have (nor need) an extra '::' before '<' because\n+// unlike in expr context, there are no \"less-than\" type exprs to\n+// be ambiguous with.\n+path_generic_args_without_colons\n+: %prec IDENT\n+  ident                                                                       { $$ = mk_node(\"components\", 1, $1); }\n+| %prec IDENT\n+  ident generic_args                                                          { $$ = mk_node(\"components\", 2, $1, $2); }\n+| %prec IDENT\n+  ident '(' maybe_ty_sums ')' ret_ty                                          { $$ = mk_node(\"components\", 2, $1, $3); }\n+| %prec IDENT\n+  path_generic_args_without_colons MOD_SEP ident                              { $$ = ext_node($1, 1, $3); }\n+| %prec IDENT\n+  path_generic_args_without_colons MOD_SEP ident generic_args                 { $$ = ext_node($1, 2, $3, $4); }\n+| %prec IDENT\n+  path_generic_args_without_colons MOD_SEP ident '(' maybe_ty_sums ')' ret_ty { $$ = ext_node($1, 2, $3, $5); }\n+;\n+\n+generic_args\n+: '<' generic_values '>'   { $$ = $2; }\n+| '<' generic_values SHR   { push_back('>'); $$ = $2; }\n+| '<' generic_values GE    { push_back('='); $$ = $2; }\n+| '<' generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n+// If generic_args starts with \"<<\", the first arg must be a\n+// TyQualifiedPath because that's the only type that can start with a\n+// '<'. This rule parses that as the first ty_sum and then continues\n+// with the rest of generic_values.\n+| SHL ty_qualified_path_and_generic_values '>'   { $$ = $2; }\n+| SHL ty_qualified_path_and_generic_values SHR   { push_back('>'); $$ = $2; }\n+| SHL ty_qualified_path_and_generic_values GE    { push_back('='); $$ = $2; }\n+| SHL ty_qualified_path_and_generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n+;\n+\n+generic_values\n+: maybe_lifetimes maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 2, $1, $2); }\n+;\n+\n+maybe_ty_sums_and_or_bindings\n+: ty_sums\n+| ty_sums ','\n+| ty_sums ',' bindings { $$ = mk_node(\"TySumsAndBindings\", 2, $1, $3); }\n+| bindings\n+| bindings ','\n+| %empty               { $$ = mk_none(); }\n+;\n+\n+maybe_bindings\n+: ',' bindings { $$ = $2; }\n+| %empty       { $$ = mk_none(); }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 2: Patterns\n+////////////////////////////////////////////////////////////////////////\n+\n+pat\n+: UNDERSCORE                                      { $$ = mk_atom(\"PatWild\"); }\n+| '&' pat                                         { $$ = mk_node(\"PatRegion\", 1, $2); }\n+| '&' MUT pat                                     { $$ = mk_node(\"PatRegion\", 1, $3); }\n+| ANDAND pat                                      { $$ = mk_node(\"PatRegion\", 1, mk_node(\"PatRegion\", 1, $2)); }\n+| '(' ')'                                         { $$ = mk_atom(\"PatUnit\"); }\n+| '(' pat_tup ')'                                 { $$ = mk_node(\"PatTup\", 1, $2); }\n+| '(' pat_tup ',' ')'                             { $$ = mk_node(\"PatTup\", 1, $2); }\n+| '[' pat_vec ']'                                 { $$ = mk_node(\"PatVec\", 1, $2); }\n+| lit_or_path\n+| lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(\"PatRange\", 2, $1, $3); }\n+| path_expr '{' pat_struct '}'                    { $$ = mk_node(\"PatStruct\", 2, $1, $3); }\n+| path_expr '(' DOTDOT ')'                        { $$ = mk_node(\"PatEnum\", 1, $1); }\n+| path_expr '(' pat_tup ')'                       { $$ = mk_node(\"PatEnum\", 2, $1, $3); }\n+| path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(\"PatMac\", 3, $1, $3, $4); }\n+| binding_mode ident                              { $$ = mk_node(\"PatIdent\", 2, $1, $2); }\n+|              ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, mk_node(\"BindByValue\", 1, mk_atom(\"MutImmutable\")), $1, $3); }\n+| binding_mode ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, $1, $2, $4); }\n+| BOX pat                                         { $$ = mk_node(\"PatUniq\", 1, $2); }\n+| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"PatQualifiedPath\", 3, $2, $3, $6); }\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n+{\n+  $$ = mk_node(\"PatQualifiedPath\", 3, mk_node(\"PatQualifiedPath\", 3, $2, $3, $6), $7, $10);\n+}\n+;\n+\n+pats_or\n+: pat              { $$ = mk_node(\"Pats\", 1, $1); }\n+| pats_or '|' pat  { $$ = ext_node($1, 1, $3); }\n+;\n+\n+binding_mode\n+: REF         { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutImmutable\")); }\n+| REF MUT     { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutMutable\")); }\n+| MUT         { $$ = mk_node(\"BindByValue\", 1, mk_atom(\"MutMutable\")); }\n+;\n+\n+lit_or_path\n+: path_expr    { $$ = mk_node(\"PatLit\", 1, $1); }\n+| lit          { $$ = mk_node(\"PatLit\", 1, $1); }\n+| '-' lit      { $$ = mk_node(\"PatLit\", 1, $2); }\n+;\n+\n+pat_field\n+:                  ident        { $$ = mk_node(\"PatField\", 1, $1); }\n+|     binding_mode ident        { $$ = mk_node(\"PatField\", 2, $1, $2); }\n+| BOX              ident        { $$ = mk_node(\"PatField\", 2, mk_atom(\"box\"), $2); }\n+| BOX binding_mode ident        { $$ = mk_node(\"PatField\", 3, mk_atom(\"box\"), $2, $3); }\n+|              ident ':' pat    { $$ = mk_node(\"PatField\", 2, $1, $3); }\n+| binding_mode ident ':' pat    { $$ = mk_node(\"PatField\", 3, $1, $2, $4); }\n+;\n+\n+pat_fields\n+: pat_field                  { $$ = mk_node(\"PatFields\", 1, $1); }\n+| pat_fields ',' pat_field   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+pat_struct\n+: pat_fields                 { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n+| pat_fields ','             { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n+| pat_fields ',' DOTDOT      { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"true\")); }\n+| DOTDOT                     { $$ = mk_node(\"PatStruct\", 1, mk_atom(\"true\")); }\n+;\n+\n+pat_tup\n+: pat               { $$ = mk_node(\"pat_tup\", 1, $1); }\n+| pat_tup ',' pat   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+pat_vec\n+: pat_vec_elts                                  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts                             ','  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts     DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts ',' DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts     DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n+| pat_vec_elts     DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n+| pat_vec_elts ',' DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n+| pat_vec_elts ',' DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n+|                  DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n+|                  DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n+|                  DOTDOT                       { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n+| %empty                                        { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n+;\n+\n+pat_vec_elts\n+: pat                    { $$ = mk_node(\"PatVecElts\", 1, $1); }\n+| pat_vec_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 3: Types\n+////////////////////////////////////////////////////////////////////////\n+\n+ty\n+: ty_prim\n+| ty_closure\n+| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident                                      { $$ = mk_node(\"TyQualifiedPath\", 3, $2, $3, $6); }\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"TyQualifiedPath\", 3, mk_node(\"TyQualifiedPath\", 3, $2, $3, $6), $7, $10); }\n+| '(' ty_sums ')'                                                                      { $$ = mk_node(\"TyTup\", 1, $2); }\n+| '(' ty_sums ',' ')'                                                                  { $$ = mk_node(\"TyTup\", 1, $2); }\n+| '(' ')'                                                                              { $$ = mk_atom(\"TyNil\"); }\n+;\n+\n+ty_prim\n+: %prec IDENT path_generic_args_without_colons              { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons      { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n+| %prec IDENT SELF MOD_SEP path_generic_args_without_colons { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n+| BOX ty                                                    { $$ = mk_node(\"TyBox\", 1, $2); }\n+| '*' maybe_mut_or_const ty                                 { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n+| '&' ty                                                    { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n+| '&' MUT ty                                                { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n+| ANDAND ty                                                 { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n+| ANDAND MUT ty                                             { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n+| '&' lifetime maybe_mut ty                                 { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n+| ANDAND lifetime maybe_mut ty                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n+| '[' ty ']'                                                { $$ = mk_node(\"TyVec\", 1, $2); }\n+| '[' ty ',' DOTDOT expr ']'                                { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n+| '[' ty ';' expr ']'                                       { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n+| TYPEOF '(' expr ')'                                       { $$ = mk_node(\"TyTypeof\", 1, $3); }\n+| UNDERSCORE                                                { $$ = mk_atom(\"TyInfer\"); }\n+| ty_bare_fn\n+| ty_proc\n+| for_in_type\n+;\n+\n+ty_bare_fn\n+:                         FN ty_fn_decl { $$ = $2; }\n+| UNSAFE                  FN ty_fn_decl { $$ = $3; }\n+|        EXTERN maybe_abi FN ty_fn_decl { $$ = $4; }\n+| UNSAFE EXTERN maybe_abi FN ty_fn_decl { $$ = $5; }\n+;\n+\n+ty_fn_decl\n+: generic_params fn_anon_params ret_ty { $$ = mk_node(\"TyFnDecl\", 3, $1, $2, $3); }\n+;\n+\n+ty_closure\n+: UNSAFE '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $3, $5, $6); }\n+|        '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $2, $4, $5); }\n+| UNSAFE OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $3, $4); }\n+|        OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $2, $3); }\n+;\n+\n+ty_proc\n+: PROC generic_params fn_params maybe_bounds ret_ty { $$ = mk_node(\"TyProc\", 4, $2, $3, $4, $5); }\n+;\n+\n+for_in_type\n+: FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(\"ForInType\", 2, $3, $5); }\n+;\n+\n+for_in_type_suffix\n+: ty_proc\n+| ty_bare_fn\n+| trait_ref\n+| ty_closure\n+;\n+\n+maybe_mut\n+: MUT              { $$ = mk_atom(\"MutMutable\"); }\n+| %prec MUT %empty { $$ = mk_atom(\"MutImmutable\"); }\n+;\n+\n+maybe_mut_or_const\n+: MUT    { $$ = mk_atom(\"MutMutable\"); }\n+| CONST  { $$ = mk_atom(\"MutImmutable\"); }\n+| %empty { $$ = mk_atom(\"MutImmutable\"); }\n+;\n+\n+ty_qualified_path_and_generic_values\n+: ty_qualified_path maybe_bindings\n+{\n+  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 1, mk_node(\"TySum\", 1, $1)), $2);\n+}\n+| ty_qualified_path ',' ty_sums maybe_bindings\n+{\n+  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 2, $1, $3), $4);\n+}\n+;\n+\n+ty_qualified_path\n+: ty_sum AS trait_ref '>' MOD_SEP ident                     { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n+| ty_sum AS trait_ref '>' MOD_SEP ident '+' ty_param_bounds { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n+;\n+\n+maybe_ty_sums\n+: ty_sums\n+| ty_sums ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+ty_sums\n+: ty_sum             { $$ = mk_node(\"TySums\", 1, $1); }\n+| ty_sums ',' ty_sum { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ty_sum\n+: ty                     { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+;\n+\n+ty_prim_sum\n+: ty_prim                     { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty_prim '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+;\n+\n+maybe_ty_param_bounds\n+: ':' ty_param_bounds { $$ = $2; }\n+| %empty              { $$ = mk_none(); }\n+;\n+\n+ty_param_bounds\n+: boundseq\n+| %empty { $$ = mk_none(); }\n+;\n+\n+boundseq\n+: polybound\n+| boundseq '+' polybound { $$ = ext_node($1, 1, $3); }\n+;\n+\n+polybound\n+: FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $3, $5); }\n+| bound\n+| '?' bound { $$ = $2; }\n+;\n+\n+bindings\n+: binding              { $$ = mk_node(\"Bindings\", 1, $1); }\n+| bindings ',' binding { $$ = ext_node($1, 1, $3); }\n+;\n+\n+binding\n+: ident '=' ty { mk_node(\"Binding\", 2, $1, $3); }\n+;\n+\n+ty_param\n+: ident maybe_ty_param_bounds maybe_ty_default           { $$ = mk_node(\"TyParam\", 3, $1, $2, $3); }\n+| ident '?' ident maybe_ty_param_bounds maybe_ty_default { $$ = mk_node(\"TyParam\", 4, $1, $3, $4, $5); }\n+;\n+\n+maybe_bounds\n+: %prec SHIFTPLUS\n+  ':' bounds             { $$ = $2; }\n+| %prec SHIFTPLUS %empty { $$ = mk_none(); }\n+;\n+\n+bounds\n+: bound            { $$ = mk_node(\"bounds\", 1, $1); }\n+| bounds '+' bound { $$ = ext_node($1, 1, $3); }\n+;\n+\n+bound\n+: lifetime\n+| trait_ref\n+;\n+\n+maybe_ltbounds\n+: %prec SHIFTPLUS\n+  ':' ltbounds       { $$ = $2; }\n+| %empty             { $$ = mk_none(); }\n+;\n+\n+ltbounds\n+: lifetime              { $$ = mk_node(\"ltbounds\", 1, $1); }\n+| ltbounds '+' lifetime { $$ = ext_node($1, 1, $3); }\n+;\n+\n+maybe_ty_default\n+: '=' ty_sum { $$ = mk_node(\"TyDefault\", 1, $2); }\n+| %empty     { $$ = mk_none(); }\n+;\n+\n+maybe_lifetimes\n+: lifetimes\n+| lifetimes ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+lifetimes\n+: lifetime_and_bounds               { $$ = mk_node(\"Lifetimes\", 1, $1); }\n+| lifetimes ',' lifetime_and_bounds { $$ = ext_node($1, 1, $3); }\n+;\n+\n+lifetime_and_bounds\n+: LIFETIME maybe_ltbounds         { $$ = mk_node(\"lifetime\", 2, mk_atom(yytext), $2); }\n+| STATIC_LIFETIME                 { $$ = mk_atom(\"static_lifetime\"); }\n+;\n+\n+lifetime\n+: LIFETIME         { $$ = mk_node(\"lifetime\", 1, mk_atom(yytext)); }\n+| STATIC_LIFETIME  { $$ = mk_atom(\"static_lifetime\"); }\n+;\n+\n+trait_ref\n+: %prec IDENT path_generic_args_without_colons\n+| %prec IDENT MOD_SEP path_generic_args_without_colons { $$ = $2; }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 4: Blocks, statements, and expressions\n+////////////////////////////////////////////////////////////////////////\n+\n+inner_attrs_and_block\n+: '{' maybe_inner_attrs maybe_stmts '}'        { $$ = mk_node(\"ExprBlock\", 2, $2, $3); }\n+;\n+\n+block\n+: '{' maybe_stmts '}'                          { $$ = mk_node(\"ExprBlock\", 1, $2); }\n+;\n+\n+maybe_stmts\n+: stmts\n+| stmts nonblock_expr { $$ = ext_node($1, 1, $2); }\n+| nonblock_expr\n+| %empty              { $$ = mk_none(); }\n+;\n+\n+// There are two sub-grammars within a \"stmts: exprs\" derivation\n+// depending on whether each stmt-expr is a block-expr form; this is to\n+// handle the \"semicolon rule\" for stmt sequencing that permits\n+// writing\n+//\n+//     if foo { bar } 10\n+//\n+// as a sequence of two stmts (one if-expr stmt, one lit-10-expr\n+// stmt). Unfortunately by permitting juxtaposition of exprs in\n+// sequence like that, the non-block expr grammar has to have a\n+// second limited sub-grammar that excludes the prefix exprs that\n+// are ambiguous with binops. That is to say:\n+//\n+//     {10} - 1\n+//\n+// should parse as (progn (progn 10) (- 1)) not (- (progn 10) 1), that\n+// is to say, two statements rather than one, at least according to\n+// the mainline rust parser.\n+//\n+// So we wind up with a 3-way split in exprs that occur in stmt lists:\n+// block, nonblock-prefix, and nonblock-nonprefix.\n+//\n+// In non-stmts contexts, expr can relax this trichotomy.\n+//\n+// There is also one other expr subtype: nonparen_expr disallows exprs\n+// surrounded by parens (including tuple expressions), this is\n+// necessary for BOX (place) expressions, so a parens expr following\n+// the BOX is always parsed as the place.\n+\n+stmts\n+: stmt           { $$ = mk_node(\"stmts\", 1, $1); }\n+| stmts stmt     { $$ = ext_node($1, 1, $2); }\n+;\n+\n+stmt\n+: let\n+|                 stmt_item\n+|             PUB stmt_item { $$ = $2; }\n+| outer_attrs     stmt_item { $$ = $2; }\n+| outer_attrs PUB stmt_item { $$ = $3; }\n+| full_block_expr\n+| block\n+| nonblock_expr ';'\n+| ';'                   { $$ = mk_none(); }\n+;\n+\n+maybe_exprs\n+: exprs\n+| exprs ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+maybe_expr\n+: expr\n+| %empty { $$ = mk_none(); }\n+;\n+\n+exprs\n+: expr                                                        { $$ = mk_node(\"exprs\", 1, $1); }\n+| exprs ',' expr                                              { $$ = ext_node($1, 1, $3); }\n+;\n+\n+path_expr\n+: path_generic_args_with_colons\n+| MOD_SEP path_generic_args_with_colons      { $$ = $2; }\n+| SELF MOD_SEP path_generic_args_with_colons { $$ = mk_node(\"SelfPath\", 1, $3); }\n+;\n+\n+// A path with a lifetime and type parameters with double colons before\n+// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n+//\n+// These show up in expr context, in order to disambiguate from \"less-than\"\n+// expressions.\n+path_generic_args_with_colons\n+: ident                                              { $$ = mk_node(\"components\", 1, $1); }\n+| path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\n+| path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// the braces-delimited macro is a block_expr so it doesn't appear here\n+macro_expr\n+: path_expr '!' maybe_ident parens_delimited_token_trees   { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n+| path_expr '!' maybe_ident brackets_delimited_token_trees { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n+;\n+\n+nonblock_expr\n+: lit                                                           { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                                     { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                          { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                                    { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| nonblock_expr '[' maybe_expr ']'                              { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| nonblock_expr '(' maybe_exprs ')'                             { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '[' vec_expr ']'                                              { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| '(' maybe_exprs ')'                                           { $$ = mk_node(\"ExprParen\", 1, $2); }\n+| CONTINUE                                                      { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE lifetime                                             { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                                        { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n+| nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| nonblock_expr SHREQ expr                                      { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| nonblock_expr MINUSEQ expr                                    { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| nonblock_expr ANDEQ expr                                      { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| nonblock_expr OREQ expr                                       { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| nonblock_expr PLUSEQ expr                                     { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| nonblock_expr STAREQ expr                                     { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| nonblock_expr SLASHEQ expr                                    { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| nonblock_expr CARETEQ expr                                    { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| nonblock_expr PERCENTEQ expr                                  { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| nonblock_expr OROR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| nonblock_expr ANDAND expr                                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| nonblock_expr EQEQ expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| nonblock_expr NE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| nonblock_expr '<' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| nonblock_expr '>' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| nonblock_expr LE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| nonblock_expr GE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| nonblock_expr '|' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| nonblock_expr '^' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| nonblock_expr '&' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| nonblock_expr SHL expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| nonblock_expr SHR expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| nonblock_expr '+' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| nonblock_expr '-' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| nonblock_expr '*' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| nonblock_expr '/' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| nonblock_expr '%' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| nonblock_expr DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| nonblock_expr DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|               DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+|               DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n+| nonblock_expr AS ty                                           { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                             { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' nonblock_expr           { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n+| expr_qualified_path\n+| nonblock_prefix_expr\n+;\n+\n+expr\n+: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| expr '.' path_generic_args_with_colons              { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| expr '.' LIT_INTEGER                                { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| expr '[' maybe_expr ']'                             { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| expr '(' maybe_exprs ')'                            { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n+| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n+| expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| expr SHREQ expr                                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| expr MINUSEQ expr                                   { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| expr ANDEQ expr                                     { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| expr OREQ expr                                      { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| expr PLUSEQ expr                                    { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| expr STAREQ expr                                    { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| expr SLASHEQ expr                                   { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| expr CARETEQ expr                                   { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| expr PERCENTEQ expr                                 { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| expr OROR expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| expr ANDAND expr                                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| expr EQEQ expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| expr NE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| expr '<' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| expr '>' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| expr LE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| expr GE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| expr '|' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| expr '^' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| expr '&' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| expr SHL expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| expr SHR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| expr '+' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| expr '-' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| expr '*' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| expr '/' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| expr '%' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| expr DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| expr DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|      DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+|      DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n+| expr AS ty                                          { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n+| expr_qualified_path\n+| block_expr\n+| block\n+| nonblock_prefix_expr\n+;\n+\n+nonparen_expr\n+: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| nonparen_expr '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| nonparen_expr '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| nonparen_expr '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| nonparen_expr '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| nonparen_expr LARROW nonparen_expr                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n+| nonparen_expr '=' nonparen_expr                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| nonparen_expr SHLEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| nonparen_expr SHREQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| nonparen_expr MINUSEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| nonparen_expr ANDEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| nonparen_expr OREQ nonparen_expr                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| nonparen_expr PLUSEQ nonparen_expr                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| nonparen_expr STAREQ nonparen_expr                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| nonparen_expr SLASHEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| nonparen_expr CARETEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| nonparen_expr PERCENTEQ nonparen_expr               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| nonparen_expr OROR nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| nonparen_expr ANDAND nonparen_expr                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| nonparen_expr EQEQ nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| nonparen_expr NE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| nonparen_expr '<' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| nonparen_expr '>' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| nonparen_expr LE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| nonparen_expr GE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| nonparen_expr '|' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| nonparen_expr '^' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| nonparen_expr '&' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| nonparen_expr SHL nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| nonparen_expr SHR nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| nonparen_expr '+' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| nonparen_expr '-' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| nonparen_expr '*' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| nonparen_expr '/' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| nonparen_expr '%' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| nonparen_expr DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| nonparen_expr DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|               DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n+| nonparen_expr AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr_qualified_path\n+| block_expr\n+| block\n+| nonblock_prefix_expr\n+;\n+\n+expr_nostruct\n+: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| expr_nostruct '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| expr_nostruct '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n+| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n+| expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| expr_nostruct MINUSEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| expr_nostruct ANDEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| expr_nostruct OREQ expr_nostruct                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| expr_nostruct PLUSEQ expr_nostruct                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| expr_nostruct STAREQ expr_nostruct                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| expr_nostruct SLASHEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| expr_nostruct CARETEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| expr_nostruct PERCENTEQ expr_nostruct               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| expr_nostruct OROR expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| expr_nostruct ANDAND expr_nostruct                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| expr_nostruct EQEQ expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| expr_nostruct NE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| expr_nostruct '<' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| expr_nostruct '>' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| expr_nostruct LE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| expr_nostruct GE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| expr_nostruct '|' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| expr_nostruct '^' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| expr_nostruct '&' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| expr_nostruct SHL expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| expr_nostruct SHR expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| expr_nostruct '+' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| expr_nostruct '-' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| expr_nostruct '*' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| expr_nostruct '/' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| expr_nostruct '%' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| expr_nostruct DOTDOT               %prec RANGE      { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| expr_nostruct DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|               DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n+| expr_nostruct AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' expr_nostruct { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr_qualified_path\n+| block_expr\n+| block\n+| nonblock_prefix_expr_nostruct\n+;\n+\n+nonblock_prefix_expr_nostruct\n+: '-' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n+| '!' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n+| '*' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n+| '&' maybe_mut expr_nostruct               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n+| ANDAND maybe_mut expr_nostruct            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n+| lambda_expr_nostruct\n+| MOVE lambda_expr_nostruct                 { $$ = $2; }\n+| proc_expr_nostruct\n+;\n+\n+nonblock_prefix_expr\n+: '-' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n+| '!' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n+| '*' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n+| '&' maybe_mut expr               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n+| ANDAND maybe_mut expr            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n+| lambda_expr\n+| MOVE lambda_expr                 { $$ = $2; }\n+| proc_expr\n+;\n+\n+expr_qualified_path\n+: '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_qpath_params\n+{\n+  $$ = mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7);\n+}\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n+{\n+  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10);\n+}\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident\n+{\n+  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11);\n+}\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident generic_args\n+{\n+  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10, $11);\n+}\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident generic_args\n+{\n+  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11, $12);\n+}\n+\n+maybe_qpath_params\n+: MOD_SEP generic_args { $$ = $2; }\n+| %empty               { $$ = mk_none(); }\n+;\n+\n+maybe_as_trait_ref\n+: AS trait_ref { $$ = $2; }\n+| %empty       { $$ = mk_none(); }\n+;\n+\n+lambda_expr\n+: %prec LAMBDA\n+  OROR ret_ty expr                                        { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n+| %prec LAMBDA\n+  '|' maybe_unboxed_closure_kind '|' ret_ty expr          { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $4, $5); }\n+| %prec LAMBDA\n+  '|' inferrable_params '|' ret_ty expr                   { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n+| %prec LAMBDA\n+  '|' '&' maybe_mut ':' inferrable_params '|' ret_ty expr { $$ = mk_node(\"ExprFnBlock\", 3, $5, $7, $8); }\n+| %prec LAMBDA\n+  '|' ':' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $3, $5, $6); }\n+;\n+\n+lambda_expr_nostruct\n+: %prec LAMBDA\n+  OROR expr_nostruct                                        { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n+| %prec LAMBDA\n+  '|' maybe_unboxed_closure_kind '|'  expr_nostruct         { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $4); }\n+| %prec LAMBDA\n+  '|' inferrable_params '|' expr_nostruct                   { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n+| %prec LAMBDA\n+  '|' '&' maybe_mut ':' inferrable_params '|' expr_nostruct { $$ = mk_node(\"ExprFnBlock\", 2, $5, $7); }\n+| %prec LAMBDA\n+  '|' ':' inferrable_params '|' expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 2, $3, $5); }\n+\n+;\n+\n+proc_expr\n+: %prec LAMBDA\n+  PROC '(' ')' expr                         { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+| %prec LAMBDA\n+  PROC '(' inferrable_params ')' expr       { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+;\n+\n+proc_expr_nostruct\n+: %prec LAMBDA\n+  PROC '(' ')' expr_nostruct                     { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+| %prec LAMBDA\n+  PROC '(' inferrable_params ')' expr_nostruct   { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+;\n+\n+vec_expr\n+: maybe_exprs\n+| exprs ';' expr { $$ = mk_node(\"VecRepeat\", 2, $1, $3); }\n+;\n+\n+struct_expr_fields\n+: field_inits\n+| field_inits ','\n+| maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\n+;\n+\n+maybe_field_inits\n+: field_inits\n+| field_inits ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+field_inits\n+: field_init                 { $$ = mk_node(\"FieldInits\", 1, $1); }\n+| field_inits ',' field_init { $$ = ext_node($1, 1, $3); }\n+;\n+\n+field_init\n+: ident ':' expr   { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n+;\n+\n+default_field_init\n+: DOTDOT expr   { $$ = mk_node(\"DefaultFieldInit\", 1, $2); }\n+;\n+\n+block_expr\n+: expr_match\n+| expr_if\n+| expr_if_let\n+| expr_while\n+| expr_while_let\n+| expr_loop\n+| expr_for\n+| UNSAFE block                                           { $$ = mk_node(\"UnsafeBlock\", 1, $2); }\n+| path_expr '!' maybe_ident braces_delimited_token_trees { $$ = mk_node(\"Macro\", 3, $1, $3, $4); }\n+;\n+\n+full_block_expr\n+: block_expr\n+| full_block_expr '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| full_block_expr '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n+| full_block_expr '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n+| full_block_expr '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+;\n+\n+expr_match\n+: MATCH expr_nostruct '{' '}'                                     { $$ = mk_node(\"ExprMatch\", 1, $2); }\n+| MATCH expr_nostruct '{' match_clauses                       '}' { $$ = mk_node(\"ExprMatch\", 2, $2, $4); }\n+| MATCH expr_nostruct '{' match_clauses nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, ext_node($4, 1, $5)); }\n+| MATCH expr_nostruct '{'               nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, mk_node(\"Arms\", 1, $4)); }\n+;\n+\n+match_clauses\n+: match_clause               { $$ = mk_node(\"Arms\", 1, $1); }\n+| match_clauses match_clause { $$ = ext_node($1, 1, $2); }\n+;\n+\n+match_clause\n+: nonblock_match_clause ','\n+| block_match_clause\n+| block_match_clause ','\n+;\n+\n+nonblock_match_clause\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr   { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW full_block_expr { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+;\n+\n+block_match_clause\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+;\n+\n+maybe_guard\n+: IF expr_nostruct           { $$ = $2; }\n+| %empty                     { $$ = mk_none(); }\n+;\n+\n+expr_if\n+: IF expr_nostruct block                              { $$ = mk_node(\"ExprIf\", 2, $2, $3); }\n+| IF expr_nostruct block ELSE block_or_if             { $$ = mk_node(\"ExprIf\", 3, $2, $3, $5); }\n+;\n+\n+expr_if_let\n+: IF LET pat '=' expr_nostruct block                  { $$ = mk_node(\"ExprIfLet\", 3, $3, $5, $6); }\n+| IF LET pat '=' expr_nostruct block ELSE block_or_if { $$ = mk_node(\"ExprIfLet\", 4, $3, $5, $6, $8); }\n+;\n+\n+block_or_if\n+: block\n+| expr_if\n+| expr_if_let\n+;\n+\n+expr_while\n+: maybe_label WHILE expr_nostruct block               { $$ = mk_node(\"ExprWhile\", 3, $1, $3, $4); }\n+;\n+\n+expr_while_let\n+: maybe_label WHILE LET pat '=' expr_nostruct block   { $$ = mk_node(\"ExprWhileLet\", 4, $1, $4, $6, $7); }\n+;\n+\n+expr_loop\n+: maybe_label LOOP block                              { $$ = mk_node(\"ExprLoop\", 2, $1, $3); }\n+;\n+\n+expr_for\n+: maybe_label FOR pat IN expr_nostruct block          { $$ = mk_node(\"ExprForLoop\", 4, $1, $3, $5, $6); }\n+;\n+\n+maybe_label\n+: lifetime ':'\n+| %empty { $$ = mk_none(); }\n+;\n+\n+let\n+: LET pat maybe_ty_ascription maybe_init_expr ';' { $$ = mk_node(\"DeclLocal\", 3, $2, $3, $4); }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 5: Macros and misc. rules\n+////////////////////////////////////////////////////////////////////////\n+\n+lit\n+: LIT_BYTE                   { $$ = mk_node(\"LitByte\", 1, mk_atom(yytext)); }\n+| LIT_CHAR                   { $$ = mk_node(\"LitChar\", 1, mk_atom(yytext)); }\n+| LIT_INTEGER                { $$ = mk_node(\"LitInteger\", 1, mk_atom(yytext)); }\n+| LIT_FLOAT                  { $$ = mk_node(\"LitFloat\", 1, mk_atom(yytext)); }\n+| TRUE                       { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n+| FALSE                      { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n+| str\n+;\n+\n+str\n+: LIT_STR                    { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"CookedStr\")); }\n+| LIT_STR_RAW                { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"RawStr\")); }\n+| LIT_BYTE_STR                 { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"ByteStr\")); }\n+| LIT_BYTE_STR_RAW             { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"RawByteStr\")); }\n+;\n+\n+maybe_ident\n+: %empty { $$ = mk_none(); }\n+| ident\n+;\n+\n+ident\n+: IDENT                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+;\n+\n+unpaired_token\n+: SHL                        { $$ = mk_atom(yytext); }\n+| SHR                        { $$ = mk_atom(yytext); }\n+| LE                         { $$ = mk_atom(yytext); }\n+| EQEQ                       { $$ = mk_atom(yytext); }\n+| NE                         { $$ = mk_atom(yytext); }\n+| GE                         { $$ = mk_atom(yytext); }\n+| ANDAND                     { $$ = mk_atom(yytext); }\n+| OROR                       { $$ = mk_atom(yytext); }\n+| LARROW                     { $$ = mk_atom(yytext); }\n+| SHLEQ                      { $$ = mk_atom(yytext); }\n+| SHREQ                      { $$ = mk_atom(yytext); }\n+| MINUSEQ                    { $$ = mk_atom(yytext); }\n+| ANDEQ                      { $$ = mk_atom(yytext); }\n+| OREQ                       { $$ = mk_atom(yytext); }\n+| PLUSEQ                     { $$ = mk_atom(yytext); }\n+| STAREQ                     { $$ = mk_atom(yytext); }\n+| SLASHEQ                    { $$ = mk_atom(yytext); }\n+| CARETEQ                    { $$ = mk_atom(yytext); }\n+| PERCENTEQ                  { $$ = mk_atom(yytext); }\n+| DOTDOT                     { $$ = mk_atom(yytext); }\n+| DOTDOTDOT                  { $$ = mk_atom(yytext); }\n+| MOD_SEP                    { $$ = mk_atom(yytext); }\n+| RARROW                     { $$ = mk_atom(yytext); }\n+| FAT_ARROW                  { $$ = mk_atom(yytext); }\n+| LIT_BYTE                   { $$ = mk_atom(yytext); }\n+| LIT_CHAR                   { $$ = mk_atom(yytext); }\n+| LIT_INTEGER                { $$ = mk_atom(yytext); }\n+| LIT_FLOAT                  { $$ = mk_atom(yytext); }\n+| LIT_STR                    { $$ = mk_atom(yytext); }\n+| LIT_STR_RAW                { $$ = mk_atom(yytext); }\n+| LIT_BYTE_STR               { $$ = mk_atom(yytext); }\n+| LIT_BYTE_STR_RAW           { $$ = mk_atom(yytext); }\n+| IDENT                      { $$ = mk_atom(yytext); }\n+| UNDERSCORE                 { $$ = mk_atom(yytext); }\n+| LIFETIME                   { $$ = mk_atom(yytext); }\n+| SELF                       { $$ = mk_atom(yytext); }\n+| STATIC                     { $$ = mk_atom(yytext); }\n+| AS                         { $$ = mk_atom(yytext); }\n+| BREAK                      { $$ = mk_atom(yytext); }\n+| CRATE                      { $$ = mk_atom(yytext); }\n+| ELSE                       { $$ = mk_atom(yytext); }\n+| ENUM                       { $$ = mk_atom(yytext); }\n+| EXTERN                     { $$ = mk_atom(yytext); }\n+| FALSE                      { $$ = mk_atom(yytext); }\n+| FN                         { $$ = mk_atom(yytext); }\n+| FOR                        { $$ = mk_atom(yytext); }\n+| IF                         { $$ = mk_atom(yytext); }\n+| IMPL                       { $$ = mk_atom(yytext); }\n+| IN                         { $$ = mk_atom(yytext); }\n+| LET                        { $$ = mk_atom(yytext); }\n+| LOOP                       { $$ = mk_atom(yytext); }\n+| MATCH                      { $$ = mk_atom(yytext); }\n+| MOD                        { $$ = mk_atom(yytext); }\n+| MOVE                       { $$ = mk_atom(yytext); }\n+| MUT                        { $$ = mk_atom(yytext); }\n+| PRIV                       { $$ = mk_atom(yytext); }\n+| PUB                        { $$ = mk_atom(yytext); }\n+| REF                        { $$ = mk_atom(yytext); }\n+| RETURN                     { $$ = mk_atom(yytext); }\n+| STRUCT                     { $$ = mk_atom(yytext); }\n+| TRUE                       { $$ = mk_atom(yytext); }\n+| TRAIT                      { $$ = mk_atom(yytext); }\n+| TYPE                       { $$ = mk_atom(yytext); }\n+| UNSAFE                     { $$ = mk_atom(yytext); }\n+| USE                        { $$ = mk_atom(yytext); }\n+| WHILE                      { $$ = mk_atom(yytext); }\n+| CONTINUE                   { $$ = mk_atom(yytext); }\n+| PROC                       { $$ = mk_atom(yytext); }\n+| BOX                        { $$ = mk_atom(yytext); }\n+| CONST                      { $$ = mk_atom(yytext); }\n+| WHERE                      { $$ = mk_atom(yytext); }\n+| TYPEOF                     { $$ = mk_atom(yytext); }\n+| INNER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n+| OUTER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n+| SHEBANG                    { $$ = mk_atom(yytext); }\n+| STATIC_LIFETIME            { $$ = mk_atom(yytext); }\n+| ';'                        { $$ = mk_atom(yytext); }\n+| ','                        { $$ = mk_atom(yytext); }\n+| '.'                        { $$ = mk_atom(yytext); }\n+| '@'                        { $$ = mk_atom(yytext); }\n+| '#'                        { $$ = mk_atom(yytext); }\n+| '~'                        { $$ = mk_atom(yytext); }\n+| ':'                        { $$ = mk_atom(yytext); }\n+| '$'                        { $$ = mk_atom(yytext); }\n+| '='                        { $$ = mk_atom(yytext); }\n+| '?'                        { $$ = mk_atom(yytext); }\n+| '!'                        { $$ = mk_atom(yytext); }\n+| '<'                        { $$ = mk_atom(yytext); }\n+| '>'                        { $$ = mk_atom(yytext); }\n+| '-'                        { $$ = mk_atom(yytext); }\n+| '&'                        { $$ = mk_atom(yytext); }\n+| '|'                        { $$ = mk_atom(yytext); }\n+| '+'                        { $$ = mk_atom(yytext); }\n+| '*'                        { $$ = mk_atom(yytext); }\n+| '/'                        { $$ = mk_atom(yytext); }\n+| '^'                        { $$ = mk_atom(yytext); }\n+| '%'                        { $$ = mk_atom(yytext); }\n+;\n+\n+token_trees\n+: %empty                     { $$ = mk_node(\"TokenTrees\", 0); }\n+| token_trees token_tree     { $$ = ext_node($1, 1, $2); }\n+;\n+\n+token_tree\n+: delimited_token_trees\n+| unpaired_token         { $$ = mk_node(\"TTTok\", 1, $1); }\n+;\n+\n+delimited_token_trees\n+: parens_delimited_token_trees\n+| braces_delimited_token_trees\n+| brackets_delimited_token_trees\n+;\n+\n+parens_delimited_token_trees\n+: '(' token_trees ')'\n+{\n+  $$ = mk_node(\"TTDelim\", 3,\n+               mk_node(\"TTTok\", 1, mk_atom(\"(\")),\n+               $2,\n+               mk_node(\"TTTok\", 1, mk_atom(\")\")));\n+}\n+;\n+\n+braces_delimited_token_trees\n+: '{' token_trees '}'\n+{\n+  $$ = mk_node(\"TTDelim\", 3,\n+               mk_node(\"TTTok\", 1, mk_atom(\"{\")),\n+               $2,\n+               mk_node(\"TTTok\", 1, mk_atom(\"}\")));\n+}\n+;\n+\n+brackets_delimited_token_trees\n+: '[' token_trees ']'\n+{\n+  $$ = mk_node(\"TTDelim\", 3,\n+               mk_node(\"TTTok\", 1, mk_atom(\"[\")),\n+               $2,\n+               mk_node(\"TTTok\", 1, mk_atom(\"]\")));\n+}\n+;\n\\ No newline at end of file"}, {"sha": "c909f2333148a99d3482373c91e279a2dad2a1ce", "filename": "src/grammar/raw-string-literal-ambiguity.md", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fraw-string-literal-ambiguity.md?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,64 @@\n+Rust's lexical grammar is not context-free. Raw string literals are the source\n+of the problem. Informally, a raw string literal is an `r`, followed by `N`\n+hashes (where N can be zero), a quote, any characters, then a quote followed\n+by `N` hashes. Critically, once inside the first pair of quotes,\n+another quote cannot be followed by `N` consecutive hashes. e.g.\n+`r###\"\"###\"###` is invalid.\n+\n+This grammar describes this as best possible:\n+\n+    R -> 'r' S\n+    S -> '\"' B '\"'\n+    S -> '#' S '#'\n+    B -> . B\n+    B -> \u03b5\n+\n+Where `.` represents any character, and `\u03b5` the empty string. Consider the\n+string `r#\"\"#\"#`. This string is not a valid raw string literal, but can be\n+accepted as one by the above grammar, using the derivation:\n+\n+    R : #\"\"#\"#\n+    S : \"\"#\"\n+    S : \"#\n+    B : #\n+    B : \u03b5\n+\n+(Where `T : U` means the rule `T` is applied, and `U` is the remainder of the\n+string.) The difficulty arises from the fact that it is fundamentally\n+context-sensitive. In particular, the context needed is the number of hashes.\n+\n+To prove that Rust's string literals are not context-free, we will use\n+the fact that context-free languages are closed under intersection with\n+regular languages, and the\n+[pumping lemma for context-free languages](https://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages).\n+\n+Consider the regular language `R = r#+\"\"#*\"#+`. If Rust's raw string literals are\n+context-free, then their intersection with `R`, `R'`, should also be context-free.\n+Therefore, to prove that raw string literals are not context-free,\n+it is sufficient to prove that `R'` is not context-free.\n+\n+The language `R'` is `{r#^n\"\"#^m\"#^n | m < n}`.\n+\n+Assume `R'` *is* context-free. Then `R'` has some pumping length `p > 0` for which\n+the pumping lemma applies. Consider the following string `s` in `R'`:\n+\n+`r#^p\"\"#^{p-1}\"#^p`\n+\n+e.g. for `p = 2`: `s = r##\"\"#\"##`\n+\n+Then `s = uvwxy` for some choice of `uvwxy` such that `vx` is non-empty,\n+`|vwx| < p+1`, and `uv^iwx^iy` is in `R'` for all `i >= 0`.\n+\n+Neither `v` nor `x` can contain a `\"` or `r`, as the number of these characters\n+in any string in `R'` is fixed. So `v` and `x` contain only hashes.\n+Consequently, of the three sequences of hashes, `v` and `x` combined\n+can only pump two of them.\n+If we ever choose the central sequence of hashes, then one of the outer sequences\n+will not grow when we pump, leading to an imbalance between the outer sequences.\n+Therefore, we must pump both outer sequences of hashes. However,\n+there are `p+2` characters between these two sequences of hashes, and `|vwx|` must\n+be less than `p+1`. Therefore we have a contradiction, and `R'` must not be\n+context-free.\n+\n+Since `R'` is not context-free, it follows that the Rust's raw string literals\n+must not be context-free."}, {"sha": "37be41b935f84b4e1434ba9f76d8aa8b25ed4c98", "filename": "src/grammar/testparser.py", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Ftestparser.py", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Ftestparser.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftestparser.py?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,76 @@\n+#!/usr/bin/env python\n+#\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# ignore-tidy-linelength\n+\n+import sys\n+\n+import os\n+import subprocess\n+import argparse\n+\n+# usage: testparser.py [-h] [-p PARSER [PARSER ...]] -s SOURCE_DIR\n+\n+# Parsers should read from stdin and return exit status 0 for a\n+# successful parse, and nonzero for an unsuccessful parse\n+\n+parser = argparse.ArgumentParser()\n+parser.add_argument('-p', '--parser', nargs='+')\n+parser.add_argument('-s', '--source-dir', nargs=1, required=True)\n+args = parser.parse_args(sys.argv[1:])\n+\n+total = 0\n+ok = {}\n+bad = {}\n+for parser in args.parser:\n+    ok[parser] = 0\n+    bad[parser] = []\n+devnull = open(os.devnull, 'w')\n+print(\"\\n\")\n+\n+for base, dirs, files in os.walk(args.source_dir[0]):\n+    for f in filter(lambda p: p.endswith('.rs'), files):\n+        p = os.path.join(base, f)\n+        parse_fail = 'parse-fail' in p\n+        if sys.version_info.major == 3:\n+            lines = open(p, encoding='utf-8').readlines()\n+        else:\n+            lines = open(p).readlines()\n+        if any('ignore-test' in line or 'ignore-lexer-test' in line for line in lines):\n+            continue\n+        total += 1\n+        for parser in args.parser:\n+            if subprocess.call(parser, stdin=open(p), stderr=subprocess.STDOUT, stdout=devnull) == 0:\n+                if parse_fail:\n+                    bad[parser].append(p)\n+                else:\n+                    ok[parser] += 1\n+            else:\n+                if parse_fail:\n+                    ok[parser] += 1\n+                else:\n+                    bad[parser].append(p)\n+        parser_stats = ', '.join(['{}: {}'.format(parser, ok[parser]) for parser in args.parser])\n+        sys.stdout.write(\"\\033[K\\r total: {}, {}, scanned {}\"\n+                         .format(total, os.path.relpath(parser_stats), os.path.relpath(p)))\n+\n+devnull.close()\n+\n+print(\"\\n\")\n+\n+for parser in args.parser:\n+    filename = os.path.basename(parser) + '.bad'\n+    print(\"writing {} files that did not yield the correct result with {} to {}\".format(len(bad[parser]), parser, filename))\n+    with open(filename, \"w\") as f:\n+        for p in bad[parser]:\n+            f.write(p)\n+            f.write(\"\\n\")"}, {"sha": "081bd05025967e76940f075c1c490c6ccdf2bfa7", "filename": "src/grammar/tokens.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Token {\n+  SHL = 257, // Parser generators reserve 0-256 for char literals\n+  SHR,\n+  LE,\n+  EQEQ,\n+  NE,\n+  GE,\n+  ANDAND,\n+  OROR,\n+  SHLEQ,\n+  SHREQ,\n+  MINUSEQ,\n+  ANDEQ,\n+  OREQ,\n+  PLUSEQ,\n+  STAREQ,\n+  SLASHEQ,\n+  CARETEQ,\n+  PERCENTEQ,\n+  DOTDOT,\n+  DOTDOTDOT,\n+  MOD_SEP,\n+  RARROW,\n+  FAT_ARROW,\n+  LIT_BYTE,\n+  LIT_CHAR,\n+  LIT_INTEGER,\n+  LIT_FLOAT,\n+  LIT_STR,\n+  LIT_STR_RAW,\n+  LIT_BYTE_STR,\n+  LIT_BYTE_STR_RAW,\n+  IDENT,\n+  UNDERSCORE,\n+  LIFETIME,\n+\n+  // keywords\n+  SELF,\n+  STATIC,\n+  AS,\n+  BREAK,\n+  CRATE,\n+  ELSE,\n+  ENUM,\n+  EXTERN,\n+  FALSE,\n+  FN,\n+  FOR,\n+  IF,\n+  IMPL,\n+  IN,\n+  LET,\n+  LOOP,\n+  MATCH,\n+  MOD,\n+  MOVE,\n+  MUT,\n+  PRIV,\n+  PUB,\n+  REF,\n+  RETURN,\n+  STRUCT,\n+  TRUE,\n+  TRAIT,\n+  TYPE,\n+  UNSAFE,\n+  USE,\n+  WHILE,\n+  CONTINUE,\n+  PROC,\n+  BOX,\n+  CONST,\n+  WHERE,\n+  TYPEOF,\n+  INNER_DOC_COMMENT,\n+  OUTER_DOC_COMMENT,\n+\n+  SHEBANG,\n+  SHEBANG_LINE,\n+  STATIC_LIFETIME\n+};"}, {"sha": "6d85183faf75d9867b2f54d531b74e30973b9a07", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -277,8 +277,7 @@ impl<T> Arc<T> {\n         atomic::fence(Acquire);\n \n         unsafe {\n-            let ptr = *this.ptr;\n-            let elem = ptr::read(&(*ptr).data);\n+            let elem = ptr::read(&this.ptr.as_ref().data);\n \n             // Make a weak pointer to clean up the implicit strong-weak reference\n             let _weak = Weak { ptr: this.ptr };\n@@ -306,7 +305,7 @@ impl<T> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr = unsafe { &(**this.ptr).data as *const _ };\n+        let ptr: *const T = &*this;\n         mem::forget(this);\n         ptr\n     }\n@@ -345,7 +344,7 @@ impl<T> Arc<T> {\n         // `data` field from the pointer.\n         let ptr = (ptr as *const u8).offset(-offset_of!(ArcInner<T>, data));\n         Arc {\n-            ptr: Shared::new(ptr as *const _),\n+            ptr: Shared::new(ptr as *mut u8 as *mut _),\n         }\n     }\n }\n@@ -452,17 +451,17 @@ impl<T: ?Sized> Arc<T> {\n         // `ArcInner` structure itself is `Sync` because the inner data is\n         // `Sync` as well, so we're ok loaning out an immutable pointer to these\n         // contents.\n-        unsafe { &**self.ptr }\n+        unsafe { self.ptr.as_ref() }\n     }\n \n     // Non-inlined part of `drop`.\n     #[inline(never)]\n     unsafe fn drop_slow(&mut self) {\n-        let ptr = self.ptr.as_mut_ptr();\n+        let ptr = self.ptr.as_ptr();\n \n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n-        ptr::drop_in_place(&mut (*ptr).data);\n+        ptr::drop_in_place(&mut self.ptr.as_mut().data);\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n@@ -488,9 +487,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        let this_ptr: *const ArcInner<T> = *this.ptr;\n-        let other_ptr: *const ArcInner<T> = *other.ptr;\n-        this_ptr == other_ptr\n+        this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n@@ -621,7 +618,7 @@ impl<T: Clone> Arc<T> {\n                 // here (due to zeroing) because data is no longer accessed by\n                 // other threads (due to there being no more strong refs at this\n                 // point).\n-                let mut swap = Arc::new(ptr::read(&(**weak.ptr).data));\n+                let mut swap = Arc::new(ptr::read(&weak.ptr.as_ref().data));\n                 mem::swap(this, &mut swap);\n                 mem::forget(swap);\n             }\n@@ -634,8 +631,7 @@ impl<T: Clone> Arc<T> {\n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n         unsafe {\n-            let inner = &mut *this.ptr.as_mut_ptr();\n-            &mut inner.data\n+            &mut this.ptr.as_mut().data\n         }\n     }\n }\n@@ -677,8 +673,7 @@ impl<T: ?Sized> Arc<T> {\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n             unsafe {\n-                let inner = &mut *this.ptr.as_mut_ptr();\n-                Some(&mut inner.data)\n+                Some(&mut this.ptr.as_mut().data)\n             }\n         } else {\n             None\n@@ -767,7 +762,18 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n         // > through this reference must obviously happened before), and an\n         // > \"acquire\" operation before deleting the object.\n         //\n+        // In particular, while the contents of an Arc are usually immutable, it's\n+        // possible to have interior writes to something like a Mutex<T>. Since a\n+        // Mutex is not acquired when it is deleted, we can't rely on its\n+        // synchronization logic to make writes in thread A visible to a destructor\n+        // running in thread B.\n+        //\n+        // Also note that the Acquire fence here could probably be replaced with an\n+        // Acquire load, which could improve performance in highly-contended\n+        // situations. See [2].\n+        //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n+        // [2]: (https://github.com/rust-lang/rust/pull/41714)\n         atomic::fence(Acquire);\n \n         unsafe {\n@@ -867,7 +873,7 @@ impl<T: ?Sized> Weak<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // See comments above for why this is \"safe\"\n-        unsafe { &**self.ptr }\n+        unsafe { self.ptr.as_ref() }\n     }\n }\n \n@@ -951,7 +957,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n-        let ptr = *self.ptr;\n+        let ptr = self.ptr.as_ptr();\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about\n@@ -1132,7 +1138,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.ptr, f)\n+        fmt::Pointer::fmt(&self.ptr, f)\n     }\n }\n "}, {"sha": "fc6929f896ecbaa70870751f9c59007cc1024983", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -156,7 +156,7 @@ fn make_place<T>() -> IntermediateBox<T> {\n     let align = mem::align_of::<T>();\n \n     let p = if size == 0 {\n-        heap::EMPTY as *mut u8\n+        mem::align_of::<T>() as *mut u8\n     } else {\n         let p = unsafe { heap::allocate(size, align) };\n         if p.is_null() {"}, {"sha": "5ff21c86483c80cbbef1ef02fe516cc425b5dab6", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -138,7 +138,9 @@ pub fn usable_size(size: usize, align: usize) -> usize {\n ///\n /// This preserves the non-null invariant for types like `Box<T>`. The address\n /// may overlap with non-zero-size memory allocations.\n-pub const EMPTY: *mut () = 0x1 as *mut ();\n+#[rustc_deprecated(since = \"1.19\", reason = \"Use Unique/Shared::empty() instead\")]\n+#[unstable(feature = \"heap_api\", issue = \"27700\")]\n+pub const EMPTY: *mut () = 1 as *mut ();\n \n /// The allocator for unique pointers.\n // This function must not unwind. If it does, MIR trans will fail.\n@@ -147,7 +149,7 @@ pub const EMPTY: *mut () = 0x1 as *mut ();\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     if size == 0 {\n-        EMPTY as *mut u8\n+        align as *mut u8\n     } else {\n         let ptr = allocate(size, align);\n         if ptr.is_null() {"}, {"sha": "7edf07944ec50c812aead220f6e66b4c69402b6a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -22,13 +22,13 @@ use core::cmp;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n-/// * Produces heap::EMPTY on zero-sized types\n-/// * Produces heap::EMPTY on zero-length allocations\n+/// * Produces Unique::empty() on zero-sized types\n+/// * Produces Unique::empty() on zero-length allocations\n /// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics)\n /// * Guards against 32-bit systems allocating more than isize::MAX bytes\n /// * Guards against overflowing your length\n /// * Aborts on OOM\n-/// * Avoids freeing heap::EMPTY\n+/// * Avoids freeing Unique::empty()\n /// * Contains a ptr::Unique and thus endows the user with all related benefits\n ///\n /// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n@@ -55,15 +55,13 @@ impl<T> RawVec<T> {\n     /// it makes a RawVec with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub fn new() -> Self {\n-        unsafe {\n-            // !0 is usize::MAX. This branch should be stripped at compile time.\n-            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+        // !0 is usize::MAX. This branch should be stripped at compile time.\n+        let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n \n-            // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n-            RawVec {\n-                ptr: Unique::new(heap::EMPTY as *mut T),\n-                cap: cap,\n-            }\n+        // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n+        RawVec {\n+            ptr: Unique::empty(),\n+            cap: cap,\n         }\n     }\n \n@@ -101,7 +99,7 @@ impl<T> RawVec<T> {\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n-                heap::EMPTY as *mut u8\n+                mem::align_of::<T>() as *mut u8\n             } else {\n                 let align = mem::align_of::<T>();\n                 let ptr = if zeroed {\n@@ -148,10 +146,10 @@ impl<T> RawVec<T> {\n \n impl<T> RawVec<T> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// heap::EMPTY if `cap = 0` or T is zero-sized. In the former case, you must\n+    /// Unique::empty() if `cap = 0` or T is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n-        *self.ptr\n+        self.ptr.as_ptr()\n     }\n \n     /// Gets the capacity of the allocation.\n@@ -563,7 +561,7 @@ unsafe impl<#[may_dangle] T> Drop for RawVec<T> {\n \n             let num_bytes = elem_size * self.cap;\n             unsafe {\n-                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n+                heap::deallocate(self.ptr() as *mut u8, num_bytes, align);\n             }\n         }\n     }"}, {"sha": "d6dbf77bfac770466ff3dfb8de43e83397d217fd", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -230,7 +230,7 @@ use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::intrinsics::{abort, assume};\n+use core::intrinsics::abort;\n use core::marker;\n use core::marker::Unsize;\n use core::mem::{self, align_of_val, forget, size_of, size_of_val, uninitialized};\n@@ -358,7 +358,7 @@ impl<T> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr = unsafe { &mut (*this.ptr.as_mut_ptr()).value as *const _ };\n+        let ptr: *const T = &*this;\n         mem::forget(this);\n         ptr\n     }\n@@ -395,7 +395,11 @@ impl<T> Rc<T> {\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         // To find the corresponding pointer to the `RcBox` we need to subtract the offset of the\n         // `value` field from the pointer.\n-        Rc { ptr: Shared::new((ptr as *const u8).offset(-offset_of!(RcBox<T>, value)) as *const _) }\n+\n+        let ptr = (ptr as *const u8).offset(-offset_of!(RcBox<T>, value));\n+        Rc {\n+            ptr: Shared::new(ptr as *mut u8 as *mut _)\n+        }\n     }\n }\n \n@@ -451,7 +455,7 @@ impl<T> Rc<[T]> {\n             // Free the original allocation without freeing its (moved) contents.\n             box_free(Box::into_raw(value));\n \n-            Rc { ptr: Shared::new(ptr as *const _) }\n+            Rc { ptr: Shared::new(ptr as *mut _) }\n         }\n     }\n }\n@@ -553,8 +557,9 @@ impl<T: ?Sized> Rc<T> {\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if Rc::is_unique(this) {\n-            let inner = unsafe { &mut *this.ptr.as_mut_ptr() };\n-            Some(&mut inner.value)\n+            unsafe {\n+                Some(&mut this.ptr.as_mut().value)\n+            }\n         } else {\n             None\n         }\n@@ -578,9 +583,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        let this_ptr: *const RcBox<T> = *this.ptr;\n-        let other_ptr: *const RcBox<T> = *other.ptr;\n-        this_ptr == other_ptr\n+        this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n@@ -623,7 +626,7 @@ impl<T: Clone> Rc<T> {\n         } else if Rc::weak_count(this) != 0 {\n             // Can just steal the data, all that's left is Weaks\n             unsafe {\n-                let mut swap = Rc::new(ptr::read(&(**this.ptr).value));\n+                let mut swap = Rc::new(ptr::read(&this.ptr.as_ref().value));\n                 mem::swap(this, &mut swap);\n                 swap.dec_strong();\n                 // Remove implicit strong-weak ref (no need to craft a fake\n@@ -637,8 +640,9 @@ impl<T: Clone> Rc<T> {\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n         // reference to the inner value.\n-        let inner = unsafe { &mut *this.ptr.as_mut_ptr() };\n-        &mut inner.value\n+        unsafe {\n+            &mut this.ptr.as_mut().value\n+        }\n     }\n }\n \n@@ -683,12 +687,12 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = self.ptr.as_mut_ptr();\n+            let ptr = self.ptr.as_ptr();\n \n             self.dec_strong();\n             if self.strong() == 0 {\n                 // destroy the contained object\n-                ptr::drop_in_place(&mut (*ptr).value);\n+                ptr::drop_in_place(self.ptr.as_mut());\n \n                 // remove the implicit \"strong weak\" pointer now that we've\n                 // destroyed the contents.\n@@ -925,7 +929,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Rc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.ptr, f)\n+        fmt::Pointer::fmt(&self.ptr, f)\n     }\n }\n \n@@ -1067,7 +1071,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = *self.ptr;\n+            let ptr = self.ptr.as_ptr();\n \n             self.dec_weak();\n             // the weak count starts at 1, and will only go to zero if all\n@@ -1175,12 +1179,7 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n         unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-            &(**self.ptr)\n+            self.ptr.as_ref()\n         }\n     }\n }\n@@ -1189,12 +1188,7 @@ impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n         unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-            &(**self.ptr)\n+            self.ptr.as_ref()\n         }\n     }\n }"}, {"sha": "321fa2edd56c7717e9bb2aaa243392d175b5feb1", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -31,7 +31,6 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![feature(heap_api)]\n #![feature(generic_param_attrs)]\n #![feature(staged_api)]\n #![cfg_attr(test, feature(test))]\n@@ -48,7 +47,6 @@ use std::mem;\n use std::ptr;\n use std::slice;\n \n-use alloc::heap;\n use alloc::raw_vec::RawVec;\n \n /// An arena that can hold objects of only one type.\n@@ -140,7 +138,7 @@ impl<T> TypedArena<T> {\n         unsafe {\n             if mem::size_of::<T>() == 0 {\n                 self.ptr.set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1) as *mut T);\n-                let ptr = heap::EMPTY as *mut T;\n+                let ptr = mem::align_of::<T>() as *mut T;\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);\n                 &mut *ptr"}, {"sha": "52cdd39d8f963c0666bcc26ba71765ad977c6917", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -152,12 +152,12 @@ impl<K, V> BoxedNode<K, V> {\n     }\n \n     unsafe fn from_ptr(ptr: NonZero<*const LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::new(*ptr as *mut LeafNode<K, V>) }\n+        BoxedNode { ptr: Unique::new(ptr.get() as *mut LeafNode<K, V>) }\n     }\n \n     fn as_ptr(&self) -> NonZero<*const LeafNode<K, V>> {\n         unsafe {\n-            NonZero::new(*self.ptr as *const LeafNode<K, V>)\n+            NonZero::new(self.ptr.as_ptr())\n         }\n     }\n }\n@@ -241,7 +241,7 @@ impl<K, V> Root<K, V> {\n     pub fn pop_level(&mut self) {\n         debug_assert!(self.height > 0);\n \n-        let top = *self.node.ptr as *mut u8;\n+        let top = self.node.ptr.as_ptr() as *mut u8;\n \n         self.node = unsafe {\n             BoxedNode::from_ptr(self.as_mut()\n@@ -308,15 +308,15 @@ unsafe impl<K: Send, V: Send, Type> Send\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     fn as_internal(&self) -> &InternalNode<K, V> {\n         unsafe {\n-            &*(*self.node as *const InternalNode<K, V>)\n+            &*(self.node.get() as *const InternalNode<K, V>)\n         }\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n         unsafe {\n-            &mut *(*self.node as *mut InternalNode<K, V>)\n+            &mut *(self.node.get() as *mut InternalNode<K, V>)\n         }\n     }\n }\n@@ -358,7 +358,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n \n     fn as_leaf(&self) -> &LeafNode<K, V> {\n         unsafe {\n-            &**self.node\n+            &*self.node.get()\n         }\n     }\n \n@@ -510,7 +510,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n     fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n         unsafe {\n-            &mut *(*self.node as *mut LeafNode<K, V>)\n+            &mut *(self.node.get() as *mut LeafNode<K, V>)\n         }\n     }\n \n@@ -1253,13 +1253,13 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 heap::deallocate(\n-                    *right_node.node as *mut u8,\n+                    right_node.node.get() as *mut u8,\n                     mem::size_of::<InternalNode<K, V>>(),\n                     mem::align_of::<InternalNode<K, V>>()\n                 );\n             } else {\n                 heap::deallocate(\n-                    *right_node.node as *mut u8,\n+                    right_node.node.get() as *mut u8,\n                     mem::size_of::<LeafNode<K, V>>(),\n                     mem::align_of::<LeafNode<K, V>>()\n                 );"}, {"sha": "ae258083546f4fddcb52cbeb22920527de8f66a9", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -161,7 +161,7 @@ impl<T> LinkedList<T> {\n \n             match self.head {\n                 None => self.tail = node,\n-                Some(head) => (*head.as_mut_ptr()).prev = node,\n+                Some(mut head) => head.as_mut().prev = node,\n             }\n \n             self.head = node;\n@@ -173,12 +173,12 @@ impl<T> LinkedList<T> {\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n         self.head.map(|node| unsafe {\n-            let node = Box::from_raw(node.as_mut_ptr());\n+            let node = Box::from_raw(node.as_ptr());\n             self.head = node.next;\n \n             match self.head {\n                 None => self.tail = None,\n-                Some(head) => (*head.as_mut_ptr()).prev = None,\n+                Some(mut head) => head.as_mut().prev = None,\n             }\n \n             self.len -= 1;\n@@ -196,7 +196,7 @@ impl<T> LinkedList<T> {\n \n             match self.tail {\n                 None => self.head = node,\n-                Some(tail) => (*tail.as_mut_ptr()).next = node,\n+                Some(mut tail) => tail.as_mut().next = node,\n             }\n \n             self.tail = node;\n@@ -208,12 +208,12 @@ impl<T> LinkedList<T> {\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n         self.tail.map(|node| unsafe {\n-            let node = Box::from_raw(node.as_mut_ptr());\n+            let node = Box::from_raw(node.as_ptr());\n             self.tail = node.prev;\n \n             match self.tail {\n                 None => self.head = None,\n-                Some(tail) => (*tail.as_mut_ptr()).next = None,\n+                Some(mut tail) => tail.as_mut().next = None,\n             }\n \n             self.len -= 1;\n@@ -285,11 +285,11 @@ impl<T> LinkedList<T> {\n     pub fn append(&mut self, other: &mut Self) {\n         match self.tail {\n             None => mem::swap(self, other),\n-            Some(tail) => {\n-                if let Some(other_head) = other.head.take() {\n+            Some(mut tail) => {\n+                if let Some(mut other_head) = other.head.take() {\n                     unsafe {\n-                        (*tail.as_mut_ptr()).next = Some(other_head);\n-                        (*other_head.as_mut_ptr()).prev = Some(tail);\n+                        tail.as_mut().next = Some(other_head);\n+                        other_head.as_mut().prev = Some(tail);\n                     }\n \n                     self.tail = other.tail.take();\n@@ -477,7 +477,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n-        self.head.map(|node| unsafe { &(**node).element })\n+        unsafe {\n+            self.head.as_ref().map(|node| &node.as_ref().element)\n+        }\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n@@ -503,7 +505,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        self.head.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+        unsafe {\n+            self.head.as_mut().map(|node| &mut node.as_mut().element)\n+        }\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n@@ -523,7 +527,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        self.tail.map(|node| unsafe { &(**node).element })\n+        unsafe {\n+            self.tail.as_ref().map(|node| &node.as_ref().element)\n+        }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n@@ -549,7 +555,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        self.tail.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+        unsafe {\n+            self.tail.as_mut().map(|node| &mut node.as_mut().element)\n+        }\n     }\n \n     /// Adds an element first in the list.\n@@ -694,9 +702,9 @@ impl<T> LinkedList<T> {\n         let second_part_head;\n \n         unsafe {\n-            second_part_head = (*split_node.unwrap().as_mut_ptr()).next.take();\n-            if let Some(head) = second_part_head {\n-                (*head.as_mut_ptr()).prev = None;\n+            second_part_head = split_node.unwrap().as_mut().next.take();\n+            if let Some(mut head) = second_part_head {\n+                head.as_mut().prev = None;\n             }\n         }\n \n@@ -788,7 +796,8 @@ impl<'a, T> Iterator for Iter<'a, T> {\n             None\n         } else {\n             self.head.map(|node| unsafe {\n-                let node = &**node;\n+                // Need an unbound lifetime to get 'a\n+                let node = &*node.as_ptr();\n                 self.len -= 1;\n                 self.head = node.next;\n                 &node.element\n@@ -810,7 +819,8 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n             None\n         } else {\n             self.tail.map(|node| unsafe {\n-                let node = &**node;\n+                // Need an unbound lifetime to get 'a\n+                let node = &*node.as_ptr();\n                 self.len -= 1;\n                 self.tail = node.prev;\n                 &node.element\n@@ -835,7 +845,8 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n             None\n         } else {\n             self.head.map(|node| unsafe {\n-                let node = &mut *node.as_mut_ptr();\n+                // Need an unbound lifetime to get 'a\n+                let node = &mut *node.as_ptr();\n                 self.len -= 1;\n                 self.head = node.next;\n                 &mut node.element\n@@ -857,7 +868,8 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n             None\n         } else {\n             self.tail.map(|node| unsafe {\n-                let node = &mut *node.as_mut_ptr();\n+                // Need an unbound lifetime to get 'a\n+                let node = &mut *node.as_ptr();\n                 self.len -= 1;\n                 self.tail = node.prev;\n                 &mut node.element\n@@ -903,8 +915,8 @@ impl<'a, T> IterMut<'a, T> {\n     pub fn insert_next(&mut self, element: T) {\n         match self.head {\n             None => self.list.push_back(element),\n-            Some(head) => unsafe {\n-                let prev = match (**head).prev {\n+            Some(mut head) => unsafe {\n+                let mut prev = match head.as_ref().prev {\n                     None => return self.list.push_front(element),\n                     Some(prev) => prev,\n                 };\n@@ -915,8 +927,8 @@ impl<'a, T> IterMut<'a, T> {\n                     element: element,\n                 })));\n \n-                (*prev.as_mut_ptr()).next = node;\n-                (*head.as_mut_ptr()).prev = node;\n+                prev.as_mut().next = node;\n+                head.as_mut().prev = node;\n \n                 self.list.len += 1;\n             },\n@@ -948,7 +960,9 @@ impl<'a, T> IterMut<'a, T> {\n         if self.len == 0 {\n             None\n         } else {\n-            self.head.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+            unsafe {\n+                self.head.as_mut().map(|node| &mut node.as_mut().element)\n+            }\n         }\n     }\n }\n@@ -1276,21 +1290,21 @@ mod tests {\n                     assert_eq!(0, list.len);\n                     return;\n                 }\n-                Some(node) => node_ptr = &**node,\n+                Some(node) => node_ptr = &*node.as_ptr(),\n             }\n             loop {\n                 match (last_ptr, node_ptr.prev) {\n                     (None, None) => {}\n                     (None, _) => panic!(\"prev link for head\"),\n                     (Some(p), Some(pptr)) => {\n-                        assert_eq!(p as *const Node<T>, *pptr as *const Node<T>);\n+                        assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n                     }\n                     _ => panic!(\"prev link is none, not good\"),\n                 }\n                 match node_ptr.next {\n                     Some(next) => {\n                         last_ptr = Some(node_ptr);\n-                        node_ptr = &**next;\n+                        node_ptr = &*next.as_ptr();\n                         len += 1;\n                     }\n                     None => {"}, {"sha": "3efda1faa3b56405637a31019688775ffe8254fe", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -1341,6 +1341,9 @@ impl<T> [T] {\n     ///\n     /// The length of `src` must be the same as `self`.\n     ///\n+    /// If `src` implements `Copy`, it can be more performant to use\n+    /// [`copy_from_slice`].\n+    ///\n     /// # Panics\n     ///\n     /// This function will panic if the two slices have different lengths.\n@@ -1354,6 +1357,8 @@ impl<T> [T] {\n     /// dst.clone_from_slice(&src);\n     /// assert!(dst == [1, 2, 3]);\n     /// ```\n+    ///\n+    /// [`copy_from_slice`]: #method.copy_from_slice\n     #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n     pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n         core_slice::SliceExt::clone_from_slice(self, src)\n@@ -1363,6 +1368,8 @@ impl<T> [T] {\n     ///\n     /// The length of `src` must be the same as `self`.\n     ///\n+    /// If `src` does not implement `Copy`, use [`clone_from_slice`].\n+    ///\n     /// # Panics\n     ///\n     /// This function will panic if the two slices have different lengths.\n@@ -1376,6 +1383,8 @@ impl<T> [T] {\n     /// dst.copy_from_slice(&src);\n     /// assert_eq!(src, dst);\n     /// ```\n+    ///\n+    /// [`clone_from_slice`]: #method.clone_from_slice\n     #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n         core_slice::SliceExt::copy_from_slice(self, src)"}, {"sha": "7ec5c29de6b4be49918d8bc5678f51a0ef665d29", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -67,7 +67,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n-use alloc::heap::EMPTY;\n use alloc::raw_vec::RawVec;\n use borrow::ToOwned;\n use borrow::Cow;\n@@ -1776,9 +1775,9 @@ impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n         // A common case is passing a vector into a function which immediately\n         // re-collects into a vector. We can short circuit this if the IntoIter\n         // has not been advanced at all.\n-        if *iterator.buf == iterator.ptr as *mut T {\n+        if iterator.buf.as_ptr() as *const _ == iterator.ptr {\n             unsafe {\n-                let vec = Vec::from_raw_parts(*iterator.buf as *mut T,\n+                let vec = Vec::from_raw_parts(iterator.buf.as_ptr(),\n                                               iterator.len(),\n                                               iterator.cap);\n                 mem::forget(iterator);\n@@ -2192,7 +2191,8 @@ impl<T> Iterator for IntoIter<T> {\n                     self.ptr = arith_offset(self.ptr as *const i8, 1) as *mut T;\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n+                    // (self.ptr might be null because of wrapping)\n+                    Some(ptr::read(1 as *mut T))\n                 } else {\n                     let old = self.ptr;\n                     self.ptr = self.ptr.offset(1);\n@@ -2231,7 +2231,8 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n                     self.end = arith_offset(self.end as *const i8, -1) as *mut T;\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n+                    // (self.end might be null because of wrapping)\n+                    Some(ptr::read(1 as *mut T))\n                 } else {\n                     self.end = self.end.offset(-1);\n \n@@ -2269,7 +2270,7 @@ unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n         for _x in self.by_ref() {}\n \n         // RawVec handles deallocation\n-        let _ = unsafe { RawVec::from_raw_parts(self.buf.as_mut_ptr(), self.cap) };\n+        let _ = unsafe { RawVec::from_raw_parts(self.buf.as_ptr(), self.cap) };\n     }\n }\n \n@@ -2334,7 +2335,7 @@ impl<'a, T> Drop for Drain<'a, T> {\n \n         if self.tail_len > 0 {\n             unsafe {\n-                let source_vec = &mut *self.vec.as_mut_ptr();\n+                let source_vec = self.vec.as_mut();\n                 // memmove back untouched tail, update to new length\n                 let start = source_vec.len();\n                 let tail = self.tail_start;\n@@ -2456,8 +2457,7 @@ impl<'a, I: Iterator> Drop for Splice<'a, I> {\n \n         unsafe {\n             if self.drain.tail_len == 0 {\n-                let vec = &mut *self.drain.vec.as_mut_ptr();\n-                vec.extend(self.replace_with.by_ref());\n+                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n                 return\n             }\n \n@@ -2498,7 +2498,7 @@ impl<'a, T> Drain<'a, T> {\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n     /// Return whether we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n     unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n-        let vec = &mut *self.vec.as_mut_ptr();\n+        let vec = self.vec.as_mut();\n         let range_start = vec.len;\n         let range_end = self.tail_start;\n         let range_slice = slice::from_raw_parts_mut(\n@@ -2518,7 +2518,7 @@ impl<'a, T> Drain<'a, T> {\n \n     /// Make room for inserting more elements before the tail.\n     unsafe fn move_tail(&mut self, extra_capacity: usize) {\n-        let vec = &mut *self.vec.as_mut_ptr();\n+        let vec = self.vec.as_mut();\n         let used_capacity = self.tail_start + self.tail_len;\n         vec.buf.reserve(used_capacity, extra_capacity);\n "}, {"sha": "e826c9432b516133663c57c94a5624d7bd41fb0f", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -2160,7 +2160,7 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in self.by_ref() {}\n \n-        let source_deque = unsafe { &mut *self.deque.as_mut_ptr() };\n+        let source_deque = unsafe { self.deque.as_mut() };\n \n         // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n         //"}, {"sha": "7886f90b66e85b64baa56590c174d0ba199fb8f0", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -132,7 +132,6 @@\n //! use std::cell::Cell;\n //! use std::ptr::Shared;\n //! use std::intrinsics::abort;\n-//! use std::intrinsics::assume;\n //!\n //! struct Rc<T: ?Sized> {\n //!     ptr: Shared<RcBox<T>>\n@@ -171,8 +170,7 @@\n //! impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n //!    fn inner(&self) -> &RcBox<T> {\n //!        unsafe {\n-//!            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-//!            &(**self.ptr)\n+//!            self.ptr.as_ref()\n //!        }\n //!    }\n //! }"}, {"sha": "d93085e96dbb2833910a6df764430669bc8a40d1", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -13,7 +13,7 @@\n             reason = \"needs an RFC to flesh out the design\",\n             issue = \"27730\")]\n \n-use ops::{CoerceUnsized, Deref};\n+use ops::CoerceUnsized;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n pub unsafe trait Zeroable {}\n@@ -46,15 +46,10 @@ impl<T: Zeroable> NonZero<T> {\n     pub const unsafe fn new(inner: T) -> NonZero<T> {\n         NonZero(inner)\n     }\n-}\n-\n-impl<T: Zeroable> Deref for NonZero<T> {\n-    type Target = T;\n \n-    #[inline]\n-    fn deref(&self) -> &T {\n-        let NonZero(ref inner) = *self;\n-        inner\n+    /// Gets the inner value.\n+    pub fn get(self) -> T {\n+        self.0\n     }\n }\n "}, {"sha": "515f49d6f0bddc35aa41352a8675e3c8aa819572", "filename": "src/libcore/option.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -66,14 +66,14 @@\n //! not ([`None`]).\n //!\n //! ```\n-//! let optional: Option<Box<i32>> = None;\n-//! check_optional(&optional);\n+//! let optional = None;\n+//! check_optional(optional);\n //!\n-//! let optional: Option<Box<i32>> = Some(Box::new(9000));\n-//! check_optional(&optional);\n+//! let optional = Some(Box::new(9000));\n+//! check_optional(optional);\n //!\n-//! fn check_optional(optional: &Option<Box<i32>>) {\n-//!     match *optional {\n+//! fn check_optional(optional: Option<Box<i32>>) {\n+//!     match optional {\n //!         Some(ref p) => println!(\"has value {}\", p),\n //!         None => println!(\"has no value\"),\n //!     }"}, {"sha": "a60abefc076504027bdc99141b9add789bda7060", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 127, "deletions": 44, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -17,7 +17,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use intrinsics;\n-use ops::{CoerceUnsized, Deref};\n+use ops::CoerceUnsized;\n use fmt;\n use hash;\n use marker::{PhantomData, Unsize};\n@@ -957,13 +957,25 @@ impl<T: ?Sized> PartialOrd for *mut T {\n }\n \n /// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n-/// of this wrapper owns the referent. This in turn implies that the\n-/// `Unique<T>` is `Send`/`Sync` if `T` is `Send`/`Sync`, unlike a raw\n-/// `*mut T` (which conveys no particular ownership semantics).  It\n-/// also implies that the referent of the pointer should not be\n-/// modified without a unique path to the `Unique` reference. Useful\n-/// for building abstractions like `Vec<T>` or `Box<T>`, which\n-/// internally use raw pointers to manage the memory that they own.\n+/// of this wrapper owns the referent. Useful for building abstractions like\n+/// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n+///\n+/// Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n+/// It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n+/// the kind of strong aliasing guarantees an instance of `T` can expect:\n+/// the referent of the pointer should not be modified without a unique path to\n+/// its owning Unique.\n+///\n+/// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n+/// consider using `Shared`, which has weaker semantics.\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n+/// for any type which upholds Unique's aliasing requirements.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n            issue = \"27730\")]\n@@ -991,6 +1003,20 @@ unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n #[unstable(feature = \"unique\", issue = \"27730\")]\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<T: Sized> Unique<T> {\n+    /// Creates a new `Shared` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    pub fn empty() -> Self {\n+        unsafe {\n+            let ptr = mem::align_of::<T>() as *mut T;\n+            Unique::new(ptr)\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"unique\", issue = \"27730\")]\n impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique`.\n@@ -1002,41 +1028,72 @@ impl<T: ?Sized> Unique<T> {\n         Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n \n+    /// Acquires the underlying `*mut` pointer.\n+    pub fn as_ptr(self) -> *mut T {\n+        self.pointer.get() as *mut T\n+    }\n+\n     /// Dereferences the content.\n-    pub unsafe fn get(&self) -> &T {\n-        &**self.pointer\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n     }\n \n     /// Mutably dereferences the content.\n-    pub unsafe fn get_mut(&mut self) -> &mut T {\n-        &mut ***self\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr()`.\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n     }\n }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n-\n-#[unstable(feature = \"unique\", issue= \"27730\")]\n-impl<T:?Sized> Deref for Unique<T> {\n-    type Target = *mut T;\n-\n-    #[inline]\n-    fn deref(&self) -> &*mut T {\n-        unsafe { mem::transmute(&*self.pointer) }\n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: ?Sized> Clone for Unique<T> {\n+    fn clone(&self) -> Self {\n+        *self\n     }\n }\n \n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: ?Sized> Copy for Unique<T> { }\n+\n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+\n #[unstable(feature = \"unique\", issue = \"27730\")]\n-impl<T> fmt::Pointer for Unique<T> {\n+impl<T: ?Sized> fmt::Pointer for Unique<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.pointer, f)\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }\n \n-/// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n+/// A wrapper around a raw `*mut T` that indicates that the possessor\n /// of this wrapper has shared ownership of the referent. Useful for\n-/// building abstractions like `Rc<T>` or `Arc<T>`, which internally\n-/// use raw pointers to manage the memory that they own.\n+/// building abstractions like `Rc<T>`, `Arc<T>`, or doubly-linked lists, which\n+/// internally use aliased raw pointers to manage the memory that they own.\n+///\n+/// This is similar to `Unique`, except that it doesn't make any aliasing\n+/// guarantees, and doesn't derive Send and Sync. Note that unlike `&T`,\n+/// Shared has no special mutability requirements. Shared may mutate data\n+/// aliased by other Shared pointers. More precise rules require Rust to\n+/// develop an actual aliasing model.\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<Shared<T>>` has the same size as `Shared<T>`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `Shared<T>` is covariant over `T`. If this is incorrect\n+/// for your use case, you should include some PhantomData in your type to\n+/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n+/// Usually this won't be necessary; covariance is correct for Rc, Arc, and LinkedList\n+/// because they provide a public API that follows the normal shared XOR mutable\n+/// rules of Rust.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"shared\", reason = \"needs an RFC to flesh out design\",\n            issue = \"27730\")]\n@@ -1060,23 +1117,59 @@ impl<T: ?Sized> !Send for Shared<T> { }\n #[unstable(feature = \"shared\", issue = \"27730\")]\n impl<T: ?Sized> !Sync for Shared<T> { }\n \n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: Sized> Shared<T> {\n+    /// Creates a new `Shared` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    pub fn empty() -> Self {\n+        unsafe {\n+            let ptr = mem::align_of::<T>() as *mut T;\n+            Shared::new(ptr)\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"shared\", issue = \"27730\")]\n impl<T: ?Sized> Shared<T> {\n     /// Creates a new `Shared`.\n     ///\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    pub unsafe fn new(ptr: *const T) -> Self {\n+    pub unsafe fn new(ptr: *mut T) -> Self {\n         Shared { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n-}\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> Shared<T> {\n+    /// Acquires the underlying `*mut` pointer.\n+    pub fn as_ptr(self) -> *mut T {\n+        self.pointer.get() as *mut T\n+    }\n+\n+    /// Dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n+    }\n+\n+    /// Mutably dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr_mut()`.\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n+    }\n+\n     /// Acquires the underlying pointer as a `*mut` pointer.\n+    #[rustc_deprecated(since = \"1.19\", reason = \"renamed to `as_ptr` for ergonomics/consistency\")]\n+    #[unstable(feature = \"shared\", issue = \"27730\")]\n     pub unsafe fn as_mut_ptr(&self) -> *mut T {\n-        **self as _\n+        self.as_ptr()\n     }\n }\n \n@@ -1094,18 +1187,8 @@ impl<T: ?Sized> Copy for Shared<T> { }\n impl<T: ?Sized, U: ?Sized> CoerceUnsized<Shared<U>> for Shared<T> where T: Unsize<U> { }\n \n #[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> Deref for Shared<T> {\n-    type Target = *const T;\n-\n-    #[inline]\n-    fn deref(&self) -> &*const T {\n-        unsafe { mem::transmute(&*self.pointer) }\n-    }\n-}\n-\n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T> fmt::Pointer for Shared<T> {\n+impl<T: ?Sized> fmt::Pointer for Shared<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.pointer, f)\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }"}, {"sha": "588fffda35fca3dc20158d2b48dff128fcd21d2a", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -31,12 +31,12 @@ fn test_match_on_nonzero_option() {\n         NonZero::new(42)\n     });\n     match a {\n-        Some(val) => assert_eq!(*val, 42),\n+        Some(val) => assert_eq!(val.get(), 42),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n \n     match unsafe { Some(NonZero::new(43)) } {\n-        Some(val) => assert_eq!(*val, 43),\n+        Some(val) => assert_eq!(val.get(), 43),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n }"}, {"sha": "e28dc6a6881fde06acd2fc3a3b97269643b0b020", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -166,10 +166,10 @@ fn test_set_memory() {\n \n #[test]\n fn test_unsized_unique() {\n-    let xs: &mut [i32] = &mut [1, 2, 3];\n-    let ptr = unsafe { Unique::new(xs as *mut [i32]) };\n-    let ys = unsafe { &mut **ptr };\n-    let zs: &mut [i32] = &mut [1, 2, 3];\n+    let xs: &[i32] = &[1, 2, 3];\n+    let ptr = unsafe { Unique::new(xs as *const [i32] as *mut [i32]) };\n+    let ys = unsafe { ptr.as_ref() };\n+    let zs: &[i32] = &[1, 2, 3];\n     assert!(ys == zs);\n }\n "}, {"sha": "3619be82829cade3559577dd57a0f9fe71da2d52", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -62,14 +62,14 @@ pub struct Bytes {\n impl Deref for Bytes {\n     type Target = [u8];\n     fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(*self.ptr, self.len) }\n+        unsafe { slice::from_raw_parts(self.ptr.as_ptr(), self.len) }\n     }\n }\n \n impl Drop for Bytes {\n     fn drop(&mut self) {\n         unsafe {\n-            libc::free(*self.ptr as *mut _);\n+            libc::free(self.ptr.as_ptr() as *mut _);\n         }\n     }\n }"}, {"sha": "03562b0cb26a00f49d4eaf18ca3e49608110b0c8", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -1 +1 @@\n-Subproject commit c34a802d1eb037b44c5252078c7270b5472e0f65\n+Subproject commit 03562b0cb26a00f49d4eaf18ca3e49608110b0c8"}, {"sha": "a7e90071ceae87386524cc92450d6f831341dbbf", "filename": "src/libpanic_unwind/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibpanic_unwind%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibpanic_unwind%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwindows.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -12,11 +12,11 @@\n #![allow(dead_code)]\n #![cfg(windows)]\n \n-use libc::{c_long, c_ulong, c_ulonglong, c_void};\n+use libc::{c_long, c_ulong, c_void};\n \n pub type DWORD = c_ulong;\n pub type LONG = c_long;\n-pub type ULONG_PTR = c_ulonglong;\n+pub type ULONG_PTR = usize;\n pub type LPVOID = *mut c_void;\n \n pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;"}, {"sha": "25fc5b7a4f6d9f9c9ff2e9b101205a3dad18a20e", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -51,6 +51,9 @@ pub enum DepNode<D: Clone + Debug> {\n     // in an extern crate.\n     MetaData(D),\n \n+    // Represents some piece of metadata global to its crate.\n+    GlobalMetaData(D, GlobalMetaDataKind),\n+\n     // Represents some artifact that we save to disk. Note that these\n     // do not have a def-id as part of their identifier.\n     WorkProduct(Arc<WorkProductId>),\n@@ -79,8 +82,8 @@ pub enum DepNode<D: Clone + Debug> {\n     MirKeys,\n     LateLintCheck,\n     TransCrateItem(D),\n-    TransInlinedItem(D),\n     TransWriteMetadata,\n+    CrateVariances,\n \n     // Nodes representing bits of computed IR in the tcx. Each shared\n     // table in the tcx (or elsewhere) maps to one of these\n@@ -89,6 +92,8 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n+    ItemVarianceConstraints(D),\n+    ItemVariances(D),\n     IsForeignItem(D),\n     TypeParamPredicates((D, D)),\n     SizedConstraint(D),\n@@ -162,6 +167,7 @@ pub enum DepNode<D: Clone + Debug> {\n     IsMirAvailable(D),\n     ItemAttrs(D),\n     FnArgNames(D),\n+    FileMap(D, Arc<String>),\n }\n \n impl<D: Clone + Debug> DepNode<D> {\n@@ -188,6 +194,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrateItem,\n             AssociatedItems,\n             ItemSignature,\n+            ItemVariances,\n             IsForeignItem,\n             AssociatedItemDefIds,\n             InherentImpls,\n@@ -209,6 +216,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             MirKrate => Some(MirKrate),\n             TypeckBodiesKrate => Some(TypeckBodiesKrate),\n             Coherence => Some(Coherence),\n+            CrateVariances => Some(CrateVariances),\n             Resolve => Some(Resolve),\n             Variance => Some(Variance),\n             PrivacyAccessLevels(k) => Some(PrivacyAccessLevels(k)),\n@@ -237,9 +245,10 @@ impl<D: Clone + Debug> DepNode<D> {\n             RegionMaps(ref d) => op(d).map(RegionMaps),\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n             TransCrateItem(ref d) => op(d).map(TransCrateItem),\n-            TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n+            ItemVariances(ref d) => op(d).map(ItemVariances),\n+            ItemVarianceConstraints(ref d) => op(d).map(ItemVarianceConstraints),\n             IsForeignItem(ref d) => op(d).map(IsForeignItem),\n             TypeParamPredicates((ref item, ref param)) => {\n                 Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))\n@@ -280,6 +289,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             ItemBodyNestedBodies(ref d) => op(d).map(ItemBodyNestedBodies),\n             ConstIsRvaluePromotableToStatic(ref d) => op(d).map(ConstIsRvaluePromotableToStatic),\n             IsMirAvailable(ref d) => op(d).map(IsMirAvailable),\n+            GlobalMetaData(ref d, kind) => op(d).map(|d| GlobalMetaData(d, kind)),\n+            FileMap(ref d, ref file_name) => op(d).map(|d| FileMap(d, file_name.clone())),\n         }\n     }\n }\n@@ -291,3 +302,16 @@ impl<D: Clone + Debug> DepNode<D> {\n /// them even in the absence of a tcx.)\n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct WorkProductId(pub String);\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub enum GlobalMetaDataKind {\n+    Krate,\n+    CrateDeps,\n+    DylibDependencyFormats,\n+    LangItems,\n+    LangItemsMissing,\n+    NativeLibraries,\n+    CodeMap,\n+    Impls,\n+    ExportedSymbols,\n+}"}, {"sha": "822b61df7a489ae7b2c11677b341343a46585fb6", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -18,15 +18,14 @@ mod raii;\n mod safe;\n mod shadow;\n mod thread;\n-mod visit;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::DepNode;\n pub use self::dep_node::WorkProductId;\n+pub use self::dep_node::GlobalMetaDataKind;\n pub use self::graph::DepGraph;\n pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n-pub use self::visit::visit_all_item_likes_in_krate;\n pub use self::raii::DepTask;"}, {"sha": "bf3748659fe07f0e4f4e84e8bb7ccb7782a85eb0", "filename": "src/librustc/dep_graph/visit.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/dfb740f83ca1d6f2056f5cf8de1adbe81b973438/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb740f83ca1d6f2056f5cf8de1adbe81b973438/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=dfb740f83ca1d6f2056f5cf8de1adbe81b973438", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use hir;\n-use hir::def_id::DefId;\n-use hir::itemlikevisit::ItemLikeVisitor;\n-use ty::TyCtxt;\n-\n-use super::dep_node::DepNode;\n-\n-/// Visit all the items in the krate in some order. When visiting a\n-/// particular item, first create a dep-node by calling `dep_node_fn`\n-/// and push that onto the dep-graph stack of tasks, and also create a\n-/// read edge from the corresponding AST node. This is used in\n-/// compiler passes to automatically record the item that they are\n-/// working on.\n-pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                     mut dep_node_fn: F,\n-                                                     visitor: &mut V)\n-    where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'tcx>\n-{\n-    struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n-        tcx: TyCtxt<'visit, 'tcx, 'tcx>,\n-        dep_node_fn: &'visit mut F,\n-        visitor: &'visit mut V,\n-    }\n-\n-    impl<'visit, 'tcx, F, V> ItemLikeVisitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'tcx>\n-    {\n-        fn visit_item(&mut self, i: &'tcx hir::Item) {\n-            let item_def_id = self.tcx.hir.local_def_id(i.id);\n-            let task_id = (self.dep_node_fn)(item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n-            debug!(\"Started task {:?}\", task_id);\n-            self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n-            self.visitor.visit_item(i);\n-            debug!(\"Ended task {:?}\", task_id);\n-        }\n-\n-        fn visit_trait_item(&mut self, i: &'tcx hir::TraitItem) {\n-            let trait_item_def_id = self.tcx.hir.local_def_id(i.id);\n-            let task_id = (self.dep_node_fn)(trait_item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n-            debug!(\"Started task {:?}\", task_id);\n-            self.tcx.dep_graph.read(DepNode::Hir(trait_item_def_id));\n-            self.visitor.visit_trait_item(i);\n-            debug!(\"Ended task {:?}\", task_id);\n-        }\n-\n-        fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n-            let impl_item_def_id = self.tcx.hir.local_def_id(i.id);\n-            let task_id = (self.dep_node_fn)(impl_item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n-            debug!(\"Started task {:?}\", task_id);\n-            self.tcx.dep_graph.read(DepNode::Hir(impl_item_def_id));\n-            self.visitor.visit_impl_item(i);\n-            debug!(\"Ended task {:?}\", task_id);\n-        }\n-    }\n-\n-    let krate = tcx.dep_graph.with_ignore(|| tcx.hir.krate());\n-    let mut tracking_visitor = TrackingVisitor {\n-        tcx: tcx,\n-        dep_node_fn: &mut dep_node_fn,\n-        visitor: visitor,\n-    };\n-    krate.visit_all_item_likes(&mut tracking_visitor)\n-}\n-"}, {"sha": "f553c03d09bd680e683243f3bc57a1171640dd22", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -43,7 +43,7 @@ impl<'a> CheckAttrVisitor<'a> {\n     fn check_inline(&self, attr: &ast::Attribute, target: Target) {\n         if target != Target::Fn {\n             struct_span_err!(self.sess, attr.span, E0518, \"attribute should be applied to function\")\n-                .span_label(attr.span, &format!(\"requires a function\"))\n+                .span_label(attr.span, \"requires a function\")\n                 .emit();\n         }\n     }\n@@ -123,7 +123,7 @@ impl<'a> CheckAttrVisitor<'a> {\n                 _ => continue,\n             };\n             struct_span_err!(self.sess, attr.span, E0517, \"{}\", message)\n-                .span_label(attr.span, &format!(\"requires {}\", label))\n+                .span_label(attr.span, format!(\"requires {}\", label))\n                 .emit();\n         }\n         if conflicting_reprs > 1 {"}, {"sha": "47604b961ae4ac04f505fe9b013d504575cfaee6", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -36,7 +36,10 @@ pub const LOCAL_CRATE: CrateNum = CrateNum(0);\n \n /// Virtual crate for builtin macros\n // FIXME(jseyfried): this is also used for custom derives until proc-macro crates get `CrateNum`s.\n-pub const BUILTIN_MACROS_CRATE: CrateNum = CrateNum(!0);\n+pub const BUILTIN_MACROS_CRATE: CrateNum = CrateNum(u32::MAX);\n+\n+/// A CrateNum value that indicates that something is wrong.\n+pub const INVALID_CRATE: CrateNum = CrateNum(u32::MAX - 1);\n \n impl CrateNum {\n     pub fn new(x: usize) -> CrateNum {"}, {"sha": "836d9775a3f69b7f5292897801ec0eb30b85310d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -88,7 +88,7 @@ pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n     /// that are inside of an item-like.\n     ///\n     /// **This is the most common choice.** A very commmon pattern is\n-    /// to use `tcx.visit_all_item_likes_in_krate()` as an outer loop,\n+    /// to use `visit_all_item_likes()` as an outer loop,\n     /// and to have the visitor that visits the contents of each item\n     /// using this setting.\n     OnlyBodies(&'this Map<'tcx>),\n@@ -140,23 +140,6 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n pub trait Visitor<'v> : Sized {\n-    /// Invokes the suitable visitor method for the given `Node`\n-    /// extracted from the hir map.\n-    fn visit_hir_map_node(&mut self, node: map::Node<'v>) {\n-        match node {\n-            map::NodeItem(a) => self.visit_item(a),\n-            map::NodeForeignItem(a) => self.visit_foreign_item(a),\n-            map::NodeTraitItem(a) => self.visit_trait_item(a),\n-            map::NodeImplItem(a) => self.visit_impl_item(a),\n-            map::NodeExpr(a) => self.visit_expr(a),\n-            map::NodeStmt(a) => self.visit_stmt(a),\n-            map::NodeTy(a) => self.visit_ty(a),\n-            map::NodePat(a) => self.visit_pat(a),\n-            map::NodeBlock(a) => self.visit_block(a),\n-            _ => bug!(\"Visitor::visit_hir_map_node() not yet impl for node `{:?}`\", node)\n-        }\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // Nested items.\n "}, {"sha": "ce1a34faf5ee8a850df8e9ec91ce463009c1c9ad", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -19,9 +19,8 @@ use super::intravisit::Visitor;\n ///\n /// 1. **Shallow visit**: Get a simple callback for every item (or item-like thing) in the HIR.\n ///    - Example: find all items with a `#[foo]` attribute on them.\n-///    - How: Implement `ItemLikeVisitor` and call `tcx.visit_all_item_likes_in_krate()`.\n+///    - How: Implement `ItemLikeVisitor` and call `tcx.hir.krate().visit_all_item_likes()`.\n ///    - Pro: Efficient; just walks the lists of item-like things, not the nodes themselves.\n-///    - Pro: Integrates well into dependency tracking.\n ///    - Con: Don't get information about nesting\n ///    - Con: Don't have methods for specific bits of HIR, like \"on\n ///      every expr, do this\".\n@@ -30,7 +29,7 @@ use super::intravisit::Visitor;\n ///    within one another.\n ///    - Example: Examine each expression to look for its type and do some check or other.\n ///    - How: Implement `intravisit::Visitor` and use\n-///      `tcx.visit_all_item_likes_in_krate(visitor.as_deep_visitor())`. Within\n+///      `tcx.hir.krate().visit_all_item_likes(visitor.as_deep_visitor())`. Within\n ///      your `intravisit::Visitor` impl, implement methods like\n ///      `visit_expr()`; don't forget to invoke\n ///      `intravisit::walk_visit_expr()` to keep walking the subparts."}, {"sha": "c715484a934df37afc1ed353c9cc0fd73cbff14b", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -442,27 +442,36 @@ impl<'hir> Map<'hir> {\n         self.local_def_id(self.body_owner(id))\n     }\n \n-    /// Given a body owner's id, returns the `BodyId` associated with it.\n-    pub fn body_owned_by(&self, id: NodeId) -> BodyId {\n+    /// Given a node id, returns the `BodyId` associated with it,\n+    /// if the node is a body owner, otherwise returns `None`.\n+    pub fn maybe_body_owned_by(&self, id: NodeId) -> Option<BodyId> {\n         if let Some(entry) = self.find_entry(id) {\n             if let Some(body_id) = entry.associated_body() {\n                 // For item-like things and closures, the associated\n                 // body has its own distinct id, and that is returned\n                 // by `associated_body`.\n-                body_id\n+                Some(body_id)\n             } else {\n                 // For some expressions, the expression is its own body.\n                 if let EntryExpr(_, expr) = entry {\n-                    BodyId { node_id: expr.id }\n+                    Some(BodyId { node_id: expr.id })\n                 } else {\n-                    span_bug!(self.span(id), \"id `{}` has no associated body: {:?}\", id, entry);\n+                    None\n                 }\n             }\n         } else {\n             bug!(\"no entry for id `{}`\", id)\n         }\n     }\n \n+    /// Given a body owner's id, returns the `BodyId` associated with it.\n+    pub fn body_owned_by(&self, id: NodeId) -> BodyId {\n+        self.maybe_body_owned_by(id).unwrap_or_else(|| {\n+            span_bug!(self.span(id), \"body_owned_by: {} has no associated body\",\n+                      self.node_to_string(id));\n+        })\n+    }\n+\n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n             NodeItem(&Item { node: ItemTrait(..), .. }) => id,"}, {"sha": "a6cfcb710edad6919ec68c2c32008f38c95681d7", "filename": "src/librustc/hir/svh.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fhir%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fsvh.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -66,3 +66,7 @@ impl Decodable for Svh {\n          .map(Svh::new)\n     }\n }\n+\n+impl_stable_hash_for!(struct Svh {\n+    hash\n+});"}, {"sha": "b21c3a2b216000e4072b3e2b11dbcccc637c6345", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -8,10 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ty::TyCtxt;\n+use dep_graph::{DepGraph, DepNode};\n+use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n+use rustc_data_structures::bitvec::BitVector;\n use std::rc::Rc;\n+use std::sync::Arc;\n use syntax::codemap::CodeMap;\n use syntax_pos::{BytePos, FileMap};\n+use ty::TyCtxt;\n \n #[derive(Clone)]\n struct CacheEntry {\n@@ -20,30 +24,37 @@ struct CacheEntry {\n     line_start: BytePos,\n     line_end: BytePos,\n     file: Rc<FileMap>,\n+    file_index: usize,\n }\n \n pub struct CachingCodemapView<'tcx> {\n     codemap: &'tcx CodeMap,\n     line_cache: [CacheEntry; 3],\n     time_stamp: usize,\n+    dep_graph: DepGraph,\n+    dep_tracking_reads: BitVector,\n }\n \n impl<'tcx> CachingCodemapView<'tcx> {\n     pub fn new<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CachingCodemapView<'tcx> {\n         let codemap = tcx.sess.codemap();\n-        let first_file = codemap.files.borrow()[0].clone();\n+        let files = codemap.files_untracked();\n+        let first_file = files[0].clone();\n         let entry = CacheEntry {\n             time_stamp: 0,\n             line_number: 0,\n             line_start: BytePos(0),\n             line_end: BytePos(0),\n             file: first_file,\n+            file_index: 0,\n         };\n \n         CachingCodemapView {\n+            dep_graph: tcx.dep_graph.clone(),\n             codemap: codemap,\n             line_cache: [entry.clone(), entry.clone(), entry.clone()],\n             time_stamp: 0,\n+            dep_tracking_reads: BitVector::new(files.len()),\n         }\n     }\n \n@@ -56,6 +67,10 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         for cache_entry in self.line_cache.iter_mut() {\n             if pos >= cache_entry.line_start && pos < cache_entry.line_end {\n                 cache_entry.time_stamp = self.time_stamp;\n+                if self.dep_tracking_reads.insert(cache_entry.file_index) {\n+                    self.dep_graph.read(dep_node(cache_entry));\n+                }\n+\n                 return Some((cache_entry.file.clone(),\n                              cache_entry.line_number,\n                              pos - cache_entry.line_start));\n@@ -75,14 +90,15 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         // If the entry doesn't point to the correct file, fix it up\n         if pos < cache_entry.file.start_pos || pos >= cache_entry.file.end_pos {\n             let file_valid;\n-            let files = self.codemap.files.borrow();\n+            let files = self.codemap.files_untracked();\n \n             if files.len() > 0 {\n                 let file_index = self.codemap.lookup_filemap_idx(pos);\n                 let file = files[file_index].clone();\n \n                 if pos >= file.start_pos && pos < file.end_pos {\n                     cache_entry.file = file;\n+                    cache_entry.file_index = file_index;\n                     file_valid = true;\n                 } else {\n                     file_valid = false;\n@@ -104,8 +120,21 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         cache_entry.line_end = line_bounds.1;\n         cache_entry.time_stamp = self.time_stamp;\n \n+        if self.dep_tracking_reads.insert(cache_entry.file_index) {\n+            self.dep_graph.read(dep_node(cache_entry));\n+        }\n+\n         return Some((cache_entry.file.clone(),\n                      cache_entry.line_number,\n                      pos - cache_entry.line_start));\n     }\n }\n+\n+fn dep_node(cache_entry: &CacheEntry) -> DepNode<DefId> {\n+    let def_id = DefId {\n+        krate: CrateNum::from_u32(cache_entry.file.crate_of_origin),\n+        index: CRATE_DEF_INDEX,\n+    };\n+    let name = Arc::new(cache_entry.file.name.clone());\n+    DepNode::FileMap(def_id, name)\n+}"}, {"sha": "e95dbdd15c5f0e1a285cc025d58d5ac628c22bd6", "filename": "src/librustc/ich/impls_cstore.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! from rustc::middle::cstore in no particular order.\n+\n+use middle;\n+\n+impl_stable_hash_for!(enum middle::cstore::DepKind {\n+    UnexportedMacrosOnly,\n+    MacrosOnly,\n+    Implicit,\n+    Explicit\n+});\n+\n+impl_stable_hash_for!(enum middle::cstore::NativeLibraryKind {\n+    NativeStatic,\n+    NativeStaticNobundle,\n+    NativeFramework,\n+    NativeUnknown\n+});\n+\n+impl_stable_hash_for!(struct middle::cstore::NativeLibrary {\n+    kind,\n+    name,\n+    cfg,\n+    foreign_items\n+});\n+\n+impl_stable_hash_for!(enum middle::cstore::LinkagePreference {\n+    RequireDynamic,\n+    RequireStatic\n+});"}, {"sha": "abc51601b6ecef814c2ea2e95da8e37739367521", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -1120,3 +1120,11 @@ impl_stable_hash_for!(struct hir::def::Export {\n     def,\n     span\n });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::lang_items::LangItem {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        ::std::hash::Hash::hash(self, hasher);\n+    }\n+}"}, {"sha": "7138db01339f6a89489a6204526c24fb26c96b87", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -19,7 +19,9 @@ use std::mem;\n use syntax::ast;\n use syntax::parse::token;\n use syntax::tokenstream;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, FileMap};\n+\n+use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n@@ -299,3 +301,79 @@ fn hash_token<'a, 'tcx, W: StableHasherResult>(token: &token::Token,\n         token::Token::Shebang(val) => val.hash_stable(hcx, hasher),\n     }\n }\n+\n+impl_stable_hash_for_spanned!(::syntax::ast::NestedMetaItemKind);\n+\n+impl_stable_hash_for!(enum ::syntax::ast::NestedMetaItemKind {\n+    MetaItem(meta_item),\n+    Literal(lit)\n+});\n+\n+impl_stable_hash_for!(struct ::syntax::ast::MetaItem {\n+    name,\n+    node,\n+    span\n+});\n+\n+impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n+    Word,\n+    List(nested_items),\n+    NameValue(lit)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for FileMap {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let FileMap {\n+            ref name,\n+            name_was_remapped,\n+            crate_of_origin,\n+            // Do not hash the source as it is not encoded\n+            src: _,\n+            start_pos,\n+            end_pos: _,\n+            ref lines,\n+            ref multibyte_chars,\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+        name_was_remapped.hash_stable(hcx, hasher);\n+\n+        DefId {\n+            krate: CrateNum::from_u32(crate_of_origin),\n+            index: CRATE_DEF_INDEX,\n+        }.hash_stable(hcx, hasher);\n+\n+        // We only hash the relative position within this filemap\n+        let lines = lines.borrow();\n+        lines.len().hash_stable(hcx, hasher);\n+        for &line in lines.iter() {\n+            stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n+        }\n+\n+        // We only hash the relative position within this filemap\n+        let multibyte_chars = multibyte_chars.borrow();\n+        multibyte_chars.len().hash_stable(hcx, hasher);\n+        for &char_pos in multibyte_chars.iter() {\n+            stable_multibyte_char(char_pos, start_pos).hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+fn stable_byte_pos(pos: ::syntax_pos::BytePos,\n+                   filemap_start: ::syntax_pos::BytePos)\n+                   -> u32 {\n+    pos.0 - filemap_start.0\n+}\n+\n+fn stable_multibyte_char(mbc: ::syntax_pos::MultiByteChar,\n+                         filemap_start: ::syntax_pos::BytePos)\n+                         -> (u32, u32) {\n+    let ::syntax_pos::MultiByteChar {\n+        pos,\n+        bytes,\n+    } = mbc;\n+\n+    (pos.0 - filemap_start.0, bytes as u32)\n+}"}, {"sha": "d881a1cc45a79a56da6c1a420b278068e6264bfb", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -19,6 +19,7 @@ mod caching_codemap_view;\n mod hcx;\n \n mod impls_const_math;\n+mod impls_cstore;\n mod impls_hir;\n mod impls_mir;\n mod impls_ty;"}, {"sha": "4c27bade0f7215e06cc36936f9b232ca96cc5bb8", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -668,9 +668,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        diag.span_label(span, &terr);\n+        diag.span_label(span, terr.to_string());\n         if let Some((sp, msg)) = secondary_span {\n-            diag.span_label(sp, &msg);\n+            diag.span_label(sp, msg);\n         }\n \n         self.note_error_origin(diag, &cause);"}, {"sha": "6f3e84247f797ddbfdadfd43ffa73d341fbedff7", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -680,12 +680,12 @@ pub trait LintContext<'tcx>: Sized {\n                                                             \"{}({}) overruled by outer forbid({})\",\n                                                             level.as_str(), lint_name,\n                                                             lint_name);\n-                    diag_builder.span_label(span, &format!(\"overruled by previous forbid\"));\n+                    diag_builder.span_label(span, \"overruled by previous forbid\");\n                     match now_source {\n                         LintSource::Default => &mut diag_builder,\n                         LintSource::Node(_, forbid_source_span) => {\n                             diag_builder.span_label(forbid_source_span,\n-                                                    &format!(\"`forbid` level set here\"))\n+                                                    \"`forbid` level set here\")\n                         },\n                         LintSource::CommandLine(_) => {\n                             diag_builder.note(\"`forbid` lint level was set on command line\")"}, {"sha": "3bbaf5c9299f8945e301378c874a15cd57473c52", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n     {\n         match self.description() {\n             ConstEvalErrDescription::Simple(message) => {\n-                diag.span_label(self.span, &message);\n+                diag.span_label(self.span, message);\n             }\n         }\n "}, {"sha": "da899a9130c8bb1e1fee34dbbaa26e51b59c4e89", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -23,6 +23,7 @@\n // probably get a better home if someone can find one.\n \n use hir::def;\n+use dep_graph::DepNode;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n@@ -161,7 +162,16 @@ pub struct ExternCrate {\n \n pub struct EncodedMetadata {\n     pub raw_data: Vec<u8>,\n-    pub hashes: Vec<EncodedMetadataHash>,\n+    pub hashes: EncodedMetadataHashes,\n+}\n+\n+impl EncodedMetadata {\n+    pub fn new() -> EncodedMetadata {\n+        EncodedMetadata {\n+            raw_data: Vec::new(),\n+            hashes: EncodedMetadataHashes::new(),\n+        }\n+    }\n }\n \n /// The hash for some metadata that (when saving) will be exported\n@@ -173,6 +183,24 @@ pub struct EncodedMetadataHash {\n     pub hash: ich::Fingerprint,\n }\n \n+/// The hash for some metadata that (when saving) will be exported\n+/// from this crate, or which (when importing) was exported by an\n+/// upstream crate.\n+#[derive(Debug, RustcEncodable, RustcDecodable, Clone)]\n+pub struct EncodedMetadataHashes {\n+    pub entry_hashes: Vec<EncodedMetadataHash>,\n+    pub global_hashes: Vec<(DepNode<()>, ich::Fingerprint)>,\n+}\n+\n+impl EncodedMetadataHashes {\n+    pub fn new() -> EncodedMetadataHashes {\n+        EncodedMetadataHashes {\n+            entry_hashes: Vec::new(),\n+            global_hashes: Vec::new(),\n+        }\n+    }\n+}\n+\n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n pub trait CrateStore {"}, {"sha": "5360a86560d399235a660c877c47090fea23bf3f", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n                     struct_span_err!(\n                         self.tcx.sess, span, E0133,\n                         \"{} requires unsafe function or block\", description)\n-                        .span_label(span, &description)\n+                        .span_label(span, description)\n                         .emit();\n                 }\n             }"}, {"sha": "24748b6cf65b8aab05159071a883fcd4821885b4", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -128,8 +128,8 @@ fn find_item(item: &Item, ctxt: &mut EntryContext, at_root: bool) {\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0137,\n                           \"multiple functions with a #[main] attribute\")\n-                .span_label(item.span, &format!(\"additional #[main] function\"))\n-                .span_label(ctxt.attr_main_fn.unwrap().1, &format!(\"first #[main] function\"))\n+                .span_label(item.span, \"additional #[main] function\")\n+                .span_label(ctxt.attr_main_fn.unwrap().1, \"first #[main] function\")\n                 .emit();\n             }\n         },\n@@ -141,8 +141,8 @@ fn find_item(item: &Item, ctxt: &mut EntryContext, at_root: bool) {\n                     ctxt.session, item.span, E0138,\n                     \"multiple 'start' functions\")\n                     .span_label(ctxt.start_fn.unwrap().1,\n-                                &format!(\"previous `start` function here\"))\n-                    .span_label(item.span, &format!(\"multiple `start` functions\"))\n+                                \"previous `start` function here\")\n+                    .span_label(item.span, \"multiple `start` functions\")\n                     .emit();\n             }\n         },"}, {"sha": "a759a9061f8428874475d8a2f61be1e8426d6057", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n                     struct_span_err!(self.infcx.tcx.sess, span, E0591,\n                                      \"`{}` is zero-sized and can't be transmuted to `{}`\",\n                                      from, to)\n-                        .span_note(span, &format!(\"cast with `as` to a pointer instead\"))\n+                        .span_note(span, \"cast with `as` to a pointer instead\")\n                         .emit();\n                     return;\n                 }\n@@ -126,7 +126,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n                   from, skeleton_string(from, sk_from),\n                   to, skeleton_string(to, sk_to))\n             .span_label(span,\n-                &format!(\"transmuting between {} and {}\",\n+                format!(\"transmuting between {} and {}\",\n                     skeleton_string(from, sk_from),\n                     skeleton_string(to, sk_to)))\n             .emit();"}, {"sha": "087ab4b94da3d254f2678bd6011748de0b197106", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 65, "deletions": 95, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -24,14 +24,16 @@ use std::mem;\n use std::rc::Rc;\n use serialize;\n use syntax::codemap;\n-use syntax::ast::{self, NodeId};\n+use syntax::ast;\n use syntax_pos::Span;\n use ty::TyCtxt;\n use ty::maps::Providers;\n \n-use hir; use hir::def_id::DefId;\n-use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n-use hir::{Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n+use hir;\n+use hir::def_id::DefId;\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n+use mir::transform::MirSource;\n \n pub type CodeExtent<'tcx> = &'tcx CodeExtentData;\n \n@@ -811,7 +813,17 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n         }\n     }\n \n-    intravisit::walk_expr(visitor, expr);\n+    match expr.node {\n+        // Manually recurse over closures, because they are the only\n+        // case of nested bodies that share the parent environment.\n+        hir::ExprClosure(.., body, _) => {\n+            let body = visitor.tcx.hir.body(body);\n+            visitor.visit_body(body);\n+        }\n+\n+        _ => intravisit::walk_expr(visitor, expr)\n+    }\n+\n     visitor.cx = prev_cx;\n }\n \n@@ -1041,74 +1053,6 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     }\n }\n \n-fn resolve_item_like<'a, 'tcx, F>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, walk: F)\n-    where F: FnOnce(&mut RegionResolutionVisitor<'a, 'tcx>)\n-{\n-    // Items create a new outer block scope as far as we're concerned.\n-    let prev_cx = visitor.cx;\n-    let prev_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n-    visitor.cx = Context {\n-        root_id: None,\n-        var_parent: None,\n-        parent: None,\n-    };\n-    walk(visitor);\n-    visitor.cx = prev_cx;\n-    visitor.terminating_scopes = prev_ts;\n-}\n-\n-fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n-                        kind: FnKind<'tcx>,\n-                        decl: &'tcx hir::FnDecl,\n-                        body_id: hir::BodyId,\n-                        sp: Span,\n-                        id: ast::NodeId) {\n-    visitor.cx.parent = Some(visitor.new_code_extent(\n-        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id }));\n-\n-    debug!(\"region::resolve_fn(id={:?}, \\\n-            span={:?}, \\\n-            body.id={:?}, \\\n-            cx.parent={:?})\",\n-           id,\n-           visitor.tcx.sess.codemap().span_to_string(sp),\n-           body_id,\n-           visitor.cx.parent);\n-\n-    let fn_decl_scope = visitor.new_code_extent(\n-        CodeExtentData::ParameterScope { fn_id: id, body_id: body_id.node_id });\n-\n-    if let Some(root_id) = visitor.cx.root_id {\n-        visitor.region_maps.record_fn_parent(body_id.node_id, root_id);\n-    }\n-\n-    let outer_cx = visitor.cx;\n-    let outer_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n-    visitor.terminating_scopes.insert(body_id.node_id);\n-\n-    // The arguments and `self` are parented to the fn.\n-    visitor.cx = Context {\n-        root_id: Some(body_id.node_id),\n-        parent: None,\n-        var_parent: Some(fn_decl_scope),\n-    };\n-\n-    intravisit::walk_fn_decl(visitor, decl);\n-    intravisit::walk_fn_kind(visitor, kind);\n-\n-    // The body of the every fn is a root scope.\n-    visitor.cx = Context {\n-        root_id: Some(body_id.node_id),\n-        parent: Some(fn_decl_scope),\n-        var_parent: Some(fn_decl_scope),\n-    };\n-    visitor.visit_nested_body(body_id);\n-\n-    // Restore context we had at the start.\n-    visitor.cx = outer_cx;\n-    visitor.terminating_scopes = outer_ts;\n-}\n-\n impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n     pub fn intern_code_extent(&mut self,\n                               data: CodeExtentData,\n@@ -1152,29 +1096,57 @@ impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_block(&mut self, b: &'tcx Block) {\n         resolve_block(self, b);\n     }\n \n-    fn visit_item(&mut self, i: &'tcx Item) {\n-        resolve_item_like(self, |this| intravisit::walk_item(this, i));\n-    }\n+    fn visit_body(&mut self, body: &'tcx hir::Body) {\n+        let body_id = body.id();\n+        let owner_id = self.map.body_owner(body_id);\n \n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        resolve_item_like(self, |this| intravisit::walk_impl_item(this, ii));\n-    }\n+        debug!(\"visit_body(id={:?}, span={:?}, body.id={:?}, cx.parent={:?})\",\n+               owner_id,\n+               self.tcx.sess.codemap().span_to_string(body.value.span),\n+               body_id,\n+               self.cx.parent);\n \n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        resolve_item_like(self, |this| intravisit::walk_trait_item(this, ti));\n-    }\n+        let outer_cx = self.cx;\n+        let outer_ts = mem::replace(&mut self.terminating_scopes, NodeSet());\n \n-    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx FnDecl,\n-                b: hir::BodyId, s: Span, n: NodeId) {\n-        resolve_fn(self, fk, fd, b, s, n);\n+        // Only functions have an outer terminating (drop) scope,\n+        // while temporaries in constant initializers are 'static.\n+        if let MirSource::Fn(_) = MirSource::from_node(self.tcx, owner_id) {\n+            self.terminating_scopes.insert(body_id.node_id);\n+        }\n+\n+        if let Some(root_id) = self.cx.root_id {\n+            self.region_maps.record_fn_parent(body_id.node_id, root_id);\n+        }\n+        self.cx.root_id = Some(body_id.node_id);\n+\n+        self.cx.parent = Some(self.new_code_extent(\n+            CodeExtentData::CallSiteScope { fn_id: owner_id, body_id: body_id.node_id }));\n+        self.cx.parent = Some(self.new_code_extent(\n+            CodeExtentData::ParameterScope { fn_id: owner_id, body_id: body_id.node_id }));\n+\n+        // The arguments and `self` are parented to the fn.\n+        self.cx.var_parent = self.cx.parent.take();\n+        for argument in &body.arguments {\n+            self.visit_pat(&argument.pat);\n+        }\n+\n+        // The body of the every fn is a root scope.\n+        self.cx.parent = self.cx.var_parent;\n+        self.visit_expr(&body.value);\n+\n+        // Restore context we had at the start.\n+        self.cx = outer_cx;\n+        self.terminating_scopes = outer_ts;\n     }\n+\n     fn visit_arm(&mut self, a: &'tcx Arm) {\n         resolve_arm(self, a);\n     }\n@@ -1192,21 +1164,18 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n     }\n }\n \n-fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, fn_id: DefId)\n+fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     -> Rc<RegionMaps<'tcx>>\n {\n-    let closure_base_def_id = tcx.closure_base_def_id(fn_id);\n-    if closure_base_def_id != fn_id {\n+    let closure_base_def_id = tcx.closure_base_def_id(def_id);\n+    if closure_base_def_id != def_id {\n         return tcx.region_maps(closure_base_def_id);\n     }\n \n     let mut maps = RegionMaps::new();\n \n-    let fn_node_id = tcx.hir.as_local_node_id(fn_id)\n-                            .expect(\"fn DefId should be for LOCAL_CRATE\");\n-    let node = tcx.hir.get(fn_node_id);\n-\n-    {\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    if let Some(body) = tcx.hir.maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx: tcx,\n             region_maps: &mut maps,\n@@ -1218,7 +1187,8 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, fn_id: DefId)\n             },\n             terminating_scopes: NodeSet(),\n         };\n-        visitor.visit_hir_map_node(node);\n+\n+        visitor.visit_body(tcx.hir.body(body));\n     }\n \n     Rc::new(maps)"}, {"sha": "67b8dfb2d8e0ca5df51ed05ee7b7db783d6df48a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -574,9 +574,9 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n                                         {} name that is already in scope\",\n                                        shadower.kind.desc(), name, orig.kind.desc()))\n     };\n-    err.span_label(orig.span, &\"first declared here\");\n+    err.span_label(orig.span, \"first declared here\");\n     err.span_label(shadower.span,\n-                   &format!(\"lifetime {} already in scope\", name));\n+                   format!(\"lifetime {} already in scope\", name));\n     err.emit();\n }\n \n@@ -919,7 +919,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         } else {\n             struct_span_err!(self.sess, lifetime_ref.span, E0261,\n                 \"use of undeclared lifetime name `{}`\", lifetime_ref.name)\n-                .span_label(lifetime_ref.span, &format!(\"undeclared lifetime\"))\n+                .span_label(lifetime_ref.span, \"undeclared lifetime\")\n                 .emit();\n         }\n     }\n@@ -1328,7 +1328,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         } else {\n             format!(\"expected lifetime parameter\")\n         };\n-        err.span_label(span, &msg);\n+        err.span_label(span, msg);\n \n         if let Some(params) = error {\n             if lifetime_refs.len() == 1 {\n@@ -1438,7 +1438,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     let mut err = struct_span_err!(self.sess, lifetime.span, E0262,\n                                   \"invalid lifetime parameter name: `{}`\", lifetime.name);\n                     err.span_label(lifetime.span,\n-                                   &format!(\"{} is a reserved lifetime name\", lifetime.name));\n+                                   format!(\"{} is a reserved lifetime name\", lifetime.name));\n                     err.emit();\n                 }\n             }\n@@ -1452,9 +1452,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                      \"lifetime name `{}` declared twice in the same scope\",\n                                      lifetime_j.lifetime.name)\n                         .span_label(lifetime_j.lifetime.span,\n-                                    &format!(\"declared twice\"))\n+                                    \"declared twice\")\n                         .span_label(lifetime_i.lifetime.span,\n-                                   &format!(\"previous declaration here\"))\n+                                   \"previous declaration here\")\n                         .emit();\n                 }\n             }"}, {"sha": "75bc940625d82d58b8701606c7557af5443b820c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 16, "deletions": 68, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -1122,14 +1122,6 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n pub enum OptionStability {\n     Stable,\n \n-    // FIXME: historically there were some options which were either `-Z` or\n-    //        required the `-Z unstable-options` flag, which were all intended\n-    //        to be unstable. Unfortunately we didn't actually gate usage of\n-    //        these options on the stable compiler, so we still allow them there\n-    //        today. There are some warnings printed out about this in the\n-    //        driver.\n-    UnstableButNotReally,\n-\n     Unstable,\n }\n \n@@ -1148,17 +1140,9 @@ impl RustcOptGroup {\n         RustcOptGroup { opt_group: g, stability: OptionStability::Stable }\n     }\n \n-    #[allow(dead_code)] // currently we have no \"truly unstable\" options\n     pub fn unstable(g: getopts::OptGroup) -> RustcOptGroup {\n         RustcOptGroup { opt_group: g, stability: OptionStability::Unstable }\n     }\n-\n-    fn unstable_bnr(g: getopts::OptGroup) -> RustcOptGroup {\n-        RustcOptGroup {\n-            opt_group: g,\n-            stability: OptionStability::UnstableButNotReally,\n-        }\n-    }\n }\n \n // The `opt` local module holds wrappers around the `getopts` API that\n@@ -1180,7 +1164,6 @@ mod opt {\n \n     fn stable(g: getopts::OptGroup) -> R { RustcOptGroup::stable(g) }\n     fn unstable(g: getopts::OptGroup) -> R { RustcOptGroup::unstable(g) }\n-    fn unstable_bnr(g: getopts::OptGroup) -> R { RustcOptGroup::unstable_bnr(g) }\n \n     pub fn opt_s(a: S, b: S, c: S, d: S) -> R {\n         stable(getopts::optopt(a, b, c, d))\n@@ -1213,24 +1196,6 @@ mod opt {\n     pub fn flagmulti(a: S, b: S, c: S) -> R {\n         unstable(getopts::optflagmulti(a, b, c))\n     }\n-\n-    // Do not use these functions for any new options added to the compiler, all\n-    // new options should use the `*_u` variants above to be truly unstable.\n-    pub fn opt_ubnr(a: S, b: S, c: S, d: S) -> R {\n-        unstable_bnr(getopts::optopt(a, b, c, d))\n-    }\n-    pub fn multi_ubnr(a: S, b: S, c: S, d: S) -> R {\n-        unstable_bnr(getopts::optmulti(a, b, c, d))\n-    }\n-    pub fn flag_ubnr(a: S, b: S, c: S) -> R {\n-        unstable_bnr(getopts::optflag(a, b, c))\n-    }\n-    pub fn flagopt_ubnr(a: S, b: S, c: S, d: S) -> R {\n-        unstable_bnr(getopts::optflagopt(a, b, c, d))\n-    }\n-    pub fn flagmulti_ubnr(a: S, b: S, c: S) -> R {\n-        unstable_bnr(getopts::optflagmulti(a, b, c))\n-    }\n }\n \n /// Returns the \"short\" subset of the rustc command line options,\n@@ -1296,7 +1261,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n         opt::multi_s(\"\", \"extern\", \"Specify where an external rust library is located\",\n                      \"NAME=PATH\"),\n         opt::opt_s(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n-        opt::multi_ubnr(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n+        opt::multi(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n         opt::opt_s(\"\", \"error-format\",\n                       \"How errors and other messages are produced\",\n                       \"human|json\"),\n@@ -1305,28 +1270,20 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n                                  always = always colorize output;\n                                  never  = never colorize output\", \"auto|always|never\"),\n \n-        opt::flagopt_ubnr(\"\", \"pretty\",\n-                          \"Pretty-print the input instead of compiling;\n-                           valid types are: `normal` (un-annotated source),\n-                           `expanded` (crates expanded), or\n-                           `expanded,identified` (fully parenthesized, AST nodes with IDs).\",\n-                          \"TYPE\"),\n-        opt::flagopt_ubnr(\"\", \"unpretty\",\n-                          \"Present the input source, unstable (and less-pretty) variants;\n-                           valid types are any of the types for `--pretty`, as well as:\n-                           `flowgraph=<nodeid>` (graphviz formatted flowgraph for node),\n-                           `everybody_loops` (all function bodies replaced with `loop {}`),\n-                           `hir` (the HIR), `hir,identified`, or\n-                           `hir,typed` (HIR with types for each node).\",\n-                          \"TYPE\"),\n-\n-        // new options here should **not** use the `_ubnr` functions, all new\n-        // unstable options should use the short variants to indicate that they\n-        // are truly unstable. All `_ubnr` flags are just that way because they\n-        // were so historically.\n-        //\n-        // You may also wish to keep this comment at the bottom of this list to\n-        // ensure that others see it.\n+        opt::flagopt(\"\", \"pretty\",\n+                     \"Pretty-print the input instead of compiling;\n+                      valid types are: `normal` (un-annotated source),\n+                      `expanded` (crates expanded), or\n+                      `expanded,identified` (fully parenthesized, AST nodes with IDs).\",\n+                     \"TYPE\"),\n+        opt::flagopt(\"\", \"unpretty\",\n+                     \"Present the input source, unstable (and less-pretty) variants;\n+                      valid types are any of the types for `--pretty`, as well as:\n+                      `flowgraph=<nodeid>` (graphviz formatted flowgraph for node),\n+                      `everybody_loops` (all function bodies replaced with `loop {}`),\n+                      `hir` (the HIR), `hir,identified`, or\n+                      `hir,typed` (HIR with types for each node).\",\n+                     \"TYPE\"),\n     ]);\n     opts\n }\n@@ -1704,7 +1661,7 @@ pub mod nightly_options {\n     use getopts;\n     use syntax::feature_gate::UnstableFeatures;\n     use super::{ErrorOutputType, OptionStability, RustcOptGroup};\n-    use session::{early_error, early_warn};\n+    use session::early_error;\n \n     pub fn is_unstable_enabled(matches: &getopts::Matches) -> bool {\n         is_nightly_build() && matches.opt_strs(\"Z\").iter().any(|x| *x == \"unstable-options\")\n@@ -1746,15 +1703,6 @@ pub mod nightly_options {\n                                        nightly compiler\", opt_name);\n                     early_error(ErrorOutputType::default(), &msg);\n                 }\n-                OptionStability::UnstableButNotReally => {\n-                    let msg = format!(\"the option `{}` is unstable and should \\\n-                                       only be used on the nightly compiler, but \\\n-                                       it is currently accepted for backwards \\\n-                                       compatibility; this will soon change, \\\n-                                       see issue #31847 for more details\",\n-                                      opt_name);\n-                    early_warn(ErrorOutputType::default(), &msg);\n-                }\n                 OptionStability::Stable => {}\n             }\n         }"}, {"sha": "2e2d5a6bd4d387e8f2cf32208270cd2f63b24876", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -11,8 +11,8 @@\n pub use self::code_stats::{CodeStats, DataTypeKind, FieldInfo};\n pub use self::code_stats::{SizeKind, TypeSizeInfo, VariantInfo};\n \n-use dep_graph::DepGraph;\n-use hir::def_id::{CrateNum, DefIndex};\n+use dep_graph::{DepGraph, DepNode};\n+use hir::def_id::{DefId, CrateNum, DefIndex, CRATE_DEF_INDEX};\n use lint;\n use middle::cstore::CrateStore;\n use middle::dependency_format;\n@@ -32,7 +32,7 @@ use syntax::parse::ParseSess;\n use syntax::symbol::Symbol;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n-use syntax_pos::{Span, MultiSpan};\n+use syntax_pos::{Span, MultiSpan, FileMap};\n \n use rustc_back::{LinkerFlavor, PanicStrategy};\n use rustc_back::target::Target;\n@@ -48,6 +48,7 @@ use std::io::Write;\n use std::rc::Rc;\n use std::fmt;\n use std::time::Duration;\n+use std::sync::Arc;\n use libc::c_int;\n \n mod code_stats;\n@@ -627,6 +628,22 @@ pub fn build_session_(sopts: config::Options,\n         }\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n+\n+    // Hook up the codemap with a callback that allows it to register FileMap\n+    // accesses with the dependency graph.\n+    let cm_depgraph = dep_graph.clone();\n+    let codemap_dep_tracking_callback = Box::new(move |filemap: &FileMap| {\n+        let def_id = DefId {\n+            krate: CrateNum::from_u32(filemap.crate_of_origin),\n+            index: CRATE_DEF_INDEX,\n+        };\n+        let name = Arc::new(filemap.name.clone());\n+        let dep_node = DepNode::FileMap(def_id, name);\n+\n+        cm_depgraph.read(dep_node);\n+    });\n+    codemap.set_dep_tracking_callback(codemap_dep_tracking_callback);\n+\n     let p_s = parse::ParseSess::with_span_handler(span_diagnostic, codemap);\n     let default_sysroot = match sopts.maybe_sysroot {\n         Some(_) => None,"}, {"sha": "152e3353994b3b32315d8591d4e482f2792b461d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -484,12 +484,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some(trait_item_span) = self.tcx.hir.span_if_local(trait_item_def_id) {\n             let span = self.tcx.sess.codemap().def_span(trait_item_span);\n-            err.span_label(span, &format!(\"definition of `{}` from trait\", item_name));\n+            err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n         }\n \n         err.span_label(\n             error_span,\n-            &format!(\"impl has extra requirement {}\", requirement));\n+            format!(\"impl has extra requirement {}\", requirement));\n \n         if let Some(node_id) = lint_id {\n             self.tcx.sess.add_lint_diagnostic(EXTRA_REQUIREMENT_IN_IMPL,\n@@ -582,7 +582,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         }\n \n                         err.span_label(span,\n-                                       &format!(\"{}the trait `{}` is not implemented for `{}`\",\n+                                       format!(\"{}the trait `{}` is not implemented for `{}`\",\n                                                 pre_message,\n                                                 trait_ref,\n                                                 trait_ref.self_ty()));\n@@ -738,11 +738,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             expected_ref,\n             found_ref);\n \n-        err.span_label(span, &format!(\"{}\", type_error));\n+        err.span_label(span, format!(\"{}\", type_error));\n \n         if let Some(sp) = found_span {\n-            err.span_label(span, &format!(\"requires `{}`\", found_ref));\n-            err.span_label(sp, &format!(\"implements `{}`\", expected_ref));\n+            err.span_label(span, format!(\"requires `{}`\", found_ref));\n+            err.span_label(sp, format!(\"implements `{}`\", expected_ref));\n         }\n \n         err\n@@ -765,12 +765,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             if expected == 1 { \"\" } else { \"s\" },\n             if expected == 1 { \"is\" } else { \"are\" });\n \n-        err.span_label(span, &format!(\"expected {} that takes {} argument{}\",\n+        err.span_label(span, format!(\"expected {} that takes {} argument{}\",\n                                       if is_closure { \"closure\" } else { \"function\" },\n                                       expected,\n                                       if expected == 1 { \"\" } else { \"s\" }));\n         if let Some(span) = found_span {\n-            err.span_label(span, &format!(\"takes {} argument{}\",\n+            err.span_label(span, format!(\"takes {} argument{}\",\n                                           found,\n                                           if found == 1 { \"\" } else { \"s\" }));\n         }\n@@ -789,7 +789,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let mut err = struct_span_err!(self.sess, span, E0072,\n                                        \"recursive type `{}` has infinite size\",\n                                        self.item_path_str(type_def_id));\n-        err.span_label(span, &format!(\"recursive type has infinite size\"));\n+        err.span_label(span, \"recursive type has infinite size\");\n         err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n                            at some point to make `{}` representable\",\n                           self.item_path_str(type_def_id)));\n@@ -808,7 +808,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.sess, span, E0038,\n             \"the trait `{}` cannot be made into an object\",\n             trait_str);\n-        err.span_label(span, &format!(\"the trait `{}` cannot be made into an object\", trait_str));\n+        err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n \n         let mut reported_violations = FxHashSet();\n         for violation in violations {\n@@ -1043,7 +1043,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        \"type annotations needed\");\n \n         for (target_span, label_message) in labels {\n-            err.span_label(target_span, &label_message);\n+            err.span_label(target_span, label_message);\n         }\n \n         err.emit();"}, {"sha": "74aac7b788b26263580a72d2043dcfb098bf090c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -470,9 +470,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub lang_items: middle::lang_items::LanguageItems,\n \n-    /// True if the variance has been computed yet; false otherwise.\n-    pub variance_computed: Cell<bool>,\n-\n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n     pub used_unsafe: RefCell<NodeSet>,\n@@ -482,14 +479,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// about.\n     pub used_mut_nodes: RefCell<NodeSet>,\n \n-    /// The set of external nominal types whose implementations have been read.\n-    /// This is used for lazy resolution of methods.\n-    pub populated_external_types: RefCell<DefIdSet>,\n-\n-    /// The set of external primitive types whose implementations have been read.\n-    /// FIXME(arielb1): why is this separate from populated_external_types?\n-    pub populated_external_primitive_impls: RefCell<DefIdSet>,\n-\n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index<'tcx>>,\n \n@@ -566,9 +555,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// error reporting, and so is lazily initialised and generally\n     /// shouldn't taint the common path (hence the RefCell).\n     pub all_traits: RefCell<Option<Vec<DefId>>>,\n-\n-    /// HIR Ty -> Ty lowering cache.\n-    pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -755,7 +741,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n             named_region_map: named_region_map,\n-            variance_computed: Cell::new(false),\n             trait_map: resolutions.trait_map,\n             export_map: resolutions.export_map,\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n@@ -770,8 +755,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             lang_items: lang_items,\n             used_unsafe: RefCell::new(NodeSet()),\n             used_mut_nodes: RefCell::new(NodeSet()),\n-            populated_external_types: RefCell::new(DefIdSet()),\n-            populated_external_primitive_impls: RefCell::new(DefIdSet()),\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n@@ -786,7 +769,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             derive_macros: RefCell::new(NodeMap()),\n             stability_interner: RefCell::new(FxHashSet()),\n             all_traits: RefCell::new(None),\n-            ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n        }, f)\n     }\n "}, {"sha": "3b5dc2ae164b60f90d8c6dc617c0e66a01126e76", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let mut err =\n                 struct_span_err!(self.sess, span, E0391,\n                                  \"unsupported cyclic reference between types/traits detected\");\n-            err.span_label(span, &format!(\"cyclic reference\"));\n+            err.span_label(span, \"cyclic reference\");\n \n             err.span_note(stack[0].0, &format!(\"the cycle begins when {}...\",\n                                                stack[0].1.describe(self)));\n@@ -267,6 +267,12 @@ impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::crate_variances<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"computing the variances for items in this crate\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n     fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n         format!(\"generating MIR shim for `{}`\",\n@@ -580,18 +586,6 @@ macro_rules! define_map_struct {\n         }\n     };\n \n-    // Detect things with the `pub` modifier\n-    (tcx: $tcx:tt,\n-     input: (([pub $($other_modifiers:tt)*] $attrs:tt $name:tt) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            ready: ([pub] $attrs $name),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n     // No modifiers left? This is a private item.\n     (tcx: $tcx:tt,\n      input: (([] $attrs:tt $name:tt) $($input:tt)*),\n@@ -718,9 +712,13 @@ define_maps! { <'tcx>\n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n     [] is_foreign_item: IsForeignItem(DefId) -> bool,\n \n+    /// Get a map with the variance of every item; use `item_variance`\n+    /// instead.\n+    [] crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n+\n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    [pub] variances_of: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n+    [] variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n     [] associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n@@ -857,3 +855,7 @@ fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n fn mir_keys(_: CrateNum) -> DepNode<DefId> {\n     DepNode::MirKeys\n }\n+\n+fn crate_variances(_: CrateNum) -> DepNode<DefId> {\n+    DepNode::CrateVariances\n+}"}, {"sha": "51cdba56cf10a98c1ab7eeaa65f1beba9ef080bc", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -15,7 +15,7 @@ pub use self::IntVarValue::*;\n pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n \n-use dep_graph::{self, DepNode};\n+use dep_graph::DepNode;\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -55,9 +55,9 @@ use rustc_const_math::ConstInt;\n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n use hir;\n-use hir::itemlikevisit::ItemLikeVisitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n pub use self::sty::{FnSig, PolyFnSig};\n@@ -309,6 +309,27 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n+/// The crate variances map is computed during typeck and contains the\n+/// variance of every item in the local crate. You should not use it\n+/// directly, because to do so will make your pass dependent on the\n+/// HIR of every item in the local crate. Instead, use\n+/// `tcx.variances_of()` to get the variance for a *particular*\n+/// item.\n+pub struct CrateVariancesMap {\n+    /// This relation tracks the dependencies between the variance of\n+    /// various items. In particular, if `a < b`, then the variance of\n+    /// `a` depends on the sources of `b`.\n+    pub dependencies: TransitiveRelation<DefId>,\n+\n+    /// For each item with generics, maps to a vector of the variance\n+    /// of its generics.  If an item has no generics, it will have no\n+    /// entry.\n+    pub variances: FxHashMap<DefId, Rc<Vec<ty::Variance>>>,\n+\n+    /// An empty vector, useful for cloning.\n+    pub empty_variance: Rc<Vec<ty::Variance>>,\n+}\n+\n #[derive(Clone, Copy, Debug, RustcDecodable, RustcEncodable)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n@@ -1217,7 +1238,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n         match tcx.hir.find(id) {\n             Some(hir_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n-                    hir::ImplItemKind::Type(_) | hir::ImplItemKind::Const(..) => {\n+                    hir::ImplItemKind::Type(_) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the impl\n                         let impl_id = tcx.hir.get_parent(id);\n@@ -1226,7 +1247,8 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                                                             impl_def_id,\n                                                             Some(tcx.item_extent(id)))\n                     }\n-                    hir::ImplItemKind::Method(_, ref body) => {\n+                    hir::ImplItemKind::Const(_, body) |\n+                    hir::ImplItemKind::Method(_, body) => {\n                         tcx.construct_parameter_environment(\n                             impl_item.span,\n                             tcx.hir.local_def_id(id),\n@@ -1236,56 +1258,37 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(hir_map::NodeTraitItem(trait_item)) => {\n                 match trait_item.node {\n-                    hir::TraitItemKind::Type(..) | hir::TraitItemKind::Const(..) => {\n-                        // associated types don't have their own entry (for some reason),\n-                        // so for now just grab environment for the trait\n-                        let trait_id = tcx.hir.get_parent(id);\n-                        let trait_def_id = tcx.hir.local_def_id(trait_id);\n+                    hir::TraitItemKind::Type(..) |\n+                    hir::TraitItemKind::Const(_, None) |\n+                    hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_))=> {\n                         tcx.construct_parameter_environment(trait_item.span,\n-                                                            trait_def_id,\n+                                                            tcx.hir.local_def_id(id),\n                                                             Some(tcx.item_extent(id)))\n                     }\n-                    hir::TraitItemKind::Method(_, ref body) => {\n-                        // Use call-site for extent (unless this is a\n-                        // trait method with no default; then fallback\n-                        // to the method id).\n-                        let extent = if let hir::TraitMethod::Provided(body_id) = *body {\n-                            // default impl: use call_site extent as free_id_outlive bound.\n-                            tcx.call_site_extent(id, body_id.node_id)\n-                        } else {\n-                            // no default impl: use item extent as free_id_outlive bound.\n-                            tcx.item_extent(id)\n-                        };\n+                    hir::TraitItemKind::Const(_, Some(body)) |\n+                    hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(body)) => {\n                         tcx.construct_parameter_environment(\n                             trait_item.span,\n                             tcx.hir.local_def_id(id),\n-                            Some(extent))\n+                            Some(tcx.call_site_extent(id, body.node_id)))\n                     }\n                 }\n             }\n             Some(hir_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(.., body_id) => {\n-                        // We assume this is a function.\n-                        let fn_def_id = tcx.hir.local_def_id(id);\n-\n+                    hir::ItemConst(_, body) |\n+                    hir::ItemStatic(.., body) |\n+                    hir::ItemFn(.., body) => {\n                         tcx.construct_parameter_environment(\n                             item.span,\n-                            fn_def_id,\n-                            Some(tcx.call_site_extent(id, body_id.node_id)))\n+                            tcx.hir.local_def_id(id),\n+                            Some(tcx.call_site_extent(id, body.node_id)))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n                     hir::ItemUnion(..) |\n                     hir::ItemTy(..) |\n                     hir::ItemImpl(..) |\n-                    hir::ItemConst(..) |\n-                    hir::ItemStatic(..) => {\n-                        let def_id = tcx.hir.local_def_id(id);\n-                        tcx.construct_parameter_environment(item.span,\n-                                                            def_id,\n-                                                            Some(tcx.item_extent(id)))\n-                    }\n                     hir::ItemTrait(..) => {\n                         let def_id = tcx.hir.local_def_id(id);\n                         tcx.construct_parameter_environment(item.span,\n@@ -2527,14 +2530,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_region(ty::ReScope(self.node_extent(id)))\n     }\n \n-    pub fn visit_all_item_likes_in_krate<V,F>(self,\n-                                              dep_node_fn: F,\n-                                              visitor: &mut V)\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'gcx>\n-    {\n-        dep_graph::visit_all_item_likes_in_krate(self.global_tcx(), dep_node_fn, visitor);\n-    }\n-\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {"}, {"sha": "dfa11b9c71a04c6c038621d4dc63330310fa986b", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -124,14 +124,8 @@ fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n            a_subst,\n            b_subst);\n \n-    let variances;\n-    let opt_variances = if relation.tcx().variance_computed.get() {\n-        variances = relation.tcx().variances_of(item_def_id);\n-        Some(&*variances)\n-    } else {\n-        None\n-    };\n-    relate_substs(relation, opt_variances, a_subst, b_subst)\n+    let opt_variances = relation.tcx().variances_of(item_def_id);\n+    relate_substs(relation, Some(&opt_variances), a_subst, b_subst)\n }\n \n pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,"}, {"sha": "e23003bf772f2d284b33ad59ca63db7d16ddcd9d", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> From<ty::Region<'tcx>> for Kind<'tcx> {\n impl<'tcx> Kind<'tcx> {\n     #[inline]\n     unsafe fn downcast<T>(self, tag: usize) -> Option<&'tcx T> {\n-        let ptr = *self.ptr;\n+        let ptr = self.ptr.get();\n         if ptr & TAG_MASK == tag {\n             Some(&*((ptr & !TAG_MASK) as *const _))\n         } else {\n@@ -102,7 +102,7 @@ impl<'tcx> fmt::Debug for Kind<'tcx> {\n         } else if let Some(r) = self.as_region() {\n             write!(f, \"{:?}\", r)\n         } else {\n-            write!(f, \"<unknwon @ {:p}>\", *self.ptr as *const ())\n+            write!(f, \"<unknown @ {:p}>\", self.ptr.get() as *const ())\n         }\n     }\n }"}, {"sha": "06d09bd350a4c8eab5002311887379924ba4bdfd", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -145,11 +145,11 @@ pub enum CopyImplementationError<'tcx> {\n ///\n /// The ordering of the cases is significant. They are sorted so that cmp::max\n /// will keep the \"more erroneous\" of two values.\n-#[derive(Copy, Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n+#[derive(Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n pub enum Representability {\n     Representable,\n     ContainsRecursive,\n-    SelfRecursive,\n+    SelfRecursive(Vec<Span>),\n }\n \n impl<'tcx> ParameterEnvironment<'tcx> {\n@@ -1006,37 +1006,51 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span)\n+    pub fn is_representable(&'tcx self,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            sp: Span)\n                             -> Representability {\n \n         // Iterate until something non-representable is found\n-        fn find_nonrepresentable<'a, 'tcx, It>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               sp: Span,\n-                                               seen: &mut Vec<Ty<'tcx>>,\n-                                               iter: It)\n-                                               -> Representability\n-        where It: Iterator<Item=Ty<'tcx>> {\n-            iter.fold(Representability::Representable,\n-                      |r, ty| cmp::max(r, is_type_structurally_recursive(tcx, sp, seen, ty)))\n+        fn fold_repr<It: Iterator<Item=Representability>>(iter: It) -> Representability {\n+            iter.fold(Representability::Representable, |r1, r2| {\n+                match (r1, r2) {\n+                    (Representability::SelfRecursive(v1),\n+                     Representability::SelfRecursive(v2)) => {\n+                        Representability::SelfRecursive(v1.iter().map(|s| *s).chain(v2).collect())\n+                    }\n+                    (r1, r2) => cmp::max(r1, r2)\n+                }\n+            })\n         }\n \n         fn are_inner_types_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span,\n                                                seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n                                                -> Representability {\n             match ty.sty {\n                 TyTuple(ref ts, _) => {\n-                    find_nonrepresentable(tcx, sp, seen, ts.iter().cloned())\n+                    // Find non representable\n+                    fold_repr(ts.iter().map(|ty| {\n+                        is_type_structurally_recursive(tcx, sp, seen, ty)\n+                    }))\n                 }\n                 // Fixed-length vectors.\n                 // FIXME(#11924) Behavior undecided for zero-length vectors.\n                 TyArray(ty, _) => {\n                     is_type_structurally_recursive(tcx, sp, seen, ty)\n                 }\n                 TyAdt(def, substs) => {\n-                    find_nonrepresentable(tcx,\n-                                          sp,\n-                                          seen,\n-                                          def.all_fields().map(|f| f.ty(tcx, substs)))\n+                    // Find non representable fields with their spans\n+                    fold_repr(def.all_fields().map(|field| {\n+                        let ty = field.ty(tcx, substs);\n+                        let span = tcx.hir.span_if_local(field.did).unwrap_or(sp);\n+                        match is_type_structurally_recursive(tcx, span, seen, ty) {\n+                            Representability::SelfRecursive(_) => {\n+                                Representability::SelfRecursive(vec![span])\n+                            }\n+                            x => x,\n+                        }\n+                    }))\n                 }\n                 TyClosure(..) => {\n                     // this check is run on type definitions, so we don't expect\n@@ -1075,7 +1089,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                                                     sp: Span,\n                                                     seen: &mut Vec<Ty<'tcx>>,\n                                                     ty: Ty<'tcx>) -> Representability {\n-            debug!(\"is_type_structurally_recursive: {:?}\", ty);\n+            debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n \n             match ty.sty {\n                 TyAdt(def, _) => {\n@@ -1096,7 +1110,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                                 debug!(\"SelfRecursive: {:?} contains {:?}\",\n                                        seen_type,\n                                        ty);\n-                                return Representability::SelfRecursive;\n+                                return Representability::SelfRecursive(vec![sp]);\n                             }\n                         }\n "}, {"sha": "adabbe11f5ecc80cceb5a27fb56adb816003573c", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -469,13 +469,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                                   nl, new_loan_msg);\n                     err.span_label(\n                             old_loan.span,\n-                            &format!(\"first mutable borrow occurs here{}\", old_loan_msg));\n+                            format!(\"first mutable borrow occurs here{}\", old_loan_msg));\n                     err.span_label(\n                             new_loan.span,\n-                            &format!(\"second mutable borrow occurs here{}\", new_loan_msg));\n+                            format!(\"second mutable borrow occurs here{}\", new_loan_msg));\n                     err.span_label(\n                             previous_end_span,\n-                            &format!(\"first borrow ends here\"));\n+                            \"first borrow ends here\");\n                     err\n                 }\n \n@@ -486,13 +486,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                      nl);\n                     err.span_label(\n                             old_loan.span,\n-                            &format!(\"first closure is constructed here\"));\n+                            \"first closure is constructed here\");\n                     err.span_label(\n                             new_loan.span,\n-                            &format!(\"second closure is constructed here\"));\n+                            \"second closure is constructed here\");\n                     err.span_label(\n                             previous_end_span,\n-                            &format!(\"borrow from first closure ends here\"));\n+                            \"borrow from first closure ends here\");\n                     err\n                 }\n \n@@ -503,13 +503,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                                    nl, ol_pronoun, old_loan_msg);\n                     err.span_label(\n                             new_loan.span,\n-                            &format!(\"closure construction occurs here{}\", new_loan_msg));\n+                            format!(\"closure construction occurs here{}\", new_loan_msg));\n                     err.span_label(\n                             old_loan.span,\n-                            &format!(\"borrow occurs here{}\", old_loan_msg));\n+                            format!(\"borrow occurs here{}\", old_loan_msg));\n                     err.span_label(\n                             previous_end_span,\n-                            &format!(\"borrow ends here\"));\n+                            \"borrow ends here\");\n                     err\n                 }\n \n@@ -520,13 +520,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                                    nl, new_loan_msg, new_loan.kind.to_user_str());\n                     err.span_label(\n                             new_loan.span,\n-                            &format!(\"borrow occurs here{}\", new_loan_msg));\n+                            format!(\"borrow occurs here{}\", new_loan_msg));\n                     err.span_label(\n                             old_loan.span,\n-                            &format!(\"closure construction occurs here{}\", old_loan_msg));\n+                            format!(\"closure construction occurs here{}\", old_loan_msg));\n                     err.span_label(\n                             previous_end_span,\n-                            &format!(\"borrow from closure ends here\"));\n+                            \"borrow from closure ends here\");\n                     err\n                 }\n \n@@ -542,17 +542,17 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                                    old_loan_msg);\n                     err.span_label(\n                             new_loan.span,\n-                            &format!(\"{} borrow occurs here{}\",\n+                            format!(\"{} borrow occurs here{}\",\n                                      new_loan.kind.to_user_str(),\n                                      new_loan_msg));\n                     err.span_label(\n                             old_loan.span,\n-                            &format!(\"{} borrow occurs here{}\",\n+                            format!(\"{} borrow occurs here{}\",\n                                      old_loan.kind.to_user_str(),\n                                      old_loan_msg));\n                     err.span_label(\n                             previous_end_span,\n-                            &format!(\"{} borrow ends here\",\n+                            format!(\"{} borrow ends here\",\n                                      old_loan.kind.to_user_str()));\n                     err\n                 }\n@@ -562,7 +562,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 euv::ClosureCapture(span) => {\n                     err.span_label(\n                         span,\n-                        &format!(\"borrow occurs due to use of `{}` in closure\", nl));\n+                        format!(\"borrow occurs due to use of `{}` in closure\", nl));\n                 }\n                 _ => { }\n             }\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 euv::ClosureCapture(span) => {\n                     err.span_label(\n                         span,\n-                        &format!(\"previous borrow occurs due to use of `{}` in closure\",\n+                        format!(\"previous borrow occurs due to use of `{}` in closure\",\n                                  ol));\n                 }\n                 _ => { }\n@@ -633,11 +633,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                  \"cannot use `{}` because it was mutably borrowed\",\n                                  &self.bccx.loan_path_to_string(copy_path))\n                     .span_label(loan_span,\n-                               &format!(\"borrow of `{}` occurs here\",\n+                               format!(\"borrow of `{}` occurs here\",\n                                        &self.bccx.loan_path_to_string(&loan_path))\n                                )\n                     .span_label(span,\n-                               &format!(\"use of borrowed `{}`\",\n+                               format!(\"use of borrowed `{}`\",\n                                         &self.bccx.loan_path_to_string(&loan_path)))\n                     .emit();\n             }\n@@ -662,12 +662,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                          &self.bccx.loan_path_to_string(move_path));\n                         err.span_label(\n                             loan_span,\n-                            &format!(\"borrow of `{}` occurs here\",\n+                            format!(\"borrow of `{}` occurs here\",\n                                     &self.bccx.loan_path_to_string(&loan_path))\n                             );\n                         err.span_label(\n                             span,\n-                            &format!(\"move into closure occurs here\")\n+                            \"move into closure occurs here\"\n                             );\n                         err\n                     }\n@@ -679,12 +679,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                          &self.bccx.loan_path_to_string(move_path));\n                         err.span_label(\n                             loan_span,\n-                            &format!(\"borrow of `{}` occurs here\",\n+                            format!(\"borrow of `{}` occurs here\",\n                                     &self.bccx.loan_path_to_string(&loan_path))\n                             );\n                         err.span_label(\n                             span,\n-                            &format!(\"move out of `{}` occurs here\",\n+                            format!(\"move out of `{}` occurs here\",\n                                 &self.bccx.loan_path_to_string(move_path))\n                             );\n                         err\n@@ -857,10 +857,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                          \"cannot assign to `{}` because it is borrowed\",\n                          self.bccx.loan_path_to_string(loan_path))\n             .span_label(loan.span,\n-                       &format!(\"borrow of `{}` occurs here\",\n+                       format!(\"borrow of `{}` occurs here\",\n                                self.bccx.loan_path_to_string(loan_path)))\n             .span_label(span,\n-                       &format!(\"assignment to borrowed `{}` occurs here\",\n+                       format!(\"assignment to borrowed `{}` occurs here\",\n                                self.bccx.loan_path_to_string(loan_path)))\n             .emit();\n     }"}, {"sha": "1ee6d565d0d7debd0718f06e5382d62f7b3cc776", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -94,7 +94,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &Vec<Move\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n             err.span_label(bccx.tcx.hir.span(upvar_id.var_id),\n-                           &\"captured outer variable\");\n+                           \"captured outer variable\");\n         }\n         err.emit();\n \n@@ -147,7 +147,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              move_from.descriptive_string(bccx.tcx));\n             err.span_label(\n                 move_from.span,\n-                &format!(\"cannot move out of {}\", move_from.descriptive_string(bccx.tcx))\n+                format!(\"cannot move out of {}\", move_from.descriptive_string(bccx.tcx))\n                 );\n             err\n         }\n@@ -160,7 +160,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                                    \"cannot move out of type `{}`, \\\n                                                     a non-copy array\",\n                                                    b.ty);\n-                    err.span_label(move_from.span, &format!(\"cannot move out of here\"));\n+                    err.span_label(move_from.span, \"cannot move out of here\");\n                     err\n                 }\n                 (_, Kind::Pattern) => {\n@@ -177,7 +177,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                                    \"cannot move out of type `{}`, \\\n                                                    which implements the `Drop` trait\",\n                                                    b.ty);\n-                    err.span_label(move_from.span, &format!(\"cannot move out of here\"));\n+                    err.span_label(move_from.span, \"cannot move out of here\");\n                     err\n                 },\n                 _ => {\n@@ -198,12 +198,12 @@ fn note_move_destination(mut err: DiagnosticBuilder,\n     if is_first_note {\n         err.span_label(\n             move_to_span,\n-            &format!(\"hint: to prevent move, use `ref {0}` or `ref mut {0}`\",\n+            format!(\"hint: to prevent move, use `ref {0}` or `ref mut {0}`\",\n                      pat_name));\n         err\n     } else {\n         err.span_label(move_to_span,\n-                      &format!(\"...and here (use `ref {0}` or `ref mut {0}`)\",\n+                      format!(\"...and here (use `ref {0}` or `ref mut {0}`)\",\n                                pat_name));\n         err\n     }"}, {"sha": "ed5e539f245f10fb2280d4821e8bf39f38166796", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -43,7 +43,7 @@ mod indexes {\n                     unsafe { $Index(NonZero::new(idx + 1)) }\n                 }\n                 fn index(self) -> usize {\n-                    *self.0 - 1\n+                    self.0.get() - 1\n                 }\n             }\n "}, {"sha": "7eb73a87532eb9b427878d81eb3d25dfeef358be", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     \"{} of possibly uninitialized variable: `{}`\",\n                     verb,\n                     self.loan_path_to_string(lp))\n-                .span_label(use_span, &format!(\"use of possibly uninitialized `{}`\",\n+                .span_label(use_span, format!(\"use of possibly uninitialized `{}`\",\n                     self.loan_path_to_string(lp)))\n                 .emit();\n                 return;\n@@ -616,12 +616,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         err = if use_span == move_span {\n             err.span_label(\n                 use_span,\n-                &format!(\"value moved{} here in previous iteration of loop\",\n+                format!(\"value moved{} here in previous iteration of loop\",\n                          move_note));\n             err\n         } else {\n-            err.span_label(use_span, &format!(\"value {} here after move\", verb_participle))\n-               .span_label(move_span, &format!(\"value moved{} here\", move_note));\n+            err.span_label(use_span, format!(\"value {} here after move\", verb_participle))\n+               .span_label(move_span, format!(\"value moved{} here\", move_note));\n             err\n         };\n \n@@ -657,9 +657,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             self.tcx.sess, span, E0384,\n             \"re-assignment of immutable variable `{}`\",\n             self.loan_path_to_string(lp));\n-        err.span_label(span, &format!(\"re-assignment of immutable variable\"));\n+        err.span_label(span, \"re-assignment of immutable variable\");\n         if span != assign.span {\n-            err.span_label(assign.span, &format!(\"first assignment to `{}`\",\n+            err.span_label(assign.span, format!(\"first assignment to `{}`\",\n                                               self.loan_path_to_string(lp)));\n         }\n         err.emit();\n@@ -821,7 +821,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess, span, E0389,\n                     \"{} in a `&` reference\", prefix);\n-                err.span_label(span, &\"assignment into an immutable reference\");\n+                err.span_label(span, \"assignment into an immutable reference\");\n                 err\n             }\n         };\n@@ -914,7 +914,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         }\n                         db.span_label(\n                             let_span,\n-                            &format!(\"consider changing this to `mut {}`\", snippet)\n+                            format!(\"consider changing this to `mut {}`\", snippet)\n                         );\n                     }\n                 }\n@@ -927,7 +927,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         if let Ok(snippet) = snippet {\n                             db.span_label(\n                                 let_span,\n-                                &format!(\"consider changing this to `{}`\",\n+                                format!(\"consider changing this to `{}`\",\n                                          snippet.replace(\"ref \", \"ref mut \"))\n                             );\n                         }\n@@ -936,7 +936,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         if let (Some(local_ty), is_implicit_self) = self.local_ty(node_id) {\n                             if let Some(msg) =\n                                  self.suggest_mut_for_immutable(local_ty, is_implicit_self) {\n-                                db.span_label(local_ty.span, &msg);\n+                                db.span_label(local_ty.span, msg);\n                             }\n                         }\n                     }\n@@ -950,7 +950,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 if let hir_map::Node::NodeField(ref field) = self.tcx.hir.get(node_id) {\n                     if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n-                        db.span_label(field.ty.span, &msg);\n+                        db.span_label(field.ty.span, msg);\n                     }\n                 }\n             }\n@@ -975,10 +975,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                           which is owned by the current function\",\n                          cmt_path_or_string)\n             .span_label(capture_span,\n-                       &format!(\"{} is borrowed here\",\n+                       format!(\"{} is borrowed here\",\n                                 cmt_path_or_string))\n             .span_label(err.span,\n-                       &format!(\"may outlive borrowed value {}\",\n+                       format!(\"may outlive borrowed value {}\",\n                                 cmt_path_or_string))\n             .span_suggestion(err.span,\n                              &format!(\"to force the closure to take ownership of {} \\\n@@ -1029,15 +1029,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         match db.span.primary_span() {\n                             Some(primary) => {\n                                 db.span = MultiSpan::from_span(s);\n-                                db.span_label(primary, &format!(\"capture occurs here\"));\n-                                db.span_label(s, &\"does not live long enough\");\n+                                db.span_label(primary, \"capture occurs here\");\n+                                db.span_label(s, \"does not live long enough\");\n                                 true\n                             }\n                             None => false\n                         }\n                     }\n                     _ => {\n-                        db.span_label(error_span, &\"does not live long enough\");\n+                        db.span_label(error_span, \"does not live long enough\");\n                         false\n                     }\n                 };\n@@ -1049,37 +1049,37 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     (Some(s1), Some(s2)) if s1 == s2 => {\n                         if !is_closure {\n                             db.span = MultiSpan::from_span(s1);\n-                            db.span_label(error_span, &value_msg);\n+                            db.span_label(error_span, value_msg);\n                             let msg = match opt_loan_path(&err.cmt) {\n                                 None => value_kind.to_string(),\n                                 Some(lp) => {\n                                     format!(\"`{}`\", self.loan_path_to_string(&lp))\n                                 }\n                             };\n                             db.span_label(s1,\n-                                          &format!(\"{} dropped here while still borrowed\", msg));\n+                                          format!(\"{} dropped here while still borrowed\", msg));\n                         } else {\n-                            db.span_label(s1, &format!(\"{} dropped before borrower\", value_kind));\n+                            db.span_label(s1, format!(\"{} dropped before borrower\", value_kind));\n                         }\n                         db.note(\"values in a scope are dropped in the opposite order \\\n                                 they are created\");\n                     }\n                     (Some(s1), Some(s2)) if !is_closure => {\n                         db.span = MultiSpan::from_span(s2);\n-                        db.span_label(error_span, &value_msg);\n+                        db.span_label(error_span, value_msg);\n                         let msg = match opt_loan_path(&err.cmt) {\n                             None => value_kind.to_string(),\n                             Some(lp) => {\n                                 format!(\"`{}`\", self.loan_path_to_string(&lp))\n                             }\n                         };\n-                        db.span_label(s2, &format!(\"{} dropped here while still borrowed\", msg));\n-                        db.span_label(s1, &format!(\"{} needs to live until here\", value_kind));\n+                        db.span_label(s2, format!(\"{} dropped here while still borrowed\", msg));\n+                        db.span_label(s1, format!(\"{} needs to live until here\", value_kind));\n                     }\n                     _ => {\n                         match sub_span {\n                             Some(s) => {\n-                                db.span_label(s, &format!(\"{} needs to live until here\",\n+                                db.span_label(s, format!(\"{} needs to live until here\",\n                                                           value_kind));\n                             }\n                             None => {\n@@ -1092,7 +1092,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         }\n                         match super_span {\n                             Some(s) => {\n-                                db.span_label(s, &format!(\"{} only lives until here\", value_kind));\n+                                db.span_label(s, format!(\"{} only lives until here\", value_kind));\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n@@ -1162,23 +1162,23 @@ before rustc 1.16, this temporary lived longer - see issue #39283 \\\n             }\n             _ => {\n                 if let Categorization::Deref(..) = err.cmt.cat {\n-                    db.span_label(*error_span, &\"cannot borrow as mutable\");\n+                    db.span_label(*error_span, \"cannot borrow as mutable\");\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n                     let span = self.tcx.hir.span(local_id);\n                     if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n-                            db.span_label(*error_span, &format!(\"cannot reborrow mutably\"));\n-                            db.span_label(*error_span, &format!(\"try removing `&mut` here\"));\n+                            db.span_label(*error_span, \"cannot reborrow mutably\");\n+                            db.span_label(*error_span, \"try removing `&mut` here\");\n                         } else {\n-                            db.span_label(*error_span, &format!(\"cannot borrow mutably\"));\n+                            db.span_label(*error_span, \"cannot borrow mutably\");\n                         }\n                     } else {\n-                        db.span_label(*error_span, &format!(\"cannot borrow mutably\"));\n+                        db.span_label(*error_span, \"cannot borrow mutably\");\n                     }\n                 } else if let Categorization::Interior(ref cmt, _) = err.cmt.cat {\n                     if let mc::MutabilityCategory::McImmutable = cmt.mutbl {\n                         db.span_label(*error_span,\n-                                      &\"cannot mutably borrow immutable field\");\n+                                      \"cannot mutably borrow immutable field\");\n                     }\n                 }\n             }"}, {"sha": "cd31290eb554c0fdce766f290657f32defc79bb6", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 \"refutable pattern in {}: `{}` not covered\",\n                 origin, pattern_string\n             );\n-            diag.span_label(pat.span, &format!(\"pattern `{}` not covered\", pattern_string));\n+            diag.span_label(pat.span, format!(\"pattern `{}` not covered\", pattern_string));\n             diag.emit();\n         });\n     }\n@@ -328,7 +328,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                 let span = first_pat.0.span;\n                                 struct_span_err!(cx.tcx.sess, span, E0162,\n                                                 \"irrefutable if-let pattern\")\n-                                    .span_label(span, &format!(\"irrefutable pattern\"))\n+                                    .span_label(span, \"irrefutable pattern\")\n                                     .emit();\n                                 printed_if_let_err = true;\n                             }\n@@ -355,7 +355,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                 1 => {\n                                     struct_span_err!(cx.tcx.sess, span, E0165,\n                                                      \"irrefutable while-let pattern\")\n-                                        .span_label(span, &format!(\"irrefutable pattern\"))\n+                                        .span_label(span, \"irrefutable pattern\")\n                                         .emit();\n                                 },\n                                 _ => bug!(),\n@@ -369,7 +369,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                             diagnostic.set_span(pat.span);\n                             // if we had a catchall pattern, hint at that\n                             if let Some(catchall) = catchall {\n-                                diagnostic.span_label(pat.span, &\"this is an unreachable pattern\");\n+                                diagnostic.span_label(pat.span, \"this is an unreachable pattern\");\n                                 diagnostic.span_note(catchall, \"this pattern matches any value\");\n                             }\n                             cx.tcx.sess.add_lint_diagnostic(lint::builtin::UNREACHABLE_PATTERNS,\n@@ -426,7 +426,7 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                         \"refutable pattern in `for` loop binding: \\\n                                 `{}` not covered\",\n                                 pattern_string)\n-                        .span_label(sp, &format!(\"pattern `{}` not covered\", pattern_string))\n+                        .span_label(sp, format!(\"pattern `{}` not covered\", pattern_string))\n                         .emit();\n                 },\n                 _ => {\n@@ -453,7 +453,7 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     create_e0004(cx.tcx.sess, sp,\n                                  format!(\"non-exhaustive patterns: {} not covered\",\n                                          joined_patterns))\n-                        .span_label(sp, &label_text)\n+                        .span_label(sp, label_text)\n                         .emit();\n                 },\n             }\n@@ -485,18 +485,18 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n         if sub.map_or(false, |p| p.contains_bindings()) {\n             struct_span_err!(cx.tcx.sess, p.span, E0007,\n                              \"cannot bind by-move with sub-bindings\")\n-                .span_label(p.span, &format!(\"binds an already bound by-move value by moving it\"))\n+                .span_label(p.span, \"binds an already bound by-move value by moving it\")\n                 .emit();\n         } else if has_guard {\n             struct_span_err!(cx.tcx.sess, p.span, E0008,\n                       \"cannot bind by-move into a pattern guard\")\n-                .span_label(p.span, &format!(\"moves value into pattern guard\"))\n+                .span_label(p.span, \"moves value into pattern guard\")\n                 .emit();\n         } else if by_ref_span.is_some() {\n             struct_span_err!(cx.tcx.sess, p.span, E0009,\n                             \"cannot bind by-move and by-ref in the same pattern\")\n-                    .span_label(p.span, &format!(\"by-move pattern here\"))\n-                    .span_label(by_ref_span.unwrap(), &format!(\"both by-ref and by-move used\"))\n+                    .span_label(p.span, \"by-move pattern here\")\n+                    .span_label(by_ref_span.unwrap(), \"both by-ref and by-move used\")\n                     .emit();\n         }\n     };\n@@ -546,7 +546,7 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n             ty::MutBorrow => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0301,\n                           \"cannot mutably borrow in a pattern guard\")\n-                    .span_label(span, &format!(\"borrowed mutably in pattern guard\"))\n+                    .span_label(span, \"borrowed mutably in pattern guard\")\n                     .emit();\n             }\n             ty::ImmBorrow | ty::UniqueImmBorrow => {}\n@@ -557,7 +557,7 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n         match mode {\n             MutateMode::JustWrite | MutateMode::WriteAndRead => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")\n-                    .span_label(span, &format!(\"assignment in pattern guard\"))\n+                    .span_label(span, \"assignment in pattern guard\")\n                     .emit();\n             }\n             MutateMode::Init => {}\n@@ -588,7 +588,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n                 if !self.bindings_allowed {\n                     struct_span_err!(self.cx.tcx.sess, pat.span, E0303,\n                                      \"pattern bindings are not allowed after an `@`\")\n-                        .span_label(pat.span,  &format!(\"not allowed after `@`\"))\n+                        .span_label(pat.span,  \"not allowed after `@`\")\n                         .emit();\n                 }\n "}, {"sha": "078bb801751d0b2bf4bd54d43a2c4f8944888ed1", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -255,7 +255,7 @@ impl<'a, A: Array> Drop for Drain<'a, A> {\n \n         if self.tail_len > 0 {\n             unsafe {\n-                let source_array_vec = &mut *self.array_vec.as_mut_ptr();\n+                let source_array_vec = self.array_vec.as_mut();\n                 // memmove back untouched tail, update to new length\n                 let start = source_array_vec.len();\n                 let tail = self.tail_start;"}, {"sha": "ff1ebb11b72215df9dcc966d327396509249ddfb", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -247,11 +247,11 @@ mod imp {\n     use std::os::windows::raw::HANDLE;\n     use std::path::Path;\n     use std::fs::{File, OpenOptions};\n-    use std::os::raw::{c_ulong, c_ulonglong, c_int};\n+    use std::os::raw::{c_ulong, c_int};\n \n     type DWORD = c_ulong;\n     type BOOL = c_int;\n-    type ULONG_PTR = c_ulonglong;\n+    type ULONG_PTR = usize;\n \n     type LPOVERLAPPED = *mut OVERLAPPED;\n     const LOCKFILE_EXCLUSIVE_LOCK: DWORD = 0x00000002;"}, {"sha": "023c56ca59be8fcfd97e4b9fd31d9e4dcb07401e", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -23,6 +23,6 @@ impl NodeIndex {\n     }\n \n     pub fn get(self) -> usize {\n-        (*self.index - 1) as usize\n+        (self.index.get() - 1) as usize\n     }\n }"}, {"sha": "635b95d861dafec9e88a401952c96f31222ce5f2", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -283,6 +283,16 @@ impl<CTX> HashStable<CTX> for str {\n     }\n }\n \n+\n+impl<CTX> HashStable<CTX> for String {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (&self[..]).hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl<CTX> HashStable<CTX> for bool {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "46463944043bd63c8d2c983246a919df159361c1", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -9,21 +9,23 @@\n // except according to those terms.\n \n use bitvec::BitMatrix;\n-use stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use fx::FxHashMap;\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n+use stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use std::cell::RefCell;\n use std::fmt::Debug;\n+use std::hash::Hash;\n use std::mem;\n \n \n-\n #[derive(Clone)]\n-pub struct TransitiveRelation<T: Debug + PartialEq> {\n-    // List of elements. This is used to map from a T to a usize.  We\n-    // expect domain to be small so just use a linear list versus a\n-    // hashmap or something.\n+pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash + Clone> {\n+    // List of elements. This is used to map from a T to a usize.\n     elements: Vec<T>,\n \n+    // Maps each element to an index.\n+    map: FxHashMap<T, Index>,\n+\n     // List of base edges in the graph. Require to compute transitive\n     // closure.\n     edges: Vec<Edge>,\n@@ -40,19 +42,20 @@ pub struct TransitiveRelation<T: Debug + PartialEq> {\n     closure: RefCell<Option<BitMatrix>>,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n struct Index(usize);\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n struct Edge {\n     source: Index,\n     target: Index,\n }\n \n-impl<T: Debug + PartialEq> TransitiveRelation<T> {\n+impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n     pub fn new() -> TransitiveRelation<T> {\n         TransitiveRelation {\n             elements: vec![],\n+            map: FxHashMap(),\n             edges: vec![],\n             closure: RefCell::new(None),\n         }\n@@ -63,29 +66,35 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n     }\n \n     fn index(&self, a: &T) -> Option<Index> {\n-        self.elements.iter().position(|e| *e == *a).map(Index)\n+        self.map.get(a).cloned()\n     }\n \n     fn add_index(&mut self, a: T) -> Index {\n-        match self.index(&a) {\n-            Some(i) => i,\n-            None => {\n-                self.elements.push(a);\n-\n-                // if we changed the dimensions, clear the cache\n-                *self.closure.borrow_mut() = None;\n-\n-                Index(self.elements.len() - 1)\n-            }\n-        }\n+        let &mut TransitiveRelation {\n+            ref mut elements,\n+            ref closure,\n+            ref mut map,\n+            ..\n+        } = self;\n+\n+        map.entry(a.clone())\n+           .or_insert_with(|| {\n+               elements.push(a);\n+\n+               // if we changed the dimensions, clear the cache\n+               *closure.borrow_mut() = None;\n+\n+               Index(elements.len() - 1)\n+           })\n+           .clone()\n     }\n \n     /// Applies the (partial) function to each edge and returns a new\n     /// relation.  If `f` returns `None` for any end-point, returns\n     /// `None`.\n     pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelation<U>>\n         where F: FnMut(&T) -> Option<U>,\n-              U: Debug + PartialEq,\n+              U: Clone + Debug + Eq + Hash + Clone,\n     {\n         let mut result = TransitiveRelation::new();\n         for edge in &self.edges {\n@@ -125,6 +134,20 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n         }\n     }\n \n+    /// Returns a vector of all things less than `a`.\n+    ///\n+    /// Really this probably ought to be `impl Iterator<Item=&T>`, but\n+    /// I'm too lazy to make that work, and -- given the caching\n+    /// strategy -- it'd be a touch tricky anyhow.\n+    pub fn less_than(&self, a: &T) -> Vec<&T> {\n+        match self.index(a) {\n+            Some(a) => self.with_closure(|closure| {\n+                closure.iter(a.0).map(|i| &self.elements[i]).collect()\n+            }),\n+            None => vec![],\n+        }\n+    }\n+\n     /// Picks what I am referring to as the \"postdominating\"\n     /// upper-bound for `a` and `b`. This is usually the least upper\n     /// bound, but in cases where there is no single least upper\n@@ -335,7 +358,7 @@ fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix) {\n }\n \n impl<T> Encodable for TransitiveRelation<T>\n-    where T: Encodable + Debug + PartialEq\n+    where T: Clone + Encodable + Debug + Eq + Hash + Clone\n {\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_struct(\"TransitiveRelation\", 2, |s| {\n@@ -347,19 +370,23 @@ impl<T> Encodable for TransitiveRelation<T>\n }\n \n impl<T> Decodable for TransitiveRelation<T>\n-    where T: Decodable + Debug + PartialEq\n+    where T: Clone + Decodable + Debug + Eq + Hash + Clone\n {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n         d.read_struct(\"TransitiveRelation\", 2, |d| {\n-            let elements = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n+            let elements: Vec<T> = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n             let edges = d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?;\n-            Ok(TransitiveRelation { elements, edges, closure: RefCell::new(None) })\n+            let map = elements.iter()\n+                              .enumerate()\n+                              .map(|(index, elem)| (elem.clone(), Index(index)))\n+                              .collect();\n+            Ok(TransitiveRelation { elements, edges, map, closure: RefCell::new(None) })\n         })\n     }\n }\n \n impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n-    where T: HashStable<CTX> + PartialEq + Debug\n+    where T: HashStable<CTX> + Eq + Debug + Clone + Hash\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut CTX,\n@@ -369,6 +396,8 @@ impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n         let TransitiveRelation {\n             ref elements,\n             ref edges,\n+            // \"map\" is just a copy of elements vec\n+            map: _,\n             // \"closure\" is just a copy of the data above\n             closure: _\n         } = *self;"}, {"sha": "5f14890665caba8aa963bada709f3a78601d039e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -1155,8 +1155,7 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, crate_name: &str) {\n             // Build a list of files used to compile the output and\n             // write Makefile-compatible dependency rules\n             let files: Vec<String> = sess.codemap()\n-                                         .files\n-                                         .borrow()\n+                                         .files()\n                                          .iter()\n                                          .filter(|fmap| fmap.is_real_file())\n                                          .filter(|fmap| !fmap.is_imported())"}, {"sha": "718f2b515068b3415033e2cf578e2cb39fd135e5", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -27,6 +27,8 @@ const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bm\n                                                  \"ssse3\\0\", \"tbm\\0\", \"lzcnt\\0\", \"popcnt\\0\",\n                                                  \"sse4a\\0\", \"rdrnd\\0\", \"rdseed\\0\", \"fma\\0\"];\n \n+const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\\0\", \"hvx-double\\0\"];\n+\n /// Add `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.).\n ///\n@@ -38,6 +40,7 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n     let whitelist = match &*sess.target.target.arch {\n         \"arm\" => ARM_WHITELIST,\n         \"x86\" | \"x86_64\" => X86_WHITELIST,\n+        \"hexagon\" => HEXAGON_WHITELIST,\n         _ => &[],\n     };\n "}, {"sha": "0822f7134998572349e5c5cecb70fbfcf559bd00", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -114,9 +114,8 @@ impl Diagnostic {\n     /// all, and you just supplied a `Span` to create the diagnostic,\n     /// then the snippet will just include that `Span`, which is\n     /// called the primary span.\n-    pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n-                      -> &mut Self {\n-        self.span.push_span_label(span, format!(\"{}\", label));\n+    pub fn span_label<T: Into<String>>(&mut self, span: Span, label: T) -> &mut Self {\n+        self.span.push_span_label(span, label.into());\n         self\n     }\n "}, {"sha": "a9c2bbeba2aa4ba0486eb4db917c7dcd883be258", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -112,8 +112,10 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// all, and you just supplied a `Span` to create the diagnostic,\n     /// then the snippet will just include that `Span`, which is\n     /// called the primary span.\n-    forward!(pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n-                               -> &mut Self);\n+    pub fn span_label<T: Into<String>>(&mut self, span: Span, label: T) -> &mut Self {\n+        self.diagnostic.span_label(span, label);\n+        self\n+    }\n \n     forward!(pub fn note_expected_found(&mut self,\n                                         label: &fmt::Display,"}, {"sha": "53999eb9138b6f3b5054f8a0884706fd7e74dad6", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -270,8 +270,10 @@ impl EmitterWriter {\n                           line: &Line,\n                           width_offset: usize,\n                           code_offset: usize) -> Vec<(usize, Style)> {\n-        let source_string = file.get_line(line.line_index - 1)\n-            .unwrap_or(\"\");\n+        let source_string = match file.get_line(line.line_index - 1) {\n+            Some(s) => s,\n+            None => return Vec::new(),\n+        };\n \n         let line_offset = buffer.num_lines();\n \n@@ -909,6 +911,11 @@ impl EmitterWriter {\n \n         // Print out the annotate source lines that correspond with the error\n         for annotated_file in annotated_files {\n+            // we can't annotate anything if the source is unavailable.\n+            if annotated_file.file.src.is_none() {\n+                continue;\n+            }\n+\n             // print out the span location and spacer before we print the annotated source\n             // to do this, we need to know if this span will be primary\n             let is_primary = primary_lo.file.name == annotated_file.file.name;"}, {"sha": "db8c9ac306bba718ff4ff9c6a64050289bdda97b", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -388,6 +388,14 @@ impl Handler {\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Note);\n     }\n+    pub fn span_note_diag<'a>(&'a self,\n+                              sp: Span,\n+                              msg: &str)\n+                              -> DiagnosticBuilder<'a> {\n+        let mut db = DiagnosticBuilder::new(self, Note, msg);\n+        db.set_span(sp);\n+        db\n+    }\n     pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n     }"}, {"sha": "39fe2188f68d1f5756015404d19c0b49999e7003", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -51,7 +51,7 @@ use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc::hir;\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::ich::{ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED};\n use graphviz::IntoCow;\n use std::env;\n@@ -80,7 +80,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n                                           if_this_changed: vec![],\n                                           then_this_would_need: vec![] };\n         visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.hir.krate().attrs);\n-        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+        tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n         (visitor.if_this_changed, visitor.then_this_would_need)\n     };\n \n@@ -154,7 +154,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                     None => {\n                         self.tcx.sess.span_fatal(\n                             attr.span,\n-                            &format!(\"missing DepNode variant\"));\n+                            \"missing DepNode variant\");\n                     }\n                 };\n                 self.then_this_would_need.push((attr.span,\n@@ -166,17 +166,29 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.process_attrs(item.id, &item.attrs);\n+        intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         self.process_attrs(trait_item.id, &trait_item.attrs);\n+        intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         self.process_attrs(impl_item.id, &impl_item.attrs);\n+        intravisit::walk_impl_item(self, impl_item);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+        self.process_attrs(s.id, &s.attrs);\n+        intravisit::walk_struct_field(self, s);\n     }\n }\n \n@@ -189,7 +201,7 @@ fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         for &(target_span, _, _, _) in then_this_would_need {\n             tcx.sess.span_err(\n                 target_span,\n-                &format!(\"no #[rustc_if_this_changed] annotation detected\"));\n+                \"no #[rustc_if_this_changed] annotation detected\");\n \n         }\n         return;\n@@ -207,7 +219,7 @@ fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             } else {\n                 tcx.sess.span_err(\n                     target_span,\n-                    &format!(\"OK\"));\n+                    \"OK\");\n             }\n         }\n     }"}, {"sha": "6f5cc1f3f45c87d0384dd439325e4a8453fb4fb0", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -29,9 +29,10 @@\n \n use std::cell::RefCell;\n use std::hash::Hash;\n+use std::sync::Arc;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{LOCAL_CRATE, CRATE_DEF_INDEX, DefId};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ich::{Fingerprint, StableHashingContext};\n use rustc::ty::TyCtxt;\n@@ -60,6 +61,10 @@ impl IncrementalHashesMap {\n         }\n     }\n \n+    pub fn get(&self, k: &DepNode<DefId>) -> Option<&Fingerprint> {\n+        self.hashes.get(k)\n+    }\n+\n     pub fn insert(&mut self, k: DepNode<DefId>, v: Fingerprint) -> Option<Fingerprint> {\n         self.hashes.insert(k, v)\n     }\n@@ -140,14 +145,34 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n             let hcx = &mut self.hcx;\n             let mut item_hashes: Vec<_> =\n                 self.hashes.iter()\n-                           .map(|(item_dep_node, &item_hash)| {\n-                               // convert from a DepNode<DefId> tp a\n-                               // DepNode<u64> where the u64 is the\n-                               // hash of the def-id's def-path:\n-                               let item_dep_node =\n-                                   item_dep_node.map_def(|&did| Some(hcx.def_path_hash(did)))\n-                                                .unwrap();\n-                               (item_dep_node, item_hash)\n+                           .filter_map(|(item_dep_node, &item_hash)| {\n+                                // This `match` determines what kinds of nodes\n+                                // go into the SVH:\n+                                match *item_dep_node {\n+                                    DepNode::Hir(_) |\n+                                    DepNode::HirBody(_) => {\n+                                        // We want to incoporate these into the\n+                                        // SVH.\n+                                    }\n+                                    DepNode::FileMap(..) => {\n+                                        // These don't make a semantic\n+                                        // difference, filter them out.\n+                                        return None\n+                                    }\n+                                    ref other => {\n+                                        bug!(\"Found unexpected DepNode during \\\n+                                              SVH computation: {:?}\",\n+                                             other)\n+                                    }\n+                                }\n+\n+                                // Convert from a DepNode<DefId> to a\n+                                // DepNode<u64> where the u64 is the hash of\n+                                // the def-id's def-path:\n+                                let item_dep_node =\n+                                    item_dep_node.map_def(|&did| Some(hcx.def_path_hash(did)))\n+                                                 .unwrap();\n+                                Some((item_dep_node, item_hash))\n                            })\n                            .collect();\n             item_hashes.sort_unstable(); // avoid artificial dependencies on item ordering\n@@ -229,6 +254,24 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n             visitor.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, macro_def);\n             visitor.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, macro_def);\n         }\n+\n+        for filemap in tcx.sess\n+                          .codemap()\n+                          .files_untracked()\n+                          .iter()\n+                          .filter(|fm| !fm.is_imported()) {\n+            assert_eq!(LOCAL_CRATE.as_u32(), filemap.crate_of_origin);\n+            let def_id = DefId {\n+                krate: LOCAL_CRATE,\n+                index: CRATE_DEF_INDEX,\n+            };\n+            let name = Arc::new(filemap.name.clone());\n+            let dep_node = DepNode::FileMap(def_id, name);\n+            let mut hasher = IchHasher::new();\n+            filemap.hash_stable(&mut visitor.hcx, &mut hasher);\n+            let fingerprint = hasher.finish();\n+            visitor.hashes.insert(dep_node, fingerprint);\n+        }\n     });\n \n     tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);"}, {"sha": "b016ff34bc5c604be24c0b0d4c1557d34bf2a573", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -99,7 +99,11 @@ pub struct SerializedMetadataHashes {\n     /// where `X` refers to some item in this crate. That `X` will be\n     /// a `DefPathIndex` that gets retracted to the current `DefId`\n     /// (matching the one found in this structure).\n-    pub hashes: Vec<EncodedMetadataHash>,\n+    pub entry_hashes: Vec<EncodedMetadataHash>,\n+\n+    /// This map contains fingerprints that are not specific to some DefId but\n+    /// describe something global to the whole crate.\n+    pub global_hashes: Vec<(DepNode<()>, Fingerprint)>,\n \n     /// For each DefIndex (as it occurs in SerializedMetadataHash), this\n     /// map stores the DefPathIndex (as it occurs in DefIdDirectory), so"}, {"sha": "5facfe36efdb93c8b452b186e50b15526f23e1e3", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -383,7 +383,7 @@ fn check_config(tcx: TyCtxt, attr: &Attribute) -> bool {\n \n     tcx.sess.span_fatal(\n         attr.span,\n-        &format!(\"no cfg attribute\"));\n+        \"no cfg attribute\");\n }\n \n fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> ast::Name {"}, {"sha": "5bc442deafa2bd726524e98d6cd7f09f9d214d3d", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 65, "deletions": 17, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir::def_id::{CrateNum, DefId};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::ty::TyCtxt;\n@@ -23,11 +23,15 @@ use super::data::*;\n use super::fs::*;\n use super::file_format;\n \n+use std::hash::Hash;\n+use std::fmt::Debug;\n+\n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     incremental_hashes_map: &'a IncrementalHashesMap,\n     item_metadata_hashes: FxHashMap<DefId, Fingerprint>,\n     crate_hashes: FxHashMap<CrateNum, Svh>,\n+    global_metadata_hashes: FxHashMap<DepNode<DefId>, Fingerprint>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n@@ -39,16 +43,19 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             incremental_hashes_map: incremental_hashes_map,\n             item_metadata_hashes: FxHashMap(),\n             crate_hashes: FxHashMap(),\n+            global_metadata_hashes: FxHashMap(),\n         }\n     }\n \n     pub fn is_hashable(dep_node: &DepNode<DefId>) -> bool {\n         match *dep_node {\n             DepNode::Krate |\n             DepNode::Hir(_) |\n-            DepNode::HirBody(_) =>\n+            DepNode::HirBody(_) |\n+            DepNode::FileMap(..) =>\n                 true,\n-            DepNode::MetaData(def_id) => !def_id.is_local(),\n+            DepNode::MetaData(def_id) |\n+            DepNode::GlobalMetaData(def_id, _) => !def_id.is_local(),\n             _ => false,\n         }\n     }\n@@ -60,7 +67,8 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             }\n \n             // HIR nodes (which always come from our crate) are an input:\n-            DepNode::Hir(def_id) | DepNode::HirBody(def_id) => {\n+            DepNode::Hir(def_id) |\n+            DepNode::HirBody(def_id) => {\n                 assert!(def_id.is_local(),\n                         \"cannot hash HIR for non-local def-id {:?} => {:?}\",\n                         def_id,\n@@ -69,12 +77,30 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n                 Some(self.incremental_hashes_map[dep_node])\n             }\n \n+            DepNode::FileMap(def_id, ref name) => {\n+                if def_id.is_local() {\n+                    Some(self.incremental_hashes_map[dep_node])\n+                } else {\n+                    Some(self.metadata_hash(DepNode::FileMap(def_id, name.clone()),\n+                                            def_id.krate,\n+                                            |this| &mut this.global_metadata_hashes))\n+                }\n+            }\n+\n             // MetaData from other crates is an *input* to us.\n             // MetaData nodes from *our* crates are an *output*; we\n             // don't hash them, but we do compute a hash for them and\n             // save it for others to use.\n             DepNode::MetaData(def_id) if !def_id.is_local() => {\n-                Some(self.metadata_hash(def_id))\n+                Some(self.metadata_hash(def_id,\n+                                        def_id.krate,\n+                                        |this| &mut this.item_metadata_hashes))\n+            }\n+\n+            DepNode::GlobalMetaData(def_id, kind) => {\n+                Some(self.metadata_hash(DepNode::GlobalMetaData(def_id, kind),\n+                                        def_id.krate,\n+                                        |this| &mut this.global_metadata_hashes))\n             }\n \n             _ => {\n@@ -87,33 +113,37 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    fn metadata_hash(&mut self, def_id: DefId) -> Fingerprint {\n-        debug!(\"metadata_hash(def_id={:?})\", def_id);\n+    fn metadata_hash<K, C>(&mut self,\n+                           key: K,\n+                           cnum: CrateNum,\n+                           cache: C)\n+                           -> Fingerprint\n+        where K: Hash + Eq + Debug,\n+              C: Fn(&mut Self) -> &mut FxHashMap<K, Fingerprint>,\n+    {\n+        debug!(\"metadata_hash(key={:?})\", key);\n \n-        assert!(!def_id.is_local());\n+        debug_assert!(cnum != LOCAL_CRATE);\n         loop {\n             // check whether we have a result cached for this def-id\n-            if let Some(&hash) = self.item_metadata_hashes.get(&def_id) {\n-                debug!(\"metadata_hash: def_id={:?} hash={:?}\", def_id, hash);\n+            if let Some(&hash) = cache(self).get(&key) {\n                 return hash;\n             }\n \n             // check whether we did not find detailed metadata for this\n             // krate; in that case, we just use the krate's overall hash\n-            if let Some(&svh) = self.crate_hashes.get(&def_id.krate) {\n-                debug!(\"metadata_hash: def_id={:?} crate_hash={:?}\", def_id, svh);\n-\n+            if let Some(&svh) = self.crate_hashes.get(&cnum) {\n                 // micro-\"optimization\": avoid a cache miss if we ask\n                 // for metadata from this particular def-id again.\n                 let fingerprint = svh_to_fingerprint(svh);\n-                self.item_metadata_hashes.insert(def_id, fingerprint);\n+                cache(self).insert(key, fingerprint);\n \n                 return fingerprint;\n             }\n \n             // otherwise, load the data and repeat.\n-            self.load_data(def_id.krate);\n-            assert!(self.crate_hashes.contains_key(&def_id.krate));\n+            self.load_data(cnum);\n+            assert!(self.crate_hashes.contains_key(&cnum));\n         }\n     }\n \n@@ -191,7 +221,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n \n         let serialized_hashes = SerializedMetadataHashes::decode(&mut decoder)?;\n-        for serialized_hash in serialized_hashes.hashes {\n+        for serialized_hash in serialized_hashes.entry_hashes {\n             // the hashes are stored with just a def-index, which is\n             // always relative to the old crate; convert that to use\n             // our internal crate number\n@@ -202,6 +232,24 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             debug!(\"load_from_data: def_id={:?} hash={}\", def_id, serialized_hash.hash);\n             assert!(old.is_none(), \"already have hash for {:?}\", def_id);\n         }\n+\n+        for (dep_node, fingerprint) in serialized_hashes.global_hashes {\n+            // Here we need to remap the CrateNum in the DepNode.\n+            let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+            let dep_node = match dep_node {\n+                DepNode::GlobalMetaData(_, kind) => DepNode::GlobalMetaData(def_id, kind),\n+                DepNode::FileMap(_, name) => DepNode::FileMap(def_id, name),\n+                other => {\n+                    bug!(\"unexpected DepNode variant: {:?}\", other)\n+                }\n+            };\n+\n+            // record the hash for this dep-node\n+            debug!(\"load_from_data: def_node={:?} hash={}\", dep_node, fingerprint);\n+            let old = self.global_metadata_hashes.insert(dep_node.clone(), fingerprint);\n+            assert!(old.is_none(), \"already have hash for {:?}\", dep_node);\n+        }\n+\n         Ok(())\n     }\n }"}, {"sha": "7fad600d1054294ff769cec9341d5172fa28bf6f", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -240,35 +240,40 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let mut dirty_nodes = FxHashMap();\n \n+    let print_removed_message = |dep_node: &DepNode<_>| {\n+        if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+            println!(\"node {:?} is dirty as it was removed\", dep_node);\n+        }\n+\n+        debug!(\"initial_dirty_nodes: {:?} is dirty as it was removed\", dep_node);\n+    };\n+\n     for hash in serialized_hashes {\n         if let Some(dep_node) = retraced.map(&hash.dep_node) {\n-            let current_hash = hcx.hash(&dep_node).unwrap();\n-            if current_hash == hash.hash {\n-                debug!(\"initial_dirty_nodes: {:?} is clean (hash={:?})\",\n-                   dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n-                   current_hash);\n-                continue;\n-            }\n+            if let Some(current_hash) = hcx.hash(&dep_node) {\n+                if current_hash == hash.hash {\n+                    debug!(\"initial_dirty_nodes: {:?} is clean (hash={:?})\",\n+                       dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n+                       current_hash);\n+                    continue;\n+                }\n \n-            if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n-                println!(\"node {:?} is dirty as hash is {:?} was {:?}\",\n-                         dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n-                         current_hash,\n-                         hash.hash);\n-            }\n+                if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+                    println!(\"node {:?} is dirty as hash is {:?} was {:?}\",\n+                             dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n+                             current_hash,\n+                             hash.hash);\n+                }\n \n-            debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n-                   dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n-                   current_hash,\n-                   hash.hash);\n-        } else {\n-            if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n-                println!(\"node {:?} is dirty as it was removed\",\n-                         hash.dep_node);\n+                debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n+                       dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n+                       current_hash,\n+                       hash.hash);\n+            } else {\n+                print_removed_message(&hash.dep_node);\n             }\n-\n-            debug!(\"initial_dirty_nodes: {:?} is dirty as it was removed\",\n-                   hash.dep_node);\n+        } else {\n+            print_removed_message(&hash.dep_node);\n         }\n \n         dirty_nodes.insert(hash.dep_node.clone(), hash.dep_node.clone());\n@@ -382,8 +387,8 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n \n     debug!(\"load_prev_metadata_hashes() - Mapping DefIds\");\n \n-    assert_eq!(serialized_hashes.index_map.len(), serialized_hashes.hashes.len());\n-    for serialized_hash in serialized_hashes.hashes {\n+    assert_eq!(serialized_hashes.index_map.len(), serialized_hashes.entry_hashes.len());\n+    for serialized_hash in serialized_hashes.entry_hashes {\n         let def_path_index = serialized_hashes.index_map[&serialized_hash.def_index];\n         if let Some(def_id) = retraced.def_id(def_path_index) {\n             let old = output.insert(def_id, serialized_hash.hash);"}, {"sha": "06e49e9d37c8464c82061bd4fb46198b5b8551ba", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -12,7 +12,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n-use rustc::middle::cstore::EncodedMetadataHash;\n+use rustc::middle::cstore::EncodedMetadataHashes;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n@@ -34,7 +34,7 @@ use super::work_product;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 incremental_hashes_map: &IncrementalHashesMap,\n-                                metadata_hashes: &[EncodedMetadataHash],\n+                                metadata_hashes: &EncodedMetadataHashes,\n                                 svh: Svh) {\n     debug!(\"save_dep_graph()\");\n     let _ignore = tcx.dep_graph.in_ignore();\n@@ -240,18 +240,19 @@ pub fn encode_dep_graph(preds: &Predecessors,\n \n pub fn encode_metadata_hashes(tcx: TyCtxt,\n                               svh: Svh,\n-                              metadata_hashes: &[EncodedMetadataHash],\n+                              metadata_hashes: &EncodedMetadataHashes,\n                               builder: &mut DefIdDirectoryBuilder,\n                               current_metadata_hashes: &mut FxHashMap<DefId, Fingerprint>,\n                               encoder: &mut Encoder)\n                               -> io::Result<()> {\n     let mut serialized_hashes = SerializedMetadataHashes {\n-        hashes: metadata_hashes.to_vec(),\n+        entry_hashes: metadata_hashes.entry_hashes.to_vec(),\n+        global_hashes: metadata_hashes.global_hashes.to_vec(),\n         index_map: FxHashMap()\n     };\n \n     if tcx.sess.opts.debugging_opts.query_dep_graph {\n-        for serialized_hash in &serialized_hashes.hashes {\n+        for serialized_hash in &serialized_hashes.entry_hashes {\n             let def_id = DefId::local(serialized_hash.def_index);\n \n             // Store entry in the index_map"}, {"sha": "715a769158bc3fb832b0613d52f996068cb6eda6", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -692,6 +692,82 @@ impl EarlyLintPass for DeprecatedAttr {\n     }\n }\n \n+declare_lint! {\n+    pub ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+    Warn,\n+    \"floating-point literals cannot be used in patterns\"\n+}\n+\n+/// Checks for floating point literals in patterns.\n+#[derive(Clone)]\n+pub struct IllegalFloatLiteralPattern;\n+\n+impl LintPass for IllegalFloatLiteralPattern {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(ILLEGAL_FLOATING_POINT_LITERAL_PATTERN)\n+    }\n+}\n+\n+fn fl_lit_check_expr(cx: &EarlyContext, expr: &ast::Expr) {\n+    use self::ast::{ExprKind, LitKind};\n+    match expr.node {\n+        ExprKind::Lit(ref l) => {\n+            match l.node {\n+                LitKind::FloatUnsuffixed(..) |\n+                LitKind::Float(..) => {\n+                    cx.span_lint(ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+                                 l.span,\n+                                 \"floating-point literals cannot be used in patterns\");\n+                    error!(\"span mc spanspam\");\n+                    },\n+                _ => (),\n+            }\n+        }\n+        // These may occur in patterns\n+        // and can maybe contain float literals\n+        ExprKind::Unary(_, ref f) => fl_lit_check_expr(cx, f),\n+        // These may occur in patterns\n+        // and can't contain float literals\n+        ExprKind::Path(..) => (),\n+        // If something unhandled is encountered, we need to expand the\n+        // search or ignore more ExprKinds.\n+        _ => span_bug!(expr.span, \"Unhandled expression {:?} in float lit pattern lint\",\n+                       expr.node),\n+    }\n+}\n+\n+impl EarlyLintPass for IllegalFloatLiteralPattern {\n+    fn check_pat(&mut self, cx: &EarlyContext, pat: &ast::Pat) {\n+        use self::ast::PatKind;\n+        pat.walk(&mut |p| {\n+            match p.node {\n+                // Wildcard patterns and paths are uninteresting for the lint\n+                PatKind::Wild |\n+                PatKind::Path(..) => (),\n+\n+                // The walk logic recurses inside these\n+                PatKind::Ident(..) |\n+                PatKind::Struct(..) |\n+                PatKind::Tuple(..) |\n+                PatKind::TupleStruct(..) |\n+                PatKind::Ref(..) |\n+                PatKind::Box(..) |\n+                PatKind::Slice(..) => (),\n+\n+                // Extract the expressions and check them\n+                PatKind::Lit(ref e) => fl_lit_check_expr(cx, e),\n+                PatKind::Range(ref st, ref en, _) => {\n+                    fl_lit_check_expr(cx, st);\n+                    fl_lit_check_expr(cx, en);\n+                },\n+\n+                PatKind::Mac(_) => bug!(\"lint must run post-expansion\"),\n+            }\n+            true\n+        });\n+    }\n+}\n+\n declare_lint! {\n     pub UNCONDITIONAL_RECURSION,\n     Warn,"}, {"sha": "53ea3a8333f2d761c8027d1d9295ac87829d7d1d", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -113,6 +113,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                        UnusedParens,\n                        UnusedImportBraces,\n                        AnonymousParameters,\n+                       IllegalFloatLiteralPattern,\n                        );\n \n     add_early_builtin_with_new!(sess,\n@@ -201,6 +202,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN),\n             reference: \"issue #36890 <https://github.com/rust-lang/rust/issues/36890>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(ILLEGAL_FLOATING_POINT_LITERAL_PATTERN),\n+            reference: \"issue #41620 <https://github.com/rust-lang/rust/issues/41620>\",\n+        },\n         FutureIncompatibleInfo {\n             id: LintId::of(ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN),\n             reference: \"issue #36891 <https://github.com/rust-lang/rust/issues/36891>\","}, {"sha": "93ff609a280ae1d4b0d24431dcadef941b32b6a2", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -215,7 +215,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedUnsafe {\n                 let mut db = cx.struct_span_lint(UNUSED_UNSAFE, blk.span,\n                                                  \"unnecessary `unsafe` block\");\n \n-                db.span_label(blk.span, &\"unnecessary `unsafe` block\");\n+                db.span_label(blk.span, \"unnecessary `unsafe` block\");\n                 if let Some((kind, id)) = is_enclosed(cx, blk.id) {\n                     db.span_note(cx.tcx.hir.span(id),\n                                  &format!(\"because it's nested under this `unsafe` {}\", kind));"}, {"sha": "6c02ac7eafec32e0dba689f5cba942281a897bf1", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n-use index_builder::EntryBuilder;\n+use isolated_encoder::IsolatedEncoder;\n use schema::*;\n \n use rustc::hir;\n@@ -31,7 +31,7 @@ impl_stable_hash_for!(struct Ast<'tcx> {\n     rvalue_promotable_to_static\n });\n \n-impl<'a, 'b, 'tcx> EntryBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n     pub fn encode_body(&mut self, body_id: hir::BodyId) -> Lazy<Ast<'tcx>> {\n         let body = self.tcx.hir.body(body_id);\n         let lazy_body = self.lazy(body);"}, {"sha": "d2874f16289015afb8095c96111d203aac3745fa", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 54, "deletions": 28, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -12,9 +12,10 @@\n \n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n-use schema::CrateRoot;\n+use schema::{CrateRoot, Tracked};\n \n-use rustc::hir::def_id::{CrateNum, DefIndex};\n+use rustc::dep_graph::{DepNode, GlobalMetaDataKind};\n+use rustc::hir::def_id::{DefId, CrateNum, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::DepKind;\n use rustc::session::Session;\n@@ -88,7 +89,7 @@ fn register_native_lib(sess: &Session,\n             Some(span) => {\n                 struct_span_err!(sess, span, E0454,\n                                  \"#[link(name = \\\"\\\")] given with empty name\")\n-                    .span_label(span, &format!(\"empty name given\"))\n+                    .span_label(span, \"empty name given\")\n                     .emit();\n             }\n             None => {\n@@ -311,7 +312,8 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode(&metadata)\n         });\n \n-        let exported_symbols = crate_root.exported_symbols.decode(&metadata).collect();\n+        let exported_symbols = crate_root.exported_symbols\n+                                         .map(|x| x.decode(&metadata).collect());\n \n         let mut cmeta = cstore::CrateMetadata {\n             name: name,\n@@ -333,16 +335,27 @@ impl<'a> CrateLoader<'a> {\n                 rlib: rlib,\n                 rmeta: rmeta,\n             },\n-            dllimport_foreign_items: FxHashSet(),\n+            // Initialize this with an empty set. The field is populated below\n+            // after we were able to deserialize its contents.\n+            dllimport_foreign_items: Tracked::new(FxHashSet()),\n         };\n \n-        let dllimports: Vec<_> = cmeta.get_native_libraries().iter()\n-                            .filter(|lib| relevant_lib(self.sess, lib) &&\n-                                          lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n-                            .flat_map(|lib| &lib.foreign_items)\n-                            .map(|id| *id)\n-                            .collect();\n-        cmeta.dllimport_foreign_items.extend(dllimports);\n+        let dllimports: Tracked<FxHashSet<_>> = cmeta\n+            .root\n+            .native_libraries\n+            .map(|native_libraries| {\n+                let native_libraries: Vec<_> = native_libraries.decode(&cmeta)\n+                                                               .collect();\n+                native_libraries\n+                    .iter()\n+                    .filter(|lib| relevant_lib(self.sess, lib) &&\n+                                  lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n+                    .flat_map(|lib| lib.foreign_items.iter())\n+                    .map(|id| *id)\n+                    .collect()\n+            });\n+\n+        cmeta.dllimport_foreign_items = dllimports;\n \n         let cmeta = Rc::new(cmeta);\n         self.cstore.set_crate_data(cnum, cmeta.clone());\n@@ -493,10 +506,16 @@ impl<'a> CrateLoader<'a> {\n             return cstore::CrateNumMap::new();\n         }\n \n+        let dep_node = DepNode::GlobalMetaData(DefId { krate, index: CRATE_DEF_INDEX },\n+                                               GlobalMetaDataKind::CrateDeps);\n+\n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        ::std::iter::once(krate).chain(crate_root.crate_deps.decode(metadata).map(|dep| {\n+        ::std::iter::once(krate).chain(crate_root.crate_deps\n+                                                 .get(&self.sess.dep_graph, dep_node)\n+                                                 .decode(metadata)\n+                                                 .map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             if dep.kind == DepKind::UnexportedMacrosOnly {\n                 return krate;\n@@ -654,7 +673,9 @@ impl<'a> CrateLoader<'a> {\n \n     /// Look for a plugin registrar. Returns library path, crate\n     /// SVH and DefIndex of the registrar function.\n-    pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n+    pub fn find_plugin_registrar(&mut self,\n+                                 span: Span,\n+                                 name: &str)\n                                  -> Option<(PathBuf, Symbol, DefIndex)> {\n         let ekrate = self.read_extension_crate(span, &ExternCrateInfo {\n              name: Symbol::intern(name),\n@@ -740,13 +761,17 @@ impl<'a> CrateLoader<'a> {\n         let mut runtime_found = false;\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n                                                           \"needs_panic_runtime\");\n+\n+        let dep_graph = &self.sess.dep_graph;\n+\n         self.cstore.iter_crate_data(|cnum, data| {\n-            needs_panic_runtime = needs_panic_runtime || data.needs_panic_runtime();\n-            if data.is_panic_runtime() {\n+            needs_panic_runtime = needs_panic_runtime ||\n+                                  data.needs_panic_runtime(dep_graph);\n+            if data.is_panic_runtime(dep_graph) {\n                 // Inject a dependency from all #![needs_panic_runtime] to this\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                          &|data| data.needs_panic_runtime());\n+                                          &|data| data.needs_panic_runtime(dep_graph));\n                 runtime_found = runtime_found || data.dep_kind.get() == DepKind::Explicit;\n             }\n         });\n@@ -782,19 +807,19 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n-        if !data.is_panic_runtime() {\n+        if !data.is_panic_runtime(dep_graph) {\n             self.sess.err(&format!(\"the crate `{}` is not a panic runtime\",\n                                    name));\n         }\n-        if data.panic_strategy() != desired_strategy {\n+        if data.panic_strategy(dep_graph) != desired_strategy {\n             self.sess.err(&format!(\"the crate `{}` does not have the panic \\\n                                     strategy `{}`\",\n                                    name, desired_strategy.desc()));\n         }\n \n         self.sess.injected_panic_runtime.set(Some(cnum));\n         self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                  &|data| data.needs_panic_runtime());\n+                                  &|data| data.needs_panic_runtime(dep_graph));\n     }\n \n     fn inject_sanitizer_runtime(&mut self) {\n@@ -862,7 +887,7 @@ impl<'a> CrateLoader<'a> {\n                                        PathKind::Crate, dep_kind);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n-                if !data.is_sanitizer_runtime() {\n+                if !data.is_sanitizer_runtime(&self.sess.dep_graph) {\n                     self.sess.err(&format!(\"the crate `{}` is not a sanitizer runtime\",\n                                            name));\n                 }\n@@ -878,12 +903,13 @@ impl<'a> CrateLoader<'a> {\n         // also bail out as we don't need to implicitly inject one.\n         let mut needs_allocator = false;\n         let mut found_required_allocator = false;\n+        let dep_graph = &self.sess.dep_graph;\n         self.cstore.iter_crate_data(|cnum, data| {\n-            needs_allocator = needs_allocator || data.needs_allocator();\n-            if data.is_allocator() {\n+            needs_allocator = needs_allocator || data.needs_allocator(dep_graph);\n+            if data.is_allocator(dep_graph) {\n                 info!(\"{} required by rlib and is an allocator\", data.name());\n                 self.inject_dependency_if(cnum, \"an allocator\",\n-                                          &|data| data.needs_allocator());\n+                                          &|data| data.needs_allocator(dep_graph));\n                 found_required_allocator = found_required_allocator ||\n                     data.dep_kind.get() == DepKind::Explicit;\n             }\n@@ -937,14 +963,14 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the crate we loaded to ensure that it is indeed an\n         // allocator.\n-        if !data.is_allocator() {\n+        if !data.is_allocator(dep_graph) {\n             self.sess.err(&format!(\"the allocator crate `{}` is not tagged \\\n                                     with #![allocator]\", data.name()));\n         }\n \n         self.sess.injected_allocator.set(Some(cnum));\n         self.inject_dependency_if(cnum, \"an allocator\",\n-                                  &|data| data.needs_allocator());\n+                                  &|data| data.needs_allocator(dep_graph));\n     }\n \n     fn inject_dependency_if(&self,\n@@ -1029,7 +1055,7 @@ impl<'a> CrateLoader<'a> {\n                 Some(k) => {\n                     struct_span_err!(self.sess, m.span, E0458,\n                               \"unknown kind: `{}`\", k)\n-                        .span_label(m.span, &format!(\"unknown kind\")).emit();\n+                        .span_label(m.span, \"unknown kind\").emit();\n                     cstore::NativeUnknown\n                 }\n                 None => cstore::NativeUnknown\n@@ -1042,7 +1068,7 @@ impl<'a> CrateLoader<'a> {\n                 None => {\n                     struct_span_err!(self.sess, m.span, E0459,\n                                      \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n-                        .span_label(m.span, &format!(\"missing `name` argument\")).emit();\n+                        .span_label(m.span, \"missing `name` argument\").emit();\n                     Symbol::intern(\"foo\")\n                 }\n             };"}, {"sha": "8d53e7d49ee81b3d7027a37b7f77b0451a38af8d", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -12,9 +12,9 @@\n // crates and libraries\n \n use locator;\n-use schema;\n+use schema::{self, Tracked};\n \n-use rustc::dep_graph::DepGraph;\n+use rustc::dep_graph::{DepGraph, DepNode, GlobalMetaDataKind};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n@@ -83,14 +83,14 @@ pub struct CrateMetadata {\n     /// compilation support.\n     pub def_path_table: DefPathTable,\n \n-    pub exported_symbols: FxHashSet<DefIndex>,\n+    pub exported_symbols: Tracked<FxHashSet<DefIndex>>,\n \n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,\n \n     pub proc_macros: Option<Vec<(ast::Name, Rc<SyntaxExtension>)>>,\n     // Foreign items imported from a dylib (Windows only)\n-    pub dllimport_foreign_items: FxHashSet<DefIndex>,\n+    pub dllimport_foreign_items: Tracked<FxHashSet<DefIndex>>,\n }\n \n pub struct CStore {\n@@ -269,51 +269,60 @@ impl CrateMetadata {\n         self.root.disambiguator\n     }\n \n-    pub fn is_staged_api(&self) -> bool {\n-        for attr in self.get_item_attrs(CRATE_DEF_INDEX).iter() {\n+    pub fn is_staged_api(&self, dep_graph: &DepGraph) -> bool {\n+        for attr in self.get_item_attrs(CRATE_DEF_INDEX, dep_graph).iter() {\n             if attr.path == \"stable\" || attr.path == \"unstable\" {\n                 return true;\n             }\n         }\n         false\n     }\n \n-    pub fn is_allocator(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_allocator(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"allocator\")\n     }\n \n-    pub fn needs_allocator(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn needs_allocator(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"needs_allocator\")\n     }\n \n-    pub fn is_panic_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_panic_runtime(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"panic_runtime\")\n     }\n \n-    pub fn needs_panic_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn needs_panic_runtime(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"needs_panic_runtime\")\n     }\n \n-    pub fn is_compiler_builtins(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_compiler_builtins(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"compiler_builtins\")\n     }\n \n-    pub fn is_sanitizer_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_sanitizer_runtime(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"sanitizer_runtime\")\n     }\n \n-    pub fn is_no_builtins(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_no_builtins(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"no_builtins\")\n     }\n \n-    pub fn panic_strategy(&self) -> PanicStrategy {\n-        self.root.panic_strategy.clone()\n+    pub fn panic_strategy(&self, dep_graph: &DepGraph) -> PanicStrategy {\n+        let def_id = DefId {\n+            krate: self.cnum,\n+            index: CRATE_DEF_INDEX,\n+        };\n+        let dep_node = DepNode::GlobalMetaData(def_id, GlobalMetaDataKind::Krate);\n+\n+        self.root\n+            .panic_strategy\n+            .get(dep_graph, dep_node)\n+            .clone()\n     }\n }"}, {"sha": "f3fb427fed66fdd2e52204786bfbf03bc3f89312", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -24,7 +24,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n \n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, GlobalMetaDataKind};\n use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData};\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n@@ -111,15 +111,18 @@ provide! { <'tcx> tcx, def_id, cdata\n     def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n     stability => { cdata.get_stability(def_id.index) }\n     deprecation => { cdata.get_deprecation(def_id.index) }\n-    item_attrs => { cdata.get_item_attrs(def_id.index) }\n+    item_attrs => { cdata.get_item_attrs(def_id.index, &tcx.dep_graph) }\n     // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n     // a `fn` when encoding, so the dep-tracking wouldn't work.\n     // This is only used by rustdoc anyway, which shouldn't have\n     // incremental recompilation ever enabled.\n     fn_arg_names => { cdata.get_fn_arg_names(def_id.index) }\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n-    is_exported_symbol => { cdata.exported_symbols.contains(&def_id.index) }\n+    is_exported_symbol => {\n+        let dep_node = cdata.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n+        cdata.exported_symbols.get(&tcx.dep_graph, dep_node).contains(&def_id.index)\n+    }\n     item_body_nested_bodies => { Rc::new(cdata.item_body_nested_bodies(def_id.index)) }\n     const_is_rvalue_promotable_to_static => {\n         cdata.const_is_rvalue_promotable_to_static(def_id.index)\n@@ -149,7 +152,7 @@ impl CrateStore for cstore::CStore {\n         }\n         let mut result = vec![];\n         self.iter_crate_data(|_, cdata| {\n-            cdata.get_implementations_for_trait(filter, &mut result)\n+            cdata.get_implementations_for_trait(filter, &self.dep_graph, &mut result)\n         });\n         result\n     }\n@@ -186,63 +189,71 @@ impl CrateStore for cstore::CStore {\n         if def_id.krate == LOCAL_CRATE {\n             self.dllimport_foreign_items.borrow().contains(&def_id.index)\n         } else {\n-            self.get_crate_data(def_id.krate).is_dllimport_foreign_item(def_id.index)\n+            self.get_crate_data(def_id.krate)\n+                .is_dllimport_foreign_item(def_id.index, &self.dep_graph)\n         }\n     }\n \n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n                                 -> Vec<(CrateNum, LinkagePreference)>\n     {\n-        self.get_crate_data(cnum).get_dylib_dependency_formats()\n+        self.get_crate_data(cnum).get_dylib_dependency_formats(&self.dep_graph)\n     }\n \n     fn dep_kind(&self, cnum: CrateNum) -> DepKind\n     {\n-        self.get_crate_data(cnum).dep_kind.get()\n+        let data = self.get_crate_data(cnum);\n+        let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n+        self.dep_graph.read(dep_node);\n+        data.dep_kind.get()\n     }\n \n     fn export_macros(&self, cnum: CrateNum) {\n-        if self.get_crate_data(cnum).dep_kind.get() == DepKind::UnexportedMacrosOnly {\n-            self.get_crate_data(cnum).dep_kind.set(DepKind::MacrosOnly)\n+        let data = self.get_crate_data(cnum);\n+        let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n+\n+        self.dep_graph.read(dep_node);\n+        if data.dep_kind.get() == DepKind::UnexportedMacrosOnly {\n+            data.dep_kind.set(DepKind::MacrosOnly)\n         }\n     }\n \n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n     {\n-        self.get_crate_data(cnum).get_lang_items()\n+        self.get_crate_data(cnum).get_lang_items(&self.dep_graph)\n     }\n \n     fn missing_lang_items(&self, cnum: CrateNum)\n                           -> Vec<lang_items::LangItem>\n     {\n-        self.get_crate_data(cnum).get_missing_lang_items()\n+        self.get_crate_data(cnum).get_missing_lang_items(&self.dep_graph)\n     }\n \n     fn is_staged_api(&self, cnum: CrateNum) -> bool\n     {\n-        self.get_crate_data(cnum).is_staged_api()\n+        self.get_crate_data(cnum).is_staged_api(&self.dep_graph)\n     }\n \n     fn is_allocator(&self, cnum: CrateNum) -> bool\n     {\n-        self.get_crate_data(cnum).is_allocator()\n+        self.get_crate_data(cnum).is_allocator(&self.dep_graph)\n     }\n \n     fn is_panic_runtime(&self, cnum: CrateNum) -> bool\n     {\n-        self.get_crate_data(cnum).is_panic_runtime()\n+        self.get_crate_data(cnum).is_panic_runtime(&self.dep_graph)\n     }\n \n     fn is_compiler_builtins(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_compiler_builtins()\n+        self.get_crate_data(cnum).is_compiler_builtins(&self.dep_graph)\n     }\n \n     fn is_sanitizer_runtime(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_sanitizer_runtime()\n+        self.get_crate_data(cnum).is_sanitizer_runtime(&self.dep_graph)\n     }\n \n     fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n-        self.get_crate_data(cnum).panic_strategy()\n+        self.get_crate_data(cnum).panic_strategy(&self.dep_graph)\n     }\n \n     fn crate_name(&self, cnum: CrateNum) -> Symbol\n@@ -288,16 +299,16 @@ impl CrateStore for cstore::CStore {\n \n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n     {\n-        self.get_crate_data(cnum).get_native_libraries()\n+        self.get_crate_data(cnum).get_native_libraries(&self.dep_graph)\n     }\n \n     fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId>\n     {\n-        self.get_crate_data(cnum).get_exported_symbols()\n+        self.get_crate_data(cnum).get_exported_symbols(&self.dep_graph)\n     }\n \n     fn is_no_builtins(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_no_builtins()\n+        self.get_crate_data(cnum).is_no_builtins(&self.dep_graph)\n     }\n \n     fn retrace_path(&self,\n@@ -364,7 +375,7 @@ impl CrateStore for cstore::CStore {\n         let body = filemap_to_stream(&sess.parse_sess, filemap);\n \n         // Mark the attrs as used\n-        let attrs = data.get_item_attrs(id.index);\n+        let attrs = data.get_item_attrs(id.index, &self.dep_graph);\n         for attr in attrs.iter() {\n             attr::mark_used(attr);\n         }\n@@ -446,7 +457,7 @@ impl CrateStore for cstore::CStore {\n                                  reachable: &NodeSet)\n                                  -> EncodedMetadata\n     {\n-        encoder::encode_metadata(tcx, self, link_meta, reachable)\n+        encoder::encode_metadata(tcx, link_meta, reachable)\n     }\n \n     fn metadata_encoding_version(&self) -> &[u8]"}, {"sha": "ea845f722c3450b214bb7f835b16e135016c6a56", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 112, "deletions": 124, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -13,6 +13,7 @@\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n+use rustc::dep_graph::{DepGraph, DepNode, GlobalMetaDataKind};\n use rustc::hir::map::{DefKey, DefPath, DefPathData};\n use rustc::hir;\n \n@@ -405,10 +406,14 @@ impl<'a, 'tcx> MetadataBlob {\n         Lazy::with_position(pos).decode(self)\n     }\n \n-    pub fn list_crate_metadata(&self, out: &mut io::Write) -> io::Result<()> {\n+    pub fn list_crate_metadata(&self,\n+                               out: &mut io::Write) -> io::Result<()> {\n         write!(out, \"=External Dependencies=\\n\")?;\n         let root = self.get_root();\n-        for (i, dep) in root.crate_deps.decode(self).enumerate() {\n+        for (i, dep) in root.crate_deps\n+                            .get_untracked()\n+                            .decode(self)\n+                            .enumerate() {\n             write!(out, \"{} {}-{}\\n\", i + 1, dep.name, dep.hash)?;\n         }\n         write!(out, \"\\n\")?;\n@@ -654,8 +659,13 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(&self) -> Vec<(DefIndex, usize)> {\n-        self.root.lang_items.decode(self).collect()\n+    pub fn get_lang_items(&self, dep_graph: &DepGraph) -> Vec<(DefIndex, usize)> {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::LangItems);\n+        self.root\n+            .lang_items\n+            .get(dep_graph, dep_node)\n+            .decode(self)\n+            .collect()\n     }\n \n     /// Iterates over each child of the given item.\n@@ -870,13 +880,17 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self, node_id: DefIndex) -> Rc<[ast::Attribute]> {\n+    pub fn get_item_attrs(&self,\n+                          node_id: DefIndex,\n+                          dep_graph: &DepGraph) -> Rc<[ast::Attribute]> {\n         let (node_as, node_index) =\n             (node_id.address_space().index(), node_id.as_array_index());\n         if self.is_proc_macro(node_id) {\n             return Rc::new([]);\n         }\n \n+        dep_graph.read(DepNode::MetaData(self.local_def_id(node_id)));\n+\n         if let Some(&Some(ref val)) =\n             self.attribute_cache.borrow()[node_as].get(node_index) {\n             return val.clone();\n@@ -941,7 +955,10 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect()\n     }\n \n-    pub fn get_implementations_for_trait(&self, filter: Option<DefId>, result: &mut Vec<DefId>) {\n+    pub fn get_implementations_for_trait(&self,\n+                                         filter: Option<DefId>,\n+                                         dep_graph: &DepGraph,\n+                                         result: &mut Vec<DefId>) {\n         // Do a reverse lookup beforehand to avoid touching the crate_num\n         // hash map in the loop below.\n         let filter = match filter.map(|def_id| self.reverse_translate_def_id(def_id)) {\n@@ -952,7 +969,8 @@ impl<'a, 'tcx> CrateMetadata {\n         };\n \n         // FIXME(eddyb) Make this O(1) instead of O(n).\n-        for trait_impls in self.root.impls.decode(self) {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Impls);\n+        for trait_impls in self.root.impls.get(dep_graph, dep_node).decode(self) {\n             if filter.is_some() && filter != Some(trait_impls.trait_id) {\n                 continue;\n             }\n@@ -975,13 +993,29 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    pub fn get_native_libraries(&self) -> Vec<NativeLibrary> {\n-        self.root.native_libraries.decode(self).collect()\n+    pub fn get_native_libraries(&self,\n+                                dep_graph: &DepGraph)\n+                                -> Vec<NativeLibrary> {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::NativeLibraries);\n+        self.root\n+            .native_libraries\n+            .get(dep_graph, dep_node)\n+            .decode(self)\n+            .collect()\n     }\n \n-    pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n+    pub fn get_dylib_dependency_formats(&self,\n+                                        dep_graph: &DepGraph)\n+                                        -> Vec<(CrateNum, LinkagePreference)> {\n+        let def_id = DefId {\n+            krate: self.cnum,\n+            index: CRATE_DEF_INDEX,\n+        };\n+        let dep_node = DepNode::GlobalMetaData(def_id,\n+                                               GlobalMetaDataKind::DylibDependencyFormats);\n         self.root\n             .dylib_dependency_formats\n+            .get(dep_graph, dep_node)\n             .decode(self)\n             .enumerate()\n             .flat_map(|(i, link)| {\n@@ -991,8 +1025,13 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect()\n     }\n \n-    pub fn get_missing_lang_items(&self) -> Vec<lang_items::LangItem> {\n-        self.root.lang_items_missing.decode(self).collect()\n+    pub fn get_missing_lang_items(&self, dep_graph: &DepGraph) -> Vec<lang_items::LangItem> {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::LangItemsMissing);\n+        self.root\n+            .lang_items_missing\n+            .get(dep_graph, dep_node)\n+            .decode(self)\n+            .collect()\n     }\n \n     pub fn get_fn_arg_names(&self, id: DefIndex) -> Vec<ast::Name> {\n@@ -1005,8 +1044,13 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn get_exported_symbols(&self) -> Vec<DefId> {\n-        self.exported_symbols.iter().map(|&index| self.local_def_id(index)).collect()\n+    pub fn get_exported_symbols(&self, dep_graph: &DepGraph) -> Vec<DefId> {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n+        self.exported_symbols\n+            .get(dep_graph, dep_node)\n+            .iter()\n+            .map(|&index| self.local_def_id(index))\n+            .collect()\n     }\n \n     pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n@@ -1035,8 +1079,11 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn is_dllimport_foreign_item(&self, id: DefIndex) -> bool {\n-        self.dllimport_foreign_items.contains(&id)\n+    pub fn is_dllimport_foreign_item(&self, id: DefIndex, dep_graph: &DepGraph) -> bool {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::NativeLibraries);\n+        self.dllimport_foreign_items\n+            .get(dep_graph, dep_node)\n+            .contains(&id)\n     }\n \n     pub fn is_default_impl(&self, impl_id: DefIndex) -> bool {\n@@ -1114,121 +1161,62 @@ impl<'a, 'tcx> CrateMetadata {\n         let external_codemap = self.root.codemap.decode(self);\n \n         let imported_filemaps = external_codemap.map(|filemap_to_import| {\n-                // Try to find an existing FileMap that can be reused for the filemap to\n-                // be imported. A FileMap is reusable if it is exactly the same, just\n-                // positioned at a different offset within the codemap.\n-                let reusable_filemap = {\n-                    local_codemap.files\n-                        .borrow()\n-                        .iter()\n-                        .find(|fm| are_equal_modulo_startpos(&fm, &filemap_to_import))\n-                        .map(|rc| rc.clone())\n-                };\n-\n-                match reusable_filemap {\n-                    Some(fm) => {\n-\n-                        debug!(\"CrateMetaData::imported_filemaps reuse \\\n-                                filemap {:?} original (start_pos {:?} end_pos {:?}) \\\n-                                translated (start_pos {:?} end_pos {:?})\",\n-                               filemap_to_import.name,\n-                               filemap_to_import.start_pos, filemap_to_import.end_pos,\n-                               fm.start_pos, fm.end_pos);\n-\n-                        cstore::ImportedFileMap {\n-                            original_start_pos: filemap_to_import.start_pos,\n-                            original_end_pos: filemap_to_import.end_pos,\n-                            translated_filemap: fm,\n-                        }\n-                    }\n-                    None => {\n-                        // We can't reuse an existing FileMap, so allocate a new one\n-                        // containing the information we need.\n-                        let syntax_pos::FileMap { name,\n-                                                  name_was_remapped,\n-                                                  start_pos,\n-                                                  end_pos,\n-                                                  lines,\n-                                                  multibyte_chars,\n-                                                  .. } = filemap_to_import;\n-\n-                        let source_length = (end_pos - start_pos).to_usize();\n-\n-                        // Translate line-start positions and multibyte character\n-                        // position into frame of reference local to file.\n-                        // `CodeMap::new_imported_filemap()` will then translate those\n-                        // coordinates to their new global frame of reference when the\n-                        // offset of the FileMap is known.\n-                        let mut lines = lines.into_inner();\n-                        for pos in &mut lines {\n-                            *pos = *pos - start_pos;\n-                        }\n-                        let mut multibyte_chars = multibyte_chars.into_inner();\n-                        for mbc in &mut multibyte_chars {\n-                            mbc.pos = mbc.pos - start_pos;\n-                        }\n+            // We can't reuse an existing FileMap, so allocate a new one\n+            // containing the information we need.\n+            let syntax_pos::FileMap { name,\n+                                      name_was_remapped,\n+                                      start_pos,\n+                                      end_pos,\n+                                      lines,\n+                                      multibyte_chars,\n+                                      .. } = filemap_to_import;\n+\n+            let source_length = (end_pos - start_pos).to_usize();\n+\n+            // Translate line-start positions and multibyte character\n+            // position into frame of reference local to file.\n+            // `CodeMap::new_imported_filemap()` will then translate those\n+            // coordinates to their new global frame of reference when the\n+            // offset of the FileMap is known.\n+            let mut lines = lines.into_inner();\n+            for pos in &mut lines {\n+                *pos = *pos - start_pos;\n+            }\n+            let mut multibyte_chars = multibyte_chars.into_inner();\n+            for mbc in &mut multibyte_chars {\n+                mbc.pos = mbc.pos - start_pos;\n+            }\n \n-                        let local_version = local_codemap.new_imported_filemap(name,\n-                                                                               name_was_remapped,\n-                                                                               source_length,\n-                                                                               lines,\n-                                                                               multibyte_chars);\n-                        debug!(\"CrateMetaData::imported_filemaps alloc \\\n-                                filemap {:?} original (start_pos {:?} end_pos {:?}) \\\n-                                translated (start_pos {:?} end_pos {:?})\",\n-                               local_version.name, start_pos, end_pos,\n-                               local_version.start_pos, local_version.end_pos);\n-\n-                        cstore::ImportedFileMap {\n-                            original_start_pos: start_pos,\n-                            original_end_pos: end_pos,\n-                            translated_filemap: local_version,\n-                        }\n-                    }\n-                }\n-            })\n-            .collect();\n+            let local_version = local_codemap.new_imported_filemap(name,\n+                                                                   name_was_remapped,\n+                                                                   self.cnum.as_u32(),\n+                                                                   source_length,\n+                                                                   lines,\n+                                                                   multibyte_chars);\n+            debug!(\"CrateMetaData::imported_filemaps alloc \\\n+                    filemap {:?} original (start_pos {:?} end_pos {:?}) \\\n+                    translated (start_pos {:?} end_pos {:?})\",\n+                   local_version.name, start_pos, end_pos,\n+                   local_version.start_pos, local_version.end_pos);\n+\n+            cstore::ImportedFileMap {\n+                original_start_pos: start_pos,\n+                original_end_pos: end_pos,\n+                translated_filemap: local_version,\n+            }\n+        }).collect();\n \n         // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n         *self.codemap_import_info.borrow_mut() = imported_filemaps;\n         self.codemap_import_info.borrow()\n     }\n-}\n-\n-fn are_equal_modulo_startpos(fm1: &syntax_pos::FileMap, fm2: &syntax_pos::FileMap) -> bool {\n-    if fm1.byte_length() != fm2.byte_length() {\n-        return false;\n-    }\n-\n-    if fm1.name != fm2.name {\n-        return false;\n-    }\n-\n-    let lines1 = fm1.lines.borrow();\n-    let lines2 = fm2.lines.borrow();\n-\n-    if lines1.len() != lines2.len() {\n-        return false;\n-    }\n-\n-    for (&line1, &line2) in lines1.iter().zip(lines2.iter()) {\n-        if (line1 - fm1.start_pos) != (line2 - fm2.start_pos) {\n-            return false;\n-        }\n-    }\n-\n-    let multibytes1 = fm1.multibyte_chars.borrow();\n-    let multibytes2 = fm2.multibyte_chars.borrow();\n \n-    if multibytes1.len() != multibytes2.len() {\n-        return false;\n-    }\n+    pub fn metadata_dep_node(&self, kind: GlobalMetaDataKind) -> DepNode<DefId> {\n+        let def_id = DefId {\n+            krate: self.cnum,\n+            index: CRATE_DEF_INDEX,\n+        };\n \n-    for (mb1, mb2) in multibytes1.iter().zip(multibytes2.iter()) {\n-        if (mb1.bytes != mb2.bytes) || ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n-            return false;\n-        }\n+        DepNode::GlobalMetaData(def_id, kind)\n     }\n-\n-    true\n }"}, {"sha": "fa4ebed16189c7ab2cb81defdb02eeef3a4068be", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 519, "deletions": 458, "changes": 977, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cstore;\n use index::Index;\n+use index_builder::{FromId, IndexBuilder, Untracked};\n+use isolated_encoder::IsolatedEncoder;\n use schema::*;\n \n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n-                            EncodedMetadata, EncodedMetadataHash};\n+                            EncodedMetadata, EncodedMetadataHashes};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE};\n use rustc::hir::map::definitions::DefPathTable;\n+use rustc::dep_graph::{DepNode, GlobalMetaDataKind};\n+use rustc::ich::{StableHashingContext, Fingerprint};\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -26,12 +29,15 @@ use rustc::session::config::{self, CrateTypeProcMacro};\n use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+\n use std::hash::Hash;\n use std::intrinsics;\n use std::io::prelude::*;\n use std::io::Cursor;\n use std::path::Path;\n use std::rc::Rc;\n+use std::sync::Arc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n@@ -44,20 +50,18 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n-use super::index_builder::{FromId, IndexBuilder, Untracked, EntryBuilder};\n-\n pub struct EncodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Encoder<'a>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     link_meta: &'a LinkMeta,\n-    cstore: &'a cstore::CStore,\n     exported_symbols: &'a NodeSet,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n \n-    pub metadata_hashes: Vec<EncodedMetadataHash>,\n+    pub metadata_hashes: EncodedMetadataHashes,\n+    pub compute_ich: bool,\n }\n \n macro_rules! encoder_methods {\n@@ -134,6 +138,7 @@ impl<'a, 'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+\n     pub fn position(&self) -> usize {\n         self.opaque.position()\n     }\n@@ -237,19 +242,248 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Ok(())\n     }\n+\n+    // Encodes something that corresponds to a single DepNode::GlobalMetaData\n+    // and registers the Fingerprint in the `metadata_hashes` map.\n+    pub fn tracked<'x, DATA, R>(&'x mut self,\n+                                dep_node: DepNode<()>,\n+                                op: fn(&mut IsolatedEncoder<'x, 'a, 'tcx>, DATA) -> R,\n+                                data: DATA)\n+                                -> Tracked<R> {\n+        let mut entry_builder = IsolatedEncoder::new(self);\n+        let ret = op(&mut entry_builder, data);\n+        let (fingerprint, this) = entry_builder.finish();\n+\n+        if let Some(fingerprint) = fingerprint {\n+            this.metadata_hashes.global_hashes.push((dep_node, fingerprint));\n+        }\n+\n+        Tracked::new(ret)\n+    }\n+\n+    fn encode_info_for_items(&mut self) -> Index {\n+        let krate = self.tcx.hir.krate();\n+        let mut index = IndexBuilder::new(self);\n+        index.record(DefId::local(CRATE_DEF_INDEX),\n+                     IsolatedEncoder::encode_info_for_mod,\n+                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n+        let mut visitor = EncodeVisitor { index: index };\n+        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n+        for macro_def in &krate.exported_macros {\n+            visitor.visit_macro_def(macro_def);\n+        }\n+        visitor.index.into_items()\n+    }\n+\n+    fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n+        let definitions = self.tcx.hir.definitions();\n+        self.lazy(definitions.def_path_table())\n+    }\n+\n+    fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n+        let codemap = self.tcx.sess.codemap();\n+        let all_filemaps = codemap.files();\n+\n+        let hcx = &mut StableHashingContext::new(self.tcx);\n+        let (working_dir, working_dir_was_remapped) = self.tcx.sess.working_dir.clone();\n+\n+        let adapted = all_filemaps.iter()\n+            .filter(|filemap| {\n+                // No need to re-export imported filemaps, as any downstream\n+                // crate will import them from their original source.\n+                !filemap.is_imported()\n+            })\n+            .map(|filemap| {\n+                // When exporting FileMaps, we expand all paths to absolute\n+                // paths because any relative paths are potentially relative to\n+                // a wrong directory.\n+                // However, if a path has been modified via\n+                // `-Zremap-path-prefix` we assume the user has already set\n+                // things up the way they want and don't touch the path values\n+                // anymore.\n+                let name = Path::new(&filemap.name);\n+                if filemap.name_was_remapped ||\n+                   (name.is_relative() && working_dir_was_remapped) {\n+                    // This path of this FileMap has been modified by\n+                    // path-remapping, so we use it verbatim (and avoid cloning\n+                    // the whole map in the process).\n+                    filemap.clone()\n+                } else {\n+                    let mut adapted = (**filemap).clone();\n+                    let abs_path = Path::new(&working_dir).join(name)\n+                                                         .to_string_lossy()\n+                                                         .into_owned();\n+                    adapted.name = abs_path;\n+                    Rc::new(adapted)\n+                }\n+            });\n+\n+        let filemaps: Vec<_> = if self.compute_ich {\n+            adapted.inspect(|filemap| {\n+                let mut hasher = StableHasher::new();\n+                filemap.hash_stable(hcx, &mut hasher);\n+                let fingerprint = hasher.finish();\n+                let dep_node = DepNode::FileMap((), Arc::new(filemap.name.clone()));\n+                self.metadata_hashes.global_hashes.push((dep_node, fingerprint));\n+            }).collect()\n+        } else {\n+            adapted.collect()\n+        };\n+\n+        self.lazy_seq_ref(filemaps.iter().map(|fm| &**fm))\n+    }\n+\n+    fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {\n+        let mut i = self.position();\n+\n+        let crate_deps = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::CrateDeps),\n+            IsolatedEncoder::encode_crate_deps,\n+            ());\n+        let dylib_dependency_formats = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::DylibDependencyFormats),\n+            IsolatedEncoder::encode_dylib_dependency_formats,\n+            ());\n+        let dep_bytes = self.position() - i;\n+\n+        // Encode the language items.\n+        i = self.position();\n+        let lang_items = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::LangItems),\n+            IsolatedEncoder::encode_lang_items,\n+            ());\n+\n+        let lang_items_missing = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::LangItemsMissing),\n+            IsolatedEncoder::encode_lang_items_missing,\n+            ());\n+        let lang_item_bytes = self.position() - i;\n+\n+        // Encode the native libraries used\n+        i = self.position();\n+        let native_libraries = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::NativeLibraries),\n+            IsolatedEncoder::encode_native_libraries,\n+            ());\n+        let native_lib_bytes = self.position() - i;\n+\n+        // Encode codemap\n+        i = self.position();\n+        let codemap = self.encode_codemap();\n+        let codemap_bytes = self.position() - i;\n+\n+        // Encode DefPathTable\n+        i = self.position();\n+        let def_path_table = self.encode_def_path_table();\n+        let def_path_table_bytes = self.position() - i;\n+\n+        // Encode the def IDs of impls, for coherence checking.\n+        i = self.position();\n+        let impls = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::Impls),\n+            IsolatedEncoder::encode_impls,\n+            ());\n+        let impl_bytes = self.position() - i;\n+\n+        // Encode exported symbols info.\n+        i = self.position();\n+        let exported_symbols = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::ExportedSymbols),\n+            IsolatedEncoder::encode_exported_symbols,\n+            self.exported_symbols);\n+        let exported_symbols_bytes = self.position() - i;\n+\n+        // Encode and index the items.\n+        i = self.position();\n+        let items = self.encode_info_for_items();\n+        let item_bytes = self.position() - i;\n+\n+        i = self.position();\n+        let index = items.write_index(&mut self.opaque.cursor);\n+        let index_bytes = self.position() - i;\n+\n+        let tcx = self.tcx;\n+        let link_meta = self.link_meta;\n+        let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n+        let root = self.lazy(&CrateRoot {\n+            name: tcx.crate_name(LOCAL_CRATE),\n+            triple: tcx.sess.opts.target_triple.clone(),\n+            hash: link_meta.crate_hash,\n+            disambiguator: tcx.sess.local_crate_disambiguator(),\n+            panic_strategy: Tracked::new(tcx.sess.panic_strategy()),\n+            plugin_registrar_fn: tcx.sess\n+                .plugin_registrar_fn\n+                .get()\n+                .map(|id| tcx.hir.local_def_id(id).index),\n+            macro_derive_registrar: if is_proc_macro {\n+                let id = tcx.sess.derive_registrar_fn.get().unwrap();\n+                Some(tcx.hir.local_def_id(id).index)\n+            } else {\n+                None\n+            },\n+\n+            crate_deps: crate_deps,\n+            dylib_dependency_formats: dylib_dependency_formats,\n+            lang_items: lang_items,\n+            lang_items_missing: lang_items_missing,\n+            native_libraries: native_libraries,\n+            codemap: codemap,\n+            def_path_table: def_path_table,\n+            impls: impls,\n+            exported_symbols: exported_symbols,\n+            index: index,\n+        });\n+\n+        let total_bytes = self.position();\n+\n+        self.metadata_hashes.global_hashes.push((\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::Krate),\n+            Fingerprint::from_smaller_hash(link_meta.crate_hash.as_u64())\n+        ));\n+\n+        if self.tcx.sess.meta_stats() {\n+            let mut zero_bytes = 0;\n+            for e in self.opaque.cursor.get_ref() {\n+                if *e == 0 {\n+                    zero_bytes += 1;\n+                }\n+            }\n+\n+            println!(\"metadata stats:\");\n+            println!(\"             dep bytes: {}\", dep_bytes);\n+            println!(\"       lang item bytes: {}\", lang_item_bytes);\n+            println!(\"          native bytes: {}\", native_lib_bytes);\n+            println!(\"         codemap bytes: {}\", codemap_bytes);\n+            println!(\"            impl bytes: {}\", impl_bytes);\n+            println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n+            println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n+            println!(\"            item bytes: {}\", item_bytes);\n+            println!(\"           index bytes: {}\", index_bytes);\n+            println!(\"            zero bytes: {}\", zero_bytes);\n+            println!(\"           total bytes: {}\", total_bytes);\n+        }\n+\n+        root\n+    }\n }\n \n-impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n-    fn encode_item_variances(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n-        debug!(\"EntryBuilder::encode_item_variances({:?})\", def_id);\n+// These are methods for encoding various things. They are meant to be used with\n+// IndexBuilder::record() and EncodeContext::tracked(). They actually\n+// would not have to be methods of IsolatedEncoder (free standing functions\n+// taking IsolatedEncoder as first argument would be just fine) but by making\n+// them methods we don't have to repeat the lengthy `<'a, 'b: 'a, 'tcx: 'b>`\n+// clause again and again.\n+impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n+    fn encode_variances_of(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n+        debug!(\"IsolatedEncoder::encode_variances_of({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy_seq_from_slice(&tcx.variances_of(def_id))\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n         let ty = tcx.type_of(def_id);\n-        debug!(\"EntryBuilder::encode_item_type({:?}) => {:?}\", def_id, ty);\n+        debug!(\"IsolatedEncoder::encode_item_type({:?}) => {:?}\", def_id, ty);\n         self.lazy(&ty)\n     }\n \n@@ -265,7 +499,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.did;\n-        debug!(\"EntryBuilder::encode_enum_variant_info({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_enum_variant_info({:?})\", def_id);\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n@@ -306,7 +540,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                            -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def_id = tcx.hir.local_def_id(id);\n-        debug!(\"EntryBuilder::encode_info_for_mod({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n             reexports: match tcx.export_map.get(&id) {\n@@ -338,22 +572,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             mir: None\n         }\n     }\n-}\n-\n-impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n-    fn encode_fields(&mut self, adt_def_id: DefId) {\n-        let def = self.tcx.adt_def(adt_def_id);\n-        for (variant_index, variant) in def.variants.iter().enumerate() {\n-            for (field_index, field) in variant.fields.iter().enumerate() {\n-                self.record(field.did,\n-                            EntryBuilder::encode_field,\n-                            (adt_def_id, Untracked((variant_index, field_index))));\n-            }\n-        }\n-    }\n-}\n \n-impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     /// Encode data for the given field of the given variant of the\n     /// given ADT. The indices of the variant/field are untracked:\n     /// this is ok because we will have to lookup the adt-def by its\n@@ -370,7 +589,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n-        debug!(\"EntryBuilder::encode_field({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_field({:?})\", def_id);\n \n         let variant_id = tcx.hir.as_local_node_id(variant.did).unwrap();\n         let variant_data = tcx.hir.expect_variant_data(variant_id);\n@@ -396,7 +615,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_struct_ctor({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n         let variant = tcx.adt_def(adt_def_id).struct_variant();\n \n@@ -438,19 +657,19 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics> {\n-        debug!(\"EntryBuilder::encode_generics({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_generics({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(tcx.generics_of(def_id))\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n-        debug!(\"EntryBuilder::encode_predicates({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_predicates({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(&tcx.predicates_of(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_trait_item({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n@@ -533,7 +752,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_impl_item({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_impl_item({:?})\", def_id);\n         let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.hir.expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n@@ -631,7 +850,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n     fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n-        debug!(\"EntryBuilder::encode_inherent_implementations({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n         if implementations.is_empty() {\n             LazySeq::empty()\n@@ -644,19 +863,19 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_stability(&mut self, def_id: DefId) -> Option<Lazy<attr::Stability>> {\n-        debug!(\"EntryBuilder::encode_stability({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_stability({:?})\", def_id);\n         self.tcx.lookup_stability(def_id).map(|stab| self.lazy(stab))\n     }\n \n     fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n-        debug!(\"EntryBuilder::encode_deprecation({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_deprecation({:?})\", def_id);\n         self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n     }\n \n     fn encode_info_for_item(&mut self, (def_id, item): (DefId, &'tcx hir::Item)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n-        debug!(\"EntryBuilder::encode_info_for_item({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_item({:?})\", def_id);\n \n         let kind = match item.node {\n             hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n@@ -824,7 +1043,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n-                hir::ItemTrait(..) => self.encode_item_variances(def_id),\n+                hir::ItemTrait(..) => self.encode_variances_of(def_id),\n                 _ => LazySeq::empty(),\n             },\n             generics: match item.node {\n@@ -902,224 +1121,38 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             mir: None,\n         }\n     }\n-}\n \n-impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n-    /// In some cases, along with the item itself, we also\n-    /// encode some sub-items. Usually we want some info from the item\n-    /// so it's easier to do that here then to wait until we would encounter\n-    /// normally in the visitor walk.\n-    fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n-        let def_id = self.tcx.hir.local_def_id(item.id);\n-        match item.node {\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) |\n-            hir::ItemExternCrate(..) |\n-            hir::ItemUse(..) |\n-            hir::ItemDefaultImpl(..) |\n-            hir::ItemTy(..) => {\n-                // no sub-item recording needed in these cases\n-            }\n-            hir::ItemEnum(..) => {\n-                self.encode_fields(def_id);\n+    fn encode_info_for_ty_param(&mut self,\n+                                (def_id, Untracked(has_default)): (DefId, Untracked<bool>))\n+                                -> Entry<'tcx> {\n+        debug!(\"IsolatedEncoder::encode_info_for_ty_param({:?})\", def_id);\n+        let tcx = self.tcx;\n+        Entry {\n+            kind: EntryKind::Type,\n+            visibility: self.lazy(&ty::Visibility::Public),\n+            span: self.lazy(&tcx.def_span(def_id)),\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: None,\n+            deprecation: None,\n \n-                let def = self.tcx.adt_def(def_id);\n-                for (i, variant) in def.variants.iter().enumerate() {\n-                    self.record(variant.did,\n-                                EntryBuilder::encode_enum_variant_info,\n-                                (def_id, Untracked(i)));\n-                }\n-            }\n-            hir::ItemStruct(ref struct_def, _) => {\n-                self.encode_fields(def_id);\n+            ty: if has_default {\n+                Some(self.encode_item_type(def_id))\n+            } else {\n+                None\n+            },\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: None,\n+            predicates: None,\n \n-                // If the struct has a constructor, encode it.\n-                if !struct_def.is_struct() {\n-                    let ctor_def_id = self.tcx.hir.local_def_id(struct_def.id());\n-                    self.record(ctor_def_id,\n-                                EntryBuilder::encode_struct_ctor,\n-                                (def_id, ctor_def_id));\n-                }\n-            }\n-            hir::ItemUnion(..) => {\n-                self.encode_fields(def_id);\n-            }\n-            hir::ItemImpl(..) => {\n-                for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n-                    self.record(trait_item_def_id,\n-                                EntryBuilder::encode_info_for_impl_item,\n-                                trait_item_def_id);\n-                }\n-            }\n-            hir::ItemTrait(..) => {\n-                for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n-                    self.record(item_def_id,\n-                                EntryBuilder::encode_info_for_trait_item,\n-                                item_def_id);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n-    fn encode_info_for_foreign_item(&mut self,\n-                                    (def_id, nitem): (DefId, &hir::ForeignItem))\n-                                    -> Entry<'tcx> {\n-        let tcx = self.tcx;\n-\n-        debug!(\"EntryBuilder::encode_info_for_foreign_item({:?})\", def_id);\n-\n-        let kind = match nitem.node {\n-            hir::ForeignItemFn(_, ref names, _) => {\n-                let data = FnData {\n-                    constness: hir::Constness::NotConst,\n-                    arg_names: self.encode_fn_arg_names(names),\n-                };\n-                EntryKind::ForeignFn(self.lazy(&data))\n-            }\n-            hir::ForeignItemStatic(_, true) => EntryKind::ForeignMutStatic,\n-            hir::ForeignItemStatic(_, false) => EntryKind::ForeignImmStatic,\n-        };\n-\n-        Entry {\n-            kind: kind,\n-            visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.id, tcx)),\n-            span: self.lazy(&nitem.span),\n-            attributes: self.encode_attributes(&nitem.attrs),\n-            children: LazySeq::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-\n-            ast: None,\n-            mir: None,\n-        }\n-    }\n-}\n-\n-struct EncodeVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    index: IndexBuilder<'a, 'b, 'tcx>,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.index.tcx.hir)\n-    }\n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n-        intravisit::walk_expr(self, ex);\n-        self.index.encode_info_for_expr(ex);\n-    }\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        intravisit::walk_item(self, item);\n-        let def_id = self.index.tcx.hir.local_def_id(item.id);\n-        match item.node {\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) => (), // ignore these\n-            _ => self.index.record(def_id, EntryBuilder::encode_info_for_item, (def_id, item)),\n-        }\n-        self.index.encode_addl_info_for_item(item);\n-    }\n-    fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n-        intravisit::walk_foreign_item(self, ni);\n-        let def_id = self.index.tcx.hir.local_def_id(ni.id);\n-        self.index.record(def_id,\n-                          EntryBuilder::encode_info_for_foreign_item,\n-                          (def_id, ni));\n-    }\n-    fn visit_variant(&mut self,\n-                     v: &'tcx hir::Variant,\n-                     g: &'tcx hir::Generics,\n-                     id: ast::NodeId) {\n-        intravisit::walk_variant(self, v, g, id);\n-\n-        if let Some(discr) = v.node.disr_expr {\n-            let def_id = self.index.tcx.hir.body_owner_def_id(discr);\n-            self.index.record(def_id, EntryBuilder::encode_info_for_embedded_const, def_id);\n-        }\n-    }\n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        intravisit::walk_generics(self, generics);\n-        self.index.encode_info_for_generics(generics);\n-    }\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        intravisit::walk_ty(self, ty);\n-        self.index.encode_info_for_ty(ty);\n-    }\n-    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n-        let def_id = self.index.tcx.hir.local_def_id(macro_def.id);\n-        self.index.record(def_id, EntryBuilder::encode_info_for_macro_def, macro_def);\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n-    fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n-        for ty_param in &generics.ty_params {\n-            let def_id = self.tcx.hir.local_def_id(ty_param.id);\n-            let has_default = Untracked(ty_param.default.is_some());\n-            self.record(def_id, EntryBuilder::encode_info_for_ty_param, (def_id, has_default));\n-        }\n-    }\n-\n-    fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyImplTrait(_) = ty.node {\n-            let def_id = self.tcx.hir.local_def_id(ty.id);\n-            self.record(def_id, EntryBuilder::encode_info_for_anon_ty, def_id);\n-        }\n-    }\n-\n-    fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n-        match expr.node {\n-            hir::ExprClosure(..) => {\n-                let def_id = self.tcx.hir.local_def_id(expr.id);\n-                self.record(def_id, EntryBuilder::encode_info_for_closure, def_id);\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n-impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n-    fn encode_info_for_ty_param(&mut self,\n-                                (def_id, Untracked(has_default)): (DefId, Untracked<bool>))\n-                                -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_ty_param({:?})\", def_id);\n-        let tcx = self.tcx;\n-        Entry {\n-            kind: EntryKind::Type,\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n-            stability: None,\n-            deprecation: None,\n-\n-            ty: if has_default {\n-                Some(self.encode_item_type(def_id))\n-            } else {\n-                None\n-            },\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n-            generics: None,\n-            predicates: None,\n-\n-            ast: None,\n-            mir: None,\n+            ast: None,\n+            mir: None,\n         }\n     }\n \n     fn encode_info_for_anon_ty(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_anon_ty({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_anon_ty({:?})\", def_id);\n         let tcx = self.tcx;\n         Entry {\n             kind: EntryKind::Type,\n@@ -1142,7 +1175,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_closure(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_closure({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_closure({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let data = ClosureData {\n@@ -1171,7 +1204,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_embedded_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_embedded_const({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_embedded_const({:?})\", def_id);\n         let tcx = self.tcx;\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         let body = tcx.hir.body_owned_by(id);\n@@ -1198,154 +1231,70 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n \n     fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n         // NOTE: This must use lazy_seq_from_slice(), not lazy_seq() because\n-        //       we really on the HashStable specialization for [Attribute]\n+        //       we rely on the HashStable specialization for [Attribute]\n         //       to properly filter things out.\n         self.lazy_seq_from_slice(attrs)\n     }\n-}\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn encode_info_for_items(&mut self) -> Index {\n-        let krate = self.tcx.hir.krate();\n-        let mut index = IndexBuilder::new(self);\n-        index.record(DefId::local(CRATE_DEF_INDEX),\n-                     EntryBuilder::encode_info_for_mod,\n-                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n-        let mut visitor = EncodeVisitor { index: index };\n-        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n-        for macro_def in &krate.exported_macros {\n-            visitor.visit_macro_def(macro_def);\n-        }\n-        visitor.index.into_items()\n+    fn encode_native_libraries(&mut self, _: ()) -> LazySeq<NativeLibrary> {\n+        let used_libraries = self.tcx.sess.cstore.used_libraries();\n+        self.lazy_seq(used_libraries)\n     }\n \n-    fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n-        fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n-            // Pull the cnums and name,vers,hash out of cstore\n-            let mut deps = Vec::new();\n-            cstore.iter_crate_data(|cnum, val| {\n-                deps.push((cnum, val.clone()));\n-            });\n+    fn encode_crate_deps(&mut self, _: ()) -> LazySeq<CrateDep> {\n+        let cstore = &*self.tcx.sess.cstore;\n+        let crates = cstore.crates();\n+\n+        let mut deps = crates\n+            .iter()\n+            .map(|&cnum| {\n+                let dep = CrateDep {\n+                    name: cstore.original_crate_name(cnum),\n+                    hash: cstore.crate_hash(cnum),\n+                    kind: cstore.dep_kind(cnum),\n+                };\n+                (cnum, dep)\n+            })\n+            .collect::<Vec<_>>();\n \n-            // Sort by cnum\n-            deps.sort_by(|kv1, kv2| kv1.0.cmp(&kv2.0));\n+        deps.sort_by_key(|&(cnum, _)| cnum);\n \n+        {\n             // Sanity-check the crate numbers\n             let mut expected_cnum = 1;\n             for &(n, _) in &deps {\n                 assert_eq!(n, CrateNum::new(expected_cnum));\n                 expected_cnum += 1;\n             }\n-\n-            deps\n         }\n \n         // We're just going to write a list of crate 'name-hash-version's, with\n         // the assumption that they are numbered 1 to n.\n         // FIXME (#2166): This is not nearly enough to support correct versioning\n         // but is enough to get transitive crate dependencies working.\n-        let deps = get_ordered_deps(self.cstore);\n-        self.lazy_seq(deps.iter().map(|&(_, ref dep)| {\n-            CrateDep {\n-                name: dep.name(),\n-                hash: dep.hash(),\n-                kind: dep.dep_kind.get(),\n-            }\n-        }))\n+        self.lazy_seq_ref(deps.iter().map(|&(_, ref dep)| dep))\n     }\n \n-    fn encode_lang_items(&mut self) -> (LazySeq<(DefIndex, usize)>, LazySeq<lang_items::LangItem>) {\n+    fn encode_lang_items(&mut self, _: ()) -> LazySeq<(DefIndex, usize)> {\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items.items().iter();\n-        (self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n+        self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n             if let Some(def_id) = opt_def_id {\n                 if def_id.is_local() {\n                     return Some((def_id.index, i));\n                 }\n             }\n             None\n-        })),\n-         self.lazy_seq_ref(&tcx.lang_items.missing))\n-    }\n-\n-    fn encode_native_libraries(&mut self) -> LazySeq<NativeLibrary> {\n-        let used_libraries = self.tcx.sess.cstore.used_libraries();\n-        self.lazy_seq(used_libraries)\n-    }\n-\n-    fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n-        let codemap = self.tcx.sess.codemap();\n-        let all_filemaps = codemap.files.borrow();\n-        let adapted = all_filemaps.iter()\n-            .filter(|filemap| {\n-                // No need to re-export imported filemaps, as any downstream\n-                // crate will import them from their original source.\n-                !filemap.is_imported()\n-            })\n-            .map(|filemap| {\n-                // When exporting FileMaps, we expand all paths to absolute\n-                // paths because any relative paths are potentially relative to\n-                // a wrong directory.\n-                // However, if a path has been modified via\n-                // `-Zremap-path-prefix` we assume the user has already set\n-                // things up the way they want and don't touch the path values\n-                // anymore.\n-                let name = Path::new(&filemap.name);\n-                let (ref working_dir, working_dir_was_remapped) = self.tcx.sess.working_dir;\n-                if filemap.name_was_remapped ||\n-                   (name.is_relative() && working_dir_was_remapped) {\n-                    // This path of this FileMap has been modified by\n-                    // path-remapping, so we use it verbatim (and avoid cloning\n-                    // the whole map in the process).\n-                    filemap.clone()\n-                } else {\n-                    let mut adapted = (**filemap).clone();\n-                    let abs_path = Path::new(working_dir).join(name)\n-                                                         .to_string_lossy()\n-                                                         .into_owned();\n-                    adapted.name = abs_path;\n-                    Rc::new(adapted)\n-                }\n-            })\n-            .collect::<Vec<_>>();\n-\n-        self.lazy_seq_ref(adapted.iter().map(|fm| &**fm))\n-    }\n-\n-    fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n-        let definitions = self.tcx.hir.definitions();\n-        self.lazy(definitions.def_path_table())\n-    }\n-}\n-\n-struct ImplVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    impls: FxHashMap<DefId, Vec<DefIndex>>,\n-}\n-\n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemImpl(..) = item.node {\n-            let impl_id = self.tcx.hir.local_def_id(item.id);\n-            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n-                self.impls\n-                    .entry(trait_ref.def_id)\n-                    .or_insert(vec![])\n-                    .push(impl_id.index);\n-            }\n-        }\n+        }))\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &'v hir::TraitItem) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n-        // handled in `visit_item` above\n+    fn encode_lang_items_missing(&mut self, _: ()) -> LazySeq<lang_items::LangItem> {\n+        let tcx = self.tcx;\n+        self.lazy_seq_ref(&tcx.lang_items.missing)\n     }\n-}\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// Encodes an index, mapping each trait to its (local) implementations.\n-    fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n+    fn encode_impls(&mut self, _: ()) -> LazySeq<TraitImpls> {\n         let mut visitor = ImplVisitor {\n             tcx: self.tcx,\n             impls: FxHashMap(),\n@@ -1371,13 +1320,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     // middle::reachable module but filters out items that either don't have a\n     // symbol associated with them (they weren't translated) or if they're an FFI\n     // definition (as that's not defined in this crate).\n-    fn encode_exported_symbols(&mut self) -> LazySeq<DefIndex> {\n-        let exported_symbols = self.exported_symbols;\n+    fn encode_exported_symbols(&mut self, exported_symbols: &NodeSet) -> LazySeq<DefIndex> {\n         let tcx = self.tcx;\n         self.lazy_seq(exported_symbols.iter().map(|&id| tcx.hir.local_def_id(id).index))\n     }\n \n-    fn encode_dylib_dependency_formats(&mut self) -> LazySeq<Option<LinkagePreference>> {\n+    fn encode_dylib_dependency_formats(&mut self, _: ()) -> LazySeq<Option<LinkagePreference>> {\n         match self.tcx.sess.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n             Some(arr) => {\n                 self.lazy_seq(arr.iter().map(|slot| {\n@@ -1393,111 +1341,221 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             None => LazySeq::empty(),\n         }\n     }\n-}\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {\n-        let mut i = self.position();\n-        let crate_deps = self.encode_crate_deps();\n-        let dylib_dependency_formats = self.encode_dylib_dependency_formats();\n-        let dep_bytes = self.position() - i;\n+    fn encode_info_for_foreign_item(&mut self,\n+                                    (def_id, nitem): (DefId, &hir::ForeignItem))\n+                                    -> Entry<'tcx> {\n+        let tcx = self.tcx;\n \n-        // Encode the language items.\n-        i = self.position();\n-        let (lang_items, lang_items_missing) = self.encode_lang_items();\n-        let lang_item_bytes = self.position() - i;\n+        debug!(\"IsolatedEncoder::encode_info_for_foreign_item({:?})\", def_id);\n \n-        // Encode the native libraries used\n-        i = self.position();\n-        let native_libraries = self.encode_native_libraries();\n-        let native_lib_bytes = self.position() - i;\n+        let kind = match nitem.node {\n+            hir::ForeignItemFn(_, ref names, _) => {\n+                let data = FnData {\n+                    constness: hir::Constness::NotConst,\n+                    arg_names: self.encode_fn_arg_names(names),\n+                };\n+                EntryKind::ForeignFn(self.lazy(&data))\n+            }\n+            hir::ForeignItemStatic(_, true) => EntryKind::ForeignMutStatic,\n+            hir::ForeignItemStatic(_, false) => EntryKind::ForeignImmStatic,\n+        };\n \n-        // Encode codemap\n-        i = self.position();\n-        let codemap = self.encode_codemap();\n-        let codemap_bytes = self.position() - i;\n+        Entry {\n+            kind: kind,\n+            visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.id, tcx)),\n+            span: self.lazy(&nitem.span),\n+            attributes: self.encode_attributes(&nitem.attrs),\n+            children: LazySeq::empty(),\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n \n-        // Encode DefPathTable\n-        i = self.position();\n-        let def_path_table = self.encode_def_path_table();\n-        let def_path_table_bytes = self.position() - i;\n+            ty: Some(self.encode_item_type(def_id)),\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n \n-        // Encode the def IDs of impls, for coherence checking.\n-        i = self.position();\n-        let impls = self.encode_impls();\n-        let impl_bytes = self.position() - i;\n+            ast: None,\n+            mir: None,\n+        }\n+    }\n+}\n \n-        // Encode exported symbols info.\n-        i = self.position();\n-        let exported_symbols = self.encode_exported_symbols();\n-        let exported_symbols_bytes = self.position() - i;\n+struct EncodeVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+    index: IndexBuilder<'a, 'b, 'tcx>,\n+}\n \n-        // Encode and index the items.\n-        i = self.position();\n-        let items = self.encode_info_for_items();\n-        let item_bytes = self.position() - i;\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.index.tcx.hir)\n+    }\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n+        intravisit::walk_expr(self, ex);\n+        self.index.encode_info_for_expr(ex);\n+    }\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        intravisit::walk_item(self, item);\n+        let def_id = self.index.tcx.hir.local_def_id(item.id);\n+        match item.node {\n+            hir::ItemExternCrate(_) |\n+            hir::ItemUse(..) => (), // ignore these\n+            _ => self.index.record(def_id, IsolatedEncoder::encode_info_for_item, (def_id, item)),\n+        }\n+        self.index.encode_addl_info_for_item(item);\n+    }\n+    fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n+        intravisit::walk_foreign_item(self, ni);\n+        let def_id = self.index.tcx.hir.local_def_id(ni.id);\n+        self.index.record(def_id,\n+                          IsolatedEncoder::encode_info_for_foreign_item,\n+                          (def_id, ni));\n+    }\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     id: ast::NodeId) {\n+        intravisit::walk_variant(self, v, g, id);\n \n-        i = self.position();\n-        let index = items.write_index(&mut self.opaque.cursor);\n-        let index_bytes = self.position() - i;\n+        if let Some(discr) = v.node.disr_expr {\n+            let def_id = self.index.tcx.hir.body_owner_def_id(discr);\n+            self.index.record(def_id, IsolatedEncoder::encode_info_for_embedded_const, def_id);\n+        }\n+    }\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+        intravisit::walk_generics(self, generics);\n+        self.index.encode_info_for_generics(generics);\n+    }\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        intravisit::walk_ty(self, ty);\n+        self.index.encode_info_for_ty(ty);\n+    }\n+    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n+        let def_id = self.index.tcx.hir.local_def_id(macro_def.id);\n+        self.index.record(def_id, IsolatedEncoder::encode_info_for_macro_def, macro_def);\n+    }\n+}\n \n-        let tcx = self.tcx;\n-        let link_meta = self.link_meta;\n-        let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n-        let root = self.lazy(&CrateRoot {\n-            name: tcx.crate_name(LOCAL_CRATE),\n-            triple: tcx.sess.opts.target_triple.clone(),\n-            hash: link_meta.crate_hash,\n-            disambiguator: tcx.sess.local_crate_disambiguator(),\n-            panic_strategy: tcx.sess.panic_strategy(),\n-            plugin_registrar_fn: tcx.sess\n-                .plugin_registrar_fn\n-                .get()\n-                .map(|id| tcx.hir.local_def_id(id).index),\n-            macro_derive_registrar: if is_proc_macro {\n-                let id = tcx.sess.derive_registrar_fn.get().unwrap();\n-                Some(tcx.hir.local_def_id(id).index)\n-            } else {\n-                None\n-            },\n+impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n+    fn encode_fields(&mut self, adt_def_id: DefId) {\n+        let def = self.tcx.adt_def(adt_def_id);\n+        for (variant_index, variant) in def.variants.iter().enumerate() {\n+            for (field_index, field) in variant.fields.iter().enumerate() {\n+                self.record(field.did,\n+                            IsolatedEncoder::encode_field,\n+                            (adt_def_id, Untracked((variant_index, field_index))));\n+            }\n+        }\n+    }\n \n-            crate_deps: crate_deps,\n-            dylib_dependency_formats: dylib_dependency_formats,\n-            lang_items: lang_items,\n-            lang_items_missing: lang_items_missing,\n-            native_libraries: native_libraries,\n-            codemap: codemap,\n-            def_path_table: def_path_table,\n-            impls: impls,\n-            exported_symbols: exported_symbols,\n-            index: index,\n-        });\n+    fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n+        for ty_param in &generics.ty_params {\n+            let def_id = self.tcx.hir.local_def_id(ty_param.id);\n+            let has_default = Untracked(ty_param.default.is_some());\n+            self.record(def_id, IsolatedEncoder::encode_info_for_ty_param, (def_id, has_default));\n+        }\n+    }\n \n-        let total_bytes = self.position();\n+    fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n+        if let hir::TyImplTrait(_) = ty.node {\n+            let def_id = self.tcx.hir.local_def_id(ty.id);\n+            self.record(def_id, IsolatedEncoder::encode_info_for_anon_ty, def_id);\n+        }\n+    }\n \n-        if self.tcx.sess.meta_stats() {\n-            let mut zero_bytes = 0;\n-            for e in self.opaque.cursor.get_ref() {\n-                if *e == 0 {\n-                    zero_bytes += 1;\n+    fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n+        match expr.node {\n+            hir::ExprClosure(..) => {\n+                let def_id = self.tcx.hir.local_def_id(expr.id);\n+                self.record(def_id, IsolatedEncoder::encode_info_for_closure, def_id);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    /// In some cases, along with the item itself, we also\n+    /// encode some sub-items. Usually we want some info from the item\n+    /// so it's easier to do that here then to wait until we would encounter\n+    /// normally in the visitor walk.\n+    fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n+        let def_id = self.tcx.hir.local_def_id(item.id);\n+        match item.node {\n+            hir::ItemStatic(..) |\n+            hir::ItemConst(..) |\n+            hir::ItemFn(..) |\n+            hir::ItemMod(..) |\n+            hir::ItemForeignMod(..) |\n+            hir::ItemGlobalAsm(..) |\n+            hir::ItemExternCrate(..) |\n+            hir::ItemUse(..) |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemTy(..) => {\n+                // no sub-item recording needed in these cases\n+            }\n+            hir::ItemEnum(..) => {\n+                self.encode_fields(def_id);\n+\n+                let def = self.tcx.adt_def(def_id);\n+                for (i, variant) in def.variants.iter().enumerate() {\n+                    self.record(variant.did,\n+                                IsolatedEncoder::encode_enum_variant_info,\n+                                (def_id, Untracked(i)));\n                 }\n             }\n+            hir::ItemStruct(ref struct_def, _) => {\n+                self.encode_fields(def_id);\n \n-            println!(\"metadata stats:\");\n-            println!(\"             dep bytes: {}\", dep_bytes);\n-            println!(\"       lang item bytes: {}\", lang_item_bytes);\n-            println!(\"          native bytes: {}\", native_lib_bytes);\n-            println!(\"         codemap bytes: {}\", codemap_bytes);\n-            println!(\"            impl bytes: {}\", impl_bytes);\n-            println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n-            println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n-            println!(\"            item bytes: {}\", item_bytes);\n-            println!(\"           index bytes: {}\", index_bytes);\n-            println!(\"            zero bytes: {}\", zero_bytes);\n-            println!(\"           total bytes: {}\", total_bytes);\n+                // If the struct has a constructor, encode it.\n+                if !struct_def.is_struct() {\n+                    let ctor_def_id = self.tcx.hir.local_def_id(struct_def.id());\n+                    self.record(ctor_def_id,\n+                                IsolatedEncoder::encode_struct_ctor,\n+                                (def_id, ctor_def_id));\n+                }\n+            }\n+            hir::ItemUnion(..) => {\n+                self.encode_fields(def_id);\n+            }\n+            hir::ItemImpl(..) => {\n+                for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n+                    self.record(trait_item_def_id,\n+                                IsolatedEncoder::encode_info_for_impl_item,\n+                                trait_item_def_id);\n+                }\n+            }\n+            hir::ItemTrait(..) => {\n+                for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n+                    self.record(item_def_id,\n+                                IsolatedEncoder::encode_info_for_trait_item,\n+                                item_def_id);\n+                }\n+            }\n         }\n+    }\n+}\n \n-        root\n+struct ImplVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    impls: FxHashMap<DefId, Vec<DefIndex>>,\n+}\n+\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        if let hir::ItemImpl(..) = item.node {\n+            let impl_id = self.tcx.hir.local_def_id(item.id);\n+            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n+                self.impls\n+                    .entry(trait_ref.def_id)\n+                    .or_insert(vec![])\n+                    .push(impl_id.index);\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &'v hir::TraitItem) {}\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n+        // handled in `visit_item` above\n     }\n }\n \n@@ -1525,28 +1583,31 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n // generated regardless of trailing bytes that end up in it.\n \n pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 cstore: &cstore::CStore,\n                                  link_meta: &LinkMeta,\n                                  exported_symbols: &NodeSet)\n                                  -> EncodedMetadata\n {\n     let mut cursor = Cursor::new(vec![]);\n     cursor.write_all(METADATA_HEADER).unwrap();\n \n-    // Will be filed with the root position after encoding everything.\n+    // Will be filled with the root position after encoding everything.\n     cursor.write_all(&[0, 0, 0, 0]).unwrap();\n \n+     let compute_ich = (tcx.sess.opts.debugging_opts.query_dep_graph ||\n+                        tcx.sess.opts.debugging_opts.incremental_cc) &&\n+                        tcx.sess.opts.build_dep_graph();\n+\n     let (root, metadata_hashes) = {\n         let mut ecx = EncodeContext {\n             opaque: opaque::Encoder::new(&mut cursor),\n             tcx: tcx,\n             link_meta: link_meta,\n-            cstore: cstore,\n             exported_symbols: exported_symbols,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n-            metadata_hashes: Vec::new(),\n+            metadata_hashes: EncodedMetadataHashes::new(),\n+            compute_ich: compute_ich,\n         };\n \n         // Encode the rustc version string in a predictable location."}, {"sha": "478202aeba4449db284369d45fa876f3c9d835f8", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 10, "deletions": 112, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -58,20 +58,16 @@\n use encoder::EncodeContext;\n use index::Index;\n use schema::*;\n+use isolated_encoder::IsolatedEncoder;\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::ich::{StableHashingContext, Fingerprint};\n use rustc::middle::cstore::EncodedMetadataHash;\n use rustc::ty::TyCtxt;\n use syntax::ast;\n \n use std::ops::{Deref, DerefMut};\n \n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-use rustc_serialize::Encodable;\n-\n /// Builder that can encode new items, adding them into the index.\n /// Item encoding cannot be nested.\n pub struct IndexBuilder<'a, 'b: 'a, 'tcx: 'b> {\n@@ -119,7 +115,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// content system.\n     pub fn record<'x, DATA>(&'x mut self,\n                             id: DefId,\n-                            op: fn(&mut EntryBuilder<'x, 'b, 'tcx>, DATA) -> Entry<'tcx>,\n+                            op: fn(&mut IsolatedEncoder<'x, 'b, 'tcx>, DATA) -> Entry<'tcx>,\n                             data: DATA)\n         where DATA: DepGraphRead\n     {\n@@ -132,29 +128,19 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         // unclear whether that would be a win since hashing is cheap enough.\n         let _task = tcx.dep_graph.in_ignore();\n \n-        let compute_ich = (tcx.sess.opts.debugging_opts.query_dep_graph ||\n-                           tcx.sess.opts.debugging_opts.incremental_cc) &&\n-                           tcx.sess.opts.build_dep_graph();\n-\n         let ecx: &'x mut EncodeContext<'b, 'tcx> = &mut *self.ecx;\n-        let mut entry_builder = EntryBuilder {\n-            tcx: tcx,\n-            ecx: ecx,\n-            hcx: if compute_ich {\n-                Some((StableHashingContext::new(tcx), StableHasher::new()))\n-            } else {\n-                None\n-            }\n-        };\n-\n+        let mut entry_builder = IsolatedEncoder::new(ecx);\n         let entry = op(&mut entry_builder, data);\n+        let entry = entry_builder.lazy(&entry);\n \n-        if let Some((ref mut hcx, ref mut hasher)) = entry_builder.hcx {\n-            entry.hash_stable(hcx, hasher);\n+        let (fingerprint, ecx) = entry_builder.finish();\n+        if let Some(hash) = fingerprint {\n+            ecx.metadata_hashes.entry_hashes.push(EncodedMetadataHash {\n+                def_index: id.index,\n+                hash: hash,\n+            });\n         }\n \n-        let entry = entry_builder.ecx.lazy(&entry);\n-        entry_builder.finish(id);\n         self.items.record(id, entry);\n     }\n \n@@ -257,91 +243,3 @@ impl<T> DepGraphRead for FromId<T> {\n         tcx.hir.read(self.0);\n     }\n }\n-\n-pub struct EntryBuilder<'a, 'b: 'a, 'tcx: 'b> {\n-    pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-    ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    hcx: Option<(StableHashingContext<'b, 'tcx>, StableHasher<Fingerprint>)>,\n-}\n-\n-impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n-\n-    pub fn finish(self, def_id: DefId) {\n-        if let Some((_, hasher)) = self.hcx {\n-            let hash = hasher.finish();\n-            self.ecx.metadata_hashes.push(EncodedMetadataHash {\n-                def_index: def_id.index,\n-                hash: hash,\n-            });\n-        }\n-    }\n-\n-    pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n-    {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            value.hash_stable(hcx, hasher);\n-            debug!(\"metadata-hash: {:?}\", hasher);\n-        }\n-        self.ecx.lazy(value)\n-    }\n-\n-    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = T>,\n-              T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n-    {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            let iter = iter.into_iter();\n-            let (lower_bound, upper_bound) = iter.size_hint();\n-\n-            if upper_bound == Some(lower_bound) {\n-                lower_bound.hash_stable(hcx, hasher);\n-                let mut num_items_hashed = 0;\n-                let ret = self.ecx.lazy_seq(iter.inspect(|item| {\n-                    item.hash_stable(hcx, hasher);\n-                    num_items_hashed += 1;\n-                }));\n-\n-                // Sometimes items in a sequence are filtered out without being\n-                // hashed (e.g. for &[ast::Attribute]) and this code path cannot\n-                // handle that correctly, so we want to make sure we didn't hit\n-                // it by accident.\n-                if lower_bound != num_items_hashed {\n-                    bug!(\"Hashed a different number of items ({}) than expected ({})\",\n-                         num_items_hashed,\n-                         lower_bound);\n-                }\n-                debug!(\"metadata-hash: {:?}\", hasher);\n-                ret\n-            } else {\n-                // Collect into a vec so we know the length of the sequence\n-                let items: AccumulateVec<[T; 32]> = iter.collect();\n-                items.hash_stable(hcx, hasher);\n-                debug!(\"metadata-hash: {:?}\", hasher);\n-                self.ecx.lazy_seq(items)\n-            }\n-        } else {\n-            self.ecx.lazy_seq(iter)\n-        }\n-    }\n-\n-    pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n-    {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            slice.hash_stable(hcx, hasher);\n-            debug!(\"metadata-hash: {:?}\", hasher);\n-        }\n-        self.ecx.lazy_seq_ref(slice.iter())\n-    }\n-\n-    pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n-    {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            slice.hash_stable(hcx, hasher);\n-            debug!(\"metadata-hash: {:?}\", hasher);\n-        }\n-        self.ecx.lazy_seq_ref(slice.iter().map(|x| *x))\n-    }\n-}"}, {"sha": "7722a7b10c99658ec817e075ef35e1e922de4d35", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,160 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use encoder::EncodeContext;\n+use schema::{Lazy, LazySeq};\n+\n+use rustc::ich::{StableHashingContext, Fingerprint};\n+use rustc::ty::TyCtxt;\n+\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+use rustc_serialize::Encodable;\n+\n+/// The IsolatedEncoder provides facilities to write to crate metadata while\n+/// making sure that anything going through it is also feed into an ICH hasher.\n+pub struct IsolatedEncoder<'a, 'b: 'a, 'tcx: 'b> {\n+    pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+    ecx: &'a mut EncodeContext<'b, 'tcx>,\n+    hcx: Option<(StableHashingContext<'b, 'tcx>, StableHasher<Fingerprint>)>,\n+}\n+\n+impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n+\n+    pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n+        let tcx = ecx.tcx;\n+        let compute_ich = ecx.compute_ich;\n+        IsolatedEncoder {\n+            tcx: tcx,\n+            ecx: ecx,\n+            hcx: if compute_ich {\n+                Some((StableHashingContext::new(tcx), StableHasher::new()))\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    pub fn finish(self) -> (Option<Fingerprint>, &'a mut EncodeContext<'b, 'tcx>) {\n+        if let Some((_, hasher)) = self.hcx {\n+            (Some(hasher.finish()), self.ecx)\n+        } else {\n+            (None, self.ecx)\n+        }\n+    }\n+\n+    pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            value.hash_stable(hcx, hasher);\n+            debug!(\"metadata-hash: {:?}\", hasher);\n+        }\n+        self.ecx.lazy(value)\n+    }\n+\n+    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n+        where I: IntoIterator<Item = T>,\n+              T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            let iter = iter.into_iter();\n+            let (lower_bound, upper_bound) = iter.size_hint();\n+\n+            if upper_bound == Some(lower_bound) {\n+                lower_bound.hash_stable(hcx, hasher);\n+                let mut num_items_hashed = 0;\n+                let ret = self.ecx.lazy_seq(iter.inspect(|item| {\n+                    item.hash_stable(hcx, hasher);\n+                    num_items_hashed += 1;\n+                }));\n+\n+                // Sometimes items in a sequence are filtered out without being\n+                // hashed (e.g. for &[ast::Attribute]) and this code path cannot\n+                // handle that correctly, so we want to make sure we didn't hit\n+                // it by accident.\n+                if lower_bound != num_items_hashed {\n+                    bug!(\"Hashed a different number of items ({}) than expected ({})\",\n+                         num_items_hashed,\n+                         lower_bound);\n+                }\n+                debug!(\"metadata-hash: {:?}\", hasher);\n+                ret\n+            } else {\n+                // Collect into a vec so we know the length of the sequence\n+                let items: AccumulateVec<[T; 32]> = iter.collect();\n+                items.hash_stable(hcx, hasher);\n+                debug!(\"metadata-hash: {:?}\", hasher);\n+                self.ecx.lazy_seq(items)\n+            }\n+        } else {\n+            self.ecx.lazy_seq(iter)\n+        }\n+    }\n+\n+    pub fn lazy_seq_ref<'x, I, T>(&mut self, iter: I) -> LazySeq<T>\n+        where I: IntoIterator<Item = &'x T>,\n+              T: 'x + Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            let iter = iter.into_iter();\n+            let (lower_bound, upper_bound) = iter.size_hint();\n+\n+            if upper_bound == Some(lower_bound) {\n+                lower_bound.hash_stable(hcx, hasher);\n+                let mut num_items_hashed = 0;\n+                let ret = self.ecx.lazy_seq_ref(iter.inspect(|item| {\n+                    item.hash_stable(hcx, hasher);\n+                    num_items_hashed += 1;\n+                }));\n+\n+                // Sometimes items in a sequence are filtered out without being\n+                // hashed (e.g. for &[ast::Attribute]) and this code path cannot\n+                // handle that correctly, so we want to make sure we didn't hit\n+                // it by accident.\n+                if lower_bound != num_items_hashed {\n+                    bug!(\"Hashed a different number of items ({}) than expected ({})\",\n+                         num_items_hashed,\n+                         lower_bound);\n+                }\n+                debug!(\"metadata-hash: {:?}\", hasher);\n+                ret\n+            } else {\n+                // Collect into a vec so we know the length of the sequence\n+                let items: AccumulateVec<[&'x T; 32]> = iter.collect();\n+                items.hash_stable(hcx, hasher);\n+                debug!(\"metadata-hash: {:?}\", hasher);\n+                self.ecx.lazy_seq_ref(items.iter().map(|x| *x))\n+            }\n+        } else {\n+            self.ecx.lazy_seq_ref(iter)\n+        }\n+    }\n+\n+    pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            slice.hash_stable(hcx, hasher);\n+            debug!(\"metadata-hash: {:?}\", hasher);\n+        }\n+        self.ecx.lazy_seq_ref(slice.iter())\n+    }\n+\n+    pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            slice.hash_stable(hcx, hasher);\n+            debug!(\"metadata-hash: {:?}\", hasher);\n+        }\n+        self.ecx.lazy_seq_ref(slice.iter().map(|x| *x))\n+    }\n+}"}, {"sha": "90eb2bc0f6a7dae31ed100e036ce467b3b6219b0", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -57,6 +57,7 @@ mod index;\n mod encoder;\n mod decoder;\n mod cstore_impl;\n+mod isolated_encoder;\n mod schema;\n \n pub mod creader;"}, {"sha": "84bb82de370e4f55f5e4635060d8ccde38fa4dc9", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -367,7 +367,7 @@ impl<'a> Context<'a> {\n                 && self.triple != config::host_triple() {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n             }\n-            err.span_label(self.span, &format!(\"can't find crate\"));\n+            err.span_label(self.span, \"can't find crate\");\n             err\n         };\n "}, {"sha": "5abe1adfb6f359ff9478af0ec7cc5d670cff4757", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -13,7 +13,7 @@ use index;\n \n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n-use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::hir::def_id::{DefIndex, DefId, CrateNum};\n use rustc::ich::StableHashingContext;\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n@@ -32,6 +32,8 @@ use std::mem;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n                                            StableHasherResult};\n \n+use rustc::dep_graph::{DepGraph, DepNode};\n+\n pub fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n@@ -186,25 +188,59 @@ pub enum LazyState {\n     Previous(usize),\n }\n \n+/// A `Tracked<T>` wraps a value so that one can only access it when specifying\n+/// the `DepNode` for that value. This makes it harder to forget registering\n+/// reads.\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct Tracked<T> {\n+    state: T,\n+}\n+\n+impl<T> Tracked<T> {\n+    pub fn new(state: T) -> Tracked<T> {\n+        Tracked {\n+            state: state,\n+        }\n+    }\n+\n+    pub fn get(&self, dep_graph: &DepGraph, dep_node: DepNode<DefId>) -> &T {\n+        dep_graph.read(dep_node);\n+        &self.state\n+    }\n+\n+    pub fn get_untracked(&self) -> &T {\n+        &self.state\n+    }\n+\n+    pub fn map<F, R>(&self, f: F) -> Tracked<R>\n+        where F: FnOnce(&T) -> R\n+    {\n+        Tracked {\n+            state: f(&self.state),\n+        }\n+    }\n+}\n+\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct CrateRoot {\n     pub name: Symbol,\n     pub triple: String,\n     pub hash: hir::svh::Svh,\n     pub disambiguator: Symbol,\n-    pub panic_strategy: PanicStrategy,\n+    pub panic_strategy: Tracked<PanicStrategy>,\n     pub plugin_registrar_fn: Option<DefIndex>,\n     pub macro_derive_registrar: Option<DefIndex>,\n \n-    pub crate_deps: LazySeq<CrateDep>,\n-    pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,\n-    pub lang_items: LazySeq<(DefIndex, usize)>,\n-    pub lang_items_missing: LazySeq<lang_items::LangItem>,\n-    pub native_libraries: LazySeq<NativeLibrary>,\n+    pub crate_deps: Tracked<LazySeq<CrateDep>>,\n+    pub dylib_dependency_formats: Tracked<LazySeq<Option<LinkagePreference>>>,\n+    pub lang_items: Tracked<LazySeq<(DefIndex, usize)>>,\n+    pub lang_items_missing: Tracked<LazySeq<lang_items::LangItem>>,\n+    pub native_libraries: Tracked<LazySeq<NativeLibrary>>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n-    pub impls: LazySeq<TraitImpls>,\n-    pub exported_symbols: LazySeq<DefIndex>,\n+    pub impls: Tracked<LazySeq<TraitImpls>>,\n+    pub exported_symbols: Tracked<LazySeq<DefIndex>>,\n     pub index: LazySeq<index::Index>,\n }\n \n@@ -215,12 +251,35 @@ pub struct CrateDep {\n     pub kind: DepKind,\n }\n \n+impl_stable_hash_for!(struct CrateDep {\n+    name,\n+    hash,\n+    kind\n+});\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n     pub impls: LazySeq<DefIndex>,\n }\n \n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for TraitImpls {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let TraitImpls {\n+            trait_id: (krate, def_index),\n+            ref impls,\n+        } = *self;\n+\n+        DefId {\n+            krate: CrateNum::from_u32(krate),\n+            index: def_index\n+        }.hash_stable(hcx, hasher);\n+        impls.hash_stable(hcx, hasher);\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,"}, {"sha": "0d592b4d72be5b11df3d9ddd232ca0fa39cb921b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -242,9 +242,9 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                    to the crate attributes to enable\");\n         } else {\n             self.find_drop_implementation_method_span()\n-                .map(|span| err.span_label(span, &format!(\"destructor defined here\")));\n+                .map(|span| err.span_label(span, \"destructor defined here\"));\n \n-            err.span_label(self.span, &format!(\"constants cannot have destructors\"));\n+            err.span_label(self.span, \"constants cannot have destructors\");\n         }\n \n         err.emit();\n@@ -291,8 +291,8 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 \"cannot refer to statics by value, use a constant instead\"\n             };\n             struct_span_err!(self.tcx.sess, self.span, E0394, \"{}\", msg)\n-                .span_label(self.span, &format!(\"referring to another static by value\"))\n-                .note(&format!(\"use the address-of operator or a constant instead\"))\n+                .span_label(self.span, \"referring to another static by value\")\n+                .note(\"use the address-of operator or a constant instead\")\n                 .emit();\n \n             // Replace STATIC with NOT_CONST to avoid further errors.\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                         \"raw pointers cannot be dereferenced in {}s\",\n                                         this.mode)\n                                     .span_label(this.span,\n-                                        &format!(\"dereference of raw pointer in constant\"))\n+                                        \"dereference of raw pointer in constant\")\n                                     .emit();\n                                 }\n                             }\n@@ -645,7 +645,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             struct_span_err!(self.tcx.sess,  self.span, E0017,\n                                              \"references in {}s may only refer \\\n                                               to immutable values\", self.mode)\n-                                .span_label(self.span, &format!(\"{}s require immutable values\",\n+                                .span_label(self.span, format!(\"{}s require immutable values\",\n                                                                 self.mode))\n                                 .emit();\n                         }\n@@ -713,7 +713,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             self.mode)\n                         .span_label(\n                             self.span,\n-                            &format!(\"comparing raw pointers in static\"))\n+                            \"comparing raw pointers in static\")\n                         .emit();\n                     }\n                 }\n@@ -724,7 +724,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 if self.mode != Mode::Fn {\n                     struct_span_err!(self.tcx.sess, self.span, E0010,\n                                      \"allocations are not allowed in {}s\", self.mode)\n-                        .span_label(self.span, &format!(\"allocation not allowed in {}s\", self.mode))\n+                        .span_label(self.span, format!(\"allocation not allowed in {}s\", self.mode))\n                         .emit();\n                 }\n             }"}, {"sha": "14f277d1767bbc3faf3915ddec606226c46d6327", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -13,6 +13,7 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::*;\n use rustc::mir::transform::{MirSuite, MirPassIndex, MirSource};\n use rustc::ty::TyCtxt;\n+use rustc::ty::item_path;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx};\n use std::fmt::Display;\n@@ -48,7 +49,9 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return;\n     }\n \n-    let node_path = tcx.item_path_str(tcx.hir.local_def_id(source.item_id()));\n+    let node_path = item_path::with_forced_impl_filename_line(|| { // see notes on #41697 below\n+        tcx.item_path_str(tcx.hir.local_def_id(source.item_id()))\n+    });\n     dump_matched_mir_node(tcx, pass_num, pass_name, &node_path,\n                           disambiguator, source, mir);\n     for (index, promoted_mir) in mir.promoted.iter_enumerated() {\n@@ -67,7 +70,9 @@ pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Some(ref filters) => filters,\n     };\n     let node_id = source.item_id();\n-    let node_path = tcx.item_path_str(tcx.hir.local_def_id(node_id));\n+    let node_path = item_path::with_forced_impl_filename_line(|| { // see notes on #41697 below\n+        tcx.item_path_str(tcx.hir.local_def_id(node_id))\n+    });\n     filters.split(\"&\")\n            .any(|filter| {\n                filter == \"all\" ||\n@@ -76,6 +81,10 @@ pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            })\n }\n \n+// #41697 -- we use `with_forced_impl_filename_line()` because\n+// `item_path_str()` would otherwise trigger `type_of`, and this can\n+// run while we are already attempting to evaluate `type_of`.\n+\n fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    pass_num: Option<(MirSuite, MirPassIndex)>,\n                                    pass_name: &str,"}, {"sha": "d7fee7f3110f4cdb90e197f16dcfcab5fc0f0b63", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -55,7 +55,7 @@ impl<'a> AstValidator<'a> {\n                                            E0449,\n                                            \"unnecessary visibility qualifier\");\n             if vis == &Visibility::Public {\n-                err.span_label(span, &format!(\"`pub` not needed here\"));\n+                err.span_label(span, \"`pub` not needed here\");\n             }\n             if let Some(note) = note {\n                 err.note(note);\n@@ -80,7 +80,7 @@ impl<'a> AstValidator<'a> {\n             Constness::Const => {\n                 struct_span_err!(self.session, constness.span, E0379,\n                                  \"trait fns cannot be declared const\")\n-                    .span_label(constness.span, &format!(\"trait fns cannot be const\"))\n+                    .span_label(constness.span, \"trait fns cannot be const\")\n                     .emit();\n             }\n             _ => {}\n@@ -272,7 +272,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                                                    E0130,\n                                                    \"patterns aren't allowed in foreign function \\\n                                                     declarations\");\n-                    err.span_label(span, &format!(\"pattern not allowed in foreign function\"));\n+                    err.span_label(span, \"pattern not allowed in foreign function\");\n                     if is_recent {\n                         err.span_note(span,\n                                       \"this is a recent error, see issue #35203 for more details\");"}, {"sha": "a0998b1bd1bfb3fd7cd3a54da70b140d3987da0a", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -180,7 +180,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     Ok(Ordering::Greater) => {\n                         struct_span_err!(self.tcx.sess, start.span, E0030,\n                             \"lower range bound must be less than or equal to upper\")\n-                            .span_label(start.span, &format!(\"lower bound larger than upper bound\"))\n+                            .span_label(start.span, \"lower bound larger than upper bound\")\n                             .emit();\n                     }\n                     Err(ErrorReported) => {}"}, {"sha": "21a4c007fb1926b35144ee74db78919dd8ebf430", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                                              \"`break` with value from a `{}` loop\",\n                                              kind.name())\n                                 .span_label(e.span,\n-                                            &format!(\"can only break with a value inside `loop`\"))\n+                                            \"can only break with a value inside `loop`\")\n                                 .emit();\n                         }\n                     }\n@@ -154,12 +154,12 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n             Loop(_) => {}\n             Closure => {\n                 struct_span_err!(self.sess, span, E0267, \"`{}` inside of a closure\", name)\n-                .span_label(span, &format!(\"cannot break inside of a closure\"))\n+                .span_label(span, \"cannot break inside of a closure\")\n                 .emit();\n             }\n             Normal => {\n                 struct_span_err!(self.sess, span, E0268, \"`{}` outside of loop\", name)\n-                .span_label(span, &format!(\"cannot break outside of a loop\"))\n+                .span_label(span, \"cannot break outside of a loop\")\n                 .emit();\n             }\n         }\n@@ -169,7 +169,7 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n         struct_span_err!(self.sess, span, E0590,\n                          \"`break` or `continue` with no label in the condition of a `while` loop\")\n             .span_label(span,\n-                        &format!(\"unlabeled `{}` in the condition of a `while` loop\", cf_type))\n+                        format!(\"unlabeled `{}` in the condition of a `while` loop\", cf_type))\n             .emit();\n     }\n }"}, {"sha": "8d455adc23c99d95b500988fec69e1874f192d79", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'b: 'a, 'hir: 'b> CheckItemRecursionVisitor<'a, 'b, 'hir> {\n             });\n             if !any_static {\n                 struct_span_err!(self.sess, span, E0265, \"recursive constant\")\n-                    .span_label(span, &format!(\"recursion not allowed in constant\"))\n+                    .span_label(span, \"recursion not allowed in constant\")\n                     .emit();\n             }\n             return;"}, {"sha": "56d639868e0566b4885841c46e04bcac9cdd5ab1", "filename": "src/librustc_platform_intrinsics/hexagon.rs", "status": "added", "additions": 2937, "deletions": 0, "changes": 2937, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_platform_intrinsics%2Fhexagon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_platform_intrinsics%2Fhexagon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Fhexagon.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1"}, {"sha": "dd2d60a1d22d6492dcb98729f1ae7254727d73be", "filename": "src/librustc_platform_intrinsics/lib.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_platform_intrinsics%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_platform_intrinsics%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -29,7 +29,7 @@ pub enum Type {\n     Integer(/* signed */ bool, u8, /* llvm width */ u8),\n     Float(u8),\n     Pointer(&'static Type, Option<&'static Type>, /* const */ bool),\n-    Vector(&'static Type, Option<&'static Type>, u8),\n+    Vector(&'static Type, Option<&'static Type>, u16),\n     Aggregate(bool, &'static [&'static Type]),\n }\n \n@@ -56,20 +56,38 @@ static I8x16: Type = Type::Vector(&I8, None, 16);\n static U8x16: Type = Type::Vector(&U8, None, 16);\n static I8x32: Type = Type::Vector(&I8, None, 32);\n static U8x32: Type = Type::Vector(&U8, None, 32);\n+static I8x64: Type = Type::Vector(&I8, None, 64);\n+static U8x64: Type = Type::Vector(&U8, None, 64);\n+static I8x128: Type = Type::Vector(&I8, None, 128);\n+static U8x128: Type = Type::Vector(&U8, None, 128);\n+static I8x256: Type = Type::Vector(&I8, None, 256);\n+static U8x256: Type = Type::Vector(&U8, None, 256);\n \n static I16x4: Type = Type::Vector(&I16, None, 4);\n static U16x4: Type = Type::Vector(&U16, None, 4);\n static I16x8: Type = Type::Vector(&I16, None, 8);\n static U16x8: Type = Type::Vector(&U16, None, 8);\n static I16x16: Type = Type::Vector(&I16, None, 16);\n static U16x16: Type = Type::Vector(&U16, None, 16);\n+static I16x32: Type = Type::Vector(&I16, None, 32);\n+static U16x32: Type = Type::Vector(&U16, None, 32);\n+static I16x64: Type = Type::Vector(&I16, None, 64);\n+static U16x64: Type = Type::Vector(&U16, None, 64);\n+static I16x128: Type = Type::Vector(&I16, None, 128);\n+static U16x128: Type = Type::Vector(&U16, None, 128);\n \n static I32x2: Type = Type::Vector(&I32, None, 2);\n static U32x2: Type = Type::Vector(&U32, None, 2);\n static I32x4: Type = Type::Vector(&I32, None, 4);\n static U32x4: Type = Type::Vector(&U32, None, 4);\n static I32x8: Type = Type::Vector(&I32, None, 8);\n static U32x8: Type = Type::Vector(&U32, None, 8);\n+static I32x16: Type = Type::Vector(&I32, None, 16);\n+static U32x16: Type = Type::Vector(&U32, None, 16);\n+static I32x32: Type = Type::Vector(&I32, None, 32);\n+static U32x32: Type = Type::Vector(&U32, None, 32);\n+static I32x64: Type = Type::Vector(&I32, None, 64);\n+static U32x64: Type = Type::Vector(&U32, None, 64);\n \n static I64x1: Type = Type::Vector(&I64, None, 1);\n static U64x1: Type = Type::Vector(&U64, None, 1);\n@@ -96,6 +114,7 @@ mod x86;\n mod arm;\n mod aarch64;\n mod nvptx;\n+mod hexagon;\n \n impl Intrinsic {\n     pub fn find(name: &str) -> Option<Intrinsic> {\n@@ -107,6 +126,8 @@ impl Intrinsic {\n             aarch64::find(name)\n         } else if name.starts_with(\"nvptx_\") {\n             nvptx::find(name)\n+        } else if name.starts_with(\"Q6_\") {\n+            hexagon::find(name)\n         } else {\n             None\n         }"}, {"sha": "f63102433c1e6d5a6a51c2e0ea1ec65a1171694c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -433,7 +433,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n         if !def.is_enum() && !field.vis.is_accessible_from(self.current_item, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n                              field.name, def.variant_descr(), self.tcx.item_path_str(def.did))\n-                .span_label(span, &format!(\"field `{}` is private\", field.name))\n+                .span_label(span, format!(\"field `{}` is private\", field.name))\n                 .emit();\n         }\n     }\n@@ -926,7 +926,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n                     if self.has_pub_restricted || self.has_old_errors {\n                         let mut err = struct_span_err!(self.tcx.sess, self.span, E0446,\n                             \"private type `{}` in public interface\", ty);\n-                        err.span_label(self.span, &format!(\"can't leak private type\"));\n+                        err.span_label(self.span, \"can't leak private type\");\n                         err.emit();\n                     } else {\n                         self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n@@ -961,7 +961,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n                 if self.has_pub_restricted || self.has_old_errors {\n                     struct_span_err!(self.tcx.sess, self.span, E0445,\n                                      \"private trait `{}` in public interface\", trait_ref)\n-                        .span_label(self.span, &format!(\n+                        .span_label(self.span, format!(\n                                     \"private trait can't be public\"))\n                         .emit();\n                 } else {"}, {"sha": "ac556270886ac677dcb0247c2791345f6348e59b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -183,7 +183,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                            E0401,\n                                            \"can't use type parameters from outer function; \\\n                                            try using a local type parameter instead\");\n-            err.span_label(span, &format!(\"use of type variable from outer function\"));\n+            err.span_label(span, \"use of type variable from outer function\");\n             err\n         }\n         ResolutionError::OuterTypeParameterContext => {\n@@ -199,8 +199,8 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                             \"the name `{}` is already used for a type parameter \\\n                                             in this type parameter list\",\n                                             name);\n-             err.span_label(span, &format!(\"already used\"));\n-             err.span_label(first_use_span.clone(), &format!(\"first use of `{}`\", name));\n+             err.span_label(span, \"already used\");\n+             err.span_label(first_use_span.clone(), format!(\"first use of `{}`\", name));\n              err\n         }\n         ResolutionError::MethodNotMemberOfTrait(method, trait_) => {\n@@ -210,7 +210,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                            \"method `{}` is not a member of trait `{}`\",\n                                            method,\n                                            trait_);\n-            err.span_label(span, &format!(\"not a member of trait `{}`\", trait_));\n+            err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n             err\n         }\n         ResolutionError::TypeNotMemberOfTrait(type_, trait_) => {\n@@ -220,7 +220,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              \"type `{}` is not a member of trait `{}`\",\n                              type_,\n                              trait_);\n-            err.span_label(span, &format!(\"not a member of trait `{}`\", trait_));\n+            err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n             err\n         }\n         ResolutionError::ConstNotMemberOfTrait(const_, trait_) => {\n@@ -230,7 +230,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              \"const `{}` is not a member of trait `{}`\",\n                              const_,\n                              trait_);\n-            err.span_label(span, &format!(\"not a member of trait `{}`\", trait_));\n+            err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n             err\n         }\n         ResolutionError::VariableNotBoundInPattern(binding_error) => {\n@@ -239,11 +239,11 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             let msg = format!(\"variable `{}` is not bound in all patterns\", binding_error.name);\n             let mut err = resolver.session.struct_span_err_with_code(msp, &msg, \"E0408\");\n             for sp in target_sp {\n-                err.span_label(sp, &format!(\"pattern doesn't bind `{}`\", binding_error.name));\n+                err.span_label(sp, format!(\"pattern doesn't bind `{}`\", binding_error.name));\n             }\n             let origin_sp = binding_error.origin.iter().map(|x| *x).collect::<Vec<_>>();\n             for sp in origin_sp {\n-                err.span_label(sp, &\"variable not in all patterns\");\n+                err.span_label(sp, \"variable not in all patterns\");\n             }\n             err\n         }\n@@ -255,8 +255,8 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              \"variable `{}` is bound in inconsistent \\\n                              ways within the same match arm\",\n                              variable_name);\n-            err.span_label(span, &format!(\"bound in different ways\"));\n-            err.span_label(first_binding_span, &format!(\"first binding\"));\n+            err.span_label(span, \"bound in different ways\");\n+            err.span_label(first_binding_span, \"first binding\");\n             err\n         }\n         ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n@@ -265,7 +265,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              E0415,\n                              \"identifier `{}` is bound more than once in this parameter list\",\n                              identifier);\n-            err.span_label(span, &format!(\"used as parameter more than once\"));\n+            err.span_label(span, \"used as parameter more than once\");\n             err\n         }\n         ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n@@ -274,7 +274,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              E0416,\n                              \"identifier `{}` is bound more than once in the same pattern\",\n                              identifier);\n-            err.span_label(span, &format!(\"used in a pattern more than once\"));\n+            err.span_label(span, \"used in a pattern more than once\");\n             err\n         }\n         ResolutionError::UndeclaredLabel(name) => {\n@@ -283,7 +283,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                            E0426,\n                                            \"use of undeclared label `{}`\",\n                                            name);\n-            err.span_label(span, &format!(\"undeclared label `{}`\",&name));\n+            err.span_label(span, format!(\"undeclared label `{}`\", name));\n             err\n         }\n         ResolutionError::SelfImportsOnlyAllowedWithin => {\n@@ -313,14 +313,14 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             };\n             let mut err = struct_span_err!(resolver.session, span, E0432, \"{}\", msg);\n             if let Some((_, p)) = name {\n-                err.span_label(span, &p);\n+                err.span_label(span, p);\n             }\n             err\n         }\n         ResolutionError::FailedToResolve(msg) => {\n             let mut err = struct_span_err!(resolver.session, span, E0433,\n                                            \"failed to resolve. {}\", msg);\n-            err.span_label(span, &msg);\n+            err.span_label(span, msg);\n             err\n         }\n         ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n@@ -336,7 +336,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                              span,\n                              E0435,\n                              \"attempt to use a non-constant value in a constant\");\n-            err.span_label(span, &format!(\"non-constant used with constant\"));\n+            err.span_label(span, \"non-constant used with constant\");\n             err\n         }\n         ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, name, binding) => {\n@@ -345,17 +345,17 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                            span,\n                                            E0530,\n                                            \"{}s cannot shadow {}s\", what_binding, shadows_what);\n-            err.span_label(span, &format!(\"cannot be named the same as a {}\", shadows_what));\n+            err.span_label(span, format!(\"cannot be named the same as a {}\", shadows_what));\n             let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-            let msg = &format!(\"a {} `{}` is {} here\", shadows_what, name, participle);\n+            let msg = format!(\"a {} `{}` is {} here\", shadows_what, name, participle);\n             err.span_label(binding.span, msg);\n             err\n         }\n         ResolutionError::ForwardDeclaredTyParam => {\n             let mut err = struct_span_err!(resolver.session, span, E0128,\n                                            \"type parameters with a default cannot use \\\n                                             forward declared identifiers\");\n-            err.span_label(span, &format!(\"defaulted type parameters \\\n+            err.span_label(span, format!(\"defaulted type parameters \\\n                                            cannot be forward declared\"));\n             err\n         }\n@@ -2256,13 +2256,13 @@ impl<'a> Resolver<'a> {\n             if is_self_type(path, ns) {\n                 __diagnostic_used!(E0411);\n                 err.code(\"E0411\".into());\n-                err.span_label(span, &format!(\"`Self` is only available in traits and impls\"));\n+                err.span_label(span, \"`Self` is only available in traits and impls\");\n                 return err;\n             }\n             if is_self_value(path, ns) {\n                 __diagnostic_used!(E0424);\n                 err.code(\"E0424\".into());\n-                err.span_label(span, &format!(\"`self` value is only available in \\\n+                err.span_label(span, format!(\"`self` value is only available in \\\n                                                methods with `self` parameter\"));\n                 return err;\n             }\n@@ -2294,18 +2294,18 @@ impl<'a> Resolver<'a> {\n                     let self_is_available = this.self_value_is_available(path[0].ctxt);\n                     match candidate {\n                         AssocSuggestion::Field => {\n-                            err.span_label(span, &format!(\"did you mean `self.{}`?\", path_str));\n+                            err.span_label(span, format!(\"did you mean `self.{}`?\", path_str));\n                             if !self_is_available {\n-                                err.span_label(span, &format!(\"`self` value is only available in \\\n+                                err.span_label(span, format!(\"`self` value is only available in \\\n                                                                methods with `self` parameter\"));\n                             }\n                         }\n                         AssocSuggestion::MethodWithSelf if self_is_available => {\n-                            err.span_label(span, &format!(\"did you mean `self.{}(...)`?\",\n+                            err.span_label(span, format!(\"did you mean `self.{}(...)`?\",\n                                                            path_str));\n                         }\n                         AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n-                            err.span_label(span, &format!(\"did you mean `Self::{}`?\", path_str));\n+                            err.span_label(span, format!(\"did you mean `Self::{}`?\", path_str));\n                         }\n                     }\n                     return err;\n@@ -2316,29 +2316,29 @@ impl<'a> Resolver<'a> {\n \n             // Try Levenshtein.\n             if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected) {\n-                err.span_label(ident_span, &format!(\"did you mean `{}`?\", candidate));\n+                err.span_label(ident_span, format!(\"did you mean `{}`?\", candidate));\n                 levenshtein_worked = true;\n             }\n \n             // Try context dependent help if relaxed lookup didn't work.\n             if let Some(def) = def {\n                 match (def, source) {\n                     (Def::Macro(..), _) => {\n-                        err.span_label(span, &format!(\"did you mean `{}!(...)`?\", path_str));\n+                        err.span_label(span, format!(\"did you mean `{}!(...)`?\", path_str));\n                         return err;\n                     }\n                     (Def::TyAlias(..), PathSource::Trait) => {\n-                        err.span_label(span, &format!(\"type aliases cannot be used for traits\"));\n+                        err.span_label(span, \"type aliases cannot be used for traits\");\n                         return err;\n                     }\n                     (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n                         ExprKind::Field(_, ident) => {\n-                            err.span_label(parent.span, &format!(\"did you mean `{}::{}`?\",\n+                            err.span_label(parent.span, format!(\"did you mean `{}::{}`?\",\n                                                                  path_str, ident.node));\n                             return err;\n                         }\n                         ExprKind::MethodCall(ident, ..) => {\n-                            err.span_label(parent.span, &format!(\"did you mean `{}::{}(...)`?\",\n+                            err.span_label(parent.span, format!(\"did you mean `{}::{}(...)`?\",\n                                                                  path_str, ident.node));\n                             return err;\n                         }\n@@ -2349,12 +2349,12 @@ impl<'a> Resolver<'a> {\n                             if let Some((ctor_def, ctor_vis))\n                                     = this.struct_constructors.get(&def_id).cloned() {\n                                 if is_expected(ctor_def) && !this.is_accessible(ctor_vis) {\n-                                    err.span_label(span, &format!(\"constructor is not visible \\\n+                                    err.span_label(span, format!(\"constructor is not visible \\\n                                                                    here due to private fields\"));\n                                 }\n                             }\n                         }\n-                        err.span_label(span, &format!(\"did you mean `{} {{ /* fields */ }}`?\",\n+                        err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\",\n                                                        path_str));\n                         return err;\n                     }\n@@ -2364,7 +2364,7 @@ impl<'a> Resolver<'a> {\n \n             // Fallback label.\n             if !levenshtein_worked {\n-                err.span_label(base_span, &fallback_label);\n+                err.span_label(base_span, fallback_label);\n             }\n             err\n         };\n@@ -3374,9 +3374,9 @@ impl<'a> Resolver<'a> {\n             },\n         };\n \n-        err.span_label(span, &format!(\"`{}` already {}\", name, participle));\n+        err.span_label(span, format!(\"`{}` already {}\", name, participle));\n         if old_binding.span != syntax_pos::DUMMY_SP {\n-            err.span_label(old_binding.span, &format!(\"previous {} of `{}` here\", noun, name));\n+            err.span_label(old_binding.span, format!(\"previous {} of `{}` here\", noun, name));\n         }\n         err.emit();\n         self.name_already_seen.insert(name, span);"}, {"sha": "106f421f39e75b12a5b65e8da2b9c61f68525fa6", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -630,7 +630,7 @@ impl<'a> Resolver<'a> {\n                     err.help(&format!(\"did you mean `{}`?\", suggestion));\n                 }\n             } else {\n-                err.help(&format!(\"have you added the `#[macro_use]` on the module/import?\"));\n+                err.help(\"have you added the `#[macro_use]` on the module/import?\");\n             }\n         }\n     }"}, {"sha": "804e1ea740f50e4152c75fbc14a4ad03317ffddd", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -539,7 +539,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Ok(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     struct_span_err!(this.session, directive.span, E0253, \"{}\", &msg)\n-                        .span_label(directive.span, &format!(\"cannot be imported directly\"))\n+                        .span_label(directive.span, \"cannot be imported directly\")\n                         .emit();\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n@@ -701,7 +701,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             } else if ns == TypeNS {\n                 struct_span_err!(self.session, directive.span, E0365,\n                                  \"`{}` is private, and cannot be reexported\", ident)\n-                    .span_label(directive.span, &format!(\"reexport of private `{}`\", ident))\n+                    .span_label(directive.span, format!(\"reexport of private `{}`\", ident))\n                     .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                     .emit();\n             } else {\n@@ -794,7 +794,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                             let msg =\n                                 format!(\"a macro named `{}` has already been exported\", ident);\n                             self.session.struct_span_err(span, &msg)\n-                                .span_label(span, &format!(\"`{}` already exported\", ident))\n+                                .span_label(span, format!(\"`{}` already exported\", ident))\n                                 .span_note(binding.span, \"previous macro export here\")\n                                 .emit();\n                         }"}, {"sha": "6d04bff82829ae7c763822c1cc6219ccef2c43ac", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -11,9 +11,10 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = \"0.3\"\n rustc = { path = \"../librustc\" }\n+rustc_typeck = { path = \"../librustc_typeck\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-rls-data = \"0.1\"\n-rls-span = \"0.1\"\n+rls-data = \"0.3\"\n+rls-span = \"0.4\"\n # FIXME(#40527) should move rustc serialize out of tree\n rustc-serialize = \"0.3\""}, {"sha": "763414c1a555fb2250b958da9899e51b333e79fd", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -122,7 +122,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             f(self);\n             self.save_ctxt.tables = old_tables;\n         } else {\n-            f(self)\n+            f(self);\n         }\n     }\n "}, {"sha": "fd6898d19d84fce59cea36b0ffbaff53e5f56aaa", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -27,6 +27,7 @@\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n extern crate rustc_serialize;\n+extern crate rustc_typeck;\n extern crate syntax_pos;\n \n extern crate rls_data;\n@@ -50,6 +51,7 @@ use rustc::hir::def_id::DefId;\n use rustc::session::config::CrateType::CrateTypeExecutable;\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n+use rustc_typeck::hir_ty_to_ty;\n \n use std::env;\n use std::fs::File;\n@@ -606,11 +608,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 Def::Local(def_id)\n             }\n \n-            Node::NodeTy(&hir::Ty { node: hir::TyPath(ref qpath), .. }) => {\n-                match *qpath {\n-                    hir::QPath::Resolved(_, ref path) => path.def,\n-                    hir::QPath::TypeRelative(..) => {\n-                        if let Some(ty) = self.tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n+            Node::NodeTy(ty) => {\n+                if let hir::Ty { node: hir::TyPath(ref qpath), .. } = *ty {\n+                    match *qpath {\n+                        hir::QPath::Resolved(_, ref path) => path.def,\n+                        hir::QPath::TypeRelative(..) => {\n+                            let ty = hir_ty_to_ty(self.tcx, ty);\n                             if let ty::TyProjection(proj) = ty.sty {\n                                 for item in self.tcx.associated_items(proj.trait_ref.def_id) {\n                                     if item.kind == ty::AssociatedKind::Type {\n@@ -620,9 +623,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                     }\n                                 }\n                             }\n+                            Def::Err\n                         }\n-                        Def::Err\n                     }\n+                } else {\n+                    Def::Err\n                 }\n             }\n "}, {"sha": "8689e176f7a7b92d8d5d70f1443ea10361acf804", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -754,10 +754,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     }).max().unwrap();\n \n     if kind == MetadataKind::None {\n-        return (metadata_llcx, metadata_llmod, EncodedMetadata {\n-            raw_data: vec![],\n-            hashes: vec![],\n-        });\n+        return (metadata_llcx, metadata_llmod, EncodedMetadata::new());\n     }\n \n     let cstore = &tcx.sess.cstore;"}, {"sha": "adcb3d682ca238b7541a3ad584155562c6f80463", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -25,9 +25,8 @@ use rustc::ty::wf::object_region_bounds;\n use rustc_back::slice;\n use require_c_abi_if_variadic;\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n-use util::nodemap::{NodeMap, FxHashSet};\n+use util::nodemap::FxHashSet;\n \n-use std::cell::RefCell;\n use std::iter;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n@@ -37,9 +36,6 @@ use syntax_pos::Span;\n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n-    /// A cache used for the result of `ast_ty_to_ty_cache`\n-    fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>>;\n-\n     /// Returns the set of bounds in scope for the type parameter with\n     /// the given id.\n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n@@ -167,7 +163,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::ParenthesizedParameters(..) => {\n                 struct_span_err!(tcx.sess, span, E0214,\n                           \"parenthesized parameters may only be used with a trait\")\n-                    .span_label(span, &format!(\"only traits may use parentheses\"))\n+                    .span_label(span, \"only traits may use parentheses\")\n                     .emit();\n \n                 return Substs::for_item(tcx, def_id, |_, _| {\n@@ -298,7 +294,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     struct_span_err!(tcx.sess, span, E0393,\n                                      \"the type parameter `{}` must be explicitly specified\",\n                                      def.name)\n-                        .span_label(span, &format!(\"missing reference to `{}`\", def.name))\n+                        .span_label(span, format!(\"missing reference to `{}`\", def.name))\n                         .note(&format!(\"because of the default `Self` reference, \\\n                                         type parameters must be specified on object types\"))\n                         .emit();\n@@ -639,7 +635,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             let span = b.trait_ref.path.span;\n             struct_span_err!(self.tcx().sess, span, E0225,\n                 \"only Send/Sync traits can be used as additional traits in a trait object\")\n-                .span_label(span, &format!(\"non-Send/Sync additional trait\"))\n+                .span_label(span, \"non-Send/Sync additional trait\")\n                 .emit();\n         }\n \n@@ -688,7 +684,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n                         name,\n                         tcx.item_path_str(trait_def_id))\n-                        .span_label(span, &format!(\n+                        .span_label(span, format!(\n                             \"missing associated type `{}` value\", name))\n                         .emit();\n         }\n@@ -734,7 +730,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                         trait_str: &str,\n                                         name: &str) {\n         struct_span_err!(self.tcx().sess, span, E0223, \"ambiguous associated type\")\n-            .span_label(span, &format!(\"ambiguous associated type\"))\n+            .span_label(span, \"ambiguous associated type\")\n             .note(&format!(\"specify the type using the syntax `<{} as {}>::{}`\",\n                   type_str, trait_str, name))\n             .emit();\n@@ -788,7 +784,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                           \"associated type `{}` not found for `{}`\",\n                           assoc_name,\n                           ty_param_name)\n-                  .span_label(span, &format!(\"associated type `{}` not found\", assoc_name))\n+                  .span_label(span, format!(\"associated type `{}` not found\", assoc_name))\n                   .emit();\n                 return Err(ErrorReported);\n             }\n@@ -801,7 +797,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 \"ambiguous associated type `{}` in bounds of `{}`\",\n                 assoc_name,\n                 ty_param_name);\n-            err.span_label(span, &format!(\"ambiguous associated type `{}`\", assoc_name));\n+            err.span_label(span, format!(\"ambiguous associated type `{}`\", assoc_name));\n \n             for bound in bounds {\n                 let bound_span = self.tcx().associated_items(bound.def_id()).find(|item| {\n@@ -810,7 +806,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 .and_then(|item| self.tcx().hir.span_if_local(item.def_id));\n \n                 if let Some(span) = bound_span {\n-                    err.span_label(span, &format!(\"ambiguous `{}` from `{}`\",\n+                    err.span_label(span, format!(\"ambiguous `{}` from `{}`\",\n                                                   assoc_name,\n                                                   bound));\n                 } else {\n@@ -955,15 +951,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             for typ in segment.parameters.types() {\n                 struct_span_err!(self.tcx().sess, typ.span, E0109,\n                                  \"type parameters are not allowed on this type\")\n-                    .span_label(typ.span, &format!(\"type parameter not allowed\"))\n+                    .span_label(typ.span, \"type parameter not allowed\")\n                     .emit();\n                 break;\n             }\n             for lifetime in segment.parameters.lifetimes() {\n                 struct_span_err!(self.tcx().sess, lifetime.span, E0110,\n                                  \"lifetime parameters are not allowed on this type\")\n                     .span_label(lifetime.span,\n-                                &format!(\"lifetime parameter not allowed on this type\"))\n+                                \"lifetime parameter not allowed on this type\")\n                     .emit();\n                 break;\n             }\n@@ -977,7 +973,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn prohibit_projection(&self, span: Span) {\n         let mut err = struct_span_err!(self.tcx().sess, span, E0229,\n                                        \"associated type bindings are not allowed here\");\n-        err.span_label(span, &format!(\"associate type not allowed here\")).emit();\n+        err.span_label(span, \"associate type not allowed here\").emit();\n     }\n \n     // Check a type Path and convert it to a Ty.\n@@ -1074,11 +1070,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let tcx = self.tcx();\n \n-        let cache = self.ast_ty_to_ty_cache();\n-        if let Some(ty) = cache.borrow().get(&ast_ty.id) {\n-            return ty;\n-        }\n-\n         let result_ty = match ast_ty.node {\n             hir::TySlice(ref ty) => {\n                 tcx.mk_slice(self.ast_ty_to_ty(&ty))\n@@ -1223,7 +1214,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyTypeof(ref _e) => {\n                 struct_span_err!(tcx.sess, ast_ty.span, E0516,\n                                  \"`typeof` is a reserved keyword but unimplemented\")\n-                    .span_label(ast_ty.span, &format!(\"reserved keyword\"))\n+                    .span_label(ast_ty.span, \"reserved keyword\")\n                     .emit();\n \n                 tcx.types.err\n@@ -1240,8 +1231,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         };\n \n-        cache.borrow_mut().insert(ast_ty.id, result_ty);\n-\n         result_ty\n     }\n \n@@ -1437,7 +1426,7 @@ fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n                 \"wrong number of type arguments: {} {}, found {}\",\n                 expected, required, supplied)\n             .span_label(span,\n-                &format!(\"{} {} type argument{}\",\n+                format!(\"{} {} type argument{}\",\n                     expected,\n                     required,\n                     arguments_plural))\n@@ -1455,7 +1444,7 @@ fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n                 expected, supplied)\n             .span_label(\n                 span,\n-                &format!(\"{} type argument{}\",\n+                format!(\"{} type argument{}\",\n                     if accepted == 0 { \"expected no\" } else { &expected },\n                     arguments_plural)\n             )\n@@ -1481,7 +1470,7 @@ fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected\n     struct_span_err!(tcx.sess, span, E0107,\n                      \"wrong number of lifetime parameters: expected {}, found {}\",\n                      expected, number)\n-        .span_label(span, &label)\n+        .span_label(span, label)\n         .emit();\n }\n "}, {"sha": "bbe34f37950dc6b7b9238092cf87891785b01654", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     struct_span_err!(tcx.sess, span, E0029,\n                         \"only char and numeric types are allowed in range patterns\")\n-                        .span_label(span, &format!(\"ranges require char or numeric types\"))\n+                        .span_label(span, \"ranges require char or numeric types\")\n                         .note(&format!(\"start type: {}\", self.ty_to_string(lhs_ty)))\n                         .note(&format!(\"end type: {}\", self.ty_to_string(rhs_ty)))\n                         .emit();\n@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     tcx.sess, pat.span, E0527,\n                                     \"pattern requires {} elements but array has {}\",\n                                     min_len, size)\n-                                    .span_label(pat.span, &format!(\"expected {} elements\",size))\n+                                    .span_label(pat.span, format!(\"expected {} elements\",size))\n                                     .emit();\n                             }\n                             (inner_ty, tcx.types.err)\n@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     \"pattern requires at least {} elements but array has {}\",\n                                     min_len, size)\n                                 .span_label(pat.span,\n-                                    &format!(\"pattern cannot match array of {} elements\", size))\n+                                    format!(\"pattern cannot match array of {} elements\", size))\n                                 .emit();\n                             (inner_ty, tcx.types.err)\n                         }\n@@ -297,7 +297,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             }\n \n                             err.span_label( pat.span,\n-                                &format!(\"pattern cannot match with input type `{}`\", expected_ty)\n+                                format!(\"pattern cannot match with input type `{}`\", expected_ty)\n                             ).emit();\n                         }\n                         (tcx.types.err, tcx.types.err)\n@@ -379,7 +379,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let type_str = self.ty_to_string(expected);\n                     struct_span_err!(self.tcx.sess, span, E0033,\n                               \"type `{}` cannot be dereferenced\", type_str)\n-                        .span_label(span, &format!(\"type `{}` cannot be dereferenced\", type_str))\n+                        .span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str))\n                         .emit();\n                     return false\n                 }\n@@ -593,7 +593,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               def.kind_name(),\n                               hir::print::to_string(&tcx.hir, |s| s.print_qpath(qpath, false)));\n             struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n-                .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n+                .span_label(pat.span, \"not a tuple variant or struct\").emit();\n             on_error();\n         };\n \n@@ -642,7 +642,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                              \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n                              subpats.len(), subpats_ending, def.kind_name(),\n                              variant.fields.len(),  fields_ending)\n-                .span_label(pat.span, &format!(\"expected {} field{}, found {}\",\n+                .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n                                                variant.fields.len(), fields_ending, subpats.len()))\n                 .emit();\n             on_error();\n@@ -683,8 +683,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       in the pattern\",\n                                      field.name)\n                         .span_label(span,\n-                                    &format!(\"multiple uses of `{}` in pattern\", field.name))\n-                        .span_label(*occupied.get(), &format!(\"first use of `{}`\", field.name))\n+                                    format!(\"multiple uses of `{}` in pattern\", field.name))\n+                        .span_label(*occupied.get(), format!(\"first use of `{}`\", field.name))\n                         .emit();\n                     tcx.types.err\n                 }\n@@ -703,7 +703,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              tcx.item_path_str(variant.did),\n                                              field.name)\n                                 .span_label(span,\n-                                            &format!(\"{} `{}` does not have field `{}`\",\n+                                            format!(\"{} `{}` does not have field `{}`\",\n                                                      kind_name,\n                                                      tcx.item_path_str(variant.did),\n                                                      field.name))\n@@ -732,7 +732,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 struct_span_err!(tcx.sess, span, E0027,\n                                 \"pattern does not mention field `{}`\",\n                                 field.name)\n-                                .span_label(span, &format!(\"missing field `{}`\", field.name))\n+                                .span_label(span, format!(\"missing field `{}`\", field.name))\n                                 .emit();\n             }\n         }"}, {"sha": "f03451c04ed004a19d5d38c0bc0295b2fa84ce49", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n                              E0055,\n                              \"reached the recursion limit while auto-dereferencing {:?}\",\n                              self.cur_ty)\n-                .span_label(self.span, &format!(\"deref recursion limit reached\"))\n+                .span_label(self.span, \"deref recursion limit reached\")\n                 .help(&format!(\n                         \"consider adding a `#[recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                         suggested_limit))"}, {"sha": "dde5f598a68329ec77a3e91c858fdcfb46575085", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -27,7 +27,7 @@ use rustc::hir;\n pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefId) {\n     if tcx.lang_items.drop_trait() == Some(trait_id) {\n         struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\")\n-            .span_label(span, &format!(\"explicit destructor calls not allowed\"))\n+            .span_label(span, \"explicit destructor calls not allowed\")\n             .emit();\n     }\n }"}, {"sha": "72ce7d3b5ed711abe4cb6539cd5380fb19108af9", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                        },\n                                        self.expr_ty);\n                 err.span_label(error_span,\n-                               &format!(\"cannot cast `{}` as `{}`\",\n+                               format!(\"cannot cast `{}` as `{}`\",\n                                         fcx.ty_to_string(self.expr_ty),\n                                         cast_ty));\n                 if let Ok(snippet) = fcx.sess().codemap().span_to_snippet(self.expr.span) {\n@@ -200,7 +200,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             }\n             CastError::CastToBool => {\n                 struct_span_err!(fcx.tcx.sess, self.span, E0054, \"cannot cast as `bool`\")\n-                    .span_label(self.span, &format!(\"unsupported cast\"))\n+                    .span_label(self.span, \"unsupported cast\")\n                     .help(\"compare with zero instead\")\n                     .emit();\n             }"}, {"sha": "fb3be849319929e8b38813e3d3fa60900ff654a1", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -126,6 +126,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (sig, kind)\n             }\n             ty::TyInfer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n+            ty::TyFnPtr(sig) => (Some(sig.skip_binder().clone()), Some(ty::ClosureKind::Fn)),\n             _ => (None, None),\n         }\n     }"}, {"sha": "c228fc6b24abde730be51c16c4ae0618176e0a79", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -965,10 +965,6 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         }\n     }\n \n-    pub fn is_empty(&self) -> bool {\n-        self.pushed == 0\n-    }\n-\n     /// Return the \"expected type\" with which this coercion was\n     /// constructed.  This represents the \"downward propagated\" type\n     /// that was given to us at the start of typing whatever construct\n@@ -1148,7 +1144,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         db = struct_span_err!(\n                             fcx.tcx.sess, cause.span, E0069,\n                             \"`return;` in a function whose return type is not `()`\");\n-                        db.span_label(cause.span, &format!(\"return type is not ()\"));\n+                        db.span_label(cause.span, \"return type is not ()\");\n                     }\n                     _ => {\n                         db = fcx.report_mismatched_types(cause, expected, found, err);"}, {"sha": "0579bb15fd6d2d8e8098faab59077745d9efe463", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -402,7 +402,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          \"lifetime parameters or bounds on method `{}` do not match the \\\n                           trait declaration\",\n                          impl_m.name)\n-            .span_label(span, &format!(\"lifetimes do not match trait\"))\n+            .span_label(span, \"lifetimes do not match trait\")\n             .emit();\n         return Err(ErrorReported);\n     }\n@@ -534,9 +534,9 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             not in the trait\",\n                                            trait_m.name,\n                                            self_descr);\n-            err.span_label(impl_m_span, &format!(\"`{}` used in impl\", self_descr));\n+            err.span_label(impl_m_span, format!(\"`{}` used in impl\", self_descr));\n             if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n-                err.span_label(span, &format!(\"trait declared without `{}`\", self_descr));\n+                err.span_label(span, format!(\"trait declared without `{}`\", self_descr));\n             }\n             err.emit();\n             return Err(ErrorReported);\n@@ -552,9 +552,9 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            trait_m.name,\n                                            self_descr);\n             err.span_label(impl_m_span,\n-                           &format!(\"expected `{}` in impl\", self_descr));\n+                           format!(\"expected `{}` in impl\", self_descr));\n             if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n-                err.span_label(span, &format!(\"`{}` used in trait\", self_descr));\n+                err.span_label(span, format!(\"`{}` used in trait\", self_descr));\n             }\n             err.emit();\n             return Err(ErrorReported);\n@@ -606,7 +606,7 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         if let Some(span) = trait_item_span {\n             err.span_label(span,\n-                           &format!(\"expected {}\",\n+                           format!(\"expected {}\",\n                                     &if num_trait_m_type_params != 1 {\n                                         format!(\"{} type parameters\", num_trait_m_type_params)\n                                     } else {\n@@ -617,7 +617,7 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         err.span_label(span,\n-                       &format!(\"found {}{}\",\n+                       format!(\"found {}{}\",\n                                 &if num_impl_m_type_params != 1 {\n                                     format!(\"{} type parameters\", num_impl_m_type_params)\n                                 } else {\n@@ -696,15 +696,15 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        trait_number_args);\n         if let Some(trait_span) = trait_span {\n             err.span_label(trait_span,\n-                           &format!(\"trait requires {}\",\n+                           format!(\"trait requires {}\",\n                                     &if trait_number_args != 1 {\n                                         format!(\"{} parameters\", trait_number_args)\n                                     } else {\n                                         format!(\"{} parameter\", trait_number_args)\n                                     }));\n         }\n         err.span_label(impl_span,\n-                       &format!(\"expected {}, found {}\",\n+                       format!(\"expected {}, found {}\",\n                                 &if trait_number_args != 1 {\n                                     format!(\"{} parameters\", trait_number_args)\n                                 } else {"}, {"sha": "60067e6a6ec0238e9c8da62e73ec9f60ed71e31c", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -57,7 +57,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         \"intrinsic has wrong number of type \\\n                         parameters: found {}, expected {}\",\n                         i_n_tps, n_tps)\n-            .span_label(span, &format!(\"expected {} type parameter\", n_tps))\n+            .span_label(span, format!(\"expected {} type parameter\", n_tps))\n             .emit();\n     } else {\n         require_same_types(tcx,\n@@ -101,7 +101,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             op => {\n                 struct_span_err!(tcx.sess, it.span, E0092,\n                       \"unrecognized atomic operation function: `{}`\", op)\n-                  .span_label(it.span, &format!(\"unrecognized atomic operation\"))\n+                  .span_label(it.span, \"unrecognized atomic operation\")\n                   .emit();\n                 return;\n             }\n@@ -305,7 +305,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 struct_span_err!(tcx.sess, it.span, E0093,\n                                 \"unrecognized intrinsic function: `{}`\",\n                                 *other)\n-                                .span_label(it.span, &format!(\"unrecognized intrinsic\"))\n+                                .span_label(it.span, \"unrecognized intrinsic\")\n                                 .emit();\n                 return;\n             }\n@@ -505,7 +505,7 @@ fn match_intrinsic_type_to_type<'a, 'tcx>(\n                     }\n                 }\n                 _ => simple_error(&format!(\"`{}`\", t),\n-                                  &format!(\"tuple\")),\n+                                  \"tuple\"),\n             }\n         }\n     }"}, {"sha": "a9e82a0601feeafe8784bba5458cb49e51271399", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -285,7 +285,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                  self.span,\n                                  E0035,\n                                  \"does not take type parameters\")\n-                    .span_label(self.span, &\"called with unneeded type parameters\")\n+                    .span_label(self.span, \"called with unneeded type parameters\")\n                     .emit();\n             } else {\n                 struct_span_err!(self.tcx.sess,\n@@ -296,7 +296,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                  num_method_types,\n                                  num_supplied_types)\n                     .span_label(self.span,\n-                                &format!(\"Passed {} type argument{}, expected {}\",\n+                                format!(\"Passed {} type argument{}, expected {}\",\n                                          num_supplied_types,\n                                          if num_supplied_types != 1 { \"s\" } else { \"\" },\n                                          num_method_types))\n@@ -433,22 +433,11 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n             debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?}\", i, expr);\n \n-            // Fix up the adjustment.\n-            let autoderefs = match self.tables.borrow_mut().adjustments.get_mut(&expr.id) {\n-                Some(&mut Adjustment {\n-                    kind: Adjust::DerefRef { autoderefs, ref mut autoref, .. }, ref mut target\n-                }) => {\n-                    if let &mut Some(AutoBorrow::Ref(_, ref mut mutbl)) = autoref {\n-                        *mutbl = hir::Mutability::MutMutable;\n-                        *target = match target.sty {\n-                            ty::TyRef(r, ty::TypeAndMut { ty, .. }) =>\n-                                self.tcx.mk_ref(r, ty::TypeAndMut { ty, mutbl: *mutbl }),\n-                            _ => span_bug!(expr.span, \"AutoBorrow::Ref resulted in non-ref {:?}\",\n-                                           target)\n-                        };\n-                    }\n-                    autoderefs\n-                }\n+            // Fix up the autoderefs. Autorefs can only occur immediately preceding\n+            // overloaded lvalue ops, and will be fixed by them in order to get\n+            // the correct region.\n+            let autoderefs = match self.tables.borrow().adjustments.get(&expr.id) {\n+                Some(&Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) => autoderefs,\n                 Some(_) | None => 0\n             };\n \n@@ -502,10 +491,35 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         let method = self.try_overloaded_lvalue_op(\n             expr.span, None, base_ty, arg_tys, PreferMutLvalue, op);\n-        let ok = method.expect(\"re-trying op failed\");\n+        let ok = match method {\n+            Some(method) => method,\n+            None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\")\n+        };\n         let method = self.register_infer_ok_obligations(ok);\n         debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n         self.tables.borrow_mut().method_map.insert(method_call, method);\n+\n+        // Convert the autoref in the base expr to mutable with the correct\n+        // region and mutability.\n+        if let Some(&mut Adjustment {\n+            ref mut target, kind: Adjust::DerefRef {\n+                autoref: Some(AutoBorrow::Ref(ref mut r, ref mut mutbl)), ..\n+            }\n+        }) = self.tables.borrow_mut().adjustments.get_mut(&base_expr.id) {\n+            debug!(\"convert_lvalue_op_to_mutable: converting autoref of {:?}\", target);\n+\n+            // extract method return type, which will be &mut T;\n+            // all LB regions should have been instantiated during method lookup\n+            let method_sig = self.tcx.no_late_bound_regions(&method.ty.fn_sig()).unwrap();\n+\n+            *target = method_sig.inputs()[0];\n+            if let ty::TyRef(r_, mt) = target.sty {\n+                *r = r_;\n+                *mutbl = mt.mutbl;\n+            } else {\n+                span_bug!(expr.span, \"input to lvalue op is not a ref?\");\n+            }\n+        }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "c7ec379b0de25d9fc1181a959ebe42a3407ebd8e", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -209,9 +209,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                               expr_string,\n                                                               item_name));\n                                         }\n-                                        err.span_label(span, &\"field, not a method\");\n+                                        err.span_label(span, \"field, not a method\");\n                                     } else {\n-                                        err.span_label(span, &\"private field, not a method\");\n+                                        err.span_label(span, \"private field, not a method\");\n                                     }\n                                     break;\n                                 }\n@@ -272,7 +272,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                span,\n                                                E0034,\n                                                \"multiple applicable items in scope\");\n-                err.span_label(span, &format!(\"multiple `{}` found\", item_name));\n+                err.span_label(span, format!(\"multiple `{}` found\", item_name));\n \n                 report_candidates(&mut err, sources);\n                 err.emit();"}, {"sha": "127ffc60cf4dd90ae66c0a0eccaa35ab19aaff6d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -451,8 +451,6 @@ impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n }\n \n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n-\n     body_id: ast::NodeId,\n \n     // Number of errors that had been reported when we started\n@@ -1132,7 +1130,7 @@ fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             struct_span_err!(\n                 tcx.sess, attr.span, E0232,\n                 \"this attribute must have a value\")\n-                .span_label(attr.span, &format!(\"attribute requires a value\"))\n+                .span_label(attr.span, \"attribute requires a value\")\n                 .note(&format!(\"eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\"))\n                 .emit();\n         }\n@@ -1148,12 +1146,12 @@ fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         \"`{}` specializes an item from a parent `impl`, but \\\n          that item is not marked `default`\",\n         impl_item.name);\n-    err.span_label(impl_item.span, &format!(\"cannot specialize default item `{}`\",\n+    err.span_label(impl_item.span, format!(\"cannot specialize default item `{}`\",\n                                             impl_item.name));\n \n     match tcx.span_of_impl(parent_impl) {\n         Ok(span) => {\n-            err.span_label(span, &\"parent `impl` is here\");\n+            err.span_label(span, \"parent `impl` is here\");\n             err.note(&format!(\"to specialize, `{}` in the parent `impl` must be marked `default`\",\n                               impl_item.name));\n         }\n@@ -1228,11 +1226,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   which doesn't match its trait `{}`\",\n                                   ty_impl_item.name,\n                                   impl_trait_ref);\n-                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         err.span_label(impl_item.span, \"does not match trait\");\n                          // We can only get the spans from local trait definition\n                          // Same for E0324 and E0325\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n-                            err.span_label(trait_span, &format!(\"item in trait\"));\n+                            err.span_label(trait_span, \"item in trait\");\n                          }\n                          err.emit()\n                     }\n@@ -1264,9 +1262,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   which doesn't match its trait `{}`\",\n                                   ty_impl_item.name,\n                                   impl_trait_ref);\n-                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n-                            err.span_label(trait_span, &format!(\"item in trait\"));\n+                            err.span_label(trait_span, \"item in trait\");\n                          }\n                          err.emit()\n                     }\n@@ -1282,9 +1280,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   which doesn't match its trait `{}`\",\n                                   ty_impl_item.name,\n                                   impl_trait_ref);\n-                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n-                            err.span_label(trait_span, &format!(\"item in trait\"));\n+                            err.span_label(trait_span, \"item in trait\");\n                          }\n                          err.emit()\n                     }\n@@ -1333,13 +1331,13 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             missing_items.iter()\n                   .map(|trait_item| trait_item.name.to_string())\n                   .collect::<Vec<_>>().join(\"`, `\"));\n-        err.span_label(impl_span, &format!(\"missing `{}` in implementation\",\n+        err.span_label(impl_span, format!(\"missing `{}` in implementation\",\n                 missing_items.iter()\n                     .map(|trait_item| trait_item.name.to_string())\n                     .collect::<Vec<_>>().join(\"`, `\")));\n         for trait_item in missing_items {\n             if let Some(span) = tcx.hir.span_if_local(trait_item.def_id) {\n-                err.span_label(span, &format!(\"`{}` from trait\", trait_item.name));\n+                err.span_label(span, format!(\"`{}` from trait\", trait_item.name));\n             } else {\n                 err.note(&format!(\"`{}` from trait: `{}`\",\n                                   trait_item.name,\n@@ -1376,8 +1374,12 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // contain themselves. For case 2, there must be an inner type that will be\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n-        Representability::SelfRecursive => {\n-            tcx.recursive_type_with_infinite_size_error(item_def_id).emit();\n+        Representability::SelfRecursive(spans) => {\n+            let mut err = tcx.recursive_type_with_infinite_size_error(item_def_id);\n+            for span in spans {\n+                err.span_label(span, \"recursive without indirection\");\n+            }\n+            err.emit();\n             return false\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),\n@@ -1397,7 +1399,7 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n             let e = fields[0].ty(tcx, substs);\n             if !fields.iter().all(|f| f.ty(tcx, substs) == e) {\n                 struct_span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\")\n-                                .span_label(sp, &format!(\"SIMD elements must have the same type\"))\n+                                .span_label(sp, \"SIMD elements must have the same type\")\n                                 .emit();\n                 return;\n             }\n@@ -1469,7 +1471,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         struct_span_err!(\n             tcx.sess, sp, E0084,\n             \"unsupported representation for zero-variant enum\")\n-            .span_label(sp, &format!(\"unsupported enum representation\"))\n+            .span_label(sp, \"unsupported enum representation\")\n             .emit();\n     }\n \n@@ -1503,8 +1505,8 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             };\n             struct_span_err!(tcx.sess, span, E0081,\n                              \"discriminant value `{}` already exists\", disr_vals[i])\n-                .span_label(i_span, &format!(\"first use of `{}`\", disr_vals[i]))\n-                .span_label(span , &format!(\"enum already has `{}`\", disr_vals[i]))\n+                .span_label(i_span, format!(\"first use of `{}`\", disr_vals[i]))\n+                .span_label(span , format!(\"enum already has `{}`\", disr_vals[i]))\n                 .emit();\n         }\n         disr_vals.push(discr);\n@@ -1516,10 +1518,6 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n-    fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>> {\n-        &self.ast_ty_to_ty_cache\n-    }\n-\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n         Some(&self.parameter_environment.free_substs)\n     }\n@@ -1621,7 +1619,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                body_id: ast::NodeId)\n                -> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n-            ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n             body_id: body_id,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n@@ -2404,12 +2401,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if arg_count == 1 {\" was\"} else {\"s were\"}),\n                 error_code);\n \n-            err.span_label(sp, &format!(\"expected {}{} parameter{}\",\n+            err.span_label(sp, format!(\"expected {}{} parameter{}\",\n                                         if variadic {\"at least \"} else {\"\"},\n                                         expected_count,\n                                         if expected_count == 1 {\"\"} else {\"s\"}));\n             if let Some(def_s) = def_span {\n-                err.span_label(def_s, &format!(\"defined here\"));\n+                err.span_label(def_s, \"defined here\");\n             }\n             err.emit();\n         }\n@@ -2941,10 +2938,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(suggested_field_name) =\n                         Self::suggest_field_name(def.struct_variant(), field, vec![]) {\n                             err.span_label(field.span,\n-                                           &format!(\"did you mean `{}`?\", suggested_field_name));\n+                                           format!(\"did you mean `{}`?\", suggested_field_name));\n                         } else {\n                             err.span_label(field.span,\n-                                           &format!(\"unknown field\"));\n+                                           \"unknown field\");\n                         };\n                 }\n                 ty::TyRawPtr(..) => {\n@@ -3079,15 +3076,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                            &field.name,\n                                                            skip_fields.collect()) {\n             err.span_label(field.name.span,\n-                           &format!(\"field does not exist - did you mean `{}`?\", field_name));\n+                           format!(\"field does not exist - did you mean `{}`?\", field_name));\n         } else {\n             match ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n-                    err.span_label(field.name.span, &format!(\"`{}::{}` does not have this field\",\n+                    err.span_label(field.name.span, format!(\"`{}::{}` does not have this field\",\n                                                              ty, variant.name));\n                 }\n                 _ => {\n-                    err.span_label(field.name.span, &format!(\"`{}` does not have this field\", ty));\n+                    err.span_label(field.name.span, format!(\"`{}` does not have this field\", ty));\n                 }\n             }\n         };\n@@ -3152,10 +3149,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                 \"field `{}` specified more than once\",\n                                                 field.name.node);\n \n-                    err.span_label(field.name.span, &format!(\"used more than once\"));\n+                    err.span_label(field.name.span, \"used more than once\");\n \n                     if let Some(prev_span) = seen_fields.get(&field.name.node) {\n-                        err.span_label(*prev_span, &format!(\"first use of `{}`\", field.name.node));\n+                        err.span_label(*prev_span, format!(\"first use of `{}`\", field.name.node));\n                     }\n \n                     err.emit();\n@@ -3202,7 +3199,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         remaining_fields_names,\n                         truncated_fields_error,\n                         adt_ty)\n-                        .span_label(span, &format!(\"missing {}{}\",\n+                        .span_label(span, format!(\"missing {}{}\",\n                             remaining_fields_names,\n                             truncated_fields_error))\n                         .emit();\n@@ -3269,7 +3266,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             struct_span_err!(self.tcx.sess, path_span, E0071,\n                              \"expected struct, variant or union type, found {}\",\n                              ty.sort_string(self.tcx))\n-                .span_label(path_span, &format!(\"not a struct\"))\n+                .span_label(path_span, \"not a struct\")\n                 .emit();\n             None\n         }\n@@ -3628,7 +3625,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     \"invalid left-hand side expression\")\n                 .span_label(\n                     expr.span,\n-                    &format!(\"left-hand of expression not valid\"))\n+                    \"left-hand of expression not valid\")\n                 .emit();\n             }\n \n@@ -4520,7 +4517,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                              \"too many lifetime parameters provided: \\\n                               expected at most {}, found {}\",\n                              expected_text, actual_text)\n-                .span_label(span, &format!(\"expected {}\", expected_text))\n+                .span_label(span, format!(\"expected {}\", expected_text))\n                 .emit();\n         } else if lifetimes.len() > 0 && lifetimes.len() < lifetime_defs.len() {\n             let expected_text = count_lifetime_params(lifetime_defs.len());\n@@ -4529,7 +4526,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                              \"too few lifetime parameters provided: \\\n                               expected {}, found {}\",\n                              expected_text, actual_text)\n-                .span_label(span, &format!(\"expected {}\", expected_text))\n+                .span_label(span, format!(\"expected {}\", expected_text))\n                 .emit();\n         }\n \n@@ -4554,7 +4551,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                              \"too many type parameters provided: \\\n                               expected at most {}, found {}\",\n                              expected_text, actual_text)\n-                .span_label(span, &format!(\"expected {}\", expected_text))\n+                .span_label(span, format!(\"expected {}\", expected_text))\n                 .emit();\n \n             // To prevent derived errors to accumulate due to extra\n@@ -4568,7 +4565,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                              \"too few type parameters provided: \\\n                               expected {}, found {}\",\n                              expected_text, actual_text)\n-                .span_label(span, &format!(\"expected {}\", expected_text))\n+                .span_label(span, format!(\"expected {}\", expected_text))\n                 .emit();\n         }\n \n@@ -4657,7 +4654,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             struct_span_err!(tcx.sess, param.span, E0091,\n                 \"type parameter `{}` is unused\",\n                 param.name)\n-                .span_label(param.span, &format!(\"unused type parameter\"))\n+                .span_label(param.span, \"unused type parameter\")\n                 .emit();\n         }\n     }"}, {"sha": "59cb61d9b97f0b3196126eb3637a6daca34a0c29", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 E0067, \"invalid left-hand side expression\")\n             .span_label(\n                 lhs_expr.span,\n-                &format!(\"invalid expression for left-hand side\"))\n+                \"invalid expression for left-hand side\")\n             .emit();\n         }\n         ty\n@@ -203,7 +203,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                          op.node.as_str(),\n                                          lhs_ty)\n                             .span_label(lhs_expr.span,\n-                                        &format!(\"cannot use `{}=` on type `{}`\",\n+                                        format!(\"cannot use `{}=` on type `{}`\",\n                                         op.node.as_str(), lhs_ty))\n                             .emit();\n                     } else {\n@@ -278,7 +278,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if let TyRef(_, r_ty) = rhs_ty.sty {\n                 if l_ty.ty.sty == TyStr && r_ty.ty.sty == TyStr {\n                     err.span_label(expr.span,\n-                        &\"`+` can't be used to concatenate two `&str` strings\");\n+                        \"`+` can't be used to concatenate two `&str` strings\");\n                     let codemap = self.tcx.sess.codemap();\n                     let suggestion =\n                         match codemap.span_to_snippet(lhs_expr.span) {"}, {"sha": "93529aecac039f883a39c9982543090002e819f4", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -684,15 +684,15 @@ fn error_392<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, param_name: ast:\n                        -> DiagnosticBuilder<'tcx> {\n     let mut err = struct_span_err!(tcx.sess, span, E0392,\n                   \"parameter `{}` is never used\", param_name);\n-    err.span_label(span, &format!(\"unused type parameter\"));\n+    err.span_label(span, \"unused type parameter\");\n     err\n }\n \n fn error_194(tcx: TyCtxt, span: Span, trait_decl_span: Span, name: ast::Name) {\n     struct_span_err!(tcx.sess, span, E0194,\n               \"type parameter `{}` shadows another type parameter of the same name\",\n               name)\n-        .span_label(span, &format!(\"shadows another type parameter\"))\n-        .span_label(trait_decl_span, &format!(\"first `{}` declared here\", name))\n+        .span_label(span, \"shadows another type parameter\")\n+        .span_label(trait_decl_span, format!(\"first `{}` declared here\", name))\n         .emit();\n }"}, {"sha": "49440037af57572f5f6f81fb7d244a32f820dd14", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -43,7 +43,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n         wbcx.visit_anon_types();\n-        wbcx.visit_type_nodes();\n         wbcx.visit_cast_types();\n         wbcx.visit_lints();\n         wbcx.visit_free_region_map();\n@@ -442,13 +441,6 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_type_nodes(&self) {\n-        for (&id, ty) in self.fcx.ast_ty_to_ty_cache.borrow().iter() {\n-            let ty = self.resolve(ty, &id);\n-            self.fcx.tcx.ast_ty_to_ty_cache.borrow_mut().insert(id, ty);\n-        }\n-    }\n-\n     fn resolve<T>(&self, x: &T, span: &Locatable) -> T::Lifted\n         where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n     {"}, {"sha": "743bfbb44ab7504ef2af4017a9f35fea53b22ae8", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -74,7 +74,7 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                          E0120,\n                                          \"the Drop trait may only be implemented on \\\n                                          structures\")\n-                            .span_label(span, &format!(\"implementing Drop requires a struct\"))\n+                            .span_label(span, \"implementing Drop requires a struct\")\n                             .emit();\n                     }\n                     _ => {\n@@ -130,7 +130,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              \"the trait `Copy` may not be implemented for this type\")\n                 .span_label(\n                     tcx.def_span(field.did),\n-                    &\"this field does not implement `Copy`\")\n+                    \"this field does not implement `Copy`\")\n                 .emit()\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n@@ -145,7 +145,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              span,\n                              E0206,\n                              \"the trait `Copy` may not be implemented for this type\")\n-                .span_label(span, &format!(\"type is not a structure or enumeration\"))\n+                .span_label(span, \"type is not a structure or enumeration\")\n                 .emit();\n         }\n         Err(CopyImplementationError::HasDestructor) => {\n@@ -154,7 +154,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              E0184,\n                              \"the trait `Copy` may not be implemented for this type; the \\\n                               type has a destructor\")\n-                .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n+                .span_label(span, \"Copy not allowed on types with destructors\")\n                 .emit();\n         }\n     }\n@@ -310,7 +310,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           })\n                                           .collect::<Vec<_>>()\n                                           .join(\", \")));\n-                    err.span_label(span, &format!(\"requires multiple coercions\"));\n+                    err.span_label(span, \"requires multiple coercions\");\n                     err.emit();\n                     return err_info;\n                 }"}, {"sha": "f7ebc21044222d28c90c309c62903e235656018c", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -259,7 +259,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n                                  ty.span,\n                                  E0118,\n                                  \"no base type found for inherent implementation\")\n-                    .span_label(ty.span, &format!(\"impl requires a base type\"))\n+                    .span_label(ty.span, \"impl requires a base type\")\n                     .note(&format!(\"either implement a trait on it or create a newtype \\\n                                     to wrap it instead\"))\n                     .emit();\n@@ -296,7 +296,7 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n                              \"cannot define inherent `impl` for a type outside of the crate \\\n                               where the type is defined\")\n                 .span_label(item.span,\n-                            &format!(\"impl for type defined outside of crate.\"))\n+                            \"impl for type defined outside of crate.\")\n                 .note(\"define and implement a trait or new type instead\")\n                 .emit();\n         }"}, {"sha": "2751e1ff38a5090620344d49ded167658087a8e5", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -56,9 +56,9 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n                                      \"duplicate definitions with name `{}`\",\n                                      name)\n                         .span_label(self.tcx.span_of_impl(item1).unwrap(),\n-                                    &format!(\"duplicate definitions for `{}`\", name))\n+                                    format!(\"duplicate definitions for `{}`\", name))\n                         .span_label(self.tcx.span_of_impl(item2).unwrap(),\n-                                    &format!(\"other definition for `{}`\", name))\n+                                    format!(\"other definition for `{}`\", name))\n                         .emit();\n                 }\n             }"}, {"sha": "8b9dc20315d25fff85ee0a9bf6a2b51cb6907a59", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -62,7 +62,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_d\n                          span,\n                          E0322,\n                          \"explicit impls for the `Sized` trait are not permitted\")\n-            .span_label(span, &format!(\"impl of 'Sized' not allowed\"))\n+            .span_label(span, \"impl of 'Sized' not allowed\")\n             .emit();\n         return;\n     }"}, {"sha": "097720adad447ee15bcee5fa4daf5c6d47345d6c", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -48,7 +48,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                          E0117,\n                                          \"only traits defined in the current crate can be \\\n                                           implemented for arbitrary types\")\n-                            .span_label(item.span, &format!(\"impl doesn't use types inside crate\"))\n+                            .span_label(item.span, \"impl doesn't use types inside crate\")\n                             .note(&format!(\"the impl does not reference any types defined in \\\n                                             this crate\"))\n                             .note(\"define and implement a trait or new type instead\")\n@@ -153,7 +153,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                      \"cannot create default implementations for traits outside \\\n                                       the crate they're defined in; define a new trait instead\")\n                         .span_label(item_trait_ref.path.span,\n-                                    &format!(\"`{}` trait not defined in this crate\",\n+                                    format!(\"`{}` trait not defined in this crate\",\n                             self.tcx.hir.node_to_pretty_string(item_trait_ref.ref_id)))\n                         .emit();\n                     return;"}, {"sha": "f479dc2e6ab617a60a52a60f8bf091d6b05b0834", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -60,9 +60,9 @@ pub fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n \n         match tcx.span_of_impl(overlap.with_impl) {\n             Ok(span) => {\n-                err.span_label(span, &format!(\"first implementation here\"));\n+                err.span_label(span, \"first implementation here\");\n                 err.span_label(tcx.span_of_impl(impl_def_id).unwrap(),\n-                               &format!(\"conflicting implementation{}\",\n+                               format!(\"conflicting implementation{}\",\n                                         overlap.self_desc\n                                             .map_or(String::new(),\n                                                     |ty| format!(\" for `{}`\", ty))));"}, {"sha": "ec200241ee695cc4a5f635b481cc6d0fe0cdc416", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -64,11 +64,10 @@ use rustc::ty::{ToPredicate, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n-use util::nodemap::{NodeMap, FxHashMap};\n+use util::nodemap::FxHashMap;\n \n use rustc_const_math::ConstInt;\n \n-use std::cell::RefCell;\n use std::collections::BTreeMap;\n \n use syntax::{abi, ast};\n@@ -116,7 +115,7 @@ pub fn provide(providers: &mut Providers) {\n /// `ItemCtxt` is parameterized by a `DefId` that it uses to satisfy\n /// `get_type_parameter_bounds` requests, drawing the information from\n /// the AST (`hir::Generics`), recursively.\n-struct ItemCtxt<'a,'tcx:'a> {\n+pub struct ItemCtxt<'a,'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     item_def_id: DefId,\n }\n@@ -180,7 +179,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n // Utility types and common code for the above passes.\n \n impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n            -> ItemCtxt<'a,'tcx> {\n         ItemCtxt {\n             tcx: tcx,\n@@ -190,18 +189,14 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n }\n \n impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n-    fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+    pub fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n }\n \n impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n \n-    fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>> {\n-        &self.tcx.ast_ty_to_ty_cache\n-    }\n-\n     fn get_type_parameter_bounds(&self,\n                                  span: Span,\n                                  def_id: DefId)\n@@ -225,7 +220,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n             span,\n             E0121,\n             \"the type placeholder `_` is not allowed within types on item signatures\"\n-        ).span_label(span, &format!(\"not allowed in type signatures\"))\n+        ).span_label(span, \"not allowed in type signatures\")\n         .emit();\n         self.tcx().types.err\n     }\n@@ -573,7 +568,7 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         } else {\n             struct_span_err!(tcx.sess, variant.span, E0370,\n                              \"enum discriminant overflowed\")\n-                .span_label(variant.span, &format!(\"overflowed on value after {}\",\n+                .span_label(variant.span, format!(\"overflowed on value after {}\",\n                                                    prev_discr.unwrap()))\n                 .note(&format!(\"explicitly set `{} = {}` if that is desired outcome\",\n                                variant.node.name, wrapped_discr))\n@@ -609,8 +604,8 @@ fn convert_struct_variant<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             struct_span_err!(tcx.sess, f.span, E0124,\n                              \"field `{}` is already declared\",\n                              f.name)\n-                .span_label(f.span, &\"field already declared\")\n-                .span_label(prev_span, &format!(\"`{}` first declared here\", f.name))\n+                .span_label(f.span, \"field already declared\")\n+                .span_label(prev_span, format!(\"`{}` first declared here\", f.name))\n                 .emit();\n         } else {\n             seen_fields.insert(f.name, f.span);"}, {"sha": "6b4f08d3d4c8d73aca47443d934014ec687f4d07", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -166,7 +166,7 @@ fn report_unused_parameter(tcx: TyCtxt,\n         \"the {} parameter `{}` is not constrained by the \\\n         impl trait, self type, or predicates\",\n         kind, name)\n-        .span_label(span, &format!(\"unconstrained {} parameter\", kind))\n+        .span_label(span, format!(\"unconstrained {} parameter\", kind))\n         .emit();\n }\n \n@@ -188,9 +188,9 @@ fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                \"duplicate definitions with name `{}`:\",\n                                                impl_item.name);\n                 err.span_label(*entry.get(),\n-                               &format!(\"previous definition of `{}` here\",\n+                               format!(\"previous definition of `{}` here\",\n                                         impl_item.name));\n-                err.span_label(impl_item.span, &format!(\"duplicate definition\"));\n+                err.span_label(impl_item.span, \"duplicate definition\");\n                 err.emit();\n             }\n             Vacant(entry) => {"}, {"sha": "84de4ff2b7b69203b32cb09ba36c42231bd68c86", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -122,14 +122,14 @@ use std::iter;\n // registered before they are used.\n pub mod diagnostics;\n \n-pub mod check;\n-pub mod check_unused;\n+mod check;\n+mod check_unused;\n mod astconv;\n-pub mod collect;\n+mod collect;\n mod constrained_type_params;\n mod impl_wf_check;\n-pub mod coherence;\n-pub mod variance;\n+mod coherence;\n+mod variance;\n \n pub struct TypeAndSubsts<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n@@ -143,7 +143,7 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n     if decl.variadic && abi != Abi::C {\n         let mut err = struct_span_err!(tcx.sess, span, E0045,\n                   \"variadic function must have C calling convention\");\n-        err.span_label(span, &(\"variadics require C calling conventions\").to_string())\n+        err.span_label(span, \"variadics require C calling conventions\")\n             .emit();\n     }\n }\n@@ -190,7 +190,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 struct_span_err!(tcx.sess, generics.span, E0131,\n                                          \"main function is not allowed to have type parameters\")\n                                     .span_label(generics.span,\n-                                                &format!(\"main cannot have type parameters\"))\n+                                                \"main cannot have type parameters\")\n                                     .emit();\n                                 return;\n                             }\n@@ -240,7 +240,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             struct_span_err!(tcx.sess, ps.span, E0132,\n                                 \"start function is not allowed to have type parameters\")\n                                 .span_label(ps.span,\n-                                            &format!(\"start function cannot have type parameters\"))\n+                                            \"start function cannot have type parameters\")\n                                 .emit();\n                             return;\n                         }\n@@ -293,6 +293,7 @@ pub fn provide(providers: &mut Providers) {\n     collect::provide(providers);\n     coherence::provide(providers);\n     check::provide(providers);\n+    variance::provide(providers);\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n@@ -307,9 +308,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n     })?;\n \n-    time(time_passes, \"variance inference\", ||\n-         variance::infer_variance(tcx));\n-\n     tcx.sess.track_errors(|| {\n         time(time_passes, \"impl wf inference\", ||\n              impl_wf_check::impl_wf_check(tcx));\n@@ -320,6 +318,11 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n           coherence::check_coherence(tcx));\n     })?;\n \n+    tcx.sess.track_errors(|| {\n+        time(time_passes, \"variance testing\", ||\n+             variance::test::test_variance(tcx));\n+    })?;\n+\n     time(time_passes, \"wf checking\", || check::check_wf_new(tcx))?;\n \n     time(time_passes, \"item-types checking\", || check::check_item_types(tcx))?;\n@@ -337,4 +340,16 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     }\n }\n \n+/// A quasi-deprecated helper used in rustdoc and save-analysis to get\n+/// the type from a HIR node.\n+pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n+    // In case there are any projections etc, find the \"environment\"\n+    // def-id that will be used to determine the traits/predicates in\n+    // scope.  This is derived from the enclosing item-like thing.\n+    let env_node_id = tcx.hir.get_parent(hir_ty.id);\n+    let env_def_id = tcx.hir.local_def_id(env_node_id);\n+    let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n+    item_cx.to_ty(hir_ty)\n+}\n+\n __build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}, {"sha": "592916178897c8ab203ec2dd6f06f852f325e742", "filename": "src/librustc_typeck/variance/README.md", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2FREADME.md?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -97,51 +97,29 @@ types involved before considering variance.\n \n #### Dependency graph management\n \n-Because variance works in two phases, if we are not careful, we wind\n-up with a muddled mess of a dep-graph. Basically, when gathering up\n-the constraints, things are fairly well-structured, but then we do a\n-fixed-point iteration and write the results back where they\n-belong. You can't give this fixed-point iteration a single task\n-because it reads from (and writes to) the variance of all types in the\n-crate. In principle, we *could* switch the \"current task\" in a very\n-fine-grained way while propagating constraints in the fixed-point\n-iteration and everything would be automatically tracked, but that\n-would add some overhead and isn't really necessary anyway.\n-\n-Instead what we do is to add edges into the dependency graph as we\n-construct the constraint set: so, if computing the constraints for\n-node `X` requires loading the inference variables from node `Y`, then\n-we can add an edge `Y -> X`, since the variance we ultimately infer\n-for `Y` will affect the variance we ultimately infer for `X`.\n-\n-At this point, we've basically mirrored the inference graph in the\n-dependency graph. This means we can just completely ignore the\n-fixed-point iteration, since it is just shuffling values along this\n-graph. In other words, if we added the fine-grained switching of tasks\n-I described earlier, all it would show is that we repeatedly read the\n-values described by the constraints, but those edges were already\n-added when building the constraints in the first place.\n-\n-Here is how this is implemented (at least as of the time of this\n-writing). The associated `DepNode` for the variance map is (at least\n-presently) `Signature(DefId)`. This means that, in `constraints.rs`,\n-when we visit an item to load up its constraints, we set\n-`Signature(DefId)` as the current task (the \"memoization\" pattern\n-described in the `dep-graph` README). Then whenever we find an\n-embedded type or trait, we add a synthetic read of `Signature(DefId)`,\n-which covers the variances we will compute for all of its\n-parameters. This read is synthetic (i.e., we call\n-`variance_map.read()`) because, in fact, the final variance is not yet\n-computed -- the read *will* occur (repeatedly) during the fixed-point\n-iteration phase.\n-\n-In fact, we don't really *need* this synthetic read. That's because we\n-do wind up looking up the `TypeScheme` or `TraitDef` for all\n-references types/traits, and those reads add an edge from\n-`Signature(DefId)` (that is, they share the same dep node as\n-variance). However, I've kept the synthetic reads in place anyway,\n-just for future-proofing (in case we change the dep-nodes in the\n-future), and because it makes the intention a bit clearer I think.\n+Because variance is a whole-crate inference, its dependency graph\n+can become quite muddled if we are not careful. To resolve this, we refactor\n+into two queries:\n+\n+- `crate_variances` computes the variance for all items in the current crate.\n+- `variances_of` accesses the variance for an individual reading; it\n+  works by requesting `crate_variances` and extracting the relevant data.\n+  \n+If you limit yourself to reading `variances_of`, your code will only\n+depend then on the inference inferred for that particular item.\n+\n+Eventually, the goal is to rely on the red-green dependency management\n+algorithm. At the moment, however, we rely instead on a hack, where\n+`variances_of` ignores the dependencies of accessing\n+`crate_variances` and instead computes the *correct* dependencies\n+itself. To this end, when we build up the constraints in the system,\n+we also built up a transitive `dependencies` relation as part of the\n+crate map. A `(X, Y)` pair is added to the map each time we have a\n+constraint that the variance of some inferred for the item `X` depends\n+on the variance of some element of `Y`. This is to some extent a\n+mirroring of the inference graph in the dependency graph. This means\n+we can just completely ignore the fixed-point iteration, since it is\n+just shuffling values along this graph.\n \n ### Addendum: Variance on traits\n "}, {"sha": "e986a381cd963df034968e27a66fa463c2a5c2e6", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 149, "deletions": 95, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -15,19 +15,20 @@\n \n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n+use rustc::dep_graph::{AssertDepGraphSafe, DepNode};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::map as hir_map;\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n+\n use super::terms::*;\n use super::terms::VarianceTerm::*;\n use super::xform::*;\n \n-use dep_graph::DepNode::ItemSignature as VarianceDepNode;\n-\n pub struct ConstraintContext<'a, 'tcx: 'a> {\n     pub terms_cx: TermsContext<'a, 'tcx>,\n \n@@ -38,6 +39,11 @@ pub struct ConstraintContext<'a, 'tcx: 'a> {\n     bivariant: VarianceTermPtr<'a>,\n \n     pub constraints: Vec<Constraint<'a>>,\n+\n+    /// This relation tracks the dependencies between the variance of\n+    /// various items. In particular, if `a < b`, then the variance of\n+    /// `a` depends on the sources of `b`.\n+    pub dependencies: TransitiveRelation<DefId>,\n }\n \n /// Declares that the variable `decl_id` appears in a location with\n@@ -48,6 +54,20 @@ pub struct Constraint<'a> {\n     pub variance: &'a VarianceTerm<'a>,\n }\n \n+/// To build constriants, we visit one item (type, trait) at a time\n+/// and look at its contents. So e.g. if we have\n+///\n+///     struct Foo<T> {\n+///         b: Bar<T>\n+///     }\n+///\n+/// then while we are visiting `Bar<T>`, the `CurrentItem` would have\n+/// the def-id and generics of `Foo`.\n+pub struct CurrentItem<'a> {\n+    def_id: DefId,\n+    generics: &'a ty::Generics,\n+}\n+\n pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n                                             -> ConstraintContext<'a, 'tcx> {\n     let tcx = terms_cx.tcx;\n@@ -62,50 +82,93 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n         invariant: invariant,\n         bivariant: bivariant,\n         constraints: Vec::new(),\n+        dependencies: TransitiveRelation::new(),\n     };\n \n-    // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_item_likes_in_krate(VarianceDepNode, &mut constraint_cx);\n+    tcx.hir.krate().visit_all_item_likes(&mut constraint_cx);\n \n     constraint_cx\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let tcx = self.terms_cx.tcx;\n-        let did = tcx.hir.local_def_id(item.id);\n+        let def_id = tcx.hir.local_def_id(item.id);\n+\n+        // Encapsulate constructing the constraints into a task we can\n+        // reference later. This can go away once the red-green\n+        // algorithm is in place.\n+        //\n+        // See README.md for a detailed discussion\n+        // on dep-graph management.\n+        match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) => {\n+                tcx.dep_graph.with_task(DepNode::ItemVarianceConstraints(def_id),\n+                                        AssertDepGraphSafe(self),\n+                                        def_id,\n+                                        visit_item_task);\n+            }\n+            _ => {\n+                // Nothing to do here, skip the task.\n+            }\n+        }\n+\n+        fn visit_item_task<'a, 'tcx>(ccx: AssertDepGraphSafe<&mut ConstraintContext<'a, 'tcx>>,\n+                                     def_id: DefId)\n+        {\n+            ccx.0.build_constraints_for_item(def_id);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n+}\n+\n+/// Is `param_id` a lifetime according to `map`?\n+fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n+    match map.find(param_id) {\n+        Some(hir_map::NodeLifetime(..)) => true,\n+        _ => false,\n+    }\n+}\n+\n+impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.terms_cx.tcx\n+    }\n \n+    fn build_constraints_for_item(&mut self, def_id: DefId) {\n+        let tcx = self.tcx();\n+        let id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n+        let item = tcx.hir.expect_item(id);\n         debug!(\"visit_item item={}\", tcx.hir.node_to_string(item.id));\n \n         match item.node {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                let generics = tcx.generics_of(did);\n+                let generics = tcx.generics_of(def_id);\n+                let current_item = &CurrentItem { def_id, generics };\n \n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n                 //\n                 // self.add_constraints_from_generics(generics);\n \n-                for field in tcx.adt_def(did).all_fields() {\n-                    self.add_constraints_from_ty(generics,\n+                for field in tcx.adt_def(def_id).all_fields() {\n+                    self.add_constraints_from_ty(current_item,\n                                                  tcx.type_of(field.did),\n                                                  self.covariant);\n                 }\n             }\n-            hir::ItemTrait(..) => {\n-                let generics = tcx.generics_of(did);\n-                let trait_ref = ty::TraitRef {\n-                    def_id: did,\n-                    substs: Substs::identity_for_item(tcx, did)\n-                };\n-                self.add_constraints_from_trait_ref(generics,\n-                                                    trait_ref,\n-                                                    self.invariant);\n-            }\n \n+            hir::ItemTrait(..) |\n             hir::ItemExternCrate(_) |\n             hir::ItemUse(..) |\n             hir::ItemStatic(..) |\n@@ -116,38 +179,25 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemGlobalAsm(..) |\n             hir::ItemTy(..) |\n             hir::ItemImpl(..) |\n-            hir::ItemDefaultImpl(..) => {}\n+            hir::ItemDefaultImpl(..) => {\n+                span_bug!(item.span, \"`build_constraints_for_item` invoked for non-type-def\");\n+            }\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-\n-/// Is `param_id` a lifetime according to `map`?\n-fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n-    match map.find(param_id) {\n-        Some(hir_map::NodeLifetime(..)) => true,\n-        _ => false,\n-    }\n-}\n-\n-impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.terms_cx.tcx\n+    /// Load the generics for another item, adding a corresponding\n+    /// relation into the dependencies to indicate that the variance\n+    /// for `current` relies on `def_id`.\n+    fn read_generics(&mut self, current: &CurrentItem, def_id: DefId) -> &'tcx ty::Generics {\n+        let generics = self.tcx().generics_of(def_id);\n+        if self.tcx().dep_graph.is_fully_enabled() {\n+            self.dependencies.add(current.def_id, def_id);\n+        }\n+        generics\n     }\n \n-    fn inferred_index(&self, param_id: ast::NodeId) -> InferredIndex {\n-        match self.terms_cx.inferred_map.get(&param_id) {\n-            Some(&index) => index,\n-            None => {\n-                bug!(\"no inferred index entry for {}\",\n-                     self.tcx().hir.node_to_string(param_id));\n-            }\n-        }\n+    fn opt_inferred_index(&self, param_id: ast::NodeId) -> Option<&InferredIndex> {\n+        self.terms_cx.inferred_map.get(&param_id)\n     }\n \n     fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n@@ -228,8 +278,27 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n-            let InferredIndex(index) = self.inferred_index(param_node_id);\n-            self.terms_cx.inferred_infos[index].term\n+            if let Some(&InferredIndex(index)) = self.opt_inferred_index(param_node_id) {\n+                self.terms_cx.inferred_infos[index].term\n+            } else {\n+                // If there is no inferred entry for a type parameter,\n+                // it must be declared on a (locally defiend) trait -- they don't\n+                // get inferreds because they are always invariant.\n+                if cfg!(debug_assertions) {\n+                    let item_node_id = self.tcx().hir.as_local_node_id(item_def_id).unwrap();\n+                    let item = self.tcx().hir.expect_item(item_node_id);\n+                    let success = match item.node {\n+                        hir::ItemTrait(..) => true,\n+                        _ => false,\n+                    };\n+                    if !success {\n+                        bug!(\"parameter {:?} has no inferred, but declared on non-trait: {:?}\",\n+                             item_def_id,\n+                             item);\n+                    }\n+                }\n+                self.invariant\n+            }\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n@@ -279,7 +348,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     }\n \n     fn add_constraints_from_trait_ref(&mut self,\n-                                      generics: &ty::Generics,\n+                                      current: &CurrentItem,\n                                       trait_ref: ty::TraitRef<'tcx>,\n                                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n@@ -288,12 +357,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n \n-        // This edge is actually implied by the call to\n-        // `trait_def`, but I'm trying to be future-proof. See\n-        // README.md for a discussion on dep-graph management.\n-        self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n-\n-        self.add_constraints_from_substs(generics,\n+        self.add_constraints_from_substs(current,\n                                          trait_ref.def_id,\n                                          &trait_generics.types,\n                                          &trait_generics.regions,\n@@ -305,7 +369,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// in a context with the generics defined in `generics` and\n     /// ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n-                               generics: &ty::Generics,\n+                               current: &CurrentItem,\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={:?}, variance={:?})\",\n@@ -325,34 +389,29 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyRef(region, ref mt) => {\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, region, contra);\n-                self.add_constraints_from_mt(generics, mt, variance);\n+                self.add_constraints_from_region(current, region, contra);\n+                self.add_constraints_from_mt(current, mt, variance);\n             }\n \n             ty::TyArray(typ, _) |\n             ty::TySlice(typ) => {\n-                self.add_constraints_from_ty(generics, typ, variance);\n+                self.add_constraints_from_ty(current, typ, variance);\n             }\n \n             ty::TyRawPtr(ref mt) => {\n-                self.add_constraints_from_mt(generics, mt, variance);\n+                self.add_constraints_from_mt(current, mt, variance);\n             }\n \n             ty::TyTuple(subtys, _) => {\n                 for &subty in subtys {\n-                    self.add_constraints_from_ty(generics, subty, variance);\n+                    self.add_constraints_from_ty(current, subty, variance);\n                 }\n             }\n \n             ty::TyAdt(def, substs) => {\n-                let adt_generics = self.tcx().generics_of(def.did);\n+                let adt_generics = self.read_generics(current, def.did);\n \n-                // This edge is actually implied by the call to\n-                // `trait_def`, but I'm trying to be future-proof. See\n-                // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(VarianceDepNode(def.did));\n-\n-                self.add_constraints_from_substs(generics,\n+                self.add_constraints_from_substs(current,\n                                                  def.did,\n                                                  &adt_generics.types,\n                                                  &adt_generics.regions,\n@@ -364,12 +423,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 let trait_ref = &data.trait_ref;\n                 let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n \n-                // This edge is actually implied by the call to\n-                // `trait_def`, but I'm trying to be future-proof. See\n-                // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n-\n-                self.add_constraints_from_substs(generics,\n+                self.add_constraints_from_substs(current,\n                                                  trait_ref.def_id,\n                                                  &trait_generics.types,\n                                                  &trait_generics.regions,\n@@ -380,25 +434,25 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::TyDynamic(ref data, r) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, r, contra);\n+                self.add_constraints_from_region(current, r, contra);\n \n                 if let Some(p) = data.principal() {\n                     let poly_trait_ref = p.with_self_ty(self.tcx(), self.tcx().types.err);\n-                    self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n+                    self.add_constraints_from_trait_ref(current, poly_trait_ref.0, variance);\n                 }\n \n                 for projection in data.projection_bounds() {\n-                    self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n+                    self.add_constraints_from_ty(current, projection.0.ty, self.invariant);\n                 }\n             }\n \n             ty::TyParam(ref data) => {\n-                assert_eq!(generics.parent, None);\n+                assert_eq!(current.generics.parent, None);\n                 let mut i = data.idx as usize;\n-                if !generics.has_self || i > 0 {\n-                    i -= generics.regions.len();\n+                if !current.generics.has_self || i > 0 {\n+                    i -= current.generics.regions.len();\n                 }\n-                let def_id = generics.types[i].def_id;\n+                let def_id = current.generics.types[i].def_id;\n                 let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 match self.terms_cx.inferred_map.get(&node_id) {\n                     Some(&index) => {\n@@ -414,7 +468,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyFnDef(.., sig) |\n             ty::TyFnPtr(sig) => {\n-                self.add_constraints_from_sig(generics, sig, variance);\n+                self.add_constraints_from_sig(current, sig, variance);\n             }\n \n             ty::TyError => {\n@@ -433,7 +487,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a nominal type (enum, struct,\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n-                                   generics: &ty::Generics,\n+                                   current: &CurrentItem,\n                                    def_id: DefId,\n                                    type_param_defs: &[ty::TypeParameterDef],\n                                    region_param_defs: &[ty::RegionParameterDef],\n@@ -451,44 +505,44 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl,\n                    variance_i);\n-            self.add_constraints_from_ty(generics, substs_ty, variance_i);\n+            self.add_constraints_from_ty(current, substs_ty, variance_i);\n         }\n \n         for p in region_param_defs {\n             let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_r = substs.region_for_def(p);\n-            self.add_constraints_from_region(generics, substs_r, variance_i);\n+            self.add_constraints_from_region(current, substs_r, variance_i);\n         }\n     }\n \n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n-                                generics: &ty::Generics,\n+                                current: &CurrentItem,\n                                 sig: ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n         for &input in sig.0.inputs() {\n-            self.add_constraints_from_ty(generics, input, contra);\n+            self.add_constraints_from_ty(current, input, contra);\n         }\n-        self.add_constraints_from_ty(generics, sig.0.output(), variance);\n+        self.add_constraints_from_ty(current, sig.0.output(), variance);\n     }\n \n     /// Adds constraints appropriate for a region appearing in a\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n-                                   generics: &ty::Generics,\n+                                   current: &CurrentItem,\n                                    region: ty::Region<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                assert_eq!(generics.parent, None);\n-                let i = data.index as usize - generics.has_self as usize;\n-                let def_id = generics.regions[i].def_id;\n+                assert_eq!(current.generics.parent, None);\n+                let i = data.index as usize - current.generics.has_self as usize;\n+                let def_id = current.generics.regions[i].def_id;\n                 let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n-                    let index = self.inferred_index(node_id);\n+                    let &index = self.opt_inferred_index(node_id).unwrap();\n                     self.add_constraint(index, variance);\n                 }\n             }\n@@ -518,17 +572,17 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a mutability-type pair\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,\n-                               generics: &ty::Generics,\n+                               current: &CurrentItem,\n                                mt: &ty::TypeAndMut<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n             hir::MutMutable => {\n                 let invar = self.invariant(variance);\n-                self.add_constraints_from_ty(generics, mt.ty, invar);\n+                self.add_constraints_from_ty(current, mt.ty, invar);\n             }\n \n             hir::MutImmutable => {\n-                self.add_constraints_from_ty(generics, mt.ty, variance);\n+                self.add_constraints_from_ty(current, mt.ty, variance);\n             }\n         }\n     }"}, {"sha": "1afe2725ac87d6fabbebe93b5c58a73b5d17b344", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -12,7 +12,12 @@\n //! parameters. See README.md for details.\n \n use arena;\n-use rustc::ty::TyCtxt;\n+use rustc::dep_graph::DepNode;\n+use rustc::hir;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::ty::{self, CrateVariancesMap, TyCtxt};\n+use rustc::ty::maps::Providers;\n+use std::rc::Rc;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n /// allocate terms.\n@@ -24,13 +29,67 @@ mod constraints;\n /// Code to solve constraints and write out the results.\n mod solve;\n \n+/// Code to write unit tests of variance.\n+pub mod test;\n+\n /// Code for transforming variances.\n mod xform;\n \n-pub fn infer_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        variances_of,\n+        crate_variances,\n+        ..*providers\n+    };\n+}\n+\n+fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n+                             -> Rc<CrateVariancesMap> {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::new();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n-    solve::solve_constraints(constraints_cx);\n-    tcx.variance_computed.set(true);\n+    Rc::new(solve::solve_constraints(constraints_cx))\n+}\n+\n+fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n+                            -> Rc<Vec<ty::Variance>> {\n+    let item_id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n+    let item = tcx.hir.expect_item(item_id);\n+    match item.node {\n+        hir::ItemTrait(..) => {\n+            // Traits are always invariant.\n+            let generics = tcx.generics_of(item_def_id);\n+            assert!(generics.parent.is_none());\n+            Rc::new(vec![ty::Variance::Invariant; generics.count()])\n+        }\n+\n+        hir::ItemEnum(..) |\n+        hir::ItemStruct(..) |\n+        hir::ItemUnion(..) => {\n+            // Everything else must be inferred.\n+\n+            // Lacking red/green, we read the variances for all items here\n+            // but ignore the dependencies, then re-synthesize the ones we need.\n+            let crate_map = tcx.dep_graph.with_ignore(|| tcx.crate_variances(LOCAL_CRATE));\n+            tcx.dep_graph.read(DepNode::ItemVarianceConstraints(item_def_id));\n+            for &dep_def_id in crate_map.dependencies.less_than(&item_def_id) {\n+                if dep_def_id.is_local() {\n+                    tcx.dep_graph.read(DepNode::ItemVarianceConstraints(dep_def_id));\n+                } else {\n+                    tcx.dep_graph.read(DepNode::ItemVariances(dep_def_id));\n+                }\n+            }\n+\n+            crate_map.variances.get(&item_def_id)\n+                               .unwrap_or(&crate_map.empty_variance)\n+                               .clone()\n+        }\n+\n+        _ => {\n+            // Variance not relevant.\n+            span_bug!(item.span, \"asked to compute variance for wrong kind of item\")\n+        }\n+    }\n }\n+"}, {"sha": "af8ad491ec00e7075ba0a5c3e2a56922bdb30ef5", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -15,7 +15,9 @@\n //! optimal solution to the constraints. The final variance for each\n //! inferred is then written into the `variance_map` in the tcx.\n \n+use rustc::hir::def_id::DefId;\n use rustc::ty;\n+use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n \n use super::constraints::*;\n@@ -31,8 +33,8 @@ struct SolveContext<'a, 'tcx: 'a> {\n     solutions: Vec<ty::Variance>,\n }\n \n-pub fn solve_constraints(constraints_cx: ConstraintContext) {\n-    let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n+pub fn solve_constraints(constraints_cx: ConstraintContext) -> ty::CrateVariancesMap {\n+    let ConstraintContext { terms_cx, dependencies, constraints, .. } = constraints_cx;\n \n     let solutions = terms_cx.inferred_infos\n         .iter()\n@@ -45,7 +47,10 @@ pub fn solve_constraints(constraints_cx: ConstraintContext) {\n         solutions: solutions,\n     };\n     solutions_cx.solve();\n-    solutions_cx.write();\n+    let variances = solutions_cx.create_map();\n+    let empty_variance = Rc::new(Vec::new());\n+\n+    ty::CrateVariancesMap { dependencies, variances, empty_variance }\n }\n \n impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n@@ -83,7 +88,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn write(&self) {\n+    fn create_map(&self) -> FxHashMap<DefId, Rc<Vec<ty::Variance>>> {\n         // Collect all the variances for a particular item and stick\n         // them into the variance map. We rely on the fact that we\n         // generate all the inferreds for a particular item\n@@ -95,11 +100,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n         let tcx = self.terms_cx.tcx;\n \n-        // Ignore the writes here because the relevant edges were\n-        // already accounted for in `constraints.rs`. See the section\n-        // on dependency graph management in README.md for more\n-        // information.\n-        let _ignore = tcx.dep_graph.in_ignore();\n+        let mut map = FxHashMap();\n \n         let solutions = &self.solutions;\n         let inferred_infos = &self.terms_cx.inferred_infos;\n@@ -127,19 +128,10 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n             let item_def_id = tcx.hir.local_def_id(item_id);\n \n-            // For unit testing: check for a special \"rustc_variance\"\n-            // attribute and report an error with various results if found.\n-            if tcx.has_attr(item_def_id, \"rustc_variance\") {\n-                span_err!(tcx.sess,\n-                          tcx.hir.span(item_id),\n-                          E0208,\n-                          \"{:?}\",\n-                          item_variances);\n-            }\n-\n-            tcx.maps.variances_of.borrow_mut()\n-               .insert(item_def_id, Rc::new(item_variances));\n+            map.insert(item_def_id, Rc::new(item_variances));\n         }\n+\n+        map\n     }\n \n     fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {"}, {"sha": "ad787c57e76f2a60ee49739eef874e17c4ae5665", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -32,8 +32,6 @@ use self::VarianceTerm::*;\n \n pub type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n-use dep_graph::DepNode::ItemSignature as VarianceDepNode;\n-\n #[derive(Copy, Clone, Debug)]\n pub struct InferredIndex(pub usize);\n \n@@ -109,7 +107,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     };\n \n     // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_item_likes_in_krate(|def_id| VarianceDepNode(def_id), &mut terms_cx);\n+    tcx.hir.krate().visit_all_item_likes(&mut terms_cx);\n \n     terms_cx\n }\n@@ -139,7 +137,6 @@ fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn add_inferreds_for_item(&mut self,\n                               item_id: ast::NodeId,\n-                              has_self: bool,\n                               generics: &hir::Generics) {\n         //! Add \"inferreds\" for the generic parameters declared on this\n         //! item. This has a lot of annoying parameters because we are\n@@ -149,38 +146,17 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         //!\n \n         // NB: In the code below for writing the results back into the\n-        // tcx, we rely on the fact that all inferreds for a particular\n-        // item are assigned continuous indices.\n-\n-        let inferreds_on_entry = self.num_inferred();\n-\n-        if has_self {\n-            self.add_inferred(item_id, 0, item_id);\n-        }\n+        // `CrateVariancesMap`, we rely on the fact that all inferreds\n+        // for a particular item are assigned continuous indices.\n \n-        for (i, p) in generics.lifetimes.iter().enumerate() {\n+        for (p, i) in generics.lifetimes.iter().zip(0..) {\n             let id = p.lifetime.id;\n-            let i = has_self as usize + i;\n             self.add_inferred(item_id, i, id);\n         }\n \n-        for (i, p) in generics.ty_params.iter().enumerate() {\n-            let i = has_self as usize + generics.lifetimes.len() + i;\n+        for (p, i) in generics.ty_params.iter().zip(generics.lifetimes.len()..) {\n             self.add_inferred(item_id, i, p.id);\n         }\n-\n-        // If this item has no type or lifetime parameters,\n-        // then there are no variances to infer, so just\n-        // insert an empty entry into the variance map.\n-        // Arguably we could just leave the map empty in this\n-        // case but it seems cleaner to be able to distinguish\n-        // \"invalid item id\" from \"item id with no\n-        // parameters\".\n-        if self.num_inferred() == inferreds_on_entry {\n-            let item_def_id = self.tcx.hir.local_def_id(item_id);\n-            self.tcx.maps.variances_of.borrow_mut()\n-                .insert(item_def_id, self.empty_variances.clone());\n-        }\n     }\n \n     fn add_inferred(&mut self, item_id: ast::NodeId, index: usize, param_id: ast::NodeId) {\n@@ -232,15 +208,10 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n             hir::ItemEnum(_, ref generics) |\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n-                self.add_inferreds_for_item(item.id, false, generics);\n-            }\n-            hir::ItemTrait(_, ref generics, ..) => {\n-                // Note: all inputs for traits are ultimately\n-                // constrained to be invariant. See `visit_item` in\n-                // the impl for `ConstraintContext` in `constraints.rs`.\n-                self.add_inferreds_for_item(item.id, true, generics);\n+                self.add_inferreds_for_item(item.id, generics);\n             }\n \n+            hir::ItemTrait(..) |\n             hir::ItemExternCrate(_) |\n             hir::ItemUse(..) |\n             hir::ItemDefaultImpl(..) |"}, {"sha": "1acadb7e772365efc7b1cfd7c380dcc202b6e48e", "filename": "src/librustc_typeck/variance/test.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::ty::TyCtxt;\n+\n+pub fn test_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.hir.krate().visit_all_item_likes(&mut VarianceTest { tcx });\n+}\n+\n+struct VarianceTest<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let item_def_id = self.tcx.hir.local_def_id(item.id);\n+\n+        // For unit testing: check for a special \"rustc_variance\"\n+        // attribute and report an error with various results if found.\n+        if self.tcx.has_attr(item_def_id, \"rustc_variance\") {\n+            let variances_of = self.tcx.variances_of(item_def_id);\n+            span_err!(self.tcx.sess,\n+                      item.span,\n+                      E0208,\n+                      \"{:?}\",\n+                      variances_of);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) { }\n+    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n+}"}, {"sha": "0e8a6606ae79f387aca5d2d7941e2225a98e75af", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -21,6 +21,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n+rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_trans = { path = \"../librustc_trans\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "2dde6d9d4ee556286fd07b7d4e9a164024a57d6f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -36,6 +36,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind};\n use rustc::middle::stability;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_typeck::hir_ty_to_ty;\n \n use rustc::hir;\n \n@@ -1779,10 +1780,9 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 let mut def = Def::Err;\n-                if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&self.id) {\n-                    if let ty::TyProjection(proj) = ty.sty {\n-                        def = Def::Trait(proj.trait_ref.def_id);\n-                    }\n+                let ty = hir_ty_to_ty(cx.tcx, self);\n+                if let ty::TyProjection(proj) = ty.sty {\n+                    def = Def::Trait(proj.trait_ref.def_id);\n                 }\n                 let trait_path = hir::Path {\n                     span: self.span,"}, {"sha": "9e2d85163335c6f066a493070c8b53aa968e2ef0", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -104,7 +104,8 @@ pub fn run_core(search_paths: SearchPaths,\n                 externs: config::Externs,\n                 input: Input,\n                 triple: Option<String>,\n-                maybe_sysroot: Option<PathBuf>) -> (clean::Crate, RenderInfo)\n+                maybe_sysroot: Option<PathBuf>,\n+                allow_warnings: bool) -> (clean::Crate, RenderInfo)\n {\n     // Parse, resolve, and typecheck the given crate.\n \n@@ -119,7 +120,7 @@ pub fn run_core(search_paths: SearchPaths,\n         maybe_sysroot: maybe_sysroot,\n         search_paths: search_paths,\n         crate_types: vec![config::CrateTypeRlib],\n-        lint_opts: vec![(warning_lint, lint::Allow)],\n+        lint_opts: if !allow_warnings { vec![(warning_lint, lint::Allow)] } else { vec![] },\n         lint_cap: Some(lint::Allow),\n         externs: externs,\n         target_triple: triple.unwrap_or(config::host_triple().to_string()),"}, {"sha": "5db82e23bbf1eb0244d6500e8c0533f21e6f0105", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -687,9 +687,9 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n             }\n         }\n         clean::Vector(ref t) if is_not_debug => {\n-            primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n+            primitive_link(f, PrimitiveType::Slice, \"[\")?;\n             fmt::Display::fmt(t, f)?;\n-            primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n+            primitive_link(f, PrimitiveType::Slice, \"]\")\n         }\n         clean::Vector(ref t) => write!(f, \"[{:?}]\", t),\n         clean::FixedVector(ref t, ref s) if is_not_debug => {"}, {"sha": "d08a7bde71c73ae874480f87ccd8bb57145d5e33", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -137,7 +137,6 @@ r##\"<!DOCTYPE html>\n         window.rootPath = \"{root_path}\";\n         window.currentCrate = \"{krate}\";\n     </script>\n-    <script src=\"{root_path}jquery.js\"></script>\n     <script src=\"{root_path}main.js\"></script>\n     <script defer src=\"{root_path}search-index.js\"></script>\n </body>"}, {"sha": "ec4a23b0417bcf70b3315a81dbe9f86dc0b8fc43", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 48, "deletions": 27, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -66,18 +66,47 @@ pub struct MarkdownHtml<'a>(pub &'a str, pub RenderType);\n /// A unit struct like `Markdown`, that renders only the first paragraph.\n pub struct MarkdownSummaryLine<'a>(pub &'a str);\n \n-/// Returns Some(code) if `s` is a line that should be stripped from\n-/// documentation but used in example code. `code` is the portion of\n-/// `s` that should be used in tests. (None for lines that should be\n-/// left as-is.)\n-fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n+/// Controls whether a line will be hidden or shown in HTML output.\n+///\n+/// All lines are used in documentation tests.\n+enum Line<'a> {\n+    Hidden(&'a str),\n+    Shown(&'a str),\n+}\n+\n+impl<'a> Line<'a> {\n+    fn for_html(self) -> Option<&'a str> {\n+        match self {\n+            Line::Shown(l) => Some(l),\n+            Line::Hidden(_) => None,\n+        }\n+    }\n+\n+    fn for_code(self) -> &'a str {\n+        match self {\n+            Line::Shown(l) |\n+            Line::Hidden(l) => l,\n+        }\n+    }\n+}\n+\n+// FIXME: There is a minor inconsistency here. For lines that start with ##, we\n+// have no easy way of removing a potential single space after the hashes, which\n+// is done in the single # case. This inconsistency seems okay, if non-ideal. In\n+// order to fix it we'd have to iterate to find the first non-# character, and\n+// then reallocate to remove it; which would make us return a String.\n+fn map_line(s: &str) -> Line {\n     let trimmed = s.trim();\n-    if trimmed == \"#\" {\n-        Some(\"\")\n+    if trimmed.starts_with(\"##\") {\n+        Line::Shown(&trimmed[1..])\n     } else if trimmed.starts_with(\"# \") {\n-        Some(&trimmed[2..])\n+        // # text\n+        Line::Hidden(&trimmed[2..])\n+    } else if trimmed == \"#\" {\n+        // We cannot handle '#text' because it could be #[attr].\n+        Line::Hidden(\"\")\n     } else {\n-        None\n+        Line::Shown(s)\n     }\n }\n \n@@ -148,9 +177,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                 _ => {}\n             }\n         }\n-        let lines = origtext.lines().filter(|l| {\n-            stripped_filtered_line(*l).is_none()\n-        });\n+        let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n         let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n         PLAYGROUND.with(|play| {\n             // insert newline to clearly separate it from the\n@@ -160,9 +187,9 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                 if url.is_empty() {\n                     return None;\n                 }\n-                let test = origtext.lines().map(|l| {\n-                    stripped_filtered_line(l).unwrap_or(l)\n-                }).collect::<Vec<&str>>().join(\"\\n\");\n+                let test = origtext.lines()\n+                    .map(|l| map_line(l).for_code())\n+                    .collect::<Vec<&str>>().join(\"\\n\");\n                 let krate = krate.as_ref().map(|s| &**s);\n                 let test = test::maketest(&test, krate, false,\n                                         &Default::default());\n@@ -543,9 +570,7 @@ pub fn render(w: &mut fmt::Formatter,\n                 }\n             };\n \n-            let lines = origtext.lines().filter(|l| {\n-                stripped_filtered_line(*l).is_none()\n-            });\n+            let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n             let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n             if rendered { return }\n             PLAYGROUND.with(|play| {\n@@ -556,9 +581,9 @@ pub fn render(w: &mut fmt::Formatter,\n                     if url.is_empty() {\n                         return None;\n                     }\n-                    let test = origtext.lines().map(|l| {\n-                        stripped_filtered_line(l).unwrap_or(l)\n-                    }).collect::<Vec<&str>>().join(\"\\n\");\n+                    let test = origtext.lines()\n+                        .map(|l| map_line(l).for_code())\n+                        .collect::<Vec<&str>>().join(\"\\n\");\n                     let krate = krate.as_ref().map(|s| &**s);\n                     let test = test::maketest(&test, krate, false,\n                                               &Default::default());\n@@ -734,9 +759,7 @@ pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position\n             let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n             let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n             let text = str::from_utf8(text).unwrap();\n-            let lines = text.lines().map(|l| {\n-                stripped_filtered_line(l).unwrap_or(l)\n-            });\n+            let lines = text.lines().map(|l| map_line(l).for_code());\n             let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n             let filename = tests.get_filename();\n \n@@ -827,9 +850,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Sp\n                     }\n                 }\n                 let offset = offset.unwrap_or(0);\n-                let lines = test_s.lines().map(|l| {\n-                    stripped_filtered_line(l).unwrap_or(l)\n-                });\n+                let lines = test_s.lines().map(|l| map_line(l).for_code());\n                 let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n                 nb_lines += doc[prev_offset..offset].lines().count();\n                 let line = tests.get_line() + (nb_lines - 1);"}, {"sha": "fa9315054a11f7359f944fb6051639374463fffa", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -660,8 +660,6 @@ fn write_shared(cx: &Context,\n     // Add all the static files. These may already exist, but we just\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n \n-    write(cx.dst.join(\"jquery.js\"),\n-          include_bytes!(\"static/jquery-2.1.4.min.js\"))?;\n     write(cx.dst.join(\"main.js\"),\n           include_bytes!(\"static/main.js\"))?;\n     write(cx.dst.join(\"rustdoc.css\"),"}, {"sha": "c69861aa70a237dd77f6ff611a215080b596e2f5", "filename": "src/librustdoc/html/static/COPYRIGHT.txt", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Fstatic%2FCOPYRIGHT.txt", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Fstatic%2FCOPYRIGHT.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FCOPYRIGHT.txt?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -27,11 +27,6 @@ included, and carry their own copyright notices and license terms:\n     Licensed under the SIL Open Font License, Version 1.1.\n     See Heuristica-LICENSE.txt.\n \n-* jQuery (jquery-2.1.4.min.js):\n-\n-    Copyright 2005, 2015 jQuery Foundation, Inc.\n-    Licensed under the MIT license (see LICENSE-MIT.txt).\n-\n * rustdoc.css, main.js, and playpen.js:\n \n     Copyright 2015 The Rust Developers."}, {"sha": "49990d6e14503798f142dcb0d5b23cb0c8f80244", "filename": "src/librustdoc/html/static/jquery-2.1.4.min.js", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfb740f83ca1d6f2056f5cf8de1adbe81b973438/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjquery-2.1.4.min.js", "raw_url": "https://github.com/rust-lang/rust/raw/dfb740f83ca1d6f2056f5cf8de1adbe81b973438/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjquery-2.1.4.min.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjquery-2.1.4.min.js?ref=dfb740f83ca1d6f2056f5cf8de1adbe81b973438", "patch": "@@ -1,4 +0,0 @@\n-/*! jQuery v2.1.4 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */\n-!function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m=\"2.1.4\",n=function(a,b){return new n.fn.init(a,b)},o=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,p=/^-ms-/,q=/-([\\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:\"\",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:\"jQuery\"+(m+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return\"object\"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,\"isPrototypeOf\")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?h[i.call(a)]||\"object\":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf(\"use strict\")?(b=l.createElement(\"script\"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,\"ms-\").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(o,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,\"string\"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return\"string\"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(a,b){h[\"[object \"+b+\"]\"]=b.toLowerCase()});function s(a){var b=\"length\"in a&&a.length,c=n.type(a);return\"function\"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",L=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",M=\"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",N=M.replace(\"w\",\"w#\"),O=\"\\\\[\"+L+\"*(\"+M+\")(?:\"+L+\"*([*^$|!~]?=)\"+L+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+N+\"))|)\"+L+\"*\\\\]\",P=\":(\"+M+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+O+\")*)|.*)\\\\)|)\",Q=new RegExp(L+\"+\",\"g\"),R=new RegExp(\"^\"+L+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+L+\"+$\",\"g\"),S=new RegExp(\"^\"+L+\"*,\"+L+\"*\"),T=new RegExp(\"^\"+L+\"*([>+~]|\"+L+\")\"+L+\"*\"),U=new RegExp(\"=\"+L+\"*([^\\\\]'\\\"]*?)\"+L+\"*\\\\]\",\"g\"),V=new RegExp(P),W=new RegExp(\"^\"+N+\"$\"),X={ID:new RegExp(\"^#(\"+M+\")\"),CLASS:new RegExp(\"^\\\\.(\"+M+\")\"),TAG:new RegExp(\"^(\"+M.replace(\"w\",\"w*\")+\")\"),ATTR:new RegExp(\"^\"+O),PSEUDO:new RegExp(\"^\"+P),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+L+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+L+\"*(?:([+-]|)\"+L+\"*(\\\\d+)|))\"+L+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+K+\")$\",\"i\"),needsContext:new RegExp(\"^\"+L+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+L+\"*((?:-\\\\d)?\\\\d*)\"+L+\"*\\\\)|)(?=[^-]|$)\",\"i\")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\\d$/i,$=/^[^{]+\\{\\s*\\[native \\w/,_=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,aa=/[+~]/,ba=/'|\\\\/g,ca=new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\"+L+\"?|(\"+L+\")|.)\",\"ig\"),da=function(a,b,c){var d=\"0x\"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,\"string\"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&\"object\"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute(\"id\"))?s=r.replace(ba,\"\\\\$&\"):b.setAttribute(\"id\",s),s=\"[id='\"+s+\"'] \",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(\",\")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute(\"id\")}}}return i(a.replace(R,\"$1\"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+\" \")>d.cacheLength&&delete b[a.shift()],b[c+\" \"]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement(\"div\");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split(\"|\"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return\"input\"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return(\"input\"===c||\"button\"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&\"undefined\"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?\"HTML\"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener(\"unload\",ea,!1):e.attachEvent&&e.attachEvent(\"onunload\",ea)),p=!f(g),c.attributes=ja(function(a){return a.className=\"i\",!a.getAttribute(\"className\")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment(\"\")),!a.getElementsByTagName(\"*\").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if(\"undefined\"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute(\"id\")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c=\"undefined\"!=typeof a.getAttributeNode&&a.getAttributeNode(\"id\");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return\"undefined\"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if(\"*\"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML=\"<a id='\"+u+\"'></a><select id='\"+u+\"-\\f]' msallowcapture=''><option selected=''></option></select>\",a.querySelectorAll(\"[msallowcapture^='']\").length&&q.push(\"[*^$]=\"+L+\"*(?:''|\\\"\\\")\"),a.querySelectorAll(\"[selected]\").length||q.push(\"\\\\[\"+L+\"*(?:value|\"+K+\")\"),a.querySelectorAll(\"[id~=\"+u+\"-]\").length||q.push(\"~=\"),a.querySelectorAll(\":checked\").length||q.push(\":checked\"),a.querySelectorAll(\"a#\"+u+\"+*\").length||q.push(\".#.+[+~]\")}),ja(function(a){var b=g.createElement(\"input\");b.setAttribute(\"type\",\"hidden\"),a.appendChild(b).setAttribute(\"name\",\"D\"),a.querySelectorAll(\"[name=d]\").length&&q.push(\"name\"+L+\"*[*^$|!~]?=\"),a.querySelectorAll(\":enabled\").length||q.push(\":enabled\",\":disabled\"),a.querySelectorAll(\"*,:x\"),q.push(\",.*:\")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,\"div\"),s.call(a,\"[s!='']:x\"),r.push(\"!=\",P)}),q=q.length&&new RegExp(q.join(\"|\")),r=r.length&&new RegExp(r.join(\"|\")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,\"='$1']\"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error(\"Syntax error, unrecognized expression: \"+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c=\"\",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if(\"string\"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||\"\").replace(ca,da),\"~=\"===a[2]&&(a[3]=\" \"+a[3]+\" \"),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),\"nth\"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*(\"even\"===a[3]||\"odd\"===a[3])),a[5]=+(a[7]+a[8]||\"odd\"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||\"\":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(\")\",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return\"*\"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+\" \"];return b||(b=new RegExp(\"(^|\"+L+\")\"+a+\"(\"+L+\"|$)\"))&&y(a,function(a){return b.test(\"string\"==typeof a.className&&a.className||\"undefined\"!=typeof a.getAttribute&&a.getAttribute(\"class\")||\"\")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?\"!=\"===b:b?(e+=\"\",\"=\"===b?e===c:\"!=\"===b?e!==c:\"^=\"===b?c&&0===e.indexOf(c):\"*=\"===b?c&&e.indexOf(c)>-1:\"$=\"===b?c&&e.slice(-c.length)===c:\"~=\"===b?(\" \"+e.replace(Q,\" \")+\" \").indexOf(c)>-1:\"|=\"===b?e===c||e.slice(0,c.length+1)===c+\"-\":!1):!0}},CHILD:function(a,b,c,d,e){var f=\"nth\"!==a.slice(0,3),g=\"last\"!==a.slice(-4),h=\"of-type\"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?\"nextSibling\":\"previousSibling\",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p=\"only\"===a&&!o&&\"nextSibling\"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error(\"unsupported pseudo: \"+a);return e[u]?e(b):e.length>1?(c=[a,a,\"\",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,\"$1\"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||\"\")||ga.error(\"unsupported lang: \"+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute(\"xml:lang\")||b.getAttribute(\"lang\"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+\"-\");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return\"input\"===b&&!!a.checked||\"option\"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return\"input\"===b&&\"button\"===a.type||\"button\"===b},text:function(a){var b;return\"input\"===a.nodeName.toLowerCase()&&\"text\"===a.type&&(null==(b=a.getAttribute(\"type\"))||\"text\"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+\" \"];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R,\" \")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d=\"\";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&\"parentNode\"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||\"*\",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[\" \"],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:\" \"===a[i-2].type?\"*\":\"\"})).replace(R,\"$1\"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q=\"0\",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG(\"*\",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+\" \"];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n=\"function\"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&\"ID\"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split(\"\").sort(B).join(\"\")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement(\"div\"))}),ja(function(a){return a.innerHTML=\"<a href='#'></a>\",\"#\"===a.firstChild.getAttribute(\"href\")})||ka(\"type|href|height|width\",function(a,b,c){return c?void 0:a.getAttribute(b,\"type\"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML=\"<input/>\",a.firstChild.setAttribute(\"value\",\"\"),\"\"===a.firstChild.getAttribute(\"value\")})||ka(\"value\",function(a,b,c){return c||\"input\"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute(\"disabled\")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);n.find=t,n.expr=t.selectors,n.expr[\":\"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,w=/^.[^:#\\[\\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if(\"string\"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=\":not(\"+a+\")\"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if(\"string\"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+\" \"+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,\"string\"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if(\"string\"==typeof a){if(c=\"<\"===a[0]&&\">\"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?\"undefined\"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||\"string\"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?\"string\"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,\"parentNode\")},parentsUntil:function(a,b,c){return n.dir(a,\"parentNode\",c)},next:function(a){return D(a,\"nextSibling\")},prev:function(a){return D(a,\"previousSibling\")},nextAll:function(a){return n.dir(a,\"nextSibling\")},prevAll:function(a){return n.dir(a,\"previousSibling\")},nextUntil:function(a,b,c){return n.dir(a,\"nextSibling\",c)},prevUntil:function(a,b,c){return n.dir(a,\"previousSibling\",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return\"Until\"!==a.slice(-5)&&(d=c),d&&\"string\"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a=\"string\"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);\"function\"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&\"string\"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[[\"resolve\",\"done\",n.Callbacks(\"once memory\"),\"resolved\"],[\"reject\",\"fail\",n.Callbacks(\"once memory\"),\"rejected\"],[\"notify\",\"progress\",n.Callbacks(\"memory\")]],c=\"pending\",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+\"With\"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+\"With\"](this===e?d:this,arguments),this},e[f[0]+\"With\"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler(\"ready\"),n(l).off(\"ready\"))))}});function I(){l.removeEventListener(\"DOMContentLoaded\",I,!1),a.removeEventListener(\"load\",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),\"complete\"===l.readyState?setTimeout(n.ready):(l.addEventListener(\"DOMContentLoaded\",I,!1),a.addEventListener(\"load\",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if(\"object\"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+K.uid++}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if(\"string\"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&\"string\"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d=\"data-\"+b.replace(O,\"-$1\").toLowerCase(),c=a.getAttribute(d),\"string\"==typeof c){try{c=\"true\"===c?!0:\"false\"===c?!1:\"null\"===c?null:+c+\"\"===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){\n-return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,\"hasDataAttrs\"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf(\"data-\")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,\"hasDataAttrs\",!0)}return e}return\"object\"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf(\"-\")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||\"fx\")+\"queue\",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||\"fx\";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};\"inprogress\"===e&&(e=c.shift(),d--),e&&(\"fx\"===b&&c.unshift(\"inprogress\"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+\"queueHooks\";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks(\"once memory\").add(function(){L.remove(a,[b+\"queue\",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return\"string\"!=typeof a&&(b=a,a=\"fx\",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),\"fx\"===a&&\"inprogress\"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||\"fx\",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};\"string\"!=typeof a&&(b=a,a=void 0),a=a||\"fx\";while(g--)c=L.get(f[g],a+\"queueHooks\"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,R=[\"Top\",\"Right\",\"Bottom\",\"Left\"],S=function(a,b){return a=b||a,\"none\"===n.css(a,\"display\")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement(\"div\")),c=l.createElement(\"input\");c.setAttribute(\"type\",\"radio\"),c.setAttribute(\"checked\",\"checked\"),c.setAttribute(\"name\",\"t\"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML=\"<textarea>x</textarea>\",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U=\"undefined\";k.focusinBubbles=\"onfocusin\"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||\"\").match(E)||[\"\"],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||\"\").split(\".\").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(\".\")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||\"\").match(E)||[\"\"],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||\"\").split(\".\").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp(\"(^|\\\\.)\"+p.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&(\"**\"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,\"events\"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,\"type\")?b.type:b,r=j.call(b,\"namespace\")?b.namespace.split(\".\"):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(\".\")>=0&&(r=q.split(\".\"),q=r.shift(),r.sort()),k=q.indexOf(\":\")<0&&\"on\"+q,b=b[n.expando]?b:new n.Event(q,\"object\"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join(\".\"),b.namespace_re=b.namespace?new RegExp(\"(^|\\\\.)\"+r.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,\"events\")||{})[b.type]&&L.get(g,\"handle\"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,\"events\")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||\"click\"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||\"click\"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+\" \",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:\"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),fixHooks:{},keyHooks:{props:\"char charCode key keyCode\".split(\" \"),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:\"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:\"focusin\"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:\"focusout\"},click:{trigger:function(){return\"checkbox\"===this.type&&this.click&&n.nodeName(this,\"input\")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,\"a\")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:\"focusin\",blur:\"focusout\"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if(\"object\"==typeof a){\"string\"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&(\"string\"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+\".\"+d.namespace:d.origType,d.selector,d.handler),this;if(\"object\"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||\"function\"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,ba=/<([\\w:]+)/,ca=/<|&#?\\w+;/,da=/<(?:script|style|link)/i,ea=/checked\\s*(?:[^=]|=\\s*.checked.)/i,fa=/^$|\\/(?:java|ecma)script/i,ga=/^true\\/(.*)/,ha=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,ia={option:[1,\"<select multiple='multiple'>\",\"</select>\"],thead:[1,\"<table>\",\"</table>\"],col:[2,\"<table><colgroup>\",\"</colgroup></table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:[0,\"\",\"\"]};ia.optgroup=ia.option,ia.tbody=ia.tfoot=ia.colgroup=ia.caption=ia.thead,ia.th=ia.td;function ja(a,b){return n.nodeName(a,\"table\")&&n.nodeName(11!==b.nodeType?b:b.firstChild,\"tr\")?a.getElementsByTagName(\"tbody\")[0]||a.appendChild(a.ownerDocument.createElement(\"tbody\")):a}function ka(a){return a.type=(null!==a.getAttribute(\"type\"))+\"/\"+a.type,a}function la(a){var b=ga.exec(a.type);return b?a.type=b[1]:a.removeAttribute(\"type\"),a}function ma(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],\"globalEval\",!b||L.get(b[c],\"globalEval\"))}function na(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function oa(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||\"*\"):a.querySelectorAll?a.querySelectorAll(b||\"*\"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pa(a,b){var c=b.nodeName.toLowerCase();\"input\"===c&&T.test(a.type)?b.checked=a.checked:(\"input\"===c||\"textarea\"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=oa(h),f=oa(a),d=0,e=f.length;e>d;d++)pa(f[d],g[d]);if(b)if(c)for(f=f||oa(a),g=g||oa(h),d=0,e=f.length;e>d;d++)na(f[d],g[d]);else na(a,h);return g=oa(h,\"script\"),g.length>0&&ma(g,!i&&oa(a,\"script\")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if(\"object\"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(ca.test(e)){f=f||k.appendChild(b.createElement(\"div\")),g=(ba.exec(e)||[\"\",\"\"])[1].toLowerCase(),h=ia[g]||ia._default,f.innerHTML=h[1]+e.replace(aa,\"<$1></$2>\")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=\"\"}else l.push(b.createTextNode(e));k.textContent=\"\",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=oa(k.appendChild(e),\"script\"),i&&ma(f),c)){j=0;while(e=f[j++])fa.test(e.type||\"\")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(oa(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&ma(oa(c,\"script\")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(oa(a,!1)),a.textContent=\"\");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if(\"string\"==typeof a&&!da.test(a)&&!ia[(ba.exec(a)||[\"\",\"\"])[1].toLowerCase()]){a=a.replace(aa,\"<$1></$2>\");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(oa(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(oa(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&\"string\"==typeof p&&!k.checkClone&&ea.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(oa(c,\"script\"),ka),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,oa(h,\"script\"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,la),j=0;g>j;j++)h=f[j],fa.test(h.type||\"\")&&!L.access(h,\"globalEval\")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(ha,\"\")))}return this}}),n.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qa,ra={};function sa(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],\"display\");return e.detach(),f}function ta(a){var b=l,c=ra[a];return c||(c=sa(a,b),\"none\"!==c&&c||(qa=(qa||n(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement),b=qa[0].contentDocument,b.write(),b.close(),c=sa(a,b),qa.detach()),ra[a]=c),c}var ua=/^margin/,va=new RegExp(\"^(\"+Q+\")(?!px)[a-z%]+$\",\"i\"),wa=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)};function xa(a,b,c){var d,e,f,g,h=a.style;return c=c||wa(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(\"\"!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),va.test(g)&&ua.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+\"\":g}function ya(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement(\"div\"),f=l.createElement(\"div\");if(f.style){f.style.backgroundClip=\"content-box\",f.cloneNode(!0).style.backgroundClip=\"\",k.clearCloneStyle=\"content-box\"===f.style.backgroundClip,e.style.cssText=\"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute\",e.appendChild(f);function g(){f.style.cssText=\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute\",f.innerHTML=\"\",d.appendChild(e);var g=a.getComputedStyle(f,null);b=\"1%\"!==g.top,c=\"4px\"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement(\"div\"));return c.style.cssText=f.style.cssText=\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0\",c.style.marginRight=c.style.width=\"0\",f.style.width=\"1px\",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),f.removeChild(c),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var za=/^(none|table(?!-c[ea]).+)/,Aa=new RegExp(\"^(\"+Q+\")(.*)$\",\"i\"),Ba=new RegExp(\"^([+-])=(\"+Q+\")\",\"i\"),Ca={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Da={letterSpacing:\"0\",fontWeight:\"400\"},Ea=[\"Webkit\",\"O\",\"Moz\",\"ms\"];function Fa(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Ea.length;while(e--)if(b=Ea[e]+c,b in a)return b;return d}function Ga(a,b,c){var d=Aa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||\"px\"):b}function Ha(a,b,c,d,e){for(var f=c===(d?\"border\":\"content\")?4:\"width\"===b?1:0,g=0;4>f;f+=2)\"margin\"===c&&(g+=n.css(a,c+R[f],!0,e)),d?(\"content\"===c&&(g-=n.css(a,\"padding\"+R[f],!0,e)),\"margin\"!==c&&(g-=n.css(a,\"border\"+R[f]+\"Width\",!0,e))):(g+=n.css(a,\"padding\"+R[f],!0,e),\"padding\"!==c&&(g+=n.css(a,\"border\"+R[f]+\"Width\",!0,e)));return g}function Ia(a,b,c){var d=!0,e=\"width\"===b?a.offsetWidth:a.offsetHeight,f=wa(a),g=\"border-box\"===n.css(a,\"boxSizing\",!1,f);if(0>=e||null==e){if(e=xa(a,b,f),(0>e||null==e)&&(e=a.style[b]),va.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Ha(a,b,c||(g?\"border\":\"content\"),d,f)+\"px\"}function Ja(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,\"olddisplay\"),c=d.style.display,b?(f[g]||\"none\"!==c||(d.style.display=\"\"),\"\"===d.style.display&&S(d)&&(f[g]=L.access(d,\"olddisplay\",ta(d.nodeName)))):(e=S(d),\"none\"===c&&e||L.set(d,\"olddisplay\",e?c:n.css(d,\"display\"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&\"none\"!==d.style.display&&\"\"!==d.style.display||(d.style.display=b?f[g]||\"\":\"none\"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xa(a,\"opacity\");return\"\"===c?\"1\":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\"float\":\"cssFloat\"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fa(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&\"get\"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,\"string\"===f&&(e=Ba.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f=\"number\"),null!=c&&c===c&&(\"number\"!==f||n.cssNumber[h]||(c+=\"px\"),k.clearCloneStyle||\"\"!==c||0!==b.indexOf(\"background\")||(i[b]=\"inherit\"),g&&\"set\"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fa(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&\"get\"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xa(a,b,d)),\"normal\"===e&&b in Da&&(e=Da[b]),\"\"===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each([\"height\",\"width\"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?za.test(n.css(a,\"display\"))&&0===a.offsetWidth?n.swap(a,Ca,function(){return Ia(a,b,d)}):Ia(a,b,d):void 0},set:function(a,c,d){var e=d&&wa(a);return Ga(a,c,d?Ha(a,b,d,\"border-box\"===n.css(a,\"boxSizing\",!1,e),e):0)}}}),n.cssHooks.marginRight=ya(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:\"inline-block\"},xa,[a,\"marginRight\"]):void 0}),n.each({margin:\"\",padding:\"\",border:\"Width\"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f=\"string\"==typeof c?c.split(\" \"):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ua.test(a)||(n.cssHooks[a+b].set=Ga)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wa(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Ja(this,!0)},hide:function(){return Ja(this)},toggle:function(a){return\"boolean\"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Ka(a,b,c,d,e){return new Ka.prototype.init(a,b,c,d,e)}n.Tween=Ka,Ka.prototype={constructor:Ka,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||\"swing\",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?\"\":\"px\")},cur:function(){var a=Ka.propHooks[this.prop];return a&&a.get?a.get(this):Ka.propHooks._default.get(this)},run:function(a){var b,c=Ka.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ka.propHooks._default.set(this),this}},Ka.prototype.init.prototype=Ka.prototype,Ka.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,\"\"),b&&\"auto\"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Ka.propHooks.scrollTop=Ka.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Ka.prototype.init,n.fx.step={};var La,Ma,Na=/^(?:toggle|show|hide)$/,Oa=new RegExp(\"^(?:([+-])=|)(\"+Q+\")([a-z%]*)$\",\"i\"),Pa=/queueHooks$/,Qa=[Va],Ra={\"*\":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Oa.exec(b),f=e&&e[3]||(n.cssNumber[a]?\"\":\"px\"),g=(n.cssNumber[a]||\"px\"!==f&&+d)&&Oa.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||\".5\",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sa(){return setTimeout(function(){La=void 0}),La=n.now()}function Ta(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e[\"margin\"+c]=e[\"padding\"+c]=a;return b&&(e.opacity=e.width=a),e}function Ua(a,b,c){for(var d,e=(Ra[b]||[]).concat(Ra[\"*\"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Va(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,\"fxshow\");c.queue||(h=n._queueHooks(a,\"fx\"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,\"fx\").length||h.empty.fire()})})),1===a.nodeType&&(\"height\"in b||\"width\"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,\"display\"),k=\"none\"===j?L.get(a,\"olddisplay\")||ta(a.nodeName):j,\"inline\"===k&&\"none\"===n.css(a,\"float\")&&(o.display=\"inline-block\")),c.overflow&&(o.overflow=\"hidden\",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Na.exec(e)){if(delete b[d],f=f||\"toggle\"===e,e===(p?\"hide\":\"show\")){if(\"show\"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))\"inline\"===(\"none\"===j?ta(a.nodeName):j)&&(o.display=j);else{q?\"hidden\"in q&&(p=q.hidden):q=L.access(a,\"fxshow\",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,\"fxshow\");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ua(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start=\"width\"===d||\"height\"===d?1:0))}}function Wa(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&\"expand\"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xa(a,b,c){var d,e,f=0,g=Qa.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=La||Sa(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:La||Sa(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wa(k,j.opts.specialEasing);g>f;f++)if(d=Qa[f].call(j,a,k,j.opts))return d;return n.map(k,Ua,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xa,{tweener:function(a,b){n.isFunction(a)?(b=a,a=[\"*\"]):a=a.split(\" \");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Ra[c]=Ra[c]||[],Ra[c].unshift(b)},prefilter:function(a,b){b?Qa.unshift(a):Qa.push(a)}}),n.speed=function(a,b,c){var d=a&&\"object\"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:\"number\"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue=\"fx\"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css(\"opacity\",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xa(this,n.extend({},a),f);(e||L.get(this,\"finish\"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return\"string\"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||\"fx\",[]),this.each(function(){var b=!0,e=null!=a&&a+\"queueHooks\",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pa.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||\"fx\"),this.each(function(){var b,c=L.get(this),d=c[a+\"queue\"],e=c[a+\"queueHooks\"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each([\"toggle\",\"show\",\"hide\"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||\"boolean\"==typeof a?c.apply(this,arguments):this.animate(Ta(b,!0),a,d,e)}}),n.each({slideDown:Ta(\"show\"),slideUp:Ta(\"hide\"),slideToggle:Ta(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(La=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),La=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Ma||(Ma=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Ma),Ma=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||\"fx\",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement(\"input\"),b=l.createElement(\"select\"),c=b.appendChild(l.createElement(\"option\"));a.type=\"checkbox\",k.checkOn=\"\"!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement(\"input\"),a.value=\"t\",a.type=\"radio\",k.radioValue=\"t\"===a.value}();var Ya,Za,$a=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Za:Ya)),\n-void 0===c?d&&\"get\"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&\"set\"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+\"\"),c):void n.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&\"radio\"===b&&n.nodeName(a,\"input\")){var c=a.value;return a.setAttribute(\"type\",b),c&&(a.value=c),b}}}}}),Za={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\\w+/g),function(a,b){var c=$a[b]||n.find.attr;$a[b]=function(a,b,d){var e,f;return d||(f=$a[b],$a[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$a[b]=f),e}});var _a=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{\"for\":\"htmlFor\",\"class\":\"className\"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&\"set\"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&\"get\"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute(\"tabindex\")||_a.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){n.propFix[this.toLowerCase()]=this});var ab=/[\\t\\r\\n\\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=\"string\"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||\"\").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(\" \"+c.className+\" \").replace(ab,\" \"):\" \")){f=0;while(e=b[f++])d.indexOf(\" \"+e+\" \")<0&&(d+=e+\" \");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||\"string\"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||\"\").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(\" \"+c.className+\" \").replace(ab,\" \"):\"\")){f=0;while(e=b[f++])while(d.indexOf(\" \"+e+\" \")>=0)d=d.replace(\" \"+e+\" \",\" \");g=a?n.trim(d):\"\",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return\"boolean\"==typeof b&&\"string\"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if(\"string\"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||\"boolean\"===c)&&(this.className&&L.set(this,\"__className__\",this.className),this.className=this.className||a===!1?\"\":L.get(this,\"__className__\")||\"\")})},hasClass:function(a){for(var b=\" \"+a+\" \",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(\" \"+this[c].className+\" \").replace(ab,\" \").indexOf(b)>=0)return!0;return!1}});var bb=/\\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e=\"\":\"number\"==typeof e?e+=\"\":n.isArray(e)&&(e=n.map(e,function(a){return null==a?\"\":a+\"\"})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&\"set\"in b&&void 0!==b.set(this,e,\"value\")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&\"get\"in b&&void 0!==(c=b.get(e,\"value\"))?c:(c=e.value,\"string\"==typeof c?c.replace(bb,\"\"):null==c?\"\":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,\"value\");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f=\"select-one\"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute(\"disabled\"))||c.parentNode.disabled&&n.nodeName(c.parentNode,\"optgroup\"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each([\"radio\",\"checkbox\"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute(\"value\")?\"on\":a.value})}),n.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,\"**\"):this.off(b,a||\"**\",c)}});var cb=n.now(),db=/\\?/;n.parseJSON=function(a){return JSON.parse(a+\"\")},n.parseXML=function(a){var b,c;if(!a||\"string\"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,\"text/xml\")}catch(d){b=void 0}return(!b||b.getElementsByTagName(\"parsererror\").length)&&n.error(\"Invalid XML: \"+a),b};var eb=/#.*$/,fb=/([?&])_=[^&]*/,gb=/^(.*?):[ \\t]*([^\\r\\n]*)$/gm,hb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,ib=/^(?:GET|HEAD)$/,jb=/^\\/\\//,kb=/^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,lb={},mb={},nb=\"*/\".concat(\"*\"),ob=a.location.href,pb=kb.exec(ob.toLowerCase())||[];function qb(a){return function(b,c){\"string\"!=typeof b&&(c=b,b=\"*\");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])\"+\"===d[0]?(d=d.slice(1)||\"*\",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function rb(a,b,c,d){var e={},f=a===mb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return\"string\"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e[\"*\"]&&g(\"*\")}function sb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function tb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while(\"*\"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader(\"Content-Type\"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+\" \"+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function ub(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if(\"*\"===f)f=i;else if(\"*\"!==i&&i!==f){if(g=j[i+\" \"+f]||j[\"* \"+f],!g)for(e in j)if(h=e.split(\" \"),h[1]===f&&(g=j[i+\" \"+h[0]]||j[\"* \"+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a[\"throws\"])b=g(b);else try{b=g(b)}catch(l){return{state:\"parsererror\",error:g?l:\"No conversion from \"+i+\" to \"+f}}}return{state:\"success\",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:ob,type:\"GET\",isLocal:hb.test(pb[1]),global:!0,processData:!0,async:!0,contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":nb,text:\"text/plain\",html:\"text/html\",xml:\"application/xml, text/xml\",json:\"application/json, text/javascript\"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":n.parseJSON,\"text xml\":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?sb(sb(a,n.ajaxSettings),b):sb(n.ajaxSettings,a)},ajaxPrefilter:qb(lb),ajaxTransport:qb(mb),ajax:function(a,b){\"object\"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks(\"once memory\"),q=k.statusCode||{},r={},s={},t=0,u=\"canceled\",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=gb.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||ob)+\"\").replace(eb,\"\").replace(jb,pb[1]+\"//\"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||\"*\").toLowerCase().match(E)||[\"\"],null==k.crossDomain&&(h=kb.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===pb[1]&&h[2]===pb[2]&&(h[3]||(\"http:\"===h[1]?\"80\":\"443\"))===(pb[3]||(\"http:\"===pb[1]?\"80\":\"443\")))),k.data&&k.processData&&\"string\"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),rb(lb,k,b,v),2===t)return v;i=n.event&&k.global,i&&0===n.active++&&n.event.trigger(\"ajaxStart\"),k.type=k.type.toUpperCase(),k.hasContent=!ib.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(db.test(d)?\"&\":\"?\")+k.data,delete k.data),k.cache===!1&&(k.url=fb.test(d)?d.replace(fb,\"$1_=\"+cb++):d+(db.test(d)?\"&\":\"?\")+\"_=\"+cb++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader(\"If-Modified-Since\",n.lastModified[d]),n.etag[d]&&v.setRequestHeader(\"If-None-Match\",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader(\"Content-Type\",k.contentType),v.setRequestHeader(\"Accept\",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+(\"*\"!==k.dataTypes[0]?\", \"+nb+\"; q=0.01\":\"\"):k.accepts[\"*\"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u=\"abort\";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=rb(mb,k,b,v)){v.readyState=1,i&&m.trigger(\"ajaxSend\",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort(\"timeout\")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,\"No Transport\");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||\"\",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=tb(k,v,f)),u=ub(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader(\"Last-Modified\"),w&&(n.lastModified[d]=w),w=v.getResponseHeader(\"etag\"),w&&(n.etag[d]=w)),204===a||\"HEAD\"===k.type?x=\"nocontent\":304===a?x=\"notmodified\":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x=\"error\",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+\"\",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?\"ajaxSuccess\":\"ajaxError\",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger(\"ajaxComplete\",[v,k]),--n.active||n.event.trigger(\"ajaxStop\")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,\"json\")},getScript:function(a,b){return n.get(a,void 0,b,\"script\")}}),n.each([\"get\",\"post\"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n._evalUrl=function(a){return n.ajax({url:a,type:\"GET\",dataType:\"script\",async:!1,global:!1,\"throws\":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,\"body\")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var vb=/%20/g,wb=/\\[\\]$/,xb=/\\r?\\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+\"[\"+(\"object\"==typeof e?b:\"\")+\"]\",e,c,d)});else if(c||\"object\"!==n.type(b))d(a,b);else for(e in b)Ab(a+\"[\"+e+\"]\",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?\"\":b,d[d.length]=encodeURIComponent(a)+\"=\"+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join(\"&\").replace(vb,\"+\")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,\"elements\");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(\":disabled\")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(xb,\"\\r\\n\")}}):{name:b.name,value:c.replace(xb,\"\\r\\n\")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Bb=0,Cb={},Db={0:200,1223:204},Eb=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent(\"onunload\",function(){for(var a in Cb)Cb[a]()}),k.cors=!!Eb&&\"withCredentials\"in Eb,k.ajax=Eb=!!Eb,n.ajaxTransport(function(a){var b;return k.cors||Eb&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Bb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c[\"X-Requested-With\"]||(c[\"X-Requested-With\"]=\"XMLHttpRequest\");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Cb[g],b=f.onload=f.onerror=null,\"abort\"===a?f.abort():\"error\"===a?d(f.status,f.statusText):d(Db[f.status]||f.status,f.statusText,\"string\"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b(\"error\"),b=Cb[g]=b(\"abort\");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/(?:java|ecma)script/},converters:{\"text script\":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter(\"script\",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type=\"GET\")}),n.ajaxTransport(\"script\",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n(\"<script>\").prop({async:!0,charset:a.scriptCharset,src:a.url}).on(\"load error\",c=function(a){b.remove(),c=null,a&&e(\"error\"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Fb=[],Gb=/(=)\\?(?=&|$)|\\?\\?/;n.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var a=Fb.pop()||n.expando+\"_\"+cb++;return this[a]=!0,a}}),n.ajaxPrefilter(\"json jsonp\",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Gb.test(b.url)?\"url\":\"string\"==typeof b.data&&!(b.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&Gb.test(b.data)&&\"data\");return h||\"jsonp\"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Gb,\"$1\"+e):b.jsonp!==!1&&(b.url+=(db.test(b.url)?\"&\":\"?\")+b.jsonp+\"=\"+e),b.converters[\"script json\"]=function(){return g||n.error(e+\" was not called\"),g[0]},b.dataTypes[0]=\"json\",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Fb.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),\"script\"):void 0}),n.parseHTML=function(a,b,c){if(!a||\"string\"!=typeof a)return null;\"boolean\"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Hb=n.fn.load;n.fn.load=function(a,b,c){if(\"string\"!=typeof a&&Hb)return Hb.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(\" \");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&\"object\"==typeof b&&(e=\"POST\"),g.length>0&&n.ajax({url:a,type:e,dataType:\"html\",data:b}).done(function(a){f=arguments,g.html(d?n(\"<div>\").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Ib=a.document.documentElement;function Jb(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,\"position\"),l=n(a),m={};\"static\"===k&&(a.style.position=\"relative\"),h=l.offset(),f=n.css(a,\"top\"),i=n.css(a,\"left\"),j=(\"absolute\"===k||\"fixed\"===k)&&(f+i).indexOf(\"auto\")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),\"using\"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Jb(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return\"fixed\"===n.css(c,\"position\")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],\"html\")||(d=a.offset()),d.top+=n.css(a[0],\"borderTopWidth\",!0),d.left+=n.css(a[0],\"borderLeftWidth\",!0)),{top:b.top-d.top-n.css(c,\"marginTop\",!0),left:b.left-d.left-n.css(c,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Ib;while(a&&!n.nodeName(a,\"html\")&&\"static\"===n.css(a,\"position\"))a=a.offsetParent;return a||Ib})}}),n.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(b,c){var d=\"pageYOffset\"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Jb(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each([\"top\",\"left\"],function(a,b){n.cssHooks[b]=ya(k.pixelPosition,function(a,c){return c?(c=xa(a,b),va.test(c)?n(a).position()[b]+\"px\":c):void 0})}),n.each({Height:\"height\",Width:\"width\"},function(a,b){n.each({padding:\"inner\"+a,content:b,\"\":\"outer\"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||\"boolean\"!=typeof d),g=c||(d===!0||e===!0?\"margin\":\"border\");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement[\"client\"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body[\"scroll\"+a],e[\"scroll\"+a],b.body[\"offset\"+a],e[\"offset\"+a],e[\"client\"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return n});var Kb=a.jQuery,Lb=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Lb),b&&a.jQuery===n&&(a.jQuery=Kb),n},typeof b===U&&(a.jQuery=a.$=n),n});"}, {"sha": "fbc7615588eed2fe4b820a9d5e30ffe43e2c9e8c", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 456, "deletions": 233, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -37,10 +37,63 @@\n                      \"associatedconstant\",\n                      \"union\"];\n \n+    function hasClass(elem, className) {\n+        if (elem && className && elem.className) {\n+            var elemClass = elem.className;\n+            var start = elemClass.indexOf(className);\n+            if (start == -1) {\n+                return false;\n+            } else if (elemClass.length == className.length) {\n+                return true;\n+            } else {\n+                if (start > 0 && elemClass[start - 1] != ' ') {\n+                    return false;\n+                }\n+                var end = start + className.length;\n+                if (end < elemClass.length && elemClass[end] != ' ') {\n+                    return false;\n+                }\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    function addClass(elem, className) {\n+        if (elem && className && !hasClass(elem, className)) {\n+            if (elem.className && elem.className.length > 0) {\n+                elem.className += ' ' + className;\n+            } else {\n+                elem.className = className;\n+            }\n+        }\n+    }\n+\n+    function removeClass(elem, className) {\n+        if (elem && className && elem.className) {\n+            elem.className = (\" \" + elem.className + \" \").replace(\" \" + className + \" \", \" \")\n+                                                         .trim();\n+        }\n+    }\n+\n+    function onEach(arr, func) {\n+        if (arr && arr.length > 0 && func) {\n+            for (var i = 0; i < arr.length; i++) {\n+                func(arr[i]);\n+            }\n+        }\n+    }\n+\n+    function isHidden(elem) {\n+        return (elem.offsetParent === null)\n+    }\n+\n     // used for special search precedence\n     var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n \n-    $('.js-only').removeClass('js-only');\n+    onEach(document.getElementsByClassName('js-only'), function(e) {\n+        removeClass(e, 'js-only');\n+    });\n \n     function getQueryStringParams() {\n         var params = {};\n@@ -65,18 +118,28 @@\n             from = parseInt(match[1], 10);\n             to = Math.min(50000, parseInt(match[2] || match[1], 10));\n             from = Math.min(from, to);\n-            if ($('#' + from).length === 0) {\n+            var elem = document.getElementById(from);\n+            if (!elem) {\n                 return;\n             }\n-            if (ev === null) { $('#' + from)[0].scrollIntoView(); };\n-            $('.line-numbers span').removeClass('line-highlighted');\n+            if (ev === null) {\n+                var x = document.getElementById(from);\n+                if (x) {\n+                    x.scrollIntoView();\n+                }\n+            };\n+            onEach(document.getElementsByClassName('line-numbers'), function(e) {\n+                onEach(e.getElementsByTagName('span'), function(i_e) {\n+                    removeClass(i_e, 'line-highlighted');\n+                });\n+            })\n             for (i = from; i <= to; ++i) {\n-                $('#' + i).addClass('line-highlighted');\n+                addClass(document.getElementById(i), 'line-highlighted');\n             }\n         }\n     }\n     highlightSourceLines(null);\n-    $(window).on('hashchange', highlightSourceLines);\n+    window.onhashchange = highlightSourceLines;\n \n     // Gets the human-readable string for the virtual-key code of the\n     // given KeyboardEvent, ev.\n@@ -99,23 +162,25 @@\n     }\n \n     function handleShortcut(ev) {\n-        if (document.activeElement.tagName == \"INPUT\")\n+        if (document.activeElement.tagName === \"INPUT\")\n             return;\n \n         // Don't interfere with browser shortcuts\n         if (ev.ctrlKey || ev.altKey || ev.metaKey)\n             return;\n \n+        var help = document.getElementById(\"help\");\n         switch (getVirtualKey(ev)) {\n         case \"Escape\":\n-            if (!$(\"#help\").hasClass(\"hidden\")) {\n+            var search = document.getElementById(\"search\");\n+            if (!hasClass(help, \"hidden\")) {\n                 ev.preventDefault();\n-                $(\"#help\").addClass(\"hidden\");\n-                $(\"body\").removeClass(\"blur\");\n-            } else if (!$(\"#search\").hasClass(\"hidden\")) {\n+                addClass(help, \"hidden\");\n+                removeClass(document.body, \"blur\");\n+            } else if (!hasClass(search, \"hidden\")) {\n                 ev.preventDefault();\n-                $(\"#search\").addClass(\"hidden\");\n-                $(\"#main\").removeClass(\"hidden\");\n+                addClass(search, \"hidden\");\n+                removeClass(document.getElementById(\"main\"), \"hidden\");\n             }\n             break;\n \n@@ -131,42 +196,76 @@\n             break;\n \n         case \"?\":\n-            if (ev.shiftKey && $(\"#help\").hasClass(\"hidden\")) {\n+            if (ev.shiftKey && hasClass(help, \"hidden\")) {\n                 ev.preventDefault();\n-                $(\"#help\").removeClass(\"hidden\");\n-                $(\"body\").addClass(\"blur\");\n+                removeClass(help, \"hidden\");\n+                addClass(document.body, \"blur\");\n             }\n             break;\n         }\n     }\n \n-    $(document).on(\"keypress\", handleShortcut);\n-    $(document).on(\"keydown\", handleShortcut);\n-    $(document).on(\"click\", function(ev) {\n-        if (!$(ev.target).closest(\"#help > div\").length) {\n-            $(\"#help\").addClass(\"hidden\");\n-            $(\"body\").removeClass(\"blur\");\n-        }\n-    });\n+    document.onkeypress = handleShortcut;\n+    document.onkeydown = handleShortcut;\n+    document.onclick = function(ev) {\n+        if (hasClass(ev.target, 'collapse-toggle')) {\n+            collapseDocs(ev.target);\n+        } else if (hasClass(ev.target.parentNode, 'collapse-toggle')) {\n+            collapseDocs(ev.target.parentNode);\n+        } else if (ev.target.tagName === 'SPAN' && hasClass(ev.target.parentNode, 'line-numbers')) {\n+            var prev_id = 0;\n+\n+            function set_fragment(name) {\n+                if (browserSupportsHistoryApi()) {\n+                    history.replaceState(null, null, '#' + name);\n+                    window.hashchange();\n+                } else {\n+                    location.replace('#' + name);\n+                }\n+            }\n \n-    $('.version-selector').on('change', function() {\n-        var i, match,\n-            url = document.location.href,\n-            stripped = '',\n-            len = rootPath.match(/\\.\\.\\//g).length + 1;\n+            var cur_id = parseInt(ev.target.id, 10);\n \n-        for (i = 0; i < len; ++i) {\n-            match = url.match(/\\/[^\\/]*$/);\n-            if (i < len - 1) {\n-                stripped = match[0] + stripped;\n+            if (ev.shiftKey && prev_id) {\n+                if (prev_id > cur_id) {\n+                    var tmp = prev_id;\n+                    prev_id = cur_id;\n+                    cur_id = tmp;\n+                }\n+\n+                set_fragment(prev_id + '-' + cur_id);\n+            } else {\n+                prev_id = cur_id;\n+\n+                set_fragment(cur_id);\n             }\n-            url = url.substring(0, url.length - match[0].length);\n+        } else if (!hasClass(document.getElementById(\"help\"), \"hidden\")) {\n+            addClass(document.getElementById(\"help\"), \"hidden\");\n+            removeClass(document.body, \"blur\");\n         }\n+    };\n \n-        url += '/' + $('.version-selector').val() + stripped;\n+    var x = document.getElementsByClassName('version-selector');\n+    if (x.length > 0) {\n+        x[0].onchange = function() {\n+            var i, match,\n+                url = document.location.href,\n+                stripped = '',\n+                len = rootPath.match(/\\.\\.\\//g).length + 1;\n \n-        document.location.href = url;\n-    });\n+            for (i = 0; i < len; ++i) {\n+                match = url.match(/\\/[^\\/]*$/);\n+                if (i < len - 1) {\n+                    stripped = match[0] + stripped;\n+                }\n+                url = url.substring(0, url.length - match[0].length);\n+            }\n+\n+            url += '/' + document.getElementsByClassName('version-selector')[0].value + stripped;\n+\n+            document.location.href = url;\n+        };\n+    }\n \n     /**\n      * A function to compute the Levenshtein distance between two strings\n@@ -214,8 +313,8 @@\n         // but only if the input bar is empty. This avoid the obnoxious issue\n         // where you start trying to do a search, and the index loads, and\n         // suddenly your search is gone!\n-        if ($(\".search-input\")[0].value === \"\") {\n-            $(\".search-input\")[0].value = params.search || '';\n+        if (document.getElementsByClassName(\"search-input\")[0].value === \"\") {\n+            document.getElementsByClassName(\"search-input\")[0].value = params.search || '';\n         }\n \n         /**\n@@ -484,7 +583,8 @@\n         }\n \n         function getQuery() {\n-            var matches, type, query, raw = $('.search-input').val();\n+            var matches, type, query, raw =\n+                document.getElementsByClassName('search-input')[0].value;\n             query = raw;\n \n             matches = query.match(/^(fn|mod|struct|enum|trait|type|const|macro)\\s*:\\s*/i);\n@@ -502,54 +602,92 @@\n         }\n \n         function initSearchNav() {\n-            var hoverTimeout, $results = $('.search-results .result');\n+            var hoverTimeout;\n \n-            $results.on('click', function() {\n-                var dst = $(this).find('a')[0];\n+            var click_func = function(e) {\n+                var el = e.target;\n+                // to retrieve the real \"owner\" of the event.\n+                while (el.tagName !== 'TR') {\n+                    el = el.parentNode;\n+                }\n+                var dst = e.target.getElementsByTagName('a');\n+                if (dst.length < 1) {\n+                    return;\n+                }\n+                dst = dst[0];\n                 if (window.location.pathname === dst.pathname) {\n-                    $('#search').addClass('hidden');\n-                    $('#main').removeClass('hidden');\n+                    addClass(document.getElementById('search'), 'hidden');\n+                    removeClass(document.getElementById('main'), 'hidden');\n                     document.location.href = dst.href;\n                 }\n-            }).on('mouseover', function() {\n-                var $el = $(this);\n+            };\n+            var mouseover_func = function(e) {\n+                var el = e.target;\n+                // to retrieve the real \"owner\" of the event.\n+                while (el.tagName !== 'TR') {\n+                    el = el.parentNode;\n+                }\n                 clearTimeout(hoverTimeout);\n                 hoverTimeout = setTimeout(function() {\n-                    $results.removeClass('highlighted');\n-                    $el.addClass('highlighted');\n+                    onEach(document.getElementsByClassName('search-results'), function(e) {\n+                        onEach(e.getElementsByClassName('result'), function(i_e) {\n+                            removeClass(i_e, 'highlighted');\n+                        });\n+                    });\n+                    addClass(el, 'highlighted');\n                 }, 20);\n+            };\n+            onEach(document.getElementsByClassName('search-results'), function(e) {\n+                onEach(e.getElementsByClassName('result'), function(i_e) {\n+                    i_e.onclick = click_func;\n+                    i_e.onmouseover = mouseover_func;\n+                });\n             });\n \n-            $(document).off('keydown.searchnav');\n-            $(document).on('keydown.searchnav', function(e) {\n-                var $active = $results.filter('.highlighted');\n+            var search_input = document.getElementsByClassName('search-input')[0];\n+            search_input.onkeydown = null;\n+            search_input.onkeydown = function(e) {\n+                var actives = [];\n+                onEach(document.getElementsByClassName('search-results'), function(e) {\n+                    onEach(document.getElementsByClassName('highlighted'), function(e) {\n+                        actives.push(e);\n+                    });\n+                });\n \n                 if (e.which === 38) { // up\n-                    if (!$active.length || !$active.prev()) {\n+                    if (!actives.length || !actives[0].previousElementSibling) {\n                         return;\n                     }\n \n-                    $active.prev().addClass('highlighted');\n-                    $active.removeClass('highlighted');\n+                    addClass(actives[0].previousElementSibling, 'highlighted');\n+                    removeClass(actives[0], 'highlighted');\n                 } else if (e.which === 40) { // down\n-                    if (!$active.length) {\n-                        $results.first().addClass('highlighted');\n-                    } else if ($active.next().length) {\n-                        $active.next().addClass('highlighted');\n-                        $active.removeClass('highlighted');\n+                    if (!actives.length) {\n+                        var results = document.getElementsByClassName('search-results');\n+                        if (results.length > 0) {\n+                            var res = results[0].getElementsByClassName('result');\n+                            if (res.length > 0) {\n+                                addClass(res[0], 'highlighted');\n+                            }\n+                        }\n+                    } else if (actives[0].nextElementSibling) {\n+                        addClass(actives[0].nextElementSibling, 'highlighted');\n+                        removeClass(actives[0], 'highlighted');\n                     }\n                 } else if (e.which === 13) { // return\n-                    if ($active.length) {\n-                        document.location.href = $active.find('a').prop('href');\n+                    if (actives.length) {\n+                        document.location.href = actives[0].getElementsByTagName('a')[0].href;\n                     }\n-                } else {\n-                  $active.removeClass('highlighted');\n+                } else if (actives.length > 0) {\n+                    removeClass(actives[0], 'highlighted');\n                 }\n-            });\n+            };\n         }\n \n         function escape(content) {\n-            return $('<h1/>').text(content).html();\n+            let h1 = document.createElement('h1');\n+            h1.textContent = content;\n+            return h1.innerHTML;\n         }\n \n         function showResults(results) {\n@@ -619,10 +757,19 @@\n             }\n \n             output += \"</p>\";\n-            $('#main.content').addClass('hidden');\n-            $('#search.content').removeClass('hidden').html(output);\n-            $('#search .desc').width($('#search').width() - 40 -\n-                $('#search td:first-child').first().width());\n+            addClass(document.getElementById('main'), 'hidden');\n+            var search = document.getElementById('search');\n+            removeClass(search, 'hidden');\n+            search.innerHTML = output;\n+            var tds = search.getElementsByTagName('td');\n+            var td_width = 0;\n+            if (tds.length > 0) {\n+                td_width = tds[0].offsetWidth;\n+            }\n+            var width = search.offsetWidth - 40 - td_width;\n+            onEach(search.getElementsByClassName('desc'), function(e) {\n+                e.style.width = width + 'px';\n+            });\n             initSearchNav();\n         }\n \n@@ -645,17 +792,15 @@\n             }\n \n             // Update document title to maintain a meaningful browser history\n-            $(document).prop(\"title\", \"Results for \" + query.query + \" - Rust\");\n+            document.title = \"Results for \" + query.query + \" - Rust\";\n \n             // Because searching is incremental by character, only the most\n             // recent search query is added to the browser history.\n             if (browserSupportsHistoryApi()) {\n                 if (!history.state && !params.search) {\n-                    history.pushState(query, \"\", \"?search=\" +\n-                                                encodeURIComponent(query.raw));\n+                    history.pushState(query, \"\", \"?search=\" + encodeURIComponent(query.raw));\n                 } else {\n-                    history.replaceState(query, \"\", \"?search=\" +\n-                                                encodeURIComponent(query.raw));\n+                    history.replaceState(query, \"\", \"?search=\" + encodeURIComponent(query.raw));\n                 }\n             }\n \n@@ -744,49 +889,68 @@\n \n         function startSearch() {\n             var searchTimeout;\n-            $(\".search-input\").on(\"keyup input\",function() {\n+            var callback = function() {\n+                var search_input = document.getElementsByClassName('search-input');\n+                if (search_input.length < 1) { return; }\n+                search_input = search_input[0];\n                 clearTimeout(searchTimeout);\n-                if ($(this).val().length === 0) {\n+                if (search_input.value.length === 0) {\n                     if (browserSupportsHistoryApi()) {\n                         history.replaceState(\"\", \"std - Rust\", \"?search=\");\n                     }\n-                    $('#main.content').removeClass('hidden');\n-                    $('#search.content').addClass('hidden');\n+                    var main = document.getElementById('main');\n+                    if (hasClass(main, 'content')) {\n+                        removeClass(main, 'hidden');\n+                    }\n+                    var search_c = document.getElementById('search');\n+                    if (hasClass(search_c, 'content')) {\n+                        addClass(search_c, 'hidden');\n+                    }\n                 } else {\n                     searchTimeout = setTimeout(search, 500);\n                 }\n-            });\n-            $('.search-form').on('submit', function(e){\n+            };\n+            var search_input = document.getElementsByClassName(\"search-input\")[0];\n+            search_input.onkeyup = callback;\n+            search_input.oninput = callback;\n+            document.getElementsByClassName(\"search-form\")[0].onsubmit = function(e){\n                 e.preventDefault();\n                 clearTimeout(searchTimeout);\n                 search();\n-            });\n-            $('.search-input').on('change paste', function(e) {\n+            };\n+            search_input.onchange = function(e) {\n                 // Do NOT e.preventDefault() here. It will prevent pasting.\n                 clearTimeout(searchTimeout);\n                 // zero-timeout necessary here because at the time of event handler execution the\n                 // pasted content is not in the input field yet. Shouldn\u2019t make any difference for\n                 // change, though.\n                 setTimeout(search, 0);\n-            });\n+            };\n+            search_input.onpaste = search_input.onchange;\n \n             // Push and pop states are used to add search results to the browser\n             // history.\n             if (browserSupportsHistoryApi()) {\n                 // Store the previous <title> so we can revert back to it later.\n-                var previousTitle = $(document).prop(\"title\");\n+                var previousTitle = document.title;\n \n-                $(window).on('popstate', function(e) {\n+                window.onpopstate = function(e) {\n                     var params = getQueryStringParams();\n                     // When browsing back from search results the main page\n                     // visibility must be reset.\n                     if (!params.search) {\n-                        $('#main.content').removeClass('hidden');\n-                        $('#search.content').addClass('hidden');\n+                        var main = document.getElementById('main');\n+                        if (hasClass(main, 'content')) {\n+                            removeClass(main, 'hidden');\n+                        }\n+                        var search = document.getElementById('search');\n+                        if (hasClass(main, 'content')) {\n+                            addClass(main, 'hidden');\n+                        }\n                     }\n                     // Revert to the previous title manually since the History\n                     // API ignores the title parameter.\n-                    $(document).prop(\"title\", previousTitle);\n+                    document.title = previousTitle;\n                     // When browsing forward to search results the previous\n                     // search will be repeated, so the currentResults are\n                     // cleared to ensure the search is successful.\n@@ -795,14 +959,14 @@\n                     // perform the search. This will empty the bar if there's\n                     // nothing there, which lets you really go back to a\n                     // previous state with nothing in the bar.\n-                    $('.search-input').val(params.search);\n+                    document.getElementsByClassName('search-input')[0].value = params.search;\n                     // Some browsers fire 'onpopstate' for every page load\n                     // (Chrome), while others fire the event only when actually\n                     // popping a state (Firefox), which is why search() is\n                     // called both here and at the end of the startSearch()\n                     // function.\n                     search();\n-                });\n+                };\n             }\n             search();\n         }\n@@ -812,10 +976,12 @@\n \n         // Draw a convenient sidebar of known crates if we have a listing\n         if (rootPath === '../') {\n-            var sidebar = $('.sidebar');\n-            var div = $('<div>').attr('class', 'block crate');\n-            div.append($('<h3>').text('Crates'));\n-            var ul = $('<ul>').appendTo(div);\n+            var sidebar = document.getElementsByClassName('sidebar')[0];\n+            var div = document.createElement('div');\n+            div.className = 'block crate';\n+            div.innerHTML = '<h3>Crates</h3>';\n+            var ul = document.createElement('ul');\n+            div.appendChild(ul);\n \n             var crates = [];\n             for (var crate in rawSearchIndex) {\n@@ -828,29 +994,37 @@\n                 if (crates[i] === window.currentCrate) {\n                     klass += ' current';\n                 }\n-                var link = $('<a>', {'href': '../' + crates[i] + '/index.html',\n-                                     'title': rawSearchIndex[crates[i]].doc,\n-                                     'class': klass}).text(crates[i]);\n-                ul.append($('<li>').append(link));\n+                var link = document.createElement('a');\n+                link.href = '../' + crates[i] + '/index.html';\n+                link.title = rawSearchIndex[crates[i]].doc;\n+                link.className = klass;\n+                link.textContent = crates[i];\n+\n+                var li = document.createElement('li');\n+                li.appendChild(link);\n+                ul.appendChild(li);\n             }\n-            sidebar.append(div);\n+            sidebar.appendChild(div);\n         }\n     }\n \n     window.initSearch = initSearch;\n \n     // delayed sidebar rendering.\n     function initSidebarItems(items) {\n-        var sidebar = $('.sidebar');\n+        var sidebar = document.getElementsByClassName('sidebar')[0];\n         var current = window.sidebarCurrent;\n \n         function block(shortty, longty) {\n             var filtered = items[shortty];\n             if (!filtered) { return; }\n \n-            var div = $('<div>').attr('class', 'block ' + shortty);\n-            div.append($('<h3>').text(longty));\n-            var ul = $('<ul>').appendTo(div);\n+            var div = document.createElement('div');\n+            div.className = 'block ' + shortty;\n+            var h3 = document.createElement('h3');\n+            h3.textContent = longty;\n+            div.appendChild(h3);\n+            var ul = document.createElement('ul');\n \n             for (var i = 0; i < filtered.length; ++i) {\n                 var item = filtered[i];\n@@ -867,12 +1041,17 @@\n                 } else {\n                     path = shortty + '.' + name + '.html';\n                 }\n-                var link = $('<a>', {'href': current.relpath + path,\n-                                     'title': desc,\n-                                     'class': klass}).text(name);\n-                ul.append($('<li>').append(link));\n+                var link = document.createElement('a');\n+                link.href = current.relpath + path;\n+                link.title = desc;\n+                link.className = klass;\n+                link.textContent = name;\n+                var li = document.createElement('li');\n+                li.appendChild(link);\n+                ul.appendChild(li);\n             }\n-            sidebar.append(div);\n+            div.appendChild(ul);\n+            sidebar.appendChild(div);\n         }\n \n         block(\"primitive\", \"Primitive Types\");\n@@ -890,21 +1069,25 @@\n     window.initSidebarItems = initSidebarItems;\n \n     window.register_implementors = function(imp) {\n-        var list = $('#implementors-list');\n+        var list = document.getElementById('implementors-list');\n         var libs = Object.getOwnPropertyNames(imp);\n         for (var i = 0; i < libs.length; ++i) {\n             if (libs[i] === currentCrate) { continue; }\n             var structs = imp[libs[i]];\n             for (var j = 0; j < structs.length; ++j) {\n-                var code = $('<code>').append(structs[j]);\n-                $.each(code.find('a'), function(idx, a) {\n-                    var href = $(a).attr('href');\n+                var code = document.createElement('code');\n+                code.innerHTML = structs[j];\n+\n+                var x = code.getElementsByTagName('a');\n+                for (var i = 0; i < x.length; i++) {\n+                    var href = x[i].href;\n                     if (href && href.indexOf('http') !== 0) {\n-                        $(a).attr('href', rootPath + href);\n+                        x[i].href = rootPath + href;\n                     }\n-                });\n-                var li = $('<li>').append(code);\n-                list.append(li);\n+                }\n+                var li = document.createElement('li');\n+                li.appendChild(code);\n+                list.appendChild(li);\n             }\n         }\n     };\n@@ -922,146 +1105,186 @@\n         return \"\\u2212\"; // \"\\u2212\" is '\u2212' minus sign\n     }\n \n+    function onEveryMatchingChild(elem, className, func) {\n+        if (elem && className && func) {\n+            for (var i = 0; i < elem.childNodes.length; i++) {\n+                if (hasClass(elem.childNodes[i], className)) {\n+                    func(elem.childNodes[i]);\n+                } else {\n+                    onEveryMatchingChild(elem.childNodes[i], className, func);\n+                }\n+            }\n+        }\n+    }\n+\n     function toggleAllDocs() {\n-        var toggle = $(\"#toggle-all-docs\");\n-        if (toggle.hasClass(\"will-expand\")) {\n-            toggle.removeClass(\"will-expand\");\n-            toggle.children(\".inner\").text(labelForToggleButton(false));\n-            toggle.attr(\"title\", \"collapse all docs\");\n-            $(\".docblock\").show();\n-            $(\".toggle-label\").hide();\n-            $(\".toggle-wrapper\").removeClass(\"collapsed\");\n-            $(\".collapse-toggle\").children(\".inner\").text(labelForToggleButton(false));\n+        var toggle = document.getElementById(\"toggle-all-docs\");\n+        if (hasClass(toggle, \"will-expand\")) {\n+            removeClass(toggle, \"will-expand\");\n+            onEveryMatchingChild(toggle, \"inner\", function(e) {\n+                e.innerHTML = labelForToggleButton(false);\n+            });\n+            toggle.title = \"collapse all docs\";\n+            onEach(document.getElementsByClassName(\"docblock\"), function(e) {\n+                e.style.display = 'block';\n+            });\n+            onEach(document.getElementsByClassName(\"toggle-label\"), function(e) {\n+                e.style.display = 'none';\n+            });\n+            onEach(document.getElementsByClassName(\"toggle-wrapper\"), function(e) {\n+                removeClass(e, \"collapsed\");\n+            });\n+            onEach(document.getElementsByClassName(\"collapse-toggle\"), function(e) {\n+                onEveryMatchingChild(e, \"inner\", function(i_e) {\n+                    i_e.innerHTML = labelForToggleButton(false);\n+                });\n+            });\n         } else {\n-            toggle.addClass(\"will-expand\");\n-            toggle.children(\".inner\").text(labelForToggleButton(true));\n-            toggle.attr(\"title\", \"expand all docs\");\n-            $(\".docblock\").hide();\n-            $(\".toggle-label\").show();\n-            $(\".toggle-wrapper\").addClass(\"collapsed\");\n-            $(\".collapse-toggle\").children(\".inner\").text(labelForToggleButton(true));\n+            addClass(toggle, \"will-expand\");\n+            onEveryMatchingChild(toggle, \"inner\", function(e) {\n+                e.innerHTML = labelForToggleButton(true);\n+            });\n+            toggle.title = \"expand all docs\";\n+            onEach(document.getElementsByClassName(\"docblock\"), function(e) {\n+                e.style.display = 'none';\n+            });\n+            onEach(document.getElementsByClassName(\"toggle-label\"), function(e) {\n+                e.style.display = 'inline-block';\n+            });\n+            onEach(document.getElementsByClassName(\"toggle-wrapper\"), function(e) {\n+                addClass(e, \"collapsed\");\n+            });\n+            onEach(document.getElementsByClassName(\"collapse-toggle\"), function(e) {\n+                onEveryMatchingChild(e, \"inner\", function(i_e) {\n+                    i_e.innerHTML = labelForToggleButton(true);\n+                });\n+            });\n         }\n     }\n \n-    function collapseDocs(toggle, animate) {\n-        var relatedDoc = toggle.parent().next();\n-        if (relatedDoc.is(\".stability\")) {\n-            relatedDoc = relatedDoc.next();\n+    function collapseDocs(toggle) {\n+        if (!toggle || !toggle.parentNode) {\n+            return;\n         }\n-        if (relatedDoc.is(\".docblock\")) {\n-            if (relatedDoc.is(\":visible\")) {\n-                if (animate === true) {\n-                    relatedDoc.slideUp({\n-                        duration: 'fast',\n-                        easing: 'linear',\n-                        complete: function() {\n-                            toggle.children(\".toggle-label\").fadeIn();\n-                            toggle.parent(\".toggle-wrapper\").addClass(\"collapsed\");\n-                            toggle.children(\".inner\").text(labelForToggleButton(true));\n-                        },\n-                    });\n-                } else {\n-                    relatedDoc.hide();\n-                    toggle.children(\".toggle-label\").show();\n-                    toggle.parent(\".toggle-wrapper\").addClass(\"collapsed\");\n-                    toggle.children(\".inner\").text(labelForToggleButton(true));\n-                }\n+        var relatedDoc = toggle.parentNode.nextElementSibling;\n+        if (hasClass(relatedDoc, \"stability\")) {\n+            relatedDoc = relatedDoc.nextElementSibling;\n+        }\n+        if (hasClass(relatedDoc, \"docblock\")) {\n+            if (!isHidden(relatedDoc)) {\n+                relatedDoc.style.display = 'none';\n+                onEach(toggle.childNodes, function(e) {\n+                    if (hasClass(e, 'toggle-label')) {\n+                        e.style.display = 'inline-block';\n+                    }\n+                    if (hasClass(e, 'inner')) {\n+                        e.innerHTML = labelForToggleButton(true);\n+                    }\n+                });\n+                addClass(toggle.parentNode, 'collapsed');\n             } else {\n-                relatedDoc.slideDown({duration: 'fast', easing: 'linear'});\n-                toggle.parent(\".toggle-wrapper\").removeClass(\"collapsed\");\n-                toggle.children(\".inner\").text(labelForToggleButton(false));\n-                toggle.children(\".toggle-label\").hide();\n+                relatedDoc.style.display = 'block';\n+                removeClass(toggle.parentNode, 'collapsed');\n+                onEach(toggle.childNodes, function(e) {\n+                    if (hasClass(e, 'toggle-label')) {\n+                        e.style.display = 'none';\n+                    }\n+                    if (hasClass(e, 'inner')) {\n+                        e.innerHTML = labelForToggleButton(false);\n+                    }\n+                });\n             }\n         }\n     }\n \n-    $(\"#toggle-all-docs\").on(\"click\", toggleAllDocs);\n+    var x = document.getElementById('toggle-all-docs');\n+    if (x) {\n+        x.onclick = toggleAllDocs;\n+    }\n \n-    $(document).on(\"click\", \".collapse-toggle\", function() {\n-        collapseDocs($(this), true)\n-    });\n+    function insertAfter(newNode, referenceNode) {\n+        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n+    }\n \n-    $(function() {\n-        var toggle = $(\"<a/>\", {'href': 'javascript:void(0)', 'class': 'collapse-toggle'})\n-            .html(\"[<span class='inner'></span>]\");\n-        toggle.children(\".inner\").text(labelForToggleButton(false));\n+    var toggle = document.createElement('a');\n+    toggle.href = 'javascript:void(0)';\n+    toggle.className = 'collapse-toggle';\n+    toggle.innerHTML = \"[<span class='inner'>\"+labelForToggleButton(false)+\"</span>]\";\n \n-        $(\".method, .impl-items > .associatedconstant\").each(function() {\n-            if ($(this).next().is(\".docblock\") ||\n-                ($(this).next().is(\".stability\") && $(this).next().next().is(\".docblock\"))) {\n-                    $(this).children().last().after(toggle.clone());\n-            }\n-        });\n+    var func = function(e) {\n+        var next = e.nextElementSibling;\n+        if (!next) {\n+            return;\n+        }\n+        if (hasClass(next, 'docblock') ||\n+            (hasClass(next, 'stability') &&\n+             hasClass(next.nextElementSibling, 'docblock'))) {\n+            insertAfter(toggle.cloneNode(true), e.childNodes[e.childNodes.length - 1]);\n+        }\n+    }\n+    onEach(document.getElementsByClassName('method'), func);\n+    onEach(document.getElementsByClassName('impl-items'), function(e) {\n+        onEach(e.getElementsByClassName('associatedconstant'), func);\n+    });\n \n-        var mainToggle =\n-            $(toggle.clone()).append(\n-                $('<span/>', {'class': 'toggle-label'})\n-                    .css('display', 'none')\n-                    .html('&nbsp;Expand&nbsp;description'));\n-        var wrapper = $(\"<div class='toggle-wrapper'>\").append(mainToggle);\n-        $(\"#main > .docblock\").before(wrapper);\n-\n-        $(\".docblock.autohide\").each(function() {\n-            var wrap = $(this).prev();\n-            if (wrap.is(\".toggle-wrapper\")) {\n-                var toggle = wrap.children().first();\n-                if ($(this).children().first().is(\"h3\")) {\n-                    toggle.children(\".toggle-label\")\n-                          .text(\" Show \" + $(this).children().first().text());\n-                }\n-                $(this).hide();\n-                wrap.addClass(\"collapsed\");\n-                toggle.children(\".inner\").text(labelForToggleButton(true));\n-                toggle.children(\".toggle-label\").show();\n-            }\n-        });\n+    var span = document.createElement('span');\n+    span.className = 'toggle-label';\n+    span.style.display = 'none';\n+    span.innerHTML = '&nbsp;Expand&nbsp;description';\n \n-        var mainToggle =\n-            $(toggle).append(\n-                $('<span/>', {'class': 'toggle-label'})\n-                    .css('display', 'none')\n-                    .html('&nbsp;Expand&nbsp;attributes'));\n-        var wrapper = $(\"<div class='toggle-wrapper toggle-attributes'>\").append(mainToggle);\n-        $(\"#main > pre > .attributes\").each(function() {\n-            $(this).before(wrapper);\n-            collapseDocs($($(this).prev().children()[0]), false);\n-        });\n-    });\n+    var mainToggle = toggle.cloneNode(true);\n+    mainToggle.appendChild(span);\n \n-    $('pre.line-numbers').on('click', 'span', function() {\n-        var prev_id = 0;\n+    var wrapper = document.createElement('div');\n+    wrapper.className = 'toggle-wrapper';\n+    wrapper.appendChild(mainToggle);\n \n-        function set_fragment(name) {\n-            if (browserSupportsHistoryApi()) {\n-                history.replaceState(null, null, '#' + name);\n-                $(window).trigger('hashchange');\n-            } else {\n-                location.replace('#' + name);\n-            }\n+    onEach(document.getElementById('main').getElementsByClassName('docblock'), function(e) {\n+        if (e.parentNode.id === \"main\") {\n+            e.parentNode.insertBefore(wrapper, e);\n         }\n+    });\n \n-        return function(ev) {\n-            var cur_id = parseInt(ev.target.id, 10);\n-\n-            if (ev.shiftKey && prev_id) {\n-                if (prev_id > cur_id) {\n-                    var tmp = prev_id;\n-                    prev_id = cur_id;\n-                    cur_id = tmp;\n+    onEach(document.getElementsByClassName('docblock'), function(e) {\n+        if (hasClass(e, 'autohide')) {\n+            var wrap = e.previousElementSibling;\n+            if (wrap && hasClass(wrap, 'toggle-wrapper')) {\n+                var toggle = wrap.childNodes[0];\n+                if (e.childNodes[0].tagName === 'H3') {\n+                    onEach(toggle.getElementsByClassName('toggle-label'), function(i_e) {\n+                        i_e.innerHTML = \" Show \" + e.childNodes[0].innerHTML;\n+                    });\n                 }\n-\n-                set_fragment(prev_id + '-' + cur_id);\n-            } else {\n-                prev_id = cur_id;\n-\n-                set_fragment(cur_id);\n+                e.style.display = 'none';\n+                addClass(wrap, 'collapsed');\n+                onEach(toggle.getElementsByClassName('inner'), function(e) {\n+                    e.innerHTML = labelForToggleButton(true);\n+                });\n+                onEach(toggle.getElementsByClassName('toggle-label'), function(e) {\n+                    e.style.display = 'block';\n+                });\n             }\n-        };\n-    }());\n-\n+        }\n+    })\n+\n+    var span = document.createElement('span');\n+    span.className = 'toggle-label';\n+    span.style.display = 'none';\n+    span.innerHTML = '&nbsp;Expand&nbsp;attributes';\n+    toggle.appendChild(span);\n+\n+    var wrapper = document.createElement('div');\n+    wrapper.className = 'toggle-wrapper toggle-attributes';\n+    wrapper.appendChild(toggle);\n+    onEach(document.getElementById('main').getElementsByTagName('pre'), function(e) {\n+        onEach(e.getElementsByClassName('attributes'), function(i_e) {\n+            i_e.parentNode.insertBefore(wrapper, i_e);\n+            collapseDocs(i_e.previousSibling.childNodes[0]);\n+        });\n+    });\n }());\n \n // Sets the focus on the search bar at the top of the page\n function focusSearchBar() {\n-    $('.search-input').focus();\n+    document.getElementsByClassName('search-input')[0].focus();\n }"}, {"sha": "1156fadf8c02c146dd01b4b5539c067dc67745fb", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -41,6 +41,7 @@ extern crate rustc_resolve;\n extern crate rustc_lint;\n extern crate rustc_back;\n extern crate rustc_metadata;\n+extern crate rustc_typeck;\n extern crate serialize;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n@@ -172,6 +173,7 @@ pub fn opts() -> Vec<RustcOptGroup> {\n                          or `#![doc(html_playground_url=...)]`\",\n                         \"URL\")),\n         unstable(optflag(\"\", \"enable-commonmark\", \"to enable commonmark doc rendering/testing\")),\n+        unstable(optflag(\"\", \"display-warnings\", \"to print code warnings when testing doc\")),\n     ]\n }\n \n@@ -279,14 +281,16 @@ pub fn main_args(args: &[String]) -> isize {\n     let crate_name = matches.opt_str(\"crate-name\");\n     let playground_url = matches.opt_str(\"playground-url\");\n     let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n+    let display_warnings = matches.opt_present(\"display-warnings\");\n \n     match (should_test, markdown_input) {\n         (true, true) => {\n-            return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot, render_type)\n+            return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot, render_type,\n+                                  display_warnings)\n         }\n         (true, false) => {\n             return test::run(input, cfgs, libs, externs, test_args, crate_name, maybe_sysroot,\n-                             render_type)\n+                             render_type, display_warnings)\n         }\n         (false, true) => return markdown::render(input,\n                                                  output.unwrap_or(PathBuf::from(\"doc\")),\n@@ -388,13 +392,15 @@ where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n \n     let cr = PathBuf::from(cratefile);\n     info!(\"starting to run rustc\");\n+    let display_warnings = matches.opt_present(\"display-warnings\");\n \n     let (tx, rx) = channel();\n     rustc_driver::monitor(move || {\n         use rustc::session::config::Input;\n \n         let (mut krate, renderinfo) =\n-            core::run_core(paths, cfgs, externs, Input::File(cr), triple, maybe_sysroot);\n+            core::run_core(paths, cfgs, externs, Input::File(cr), triple, maybe_sysroot,\n+                           display_warnings);\n \n         info!(\"finished with rustc\");\n "}, {"sha": "057ce69d9de8bcf925f59cb3a9c7700763202d40", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -150,7 +150,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n /// Run any tests/code examples in the markdown file `input`.\n pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n             mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>,\n-            render_type: RenderType) -> isize {\n+            render_type: RenderType, display_warnings: bool) -> isize {\n     let input_str = match load_string(input) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n@@ -166,6 +166,7 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n     old_find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     test_args.insert(0, \"rustdoctest\".to_string());\n-    testing::test_main(&test_args, collector.tests);\n+    testing::test_main(&test_args, collector.tests,\n+                       testing::Options::new().display_output(display_warnings));\n     0\n }"}, {"sha": "d5237d629cfc1e7f8f40f2a9c3c9b53c6bdb0825", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -58,7 +58,8 @@ pub fn run(input: &str,\n            mut test_args: Vec<String>,\n            crate_name: Option<String>,\n            maybe_sysroot: Option<PathBuf>,\n-           render_type: RenderType)\n+           render_type: RenderType,\n+           display_warnings: bool)\n            -> isize {\n     let input_path = PathBuf::from(input);\n     let input = config::Input::File(input_path.clone());\n@@ -127,7 +128,8 @@ pub fn run(input: &str,\n     test_args.insert(0, \"rustdoctest\".to_string());\n \n     testing::test_main(&test_args,\n-                       collector.tests.into_iter().collect());\n+                       collector.tests.into_iter().collect(),\n+                       testing::Options::new().display_output(display_warnings));\n     0\n }\n "}, {"sha": "f84662c3f86828874498915842c732676e131b9b", "filename": "src/libstd/build.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -43,11 +43,16 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=pthread\");\n     } else if target.contains(\"apple-darwin\") {\n         println!(\"cargo:rustc-link-lib=System\");\n+\n+        // res_init and friends require -lresolv on macOS/iOS.\n+        // See #41582 and http://blog.achernya.com/2013/03/os-x-has-silly-libsystem.html\n+        println!(\"cargo:rustc-link-lib=resolv\");\n     } else if target.contains(\"apple-ios\") {\n         println!(\"cargo:rustc-link-lib=System\");\n         println!(\"cargo:rustc-link-lib=objc\");\n         println!(\"cargo:rustc-link-lib=framework=Security\");\n         println!(\"cargo:rustc-link-lib=framework=Foundation\");\n+        println!(\"cargo:rustc-link-lib=resolv\");\n     } else if target.contains(\"windows\") {\n         println!(\"cargo:rustc-link-lib=advapi32\");\n         println!(\"cargo:rustc-link-lib=ws2_32\");"}, {"sha": "a15269cc87c5da08f9e0acd973f628ba83240bda", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::heap::{EMPTY, allocate, deallocate};\n+use alloc::heap::{allocate, deallocate};\n \n use cmp;\n use hash::{BuildHasher, Hash, Hasher};\n@@ -33,6 +33,7 @@ use self::BucketState::*;\n type HashUint = usize;\n \n const EMPTY_BUCKET: HashUint = 0;\n+const EMPTY: usize = 1;\n \n /// Special `Unique<HashUint>` that uses the lower bit of the pointer\n /// to expose a boolean tag.\n@@ -49,24 +50,25 @@ impl TaggedHashUintPtr {\n \n     #[inline]\n     fn set_tag(&mut self, value: bool) {\n-        let usize_ptr = &*self.0 as *const *mut HashUint as *mut usize;\n+        let mut usize_ptr = self.0.as_ptr() as usize;\n         unsafe {\n             if value {\n-                *usize_ptr |= 1;\n+                usize_ptr |= 1;\n             } else {\n-                *usize_ptr &= !1;\n+                usize_ptr &= !1;\n             }\n+            self.0 = Unique::new(usize_ptr as *mut HashUint)\n         }\n     }\n \n     #[inline]\n     fn tag(&self) -> bool {\n-        (*self.0 as usize) & 1 == 1\n+        (self.0.as_ptr() as usize) & 1 == 1\n     }\n \n     #[inline]\n     fn ptr(&self) -> *mut HashUint {\n-        (*self.0 as usize & !1) as *mut HashUint\n+        (self.0.as_ptr() as usize & !1) as *mut HashUint\n     }\n }\n \n@@ -1112,10 +1114,12 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n \n     #[inline]\n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|raw| unsafe {\n-            (*self.table.as_mut_ptr()).size -= 1;\n-            let (k, v) = ptr::read(raw.pair());\n-            (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n+        self.iter.next().map(|raw| {\n+            unsafe {\n+                self.table.as_mut().size -= 1;\n+                let (k, v) = ptr::read(raw.pair());\n+                (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n+            }\n         })\n     }\n "}, {"sha": "528d903b8b0187ba155995fb79754ed302ff043e", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -2412,7 +2412,7 @@ mod tests {\n \n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n-        let unicode = unicode.join(&format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n+        let unicode = unicode.join(\"test-\uac01\u4e01\u30fc\u518d\u89c1\");\n         check!(fs::create_dir(&unicode));\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());"}, {"sha": "3896fc20a2dde12924ac2c477b6013f0459d2a65", "filename": "src/libstd/process.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -148,8 +148,9 @@ impl fmt::Debug for Child {\n     }\n }\n \n-/// A handle to a child process's stdin. This struct is used in the [`stdin`]\n-/// field on [`Child`].\n+/// A handle to a child process's stdin.\n+///\n+/// This struct is used in the [`stdin`] field on [`Child`].\n ///\n /// [`Child`]: struct.Child.html\n /// [`stdin`]: struct.Child.html#structfield.stdin\n@@ -190,8 +191,9 @@ impl fmt::Debug for ChildStdin {\n     }\n }\n \n-/// A handle to a child process's stdout. This struct is used in the [`stdout`]\n-/// field on [`Child`].\n+/// A handle to a child process's stdout.\n+///\n+/// This struct is used in the [`stdout`] field on [`Child`].\n ///\n /// [`Child`]: struct.Child.html\n /// [`stdout`]: struct.Child.html#structfield.stdout"}, {"sha": "2487f6bcaf74f0861e48f65492eb90ce18bc8296", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -38,3 +38,8 @@ pub unsafe fn destroy(key: Key) {\n     let r = libc::pthread_key_delete(key);\n     debug_assert_eq!(r, 0);\n }\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    false\n+}"}, {"sha": "5e46069cf7ddfb2257eb8d4f5423cb1d153f83fb", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -14,8 +14,9 @@\n #![cfg_attr(test, allow(dead_code))]\n #![unstable(issue = \"0\", feature = \"windows_c\")]\n \n-use os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort,};\n-use os::raw::{c_char, c_ulonglong};\n+use os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort, c_char};\n+#[cfg(target_arch = \"x86_64\")]\n+use os::raw::c_ulonglong;\n use libc::{wchar_t, size_t, c_void};\n use ptr;\n \n@@ -45,7 +46,7 @@ pub type SIZE_T = usize;\n pub type WORD = u16;\n pub type CHAR = c_char;\n pub type HCRYPTPROV = LONG_PTR;\n-pub type ULONG_PTR = c_ulonglong;\n+pub type ULONG_PTR = usize;\n pub type ULONG = c_ulong;\n #[cfg(target_arch = \"x86_64\")]\n pub type ULONGLONG = u64;\n@@ -935,7 +936,6 @@ extern \"system\" {\n                           args: *const c_void)\n                           -> DWORD;\n     pub fn TlsAlloc() -> DWORD;\n-    pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n     pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n     pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n     pub fn GetLastError() -> DWORD;"}, {"sha": "ad57f87dc1ff991b68b029c0884862d1c795142a", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 66, "deletions": 99, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use mem;\n use ptr;\n+use sync::atomic::AtomicPtr;\n+use sync::atomic::Ordering::SeqCst;\n use sys::c;\n-use sys_common::mutex::Mutex;\n-use sys_common;\n \n pub type Key = c::DWORD;\n pub type Dtor = unsafe extern fn(*mut u8);\n@@ -34,8 +35,6 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // * All TLS destructors are tracked by *us*, not the windows runtime. This\n //   means that we have a global list of destructors for each TLS key that\n //   we know about.\n-// * When a TLS key is destroyed, we're sure to remove it from the dtor list\n-//   if it's in there.\n // * When a thread exits, we run over the entire list and run dtors for all\n //   non-null keys. This attempts to match Unix semantics in this regard.\n //\n@@ -50,13 +49,6 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // [2]: https://github.com/ChromiumWebApps/chromium/blob/master/base\n //                        /threading/thread_local_storage_win.cc#L42\n \n-// NB these are specifically not types from `std::sync` as they currently rely\n-// on poisoning and this module needs to operate at a lower level than requiring\n-// the thread infrastructure to be in place (useful on the borders of\n-// initialization/destruction).\n-static DTOR_LOCK: Mutex = Mutex::new();\n-static mut DTORS: *mut Vec<(Key, Dtor)> = ptr::null_mut();\n-\n // -------------------------------------------------------------------------\n // Native bindings\n //\n@@ -85,81 +77,64 @@ pub unsafe fn get(key: Key) -> *mut u8 {\n }\n \n #[inline]\n-pub unsafe fn destroy(key: Key) {\n-    if unregister_dtor(key) {\n-        // FIXME: Currently if a key has a destructor associated with it we\n-        // can't actually ever unregister it. If we were to\n-        // unregister it, then any key destruction would have to be\n-        // serialized with respect to actually running destructors.\n-        //\n-        // We want to avoid a race where right before run_dtors runs\n-        // some destructors TlsFree is called. Allowing the call to\n-        // TlsFree would imply that the caller understands that *all\n-        // known threads* are not exiting, which is quite a difficult\n-        // thing to know!\n-        //\n-        // For now we just leak all keys with dtors to \"fix\" this.\n-        // Note that source [2] above shows precedent for this sort\n-        // of strategy.\n-    } else {\n-        let r = c::TlsFree(key);\n-        debug_assert!(r != 0);\n-    }\n+pub unsafe fn destroy(_key: Key) {\n+    rtabort!(\"can't destroy tls keys on windows\")\n+}\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    true\n }\n \n // -------------------------------------------------------------------------\n // Dtor registration\n //\n-// These functions are associated with registering and unregistering\n-// destructors. They're pretty simple, they just push onto a vector and scan\n-// a vector currently.\n+// Windows has no native support for running destructors so we manage our own\n+// list of destructors to keep track of how to destroy keys. We then install a\n+// callback later to get invoked whenever a thread exits, running all\n+// appropriate destructors.\n //\n-// FIXME: This could probably be at least a little faster with a BTree.\n-\n-unsafe fn init_dtors() {\n-    if !DTORS.is_null() { return }\n+// Currently unregistration from this list is not supported. A destructor can be\n+// registered but cannot be unregistered. There's various simplifying reasons\n+// for doing this, the big ones being:\n+//\n+// 1. Currently we don't even support deallocating TLS keys, so normal operation\n+//    doesn't need to deallocate a destructor.\n+// 2. There is no point in time where we know we can unregister a destructor\n+//    because it could always be getting run by some remote thread.\n+//\n+// Typically processes have a statically known set of TLS keys which is pretty\n+// small, and we'd want to keep this memory alive for the whole process anyway\n+// really.\n+//\n+// Perhaps one day we can fold the `Box` here into a static allocation,\n+// expanding the `StaticKey` structure to contain not only a slot for the TLS\n+// key but also a slot for the destructor queue on windows. An optimization for\n+// another day!\n \n-    let dtors = box Vec::<(Key, Dtor)>::new();\n+static DTORS: AtomicPtr<Node> = AtomicPtr::new(ptr::null_mut());\n \n-    let res = sys_common::at_exit(move|| {\n-        DTOR_LOCK.lock();\n-        let dtors = DTORS;\n-        DTORS = 1 as *mut _;\n-        Box::from_raw(dtors);\n-        assert!(DTORS as usize == 1); // can't re-init after destructing\n-        DTOR_LOCK.unlock();\n-    });\n-    if res.is_ok() {\n-        DTORS = Box::into_raw(dtors);\n-    } else {\n-        DTORS = 1 as *mut _;\n-    }\n+struct Node {\n+    dtor: Dtor,\n+    key: Key,\n+    next: *mut Node,\n }\n \n unsafe fn register_dtor(key: Key, dtor: Dtor) {\n-    DTOR_LOCK.lock();\n-    init_dtors();\n-    assert!(DTORS as usize != 0);\n-    assert!(DTORS as usize != 1,\n-            \"cannot create new TLS keys after the main thread has exited\");\n-    (*DTORS).push((key, dtor));\n-    DTOR_LOCK.unlock();\n-}\n+    let mut node = Box::new(Node {\n+        key: key,\n+        dtor: dtor,\n+        next: ptr::null_mut(),\n+    });\n \n-unsafe fn unregister_dtor(key: Key) -> bool {\n-    DTOR_LOCK.lock();\n-    init_dtors();\n-    assert!(DTORS as usize != 0);\n-    assert!(DTORS as usize != 1,\n-            \"cannot unregister destructors after the main thread has exited\");\n-    let ret = {\n-        let dtors = &mut *DTORS;\n-        let before = dtors.len();\n-        dtors.retain(|&(k, _)| k != key);\n-        dtors.len() != before\n-    };\n-    DTOR_LOCK.unlock();\n-    ret\n+    let mut head = DTORS.load(SeqCst);\n+    loop {\n+        node.next = head;\n+        match DTORS.compare_exchange(head, &mut *node, SeqCst, SeqCst) {\n+            Ok(_) => return mem::forget(node),\n+            Err(cur) => head = cur,\n+        }\n+    }\n }\n \n // -------------------------------------------------------------------------\n@@ -196,16 +171,12 @@ unsafe fn unregister_dtor(key: Key) -> bool {\n // # Ok, what's up with running all these destructors?\n //\n // This will likely need to be improved over time, but this function\n-// attempts a \"poor man's\" destructor callback system. To do this we clone a\n-// local copy of the dtor list to start out with. This is our fudgy attempt\n-// to not hold the lock while destructors run and not worry about the list\n-// changing while we're looking at it.\n-//\n-// Once we've got a list of what to run, we iterate over all keys, check\n-// their values, and then run destructors if the values turn out to be non\n-// null (setting them to null just beforehand). We do this a few times in a\n-// loop to basically match Unix semantics. If we don't reach a fixed point\n-// after a short while then we just inevitably leak something most likely.\n+// attempts a \"poor man's\" destructor callback system. Once we've got a list\n+// of what to run, we iterate over all keys, check their values, and then run\n+// destructors if the values turn out to be non null (setting them to null just\n+// beforehand). We do this a few times in a loop to basically match Unix\n+// semantics. If we don't reach a fixed point after a short while then we just\n+// inevitably leak something most likely.\n //\n // # The article mentions weird stuff about \"/INCLUDE\"?\n //\n@@ -259,25 +230,21 @@ unsafe extern \"system\" fn on_tls_callback(h: c::LPVOID,\n unsafe fn run_dtors() {\n     let mut any_run = true;\n     for _ in 0..5 {\n-        if !any_run { break }\n+        if !any_run {\n+            break\n+        }\n         any_run = false;\n-        let dtors = {\n-            DTOR_LOCK.lock();\n-            let ret = if DTORS as usize <= 1 {\n-                Vec::new()\n-            } else {\n-                (*DTORS).iter().map(|s| *s).collect()\n-            };\n-            DTOR_LOCK.unlock();\n-            ret\n-        };\n-        for &(key, dtor) in &dtors {\n-            let ptr = c::TlsGetValue(key);\n+        let mut cur = DTORS.load(SeqCst);\n+        while !cur.is_null() {\n+            let ptr = c::TlsGetValue((*cur).key);\n+\n             if !ptr.is_null() {\n-                c::TlsSetValue(key, ptr::null_mut());\n-                dtor(ptr as *mut _);\n+                c::TlsSetValue((*cur).key, ptr::null_mut());\n+                ((*cur).dtor)(ptr as *mut _);\n                 any_run = true;\n             }\n+\n+            cur = (*cur).next;\n         }\n     }\n }"}, {"sha": "a1897c8bd676e0ec53eb11893e668a4f4f20f56e", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -177,9 +177,22 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     };\n     let mut res = ptr::null_mut();\n     unsafe {\n-        cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints,\n-                               &mut res))?;\n-        Ok(LookupHost { original: res, cur: res })\n+        match cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)) {\n+            Ok(_) => {\n+                Ok(LookupHost { original: res, cur: res })\n+            },\n+            #[cfg(unix)]\n+            Err(e) => {\n+                // The lookup failure could be caused by using a stale /etc/resolv.conf.\n+                // See https://github.com/rust-lang/rust/issues/41570.\n+                // We therefore force a reload of the nameserver information.\n+                c::res_init();\n+                Err(e)\n+            },\n+            // the cfg is needed here to avoid an \"unreachable pattern\" warning\n+            #[cfg(not(unix))]\n+            Err(e) => Err(e),\n+        }\n     }\n }\n "}, {"sha": "0ade90e64c307e66e98edce22e3923ae9a74f1ef", "filename": "src/libstd/sys_common/thread_local.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_local.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -61,6 +61,7 @@\n use sync::atomic::{self, AtomicUsize, Ordering};\n \n use sys::thread_local as imp;\n+use sys_common::mutex::Mutex;\n \n /// A type for TLS keys that are statically allocated.\n ///\n@@ -145,20 +146,6 @@ impl StaticKey {\n     #[inline]\n     pub unsafe fn set(&self, val: *mut u8) { imp::set(self.key(), val) }\n \n-    /// Deallocates this OS TLS key.\n-    ///\n-    /// This function is unsafe as there is no guarantee that the key is not\n-    /// currently in use by other threads or will not ever be used again.\n-    ///\n-    /// Note that this does *not* run the user-provided destructor if one was\n-    /// specified at definition time. Doing so must be done manually.\n-    pub unsafe fn destroy(&self) {\n-        match self.key.swap(0, Ordering::SeqCst) {\n-            0 => {}\n-            n => { imp::destroy(n as imp::Key) }\n-        }\n-    }\n-\n     #[inline]\n     unsafe fn key(&self) -> imp::Key {\n         match self.key.load(Ordering::Relaxed) {\n@@ -168,6 +155,24 @@ impl StaticKey {\n     }\n \n     unsafe fn lazy_init(&self) -> usize {\n+        // Currently the Windows implementation of TLS is pretty hairy, and\n+        // it greatly simplifies creation if we just synchronize everything.\n+        //\n+        // Additionally a 0-index of a tls key hasn't been seen on windows, so\n+        // we just simplify the whole branch.\n+        if imp::requires_synchronized_create() {\n+            static INIT_LOCK: Mutex = Mutex::new();\n+            INIT_LOCK.lock();\n+            let mut key = self.key.load(Ordering::SeqCst);\n+            if key == 0 {\n+                key = imp::create(self.dtor) as usize;\n+                self.key.store(key, Ordering::SeqCst);\n+            }\n+            INIT_LOCK.unlock();\n+            assert!(key != 0);\n+            return key\n+        }\n+\n         // POSIX allows the key created here to be 0, but the compare_and_swap\n         // below relies on using 0 as a sentinel value to check who won the\n         // race to set the shared TLS key. As far as I know, there is no\n@@ -227,7 +232,9 @@ impl Key {\n \n impl Drop for Key {\n     fn drop(&mut self) {\n-        unsafe { imp::destroy(self.key) }\n+        // Right now Windows doesn't support TLS key destruction, but this also\n+        // isn't used anywhere other than tests, so just leak the TLS key.\n+        // unsafe { imp::destroy(self.key) }\n     }\n }\n "}, {"sha": "04cd28df4459d09d7dd5389e56e4bc488a47565f", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 61, "deletions": 13, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -66,7 +66,7 @@\n //! let res = child.join();\n //! ```\n //!\n-//! The [`join`] method returns a [`Result`] containing [`Ok`] of the final\n+//! The [`join`] method returns a [`thread::Result`] containing [`Ok`] of the final\n //! value produced by the child thread, or [`Err`] of the value given to\n //! a call to [`panic!`] if the child panicked.\n //!\n@@ -159,6 +159,7 @@\n //! [`panic!`]: ../../std/macro.panic.html\n //! [`Builder`]: ../../std/thread/struct.Builder.html\n //! [`thread::current`]: ../../std/thread/fn.current.html\n+//! [`thread::Result`]: ../../std/thread/type.Result.html\n //! [`Thread`]: ../../std/thread/struct.Thread.html\n //! [`park`]: ../../std/thread/fn.park.html\n //! [`unpark`]: ../../std/thread/struct.Thread.html#method.unpark\n@@ -457,6 +458,16 @@ pub fn yield_now() {\n \n /// Determines whether the current thread is unwinding because of panic.\n ///\n+/// A common use of this feature is to poison shared resources when writing\n+/// unsafe code, by checking `panicking` when the `drop` is called.\n+///\n+/// This is usually not needed when writing safe code, as [`Mutex`es][Mutex]\n+/// already poison themselves when a thread panics while holding the lock.\n+///\n+/// This can also be used in multithreaded applications, in order to send a\n+/// message to other threads warning that a thread has panicked (e.g. for\n+/// monitoring purposes).\n+///\n /// # Examples\n ///\n /// ```should_panic\n@@ -485,6 +496,8 @@ pub fn yield_now() {\n ///     panic!()\n /// }\n /// ```\n+///\n+/// [Mutex]: ../../std/sync/struct.Mutex.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn panicking() -> bool {\n@@ -715,21 +728,34 @@ struct Inner {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n /// A handle to a thread.\n ///\n-/// # Examples\n-///\n-/// ```\n-/// use std::thread;\n+/// You can use it to identify a thread (by name, for example). Most of the\n+/// time, there is no need to directly create a `Thread` struct using the\n+/// constructor, instead you should use a function like `spawn` to create\n+/// new threads, see the docs of [`Builder`] and [`spawn`] for more.\n ///\n-/// let handler = thread::Builder::new()\n-///     .name(\"foo\".into())\n-///     .spawn(|| {\n-///         let thread = thread::current();\n-///         println!(\"thread name: {}\", thread.name().unwrap());\n-///     })\n-///     .unwrap();\n+/// # Examples\n ///\n-/// handler.join().unwrap();\n+/// ```no_run\n+/// # // Note that this example isn't executed by default because it causes\n+/// # // deadlocks on Windows unfortunately (see #25824)\n+/// use std::thread::Builder;\n+///\n+/// for i in 0..5 {\n+///     let thread_name = format!(\"thread_{}\", i);\n+///     Builder::new()\n+///         .name(thread_name) // Now you can identify which thread panicked\n+///                            // thanks to the handle's name\n+///         .spawn(move || {\n+///             if i == 3 {\n+///                  panic!(\"I'm scared!!!\");\n+///             }\n+///         })\n+///         .unwrap();\n+/// }\n /// ```\n+/// [`Builder`]: ../../std/thread/struct.Builder.html\n+/// [`spawn`]: ../../std/thread/fn.spawn.html\n+\n pub struct Thread {\n     inner: Arc<Inner>,\n }\n@@ -851,9 +877,31 @@ impl fmt::Debug for Thread {\n // JoinHandle\n ////////////////////////////////////////////////////////////////////////////////\n \n+/// A specialized [`Result`] type for threads.\n+///\n /// Indicates the manner in which a thread exited.\n ///\n /// A thread that completes without panicking is considered to exit successfully.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+/// use std::fs;\n+///\n+/// fn copy_in_thread() -> thread::Result<()> {\n+///     thread::spawn(move || { fs::copy(\"foo.txt\", \"bar.txt\").unwrap(); }).join()\n+/// }\n+///\n+/// fn main() {\n+///     match copy_in_thread() {\n+///         Ok(_) => println!(\"this is fine\"),\n+///         Err(_) => println!(\"thread panicked\"),\n+///     }\n+/// }\n+/// ```\n+///\n+/// [`Result`]: ../../std/result/enum.Result.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type Result<T> = ::result::Result<T, Box<Any + Send + 'static>>;\n "}, {"sha": "55766ba3fed6a70660f53d4949e689d627ce7d80", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -84,7 +84,10 @@ impl Duration {\n     /// ```\n     /// use std::time::Duration;\n     ///\n-    /// let five_seconds = Duration::from_secs(5);\n+    /// let duration = Duration::from_secs(5);\n+    ///\n+    /// assert_eq!(5, duration.as_secs());\n+    /// assert_eq!(0, duration.subsec_nanos());\n     /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n@@ -99,7 +102,10 @@ impl Duration {\n     /// ```\n     /// use std::time::Duration;\n     ///\n-    /// let five_seconds = Duration::from_millis(5000);\n+    /// let duration = Duration::from_millis(2569);\n+    ///\n+    /// assert_eq!(2, duration.as_secs());\n+    /// assert_eq!(569000000, duration.subsec_nanos());\n     /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n@@ -119,9 +125,24 @@ impl Duration {\n     /// ```\n     /// use std::time::Duration;\n     ///\n-    /// let five_seconds = Duration::new(5, 0);\n-    /// assert_eq!(five_seconds.as_secs(), 5);\n+    /// let duration = Duration::new(5, 730023852);\n+    /// assert_eq!(duration.as_secs(), 5);\n+    /// ```\n+    ///\n+    /// To determine the total number of seconds represented by the `Duration`,\n+    /// use `as_secs` in combination with [`subsec_nanos`]:\n+    ///\n     /// ```\n+    /// use std::time::Duration;\n+    ///\n+    /// let duration = Duration::new(5, 730023852);\n+    ///\n+    /// assert_eq!(5.730023852,\n+    ///            duration.as_secs() as f64\n+    ///            + duration.subsec_nanos() as f64 * 1e-9);\n+    /// ```\n+    ///\n+    /// [`subsec_nanos`]: #method.subsec_nanos\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub fn as_secs(&self) -> u64 { self.secs }"}, {"sha": "7173040350ed96840428f5a180a00b2743e7e6bc", "filename": "src/libstd_unicode/tables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Ftables.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n+// NOTE: The following code was generated by \"./unicode.py\", do not edit directly\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n "}, {"sha": "5f9def02c7d1172e51c2cb441abe972d29cb3670", "filename": "src/libstd_unicode/unicode.py", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd_unicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibstd_unicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Funicode.py?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -35,7 +35,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n+// NOTE: The following code was generated by \"./unicode.py\", do not edit directly\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n '''", "previous_filename": "src/etc/unicode.py"}, {"sha": "82e7cfa0032ce5ed9221e12b4f9610857260ab92", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -11,7 +11,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n serialize = { path = \"../libserialize\" }\n log = \"0.3\"\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n+bitflags = \"0.8\"\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "0980b73e80c5c5d8125973de01fb8586db045b2d", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -511,8 +511,7 @@ pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Symb\n             } else {\n                 struct_span_err!(diag, attr.span, E0558,\n                                  \"export_name attribute has invalid format\")\n-                    .span_label(attr.span,\n-                                &format!(\"did you mean #[export_name=\\\"*\\\"]?\"))\n+                    .span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n                     .emit();\n                 None\n             }"}, {"sha": "0c8be1d4f24591822ab0686d3851a912b5c8b457", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -21,8 +21,8 @@ pub use syntax_pos::*;\n pub use syntax_pos::hygiene::{ExpnFormat, ExpnInfo, NameAndSpan};\n pub use self::ExpnFormat::*;\n \n-use std::cell::RefCell;\n-use std::path::{Path,PathBuf};\n+use std::cell::{RefCell, Ref};\n+use std::path::{Path, PathBuf};\n use std::rc::Rc;\n \n use std::env;\n@@ -103,11 +103,18 @@ impl FileLoader for RealFileLoader {\n //\n \n pub struct CodeMap {\n-    pub files: RefCell<Vec<Rc<FileMap>>>,\n+    // The `files` field should not be visible outside of libsyntax so that we\n+    // can do proper dependency tracking.\n+    pub(super) files: RefCell<Vec<Rc<FileMap>>>,\n     file_loader: Box<FileLoader>,\n     // This is used to apply the file path remapping as specified via\n     // -Zremap-path-prefix to all FileMaps allocated within this CodeMap.\n     path_mapping: FilePathMapping,\n+    // The CodeMap will invoke this callback whenever a specific FileMap is\n+    // accessed. The callback starts out as a no-op but when the dependency\n+    // graph becomes available later during the compilation process, it is\n+    // be replaced with something that notifies the dep-tracking system.\n+    dep_tracking_callback: RefCell<Box<Fn(&FileMap)>>,\n }\n \n impl CodeMap {\n@@ -116,6 +123,7 @@ impl CodeMap {\n             files: RefCell::new(Vec::new()),\n             file_loader: Box::new(RealFileLoader),\n             path_mapping: path_mapping,\n+            dep_tracking_callback: RefCell::new(Box::new(|_| {})),\n         }\n     }\n \n@@ -126,13 +134,18 @@ impl CodeMap {\n             files: RefCell::new(Vec::new()),\n             file_loader: file_loader,\n             path_mapping: path_mapping,\n+            dep_tracking_callback: RefCell::new(Box::new(|_| {})),\n         }\n     }\n \n     pub fn path_mapping(&self) -> &FilePathMapping {\n         &self.path_mapping\n     }\n \n+    pub fn set_dep_tracking_callback(&self, cb: Box<Fn(&FileMap)>) {\n+        *self.dep_tracking_callback.borrow_mut() = cb;\n+    }\n+\n     pub fn file_exists(&self, path: &Path) -> bool {\n         self.file_loader.file_exists(path)\n     }\n@@ -142,6 +155,19 @@ impl CodeMap {\n         Ok(self.new_filemap(path.to_str().unwrap().to_string(), src))\n     }\n \n+    pub fn files(&self) -> Ref<Vec<Rc<FileMap>>> {\n+        let files = self.files.borrow();\n+        for file in files.iter() {\n+            (self.dep_tracking_callback.borrow())(file);\n+        }\n+        files\n+    }\n+\n+    /// Only use this if you do your own dependency tracking!\n+    pub fn files_untracked(&self) -> Ref<Vec<Rc<FileMap>>> {\n+        self.files.borrow()\n+    }\n+\n     fn next_start_pos(&self) -> usize {\n         let files = self.files.borrow();\n         match files.last() {\n@@ -170,6 +196,7 @@ impl CodeMap {\n         let filemap = Rc::new(FileMap {\n             name: filename,\n             name_was_remapped: was_remapped,\n+            crate_of_origin: 0,\n             src: Some(Rc::new(src)),\n             start_pos: Pos::from_usize(start_pos),\n             end_pos: Pos::from_usize(end_pos),\n@@ -204,6 +231,7 @@ impl CodeMap {\n     pub fn new_imported_filemap(&self,\n                                 filename: FileName,\n                                 name_was_remapped: bool,\n+                                crate_of_origin: u32,\n                                 source_len: usize,\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>)\n@@ -225,6 +253,7 @@ impl CodeMap {\n         let filemap = Rc::new(FileMap {\n             name: filename,\n             name_was_remapped: name_was_remapped,\n+            crate_of_origin: crate_of_origin,\n             src: None,\n             start_pos: start_pos,\n             end_pos: end_pos,\n@@ -282,6 +311,8 @@ impl CodeMap {\n         let files = self.files.borrow();\n         let f = (*files)[idx].clone();\n \n+        (self.dep_tracking_callback.borrow())(&f);\n+\n         match f.lookup_line(pos) {\n             Some(line) => Ok(FileMapAndLine { fm: f, line: line }),\n             None => Err(f)\n@@ -471,6 +502,7 @@ impl CodeMap {\n     pub fn get_filemap(&self, filename: &str) -> Option<Rc<FileMap>> {\n         for fm in self.files.borrow().iter() {\n             if filename == fm.name {\n+               (self.dep_tracking_callback.borrow())(&fm);\n                 return Some(fm.clone());\n             }\n         }\n@@ -481,6 +513,7 @@ impl CodeMap {\n     pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let fm = (*self.files.borrow())[idx].clone();\n+        (self.dep_tracking_callback.borrow())(&fm);\n         let offset = bpos - fm.start_pos;\n         FileMapAndBytePos {fm: fm, pos: offset}\n     }\n@@ -491,6 +524,8 @@ impl CodeMap {\n         let files = self.files.borrow();\n         let map = &(*files)[idx];\n \n+        (self.dep_tracking_callback.borrow())(map);\n+\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n@@ -536,7 +571,7 @@ impl CodeMap {\n     }\n \n     pub fn count_lines(&self) -> usize {\n-        self.files.borrow().iter().fold(0, |a, f| a + f.count_lines())\n+        self.files().iter().fold(0, |a, f| a + f.count_lines())\n     }\n }\n "}, {"sha": "f731c5abdd6a1f7e0ad275f45460e047e1f5779f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -24,6 +24,7 @@ use ptr::P;\n use symbol::Symbol;\n use util::small_vector::SmallVector;\n \n+use std::collections::HashMap;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::default::Default;\n@@ -643,6 +644,7 @@ pub struct ExtCtxt<'a> {\n     pub resolver: &'a mut Resolver,\n     pub resolve_err_count: usize,\n     pub current_expansion: ExpansionData,\n+    pub expansions: HashMap<Span, Vec<String>>,\n }\n \n impl<'a> ExtCtxt<'a> {\n@@ -662,6 +664,7 @@ impl<'a> ExtCtxt<'a> {\n                 module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n                 directory_ownership: DirectoryOwnership::Owned,\n             },\n+            expansions: HashMap::new(),\n         }\n     }\n \n@@ -765,6 +768,15 @@ impl<'a> ExtCtxt<'a> {\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.parse_sess.span_diagnostic.span_bug(sp, msg);\n     }\n+    pub fn trace_macros_diag(&self) {\n+        for (sp, notes) in self.expansions.iter() {\n+            let mut db = self.parse_sess.span_diagnostic.span_note_diag(*sp, &\"trace_macro\");\n+            for note in notes {\n+                db.note(&note);\n+            }\n+            db.emit();\n+        }\n+    }\n     pub fn bug(&self, msg: &str) -> ! {\n         self.parse_sess.span_diagnostic.bug(msg);\n     }"}, {"sha": "a8aa103f80a8e4a7c0f150d59ebfd2a427cd7517", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             },\n             _ => unreachable!(),\n         };\n-\n+        self.cx.trace_macros_diag();\n         krate\n     }\n \n@@ -1038,7 +1038,7 @@ impl<'feat> ExpansionConfig<'feat> {\n         ExpansionConfig {\n             crate_name: crate_name,\n             features: None,\n-            recursion_limit: 64,\n+            recursion_limit: 1024,\n             trace_mac: false,\n             should_test: false,\n             single_step: false,"}, {"sha": "f959ccc989e2e9e9d55643966f0fe4648b8bd17b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -27,8 +27,8 @@ use symbol::Symbol;\n use tokenstream::{TokenStream, TokenTree};\n \n use std::cell::RefCell;\n-use std::collections::{HashMap};\n-use std::collections::hash_map::{Entry};\n+use std::collections::HashMap;\n+use std::collections::hash_map::Entry;\n use std::rc::Rc;\n \n pub struct ParserAnyMacro<'a> {\n@@ -85,15 +85,17 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n }\n \n /// Given `lhses` and `rhses`, this is the new macro we create\n-fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n+fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n                           sp: Span,\n                           name: ast::Ident,\n                           arg: TokenStream,\n                           lhses: &[quoted::TokenTree],\n                           rhses: &[quoted::TokenTree])\n                           -> Box<MacResult+'cx> {\n     if cx.trace_macros() {\n-        println!(\"{}! {{ {} }}\", name, arg);\n+        let sp = sp.macro_backtrace().last().map(|trace| trace.call_site).unwrap_or(sp);\n+        let mut values: &mut Vec<String> = cx.expansions.entry(sp).or_insert(vec![]);\n+        values.push(format!(\"expands to `{}! {{ {} }}`\", name, arg));\n     }\n \n     // Which arm's failure should we report? (the one furthest along)"}, {"sha": "89c67b88cbde6dccaa7c0006cefc9152aac9a747", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -24,20 +24,15 @@\n        test(attr(deny(warnings))))]\n #![deny(warnings)]\n \n-#![feature(associated_consts)]\n-#![feature(const_fn)]\n-#![feature(optin_builtin_traits)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(str_escape)]\n #![feature(unicode)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(specialization)]\n #![feature(i128_type)]\n \n extern crate serialize;\n #[macro_use] extern crate log;\n-#[macro_use] #[no_link] extern crate rustc_bitflags;\n+#[macro_use] extern crate bitflags;\n extern crate std_unicode;\n pub extern crate rustc_errors as errors;\n extern crate syntax_pos;"}, {"sha": "ded1f0b599a61d6ba5bd6ae274f15d625d0979a6", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -73,7 +73,7 @@ fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n }\n \n impl<'a> StringReader<'a> {\n-    fn next_token(&mut self) -> TokenAndSpan where Self: Sized {\n+    fn next_token(&mut self) -> TokenAndSpan {\n         let res = self.try_next_token();\n         self.unwrap_or_abort(res)\n     }\n@@ -504,7 +504,7 @@ impl<'a> StringReader<'a> {\n                     self.bump();\n \n                     // line comments starting with \"///\" or \"//!\" are doc-comments\n-                    let doc_comment = self.ch_is('/') || self.ch_is('!');\n+                    let doc_comment = (self.ch_is('/') && !self.nextch_is('/')) || self.ch_is('!');\n                     let start_bpos = self.pos - BytePos(2);\n \n                     while !self.is_eof() {"}, {"sha": "fe3ca1cf2305c0341ae3fb50db3616cb0e581c1b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -261,10 +261,14 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n     }\n }\n \n+pub fn escape_default(s: &str) -> String {\n+    s.chars().map(char::escape_default).flat_map(|x| x).collect()\n+}\n+\n /// Parse a string representing a string literal into its final form. Does\n /// unescaping.\n pub fn str_lit(lit: &str) -> String {\n-    debug!(\"parse_str_lit: given {}\", lit.escape_default());\n+    debug!(\"parse_str_lit: given {}\", escape_default(lit));\n     let mut res = String::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n@@ -339,7 +343,7 @@ pub fn str_lit(lit: &str) -> String {\n /// Parse a string representing a raw string literal into its final form. The\n /// only operation this does is convert embedded CRLF into a single LF.\n pub fn raw_str_lit(lit: &str) -> String {\n-    debug!(\"raw_str_lit: given {}\", lit.escape_default());\n+    debug!(\"raw_str_lit: given {}\", escape_default(lit));\n     let mut res = String::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator"}, {"sha": "ca1351e3b4158c89793b06bd622f4e54f22aad99", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -64,7 +64,7 @@ use std::path::{self, Path, PathBuf};\n use std::slice;\n \n bitflags! {\n-    flags Restrictions: u8 {\n+    pub flags Restrictions: u8 {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n         const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n     }\n@@ -602,10 +602,10 @@ impl<'a> Parser<'a> {\n                 label_sp\n             };\n             if self.span.contains(sp) {\n-                err.span_label(self.span, &label_exp);\n+                err.span_label(self.span, label_exp);\n             } else {\n-                err.span_label(sp, &label_exp);\n-                err.span_label(self.span, &\"unexpected token\");\n+                err.span_label(sp, label_exp);\n+                err.span_label(self.span, \"unexpected token\");\n             }\n             Err(err)\n         }\n@@ -1512,10 +1512,10 @@ impl<'a> Parser<'a> {\n                 err.span_suggestion(sum_span, \"try adding parentheses:\", sum_with_parens);\n             }\n             TyKind::Ptr(..) | TyKind::BareFn(..) => {\n-                err.span_label(sum_span, &\"perhaps you forgot parentheses?\");\n+                err.span_label(sum_span, \"perhaps you forgot parentheses?\");\n             }\n             _ => {\n-                err.span_label(sum_span, &\"expected a path\");\n+                err.span_label(sum_span, \"expected a path\");\n             },\n         }\n         err.emit();\n@@ -2291,7 +2291,7 @@ impl<'a> Parser<'a> {\n                     let e = if self.token.can_begin_expr()\n                                && !(self.token == token::OpenDelim(token::Brace)\n                                     && self.restrictions.contains(\n-                                           Restrictions::RESTRICTION_NO_STRUCT_LITERAL)) {\n+                                           RESTRICTION_NO_STRUCT_LITERAL)) {\n                         Some(self.parse_expr()?)\n                     } else {\n                         None\n@@ -2318,7 +2318,7 @@ impl<'a> Parser<'a> {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n                         let prohibited = self.restrictions.contains(\n-                            Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n+                            RESTRICTION_NO_STRUCT_LITERAL\n                         );\n                         if !prohibited {\n                             return self.parse_struct_expr(lo, pth, attrs);\n@@ -2556,7 +2556,7 @@ impl<'a> Parser<'a> {\n                     let fstr = n.as_str();\n                     let mut err = self.diagnostic().struct_span_err(self.prev_span,\n                         &format!(\"unexpected token: `{}`\", n));\n-                    err.span_label(self.prev_span, &\"unexpected token\");\n+                    err.span_label(self.prev_span, \"unexpected token\");\n                     if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,\n@@ -2700,6 +2700,19 @@ impl<'a> Parser<'a> {\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 (span, self.mk_unary(UnOp::Not, e))\n             }\n+            // Suggest `!` for bitwise negation when encountering a `~`\n+            token::Tilde => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                let span_of_tilde = lo;\n+                let mut err = self.diagnostic().struct_span_err(span_of_tilde,\n+                        \"`~` can not be used as a unary operator\");\n+                err.span_label(span_of_tilde, \"did you mean `!`?\");\n+                err.help(\"use `!` instead of `~` if you meant to perform bitwise negation\");\n+                err.emit();\n+                (span, self.mk_unary(UnOp::Not, e))\n+            }\n             token::BinOp(token::Minus) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n@@ -2722,7 +2735,7 @@ impl<'a> Parser<'a> {\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 self.bump();\n                 let place = self.parse_expr_res(\n-                    Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n+                    RESTRICTION_NO_STRUCT_LITERAL,\n                     None,\n                 )?;\n                 let blk = self.parse_block()?;\n@@ -2785,7 +2798,7 @@ impl<'a> Parser<'a> {\n \n             let cur_op_span = self.span;\n             let restrictions = if op.is_assign_like() {\n-                self.restrictions & Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n+                self.restrictions & RESTRICTION_NO_STRUCT_LITERAL\n             } else {\n                 self.restrictions\n             };\n@@ -2835,21 +2848,21 @@ impl<'a> Parser<'a> {\n \n             let rhs = match op.fixity() {\n                 Fixity::Right => self.with_res(\n-                    restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n+                    restrictions - RESTRICTION_STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence(),\n                             LhsExpr::NotYetParsed)\n                 }),\n                 Fixity::Left => self.with_res(\n-                    restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n+                    restrictions - RESTRICTION_STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence() + 1,\n                             LhsExpr::NotYetParsed)\n                 }),\n                 // We currently have no non-associative operators that are not handled above by\n                 // the special cases. The code is here only for future convenience.\n                 Fixity::None => self.with_res(\n-                    restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n+                    restrictions - RESTRICTION_STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence() + 1,\n                             LhsExpr::NotYetParsed)\n@@ -2959,7 +2972,7 @@ impl<'a> Parser<'a> {\n         if self.token.can_begin_expr() {\n             // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n             if self.token == token::OpenDelim(token::Brace) {\n-                return !self.restrictions.contains(Restrictions::RESTRICTION_NO_STRUCT_LITERAL);\n+                return !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL);\n             }\n             true\n         } else {\n@@ -2973,7 +2986,7 @@ impl<'a> Parser<'a> {\n             return self.parse_if_let_expr(attrs);\n         }\n         let lo = self.prev_span;\n-        let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span;\n@@ -2992,7 +3005,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let (hi, els) = if self.eat_keyword(keywords::Else) {\n             let expr = self.parse_else_expr()?;\n@@ -3046,7 +3059,7 @@ impl<'a> Parser<'a> {\n \n         let pat = self.parse_pat()?;\n         self.expect_keyword(keywords::In)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n \n@@ -3061,7 +3074,7 @@ impl<'a> Parser<'a> {\n         if self.token.is_keyword(keywords::Let) {\n             return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n-        let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n@@ -3075,7 +3088,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n@@ -3105,7 +3118,7 @@ impl<'a> Parser<'a> {\n     fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_span;\n         let lo = self.prev_span;\n-        let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n+        let discriminant = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL,\n                                                None)?;\n         if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n@@ -3146,7 +3159,7 @@ impl<'a> Parser<'a> {\n             guard = Some(self.parse_expr()?);\n         }\n         self.expect(&token::FatArrow)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_STMT_EXPR, None)?;\n \n         let require_comma =\n             !classify::expr_is_simple_block(&expr)\n@@ -3727,7 +3740,7 @@ impl<'a> Parser<'a> {\n         self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n \n         // prevent `while catch {} {}`, `if catch {} {} else {}`, etc.\n-        !self.restrictions.contains(Restrictions::RESTRICTION_NO_STRUCT_LITERAL)\n+        !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL)\n     }\n \n     fn is_union_item(&self) -> bool {\n@@ -3799,7 +3812,7 @@ impl<'a> Parser<'a> {\n                     self.mk_expr(lo.to(hi), ExprKind::Path(None, pth), ThinVec::new())\n                 };\n \n-                let expr = self.with_res(Restrictions::RESTRICTION_STMT_EXPR, |this| {\n+                let expr = self.with_res(RESTRICTION_STMT_EXPR, |this| {\n                     let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n                     this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n                 })?;\n@@ -3939,7 +3952,7 @@ impl<'a> Parser<'a> {\n \n                     // Remainder are line-expr stmts.\n                     let e = self.parse_expr_res(\n-                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n+                        RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n                     Stmt {\n                         id: ast::DUMMY_NODE_ID,\n                         span: lo.to(e.span),\n@@ -3952,7 +3965,7 @@ impl<'a> Parser<'a> {\n \n     /// Is this expression a successfully-parsed statement?\n     fn expr_is_complete(&mut self, e: &Expr) -> bool {\n-        self.restrictions.contains(Restrictions::RESTRICTION_STMT_EXPR) &&\n+        self.restrictions.contains(RESTRICTION_STMT_EXPR) &&\n             !classify::expr_requires_semi_to_be_stmt(e)\n     }\n \n@@ -4779,7 +4792,7 @@ impl<'a> Parser<'a> {\n             sp,\n             &format!(\"missing `fn`, `type`, or `const` for {}-item declaration\",\n                      item_type));\n-        err.span_label(sp, &\"missing `fn`, `type`, or `const`\");\n+        err.span_label(sp, \"missing `fn`, `type`, or `const`\");\n         err\n     }\n "}, {"sha": "0c7e8fda83766cbdbc8f4f0df87c1e42b5f9c523", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -677,7 +677,7 @@ pub trait PrintState<'a> {\n                     style: ast::StrStyle) -> io::Result<()> {\n         let st = match style {\n             ast::StrStyle::Cooked => {\n-                (format!(\"\\\"{}\\\"\", st.escape_default()))\n+                (format!(\"\\\"{}\\\"\", parse::escape_default(st)))\n             }\n             ast::StrStyle::Raw(n) => {\n                 (format!(\"r{delim}\\\"{string}\\\"{delim}\","}, {"sha": "91746a2edd9b2a62abc70b84d7647ce277b5174a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -442,7 +442,7 @@ We're going to be building a module that looks more or less like:\n mod __test {\n   extern crate test (name = \"test\", vers = \"...\");\n   fn main() {\n-    test::test_main_static(&::os::args()[], tests)\n+    test::test_main_static(&::os::args()[], tests, test::Options::new())\n   }\n \n   static tests : &'static [test::TestDescAndFn] = &[\n@@ -478,7 +478,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     //        pub fn main() {\n     //            #![main]\n     //            use std::slice::AsSlice;\n-    //            test::test_main_static(::std::os::args().as_slice(), TESTS);\n+    //            test::test_main_static(::std::os::args().as_slice(), TESTS, test::Options::new());\n     //        }\n \n     let sp = ignored_span(cx, DUMMY_SP);"}, {"sha": "eb86a8e13797b1107a79716342f4c4cecf94b524", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -377,6 +377,8 @@ pub struct FileMap {\n     pub name: FileName,\n     /// True if the `name` field above has been modified by -Zremap-path-prefix\n     pub name_was_remapped: bool,\n+    /// Indicates which crate this FileMap was imported from.\n+    pub crate_of_origin: u32,\n     /// The complete source code\n     pub src: Option<Rc<String>>,\n     /// The start position of this source in the CodeMap\n@@ -491,6 +493,10 @@ impl Decodable for FileMap {\n             Ok(FileMap {\n                 name: name,\n                 name_was_remapped: name_was_remapped,\n+                // `crate_of_origin` has to be set by the importer.\n+                // This value matches up with rustc::hir::def_id::INVALID_CRATE.\n+                // That constant is not available here unfortunately :(\n+                crate_of_origin: ::std::u32::MAX - 1,\n                 start_pos: start_pos,\n                 end_pos: end_pos,\n                 src: None,"}, {"sha": "35f2fbca69f8df2613da9e0ca38174e7002459a9", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 68, "deletions": 6, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -76,7 +76,7 @@ pub mod test {\n     pub use {Bencher, TestName, TestResult, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n              TrFailedMsg, TrIgnored, TrOk, Metric, MetricMap, StaticTestFn, StaticTestName,\n              DynTestName, DynTestFn, run_test, test_main, test_main_static, filter_tests,\n-             parse_opts, StaticBenchFn, ShouldPanic};\n+             parse_opts, StaticBenchFn, ShouldPanic, Options};\n }\n \n pub mod stats;\n@@ -252,14 +252,34 @@ impl Clone for MetricMap {\n     }\n }\n \n+/// In case we want to add other options as well, just add them in this struct.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Options {\n+    display_output: bool,\n+}\n+\n+impl Options {\n+    pub fn new() -> Options {\n+        Options {\n+            display_output: false,\n+        }\n+    }\n+\n+    pub fn display_output(mut self, display_output: bool) -> Options {\n+        self.display_output = display_output;\n+        self\n+    }\n+}\n+\n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n-pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>) {\n-    let opts = match parse_opts(args) {\n+pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n+    let mut opts = match parse_opts(args) {\n         Some(Ok(o)) => o,\n         Some(Err(msg)) => panic!(\"{:?}\", msg),\n         None => return,\n     };\n+    opts.options = options;\n     if opts.list {\n         if let Err(e) = list_tests_console(&opts, tests) {\n             panic!(\"io error when listing tests: {:?}\", e);\n@@ -301,16 +321,17 @@ pub fn test_main_static(tests: &[TestDescAndFn]) {\n                                }\n                            })\n                            .collect();\n-    test_main(&args, owned_tests)\n+    test_main(&args, owned_tests, Options::new())\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum ColorConfig {\n     AutoColor,\n     AlwaysColor,\n     NeverColor,\n }\n \n+#[derive(Debug)]\n pub struct TestOpts {\n     pub list: bool,\n     pub filter: Option<String>,\n@@ -324,6 +345,7 @@ pub struct TestOpts {\n     pub quiet: bool,\n     pub test_threads: Option<usize>,\n     pub skip: Vec<String>,\n+    pub options: Options,\n }\n \n impl TestOpts {\n@@ -342,6 +364,7 @@ impl TestOpts {\n             quiet: false,\n             test_threads: None,\n             skip: vec![],\n+            options: Options::new(),\n         }\n     }\n }\n@@ -481,6 +504,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         quiet: quiet,\n         test_threads: test_threads,\n         skip: matches.opt_strs(\"skip\"),\n+        options: Options::new(),\n     };\n \n     Some(Ok(test_opts))\n@@ -521,7 +545,9 @@ struct ConsoleTestState<T> {\n     measured: usize,\n     metrics: MetricMap,\n     failures: Vec<(TestDesc, Vec<u8>)>,\n+    not_failures: Vec<(TestDesc, Vec<u8>)>,\n     max_name_len: usize, // number of columns to fill when aligning names\n+    options: Options,\n }\n \n impl<T: Write> ConsoleTestState<T> {\n@@ -547,7 +573,9 @@ impl<T: Write> ConsoleTestState<T> {\n             measured: 0,\n             metrics: MetricMap::new(),\n             failures: Vec::new(),\n+            not_failures: Vec::new(),\n             max_name_len: 0,\n+            options: opts.options,\n         })\n     }\n \n@@ -703,9 +731,38 @@ impl<T: Write> ConsoleTestState<T> {\n         Ok(())\n     }\n \n+    pub fn write_outputs(&mut self) -> io::Result<()> {\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        let mut successes = Vec::new();\n+        let mut stdouts = String::new();\n+        for &(ref f, ref stdout) in &self.not_failures {\n+            successes.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                stdouts.push_str(&output);\n+                stdouts.push_str(\"\\n\");\n+            }\n+        }\n+        if !stdouts.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&stdouts)?;\n+        }\n+\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        successes.sort();\n+        for name in &successes {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n     pub fn write_run_finish(&mut self) -> io::Result<bool> {\n         assert!(self.passed + self.failed + self.ignored + self.measured == self.total);\n \n+        if self.options.display_output {\n+            self.write_outputs()?;\n+        }\n         let success = self.failed == 0;\n         if !success {\n             self.write_failures()?;\n@@ -824,7 +881,10 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n                 st.write_log_result(&test, &result)?;\n                 st.write_result(&result)?;\n                 match result {\n-                    TrOk => st.passed += 1,\n+                    TrOk => {\n+                        st.passed += 1;\n+                        st.not_failures.push((test, stdout));\n+                    }\n                     TrIgnored => st.ignored += 1,\n                     TrMetrics(mm) => {\n                         let tname = test.name;\n@@ -901,6 +961,8 @@ fn should_sort_failures_before_printing_them() {\n         max_name_len: 10,\n         metrics: MetricMap::new(),\n         failures: vec![(test_b, Vec::new()), (test_a, Vec::new())],\n+        options: Options::new(),\n+        not_failures: Vec::new(),\n     };\n \n     st.write_failures().unwrap();"}, {"sha": "cf85b5a8da7853c4de5cc57766da8b7988c06461", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -1 +1 @@\n-Subproject commit 15745af7683844e43bdec966072b8e7b44772450\n+Subproject commit cf85b5a8da7853c4de5cc57766da8b7988c06461"}, {"sha": "2e6417f6af5218a29a8ee72ed17af085560b9b9c", "filename": "src/rust-installer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frust-installer?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -1 +1 @@\n-Subproject commit 4f994850808a572e2cc8d43f968893c8e942e9bf\n+Subproject commit 2e6417f6af5218a29a8ee72ed17af085560b9b9c"}, {"sha": "d73d1c25e5bdb6ec1cc14b9acef626db7e433145", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2017-04-26\n+2017-05-06"}, {"sha": "10c99703a97ff8dac71a52a61c3d8853a80c2acc", "filename": "src/test/compile-fail/closure-no-fn-1.rs", "status": "renamed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-1.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -15,10 +15,4 @@ fn main() {\n     let mut a = 0u8;\n     let foo: fn(u8) -> u8 = |v: u8| { a += v; a };\n     //~^ ERROR mismatched types\n-    let b = 0u8;\n-    let bar: fn() -> u8 = || { b };\n-    //~^ ERROR mismatched types\n-    let baz: fn() -> u8 = || { b } as fn() -> u8;\n-    //~^ ERROR mismatched types\n-    //~^^ ERROR non-scalar cast\n }", "previous_filename": "src/test/compile-fail/closure-no-fn.rs"}, {"sha": "a6438bb5f241847845d31fffc4a120f28a415858", "filename": "src/test/compile-fail/closure-no-fn-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-2.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that capturing closures are never coerced to fns\n+// Especially interesting as non-capturing closures can be.\n+\n+fn main() {\n+    let b = 0u8;\n+    let bar: fn() -> u8 = || { b };\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "85dbc899208f6f95e7b3c8096a4122d0982355f8", "filename": "src/test/compile-fail/closure-no-fn-3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-3.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that capturing closures are never coerced to fns\n+// Especially interesting as non-capturing closures can be.\n+\n+fn main() {\n+    let b = 0u8;\n+    let baz: fn() -> u8 = (|| { b }) as fn() -> u8;\n+    //~^ ERROR non-scalar cast\n+}"}, {"sha": "3f568194e23d8071fc9bd67c7fe05d1f2120d02f", "filename": "src/test/compile-fail/dep-graph-struct-signature.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -58,13 +58,15 @@ mod signatures {\n         fn method(&self, x: u32) { }\n     }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n     struct WillChanges {\n+        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n         x: WillChange,\n+        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n         y: WillChange\n     }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    // The fields change, not the type itself.\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n     fn indirect(x: WillChanges) { }\n }\n "}, {"sha": "56636a00a313a26afb911c4cce8f3a32d517d709", "filename": "src/test/compile-fail/dep-graph-type-alias.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -23,15 +23,21 @@ fn main() { }\n #[rustc_if_this_changed]\n type TypeAlias = u32;\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+// The type alias directly affects the type of the field,\n+// not the enclosing struct:\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n struct Struct {\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n     x: TypeAlias,\n     y: u32\n }\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n enum Enum {\n-    Variant1(TypeAlias),\n+    Variant1 {\n+        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+        t: TypeAlias\n+    },\n     Variant2(i32)\n }\n "}, {"sha": "9b621a13fc484b7200b44c96a81294ab127664bd", "filename": "src/test/compile-fail/dep-graph-variance-alias.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that changing what a `type` points to does not go unnoticed\n+// by the variance analysis.\n+\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+fn main() { }\n+\n+struct Foo<T> {\n+    f: T\n+}\n+\n+#[rustc_if_this_changed]\n+type TypeAlias<T> = Foo<T>;\n+\n+#[rustc_then_this_would_need(ItemVariances)] //~ ERROR OK\n+struct Use<T> {\n+    x: TypeAlias<T>\n+}"}, {"sha": "7ca6d9301a689349dd12362f1cd55184b1385003", "filename": "src/test/compile-fail/issue-3008-1.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -8,9 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum foo { foo_(bar) }\n-enum bar { bar_none, bar_some(bar) }\n-//~^ ERROR recursive type `bar` has infinite size\n+enum Foo {\n+    Foo_(Bar)\n+}\n+\n+enum Bar {\n+    //~^ ERROR recursive type `Bar` has infinite size\n+    //~| NOTE recursive type has infinite size\n+    BarNone,\n+    BarSome(Bar)  //~ NOTE recursive without indirection\n+}\n \n fn main() {\n }"}, {"sha": "061d1facda0ca7cf13232e389b8e89b775a5824d", "filename": "src/test/compile-fail/issue-3008-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -12,6 +12,7 @@ enum foo { foo_(bar) }\n struct bar { x: bar }\n //~^ ERROR E0072\n //~| NOTE recursive type has infinite size\n+//~| NOTE recursive without indirection\n \n fn main() {\n }"}, {"sha": "70a7cd8b9702128acfaaf0e373c5c9fcbc0cb95e", "filename": "src/test/compile-fail/issue-32326.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -15,6 +15,8 @@\n enum Expr { //~ ERROR E0072\n             //~| NOTE recursive type has infinite size\n     Plus(Expr, Expr),\n+    //~^ NOTE recursive without indirection\n+    //~| NOTE recursive without indirection\n     Literal(i64),\n }\n "}, {"sha": "10f73dc086288aed40084f0bb3e441dc20a33f60", "filename": "src/test/compile-fail/issue-3779.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S { //~ ERROR E0072\n-           //~| NOTE recursive type has infinite size\n+struct S {\n+    //~^ ERROR E0072\n+    //~| NOTE recursive type has infinite size\n     element: Option<S>\n+    //~^ NOTE recursive without indirection\n }\n \n fn main() {"}, {"sha": "3ccee0f12becb63e1f84cf4bd89be3109253a3c5", "filename": "src/test/compile-fail/issue-40000.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-40000.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-40000.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40000.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -11,8 +11,7 @@\n #![feature(closure_to_fn_coercion)]\n \n fn main() {\n-    let bar: fn(&mut u32) = |_| {}; //~ ERROR mismatched types\n-    //~| expected concrete lifetime, found bound lifetime parameter\n+    let bar: fn(&mut u32) = |_| {};\n \n     fn foo(x: Box<Fn(&i32)>) {}\n     let bar = Box::new(|x: &i32| {}) as Box<Fn(_)>;"}, {"sha": "a4585f7bac7da535adaa7729a3f1a1c25b8d89a0", "filename": "src/test/compile-fail/issue-41255.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Matching against float literals should result in a linter error\n+\n+#![feature(slice_patterns)]\n+#![feature(exclusive_range_pattern)]\n+#![allow(unused)]\n+#![forbid(illegal_floating_point_literal_pattern)]\n+\n+fn main() {\n+    let x = 42.0;\n+    match x {\n+        5.0 => {}, //~ ERROR floating-point literals cannot be used\n+                   //~| WARNING hard error\n+        5.0f32 => {}, //~ ERROR floating-point literals cannot be used\n+                      //~| WARNING hard error\n+        -5.0 => {}, //~ ERROR floating-point literals cannot be used\n+                    //~| WARNING hard error\n+        1.0 .. 33.0 => {}, //~ ERROR floating-point literals cannot be used\n+                           //~| WARNING hard error\n+                           //~| ERROR floating-point literals cannot be used\n+                           //~| WARNING hard error\n+        39.0 ... 70.0 => {}, //~ ERROR floating-point literals cannot be used\n+                             //~| WARNING hard error\n+                             //~| ERROR floating-point literals cannot be used\n+                             //~| WARNING hard error\n+        _ => {},\n+    };\n+    let y = 5.0;\n+    // Same for tuples\n+    match (x, 5) {\n+        (3.14, 1) => {}, //~ ERROR floating-point literals cannot be used\n+                         //~| WARNING hard error\n+                         //~| ERROR floating-point literals cannot be used\n+                         //~| WARNING hard error\n+        _ => {},\n+    }\n+    // Or structs\n+    struct Foo { x: f32 };\n+    match (Foo { x }) {\n+        Foo { x: 2.0 } => {}, //~ ERROR floating-point literals cannot be used\n+                              //~| WARNING hard error\n+                              //~| ERROR floating-point literals cannot be used\n+                              //~| WARNING hard error\n+        _ => {},\n+    }\n+}"}, {"sha": "c8cd9209bceb4ef6ddc7e60189becf5b61c6073a", "filename": "src/test/compile-fail/issue-41726.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-41726.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-41726.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41726.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+fn main() {\n+    let things: HashMap<String, Vec<String>> = HashMap::new();\n+    for src in things.keys() {\n+        things[src.as_str()].sort(); //~ ERROR cannot borrow immutable\n+    }\n+}"}, {"sha": "067531e036ad810f0f23a1c5a9e5235e9a6302b2", "filename": "src/test/compile-fail/issue-41742.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-41742.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fissue-41742.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41742.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::{Index, IndexMut};\n+\n+struct S;\n+struct H;\n+\n+impl S {\n+    fn f(&mut self) {}\n+}\n+\n+impl Index<u32> for H {\n+    type Output = S;\n+    fn index(&self, index: u32) -> &S {\n+        unimplemented!()\n+    }\n+}\n+\n+impl IndexMut<u32> for H {\n+    fn index_mut(&mut self, index: u32) -> &mut S {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {\n+    H[\"?\"].f(); //~ ERROR mismatched types\n+}"}, {"sha": "13b62429f46930d3c67a17cc9d1bf63022ee9dd0", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(slice_patterns)]\n+#![allow(illegal_floating_point_literal_pattern)]\n \n enum t { a, b, }\n "}, {"sha": "167c8630707528d1ca5c5d0dbe922a3a615648e8", "filename": "src/test/compile-fail/regions-adjusted-lvalue-op.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fregions-adjusted-lvalue-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fregions-adjusted-lvalue-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-adjusted-lvalue-op.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that we link regions in mutable lvalue ops correctly - issue #41774\n+\n+struct Data(i32);\n+\n+trait OhNo {\n+    fn oh_no(&mut self, other: &Vec<Data>) { loop {} }\n+}\n+\n+impl OhNo for Data {}\n+impl OhNo for [Data] {}\n+\n+fn main() {\n+    let mut v = vec![Data(0)];\n+    v[0].oh_no(&v); //~ ERROR cannot borrow `v` as immutable because\n+    (*v).oh_no(&v); //~ ERROR cannot borrow `v` as immutable because\n+}"}, {"sha": "5dd76ce32c7a401ab0d47f1d674cee2fe8386154", "filename": "src/test/compile-fail/type-recursive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -11,7 +11,7 @@\n struct t1 { //~ ERROR E0072\n             //~| NOTE recursive type has infinite size\n     foo: isize,\n-    foolish: t1\n+    foolish: t1  //~ NOTE recursive without indirection\n }\n \n fn main() { }"}, {"sha": "cd047cc580f8720b2c0df3c0873a5f7c74c7fcf1", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -60,7 +60,6 @@ struct Test6<'a, 'b:'a> { //~ ERROR [-, o]\n \n #[rustc_variance]\n struct Test7<'a> { //~ ERROR [*]\n-    //~^ ERROR parameter `'a` is never used\n     x: isize\n }\n "}, {"sha": "60d4d73fe88b8845e08405d77869515eedf44c73", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -16,27 +16,23 @@\n \n #[rustc_variance]\n enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR [+, -, o, *]\n-    //~^ ERROR parameter `'d` is never used\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR [*, o, -, +]\n-    //~^ ERROR parameter `'w` is never used\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n struct Derived2<'a, 'b:'a, 'c> { //~ ERROR [o, o, *]\n-    //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n struct Derived3<'a:'b, 'b, 'c> { //~ ERROR [o, -, *]\n-    //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'b, 'a, 'c>\n }\n "}, {"sha": "58fb785c48ca7b24a70c92e2cd5c9e897b6c9230", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -30,8 +30,7 @@ struct TestStruct<U,T:Setter<U>> { //~ ERROR [+, +]\n }\n \n #[rustc_variance]\n-enum TestEnum<U,T:Setter<U>> {//~ ERROR [*, +]\n-    //~^ ERROR parameter `U` is never used\n+enum TestEnum<U,T:Setter<U>> { //~ ERROR [*, +]\n     Foo(T)\n }\n \n@@ -51,13 +50,11 @@ trait TestTrait3<U> { //~ ERROR [o, o]\n \n #[rustc_variance]\n struct TestContraStruct<U,T:Setter<U>> { //~ ERROR [*, +]\n-    //~^ ERROR parameter `U` is never used\n     t: T\n }\n \n #[rustc_variance]\n struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR [*, +]\n-    //~^ ERROR parameter `U` is never used\n     t: T\n }\n "}, {"sha": "09db90d618b69ce9af6a0361c241047cc506a7f9", "filename": "src/test/incremental/remapped_paths_cc/auxiliary/extern_crate.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// aux-build:extern_crate.rs\n+//[rpass1] compile-flags: -g\n+//[rpass2] compile-flags: -g\n+//[rpass3] compile-flags: -g -Zremap-path-prefix-from={{src-base}} -Zremap-path-prefix-to=/the/src\n+\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+#[inline(always)]\n+pub fn inline_fn() {\n+    println!(\"test\");\n+}"}, {"sha": "8a8c658acccbf2d936fe1648d65273b1682ba2ba", "filename": "src/test/incremental/remapped_paths_cc/main.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions:rpass1 rpass2 rpass3\n+// compile-flags: -Z query-dep-graph -g\n+// aux-build:extern_crate.rs\n+\n+\n+// This test case makes sure that we detect if paths emitted into debuginfo\n+// are changed, even when the change happens in an external crate.\n+\n+#![feature(rustc_attrs)]\n+\n+#![rustc_partition_reused(module=\"main\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"main-some_mod\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"main\", cfg=\"rpass3\")]\n+#![rustc_partition_translated(module=\"main-some_mod\", cfg=\"rpass3\")]\n+\n+extern crate extern_crate;\n+\n+#[rustc_clean(label=\"TransCrateItem\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"TransCrateItem\", cfg=\"rpass3\")]\n+fn main() {\n+    some_mod::some_fn();\n+}\n+\n+mod some_mod {\n+    use extern_crate;\n+\n+    #[rustc_clean(label=\"TransCrateItem\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"TransCrateItem\", cfg=\"rpass3\")]\n+    pub fn some_fn() {\n+        extern_crate::inline_fn();\n+    }\n+}"}, {"sha": "ac085d475114e6b4e08233ed03fc8a0c34b04c5a", "filename": "src/test/parse-fail/lex-bare-cr-string-literal-doc-comment.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fparse-fail%2Flex-bare-cr-string-literal-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fparse-fail%2Flex-bare-cr-string-literal-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flex-bare-cr-string-literal-doc-comment.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -21,6 +21,12 @@ pub fn bar() {}\n //~^^ ERROR: bare CR not allowed in block doc-comment\n \n fn main() {\n+    //! doc comment with bare CR: '\r'\n+    //~^ ERROR: bare CR not allowed in doc-comment\n+\n+    /*! block doc comment with bare CR: '\r' */\n+    //~^ ERROR: bare CR not allowed in block doc-comment\n+\n     // the following string literal has a bare CR in it\n     let _s = \"foo\rbar\"; //~ ERROR: bare CR not allowed in string\n "}, {"sha": "693573d53a4a27960c579a588d6b5f034707d0b8", "filename": "src/test/run-make/tools.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-make%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-make%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftools.mk?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -72,6 +72,7 @@ else\n endif\n else\n ifeq ($(UNAME),Darwin)\n+\tEXTRACFLAGS := -lresolv\n else\n ifeq ($(UNAME),FreeBSD)\n \tEXTRACFLAGS := -lm -lpthread -lgcc_s"}, {"sha": "3338e394e0ef9005687b3a785cb9b0c95077dfd8", "filename": "src/test/run-make/trace-macros-flag/Makefile", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfb740f83ca1d6f2056f5cf8de1adbe81b973438/src%2Ftest%2Frun-make%2Ftrace-macros-flag%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/dfb740f83ca1d6f2056f5cf8de1adbe81b973438/src%2Ftest%2Frun-make%2Ftrace-macros-flag%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftrace-macros-flag%2FMakefile?ref=dfb740f83ca1d6f2056f5cf8de1adbe81b973438", "patch": "@@ -1,9 +0,0 @@\n-# This test verifies that \"-Z trace-macros\"  works as it should. The traditional\n-# \"hello world\" program provides a small example of this as not only println! is\n-# listed, but also print! (since println! expands to this)\n-\n--include ../tools.mk\n-\n-all:\n-\t$(RUSTC) -Z trace-macros hello.rs > $(TMPDIR)/hello.out\n-\tdiff -u $(TMPDIR)/hello.out hello.trace"}, {"sha": "cf733339eadf63ace80afc5d60b768188bf265ed", "filename": "src/test/run-make/trace-macros-flag/hello.trace", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfb740f83ca1d6f2056f5cf8de1adbe81b973438/src%2Ftest%2Frun-make%2Ftrace-macros-flag%2Fhello.trace", "raw_url": "https://github.com/rust-lang/rust/raw/dfb740f83ca1d6f2056f5cf8de1adbe81b973438/src%2Ftest%2Frun-make%2Ftrace-macros-flag%2Fhello.trace", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftrace-macros-flag%2Fhello.trace?ref=dfb740f83ca1d6f2056f5cf8de1adbe81b973438", "patch": "@@ -1,2 +0,0 @@\n-println! { \"Hello, World!\" }\n-print! { concat ! ( \"Hello, World!\" , \"\\n\" ) }"}, {"sha": "745fbbe769e60f91d563d55f04553f48ab3b855f", "filename": "src/test/run-pass-fulldeps/auxiliary/issue_24106.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue_24106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue_24106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue_24106.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"lib\"]\n+\n+enum E { E0 = 0, E1 = 1 }\n+const E0_U8: u8 = E::E0 as u8;\n+const E1_U8: u8 = E::E1 as u8;\n+\n+pub fn go<T>() {\n+    match 0 {\n+        E0_U8 => (),\n+        E1_U8 => (),\n+        _ => (),\n+    }\n+}"}, {"sha": "7cfd11537f4e942b3e3662a352bbbea4189e0365", "filename": "src/test/run-pass-fulldeps/issue_24106.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass-fulldeps%2Fissue_24106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass-fulldeps%2Fissue_24106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue_24106.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue_24106.rs\n+\n+extern crate issue_24106;\n+\n+fn main() {\n+    issue_24106::go::<()>();\n+}"}, {"sha": "b276589f0c47b1ed0b4136853d07799664f34238", "filename": "src/test/run-pass/associated-const-type-parameters.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass%2Fassociated-const-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass%2Fassociated-const-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-type-parameters.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -27,6 +27,12 @@ impl Foo for Def {\n     const X: i32 = 97;\n }\n \n+struct Proxy<T>(T);\n+\n+impl<T: Foo> Foo for Proxy<T> {\n+    const X: i32 = T::X;\n+}\n+\n fn sub<A: Foo, B: Foo>() -> i32 {\n     A::X - B::X\n }\n@@ -38,4 +44,7 @@ fn main() {\n     assert_eq!(97, Def::get_x());\n     assert_eq!(-86, sub::<Abc, Def>());\n     assert_eq!(86, sub::<Def, Abc>());\n+    assert_eq!(-86, sub::<Proxy<Abc>, Def>());\n+    assert_eq!(-86, sub::<Abc, Proxy<Def>>());\n+    assert_eq!(86, sub::<Proxy<Def>, Proxy<Abc>>());\n }"}, {"sha": "7214ebfaf07033b67648876e7b82dddca2c6799f", "filename": "src/test/run-pass/closure_to_fn_coercion-expected-types.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass%2Fclosure_to_fn_coercion-expected-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass%2Fclosure_to_fn_coercion-expected-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure_to_fn_coercion-expected-types.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+// Ensure that we deduce expected argument types when a `fn()` type is expected (#41755)\n+\n+#![feature(closure_to_fn_coercion)]\n+fn foo(f: fn(Vec<u32>) -> usize) { }\n+\n+fn main() {\n+    foo(|x| x.len())\n+}"}, {"sha": "2817ef77108b05d9017a5984bddaf01e29cdcf98", "filename": "src/test/run-pass/issue-22066.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass%2Fissue-22066.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass%2Fissue-22066.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22066.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait LineFormatter<'a> {\n+    type Iter: Iterator<Item=&'a str> + 'a;\n+    fn iter(&'a self, line: &'a str) -> Self::Iter;\n+\n+    fn dimensions(&'a self, line: &'a str) {\n+        let iter: Self::Iter = self.iter(line);\n+        <_ as IntoIterator>::into_iter(iter);\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "d59b6a16562acbf213931a798b8a1e89d10fd19b", "filename": "src/test/run-pass/issue-41697.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass%2Fissue-41697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass%2Fissue-41697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41697.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Zdump-mir=NEVER_MATCHED\n+\n+// Regression test for #41697. Using dump-mir was triggering\n+// artificial cycles: during type-checking, we had to get the MIR for\n+// the constant expressions in `[u8; 2]`, which in turn would trigger\n+// an attempt to get the item-path, which in turn would request the\n+// types of the impl, which would trigger a cycle. We supressed this\n+// cycle now by forcing mir-dump to avoid asking for types of an impl.\n+\n+#![feature(rustc_attrs)]\n+\n+use std::sync::Arc;\n+\n+trait Foo {\n+    fn get(&self) -> [u8; 2];\n+}\n+\n+impl Foo for [u8; 2] {\n+    fn get(&self) -> [u8; 2] {\n+        *self\n+    }\n+}\n+\n+struct Bar<T: ?Sized>(T);\n+\n+fn unsize_fat_ptr<'a>(x: &'a Bar<Foo + Send + 'a>) -> &'a Bar<Foo + 'a> {\n+    x\n+}\n+\n+fn unsize_nested_fat_ptr(x: Arc<Foo + Send>) -> Arc<Foo> {\n+    x\n+}\n+\n+fn main() {\n+    let x: Box<Bar<Foo + Send>> = Box::new(Bar([1,2]));\n+    assert_eq!(unsize_fat_ptr(&*x).0.get(), [1, 2]);\n+\n+    let x: Arc<Foo + Send> = Arc::new([3, 4]);\n+    assert_eq!(unsize_nested_fat_ptr(x).get(), [3, 4]);\n+}"}, {"sha": "ba949ca88814d1f86ff295d9f5d2ec48c8d555d4", "filename": "src/test/run-pass/lex-bare-cr-nondoc-comment.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass%2Flex-bare-cr-nondoc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frun-pass%2Flex-bare-cr-nondoc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flex-bare-cr-nondoc-comment.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-cr\n+\n+// nondoc comment with bare CR: '\r'\n+//// nondoc comment with bare CR: '\r'\n+/* block nondoc comment with bare CR: '\r' */\n+\n+fn main() {\n+}"}, {"sha": "3933b8bcbb8fdf6762cacf3b3be0ff0f84b4cb5e", "filename": "src/test/rustdoc/issue-41783.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frustdoc%2Fissue-41783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Frustdoc%2Fissue-41783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-41783.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// @has issue_41783/struct.Foo.html\n+// @!has - 'space'\n+// @!has - 'comment'\n+// @has - '# <span class=\"ident\">single'\n+// @has - '#<span class=\"attribute\"># <span class=\"ident\">double</span>'\n+// @has - '#<span class=\"attribute\">#<span class=\"attribute\"># <span class=\"ident\">triple</span>'\n+\n+/// ```no_run\n+/// # # space\n+/// # comment\n+/// ## single\n+/// ### double\n+/// #### triple\n+/// ```\n+pub struct Foo;"}, {"sha": "5091b9efc34226bc796b3b8bacb60fd2f1079f2f", "filename": "src/test/ui/did_you_mean/issue-41679.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = ~1;\n+}"}, {"sha": "2abbbf65ba9b507254cef20ec002e58cf760aea5", "filename": "src/test/ui/did_you_mean/issue-41679.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-41679.stderr?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,10 @@\n+error: `~` can not be used as a unary operator\n+  --> $DIR/issue-41679.rs:12:13\n+   |\n+12 |     let x = ~1;\n+   |             ^ did you mean `!`?\n+   |\n+   = help: use `!` instead of `~` if you meant to perform bitwise negation\n+\n+error: aborting due to previous error\n+"}, {"sha": "0b714432f161578a823ccfdb17113c31321679d3", "filename": "src/test/ui/issue-41652/auxiliary/issue_41652_b.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fissue-41652%2Fauxiliary%2Fissue_41652_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fissue-41652%2Fauxiliary%2Fissue_41652_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-41652%2Fauxiliary%2Fissue_41652_b.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Tr {\n+    // Note: The function needs to be declared over multiple lines to reproduce\n+    // the crash. DO NOT reformat.\n+    fn f()\n+        where Self: Sized;\n+}"}, {"sha": "1874ee6cd3aa0ac3b64a00827677c46d338d1f7a", "filename": "src/test/ui/issue-41652/issue_41652.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fissue-41652%2Fissue_41652.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fissue-41652%2Fissue_41652.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-41652%2Fissue_41652.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue_41652_b.rs\n+\n+extern crate issue_41652_b;\n+\n+struct S;\n+\n+impl issue_41652_b::Tr for S {\n+    fn f() {\n+        3.f()\n+        //~^ ERROR no method named `f` found for type `{integer}` in the current scope\n+        //~| NOTE found the following associated functions\n+        //~| NOTE candidate #1 is defined in the trait `issue_41652_b::Tr`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4d33a99f6a38c47b37981666bd7d45df1edce3bf", "filename": "src/test/ui/issue-41652/issue_41652.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fissue-41652%2Fissue_41652.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fissue-41652%2Fissue_41652.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-41652%2Fissue_41652.stderr?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,12 @@\n+error: no method named `f` found for type `{integer}` in the current scope\n+  --> $DIR/issue_41652.rs:19:11\n+   |\n+19 |         3.f()\n+   |           ^\n+   |\n+   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n+note: candidate #1 is defined in the trait `issue_41652_b::Tr`\n+   = help: to disambiguate the method call, write `issue_41652_b::Tr::f(3)` instead\n+\n+error: aborting due to previous error\n+"}, {"sha": "34f674ae016a589b7f3eec6a00aafb11c032af0c", "filename": "src/test/ui/macros/trace-macro.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z trace-macros\n+\n fn main() {\n     println!(\"Hello, World!\");\n }", "previous_filename": "src/test/run-make/trace-macros-flag/hello.rs"}, {"sha": "09117a4ca740452e0870a1adbd7c369f545e1ec0", "filename": "src/test/ui/macros/trace-macro.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace-macro.stderr?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,9 @@\n+note: trace_macro\n+  --> $DIR/trace-macro.rs:14:5\n+   |\n+14 |     println!(\"Hello, World!\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: expands to `println! { \"Hello, World!\" }`\n+   = note: expands to `print! { concat ! ( \"Hello, World!\" , \"/n\" ) }`\n+"}, {"sha": "1f6dd6b1d165f52c9eb3f5e257ccce7dcafd4718", "filename": "src/test/ui/span/E0072.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0072.stderr?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -3,6 +3,9 @@ error[E0072]: recursive type `ListNode` has infinite size\n    |\n 11 | struct ListNode {\n    | ^^^^^^^^^^^^^^^ recursive type has infinite size\n+12 |     head: u8,\n+13 |     tail: Option<ListNode>,\n+   |     ---------------------- recursive without indirection\n    |\n    = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `ListNode` representable\n "}, {"sha": "a06cbd04deb4fb4a32bc030387426608e8a913fd", "filename": "src/test/ui/span/multiline-span-E0072.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -6,6 +6,7 @@ error[E0072]: recursive type `ListNode` has infinite size\n 14 | | {\n 15 | |     head: u8,\n 16 | |     tail: Option<ListNode>,\n+   | |     ---------------------- recursive without indirection\n 17 | | }\n    | |_^ recursive type has infinite size\n    |"}, {"sha": "6fef4d30f7a77cc21070848c97d0cd44ffb4450f", "filename": "src/test/ui/span/recursive-type-field.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+struct Foo<'a> {\n+    bar: Bar<'a>,\n+    b: Rc<Bar<'a>>,\n+}\n+\n+struct Bar<'a> {\n+    y: (Foo<'a>, Foo<'a>),\n+    z: Option<Bar<'a>>,\n+    a: &'a Foo<'a>,\n+    c: &'a [Bar<'a>],\n+    d: [Bar<'a>; 1],\n+    e: Foo<'a>,\n+    x: Bar<'a>,\n+}\n+\n+fn main() {}"}, {"sha": "b4d0b5a6a25d03557028beec40e27409ccb2b19e", "filename": "src/test/ui/span/recursive-type-field.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -0,0 +1,31 @@\n+error[E0072]: recursive type `Foo` has infinite size\n+  --> $DIR/recursive-type-field.rs:13:1\n+   |\n+13 | struct Foo<'a> {\n+   | ^^^^^^^^^^^^^^ recursive type has infinite size\n+14 |     bar: Bar<'a>,\n+   |     ------------ recursive without indirection\n+   |\n+   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n+\n+error[E0072]: recursive type `Bar` has infinite size\n+  --> $DIR/recursive-type-field.rs:18:1\n+   |\n+18 | struct Bar<'a> {\n+   | ^^^^^^^^^^^^^^ recursive type has infinite size\n+19 |     y: (Foo<'a>, Foo<'a>),\n+   |     --------------------- recursive without indirection\n+20 |     z: Option<Bar<'a>>,\n+   |     ------------------ recursive without indirection\n+...\n+23 |     d: [Bar<'a>; 1],\n+   |     --------------- recursive without indirection\n+24 |     e: Foo<'a>,\n+   |     ---------- recursive without indirection\n+25 |     x: Bar<'a>,\n+   |     ---------- recursive without indirection\n+   |\n+   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Bar` representable\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "ba37863b1f62d6af309bfac54385d15b6d9a31a3", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -116,10 +116,26 @@ struct Target {\n     available: bool,\n     url: Option<String>,\n     hash: Option<String>,\n+    xz_url: Option<String>,\n+    xz_hash: Option<String>,\n     components: Option<Vec<Component>>,\n     extensions: Option<Vec<Component>>,\n }\n \n+impl Target {\n+    fn unavailable() -> Target {\n+        Target {\n+            available: false,\n+            url: None,\n+            hash: None,\n+            xz_url: None,\n+            xz_hash: None,\n+            components: None,\n+            extensions: None,\n+        }\n+    }\n+}\n+\n #[derive(RustcEncodable)]\n struct Component {\n     pkg: String,\n@@ -242,16 +258,12 @@ impl Builder {\n             let digest = match self.digests.remove(&filename) {\n                 Some(digest) => digest,\n                 None => {\n-                    pkg.target.insert(host.to_string(), Target {\n-                        available: false,\n-                        url: None,\n-                        hash: None,\n-                        components: None,\n-                        extensions: None,\n-                    });\n+                    pkg.target.insert(host.to_string(), Target::unavailable());\n                     continue\n                 }\n             };\n+            let xz_filename = filename.replace(\".tar.gz\", \".tar.xz\");\n+            let xz_digest = self.digests.remove(&xz_filename);\n             let mut components = Vec::new();\n             let mut extensions = Vec::new();\n \n@@ -293,8 +305,10 @@ impl Builder {\n \n             pkg.target.insert(host.to_string(), Target {\n                 available: true,\n-                url: Some(self.url(\"rust\", host)),\n+                url: Some(self.url(&filename)),\n                 hash: Some(digest),\n+                xz_url: xz_digest.as_ref().map(|_| self.url(&xz_filename)),\n+                xz_hash: xz_digest,\n                 components: Some(components),\n                 extensions: Some(extensions),\n             });\n@@ -312,21 +326,17 @@ impl Builder {\n             let filename = self.filename(pkgname, name);\n             let digest = match self.digests.remove(&filename) {\n                 Some(digest) => digest,\n-                None => {\n-                    return (name.to_string(), Target {\n-                        available: false,\n-                        url: None,\n-                        hash: None,\n-                        components: None,\n-                        extensions: None,\n-                    })\n-                }\n+                None => return (name.to_string(), Target::unavailable()),\n             };\n+            let xz_filename = filename.replace(\".tar.gz\", \".tar.xz\");\n+            let xz_digest = self.digests.remove(&xz_filename);\n \n             (name.to_string(), Target {\n                 available: true,\n-                url: Some(self.url(pkgname, name)),\n+                url: Some(self.url(&filename)),\n                 hash: Some(digest),\n+                xz_url: xz_digest.as_ref().map(|_| self.url(&xz_filename)),\n+                xz_hash: xz_digest,\n                 components: None,\n                 extensions: None,\n             })\n@@ -338,11 +348,11 @@ impl Builder {\n         });\n     }\n \n-    fn url(&self, component: &str, target: &str) -> String {\n+    fn url(&self, filename: &str) -> String {\n         format!(\"{}/{}/{}\",\n                 self.s3_address,\n                 self.date,\n-                self.filename(component, target))\n+                filename)\n     }\n \n     fn filename(&self, component: &str, target: &str) -> String {"}, {"sha": "6fc7f9f07ac174c407a235adc4e173aea6bf8476", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -336,6 +336,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         test_threads: None,\n         skip: vec![],\n         list: false,\n+        options: test::Options::new(),\n     }\n }\n "}, {"sha": "1a41b2c0f390ee56ba2df7f5241e3b96ea975e45", "filename": "src/tools/remote-test-client/src/main.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -25,6 +25,8 @@ use std::process::{Command, Stdio};\n use std::thread;\n use std::time::Duration;\n \n+const REMOTE_ADDR_ENV: &'static str = \"TEST_DEVICE_ADDR\";\n+\n macro_rules! t {\n     ($e:expr) => (match $e {\n         Ok(e) => e,\n@@ -56,7 +58,11 @@ fn spawn_emulator(target: &str,\n                   server: &Path,\n                   tmpdir: &Path,\n                   rootfs: Option<PathBuf>) {\n-    if target.contains(\"android\") {\n+    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(\"127.0.0.1:12345\".to_string());\n+\n+    if env::var(REMOTE_ADDR_ENV).is_ok() {\n+        println!(\"Connecting to remote device {} ...\", device_address);\n+    } else if target.contains(\"android\") {\n         start_android_emulator(server);\n     } else {\n         let rootfs = rootfs.as_ref().expect(\"need rootfs on non-android\");\n@@ -66,7 +72,7 @@ fn spawn_emulator(target: &str,\n     // Wait for the emulator to come online\n     loop {\n         let dur = Duration::from_millis(100);\n-        if let Ok(mut client) = TcpStream::connect(\"127.0.0.1:12345\") {\n+        if let Ok(mut client) = TcpStream::connect(&device_address) {\n             t!(client.set_read_timeout(Some(dur)));\n             t!(client.set_write_timeout(Some(dur)));\n             if client.write_all(b\"ping\").is_ok() {\n@@ -162,7 +168,8 @@ fn start_qemu_emulator(rootfs: &Path, server: &Path, tmpdir: &Path) {\n }\n \n fn push(path: &Path) {\n-    let client = t!(TcpStream::connect(\"127.0.0.1:12345\"));\n+    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(\"127.0.0.1:12345\".to_string());\n+    let client = t!(TcpStream::connect(device_address));\n     let mut client = BufWriter::new(client);\n     t!(client.write_all(b\"push\"));\n     send(path, &mut client);\n@@ -178,7 +185,8 @@ fn push(path: &Path) {\n }\n \n fn run(files: String, args: Vec<String>) {\n-    let client = t!(TcpStream::connect(\"127.0.0.1:12345\"));\n+    let device_address = env::var(REMOTE_ADDR_ENV).unwrap_or(\"127.0.0.1:12345\".to_string());\n+    let client = t!(TcpStream::connect(device_address));\n     let mut client = BufWriter::new(client);\n     t!(client.write_all(b\"run \"));\n "}, {"sha": "ae13acd58bbc287b7f45206d8bf7f8802d6ede3d", "filename": "src/tools/remote-test-server/src/main.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// This is a small server which is intended to run inside of an emulator. This\n-/// server pairs with the `remote-test-client` program in this repository. The\n-/// `remote-test-client` connects to this server over a TCP socket and performs\n-/// work such as:\n+/// This is a small server which is intended to run inside of an emulator or\n+/// on a remote test device. This server pairs with the `remote-test-client`\n+/// program in this repository. The `remote-test-client` connects to this\n+/// server over a TCP socket and performs work such as:\n ///\n /// 1. Pushing shared libraries to the server\n /// 2. Running tests through the server\n@@ -21,6 +21,7 @@\n /// basically custom format suiting our needs.\n \n use std::cmp;\n+use std::env;\n use std::fs::{self, File, Permissions};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n@@ -42,12 +43,54 @@ macro_rules! t {\n \n static TEST: AtomicUsize = ATOMIC_USIZE_INIT;\n \n+struct Config {\n+    pub remote: bool,\n+    pub verbose: bool,\n+}\n+\n+impl Config {\n+    pub fn default() -> Config {\n+        Config {\n+            remote: false,\n+            verbose: false,\n+        }\n+    }\n+\n+    pub fn parse_args() -> Config {\n+        let mut config = Config::default();\n+\n+        let args = env::args().skip(1);\n+        for argument in args {\n+            match &argument[..] {\n+                \"remote\" => {\n+                    config.remote = true;\n+                },\n+                \"verbose\" | \"-v\" => {\n+                    config.verbose = true;\n+                }\n+                arg => panic!(\"unknown argument: {}\", arg),\n+            }\n+        }\n+\n+        config\n+    }\n+}\n+\n fn main() {\n     println!(\"starting test server\");\n+\n+    let config = Config::parse_args();\n+\n+    let bind_addr = if cfg!(target_os = \"android\") || config.remote {\n+        \"0.0.0.0:12345\"\n+    } else {\n+        \"10.0.2.15:12345\"\n+    };\n+\n     let (listener, work) = if cfg!(target_os = \"android\") {\n-        (t!(TcpListener::bind(\"0.0.0.0:12345\")), \"/data/tmp/work\")\n+        (t!(TcpListener::bind(bind_addr)), \"/data/tmp/work\")\n     } else {\n-        (t!(TcpListener::bind(\"10.0.2.15:12345\")), \"/tmp/work\")\n+        (t!(TcpListener::bind(bind_addr)), \"/tmp/work\")\n     };\n     println!(\"listening!\");\n "}, {"sha": "28a55a8763c64e47c4720926bbadfcc9d5b1ad53", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35812d1746b8b98200533bd2bef18649ef5807d1/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=35812d1746b8b98200533bd2bef18649ef5807d1", "patch": "@@ -101,7 +101,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n            filename.starts_with(\".#\") {\n             return\n         }\n-        if filename == \"miniz.c\" || filename.contains(\"jquery\") {\n+        if filename == \"miniz.c\" {\n             return\n         }\n "}]}