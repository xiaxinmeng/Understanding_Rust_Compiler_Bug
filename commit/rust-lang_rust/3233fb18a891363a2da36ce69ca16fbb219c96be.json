{"sha": "3233fb18a891363a2da36ce69ca16fbb219c96be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMzNmYjE4YTg5MTM2M2EyZGEzNmNlNjljYTE2ZmJiMjE5Yzk2YmU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-08-28T06:02:46Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-08-30T18:15:24Z"}, "message": "Extend dataflow framework to support arbitrary lattices", "tree": {"sha": "e7423c01a36c5e1c9e0615ee3459f2604b3c5727", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7423c01a36c5e1c9e0615ee3459f2604b3c5727"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3233fb18a891363a2da36ce69ca16fbb219c96be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3233fb18a891363a2da36ce69ca16fbb219c96be", "html_url": "https://github.com/rust-lang/rust/commit/3233fb18a891363a2da36ce69ca16fbb219c96be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3233fb18a891363a2da36ce69ca16fbb219c96be/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e45e90596faf6e741665d1c4ff6b94ad3885dbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e45e90596faf6e741665d1c4ff6b94ad3885dbe", "html_url": "https://github.com/rust-lang/rust/commit/9e45e90596faf6e741665d1c4ff6b94ad3885dbe"}], "stats": {"total": 1252, "additions": 738, "deletions": 514}, "files": [{"sha": "4942bed656cc6b251e756e71e1871cd1686db926", "filename": "compiler/rustc_mir/src/dataflow/framework/cursor.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs?ref=3233fb18a891363a2da36ce69ca16fbb219c96be", "patch": "@@ -4,6 +4,7 @@ use std::borrow::Borrow;\n use std::cmp::Ordering;\n \n use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, BasicBlock, Location};\n \n use super::{Analysis, Direction, Effect, EffectIndex, Results};\n@@ -26,7 +27,7 @@ where\n {\n     body: &'mir mir::Body<'tcx>,\n     results: R,\n-    state: BitSet<A::Idx>,\n+    state: A::Domain,\n \n     pos: CursorPosition,\n \n@@ -46,17 +47,16 @@ where\n {\n     /// Returns a new cursor that can inspect `results`.\n     pub fn new(body: &'mir mir::Body<'tcx>, results: R) -> Self {\n-        let bits_per_block = results.borrow().entry_set_for_block(mir::START_BLOCK).domain_size();\n-\n+        let bottom_value = results.borrow().analysis.bottom_value(body);\n         ResultsCursor {\n             body,\n             results,\n \n-            // Initialize to an empty `BitSet` and set `state_needs_reset` to tell the cursor that\n+            // Initialize to the `bottom_value` and set `state_needs_reset` to tell the cursor that\n             // it needs to reset to block entry before the first seek. The cursor position is\n             // immaterial.\n             state_needs_reset: true,\n-            state: BitSet::new_empty(bits_per_block),\n+            state: bottom_value,\n             pos: CursorPosition::block_entry(mir::START_BLOCK),\n \n             #[cfg(debug_assertions)]\n@@ -79,17 +79,10 @@ where\n     }\n \n     /// Returns the dataflow state at the current location.\n-    pub fn get(&self) -> &BitSet<A::Idx> {\n+    pub fn get(&self) -> &A::Domain {\n         &self.state\n     }\n \n-    /// Returns `true` if the dataflow state at the current location contains the given element.\n-    ///\n-    /// Shorthand for `self.get().contains(elem)`\n-    pub fn contains(&self, elem: A::Idx) -> bool {\n-        self.state.contains(elem)\n-    }\n-\n     /// Resets the cursor to hold the entry set for the given basic block.\n     ///\n     /// For forward dataflow analyses, this is the dataflow state prior to the first statement.\n@@ -99,7 +92,7 @@ where\n         #[cfg(debug_assertions)]\n         assert!(self.reachable_blocks.contains(block));\n \n-        self.state.overwrite(&self.results.borrow().entry_set_for_block(block));\n+        self.state.clone_from(&self.results.borrow().entry_set_for_block(block));\n         self.pos = CursorPosition::block_entry(block);\n         self.state_needs_reset = false;\n     }\n@@ -207,12 +200,23 @@ where\n     ///\n     /// This can be used, e.g., to apply the call return effect directly to the cursor without\n     /// creating an extra copy of the dataflow state.\n-    pub fn apply_custom_effect(&mut self, f: impl FnOnce(&A, &mut BitSet<A::Idx>)) {\n+    pub fn apply_custom_effect(&mut self, f: impl FnOnce(&A, &mut A::Domain)) {\n         f(&self.results.borrow().analysis, &mut self.state);\n         self.state_needs_reset = true;\n     }\n }\n \n+impl<'mir, 'tcx, A, R, T> ResultsCursor<'mir, 'tcx, A, R>\n+where\n+    A: Analysis<'tcx, Domain = BitSet<T>>,\n+    T: Idx,\n+    R: Borrow<Results<'tcx, A>>,\n+{\n+    pub fn contains(&self, elem: T) -> bool {\n+        self.get().contains(elem)\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug)]\n struct CursorPosition {\n     block: BasicBlock,"}, {"sha": "94d299bd088ece1b9be0e510d54dfa12fa1c7e8a", "filename": "compiler/rustc_mir/src/dataflow/framework/direction.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs?ref=3233fb18a891363a2da36ce69ca16fbb219c96be", "patch": "@@ -18,7 +18,7 @@ pub trait Direction {\n     /// `effects.start()` must precede or equal `effects.end()` in this direction.\n     fn apply_effects_in_range<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n         effects: RangeInclusive<EffectIndex>,\n@@ -27,7 +27,7 @@ pub trait Direction {\n \n     fn apply_effects_in_block<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n     ) where\n@@ -55,9 +55,9 @@ pub trait Direction {\n         tcx: TyCtxt<'tcx>,\n         body: &mir::Body<'tcx>,\n         dead_unwinds: Option<&BitSet<BasicBlock>>,\n-        exit_state: &mut BitSet<A::Idx>,\n+        exit_state: &mut A::Domain,\n         block: (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n-        propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+        propagate: impl FnMut(BasicBlock, &A::Domain),\n     ) where\n         A: Analysis<'tcx>;\n }\n@@ -72,7 +72,7 @@ impl Direction for Backward {\n \n     fn apply_effects_in_block<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n     ) where\n@@ -112,7 +112,7 @@ impl Direction for Backward {\n \n     fn apply_effects_in_range<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n         effects: RangeInclusive<EffectIndex>,\n@@ -224,9 +224,9 @@ impl Direction for Backward {\n         _tcx: TyCtxt<'tcx>,\n         body: &mir::Body<'tcx>,\n         dead_unwinds: Option<&BitSet<BasicBlock>>,\n-        exit_state: &mut BitSet<A::Idx>,\n+        exit_state: &mut A::Domain,\n         (bb, _bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n-        mut propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+        mut propagate: impl FnMut(BasicBlock, &A::Domain),\n     ) where\n         A: Analysis<'tcx>,\n     {\n@@ -281,7 +281,7 @@ impl Direction for Forward {\n \n     fn apply_effects_in_block<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n     ) where\n@@ -321,7 +321,7 @@ impl Direction for Forward {\n \n     fn apply_effects_in_range<A>(\n         analysis: &A,\n-        state: &mut BitSet<A::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         block_data: &mir::BasicBlockData<'tcx>,\n         effects: RangeInclusive<EffectIndex>,\n@@ -428,9 +428,9 @@ impl Direction for Forward {\n         tcx: TyCtxt<'tcx>,\n         body: &mir::Body<'tcx>,\n         dead_unwinds: Option<&BitSet<BasicBlock>>,\n-        exit_state: &mut BitSet<A::Idx>,\n+        exit_state: &mut A::Domain,\n         (bb, bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n-        mut propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+        mut propagate: impl FnMut(BasicBlock, &A::Domain),\n     ) where\n         A: Analysis<'tcx>,\n     {\n@@ -499,7 +499,7 @@ impl Direction for Forward {\n                         // MIR building adds discriminants to the `values` array in the same order as they\n                         // are yielded by `AdtDef::discriminants`. We rely on this to match each\n                         // discriminant in `values` to its corresponding variant in linear time.\n-                        let mut tmp = BitSet::new_empty(exit_state.domain_size());\n+                        let mut tmp = analysis.bottom_value(body);\n                         let mut discriminants = enum_def.discriminants(tcx);\n                         for (value, target) in values.iter().zip(targets.iter().copied()) {\n                             let (variant_idx, _) =\n@@ -508,7 +508,7 @@ impl Direction for Forward {\n                                          from that of `SwitchInt::values`\",\n                                 );\n \n-                            tmp.overwrite(exit_state);\n+                            tmp.clone_from(exit_state);\n                             analysis.apply_discriminant_switch_effect(\n                                 &mut tmp,\n                                 bb,"}, {"sha": "07f5ab5e7bd34d4a6091b8bf78cb3f3a1fee3d83", "filename": "compiler/rustc_mir/src/dataflow/framework/engine.rs", "status": "modified", "additions": 48, "deletions": 57, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs?ref=3233fb18a891363a2da36ce69ca16fbb219c96be", "patch": "@@ -1,5 +1,6 @@\n //! A solver for dataflow problems.\n \n+use std::borrow::BorrowMut;\n use std::ffi::OsString;\n use std::fs;\n use std::path::PathBuf;\n@@ -9,14 +10,16 @@ use rustc_data_structures::work_queue::WorkQueue;\n use rustc_graphviz as dot;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{self, traversal, BasicBlock};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n \n+use super::fmt::DebugWithContext;\n use super::graphviz;\n use super::{\n-    visit_results, Analysis, Direction, GenKillAnalysis, GenKillSet, ResultsCursor, ResultsVisitor,\n+    visit_results, Analysis, Direction, GenKill, GenKillAnalysis, GenKillSet, JoinSemiLattice,\n+    ResultsCursor, ResultsVisitor,\n };\n use crate::util::pretty::dump_enabled;\n \n@@ -26,7 +29,7 @@ where\n     A: Analysis<'tcx>,\n {\n     pub analysis: A,\n-    pub(super) entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+    pub(super) entry_sets: IndexVec<BasicBlock, A::Domain>,\n }\n \n impl<A> Results<'tcx, A>\n@@ -39,23 +42,23 @@ where\n     }\n \n     /// Gets the dataflow state for the given block.\n-    pub fn entry_set_for_block(&self, block: BasicBlock) -> &BitSet<A::Idx> {\n+    pub fn entry_set_for_block(&self, block: BasicBlock) -> &A::Domain {\n         &self.entry_sets[block]\n     }\n \n     pub fn visit_with(\n         &self,\n         body: &'mir mir::Body<'tcx>,\n         blocks: impl IntoIterator<Item = BasicBlock>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = A::Domain>,\n     ) {\n         visit_results(body, blocks, self, vis)\n     }\n \n     pub fn visit_reachable_with(\n         &self,\n         body: &'mir mir::Body<'tcx>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = A::Domain>,\n     ) {\n         let blocks = mir::traversal::reachable(body);\n         visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n@@ -64,7 +67,7 @@ where\n     pub fn visit_in_rpo_with(\n         &self,\n         body: &'mir mir::Body<'tcx>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = A::Domain>,\n     ) {\n         let blocks = mir::traversal::reverse_postorder(body);\n         visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n@@ -76,21 +79,22 @@ pub struct Engine<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n-    bits_per_block: usize,\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n     def_id: DefId,\n     dead_unwinds: Option<&'a BitSet<BasicBlock>>,\n-    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+    entry_sets: IndexVec<BasicBlock, A::Domain>,\n     analysis: A,\n \n     /// Cached, cumulative transfer functions for each block.\n-    trans_for_block: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n+    apply_trans_for_block: Option<Box<dyn Fn(BasicBlock, &mut A::Domain)>>,\n }\n \n-impl<A> Engine<'a, 'tcx, A>\n+impl<A, D, T> Engine<'a, 'tcx, A>\n where\n-    A: GenKillAnalysis<'tcx>,\n+    A: GenKillAnalysis<'tcx, Idx = T, Domain = D>,\n+    D: Clone + JoinSemiLattice + GenKill<T> + BorrowMut<BitSet<T>>,\n+    T: Idx,\n {\n     /// Creates a new `Engine` to solve a gen-kill dataflow problem.\n     pub fn new_gen_kill(\n@@ -109,22 +113,26 @@ where\n \n         // Otherwise, compute and store the cumulative transfer function for each block.\n \n-        let bits_per_block = analysis.bits_per_block(body);\n-        let mut trans_for_block =\n-            IndexVec::from_elem(GenKillSet::identity(bits_per_block), body.basic_blocks());\n+        let identity = GenKillSet::identity(analysis.bottom_value(body).borrow().domain_size());\n+        let mut trans_for_block = IndexVec::from_elem(identity, body.basic_blocks());\n \n         for (block, block_data) in body.basic_blocks().iter_enumerated() {\n             let trans = &mut trans_for_block[block];\n             A::Direction::gen_kill_effects_in_block(&analysis, trans, block, block_data);\n         }\n \n-        Self::new(tcx, body, def_id, analysis, Some(trans_for_block))\n+        let apply_trans = Box::new(move |bb: BasicBlock, state: &mut A::Domain| {\n+            trans_for_block[bb].apply(state.borrow_mut());\n+        });\n+\n+        Self::new(tcx, body, def_id, analysis, Some(apply_trans as Box<_>))\n     }\n }\n \n-impl<A> Engine<'a, 'tcx, A>\n+impl<A, D> Engine<'a, 'tcx, A>\n where\n-    A: Analysis<'tcx>,\n+    A: Analysis<'tcx, Domain = D>,\n+    D: Clone + JoinSemiLattice,\n {\n     /// Creates a new `Engine` to solve a dataflow problem with an arbitrary transfer\n     /// function.\n@@ -145,32 +153,24 @@ where\n         body: &'a mir::Body<'tcx>,\n         def_id: DefId,\n         analysis: A,\n-        trans_for_block: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n+        apply_trans_for_block: Option<Box<dyn Fn(BasicBlock, &mut A::Domain)>>,\n     ) -> Self {\n-        let bits_per_block = analysis.bits_per_block(body);\n-\n-        let bottom_value_set = if A::BOTTOM_VALUE {\n-            BitSet::new_filled(bits_per_block)\n-        } else {\n-            BitSet::new_empty(bits_per_block)\n-        };\n-\n-        let mut entry_sets = IndexVec::from_elem(bottom_value_set.clone(), body.basic_blocks());\n+        let bottom_value = analysis.bottom_value(body);\n+        let mut entry_sets = IndexVec::from_elem(bottom_value.clone(), body.basic_blocks());\n         analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n \n-        if A::Direction::is_backward() && entry_sets[mir::START_BLOCK] != bottom_value_set {\n+        if A::Direction::is_backward() && entry_sets[mir::START_BLOCK] != bottom_value {\n             bug!(\"`initialize_start_block` is not yet supported for backward dataflow analyses\");\n         }\n \n         Engine {\n             analysis,\n-            bits_per_block,\n             tcx,\n             body,\n             def_id,\n             dead_unwinds: None,\n             entry_sets,\n-            trans_for_block,\n+            apply_trans_for_block,\n         }\n     }\n \n@@ -185,16 +185,18 @@ where\n     }\n \n     /// Computes the fixpoint for this dataflow problem and returns it.\n-    pub fn iterate_to_fixpoint(self) -> Results<'tcx, A> {\n+    pub fn iterate_to_fixpoint(self) -> Results<'tcx, A>\n+    where\n+        A::Domain: DebugWithContext<A>,\n+    {\n         let Engine {\n             analysis,\n-            bits_per_block,\n             body,\n             dead_unwinds,\n             def_id,\n             mut entry_sets,\n             tcx,\n-            trans_for_block,\n+            apply_trans_for_block,\n             ..\n         } = self;\n \n@@ -213,14 +215,14 @@ where\n             }\n         }\n \n-        let mut state = BitSet::new_empty(bits_per_block);\n+        let mut state = analysis.bottom_value(body);\n         while let Some(bb) = dirty_queue.pop() {\n             let bb_data = &body[bb];\n \n             // Apply the block transfer function, using the cached one if it exists.\n-            state.overwrite(&entry_sets[bb]);\n-            match &trans_for_block {\n-                Some(trans_for_block) => trans_for_block[bb].apply(&mut state),\n+            state.clone_from(&entry_sets[bb]);\n+            match &apply_trans_for_block {\n+                Some(apply) => apply(bb, &mut state),\n                 None => A::Direction::apply_effects_in_block(&analysis, &mut state, bb, bb_data),\n             }\n \n@@ -231,8 +233,8 @@ where\n                 dead_unwinds,\n                 &mut state,\n                 (bb, bb_data),\n-                |target: BasicBlock, state: &BitSet<A::Idx>| {\n-                    let set_changed = analysis.join(&mut entry_sets[target], state);\n+                |target: BasicBlock, state: &A::Domain| {\n+                    let set_changed = entry_sets[target].join(state);\n                     if set_changed {\n                         dirty_queue.insert(target);\n                     }\n@@ -242,7 +244,7 @@ where\n \n         let results = Results { analysis, entry_sets };\n \n-        let res = write_graphviz_results(tcx, def_id, &body, &results, trans_for_block);\n+        let res = write_graphviz_results(tcx, def_id, &body, &results);\n         if let Err(e) = res {\n             warn!(\"Failed to write graphviz dataflow results: {}\", e);\n         }\n@@ -260,10 +262,10 @@ fn write_graphviz_results<A>(\n     def_id: DefId,\n     body: &mir::Body<'tcx>,\n     results: &Results<'tcx, A>,\n-    block_transfer_functions: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n ) -> std::io::Result<()>\n where\n     A: Analysis<'tcx>,\n+    A::Domain: DebugWithContext<A>,\n {\n     let attrs = match RustcMirAttrs::parse(tcx, def_id) {\n         Ok(attrs) => attrs,\n@@ -290,26 +292,15 @@ where\n         None => return Ok(()),\n     };\n \n-    let bits_per_block = results.analysis.bits_per_block(body);\n-\n-    let mut formatter: Box<dyn graphviz::StateFormatter<'tcx, _>> = match attrs.formatter {\n-        Some(sym::two_phase) => Box::new(graphviz::TwoPhaseDiff::new(bits_per_block)),\n-        Some(sym::gen_kill) => {\n-            if let Some(trans_for_block) = block_transfer_functions {\n-                Box::new(graphviz::BlockTransferFunc::new(body, trans_for_block))\n-            } else {\n-                Box::new(graphviz::SimpleDiff::new(body, &results))\n-            }\n-        }\n-\n-        // Default to the `SimpleDiff` output style.\n-        _ => Box::new(graphviz::SimpleDiff::new(body, &results)),\n+    let style = match attrs.formatter {\n+        Some(sym::two_phase) => graphviz::OutputStyle::BeforeAndAfter,\n+        _ => graphviz::OutputStyle::AfterOnly,\n     };\n \n     debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n     let mut buf = Vec::new();\n \n-    let graphviz = graphviz::Formatter::new(body, def_id, results, &mut *formatter);\n+    let graphviz = graphviz::Formatter::new(body, def_id, results, style);\n     dot::render_opts(&graphviz, &mut buf, &[dot::RenderOption::Monospace])?;\n \n     if let Some(parent) = path.parent() {"}, {"sha": "0140a750544334f0053b097dfc193db55d1f65c8", "filename": "compiler/rustc_mir/src/dataflow/framework/fmt.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ffmt.rs?ref=3233fb18a891363a2da36ce69ca16fbb219c96be", "patch": "@@ -0,0 +1,172 @@\n+//! Custom formatting traits used when outputting Graphviz diagrams with the results of a dataflow\n+//! analysis.\n+\n+use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_index::vec::Idx;\n+use std::fmt;\n+\n+/// An extension to `fmt::Debug` for data that can be better printed with some auxiliary data `C`.\n+pub trait DebugWithContext<C>: Eq + fmt::Debug {\n+    fn fmt_with(&self, _ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(self, f)\n+    }\n+\n+    /// Print the difference between `self` and `old`.\n+    ///\n+    /// This should print nothing if `self == old`.\n+    ///\n+    /// `+` and `-` are typically used to indicate differences. However, these characters are\n+    /// fairly common and may be needed to print a types representation. If using them to indicate\n+    /// a diff, prefix them with the \"Unit Separator\"  control character (\u241f  U+001F).\n+    fn fmt_diff_with(&self, old: &Self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self == old {\n+            return Ok(());\n+        }\n+\n+        write!(f, \"\\u{001f}+\")?;\n+        self.fmt_with(ctxt, f)?;\n+\n+        if f.alternate() {\n+            write!(f, \"\\n\")?;\n+        } else {\n+            write!(f, \"\\t\")?;\n+        }\n+\n+        write!(f, \"\\u{001f}-\")?;\n+        self.fmt_with(ctxt, f)\n+    }\n+}\n+\n+/// Implements `fmt::Debug` by deferring to `<T as DebugWithContext<C>>::fmt_with`.\n+pub struct DebugWithAdapter<'a, T, C> {\n+    pub this: T,\n+    pub ctxt: &'a C,\n+}\n+\n+impl<T, C> fmt::Debug for DebugWithAdapter<'_, T, C>\n+where\n+    T: DebugWithContext<C>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.this.fmt_with(self.ctxt, f)\n+    }\n+}\n+\n+/// Implements `fmt::Debug` by deferring to `<T as DebugWithContext<C>>::fmt_diff_with`.\n+pub struct DebugDiffWithAdapter<'a, T, C> {\n+    pub new: T,\n+    pub old: T,\n+    pub ctxt: &'a C,\n+}\n+\n+impl<T, C> fmt::Debug for DebugDiffWithAdapter<'_, T, C>\n+where\n+    T: DebugWithContext<C>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.new.fmt_diff_with(&self.old, self.ctxt, f)\n+    }\n+}\n+\n+// Impls\n+\n+impl<T, C> DebugWithContext<C> for BitSet<T>\n+where\n+    T: Idx + DebugWithContext<C>,\n+{\n+    fn fmt_with(&self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_set().entries(self.iter().map(|i| DebugWithAdapter { this: i, ctxt })).finish()\n+    }\n+\n+    fn fmt_diff_with(&self, old: &Self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let size = self.domain_size();\n+        assert_eq!(size, old.domain_size());\n+\n+        let mut set_in_self = HybridBitSet::new_empty(size);\n+        let mut cleared_in_self = HybridBitSet::new_empty(size);\n+\n+        for i in (0..size).map(T::new) {\n+            match (self.contains(i), old.contains(i)) {\n+                (true, false) => set_in_self.insert(i),\n+                (false, true) => cleared_in_self.insert(i),\n+                _ => continue,\n+            };\n+        }\n+\n+        let mut first = true;\n+        for idx in set_in_self.iter() {\n+            let delim = if first {\n+                \"\\u{001f}+\"\n+            } else if f.alternate() {\n+                \"\\n\\u{001f}+\"\n+            } else {\n+                \", \"\n+            };\n+\n+            write!(f, \"{}\", delim)?;\n+            idx.fmt_with(ctxt, f)?;\n+            first = false;\n+        }\n+\n+        if !f.alternate() {\n+            first = true;\n+            if !set_in_self.is_empty() && !cleared_in_self.is_empty() {\n+                write!(f, \"\\t\")?;\n+            }\n+        }\n+\n+        for idx in cleared_in_self.iter() {\n+            let delim = if first {\n+                \"\\u{001f}-\"\n+            } else if f.alternate() {\n+                \"\\n\\u{001f}-\"\n+            } else {\n+                \", \"\n+            };\n+\n+            write!(f, \"{}\", delim)?;\n+            idx.fmt_with(ctxt, f)?;\n+            first = false;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<T, C> DebugWithContext<C> for &'_ T\n+where\n+    T: DebugWithContext<C>,\n+{\n+    fn fmt_with(&self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (*self).fmt_with(ctxt, f)\n+    }\n+\n+    fn fmt_diff_with(&self, old: &Self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (*self).fmt_diff_with(*old, ctxt, f)\n+    }\n+}\n+\n+impl<C> DebugWithContext<C> for rustc_middle::mir::Local {}\n+impl<C> DebugWithContext<C> for crate::dataflow::move_paths::InitIndex {}\n+\n+impl<'tcx, C> DebugWithContext<C> for crate::dataflow::move_paths::MovePathIndex\n+where\n+    C: crate::dataflow::move_paths::HasMoveData<'tcx>,\n+{\n+    fn fmt_with(&self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", ctxt.move_data().move_paths[*self])\n+    }\n+}\n+\n+impl<T, C> DebugWithContext<C> for crate::dataflow::lattice::Dual<T>\n+where\n+    T: DebugWithContext<C>,\n+{\n+    fn fmt_with(&self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (self.0).fmt_with(ctxt, f)\n+    }\n+\n+    fn fmt_diff_with(&self, old: &Self, ctxt: &C, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (self.0).fmt_diff_with(&old.0, ctxt, f)\n+    }\n+}"}, {"sha": "179c471cf4829fadba91106390e3c9913100cdcf", "filename": "compiler/rustc_mir/src/dataflow/framework/graphviz.rs", "status": "modified", "additions": 229, "deletions": 326, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs?ref=3233fb18a891363a2da36ce69ca16fbb219c96be", "patch": "@@ -1,26 +1,40 @@\n //! A helpful diagram for debugging dataflow problems.\n \n-use std::cell::RefCell;\n+use std::borrow::Cow;\n use std::{io, ops, str};\n \n+use regex::Regex;\n use rustc_graphviz as dot;\n use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::{BitSet, HybridBitSet};\n-use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{self, BasicBlock, Body, Location};\n \n-use super::{Analysis, Direction, GenKillSet, Results, ResultsRefCursor};\n+use super::fmt::{DebugDiffWithAdapter, DebugWithAdapter, DebugWithContext};\n+use super::{Analysis, Direction, Results, ResultsRefCursor, ResultsVisitor};\n use crate::util::graphviz_safe_def_name;\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum OutputStyle {\n+    AfterOnly,\n+    BeforeAndAfter,\n+}\n+\n+impl OutputStyle {\n+    fn num_state_columns(&self) -> usize {\n+        match self {\n+            Self::AfterOnly => 1,\n+            Self::BeforeAndAfter => 2,\n+        }\n+    }\n+}\n+\n pub struct Formatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n     body: &'a Body<'tcx>,\n     def_id: DefId,\n-\n-    // This must be behind a `RefCell` because `dot::Labeller` takes `&self`.\n-    block_formatter: RefCell<BlockFormatter<'a, 'tcx, A>>,\n+    results: &'a Results<'tcx, A>,\n+    style: OutputStyle,\n }\n \n impl<A> Formatter<'a, 'tcx, A>\n@@ -31,15 +45,9 @@ where\n         body: &'a Body<'tcx>,\n         def_id: DefId,\n         results: &'a Results<'tcx, A>,\n-        state_formatter: &'a mut dyn StateFormatter<'tcx, A>,\n+        style: OutputStyle,\n     ) -> Self {\n-        let block_formatter = BlockFormatter {\n-            bg: Background::Light,\n-            results: ResultsRefCursor::new(body, results),\n-            state_formatter,\n-        };\n-\n-        Formatter { body, def_id, block_formatter: RefCell::new(block_formatter) }\n+        Formatter { body, def_id, results, style }\n     }\n }\n \n@@ -62,6 +70,7 @@ fn dataflow_successors(body: &Body<'tcx>, bb: BasicBlock) -> Vec<CfgEdge> {\n impl<A> dot::Labeller<'_> for Formatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n+    A::Domain: DebugWithContext<A>,\n {\n     type Node = BasicBlock;\n     type Edge = CfgEdge;\n@@ -77,7 +86,13 @@ where\n \n     fn node_label(&self, block: &Self::Node) -> dot::LabelText<'_> {\n         let mut label = Vec::new();\n-        self.block_formatter.borrow_mut().write_node_label(&mut label, self.body, *block).unwrap();\n+        let mut fmt = BlockFormatter {\n+            results: ResultsRefCursor::new(self.body, self.results),\n+            style: self.style,\n+            bg: Background::Light,\n+        };\n+\n+        fmt.write_node_label(&mut label, self.body, *block).unwrap();\n         dot::LabelText::html(String::from_utf8(label).unwrap())\n     }\n \n@@ -126,19 +141,16 @@ where\n {\n     results: ResultsRefCursor<'a, 'a, 'tcx, A>,\n     bg: Background,\n-    state_formatter: &'a mut dyn StateFormatter<'tcx, A>,\n+    style: OutputStyle,\n }\n \n impl<A> BlockFormatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n+    A::Domain: DebugWithContext<A>,\n {\n     const HEADER_COLOR: &'static str = \"#a0a0a0\";\n \n-    fn num_state_columns(&self) -> usize {\n-        std::cmp::max(1, self.state_formatter.column_names().len())\n-    }\n-\n     fn toggle_background(&mut self) -> Background {\n         let bg = self.bg;\n         self.bg = !bg;\n@@ -187,40 +199,30 @@ where\n         write!(w, r#\"<table{fmt}>\"#, fmt = table_fmt)?;\n \n         // A + B: Block header\n-        if self.state_formatter.column_names().is_empty() {\n-            self.write_block_header_simple(w, block)?;\n-        } else {\n-            self.write_block_header_with_state_columns(w, block)?;\n+        match self.style {\n+            OutputStyle::AfterOnly => self.write_block_header_simple(w, block)?,\n+            OutputStyle::BeforeAndAfter => {\n+                self.write_block_header_with_state_columns(w, block, &[\"BEFORE\", \"AFTER\"])?\n+            }\n         }\n \n         // C: State at start of block\n         self.bg = Background::Light;\n         self.results.seek_to_block_start(block);\n-        let block_entry_state = self.results.get().clone();\n-\n+        let block_start_state = self.results.get().clone();\n         self.write_row_with_full_state(w, \"\", \"(on start)\")?;\n \n-        // D: Statement transfer functions\n-        for (i, statement) in body[block].statements.iter().enumerate() {\n-            let location = Location { block, statement_index: i };\n-            let statement_str = format!(\"{:?}\", statement);\n-            self.write_row_for_location(w, &i.to_string(), &statement_str, location)?;\n-        }\n-\n-        // E: Terminator transfer function\n-        let terminator = body[block].terminator();\n-        let terminator_loc = body.terminator_loc(block);\n-        let mut terminator_str = String::new();\n-        terminator.kind.fmt_head(&mut terminator_str).unwrap();\n-\n-        self.write_row_for_location(w, \"T\", &terminator_str, terminator_loc)?;\n+        // D + E: Statement and terminator transfer functions\n+        self.write_statements_and_terminator(w, body, block)?;\n \n         // F: State at end of block\n \n+        let terminator = body[block].terminator();\n+\n         // Write the full dataflow state immediately after the terminator if it differs from the\n         // state at block entry.\n         self.results.seek_to_block_end(block);\n-        if self.results.get() != &block_entry_state || A::Direction::is_backward() {\n+        if self.results.get() != &block_start_state || A::Direction::is_backward() {\n             let after_terminator_name = match terminator.kind {\n                 mir::TerminatorKind::Call { destination: Some(_), .. } => \"(on unwind)\",\n                 _ => \"(on end)\",\n@@ -229,8 +231,11 @@ where\n             self.write_row_with_full_state(w, \"\", after_terminator_name)?;\n         }\n \n-        // Write any changes caused by terminator-specific effects\n-        let num_state_columns = self.num_state_columns();\n+        // Write any changes caused by terminator-specific effects.\n+        //\n+        // FIXME: These should really be printed as part of each outgoing edge rather than the node\n+        // for the basic block itself. That way, we could display terminator-specific effects for\n+        // backward dataflow analyses as well as effects for `SwitchInt` terminators.\n         match terminator.kind {\n             mir::TerminatorKind::Call {\n                 destination: Some((return_place, _)),\n@@ -239,44 +244,43 @@ where\n                 ..\n             } => {\n                 self.write_row(w, \"\", \"(on successful return)\", |this, w, fmt| {\n-                    write!(\n-                        w,\n-                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n-                        colspan = num_state_columns,\n-                        fmt = fmt,\n-                    )?;\n-\n                     let state_on_unwind = this.results.get().clone();\n                     this.results.apply_custom_effect(|analysis, state| {\n                         analysis.apply_call_return_effect(state, block, func, args, return_place);\n                     });\n \n-                    write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n-                    write!(w, \"</td>\")\n+                    write!(\n+                        w,\n+                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">{diff}</td>\"#,\n+                        colspan = this.style.num_state_columns(),\n+                        fmt = fmt,\n+                        diff = diff_pretty(\n+                            this.results.get(),\n+                            &state_on_unwind,\n+                            this.results.analysis()\n+                        ),\n+                    )\n                 })?;\n             }\n \n             mir::TerminatorKind::Yield { resume, resume_arg, .. } => {\n                 self.write_row(w, \"\", \"(on yield resume)\", |this, w, fmt| {\n-                    write!(\n-                        w,\n-                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n-                        colspan = num_state_columns,\n-                        fmt = fmt,\n-                    )?;\n-\n                     let state_on_generator_drop = this.results.get().clone();\n                     this.results.apply_custom_effect(|analysis, state| {\n                         analysis.apply_yield_resume_effect(state, resume, resume_arg);\n                     });\n \n-                    write_diff(\n+                    write!(\n                         w,\n-                        this.results.analysis(),\n-                        &state_on_generator_drop,\n-                        this.results.get(),\n-                    )?;\n-                    write!(w, \"</td>\")\n+                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">{diff}</td>\"#,\n+                        colspan = this.style.num_state_columns(),\n+                        fmt = fmt,\n+                        diff = diff_pretty(\n+                            this.results.get(),\n+                            &state_on_generator_drop,\n+                            this.results.analysis()\n+                        ),\n+                    )\n                 })?;\n             }\n \n@@ -322,6 +326,7 @@ where\n         &mut self,\n         w: &mut impl io::Write,\n         block: BasicBlock,\n+        state_column_names: &[&str],\n     ) -> io::Result<()> {\n         //   +------------------------------------+-------------+\n         // A |                bb4                 |    STATE    |\n@@ -330,8 +335,6 @@ where\n         //   +-+----------------------------------+------+------+\n         //   | |              ...                 |      |      |\n \n-        let state_column_names = self.state_formatter.column_names();\n-\n         // A\n         write!(\n             w,\n@@ -357,6 +360,56 @@ where\n         write!(w, \"</tr>\")\n     }\n \n+    fn write_statements_and_terminator(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        body: &'a Body<'tcx>,\n+        block: BasicBlock,\n+    ) -> io::Result<()> {\n+        let diffs = StateDiffCollector::run(body, block, self.results.results(), self.style);\n+\n+        let mut befores = diffs.before.map(|v| v.into_iter());\n+        let mut afters = diffs.after.into_iter();\n+\n+        let next_in_dataflow_order = |it: &mut std::vec::IntoIter<_>| {\n+            if A::Direction::is_forward() { it.next().unwrap() } else { it.next_back().unwrap() }\n+        };\n+\n+        for (i, statement) in body[block].statements.iter().enumerate() {\n+            let statement_str = format!(\"{:?}\", statement);\n+            let index_str = format!(\"{}\", i);\n+\n+            let after = next_in_dataflow_order(&mut afters);\n+            let before = befores.as_mut().map(next_in_dataflow_order);\n+\n+            self.write_row(w, &index_str, &statement_str, |_this, w, fmt| {\n+                if let Some(before) = before {\n+                    write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = before)?;\n+                }\n+\n+                write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = after)\n+            })?;\n+        }\n+\n+        let after = next_in_dataflow_order(&mut afters);\n+        let before = befores.as_mut().map(next_in_dataflow_order);\n+\n+        assert!(afters.is_empty());\n+        assert!(befores.as_ref().map_or(true, ExactSizeIterator::is_empty));\n+\n+        let terminator = body[block].terminator();\n+        let mut terminator_str = String::new();\n+        terminator.kind.fmt_head(&mut terminator_str).unwrap();\n+\n+        self.write_row(w, \"T\", &terminator_str, |_this, w, fmt| {\n+            if let Some(before) = before {\n+                write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = before)?;\n+            }\n+\n+            write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = after)\n+        })\n+    }\n+\n     /// Write a row with the given index and MIR, using the function argument to fill in the\n     /// \"STATE\" column(s).\n     fn write_row<W: io::Write>(\n@@ -397,319 +450,169 @@ where\n             let state = this.results.get();\n             let analysis = this.results.analysis();\n \n+            // FIXME: The full state vector can be quite long. It would be nice to split on commas\n+            // and use some text wrapping algorithm.\n             write!(\n                 w,\n-                r#\"<td colspan=\"{colspan}\" {fmt} align=\"left\">{{\"#,\n-                colspan = this.num_state_columns(),\n+                r#\"<td colspan=\"{colspan}\" {fmt} align=\"left\">{state}</td>\"#,\n+                colspan = this.style.num_state_columns(),\n                 fmt = fmt,\n-            )?;\n-            pretty_print_state_elems(w, analysis, state.iter(), \", \", LIMIT_30_ALIGN_1)?;\n-            write!(w, \"}}</td>\")\n-        })\n-    }\n-\n-    fn write_row_for_location(\n-        &mut self,\n-        w: &mut impl io::Write,\n-        i: &str,\n-        mir: &str,\n-        location: Location,\n-    ) -> io::Result<()> {\n-        self.write_row(w, i, mir, |this, w, fmt| {\n-            this.state_formatter.write_state_for_location(w, fmt, &mut this.results, location)\n+                state = format!(\"{:?}\", DebugWithAdapter { this: state, ctxt: analysis }),\n+            )\n         })\n     }\n }\n \n-/// Controls what gets printed under the `STATE` header.\n-pub trait StateFormatter<'tcx, A>\n+struct StateDiffCollector<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n-    /// The columns that will get printed under `STATE`.\n-    fn column_names(&self) -> &[&str];\n-\n-    fn write_state_for_location(\n-        &mut self,\n-        w: &mut dyn io::Write,\n-        fmt: &str,\n-        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n-        location: Location,\n-    ) -> io::Result<()>;\n+    analysis: &'a A,\n+    prev_state: A::Domain,\n+    before: Option<Vec<String>>,\n+    after: Vec<String>,\n }\n \n-/// Prints a single column containing the state vector immediately *after* each statement.\n-pub struct SimpleDiff<'a, 'tcx, A>\n+impl<A> StateDiffCollector<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n+    A::Domain: DebugWithContext<A>,\n {\n-    prev_state: ResultsRefCursor<'a, 'a, 'tcx, A>,\n-}\n+    fn run(\n+        body: &'a mir::Body<'tcx>,\n+        block: BasicBlock,\n+        results: &'a Results<'tcx, A>,\n+        style: OutputStyle,\n+    ) -> Self {\n+        let mut collector = StateDiffCollector {\n+            analysis: &results.analysis,\n+            prev_state: results.analysis.bottom_value(body),\n+            after: vec![],\n+            before: (style == OutputStyle::BeforeAndAfter).then_some(vec![]),\n+        };\n \n-impl<A> SimpleDiff<'a, 'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    pub fn new(body: &'a Body<'tcx>, results: &'a Results<'tcx, A>) -> Self {\n-        SimpleDiff { prev_state: ResultsRefCursor::new(body, results) }\n+        results.visit_with(body, std::iter::once(block), &mut collector);\n+        collector\n     }\n }\n \n-impl<A> StateFormatter<'tcx, A> for SimpleDiff<'_, 'tcx, A>\n+impl<A> ResultsVisitor<'a, 'tcx> for StateDiffCollector<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n+    A::Domain: DebugWithContext<A>,\n {\n-    fn column_names(&self) -> &[&str] {\n-        &[]\n-    }\n+    type FlowState = A::Domain;\n \n-    fn write_state_for_location(\n+    fn visit_block_start(\n         &mut self,\n-        mut w: &mut dyn io::Write,\n-        fmt: &str,\n-        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n-        location: Location,\n-    ) -> io::Result<()> {\n+        state: &Self::FlowState,\n+        _block_data: &'mir mir::BasicBlockData<'tcx>,\n+        _block: BasicBlock,\n+    ) {\n         if A::Direction::is_forward() {\n-            if location.statement_index == 0 {\n-                self.prev_state.seek_to_block_start(location.block);\n-            } else {\n-                self.prev_state.seek_after_primary_effect(Location {\n-                    statement_index: location.statement_index - 1,\n-                    ..location\n-                });\n-            }\n-        } else {\n-            if location == results.body().terminator_loc(location.block) {\n-                self.prev_state.seek_to_block_end(location.block);\n-            } else {\n-                self.prev_state.seek_after_primary_effect(location.successor_within_block());\n-            }\n+            self.prev_state.clone_from(state);\n         }\n-\n-        write!(w, r#\"<td {fmt} balign=\"left\" align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_after_primary_effect(location);\n-        let curr_state = results.get();\n-        write_diff(&mut w, results.analysis(), self.prev_state.get(), curr_state)?;\n-        write!(w, \"</td>\")\n     }\n-}\n \n-/// Prints two state columns, one containing only the \"before\" effect of each statement and one\n-/// containing the full effect.\n-pub struct TwoPhaseDiff<T: Idx> {\n-    prev_state: BitSet<T>,\n-    prev_loc: Location,\n-}\n+    fn visit_block_end(\n+        &mut self,\n+        state: &Self::FlowState,\n+        _block_data: &'mir mir::BasicBlockData<'tcx>,\n+        _block: BasicBlock,\n+    ) {\n+        if A::Direction::is_backward() {\n+            self.prev_state.clone_from(state);\n+        }\n+    }\n \n-impl<T: Idx> TwoPhaseDiff<T> {\n-    pub fn new(bits_per_block: usize) -> Self {\n-        TwoPhaseDiff { prev_state: BitSet::new_empty(bits_per_block), prev_loc: Location::START }\n+    fn visit_statement_before_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        _statement: &'mir mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+        if let Some(before) = self.before.as_mut() {\n+            before.push(diff_pretty(state, &self.prev_state, self.analysis));\n+            self.prev_state.clone_from(state)\n+        }\n     }\n-}\n \n-impl<A> StateFormatter<'tcx, A> for TwoPhaseDiff<A::Idx>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    fn column_names(&self) -> &[&str] {\n-        &[\"BEFORE\", \" AFTER\"]\n+    fn visit_statement_after_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        _statement: &'mir mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+        self.after.push(diff_pretty(state, &self.prev_state, self.analysis));\n+        self.prev_state.clone_from(state)\n     }\n \n-    fn write_state_for_location(\n+    fn visit_terminator_before_primary_effect(\n         &mut self,\n-        mut w: &mut dyn io::Write,\n-        fmt: &str,\n-        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n-        location: Location,\n-    ) -> io::Result<()> {\n-        if location.statement_index == 0 {\n-            results.seek_to_block_entry(location.block);\n-            self.prev_state.overwrite(results.get());\n-        } else {\n-            // Ensure that we are visiting statements in order, so `prev_state` is correct.\n-            assert_eq!(self.prev_loc.successor_within_block(), location);\n+        state: &Self::FlowState,\n+        _terminator: &'mir mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+        if let Some(before) = self.before.as_mut() {\n+            before.push(diff_pretty(state, &self.prev_state, self.analysis));\n+            self.prev_state.clone_from(state)\n         }\n-\n-        self.prev_loc = location;\n-\n-        // Before\n-\n-        write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_before_primary_effect(location);\n-        let curr_state = results.get();\n-        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n-        self.prev_state.overwrite(curr_state);\n-        write!(w, \"</td>\")?;\n-\n-        // After\n-\n-        write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_after_primary_effect(location);\n-        let curr_state = results.get();\n-        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n-        self.prev_state.overwrite(curr_state);\n-        write!(w, \"</td>\")\n     }\n-}\n-\n-/// Prints the gen/kill set for the entire block.\n-pub struct BlockTransferFunc<'a, 'tcx, T: Idx> {\n-    body: &'a mir::Body<'tcx>,\n-    trans_for_block: IndexVec<BasicBlock, GenKillSet<T>>,\n-}\n \n-impl<T: Idx> BlockTransferFunc<'mir, 'tcx, T> {\n-    pub fn new(\n-        body: &'mir mir::Body<'tcx>,\n-        trans_for_block: IndexVec<BasicBlock, GenKillSet<T>>,\n-    ) -> Self {\n-        BlockTransferFunc { body, trans_for_block }\n+    fn visit_terminator_after_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        _terminator: &'mir mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+        self.after.push(diff_pretty(state, &self.prev_state, self.analysis));\n+        self.prev_state.clone_from(state)\n     }\n }\n \n-impl<A> StateFormatter<'tcx, A> for BlockTransferFunc<'mir, 'tcx, A::Idx>\n+fn diff_pretty<T, C>(new: T, old: T, ctxt: &C) -> String\n where\n-    A: Analysis<'tcx>,\n+    T: DebugWithContext<C>,\n {\n-    fn column_names(&self) -> &[&str] {\n-        &[\"GEN\", \"KILL\"]\n+    if new == old {\n+        return String::new();\n     }\n \n-    fn write_state_for_location(\n-        &mut self,\n-        mut w: &mut dyn io::Write,\n-        fmt: &str,\n-        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n-        location: Location,\n-    ) -> io::Result<()> {\n-        // Only print a single row.\n-        if location.statement_index != 0 {\n-            return Ok(());\n-        }\n+    let re = Regex::new(\"\\u{001f}([+-])\").unwrap();\n \n-        let block_trans = &self.trans_for_block[location.block];\n-        let rowspan = self.body.basic_blocks()[location.block].statements.len();\n+    let raw_diff = format!(\"{:#?}\", DebugDiffWithAdapter { new, old, ctxt });\n \n-        for set in &[&block_trans.gen, &block_trans.kill] {\n-            write!(\n-                w,\n-                r#\"<td {fmt} rowspan=\"{rowspan}\" balign=\"left\" align=\"left\">\"#,\n-                fmt = fmt,\n-                rowspan = rowspan\n-            )?;\n+    // Replace newlines in the `Debug` output with `<br/>`\n+    let raw_diff = raw_diff.replace('\\n', r#\"<br align=\"left\"/>\"#);\n \n-            pretty_print_state_elems(&mut w, results.analysis(), set.iter(), BR_LEFT, None)?;\n-            write!(w, \"</td>\")?;\n+    let mut inside_font_tag = false;\n+    let html_diff = re.replace_all(&raw_diff, |captures: &regex::Captures<'_>| {\n+        let mut ret = String::new();\n+        if inside_font_tag {\n+            ret.push_str(r#\"</font>\"#);\n         }\n \n-        Ok(())\n-    }\n-}\n-\n-/// Writes two lines, one containing the added bits and one the removed bits.\n-fn write_diff<A: Analysis<'tcx>>(\n-    w: &mut impl io::Write,\n-    analysis: &A,\n-    from: &BitSet<A::Idx>,\n-    to: &BitSet<A::Idx>,\n-) -> io::Result<()> {\n-    assert_eq!(from.domain_size(), to.domain_size());\n-    let len = from.domain_size();\n-\n-    let mut set = HybridBitSet::new_empty(len);\n-    let mut clear = HybridBitSet::new_empty(len);\n-\n-    // FIXME: Implement a lazy iterator over the symmetric difference of two bitsets.\n-    for i in (0..len).map(A::Idx::new) {\n-        match (from.contains(i), to.contains(i)) {\n-            (false, true) => set.insert(i),\n-            (true, false) => clear.insert(i),\n-            _ => continue,\n+        let tag = match &captures[1] {\n+            \"+\" => r#\"<font color=\"darkgreen\">+\"#,\n+            \"-\" => r#\"<font color=\"red\">-\"#,\n+            _ => unreachable!(),\n         };\n-    }\n-\n-    if !set.is_empty() {\n-        write!(w, r#\"<font color=\"darkgreen\">+\"#)?;\n-        pretty_print_state_elems(w, analysis, set.iter(), \", \", LIMIT_30_ALIGN_1)?;\n-        write!(w, r#\"</font>\"#)?;\n-    }\n-\n-    if !set.is_empty() && !clear.is_empty() {\n-        write!(w, \"{}\", BR_LEFT)?;\n-    }\n-\n-    if !clear.is_empty() {\n-        write!(w, r#\"<font color=\"red\">-\"#)?;\n-        pretty_print_state_elems(w, analysis, clear.iter(), \", \", LIMIT_30_ALIGN_1)?;\n-        write!(w, r#\"</font>\"#)?;\n-    }\n-\n-    Ok(())\n-}\n \n-const BR_LEFT: &str = r#\"<br align=\"left\"/>\"#;\n-const BR_LEFT_SPACE: &str = r#\"<br align=\"left\"/> \"#;\n+        inside_font_tag = true;\n+        ret.push_str(tag);\n+        ret\n+    });\n \n-/// Line break policy that breaks at 40 characters and starts the next line with a single space.\n-const LIMIT_30_ALIGN_1: Option<LineBreak> = Some(LineBreak { sequence: BR_LEFT_SPACE, limit: 30 });\n-\n-struct LineBreak {\n-    sequence: &'static str,\n-    limit: usize,\n-}\n-\n-/// Formats each `elem` using the pretty printer provided by `analysis` into a list with the given\n-/// separator (`sep`).\n-///\n-/// Optionally, it will break lines using the given character sequence (usually `<br/>`) and\n-/// character limit.\n-fn pretty_print_state_elems<A>(\n-    w: &mut impl io::Write,\n-    analysis: &A,\n-    elems: impl Iterator<Item = A::Idx>,\n-    sep: &str,\n-    line_break: Option<LineBreak>,\n-) -> io::Result<bool>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    let sep_width = sep.chars().count();\n-\n-    let mut buf = Vec::new();\n-\n-    let mut first = true;\n-    let mut curr_line_width = 0;\n-    let mut line_break_inserted = false;\n-\n-    for idx in elems {\n-        buf.clear();\n-        analysis.pretty_print_idx(&mut buf, idx)?;\n-        let idx_str =\n-            str::from_utf8(&buf).expect(\"Output of `pretty_print_idx` must be valid UTF-8\");\n-        let escaped = dot::escape_html(idx_str);\n-        let escaped_width = escaped.chars().count();\n-\n-        if first {\n-            first = false;\n-        } else {\n-            write!(w, \"{}\", sep)?;\n-            curr_line_width += sep_width;\n-\n-            if let Some(line_break) = &line_break {\n-                if curr_line_width + sep_width + escaped_width > line_break.limit {\n-                    write!(w, \"{}\", line_break.sequence)?;\n-                    line_break_inserted = true;\n-                    curr_line_width = 0;\n-                }\n-            }\n-        }\n+    let mut html_diff = match html_diff {\n+        Cow::Borrowed(_) => return raw_diff,\n+        Cow::Owned(s) => s,\n+    };\n \n-        write!(w, \"{}\", escaped)?;\n-        curr_line_width += escaped_width;\n+    if inside_font_tag {\n+        html_diff.push_str(\"</font>\");\n     }\n \n-    Ok(line_break_inserted)\n+    html_diff\n }\n \n /// The background color used for zebra-striping the table."}, {"sha": "9294e0cc453ede8b3d7c038e4d6733380c79b21c", "filename": "compiler/rustc_mir/src/dataflow/framework/lattice.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs?ref=3233fb18a891363a2da36ce69ca16fbb219c96be", "patch": "@@ -0,0 +1,196 @@\n+//! Traits used to represent [lattices] for use as the domain of a dataflow analysis.\n+//!\n+//! ## Implementation Notes\n+//!\n+//! Given that they represent partially ordered sets, you may be surprised that [`MeetSemiLattice`]\n+//! and [`JoinSemiLattice`] do not have [`PartialOrd`][std::cmp::PartialOrd] as a supertrait. This\n+//! is because most standard library types use lexicographic ordering instead of [set inclusion]\n+//! for their `PartialOrd` impl. Since we do not actually need to compare lattice elements to run a\n+//! dataflow analysis, there's no need for a hypothetical `SetInclusion` newtype with a custom\n+//! `PartialOrd` impl.  The only benefit would be the ability to check (in debug mode) that the\n+//! least upper (or greatest lower) bound returned by the lattice join (or meet) operator was in\n+//! fact greater (or lower) than the inputs.\n+//!\n+//! [lattices]: https://en.wikipedia.org/wiki/Lattice_(order)\n+//! [set inclusion]: https://en.wikipedia.org/wiki/Subset\n+\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::{Idx, IndexVec};\n+\n+/// A [partially ordered set][poset] that has a [least upper bound][lub] for any pair of elements\n+/// in the set.\n+///\n+/// [lub]: https://en.wikipedia.org/wiki/Infimum_and_supremum\n+/// [poset]: https://en.wikipedia.org/wiki/Partially_ordered_set\n+pub trait JoinSemiLattice: Eq {\n+    /// Computes the least upper bound of two elements, storing the result in `self` and returning\n+    /// `true` if `self` has changed.\n+    ///\n+    /// The lattice join operator is abbreviated as `\u2228`.\n+    fn join(&mut self, other: &Self) -> bool;\n+}\n+\n+/// A [partially ordered set][poset] that has a [greatest lower bound][glb] for any pair of\n+/// elements in the set.\n+///\n+/// Dataflow analyses only require that their domains implement [`JoinSemiLattice`], not\n+/// `MeetSemiLattice`. However, types that will be used as dataflow domains should implement both\n+/// so that they can be used with [`Dual`].\n+///\n+/// [glb]: https://en.wikipedia.org/wiki/Infimum_and_supremum\n+/// [poset]: https://en.wikipedia.org/wiki/Partially_ordered_set\n+pub trait MeetSemiLattice: Eq {\n+    /// Computes the greatest lower bound of two elements, storing the result in `self` and\n+    /// returning `true` if `self` has changed.\n+    ///\n+    /// The lattice meet operator is abbreviated as `\u2227`.\n+    fn meet(&mut self, other: &Self) -> bool;\n+}\n+\n+/// A `bool` is a \"two-point\" lattice with `true` as the top element and `false` as the bottom.\n+impl JoinSemiLattice for bool {\n+    fn join(&mut self, other: &Self) -> bool {\n+        if let (false, true) = (*self, *other) {\n+            *self = true;\n+            return true;\n+        }\n+\n+        false\n+    }\n+}\n+\n+impl MeetSemiLattice for bool {\n+    fn meet(&mut self, other: &Self) -> bool {\n+        if let (true, false) = (*self, *other) {\n+            *self = false;\n+            return true;\n+        }\n+\n+        false\n+    }\n+}\n+\n+/// A tuple or list of lattices is itself a lattice whose least upper bound is the concatenation of\n+/// the least upper bounds of each element of the tuple or list.\n+impl<I: Idx, T: JoinSemiLattice> JoinSemiLattice for IndexVec<I, T> {\n+    fn join(&mut self, other: &Self) -> bool {\n+        assert_eq!(self.len(), other.len());\n+\n+        let mut changed = false;\n+        for (a, b) in self.iter_mut().zip(other.iter()) {\n+            changed |= a.join(b);\n+        }\n+        changed\n+    }\n+}\n+\n+impl<I: Idx, T: MeetSemiLattice> MeetSemiLattice for IndexVec<I, T> {\n+    fn meet(&mut self, other: &Self) -> bool {\n+        assert_eq!(self.len(), other.len());\n+\n+        let mut changed = false;\n+        for (a, b) in self.iter_mut().zip(other.iter()) {\n+            changed |= a.meet(b);\n+        }\n+        changed\n+    }\n+}\n+\n+/// A `BitSet` is an efficent way to store a tuple of \"two-point\" lattices. Equivalently, it is the\n+/// lattice corresponding to the powerset of the set of all possibe values of the index type `T`\n+/// ordered by inclusion.\n+impl<T: Idx> JoinSemiLattice for BitSet<T> {\n+    fn join(&mut self, other: &Self) -> bool {\n+        self.union(other)\n+    }\n+}\n+\n+impl<T: Idx> MeetSemiLattice for BitSet<T> {\n+    fn meet(&mut self, other: &Self) -> bool {\n+        self.intersect(other)\n+    }\n+}\n+\n+/// The counterpart of a given semilattice `T` using the [inverse order].\n+///\n+/// The dual of a join-semilattice is a meet-semilattice and vice versa. For example, the dual of a\n+/// powerset has the empty set as its top element and the full set as its bottom element and uses\n+/// set *intersection* as its join operator.\n+///\n+/// [inverse order]: https://en.wikipedia.org/wiki/Duality_(order_theory)\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub struct Dual<T>(pub T);\n+\n+impl<T> std::borrow::Borrow<T> for Dual<T> {\n+    fn borrow(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+impl<T> std::borrow::BorrowMut<T> for Dual<T> {\n+    fn borrow_mut(&mut self) -> &mut T {\n+        &mut self.0\n+    }\n+}\n+\n+impl<T: MeetSemiLattice> JoinSemiLattice for Dual<T> {\n+    fn join(&mut self, other: &Self) -> bool {\n+        self.0.meet(&other.0)\n+    }\n+}\n+\n+impl<T: JoinSemiLattice> MeetSemiLattice for Dual<T> {\n+    fn meet(&mut self, other: &Self) -> bool {\n+        self.0.join(&other.0)\n+    }\n+}\n+\n+/// Extends a type `T` with top and bottom elements to make it a partially ordered set in which no\n+/// value of `T` is comparable with any other. A flat set has the following [Hasse\n+/// diagram](https://en.wikipedia.org/wiki/Hasse_diagram):\n+///\n+/// ```text\n+///         top\n+///       / /  \\ \\\n+/// all possible values of `T`\n+///       \\ \\  / /\n+///        bottom\n+/// ```\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum FlatSet<T> {\n+    Bottom,\n+    Elem(T),\n+    Top,\n+}\n+\n+impl<T: Clone + Eq> JoinSemiLattice for FlatSet<T> {\n+    fn join(&mut self, other: &Self) -> bool {\n+        let result = match (&*self, other) {\n+            (Self::Top, _) | (_, Self::Bottom) => return false,\n+            (Self::Elem(a), Self::Elem(b)) if a == b => return false,\n+\n+            (Self::Bottom, Self::Elem(x)) => Self::Elem(x.clone()),\n+\n+            _ => Self::Top,\n+        };\n+\n+        *self = result;\n+        true\n+    }\n+}\n+\n+impl<T: Clone + Eq> MeetSemiLattice for FlatSet<T> {\n+    fn meet(&mut self, other: &Self) -> bool {\n+        let result = match (&*self, other) {\n+            (Self::Bottom, _) | (_, Self::Top) => return false,\n+            (Self::Elem(ref a), Self::Elem(ref b)) if a == b => return false,\n+\n+            (Self::Top, Self::Elem(ref x)) => Self::Elem(x.clone()),\n+\n+            _ => Self::Bottom,\n+        };\n+\n+        *self = result;\n+        true\n+    }\n+}"}, {"sha": "eba3b88d47ef9258b67063dea6a93144b00605f2", "filename": "compiler/rustc_mir/src/dataflow/framework/mod.rs", "status": "modified", "additions": 38, "deletions": 75, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs?ref=3233fb18a891363a2da36ce69ca16fbb219c96be", "patch": "@@ -30,8 +30,8 @@\n //!\n //! [gen-kill]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n \n+use std::borrow::BorrowMut;\n use std::cmp::Ordering;\n-use std::io;\n \n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n@@ -43,67 +43,24 @@ use rustc_target::abi::VariantIdx;\n mod cursor;\n mod direction;\n mod engine;\n+pub mod fmt;\n mod graphviz;\n+pub mod lattice;\n mod visitor;\n \n pub use self::cursor::{ResultsCursor, ResultsRefCursor};\n pub use self::direction::{Backward, Direction, Forward};\n pub use self::engine::{Engine, Results};\n+pub use self::lattice::{JoinSemiLattice, MeetSemiLattice};\n pub use self::visitor::{visit_results, ResultsVisitor};\n pub use self::visitor::{BorrowckFlowState, BorrowckResults};\n \n-/// Parameterization for the precise form of data flow that is used.\n-///\n-/// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n-/// This also determines the semantics of the lattice `join` operator used to merge dataflow\n-/// results, since dataflow works by starting at the bottom and moving monotonically to a fixed\n-/// point.\n-///\n-/// This means, for propagation across the graph, that you either want to start at all-zeroes and\n-/// then use Union as your merge when propagating, or you start at all-ones and then use Intersect\n-/// as your merge when propagating.\n-pub trait BottomValue {\n-    /// Specifies the initial value for each bit in the entry set for each basic block.\n-    const BOTTOM_VALUE: bool;\n-\n-    /// Merges `in_set` into `inout_set`, returning `true` if `inout_set` changed.\n-    ///\n-    /// It is almost certainly wrong to override this, since it automatically applies\n-    /// * `inout_set & in_set` if `BOTTOM_VALUE == true`\n-    /// * `inout_set | in_set` if `BOTTOM_VALUE == false`\n-    ///\n-    /// This means that if a bit is not `BOTTOM_VALUE`, it is propagated into all target blocks.\n-    /// For clarity, the above statement again from a different perspective:\n-    /// A bit in the block's entry set is `!BOTTOM_VALUE` if *any* predecessor block's bit value is\n-    /// `!BOTTOM_VALUE`.\n-    ///\n-    /// There are situations where you want the opposite behaviour: propagate only if *all*\n-    /// predecessor blocks's value is `!BOTTOM_VALUE`.\n-    /// E.g. if you want to know whether a bit is *definitely* set at a specific location. This\n-    /// means that all code paths leading to the location must have set the bit, instead of any\n-    /// code path leading there.\n-    ///\n-    /// If you want this kind of \"definitely set\" analysis, you need to\n-    /// 1. Invert `BOTTOM_VALUE`\n-    /// 2. Reset the `entry_set` in `start_block_effect` to `!BOTTOM_VALUE`\n-    /// 3. Override `join` to do the opposite from what it's doing now.\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        if !Self::BOTTOM_VALUE { inout_set.union(in_set) } else { inout_set.intersect(in_set) }\n-    }\n-}\n-\n /// Define the domain of a dataflow problem.\n ///\n-/// This trait specifies the lattice on which this analysis operates. For now, this must be a\n-/// powerset of values of type `Idx`. The elements of this lattice are represented with a `BitSet`\n-/// and referred to as the state vector.\n-///\n-/// This trait also defines the initial value for the dataflow state upon entry to the\n-/// `START_BLOCK`, as well as some names used to refer to this analysis when debugging.\n-pub trait AnalysisDomain<'tcx>: BottomValue {\n-    /// The type of the elements in the state vector.\n-    type Idx: Idx;\n+/// This trait specifies the lattice on which this analysis operates (the domain) as well as its\n+/// initial value at the entry point of each basic block.\n+pub trait AnalysisDomain<'tcx> {\n+    type Domain: Clone + JoinSemiLattice;\n \n     /// The direction of this analyis. Either `Forward` or `Backward`.\n     type Direction: Direction = Forward;\n@@ -114,8 +71,7 @@ pub trait AnalysisDomain<'tcx>: BottomValue {\n     /// suitable as part of a filename.\n     const NAME: &'static str;\n \n-    /// The size of the state vector.\n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain;\n \n     /// Mutates the entry set of the `START_BLOCK` to contain the initial state for dataflow\n     /// analysis.\n@@ -126,20 +82,15 @@ pub trait AnalysisDomain<'tcx>: BottomValue {\n     // FIXME: For backward dataflow analyses, the initial state should be applied to every basic\n     // block where control flow could exit the MIR body (e.g., those terminated with `return` or\n     // `resume`). It's not obvious how to handle `yield` points in generators, however.\n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>);\n-\n-    /// Prints an element in the state vector for debugging.\n-    fn pretty_print_idx(&self, w: &mut impl io::Write, idx: Self::Idx) -> io::Result<()> {\n-        write!(w, \"{:?}\", idx)\n-    }\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut Self::Domain);\n }\n \n /// A dataflow problem with an arbitrarily complex transfer function.\n pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// Updates the current dataflow state with the effect of evaluating a statement.\n     fn apply_statement_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         statement: &mir::Statement<'tcx>,\n         location: Location,\n     );\n@@ -152,7 +103,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// analyses should not implement this without implementing `apply_statement_effect`.\n     fn apply_before_statement_effect(\n         &self,\n-        _state: &mut BitSet<Self::Idx>,\n+        _state: &mut Self::Domain,\n         _statement: &mir::Statement<'tcx>,\n         _location: Location,\n     ) {\n@@ -166,7 +117,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// initialized here.\n     fn apply_terminator_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     );\n@@ -179,7 +130,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// analyses should not implement this without implementing `apply_terminator_effect`.\n     fn apply_before_terminator_effect(\n         &self,\n-        _state: &mut BitSet<Self::Idx>,\n+        _state: &mut Self::Domain,\n         _terminator: &mir::Terminator<'tcx>,\n         _location: Location,\n     ) {\n@@ -192,7 +143,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// edges.\n     fn apply_call_return_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         block: BasicBlock,\n         func: &mir::Operand<'tcx>,\n         args: &[mir::Operand<'tcx>],\n@@ -207,7 +158,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// By default, no effects happen.\n     fn apply_yield_resume_effect(\n         &self,\n-        _state: &mut BitSet<Self::Idx>,\n+        _state: &mut Self::Domain,\n         _resume_block: BasicBlock,\n         _resume_place: mir::Place<'tcx>,\n     ) {\n@@ -222,7 +173,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     /// FIXME: This class of effects is not supported for backward dataflow analyses.\n     fn apply_discriminant_switch_effect(\n         &self,\n-        _state: &mut BitSet<Self::Idx>,\n+        _state: &mut Self::Domain,\n         _block: BasicBlock,\n         _enum_place: mir::Place<'tcx>,\n         _adt: &ty::AdtDef,\n@@ -264,6 +215,8 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n ///\n /// `Analysis` is automatically implemented for all implementers of `GenKillAnalysis`.\n pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n+    type Idx: Idx;\n+\n     /// See `Analysis::apply_statement_effect`.\n     fn statement_effect(\n         &self,\n@@ -332,10 +285,11 @@ pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n impl<A> Analysis<'tcx> for A\n where\n     A: GenKillAnalysis<'tcx>,\n+    A::Domain: GenKill<A::Idx> + BorrowMut<BitSet<A::Idx>>,\n {\n     fn apply_statement_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n@@ -344,7 +298,7 @@ where\n \n     fn apply_before_statement_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n@@ -353,7 +307,7 @@ where\n \n     fn apply_terminator_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n@@ -362,7 +316,7 @@ where\n \n     fn apply_before_terminator_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n@@ -371,7 +325,7 @@ where\n \n     fn apply_call_return_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         func: &mir::Operand<'tcx>,\n         args: &[mir::Operand<'tcx>],\n@@ -382,7 +336,7 @@ where\n \n     fn apply_yield_resume_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         resume_block: BasicBlock,\n         resume_place: mir::Place<'tcx>,\n     ) {\n@@ -391,7 +345,7 @@ where\n \n     fn apply_discriminant_switch_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut A::Domain,\n         block: BasicBlock,\n         enum_place: mir::Place<'tcx>,\n         adt: &ty::AdtDef,\n@@ -450,7 +404,7 @@ pub trait GenKill<T> {\n /// applied multiple times efficiently. When there are multiple calls to `gen` and/or `kill` for\n /// the same element, the most recent one takes precedence.\n #[derive(Clone)]\n-pub struct GenKillSet<T: Idx> {\n+pub struct GenKillSet<T> {\n     gen: HybridBitSet<T>,\n     kill: HybridBitSet<T>,\n }\n@@ -464,7 +418,6 @@ impl<T: Idx> GenKillSet<T> {\n         }\n     }\n \n-    /// Applies this transfer function to the given state vector.\n     pub fn apply(&self, state: &mut BitSet<T>) {\n         state.union(&self.gen);\n         state.subtract(&self.kill);\n@@ -493,6 +446,16 @@ impl<T: Idx> GenKill<T> for BitSet<T> {\n     }\n }\n \n+impl<T: Idx> GenKill<T> for lattice::Dual<BitSet<T>> {\n+    fn gen(&mut self, elem: T) {\n+        self.0.insert(elem);\n+    }\n+\n+    fn kill(&mut self, elem: T) {\n+        self.0.remove(elem);\n+    }\n+}\n+\n // NOTE: DO NOT CHANGE VARIANT ORDER. The derived `Ord` impls rely on the current order.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Effect {"}, {"sha": "a5989121679c4fa8fb2014cd9910581e30520a48", "filename": "compiler/rustc_mir/src/dataflow/framework/tests.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Ftests.rs?ref=3233fb18a891363a2da36ce69ca16fbb219c96be", "patch": "@@ -9,7 +9,6 @@ use rustc_middle::ty;\n use rustc_span::DUMMY_SP;\n \n use super::*;\n-use crate::dataflow::BottomValue;\n \n /// Creates a `mir::Body` with a few disconnected basic blocks.\n ///\n@@ -92,13 +91,13 @@ impl<D: Direction> MockAnalysis<'tcx, D> {\n     /// The entry set for each `BasicBlock` is the ID of that block offset by a fixed amount to\n     /// avoid colliding with the statement/terminator effects.\n     fn mock_entry_set(&self, bb: BasicBlock) -> BitSet<usize> {\n-        let mut ret = BitSet::new_empty(self.bits_per_block(self.body));\n+        let mut ret = self.bottom_value(self.body);\n         ret.insert(Self::BASIC_BLOCK_OFFSET + bb.index());\n         ret\n     }\n \n     fn mock_entry_sets(&self) -> IndexVec<BasicBlock, BitSet<usize>> {\n-        let empty = BitSet::new_empty(self.bits_per_block(self.body));\n+        let empty = self.bottom_value(self.body);\n         let mut ret = IndexVec::from_elem(empty, &self.body.basic_blocks());\n \n         for (bb, _) in self.body.basic_blocks().iter_enumerated() {\n@@ -130,7 +129,7 @@ impl<D: Direction> MockAnalysis<'tcx, D> {\n     /// would be `[102, 0, 1, 2, 3, 4]`.\n     fn expected_state_at_target(&self, target: SeekTarget) -> BitSet<usize> {\n         let block = target.block();\n-        let mut ret = BitSet::new_empty(self.bits_per_block(self.body));\n+        let mut ret = self.bottom_value(self.body);\n         ret.insert(Self::BASIC_BLOCK_OFFSET + block.index());\n \n         let target = match target {\n@@ -161,29 +160,25 @@ impl<D: Direction> MockAnalysis<'tcx, D> {\n     }\n }\n \n-impl<D: Direction> BottomValue for MockAnalysis<'tcx, D> {\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n impl<D: Direction> AnalysisDomain<'tcx> for MockAnalysis<'tcx, D> {\n-    type Idx = usize;\n+    type Domain = BitSet<usize>;\n     type Direction = D;\n \n     const NAME: &'static str = \"mock\";\n \n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n-        Self::BASIC_BLOCK_OFFSET + body.basic_blocks().len()\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        BitSet::new_empty(Self::BASIC_BLOCK_OFFSET + body.basic_blocks().len())\n     }\n \n-    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut Self::Domain) {\n         unimplemented!(\"This is never called since `MockAnalysis` is never iterated to fixpoint\");\n     }\n }\n \n impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n     fn apply_statement_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         _statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n@@ -193,7 +188,7 @@ impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n \n     fn apply_before_statement_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         _statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n@@ -203,7 +198,7 @@ impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n \n     fn apply_terminator_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         _terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n@@ -213,7 +208,7 @@ impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n \n     fn apply_before_terminator_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n+        state: &mut Self::Domain,\n         _terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n@@ -223,7 +218,7 @@ impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n \n     fn apply_call_return_effect(\n         &self,\n-        _state: &mut BitSet<Self::Idx>,\n+        _state: &mut Self::Domain,\n         _block: BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],"}, {"sha": "82eb734ed0699a2ae00f18635b59c9414cf552a3", "filename": "compiler/rustc_mir/src/dataflow/framework/visitor.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fvisitor.rs?ref=3233fb18a891363a2da36ce69ca16fbb219c96be", "patch": "@@ -1,4 +1,3 @@\n-use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Location};\n \n use super::{Analysis, Direction, Results};\n@@ -139,16 +138,16 @@ impl<'tcx, A> ResultsVisitable<'tcx> for Results<'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n-    type FlowState = BitSet<A::Idx>;\n+    type FlowState = A::Domain;\n \n     type Direction = A::Direction;\n \n     fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n-        BitSet::new_empty(self.analysis.bits_per_block(body))\n+        self.analysis.bottom_value(body)\n     }\n \n     fn reset_to_block_entry(&self, state: &mut Self::FlowState, block: BasicBlock) {\n-        state.overwrite(&self.entry_set_for_block(block));\n+        state.clone_from(&self.entry_set_for_block(block));\n     }\n \n     fn reconstruct_before_statement_effect(\n@@ -217,11 +216,11 @@ macro_rules! impl_visitable {\n             $( $A: Analysis<'tcx, Direction = D>, )*\n         {\n             type Direction = D;\n-            type FlowState = $T<$( BitSet<$A::Idx> ),*>;\n+            type FlowState = $T<$( $A::Domain ),*>;\n \n             fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n                 $T {\n-                    $( $field: BitSet::new_empty(self.$field.analysis.bits_per_block(body)) ),*\n+                    $( $field: self.$field.analysis.bottom_value(body) ),*\n                 }\n             }\n \n@@ -230,7 +229,7 @@ macro_rules! impl_visitable {\n                 state: &mut Self::FlowState,\n                 block: BasicBlock,\n             ) {\n-                $( state.$field.overwrite(&self.$field.entry_set_for_block(block)); )*\n+                $( state.$field.clone_from(&self.$field.entry_set_for_block(block)); )*\n             }\n \n             fn reconstruct_before_statement_effect("}, {"sha": "5575a97982fc4e34bebb5d9db48e1754b7f208bd", "filename": "compiler/rustc_mir/src/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmod.rs?ref=3233fb18a891363a2da36ce69ca16fbb219c96be", "patch": "@@ -5,9 +5,9 @@ use rustc_span::symbol::{sym, Symbol};\n \n pub(crate) use self::drop_flag_effects::*;\n pub use self::framework::{\n-    visit_results, Analysis, AnalysisDomain, Backward, BorrowckFlowState, BorrowckResults,\n-    BottomValue, Engine, Forward, GenKill, GenKillAnalysis, Results, ResultsCursor,\n-    ResultsRefCursor, ResultsVisitor,\n+    fmt, lattice, visit_results, Analysis, AnalysisDomain, Backward, BorrowckFlowState,\n+    BorrowckResults, Engine, Forward, GenKill, GenKillAnalysis, JoinSemiLattice, Results,\n+    ResultsCursor, ResultsRefCursor, ResultsVisitor,\n };\n \n use self::move_paths::MoveData;"}, {"sha": "42717f273843aa4196ff0aaacd2cd18e901ecd22", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3233fb18a891363a2da36ce69ca16fbb219c96be/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=3233fb18a891363a2da36ce69ca16fbb219c96be", "patch": "@@ -14,6 +14,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(drain_filter)]\n+#![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n #![feature(iter_order_by)]\n #![feature(never_type)]"}]}