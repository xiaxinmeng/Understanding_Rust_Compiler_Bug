{"sha": "0d03fe6ef57d3956e92382e0e1f1a916015191cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMDNmZTZlZjU3ZDM5NTZlOTIzODJlMGUxZjFhOTE2MDE1MTkxY2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-13T17:28:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-13T17:28:22Z"}, "message": "Merge #5971\n\n5971: Implement async blocks r=flodiebold a=oxalica\n\nFix #4018\r\n\r\n@flodiebold already gave a generic guide in the issue. Here's some concern about implementation detail:\r\n- Chalk doesn't support generator type yet.\r\n- Adding generator type as a brand new type (ctor) can be complex and need to *re-introduced* builtin impls. (Like how we implement closures before native closure support of chalk, which is already removed in #5401 )\r\n- The output type of async block should be known after type inference of the whole body.\r\n  - We cannot directly get the type from source like return-positon-impl-trait. But we still need to provide trait bounds when chalk asking for `opaque_ty_data`.\r\n  - During the inference, the output type of async block can be temporary unknown and participate the later inference.\r\n    `let a = async { None }; let _: i32 = a.await.unwrap();`\r\n\r\nSo in this PR, the type of async blocks is inferred as an opaque type parameterized by the `Future::Output` type it should be, like what we do with closure type.\r\nAnd it really works now.\r\n\r\nWell, I still have some questions:\r\n- The bounds `AsyncBlockImplType<T>: Future<Output = T>` is currently generated in `opaque_ty_data`. I'm not sure if we should put this code here.\r\n- Type of async block is now rendered as `impl Future<Output = OutputType>`. Do we need to special display to hint that it's a async block? Note that closure type has its special format, instead of `impl Fn(..) -> ..` or function type.\r\n\r\n\n\nCo-authored-by: oxalica <oxalicc@pm.me>", "tree": {"sha": "02d51d9e08c50812b895e5b5d1b2fc30ff9150d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02d51d9e08c50812b895e5b5d1b2fc30ff9150d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d03fe6ef57d3956e92382e0e1f1a916015191cb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfXla2CRBK7hj4Ov3rIwAAdHIIAFv//mygToKsFmurUfPaZKIc\nQfzg+uaiGwFYLujzhtiyiOKifqnfZUL5QiBunWaGhZEfa6AYuBPznZ8nG0Pm58Dx\n3PvxOEdkUAC7F8635x2v44B6ng12mOXd4yl7D5XdehAF5VH9/sF6LnpZ+52wlY8O\n3mANLJkw5ybDEDz+77oGeQiSPByCQ2knmaBqHbjrdK/AjXoCmWHIJOlNiKVKoI5f\ntUsNA5AxO0VJA12albq2YNcRy93xmilqcRlUSJEub5Pln8Z5r4G+jQvG6+zdINtn\n8/3vEkUgJ4a+6UWKkbNO5uUamRraqW42q53nx3u2/3vzYmE+cV0mMOh0FLLSSb8=\n=UWh1\n-----END PGP SIGNATURE-----\n", "payload": "tree 02d51d9e08c50812b895e5b5d1b2fc30ff9150d6\nparent fda6937d7f91dc723229d1045d9a57b22a846dc7\nparent 529c369c9bc15a73e7a03260eca84ccef99ac281\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1600018102 +0000\ncommitter GitHub <noreply@github.com> 1600018102 +0000\n\nMerge #5971\n\n5971: Implement async blocks r=flodiebold a=oxalica\n\nFix #4018\r\n\r\n@flodiebold already gave a generic guide in the issue. Here's some concern about implementation detail:\r\n- Chalk doesn't support generator type yet.\r\n- Adding generator type as a brand new type (ctor) can be complex and need to *re-introduced* builtin impls. (Like how we implement closures before native closure support of chalk, which is already removed in #5401 )\r\n- The output type of async block should be known after type inference of the whole body.\r\n  - We cannot directly get the type from source like return-positon-impl-trait. But we still need to provide trait bounds when chalk asking for `opaque_ty_data`.\r\n  - During the inference, the output type of async block can be temporary unknown and participate the later inference.\r\n    `let a = async { None }; let _: i32 = a.await.unwrap();`\r\n\r\nSo in this PR, the type of async blocks is inferred as an opaque type parameterized by the `Future::Output` type it should be, like what we do with closure type.\r\nAnd it really works now.\r\n\r\nWell, I still have some questions:\r\n- The bounds `AsyncBlockImplType<T>: Future<Output = T>` is currently generated in `opaque_ty_data`. I'm not sure if we should put this code here.\r\n- Type of async block is now rendered as `impl Future<Output = OutputType>`. Do we need to special display to hint that it's a async block? Note that closure type has its special format, instead of `impl Fn(..) -> ..` or function type.\r\n\r\n\n\nCo-authored-by: oxalica <oxalicc@pm.me>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d03fe6ef57d3956e92382e0e1f1a916015191cb", "html_url": "https://github.com/rust-lang/rust/commit/0d03fe6ef57d3956e92382e0e1f1a916015191cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d03fe6ef57d3956e92382e0e1f1a916015191cb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fda6937d7f91dc723229d1045d9a57b22a846dc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fda6937d7f91dc723229d1045d9a57b22a846dc7", "html_url": "https://github.com/rust-lang/rust/commit/fda6937d7f91dc723229d1045d9a57b22a846dc7"}, {"sha": "529c369c9bc15a73e7a03260eca84ccef99ac281", "url": "https://api.github.com/repos/rust-lang/rust/commits/529c369c9bc15a73e7a03260eca84ccef99ac281", "html_url": "https://github.com/rust-lang/rust/commit/529c369c9bc15a73e7a03260eca84ccef99ac281"}], "stats": {"total": 369, "additions": 314, "deletions": 55}, "files": [{"sha": "7a9747fc71024968b4d39875c990b61963317405", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -1283,6 +1283,8 @@ impl Type {\n     /// Checks that particular type `ty` implements `std::future::Future`.\n     /// This function is used in `.await` syntax completion.\n     pub fn impls_future(&self, db: &dyn HirDatabase) -> bool {\n+        // No special case for the type of async block, since Chalk can figure it out.\n+\n         let krate = self.krate;\n \n         let std_future_trait =\n@@ -1600,6 +1602,11 @@ impl Type {\n                                 cb(type_.derived(ty.clone()));\n                             }\n                         }\n+                        TypeCtor::OpaqueType(..) => {\n+                            if let Some(bounds) = ty.impl_trait_bounds(db) {\n+                                walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n+                            }\n+                        }\n                         _ => (),\n                     }\n "}, {"sha": "2d91bb21f59fc71f4ce8175be7af1e7bd0501b4c", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -239,7 +239,10 @@ impl ExprCollector<'_> {\n                     None => self.missing_expr(),\n                 },\n                 // FIXME: we need to record these effects somewhere...\n-                ast::Effect::Async(_) => self.collect_block_opt(e.block_expr()),\n+                ast::Effect::Async(_) => {\n+                    let body = self.collect_block_opt(e.block_expr());\n+                    self.alloc_expr(Expr::Async { body }, syntax_ptr)\n+                }\n             },\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {"}, {"sha": "e5d740a3653a46f861371ac995aa72b31b1107a9", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -111,6 +111,9 @@ pub enum Expr {\n     TryBlock {\n         body: ExprId,\n     },\n+    Async {\n+        body: ExprId,\n+    },\n     Cast {\n         expr: ExprId,\n         type_ref: TypeRef,\n@@ -250,7 +253,7 @@ impl Expr {\n                     f(*expr);\n                 }\n             }\n-            Expr::TryBlock { body } | Expr::Unsafe { body } => f(*body),\n+            Expr::TryBlock { body } | Expr::Unsafe { body } | Expr::Async { body } => f(*body),\n             Expr::Loop { body, .. } => f(*body),\n             Expr::While { condition, body, .. } => {\n                 f(*condition);"}, {"sha": "efb48c7ee4bdece7ef7994793cac12db890f323c", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -381,19 +381,24 @@ impl HirDisplay for ApplicationTy {\n                 }\n             }\n             TypeCtor::OpaqueType(opaque_ty_id) => {\n-                let bounds = match opaque_ty_id {\n+                match opaque_ty_id {\n                     OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n                             f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        data.subst(&self.parameters)\n+                        let bounds = data.subst(&self.parameters);\n+                        write!(f, \"impl \")?;\n+                        write_bounds_like_dyn_trait(&bounds.value, f)?;\n+                        // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n                     }\n-                };\n-                write!(f, \"impl \")?;\n-                write_bounds_like_dyn_trait(&bounds.value, f)?;\n-                // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n+                    OpaqueTyId::AsyncBlockTypeImplTrait(..) => {\n+                        write!(f, \"impl Future<Output = \")?;\n+                        self.parameters[0].hir_fmt(f)?;\n+                        write!(f, \">\")?;\n+                    }\n+                }\n             }\n             TypeCtor::Closure { .. } => {\n                 let sig = self.parameters[0].callable_sig(f.db);\n@@ -474,18 +479,21 @@ impl HirDisplay for Ty {\n                 write_bounds_like_dyn_trait(predicates, f)?;\n             }\n             Ty::Opaque(opaque_ty) => {\n-                let bounds = match opaque_ty.opaque_ty_id {\n+                match opaque_ty.opaque_ty_id {\n                     OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n                             f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        data.subst(&opaque_ty.parameters)\n+                        let bounds = data.subst(&opaque_ty.parameters);\n+                        write!(f, \"impl \")?;\n+                        write_bounds_like_dyn_trait(&bounds.value, f)?;\n+                    }\n+                    OpaqueTyId::AsyncBlockTypeImplTrait(..) => {\n+                        write!(f, \"{{async block}}\")?;\n                     }\n                 };\n-                write!(f, \"impl \")?;\n-                write_bounds_like_dyn_trait(&bounds.value, f)?;\n             }\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n             Ty::Infer(..) => write!(f, \"_\")?,"}, {"sha": "0a141b9cb947276183f348d5d8663d99f3dad9c0", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -17,8 +17,8 @@ use crate::{\n     autoderef, method_resolution, op,\n     traits::{FnTrait, InEnvironment},\n     utils::{generics, variant_data, Generics},\n-    ApplicationTy, Binders, CallableDefId, InferTy, IntTy, Mutability, Obligation, Rawness, Substs,\n-    TraitRef, Ty, TypeCtor,\n+    ApplicationTy, Binders, CallableDefId, InferTy, IntTy, Mutability, Obligation, OpaqueTyId,\n+    Rawness, Substs, TraitRef, Ty, TypeCtor,\n };\n \n use super::{\n@@ -146,6 +146,13 @@ impl<'a> InferenceContext<'a> {\n                 // FIXME should be std::result::Result<{inner}, _>\n                 Ty::Unknown\n             }\n+            Expr::Async { body } => {\n+                // Use the first type parameter as the output type of future.\n+                // existenail type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n+                let inner_ty = self.infer_expr(*body, &Expectation::none());\n+                let opaque_ty_id = OpaqueTyId::AsyncBlockTypeImplTrait(self.owner, *body);\n+                Ty::apply_one(TypeCtor::OpaqueType(opaque_ty_id), inner_ty)\n+            }\n             Expr::Loop { body, label } => {\n                 self.breakables.push(BreakableContext {\n                     may_break: false,"}, {"sha": "f16d1fc979f0bd8fe1848da57b381d78874bb2e3", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -129,8 +129,9 @@ pub enum TypeCtor {\n \n     /// This represents a placeholder for an opaque type in situations where we\n     /// don't know the hidden type (i.e. currently almost always). This is\n-    /// analogous to the `AssociatedType` type constructor. As with that one,\n-    /// these are only produced by Chalk.\n+    /// analogous to the `AssociatedType` type constructor.\n+    /// It is also used as the type of async block, with one type parameter\n+    /// representing the Future::Output type.\n     OpaqueType(OpaqueTyId),\n \n     /// The type of a specific closure.\n@@ -173,6 +174,8 @@ impl TypeCtor {\n                         let generic_params = generics(db.upcast(), func.into());\n                         generic_params.len()\n                     }\n+                    // 1 param representing Future::Output type.\n+                    OpaqueTyId::AsyncBlockTypeImplTrait(..) => 1,\n                 }\n             }\n             TypeCtor::FnPtr { num_args, is_varargs: _ } => num_args as usize + 1,\n@@ -205,6 +208,7 @@ impl TypeCtor {\n                 OpaqueTyId::ReturnTypeImplTrait(func, _) => {\n                     Some(func.lookup(db.upcast()).module(db.upcast()).krate)\n                 }\n+                OpaqueTyId::AsyncBlockTypeImplTrait(def, _) => Some(def.module(db.upcast()).krate),\n             },\n         }\n     }\n@@ -843,6 +847,29 @@ impl Ty {\n \n     pub fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<GenericPredicate>> {\n         match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::OpaqueType(opaque_ty_id), .. }) => {\n+                match opaque_ty_id {\n+                    OpaqueTyId::AsyncBlockTypeImplTrait(def, _expr) => {\n+                        let krate = def.module(db.upcast()).krate;\n+                        if let Some(future_trait) = db\n+                            .lang_item(krate, \"future_trait\".into())\n+                            .and_then(|item| item.as_trait())\n+                        {\n+                            // This is only used by type walking.\n+                            // Parameters will be walked outside, and projection predicate is not used.\n+                            // So just provide the Future trait.\n+                            let impl_bound = GenericPredicate::Implemented(TraitRef {\n+                                trait_: future_trait,\n+                                substs: Substs::empty(),\n+                            });\n+                            Some(vec![impl_bound])\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    OpaqueTyId::ReturnTypeImplTrait(..) => None,\n+                }\n+            }\n             Ty::Opaque(opaque_ty) => {\n                 let predicates = match opaque_ty.opaque_ty_id {\n                     OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n@@ -853,6 +880,8 @@ impl Ty {\n                             data.subst(&opaque_ty.parameters)\n                         })\n                     }\n+                    // It always has an parameter for Future::Output type.\n+                    OpaqueTyId::AsyncBlockTypeImplTrait(..) => unreachable!(),\n                 };\n \n                 predicates.map(|it| it.value)\n@@ -1065,6 +1094,7 @@ impl<T: TypeWalk> TypeWalk for Vec<T> {\n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub enum OpaqueTyId {\n     ReturnTypeImplTrait(hir_def::FunctionId, u16),\n+    AsyncBlockTypeImplTrait(hir_def::DefWithBodyId, ExprId),\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]"}, {"sha": "5b07948f3da5bf6b70befe7874d5b4944c50d7f3", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -1889,31 +1889,40 @@ fn fn_pointer_return() {\n fn effects_smoke_test() {\n     check_infer(\n         r#\"\n-        fn main() {\n+        async fn main() {\n             let x = unsafe { 92 };\n             let y = async { async { () }.await };\n             let z = try { () };\n             let t = 'a: { 92 };\n         }\n+\n+        #[prelude_import] use future::*;\n+\n+        mod future {\n+            #[lang = \"future_trait\"]\n+            pub trait Future { type Output; }\n+        }\n         \"#,\n         expect![[r#\"\n-            10..130 '{     ...2 }; }': ()\n-            20..21 'x': i32\n-            24..37 'unsafe { 92 }': i32\n-            31..37 '{ 92 }': i32\n-            33..35 '92': i32\n-            47..48 'y': {unknown}\n-            57..79 '{ asyn...wait }': {unknown}\n-            59..77 'async ....await': {unknown}\n-            65..71 '{ () }': ()\n-            67..69 '()': ()\n-            89..90 'z': {unknown}\n-            93..103 'try { () }': {unknown}\n-            97..103 '{ () }': ()\n-            99..101 '()': ()\n-            113..114 't': i32\n-            121..127 '{ 92 }': i32\n-            123..125 '92': i32\n+            16..136 '{     ...2 }; }': ()\n+            26..27 'x': i32\n+            30..43 'unsafe { 92 }': i32\n+            37..43 '{ 92 }': i32\n+            39..41 '92': i32\n+            53..54 'y': impl Future<Output = ()>\n+            57..85 'async ...wait }': impl Future<Output = ()>\n+            63..85 '{ asyn...wait }': ()\n+            65..77 'async { () }': impl Future<Output = ()>\n+            65..83 'async ....await': ()\n+            71..77 '{ () }': ()\n+            73..75 '()': ()\n+            95..96 'z': {unknown}\n+            99..109 'try { () }': {unknown}\n+            103..109 '{ () }': ()\n+            105..107 '()': ()\n+            119..120 't': i32\n+            127..133 '{ 92 }': i32\n+            129..131 '92': i32\n         \"#]],\n     )\n }"}, {"sha": "41d0975197beb5c7c6d09b09e0326ed4e20150ae", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -85,6 +85,46 @@ mod future {\n     );\n }\n \n+#[test]\n+fn infer_async_block() {\n+    check_types(\n+        r#\"\n+//- /main.rs crate:main deps:core\n+async fn test() {\n+    let a = async { 42 };\n+    a;\n+//  ^ impl Future<Output = i32>\n+    let x = a.await;\n+    x;\n+//  ^ i32\n+    let b = async {}.await;\n+    b;\n+//  ^ ()\n+    let c = async {\n+        let y = Option::None;\n+        y\n+    //  ^ Option<u64>\n+    };\n+    let _: Option<u64> = c.await;\n+    c;\n+//  ^ impl Future<Output = Option<u64>>\n+}\n+\n+enum Option<T> { None, Some(T) }\n+\n+//- /core.rs crate:core\n+#[prelude_import] use future::*;\n+mod future {\n+    #[lang = \"future_trait\"]\n+    trait Future {\n+        type Output;\n+    }\n+}\n+\n+\"#,\n+    );\n+}\n+\n #[test]\n fn infer_try() {\n     check_types("}, {"sha": "57d0a32df026dc6bb91d8ebf6dd0c0871405e86f", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 84, "deletions": 21, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -11,14 +11,16 @@ use hir_def::{\n     lang_item::{lang_attr, LangItemTarget},\n     AssocContainerId, AssocItemId, HasModule, Lookup, TypeAliasId,\n };\n+use hir_expand::name::name;\n \n use super::ChalkContext;\n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n     method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     utils::generics,\n-    CallableDefId, DebruijnIndex, FnSig, GenericPredicate, Substs, Ty, TypeCtor,\n+    BoundVar, CallableDefId, DebruijnIndex, FnSig, GenericPredicate, ProjectionPredicate,\n+    ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n use mapping::{\n     convert_where_clauses, generic_predicate_to_inline_bound, make_binders, TypeAliasAsValue,\n@@ -166,27 +168,88 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn opaque_ty_data(&self, id: chalk_ir::OpaqueTyId<Interner>) -> Arc<OpaqueTyDatum> {\n         let interned_id = crate::db::InternedOpaqueTyId::from(id);\n         let full_id = self.db.lookup_intern_impl_trait_id(interned_id);\n-        let (func, idx) = match full_id {\n-            crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => (func, idx),\n-        };\n-        let datas =\n-            self.db.return_type_impl_traits(func).expect(\"impl trait id without impl traits\");\n-        let data = &datas.value.impl_traits[idx as usize];\n-        let bound = OpaqueTyDatumBound {\n-            bounds: make_binders(\n-                data.bounds\n-                    .value\n-                    .iter()\n-                    .cloned()\n-                    .filter(|b| !b.is_error())\n-                    .map(|b| b.to_chalk(self.db))\n-                    .collect(),\n-                1,\n-            ),\n-            where_clauses: make_binders(vec![], 0),\n+        let bound = match full_id {\n+            crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n+                let datas = self\n+                    .db\n+                    .return_type_impl_traits(func)\n+                    .expect(\"impl trait id without impl traits\");\n+                let data = &datas.value.impl_traits[idx as usize];\n+                let bound = OpaqueTyDatumBound {\n+                    bounds: make_binders(\n+                        data.bounds\n+                            .value\n+                            .iter()\n+                            .cloned()\n+                            .filter(|b| !b.is_error())\n+                            .map(|b| b.to_chalk(self.db))\n+                            .collect(),\n+                        1,\n+                    ),\n+                    where_clauses: make_binders(vec![], 0),\n+                };\n+                let num_vars = datas.num_binders;\n+                make_binders(bound, num_vars)\n+            }\n+            crate::OpaqueTyId::AsyncBlockTypeImplTrait(..) => {\n+                if let Some((future_trait, future_output)) = self\n+                    .db\n+                    .lang_item(self.krate, \"future_trait\".into())\n+                    .and_then(|item| item.as_trait())\n+                    .and_then(|trait_| {\n+                        let alias =\n+                            self.db.trait_data(trait_).associated_type_by_name(&name![Output])?;\n+                        Some((trait_, alias))\n+                    })\n+                {\n+                    // Making up `AsyncBlock<T>: Future<Output = T>`\n+                    //\n+                    // |--------------------OpaqueTyDatum-------------------|\n+                    //        |-------------OpaqueTyDatumBound--------------|\n+                    // for<T> <Self> [Future<Self>, Future::Output<Self> = T]\n+                    //     ^1  ^0            ^0                    ^0      ^1\n+                    let impl_bound = GenericPredicate::Implemented(TraitRef {\n+                        trait_: future_trait,\n+                        // Self type as the first parameter.\n+                        substs: Substs::single(Ty::Bound(BoundVar {\n+                            debruijn: DebruijnIndex::INNERMOST,\n+                            index: 0,\n+                        })),\n+                    });\n+                    let proj_bound = GenericPredicate::Projection(ProjectionPredicate {\n+                        // The parameter of the opaque type.\n+                        ty: Ty::Bound(BoundVar { debruijn: DebruijnIndex::ONE, index: 0 }),\n+                        projection_ty: ProjectionTy {\n+                            associated_ty: future_output,\n+                            // Self type as the first parameter.\n+                            parameters: Substs::single(Ty::Bound(BoundVar::new(\n+                                DebruijnIndex::INNERMOST,\n+                                0,\n+                            ))),\n+                        },\n+                    });\n+                    let bound = OpaqueTyDatumBound {\n+                        bounds: make_binders(\n+                            vec![impl_bound.to_chalk(self.db), proj_bound.to_chalk(self.db)],\n+                            1,\n+                        ),\n+                        where_clauses: make_binders(vec![], 0),\n+                    };\n+                    // The opaque type has 1 parameter.\n+                    make_binders(bound, 1)\n+                } else {\n+                    // If failed to find `Future::Output`, return empty bounds as fallback.\n+                    let bound = OpaqueTyDatumBound {\n+                        bounds: make_binders(vec![], 0),\n+                        where_clauses: make_binders(vec![], 0),\n+                    };\n+                    // The opaque type has 1 parameter.\n+                    make_binders(bound, 1)\n+                }\n+            }\n         };\n-        let num_vars = datas.num_binders;\n-        Arc::new(OpaqueTyDatum { opaque_ty_id: id, bound: make_binders(bound, num_vars) })\n+\n+        Arc::new(OpaqueTyDatum { opaque_ty_id: id, bound })\n     }\n \n     fn hidden_opaque_type(&self, _id: chalk_ir::OpaqueTyId<Interner>) -> chalk_ir::Ty<Interner> {"}, {"sha": "cb6b0fe81fdeacc2eb4c0dc434aeb01a3914ba2c", "filename": "crates/hir_ty/src/traits/chalk/tls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -73,6 +73,9 @@ impl DebugContext<'_> {\n                 crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                     write!(f, \"{{impl trait {} of {:?}}}\", idx, func)?;\n                 }\n+                crate::OpaqueTyId::AsyncBlockTypeImplTrait(def, idx) => {\n+                    write!(f, \"{{impl trait of async block {} of {:?}}}\", idx.into_raw(), def)?;\n+                }\n             },\n             TypeCtor::Closure { def, expr } => {\n                 write!(f, \"{{closure {:?} in \", expr.into_raw())?;"}, {"sha": "5645b41fa485c35e62949626c79b54e1cfa2741e", "filename": "crates/ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -506,6 +506,28 @@ pub mod future {\n     #[lang = \"future_trait\"]\n     pub trait Future {}\n }\n+\"#,\n+            expect![[r#\"\n+                kw await expr.await\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+//- /main.rs\n+use std::future::*;\n+fn foo() {\n+    let a = async {};\n+    a.<|>\n+}\n+\n+//- /std/lib.rs\n+pub mod future {\n+    #[lang = \"future_trait\"]\n+    pub trait Future {\n+        type Output;\n+    }\n+}\n \"#,\n             expect![[r#\"\n                 kw await expr.await"}, {"sha": "37171cbef33ae552cd644e46e36ac45a1143abde", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d03fe6ef57d3956e92382e0e1f1a916015191cb/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=0d03fe6ef57d3956e92382e0e1f1a916015191cb", "patch": "@@ -2646,6 +2646,70 @@ fn foo(ar<|>g: &impl Foo + Bar<S>) {}\n         );\n     }\n \n+    #[test]\n+    fn test_hover_async_block_impl_trait_has_goto_type_action() {\n+        check_actions(\n+            r#\"\n+struct S;\n+fn foo() {\n+    let fo<|>o = async { S };\n+}\n+\n+#[prelude_import] use future::*;\n+mod future {\n+    #[lang = \"future_trait\"]\n+    pub trait Future { type Output; }\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    GoToType(\n+                        [\n+                            HoverGotoTypeData {\n+                                mod_path: \"test::future::Future\",\n+                                nav: NavigationTarget {\n+                                    file_id: FileId(\n+                                        1,\n+                                    ),\n+                                    full_range: 101..163,\n+                                    focus_range: Some(\n+                                        140..146,\n+                                    ),\n+                                    name: \"Future\",\n+                                    kind: TRAIT,\n+                                    container_name: None,\n+                                    description: Some(\n+                                        \"pub trait Future\",\n+                                    ),\n+                                    docs: None,\n+                                },\n+                            },\n+                            HoverGotoTypeData {\n+                                mod_path: \"test::S\",\n+                                nav: NavigationTarget {\n+                                    file_id: FileId(\n+                                        1,\n+                                    ),\n+                                    full_range: 0..9,\n+                                    focus_range: Some(\n+                                        7..8,\n+                                    ),\n+                                    name: \"S\",\n+                                    kind: STRUCT,\n+                                    container_name: None,\n+                                    description: Some(\n+                                        \"struct S\",\n+                                    ),\n+                                    docs: None,\n+                                },\n+                            },\n+                        ],\n+                    ),\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_hover_arg_generic_impl_trait_has_goto_type_action() {\n         check_actions("}]}