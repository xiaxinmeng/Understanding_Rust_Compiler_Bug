{"sha": "4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZmMxNWUzMGM1ODJkMGVmOTk0ZjEyZmM1ZWFhOTBiY2FlYWIxODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-21T06:31:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-21T06:31:30Z"}, "message": "auto merge of #14259 : alexcrichton/rust/core-mem, r=brson\n\nExcluding the functions inherited from the cast module last week (with marked\r\nstability levels), these functions received the following treatment.\r\n\r\n* size_of - this method has become #[stable]\r\n* nonzero_size_of/nonzero_size_of_val - these methods have been removed\r\n* min_align_of - this method is now #[stable]\r\n* pref_align_of - this method has been renamed without the\r\n  `pref_` prefix, and it is the \"default alignment\" now. This decision is in line\r\n  with what clang does (see url linked in comment on function). This function\r\n  is now #[stable].\r\n* init - renamed to zeroed and marked #[stable]\r\n* uninit - marked #[stable]\r\n* move_val_init - renamed to overwrite and marked #[stable]\r\n* {from,to}_{be,le}{16,32,64} - all functions marked #[stable]\r\n* swap/replace/drop - marked #[stable]\r\n* size_of_val/min_align_of_val/align_of_val - these functions are marked\r\n  #[unstable], but will continue to exist in some form. Concerns have been\r\n  raised about their `_val` prefix.", "tree": {"sha": "5a9b3f517121774014c01d03f3d0467ad0a0d43d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a9b3f517121774014c01d03f3d0467ad0a0d43d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "html_url": "https://github.com/rust-lang/rust/commit/4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "feb9f302ca52b8105ad6641a3bf2646cd26d1434", "url": "https://api.github.com/repos/rust-lang/rust/commits/feb9f302ca52b8105ad6641a3bf2646cd26d1434", "html_url": "https://github.com/rust-lang/rust/commit/feb9f302ca52b8105ad6641a3bf2646cd26d1434"}, {"sha": "19dc3b50bd63489988eb8fc83d25b08ca83df151", "url": "https://api.github.com/repos/rust-lang/rust/commits/19dc3b50bd63489988eb8fc83d25b08ca83df151", "html_url": "https://github.com/rust-lang/rust/commit/19dc3b50bd63489988eb8fc83d25b08ca83df151"}], "stats": {"total": 359, "additions": 222, "deletions": 137}, "files": [{"sha": "3ff05ef3fd0644796b39006e313495cbffaa6df9", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -216,9 +216,9 @@ impl<T: Send> Unique<T> {\n             // we *need* valid pointer.\n             assert!(!ptr.is_null());\n             // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\n-            // move_val_init moves a value into this memory without\n+            // `overwrite` moves a value into this memory without\n             // attempting to drop the original value.\n-            mem::move_val_init(&mut *ptr, value);\n+            mem::overwrite(&mut *ptr, value);\n             Unique{ptr: ptr}\n         }\n     }"}, {"sha": "3c93cdac8bbc97109f36282fa501f51b185ffce3", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -35,7 +35,6 @@ use std::cmp;\n use std::intrinsics::{TyDesc, get_tydesc};\n use std::intrinsics;\n use std::mem;\n-use std::mem::min_align_of;\n use std::num;\n use std::ptr::read;\n use std::rc::Rc;\n@@ -155,7 +154,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         }\n \n         // Find where the next tydesc lives\n-        idx = round_up(start + size, mem::pref_align_of::<*TyDesc>());\n+        idx = round_up(start + size, mem::align_of::<*TyDesc>());\n     }\n }\n \n@@ -207,9 +206,10 @@ impl Arena {\n     #[inline]\n     fn alloc_copy<'a, T>(&'a mut self, op: || -> T) -> &'a T {\n         unsafe {\n-            let ptr = self.alloc_copy_inner(mem::size_of::<T>(), min_align_of::<T>());\n+            let ptr = self.alloc_copy_inner(mem::size_of::<T>(),\n+                                            mem::min_align_of::<T>());\n             let ptr = ptr as *mut T;\n-            mem::move_val_init(&mut (*ptr), op());\n+            mem::overwrite(&mut (*ptr), op());\n             return &*ptr;\n         }\n     }\n@@ -239,7 +239,7 @@ impl Arena {\n                 return self.alloc_noncopy_grow(n_bytes, align);\n             }\n \n-            self.head.fill.set(round_up(end, mem::pref_align_of::<*TyDesc>()));\n+            self.head.fill.set(round_up(end, mem::align_of::<*TyDesc>()));\n \n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n@@ -254,14 +254,15 @@ impl Arena {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n-                self.alloc_noncopy_inner(mem::size_of::<T>(), min_align_of::<T>());\n+                self.alloc_noncopy_inner(mem::size_of::<T>(),\n+                                         mem::min_align_of::<T>());\n             let ty_ptr = ty_ptr as *mut uint;\n             let ptr = ptr as *mut T;\n             // Write in our tydesc along with a bit indicating that it\n             // has *not* been initialized yet.\n             *ty_ptr = mem::transmute(tydesc);\n             // Actually initialize it\n-            mem::move_val_init(&mut(*ptr), op());\n+            mem::overwrite(&mut(*ptr), op());\n             // Now that we are done, update the tydesc to indicate that\n             // the object is there.\n             *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n@@ -357,9 +358,10 @@ impl<T> TypedArenaChunk<T> {\n         size = size.checked_add(&elems_size).unwrap();\n \n         let mut chunk = unsafe {\n-            let chunk = exchange_malloc(size, min_align_of::<TypedArenaChunk<T>>());\n+            let chunk = exchange_malloc(size,\n+                                        mem::min_align_of::<TypedArenaChunk<T>>());\n             let mut chunk: Box<TypedArenaChunk<T>> = mem::transmute(chunk);\n-            mem::move_val_init(&mut chunk.next, next);\n+            mem::overwrite(&mut chunk.next, next);\n             chunk\n         };\n \n@@ -396,7 +398,8 @@ impl<T> TypedArenaChunk<T> {\n     fn start(&self) -> *u8 {\n         let this: *TypedArenaChunk<T> = self;\n         unsafe {\n-            mem::transmute(round_up(this.offset(1) as uint, min_align_of::<T>()))\n+            mem::transmute(round_up(this.offset(1) as uint,\n+                                    mem::min_align_of::<T>()))\n         }\n     }\n \n@@ -440,7 +443,7 @@ impl<T> TypedArena<T> {\n             }\n \n             let ptr: &'a mut T = mem::transmute(this.ptr);\n-            mem::move_val_init(ptr, object);\n+            mem::overwrite(ptr, object);\n             this.ptr = this.ptr.offset(1);\n             let ptr: &'a T = ptr;\n             ptr"}, {"sha": "4a0daf529de88bd18b71ef16bc8d5157118cbe0a", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -13,7 +13,7 @@\n #![allow(missing_doc)]\n \n use std::clone::Clone;\n-use std::mem::{move_val_init, init, replace, swap};\n+use std::mem::{overwrite, zeroed, replace, swap};\n use std::slice;\n \n /// A priority queue implemented with a binary heap\n@@ -157,40 +157,40 @@ impl<T: TotalOrd> PriorityQueue<T> {\n     // compared to using swaps, which involves twice as many moves.\n     fn siftup(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n-            let new = replace(self.data.get_mut(pos), init());\n+            let new = replace(self.data.get_mut(pos), zeroed());\n \n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n                 if new > *self.data.get(parent) {\n-                    let x = replace(self.data.get_mut(parent), init());\n-                    move_val_init(self.data.get_mut(pos), x);\n+                    let x = replace(self.data.get_mut(parent), zeroed());\n+                    overwrite(self.data.get_mut(pos), x);\n                     pos = parent;\n                     continue\n                 }\n                 break\n             }\n-            move_val_init(self.data.get_mut(pos), new);\n+            overwrite(self.data.get_mut(pos), new);\n         }\n     }\n \n     fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n-            let new = replace(self.data.get_mut(pos), init());\n+            let new = replace(self.data.get_mut(pos), zeroed());\n \n             let mut child = 2 * pos + 1;\n             while child < end {\n                 let right = child + 1;\n                 if right < end && !(*self.data.get(child) > *self.data.get(right)) {\n                     child = right;\n                 }\n-                let x = replace(self.data.get_mut(child), init());\n-                move_val_init(self.data.get_mut(pos), x);\n+                let x = replace(self.data.get_mut(child), zeroed());\n+                overwrite(self.data.get_mut(pos), x);\n                 pos = child;\n                 child = 2 * pos + 1;\n             }\n \n-            move_val_init(self.data.get_mut(pos), new);\n+            overwrite(self.data.get_mut(pos), new);\n             self.siftup(start, pos);\n         }\n     }"}, {"sha": "9d64b3c2394b02d7cf47c93deeb47cdfff52809f", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -10,7 +10,7 @@\n \n //! Ordered containers with integer keys, implemented as radix tries (`TrieSet` and `TrieMap` types)\n \n-use std::mem::init;\n+use std::mem::zeroed;\n use std::mem;\n use std::slice::{Items, MutItems};\n use std::slice;\n@@ -522,7 +522,8 @@ macro_rules! iterator_impl {\n                     remaining_max: 0,\n                     length: 0,\n                     // ick :( ... at least the compiler will tell us if we screwed up.\n-                    stack: [init(), init(), init(), init(), init(), init(), init(), init()]\n+                    stack: [zeroed(), zeroed(), zeroed(), zeroed(), zeroed(),\n+                            zeroed(), zeroed(), zeroed()]\n                 }\n             }\n \n@@ -532,8 +533,10 @@ macro_rules! iterator_impl {\n                     remaining_min: 0,\n                     remaining_max: 0,\n                     length: 0,\n-                    stack: [init(), init(), init(), init(), init(), init(), init(), init(),\n-                            init(), init(), init(), init(), init(), init(), init(), init()]\n+                    stack: [zeroed(), zeroed(), zeroed(), zeroed(),\n+                            zeroed(), zeroed(), zeroed(), zeroed(),\n+                            zeroed(), zeroed(), zeroed(), zeroed(),\n+                            zeroed(), zeroed(), zeroed(), zeroed()]\n                 }\n             }\n         }"}, {"sha": "aa7a8f0f8b63af28ae33f0ebaf12cca34eae4306", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 140, "deletions": 68, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -19,83 +19,145 @@ use intrinsics::{bswap16, bswap32, bswap64};\n \n /// Returns the size of a type in bytes.\n #[inline]\n+#[stable]\n pub fn size_of<T>() -> uint {\n     unsafe { intrinsics::size_of::<T>() }\n }\n \n /// Returns the size of the type that `_val` points to in bytes.\n #[inline]\n+#[unstable = \"the name of this function may change slightly before stabilizing\"]\n pub fn size_of_val<T>(_val: &T) -> uint {\n     size_of::<T>()\n }\n \n-/// Returns the size of a type in bytes, or 1 if the actual size is zero.\n-///\n-/// Useful for building structures containing variable-length arrays.\n+/// Deprecated, this function will be removed soon\n #[inline]\n+#[deprecated = \"this function will be removed soon\"]\n pub fn nonzero_size_of<T>() -> uint {\n     match size_of::<T>() {\n         0 => 1,\n-        x => x\n+        n => n,\n     }\n }\n \n-/// Returns the size in bytes of the type of the value that `_val` points to.\n+/// Deprecated, this function will be removed soon\n #[inline]\n-pub fn nonzero_size_of_val<T>(_val: &T) -> uint {\n-    nonzero_size_of::<T>()\n+#[deprecated = \"this function will be removed soon\"]\n+pub fn nonzero_size_of_val<T>(val: &T) -> uint {\n+    match size_of_val::<T>(val) {\n+        0 => 1,\n+        n => n,\n+    }\n }\n \n /// Returns the ABI-required minimum alignment of a type\n ///\n /// This is the alignment used for struct fields. It may be smaller\n /// than the preferred alignment.\n #[inline]\n+#[stable]\n pub fn min_align_of<T>() -> uint {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n /// Returns the ABI-required minimum alignment of the type of the value that\n /// `_val` points to\n #[inline]\n+#[unstable = \"the name of this function may change slightly before stabilizing\"]\n pub fn min_align_of_val<T>(_val: &T) -> uint {\n     min_align_of::<T>()\n }\n \n-/// Returns the preferred alignment of a type\n+/// Returns the alignment in memory for a type.\n+///\n+/// This function will return the alignment, in bytes, of a type in memory. If\n+/// the alignment returned is adhered to, then the type is guaranteed to\n+/// function properly.\n #[inline]\n-pub fn pref_align_of<T>() -> uint {\n+#[stable]\n+pub fn align_of<T>() -> uint {\n+    // We use the preferred alignment as the default alignment for a type. This\n+    // appears to be what clang migrated towards as well:\n+    //\n+    // http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20110725/044411.html\n     unsafe { intrinsics::pref_align_of::<T>() }\n }\n \n-/// Returns the preferred alignment of the type of the value that\n-/// `_val` points to\n+/// Returns the alignment of the type of the value that `_val` points to.\n+///\n+/// This is similar to `align_of`, but function will properly handle types such\n+/// as trait objects (in the future), returning the alignment for an arbitrary\n+/// value at runtime.\n #[inline]\n-pub fn pref_align_of_val<T>(_val: &T) -> uint {\n-    pref_align_of::<T>()\n+#[unstable = \"the name of this function may change slightly before stabilizing\"]\n+pub fn align_of_val<T>(_val: &T) -> uint {\n+    align_of::<T>()\n }\n \n+/// Deprecated, this function has been renamed to align_of\n+#[inline]\n+#[deprecated = \"use mem::align_of instead\"]\n+pub fn pref_align_of<T>() -> uint { align_of::<T>() }\n+\n+/// Deprecated, this function has been renamed to align_of_val\n+#[inline]\n+#[deprecated = \"use mem::align_of_val instead\"]\n+pub fn pref_align_of_val<T>(val: &T) -> uint { align_of_val(val) }\n+\n /// Create a value initialized to zero.\n ///\n-/// `init` is unsafe because it returns a zeroed-out datum,\n-/// which is unsafe unless T is Copy.\n+/// This function is similar to allocating space for a a local variable and\n+/// zeroing it out (an unsafe operation).\n+///\n+/// Care must be taken when using this function, if the type `T` has a\n+/// destructor and the value falls out of scope (due to unwinding or returning)\n+/// before being initialized, then the destructor will run on zeroed\n+/// data, likely leading to crashes.\n+///\n+/// This is useful for FFI functions sometimes, but should generally be avoided.\n #[inline]\n-pub unsafe fn init<T>() -> T {\n+#[unstable = \"the name of this function is subject to change\"]\n+pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n \n+/// Deprecated, use zeroed() instead\n+#[inline]\n+#[deprecated = \"this function has been renamed to zeroed()\"]\n+pub unsafe fn init<T>() -> T { zeroed() }\n+\n /// Create an uninitialized value.\n+///\n+/// Care must be taken when using this function, if the type `T` has a\n+/// destructor and the value falls out of scope (due to unwinding or returning)\n+/// before being initialized, then the destructor will run on uninitialized\n+/// data, likely leading to crashes.\n+///\n+/// This is useful for FFI functions sometimes, but should generally be avoided.\n #[inline]\n+#[unstable = \"the name of this function is subject to change\"]\n pub unsafe fn uninit<T>() -> T {\n     intrinsics::uninit()\n }\n \n-/// Move a value to an uninitialized memory location.\n+/// Unsafely overwrite a memory location with the given value without destroying\n+/// the old value.\n ///\n-/// Drop glue is not run on the destination.\n+/// This operation is unsafe because it does not destroy the previous value\n+/// contained at the location `dst`. This could leak allocations or resources,\n+/// so care must be taken to previously deallocate the value at `dst`.\n+#[inline]\n+#[unstable = \"the name of this function is subject to change\"]\n+pub unsafe fn overwrite<T>(dst: *mut T, src: T) {\n+    intrinsics::move_val_init(&mut *dst, src)\n+}\n+\n+/// Deprecated, use move_val_init() instead\n #[inline]\n+#[deprecated = \"this function has been renamed to move_val_init()\"]\n pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n-    intrinsics::move_val_init(dst, src)\n+    overwrite(dst, src)\n }\n \n /// Convert an u16 to little endian from the target's endianness.\n@@ -106,126 +168,150 @@ pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n /// Convert an u16 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn to_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n /// Convert an u32 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_le32(x: u32) -> u32 { x }\n+#[cfg(target_endian = \"little\")] #[inline] #[stable]\n+pub fn to_le32(x: u32) -> u32 { x }\n \n /// Convert an u32 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn to_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n /// Convert an u64 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_le64(x: u64) -> u64 { x }\n+#[cfg(target_endian = \"little\")] #[inline] #[stable]\n+pub fn to_le64(x: u64) -> u64 { x }\n \n /// Convert an u64 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn to_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n \n /// Convert an u16 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] #[stable]\n+pub fn to_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n /// Convert an u16 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be16(x: u16) -> u16 { x }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn to_be16(x: u16) -> u16 { x }\n \n /// Convert an u32 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] #[stable]\n+pub fn to_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n /// Convert an u32 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be32(x: u32) -> u32 { x }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn to_be32(x: u32) -> u32 { x }\n \n /// Convert an u64 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] #[stable]\n+pub fn to_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n /// Convert an u64 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be64(x: u64) -> u64 { x }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn to_be64(x: u64) -> u64 { x }\n \n \n /// Convert an u16 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_le16(x: u16) -> u16 { x }\n+#[cfg(target_endian = \"little\")] #[inline] #[stable]\n+pub fn from_le16(x: u16) -> u16 { x }\n \n /// Convert an u16 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn from_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n /// Convert an u32 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_le32(x: u32) -> u32 { x }\n+#[cfg(target_endian = \"little\")] #[inline] #[stable]\n+pub fn from_le32(x: u32) -> u32 { x }\n \n /// Convert an u32 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn from_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n /// Convert an u64 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_le64(x: u64) -> u64 { x }\n+#[cfg(target_endian = \"little\")] #[inline] #[stable]\n+pub fn from_le64(x: u64) -> u64 { x }\n \n /// Convert an u64 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn from_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n \n /// Convert an u16 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] #[stable]\n+pub fn from_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n /// Convert an u16 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be16(x: u16) -> u16 { x }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn from_be16(x: u16) -> u16 { x }\n \n /// Convert an u32 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] #[stable]\n+pub fn from_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n /// Convert an u32 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be32(x: u32) -> u32 { x }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn from_be32(x: u32) -> u32 { x }\n \n /// Convert an u64 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] #[stable]\n+pub fn from_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n /// Convert an u64 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be64(x: u64) -> u64 { x }\n+#[cfg(target_endian = \"big\")] #[inline] #[stable]\n+pub fn from_be64(x: u64) -> u64 { x }\n \n /**\n  * Swap the values at two mutable locations of the same type, without\n  * deinitialising or copying either one.\n  */\n #[inline]\n+#[stable]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n         // Give ourselves some scratch space to work with\n@@ -279,6 +365,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n  * ```\n  */\n #[inline]\n+#[stable]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n     swap(dest, &mut src);\n     src\n@@ -304,6 +391,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"{}\", *borrow);\n /// ```\n #[inline]\n+#[stable]\n pub fn drop<T>(_x: T) { }\n \n /// Moves a thing into the void.\n@@ -415,50 +503,34 @@ mod tests {\n         assert_eq!(size_of_val(&1u64), 8);\n     }\n \n-    #[test]\n-    fn nonzero_size_of_basic() {\n-        type Z = [i8, ..0];\n-        assert_eq!(size_of::<Z>(), 0u);\n-        assert_eq!(nonzero_size_of::<Z>(), 1u);\n-        assert_eq!(nonzero_size_of::<uint>(), size_of::<uint>());\n-    }\n-\n-    #[test]\n-    fn nonzero_size_of_val_basic() {\n-        let z = [0u8, ..0];\n-        assert_eq!(size_of_val(&z), 0u);\n-        assert_eq!(nonzero_size_of_val(&z), 1u);\n-        assert_eq!(nonzero_size_of_val(&1u), size_of_val(&1u));\n-    }\n-\n     #[test]\n     fn align_of_basic() {\n-        assert_eq!(pref_align_of::<u8>(), 1u);\n-        assert_eq!(pref_align_of::<u16>(), 2u);\n-        assert_eq!(pref_align_of::<u32>(), 4u);\n+        assert_eq!(align_of::<u8>(), 1u);\n+        assert_eq!(align_of::<u16>(), 2u);\n+        assert_eq!(align_of::<u32>(), 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n     fn align_of_32() {\n-        assert_eq!(pref_align_of::<uint>(), 4u);\n-        assert_eq!(pref_align_of::<*uint>(), 4u);\n+        assert_eq!(align_of::<uint>(), 4u);\n+        assert_eq!(align_of::<*uint>(), 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     fn align_of_64() {\n-        assert_eq!(pref_align_of::<uint>(), 8u);\n-        assert_eq!(pref_align_of::<*uint>(), 8u);\n+        assert_eq!(align_of::<uint>(), 8u);\n+        assert_eq!(align_of::<*uint>(), 8u);\n     }\n \n     #[test]\n     fn align_of_val_basic() {\n-        assert_eq!(pref_align_of_val(&1u8), 1u);\n-        assert_eq!(pref_align_of_val(&1u16), 2u);\n-        assert_eq!(pref_align_of_val(&1u32), 4u);\n+        assert_eq!(align_of_val(&1u8), 1u);\n+        assert_eq!(align_of_val(&1u16), 2u);\n+        assert_eq!(align_of_val(&1u32), 4u);\n     }\n \n     #[test]"}, {"sha": "ccca52c573d215725ef3d56b6ce01a7a08f100c7", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -171,15 +171,17 @@ impl<A: Clone> Clone for ~[A] {\n         unsafe {\n             let ret = alloc(size) as *mut Vec<A>;\n \n-            (*ret).fill = len * mem::nonzero_size_of::<A>();\n-            (*ret).alloc = len * mem::nonzero_size_of::<A>();\n+            let a_size = mem::size_of::<A>();\n+            let a_size = if a_size == 0 {1} else {a_size};\n+            (*ret).fill = len * a_size;\n+            (*ret).alloc = len * a_size;\n \n             let mut i = 0;\n             let p = &mut (*ret).data as *mut _ as *mut A;\n             try_finally(\n                 &mut i, (),\n                 |i, ()| while *i < len {\n-                    mem::move_val_init(\n+                    mem::overwrite(\n                         &mut(*p.offset(*i as int)),\n                         self.unsafe_ref(*i).clone());\n                     *i += 1;"}, {"sha": "755c6738b4a626f7608d2739ec6858646538fb83", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -1122,7 +1122,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n \n     #[inline]\n     unsafe fn init_elem(self, i: uint, val: T) {\n-        mem::move_val_init(&mut (*self.as_mut_ptr().offset(i as int)), val);\n+        mem::overwrite(&mut (*self.as_mut_ptr().offset(i as int)), val);\n     }\n \n     #[inline]\n@@ -1306,7 +1306,8 @@ macro_rules! iterator {\n             #[inline]\n             fn size_hint(&self) -> (uint, Option<uint>) {\n                 let diff = (self.end as uint) - (self.ptr as uint);\n-                let exact = diff / mem::nonzero_size_of::<T>();\n+                let size = mem::size_of::<T>();\n+                let exact = diff / (if size == 0 {1} else {size});\n                 (exact, Some(exact))\n             }\n         }"}, {"sha": "3bfd70a0a8b0c92a353d6dc3a0d84794b15cb73c", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -118,7 +118,7 @@ impl rtio::RtioFileStream for FileDesc {\n \n     fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n         let mut read = 0;\n-        let mut overlap: libc::OVERLAPPED = unsafe { mem::init() };\n+        let mut overlap: libc::OVERLAPPED = unsafe { mem::zeroed() };\n         overlap.Offset = offset as libc::DWORD;\n         overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n         let ret = unsafe {\n@@ -135,7 +135,7 @@ impl rtio::RtioFileStream for FileDesc {\n     fn pwrite(&mut self, buf: &[u8], mut offset: u64) -> Result<(), IoError> {\n         let mut cur = buf.as_ptr();\n         let mut remaining = buf.len();\n-        let mut overlap: libc::OVERLAPPED = unsafe { mem::init() };\n+        let mut overlap: libc::OVERLAPPED = unsafe { mem::zeroed() };\n         while remaining > 0 {\n             overlap.Offset = offset as libc::DWORD;\n             overlap.OffsetHigh = (offset >> 32) as libc::DWORD;"}, {"sha": "6ba92009c39d56638d57da414abfb33d3add616f", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -68,7 +68,7 @@ fn ip_to_inaddr(ip: ip::IpAddr) -> InAddr {\n \n fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     unsafe {\n-        let storage: libc::sockaddr_storage = mem::init();\n+        let storage: libc::sockaddr_storage = mem::zeroed();\n         let len = match ip_to_inaddr(addr.ip) {\n             InAddr(inaddr) => {\n                 let storage: *mut libc::sockaddr_in = mem::transmute(&storage);\n@@ -120,7 +120,7 @@ fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n                            val: libc::c_int) -> IoResult<T> {\n     unsafe {\n-        let mut slot: T = mem::init();\n+        let mut slot: T = mem::zeroed();\n         let mut len = mem::size_of::<T>() as libc::socklen_t;\n         let ret = c::getsockopt(fd, opt, val,\n                                 &mut slot as *mut _ as *mut _,\n@@ -152,7 +152,7 @@ fn sockname(fd: sock_t,\n                                          *mut libc::socklen_t) -> libc::c_int)\n     -> IoResult<ip::SocketAddr>\n {\n-    let mut storage: libc::sockaddr_storage = unsafe { mem::init() };\n+    let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n     let mut len = mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n     unsafe {\n         let storage = &mut storage as *mut libc::sockaddr_storage;\n@@ -221,7 +221,7 @@ pub fn init() {\n \n         let _guard = LOCK.lock();\n         if !INITIALIZED {\n-            let mut data: c::WSADATA = mem::init();\n+            let mut data: c::WSADATA = mem::zeroed();\n             let ret = c::WSAStartup(0x202,      // version 2.2\n                                     &mut data);\n             assert_eq!(ret, 0);\n@@ -497,7 +497,7 @@ impl TcpAcceptor {\n             try!(util::await(self.fd(), Some(self.deadline), util::Readable));\n         }\n         unsafe {\n-            let mut storage: libc::sockaddr_storage = mem::init();\n+            let mut storage: libc::sockaddr_storage = mem::zeroed();\n             let storagep = &mut storage as *mut libc::sockaddr_storage;\n             let size = mem::size_of::<libc::sockaddr_storage>();\n             let mut size = size as libc::socklen_t;\n@@ -622,7 +622,7 @@ impl rtio::RtioSocket for UdpSocket {\n impl rtio::RtioUdpSocket for UdpSocket {\n     fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, ip::SocketAddr)> {\n         let fd = self.fd();\n-        let mut storage: libc::sockaddr_storage = unsafe { mem::init() };\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n         let mut addrlen: libc::socklen_t =\n                 mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;"}, {"sha": "5acb48a5f391e82c639138a3d69c15b77004c9c2", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -86,8 +86,8 @@\n \n use libc;\n use std::c_str::CString;\n-use std::intrinsics;\n use std::io;\n+use std::mem;\n use std::os::win32::as_utf16_p;\n use std::os;\n use std::ptr;\n@@ -345,7 +345,7 @@ impl rtio::RtioPipe for UnixStream {\n         }\n \n         let mut bytes_read = 0;\n-        let mut overlapped: libc::OVERLAPPED = unsafe { intrinsics::init() };\n+        let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n         overlapped.hEvent = self.read.get_ref().handle();\n \n         // Pre-flight check to see if the reading half has been closed. This\n@@ -417,7 +417,7 @@ impl rtio::RtioPipe for UnixStream {\n         }\n \n         let mut offset = 0;\n-        let mut overlapped: libc::OVERLAPPED = unsafe { intrinsics::init() };\n+        let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n         overlapped.hEvent = self.write.get_ref().handle();\n \n         while offset < buf.len() {\n@@ -633,7 +633,7 @@ impl UnixAcceptor {\n         // someone on the other end connects. This function can \"fail\" if a\n         // client connects after we created the pipe but before we got down\n         // here. Thanks windows.\n-        let mut overlapped: libc::OVERLAPPED = unsafe { intrinsics::init() };\n+        let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n         overlapped.hEvent = self.event.handle();\n         if unsafe { libc::ConnectNamedPipe(handle, &mut overlapped) == 0 } {\n             let mut err = unsafe { libc::GetLastError() };"}, {"sha": "04911bc5f1bd670648c9c4a3e47cdd6af2e078a4", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -896,8 +896,8 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n     // self-pipe plus the old handler registered (return value of sigaction).\n     fn register_sigchld() -> (libc::c_int, c::sigaction) {\n         unsafe {\n-            let mut old: c::sigaction = mem::init();\n-            let mut new: c::sigaction = mem::init();\n+            let mut old: c::sigaction = mem::zeroed();\n+            let mut new: c::sigaction = mem::zeroed();\n             new.sa_handler = sigchld_handler;\n             new.sa_flags = c::SA_NOCLDSTOP;\n             assert_eq!(c::sigaction(c::SIGCHLD, &new, &mut old), 0);\n@@ -916,7 +916,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n                       messages: Receiver<Req>,\n                       (read_fd, old): (libc::c_int, c::sigaction)) {\n         util::set_nonblocking(input, true).unwrap();\n-        let mut set: c::fd_set = unsafe { mem::init() };\n+        let mut set: c::fd_set = unsafe { mem::zeroed() };\n         let mut tv: libc::timeval;\n         let mut active = Vec::<(libc::pid_t, Sender<p::ProcessExit>, u64)>::new();\n         let max = cmp::max(input, read_fd) + 1;"}, {"sha": "ed218022b2edecfa2aaa467c7a2a3d43bd69f229", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -87,17 +87,17 @@ pub enum Req {\n // returns the current time (in milliseconds)\n pub fn now() -> u64 {\n     unsafe {\n-        let mut now: libc::timeval = mem::init();\n+        let mut now: libc::timeval = mem::zeroed();\n         assert_eq!(c::gettimeofday(&mut now, ptr::null()), 0);\n         return (now.tv_sec as u64) * 1000 + (now.tv_usec as u64) / 1000;\n     }\n }\n \n fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n-    let mut set: c::fd_set = unsafe { mem::init() };\n+    let mut set: c::fd_set = unsafe { mem::zeroed() };\n \n     let mut fd = FileDesc::new(input, true);\n-    let mut timeout: libc::timeval = unsafe { mem::init() };\n+    let mut timeout: libc::timeval = unsafe { mem::zeroed() };\n \n     // active timers are those which are able to be selected upon (and it's a\n     // sorted list, and dead timers are those which have expired, but ownership"}, {"sha": "fe7a58a5e6868f705f38dc485239f89839584669", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -89,7 +89,7 @@ pub fn connect_timeout(fd: net::sock_t,\n         // to use select() with a timeout.\n         -1 if os::errno() as int == INPROGRESS as int ||\n               os::errno() as int == WOULDBLOCK as int => {\n-            let mut set: c::fd_set = unsafe { mem::init() };\n+            let mut set: c::fd_set = unsafe { mem::zeroed() };\n             c::fd_set(&mut set, fd);\n             match await(fd, &mut set, timeout_ms) {\n                 0 => Err(timeout(\"connection timed out\")),\n@@ -137,13 +137,13 @@ pub fn connect_timeout(fd: net::sock_t,\n \n pub fn await(fd: net::sock_t, deadline: Option<u64>,\n              status: SocketStatus) -> IoResult<()> {\n-    let mut set: c::fd_set = unsafe { mem::init() };\n+    let mut set: c::fd_set = unsafe { mem::zeroed() };\n     c::fd_set(&mut set, fd);\n     let (read, write) = match status {\n         Readable => (&set as *_, ptr::null()),\n         Writable => (ptr::null(), &set as *_),\n     };\n-    let mut tv: libc::timeval = unsafe { mem::init() };\n+    let mut tv: libc::timeval = unsafe { mem::zeroed() };\n \n     match retry(|| {\n         let now = ::io::timer::now();"}, {"sha": "f24bd661c8c178c9bfd6806542d66695c32c8374", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -176,7 +176,7 @@ mod imp {\n             if handle as uint == libc::INVALID_HANDLE_VALUE as uint {\n                 fail!(\"create file error: {}\", os::last_os_error());\n             }\n-            let mut overlapped: libc::OVERLAPPED = unsafe { mem::init() };\n+            let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n             let ret = unsafe {\n                 LockFileEx(handle, LOCKFILE_EXCLUSIVE_LOCK, 0, 100, 0,\n                            &mut overlapped)\n@@ -192,7 +192,7 @@ mod imp {\n \n     impl Drop for Lock {\n         fn drop(&mut self) {\n-            let mut overlapped: libc::OVERLAPPED = unsafe { mem::init() };\n+            let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n             unsafe {\n                 UnlockFileEx(self.handle, 0, 100, 0, &mut overlapped);\n                 libc::CloseHandle(self.handle);"}, {"sha": "9c77c7eb56be3a855c22b027158eae18c3c5c05e", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -79,7 +79,7 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n \n fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     unsafe {\n-        let mut storage: libc::sockaddr_storage = mem::init();\n+        let mut storage: libc::sockaddr_storage = mem::zeroed();\n         let len = match addr.ip {\n             ip::Ipv4Addr(a, b, c, d) => {\n                 let storage: &mut libc::sockaddr_in =\n@@ -133,7 +133,7 @@ fn socket_name(sk: SocketNameKind,\n     };\n \n     // Allocate a sockaddr_storage since we don't know if it's ipv4 or ipv6\n-    let mut sockaddr: libc::sockaddr_storage = unsafe { mem::init() };\n+    let mut sockaddr: libc::sockaddr_storage = unsafe { mem::zeroed() };\n     let mut namelen = mem::size_of::<libc::sockaddr_storage>() as c_int;\n \n     let sockaddr_p = &mut sockaddr as *mut libc::sockaddr_storage;"}, {"sha": "e78122f699d408cd585143352c4092331f21d2eb", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -306,8 +306,10 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n             // this should pass the real required alignment\n             let ret = exchange_malloc(size, 8) as *mut RawVec<()>;\n \n-            (*ret).fill = len * mem::nonzero_size_of::<T>();\n-            (*ret).alloc = len * mem::nonzero_size_of::<T>();\n+            let a_size = mem::size_of::<T>();\n+            let a_size = if a_size == 0 {1} else {a_size};\n+            (*ret).fill = len * a_size;\n+            (*ret).alloc = len * a_size;\n \n             // Be careful with the following loop. We want it to be optimized\n             // to a memcpy (or something similarly fast) when T is Copy. LLVM\n@@ -318,7 +320,7 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n             try_finally(\n                 &mut i, (),\n                 |i, ()| while *i < len {\n-                    mem::move_val_init(\n+                    mem::overwrite(\n                         &mut(*p.offset(*i as int)),\n                         self.unsafe_ref(*i).clone());\n                     *i += 1;"}, {"sha": "760214eb8f842f34c8cb1e9e50baade600c6a2a5", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -390,8 +390,8 @@ mod imp {\n     impl Mutex {\n         pub unsafe fn new() -> Mutex {\n             let m = Mutex {\n-                lock: Unsafe::new(mem::init()),\n-                cond: Unsafe::new(mem::init()),\n+                lock: Unsafe::new(mem::zeroed()),\n+                cond: Unsafe::new(mem::zeroed()),\n             };\n \n             pthread_mutex_init(m.lock.get(), 0 as *libc::c_void);"}, {"sha": "32883707615d535b839265a7f89df14942bcd999", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -117,7 +117,7 @@ impl<T> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n-                mem::move_val_init(xs.as_mut_slice().unsafe_mut_ref(xs.len),\n+                mem::overwrite(xs.as_mut_slice().unsafe_mut_ref(xs.len),\n                                    op(xs.len));\n                 xs.len += 1;\n             }\n@@ -214,7 +214,7 @@ impl<T: Clone> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n-                mem::move_val_init(xs.as_mut_slice().unsafe_mut_ref(xs.len),\n+                mem::overwrite(xs.as_mut_slice().unsafe_mut_ref(xs.len),\n                                    value.clone());\n                 xs.len += 1;\n             }\n@@ -325,7 +325,7 @@ impl<T:Clone> Clone for Vec<T> {\n             let this_slice = self.as_slice();\n             while vector.len < len {\n                 unsafe {\n-                    mem::move_val_init(\n+                    mem::overwrite(\n                         vector.as_mut_slice().unsafe_mut_ref(vector.len),\n                         this_slice.unsafe_ref(vector.len).clone());\n                 }\n@@ -600,7 +600,7 @@ impl<T> Vec<T> {\n \n         unsafe {\n             let end = (self.ptr as *T).offset(self.len as int) as *mut T;\n-            mem::move_val_init(&mut *end, value);\n+            mem::overwrite(&mut *end, value);\n             self.len += 1;\n         }\n     }\n@@ -963,7 +963,7 @@ impl<T> Vec<T> {\n                 ptr::copy_memory(p.offset(1), &*p, len - index);\n                 // Write it in, overwriting the first copy of the `index`th\n                 // element.\n-                mem::move_val_init(&mut *p, element);\n+                mem::overwrite(&mut *p, element);\n             }\n             self.set_len(len + 1);\n         }\n@@ -1542,8 +1542,10 @@ impl<T> FromVec<T> for ~[T] {\n         unsafe {\n             let ret = allocate(size, 8) as *mut RawVec<()>;\n \n-            (*ret).fill = len * mem::nonzero_size_of::<T>();\n-            (*ret).alloc = len * mem::nonzero_size_of::<T>();\n+            let a_size = mem::size_of::<T>();\n+            let a_size = if a_size == 0 {1} else {a_size};\n+            (*ret).fill = len * a_size;\n+            (*ret).alloc = len * a_size;\n \n             ptr::copy_nonoverlapping_memory(&mut (*ret).data as *mut _ as *mut u8,\n                                             vp as *u8, data_size);"}, {"sha": "97bf9e9e8e2a66e72e30a6c6dbb83fd6832a4cf5", "filename": "src/test/run-pass/type-use-i1-versus-i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Ftest%2Frun-pass%2Ftype-use-i1-versus-i8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4afc15e30c582d0ef994f12fc5eaa90bcaeab180/src%2Ftest%2Frun-pass%2Ftype-use-i1-versus-i8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-use-i1-versus-i8.rs?ref=4afc15e30c582d0ef994f12fc5eaa90bcaeab180", "patch": "@@ -14,6 +14,6 @@ pub fn main() {\n     unsafe {\n         let mut x: bool = false;\n         // this line breaks it\n-        mem::move_val_init(&mut x, false);\n+        mem::overwrite(&mut x, false);\n     }\n }"}]}