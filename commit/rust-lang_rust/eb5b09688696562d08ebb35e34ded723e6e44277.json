{"sha": "eb5b09688696562d08ebb35e34ded723e6e44277", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNWIwOTY4ODY5NjU2MmQwOGViYjM1ZTM0ZGVkNzIzZTZlNDQyNzc=", "commit": {"author": {"name": "Matthieu M", "email": "matthieum.147192@gmail.com", "date": "2019-02-03T15:58:29Z"}, "committer": {"name": "Matthieu M", "email": "matthieum.147192@gmail.com", "date": "2019-02-03T15:58:29Z"}, "message": "RangeInclusive internal iteration performance improvement.\n\nSpecialize Iterator::try_fold and DoubleEndedIterator::try_rfold to\nimprove code generation in all internal iteration scenarios.\n\nThis changes brings the performance of internal iteration with\nRangeInclusive on par with the performance of iteration with Range:\n\n - Single conditional jump in hot loop,\n - Unrolling and vectorization,\n - And even Closed Form substitution.\n\nUnfortunately, it only applies to internal iteration. Despite various\nattempts at stream-lining the implementation of next and next_back,\nLLVM has stubbornly refused to optimize external iteration\nappropriately, leaving me with a choice between:\n\n - The current implementation, for which Closed Form substitution is\n   performed, but which uses 2 conditional jumps in the hot loop when\n   optimization fail.\n - An implementation using a \"is_done\" boolean, which uses 1\n   conditional jump in the hot loop when optimization fail, allowing\n   unrolling and vectorization, but for which Closed Form substitution\n   fails.\n\nIn the absence of any conclusive evidence as to which usecase matters\nmost, and with no assurance that the lack of Closed Form substitution\nis not indicative of other optimizations being foiled, there is no way\nto pick one implementation over the other, and thus I defer to the\nstatu quo as far as next and next_back are concerned.", "tree": {"sha": "311ca64a210ca1b7a0c624ce9f5f81c6635f823a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/311ca64a210ca1b7a0c624ce9f5f81c6635f823a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb5b09688696562d08ebb35e34ded723e6e44277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb5b09688696562d08ebb35e34ded723e6e44277", "html_url": "https://github.com/rust-lang/rust/commit/eb5b09688696562d08ebb35e34ded723e6e44277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb5b09688696562d08ebb35e34ded723e6e44277/comments", "author": {"login": "matthieu-m", "id": 2420441, "node_id": "MDQ6VXNlcjI0MjA0NDE=", "avatar_url": "https://avatars.githubusercontent.com/u/2420441?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthieu-m", "html_url": "https://github.com/matthieu-m", "followers_url": "https://api.github.com/users/matthieu-m/followers", "following_url": "https://api.github.com/users/matthieu-m/following{/other_user}", "gists_url": "https://api.github.com/users/matthieu-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthieu-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthieu-m/subscriptions", "organizations_url": "https://api.github.com/users/matthieu-m/orgs", "repos_url": "https://api.github.com/users/matthieu-m/repos", "events_url": "https://api.github.com/users/matthieu-m/events{/privacy}", "received_events_url": "https://api.github.com/users/matthieu-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthieu-m", "id": 2420441, "node_id": "MDQ6VXNlcjI0MjA0NDE=", "avatar_url": "https://avatars.githubusercontent.com/u/2420441?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthieu-m", "html_url": "https://github.com/matthieu-m", "followers_url": "https://api.github.com/users/matthieu-m/followers", "following_url": "https://api.github.com/users/matthieu-m/following{/other_user}", "gists_url": "https://api.github.com/users/matthieu-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthieu-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthieu-m/subscriptions", "organizations_url": "https://api.github.com/users/matthieu-m/orgs", "repos_url": "https://api.github.com/users/matthieu-m/repos", "events_url": "https://api.github.com/users/matthieu-m/events{/privacy}", "received_events_url": "https://api.github.com/users/matthieu-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cae623c5ce12df8f237264d8f2c31fdaa664c382", "url": "https://api.github.com/repos/rust-lang/rust/commits/cae623c5ce12df8f237264d8f2c31fdaa664c382", "html_url": "https://github.com/rust-lang/rust/commit/cae623c5ce12df8f237264d8f2c31fdaa664c382"}], "stats": {"total": 53, "additions": 50, "deletions": 3}, "files": [{"sha": "52b0ccd48d47659994a8258e070930964b12185b", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/eb5b09688696562d08ebb35e34ded723e6e44277/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5b09688696562d08ebb35e34ded723e6e44277/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=eb5b09688696562d08ebb35e34ded723e6e44277", "patch": "@@ -1,6 +1,6 @@\n use convert::TryFrom;\n use mem;\n-use ops::{self, Add, Sub};\n+use ops::{self, Add, Sub, Try};\n use usize;\n \n use super::{FusedIterator, TrustedLen};\n@@ -368,11 +368,11 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n                 Some(Less) => {\n                     self.is_empty = Some(false);\n                     self.start = plus_n.add_one();\n-                    return Some(plus_n)\n+                    return Some(plus_n);\n                 }\n                 Some(Equal) => {\n                     self.is_empty = Some(true);\n-                    return Some(plus_n)\n+                    return Some(plus_n);\n                 }\n                 _ => {}\n             }\n@@ -382,6 +382,29 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         None\n     }\n \n+    #[inline]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.compute_is_empty();\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            let n = self.start.add_one();\n+            let n = mem::replace(&mut self.start, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        self.is_empty = Some(true);\n+        Try::from_ok(accum)\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<A> {\n         self.next_back()\n@@ -415,6 +438,28 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n             self.end.clone()\n         })\n     }\n+\n+    #[inline]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.compute_is_empty();\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            let n = self.end.sub_one();\n+            let n = mem::replace(&mut self.end, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        self.is_empty = Some(true);\n+        Try::from_ok(accum)\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]"}, {"sha": "6776ebdc66edc7827051038e0d6a53af10448320", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb5b09688696562d08ebb35e34ded723e6e44277/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5b09688696562d08ebb35e34ded723e6e44277/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=eb5b09688696562d08ebb35e34ded723e6e44277", "patch": "@@ -334,12 +334,14 @@ pub struct RangeInclusive<Idx> {\n trait RangeInclusiveEquality: Sized {\n     fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool;\n }\n+\n impl<T> RangeInclusiveEquality for T {\n     #[inline]\n     default fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n         range.is_empty.unwrap_or_default()\n     }\n }\n+\n impl<T: PartialOrd> RangeInclusiveEquality for T {\n     #[inline]\n     fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {"}]}