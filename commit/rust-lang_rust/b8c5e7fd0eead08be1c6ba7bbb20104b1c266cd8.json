{"sha": "b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YzVlN2ZkMGVlYWQwOGJlMWM2YmE3YmJiMjAxMDRiMWMyNjZjZDg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-22T03:18:42Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-22T04:02:11Z"}, "message": "refactor pointer handling in binops", "tree": {"sha": "e5fdbbdf029a5a1ae86fba6910f938b471720c3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5fdbbdf029a5a1ae86fba6910f938b471720c3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8", "html_url": "https://github.com/rust-lang/rust/commit/b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "184d3b3badb9072aee9a439386dcc8e905d1f800", "url": "https://api.github.com/repos/rust-lang/rust/commits/184d3b3badb9072aee9a439386dcc8e905d1f800", "html_url": "https://github.com/rust-lang/rust/commit/184d3b3badb9072aee9a439386dcc8e905d1f800"}], "stats": {"total": 152, "additions": 76, "deletions": 76}, "files": [{"sha": "1c8c1a5d490cbaf6ad9659508ac355109ba5edaa", "filename": "src/operator.rs", "status": "modified", "additions": 43, "deletions": 69, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8", "patch": "@@ -146,45 +146,52 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let left_kind  = self.ty_to_primval_kind(left_ty)?;\n         let right_kind = self.ty_to_primval_kind(right_ty)?;\n \n-        // Offset is handled early, before we dispatch to unrelated_ptr_ops.  We have to also catch the case where both arguments *are* convertible to integers.\n-        if bin_op == Offset {\n-            if left_kind == Ptr && right_kind == PrimValKind::from_uint_size(self.memory.pointer_size()) {\n-                let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n-                let ptr = self.pointer_offset(left, pointee_ty, right.to_bytes()? as i64)?;\n-                return Ok((ptr, false));\n-            } else {\n-                bug!(\"Offset used with wrong type\");\n-            }\n-        }\n-\n-        // unrelated pointer ops\n-        let op: Option<fn(&PrimVal, &PrimVal) -> bool> = match bin_op {\n-            Eq => Some(PrimVal::eq),\n-            Ne => Some(PrimVal::ne),\n-            _ => None,\n-        };\n-        if let Some(op) = op {\n-            // only floats can't be binary compared\n-            let ok = left_kind != F32 && left_kind != F64;\n-            let ok = ok && right_kind != F32 && right_kind != F64;\n-            if ok {\n-                return Ok((PrimVal::from_bool(op(&left, &right)), false));\n-            }\n-        }\n-\n-        \n-        if let (Ok(left), Ok(right)) = (left.to_ptr(), right.to_ptr()) {\n-            if left.alloc_id == right.alloc_id {\n-                return self.ptr_ops(\n-                    bin_op,\n-                    left.offset,\n-                    right.offset,\n-                );\n-            } else {\n-                return Err(EvalError::InvalidPointerMath);\n+        // I: Handle operations that support pointers\n+        let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n+        let isize = PrimValKind::from_int_size(self.memory.pointer_size());\n+        if !left_kind.is_float() && !right_kind.is_float() {\n+            match bin_op {\n+                Offset if left_kind == Ptr && right_kind == usize => {\n+                    let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n+                    let ptr = self.pointer_offset(left, pointee_ty, right.to_bytes()? as i64)?;\n+                    return Ok((ptr, false));\n+                },\n+                // These work on anything\n+                Eq if left_kind == right_kind => {\n+                    return Ok((PrimVal::from_bool(left == right), false));\n+                }\n+                Ne if left_kind == right_kind => {\n+                    return Ok((PrimVal::from_bool(left != right), false));\n+                }\n+                // These need both pointers to be in the same allocation\n+                Lt | Le | Gt | Ge | Sub\n+                if left_kind == right_kind\n+                && (left_kind == Ptr || left_kind == usize || left_kind == isize)\n+                && left.is_ptr() && right.is_ptr() => {\n+                    let left = left.to_ptr()?;\n+                    let right = right.to_ptr()?;\n+                    if left.alloc_id == right.alloc_id {\n+                        let res = match bin_op {\n+                            Lt => left.offset < right.offset,\n+                            Le => left.offset <= right.offset,\n+                            Gt => left.offset > right.offset,\n+                            Ge => left.offset >= right.offset,\n+                            Sub => {\n+                                return int_arithmetic!(left_kind, overflowing_sub, left.offset, right.offset);\n+                            }\n+                            _ => bug!(\"We already established it has to be one of these operators.\"),\n+                        };\n+                        return Ok((PrimVal::from_bool(res), false));\n+                    } else {\n+                        // Both are pointers, but from different allocations.\n+                        return Err(EvalError::InvalidPointerMath);\n+                    }\n+                }\n+                _ => {}\n             }\n         }\n \n+        // II: From now on, everything must be bytes, no pointers\n         let l = left.to_bytes()?;\n         let r = right.to_bytes()?;\n \n@@ -229,8 +236,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             (Div, F64) => f64_arithmetic!(/, l, r),\n             (Rem, F64) => f64_arithmetic!(%, l, r),\n \n-            (Eq, _) => PrimVal::from_bool(l == r),\n-            (Ne, _) => PrimVal::from_bool(l != r),\n             (Lt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) < (r as i128)),\n             (Lt, _) => PrimVal::from_bool(l <  r),\n             (Le, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) <= (r as i128)),\n@@ -258,37 +263,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         Ok((val, false))\n     }\n-\n-    fn ptr_ops(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: u64,\n-        right: u64,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n-        use rustc::mir::BinOp::*;\n-\n-        let val = match bin_op {\n-            Eq => PrimVal::from_bool(left == right),\n-            Ne => PrimVal::from_bool(left != right),\n-            Lt | Le | Gt | Ge => {\n-                PrimVal::from_bool(match bin_op {\n-                    Lt => left < right,\n-                    Le => left <= right,\n-                    Gt => left > right,\n-                    Ge => left >= right,\n-                    _ => bug!(\"We already established it has to be a comparison operator.\"),\n-                })\n-            }\n-            Sub => {\n-                let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n-                return int_arithmetic!(usize, overflowing_sub, left, right);\n-            }\n-            _ => {\n-                return Err(EvalError::ReadPointerAsBytes);\n-            }\n-        };\n-        Ok((val, false))\n-    }\n }\n \n pub fn unary_op<'tcx>("}, {"sha": "2f00d7eb1dff1b5e7010731d72e51d01d4a75b0b", "filename": "src/value.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8", "patch": "@@ -160,6 +160,27 @@ impl<'tcx> PrimVal {\n         }\n     }\n \n+    pub fn is_bytes(self) -> bool {\n+        match self {\n+            PrimVal::Bytes(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_ptr(self) -> bool {\n+        match self {\n+            PrimVal::Ptr(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_undef(self) -> bool {\n+        match self {\n+            PrimVal::Undef => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn to_u128(self) -> EvalResult<'tcx, u128> {\n         self.to_bytes()\n     }\n@@ -252,14 +273,11 @@ pub fn signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> EvalR\n }\n \n pub fn offset<'tcx>(val: u64, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n-    if let Some(res) = val.checked_add(i) {\n-        if res as u128 >= (1u128 << layout.pointer_size.bits()) {\n-            Err(EvalError::OverflowingMath)\n-        } else {\n-            Ok(res)\n-        }\n-    } else {\n+    let res = val.checked_add(i).ok_or(EvalError::OverflowingMath)?;\n+    if res as u128 >= (1u128 << layout.pointer_size.bits()) {\n         Err(EvalError::OverflowingMath)\n+    } else {\n+        Ok(res)\n     }\n }\n \n@@ -284,6 +302,14 @@ impl PrimValKind {\n         }\n     }\n \n+     pub fn is_float(self) -> bool {\n+        use self::PrimValKind::*;\n+        match self {\n+            F32 | F64 => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn from_uint_size(size: u64) -> Self {\n         match size {\n             1 => PrimValKind::U8,"}]}