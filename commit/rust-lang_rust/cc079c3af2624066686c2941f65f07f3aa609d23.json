{"sha": "cc079c3af2624066686c2941f65f07f3aa609d23", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMDc5YzNhZjI2MjQwNjY2ODZjMjk0MWY2NWYwN2YzYWE2MDlkMjM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T03:39:48Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T08:09:24Z"}, "message": "Refactor away `ImportResolvingError`.", "tree": {"sha": "5bb716f19daac445a512f19028556bf988fdeda2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bb716f19daac445a512f19028556bf988fdeda2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc079c3af2624066686c2941f65f07f3aa609d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc079c3af2624066686c2941f65f07f3aa609d23", "html_url": "https://github.com/rust-lang/rust/commit/cc079c3af2624066686c2941f65f07f3aa609d23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc079c3af2624066686c2941f65f07f3aa609d23/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cd43f6ee92fa3a235482fa28c5ac2c799018b8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cd43f6ee92fa3a235482fa28c5ac2c799018b8a", "html_url": "https://github.com/rust-lang/rust/commit/6cd43f6ee92fa3a235482fa28c5ac2c799018b8a"}], "stats": {"total": 40, "additions": 10, "deletions": 30}, "files": [{"sha": "bde175bcd6f196add9f24acbc20637995e56baa4", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cc079c3af2624066686c2941f65f07f3aa609d23/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc079c3af2624066686c2941f65f07f3aa609d23/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=cc079c3af2624066686c2941f65f07f3aa609d23", "patch": "@@ -342,12 +342,6 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-struct ImportResolvingError<'a> {\n-    import_directive: &'a ImportDirective<'a>,\n-    span: Span,\n-    help: String,\n-}\n-\n struct ImportResolver<'a, 'b: 'a> {\n     resolver: &'a mut Resolver<'b>,\n }\n@@ -416,34 +410,33 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             self.finalize_resolutions_in(module);\n         }\n \n-        let mut errors = Vec::new();\n+        let mut errors = false;\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n             if let Failed(err) = self.finalize_import(import) {\n+                errors = true;\n                 let (span, help) = match err {\n                     Some((span, msg)) => (span, format!(\". {}\", msg)),\n                     None => (import.span, String::new()),\n                 };\n-                errors.push(ImportResolvingError {\n-                    import_directive: import,\n-                    span: span,\n-                    help: help,\n-                });\n+\n+                // If the error is a single failed import then create a \"fake\" import\n+                // resolution for it so that later resolve stages won't complain.\n+                self.import_dummy_binding(import);\n+                let path = import_path_to_string(&import.module_path, &import.subclass);\n+                let error = ResolutionError::UnresolvedImport(Some((&path, &help)));\n+                resolve_error(self.resolver, span, error);\n             }\n         }\n \n         // Report unresolved imports only if no hard error was already reported\n         // to avoid generating multiple errors on the same import.\n-        if errors.len() == 0 {\n+        if !errors {\n             if let Some(import) = self.indeterminate_imports.iter().next() {\n                 let error = ResolutionError::UnresolvedImport(None);\n                 resolve_error(self.resolver, import.span, error);\n             }\n         }\n-\n-        for e in errors {\n-            self.import_resolving_error(e)\n-        }\n     }\n \n     // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n@@ -462,19 +455,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    /// Resolves an `ImportResolvingError` into the correct enum discriminant\n-    /// and passes that on to `resolve_error`.\n-    fn import_resolving_error(&mut self, e: ImportResolvingError<'b>) {\n-        // If the error is a single failed import then create a \"fake\" import\n-        // resolution for it so that later resolve stages won't complain.\n-        self.import_dummy_binding(e.import_directive);\n-        let path = import_path_to_string(&e.import_directive.module_path,\n-                                         &e.import_directive.subclass);\n-        resolve_error(self.resolver,\n-                      e.span,\n-                      ResolutionError::UnresolvedImport(Some((&path, &e.help))));\n-    }\n-\n     /// Attempts to resolve the given import. The return value indicates\n     /// failure if we're certain the name does not exist, indeterminate if we\n     /// don't know whether the name exists at the moment due to other"}]}