{"sha": "f1d682334d07e125595bb73735b6045bedfb30c4", "node_id": "C_kwDOAAsO6NoAKGYxZDY4MjMzNGQwN2UxMjU1OTViYjczNzM1YjYwNDViZWRmYjMwYzQ", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-12-21T21:31:35Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-12-21T21:34:12Z"}, "message": "Add `#[rustc_clean(loaded_from_disk)]` to assert loading of query result\n\nCurrently, you can use `#[rustc_clean]` to assert to that a particular\nquery (technically, a `DepNode`) is green or red. However, a green\n`DepNode` does not mean that the query result was actually deserialized\nfrom disk - we might have never re-run a query that needed the result.\n\nSome incremental tests are written as regression tests for ICEs that\noccured during query result decoding. Using\n`#[rustc_clean(loaded_from_disk=\"typeck\")]`, you can now assert\nthat the result of a particular query (e.g. `typeck`) was actually\nloaded from disk, in addition to being green.", "tree": {"sha": "75b6c4b5469f4166668ab3c67721ee0a169240b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75b6c4b5469f4166668ab3c67721ee0a169240b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1d682334d07e125595bb73735b6045bedfb30c4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmHCSFcACgkQtAh+UQ6Y\nsWQvAg//XNqJz2LvC38GhSH2mH9aRI9fLuswmrVFhQBpfrXEHufAdoG9ZEAr3hzZ\nDgw6WDa2uK8lUuTh6B3mcM5G+yYc0jGrmsrZL0GZhsfbMH7HvQO4ouxxli53Vt7T\nfzuaghIA4QiOSbnNBNrdpA4PEedJOXCWoi2L/TTof4OggFk3oGMvp+ZJcVO9Rh2q\n/FEo0AsknehL218YEvubhRQHzRoiwkyOTjxWp0KfVDpIyupCqoUp1sRq2K3rowI0\nPwiTf39w/sucRMQr9MY+KOViw69bhsVns0XMagqG79ptm2TC5CPIjl31Kci0qz9E\ntmUDC8AHeNNpkqX2QsQtY5xjiZcaNUTS+ZlifCzYUGJEUQRcKCnBkORzP1npJBs+\nAd0md+j7QyZbhK9uKreg5IZlmv14yir8awwZXnBiTjLotPGBrXeSm6pm5YVkKIE7\nRjnsvgFJOv8Xhvxnla7zuAqCraOaVUXROqqQmsYS0aOdOQWfEaDil2cJueM51TaI\nm77JFPqNbr1dvSMXOcVbvVuT/ZTzcUFkc7Nod8iBKPVg9raCutoLpp82hOms0NGv\nZdVLw3jx6EATDfsnAJ2cvIu0HWvvnhefcqVCqtFKeFCbY8NNINHFHhV2cN+gQysN\nxNeEtaQ06dqgxrHqm02cjdQzRNqkO1WG6xYxufnqUSB6f0e1HLI=\n=kSIo\n-----END PGP SIGNATURE-----", "payload": "tree 75b6c4b5469f4166668ab3c67721ee0a169240b0\nparent e100ec5bc7cd768ec17d75448b29c9ab4a39272b\nauthor Aaron Hill <aa1ronham@gmail.com> 1640122295 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1640122452 -0500\n\nAdd `#[rustc_clean(loaded_from_disk)]` to assert loading of query result\n\nCurrently, you can use `#[rustc_clean]` to assert to that a particular\nquery (technically, a `DepNode`) is green or red. However, a green\n`DepNode` does not mean that the query result was actually deserialized\nfrom disk - we might have never re-run a query that needed the result.\n\nSome incremental tests are written as regression tests for ICEs that\noccured during query result decoding. Using\n`#[rustc_clean(loaded_from_disk=\"typeck\")]`, you can now assert\nthat the result of a particular query (e.g. `typeck`) was actually\nloaded from disk, in addition to being green.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1d682334d07e125595bb73735b6045bedfb30c4", "html_url": "https://github.com/rust-lang/rust/commit/f1d682334d07e125595bb73735b6045bedfb30c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1d682334d07e125595bb73735b6045bedfb30c4/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e100ec5bc7cd768ec17d75448b29c9ab4a39272b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e100ec5bc7cd768ec17d75448b29c9ab4a39272b", "html_url": "https://github.com/rust-lang/rust/commit/e100ec5bc7cd768ec17d75448b29c9ab4a39272b"}], "stats": {"total": 67, "additions": 64, "deletions": 3}, "files": [{"sha": "88795679943fb98e49b5b7f87df5d29b66d98c23", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f1d682334d07e125595bb73735b6045bedfb30c4/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d682334d07e125595bb73735b6045bedfb30c4/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=f1d682334d07e125595bb73735b6045bedfb30c4", "patch": "@@ -9,6 +9,13 @@\n //! - `#[rustc_clean(cfg=\"rev2\")]` same as above, except that the\n //!   fingerprints must be the SAME (along with all other fingerprints).\n //!\n+//! - `#[rustc_clean(cfg=\"rev2\", loaded_from_disk='typeck\")]` asserts that\n+//!   the query result for `DepNode::typeck(X)` was actually\n+//!   loaded from disk (not just marked green). This can be useful\n+//!   to ensure that a test is actually exercising the deserialization\n+//!   logic for a particular query result. This can be combined with\n+//!   `except`\n+//!\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n \n@@ -28,6 +35,7 @@ use rustc_span::Span;\n use std::iter::FromIterator;\n use std::vec::Vec;\n \n+const LOADED_FROM_DISK: Symbol = sym::loaded_from_disk;\n const EXCEPT: Symbol = sym::except;\n const CFG: Symbol = sym::cfg;\n \n@@ -124,6 +132,7 @@ type Labels = FxHashSet<String>;\n struct Assertion {\n     clean: Labels,\n     dirty: Labels,\n+    loaded_from_disk: Labels,\n }\n \n pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n@@ -174,6 +183,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n     fn assertion_auto(&mut self, item_id: LocalDefId, attr: &Attribute) -> Assertion {\n         let (name, mut auto) = self.auto_labels(item_id, attr);\n         let except = self.except(attr);\n+        let loaded_from_disk = self.loaded_from_disk(attr);\n         for e in except.iter() {\n             if !auto.remove(e) {\n                 let msg = format!(\n@@ -183,7 +193,19 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n                 self.tcx.sess.span_fatal(attr.span, &msg);\n             }\n         }\n-        Assertion { clean: auto, dirty: except }\n+        Assertion { clean: auto, dirty: except, loaded_from_disk }\n+    }\n+\n+    /// `loaded_from_disk=` attribute value\n+    fn loaded_from_disk(&self, attr: &Attribute) -> Labels {\n+        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+            if item.has_name(LOADED_FROM_DISK) {\n+                let value = expect_associated_value(self.tcx, &item);\n+                return self.resolve_labels(&item, value);\n+            }\n+        }\n+        // If `loaded_from_disk=` is not specified, don't assert anything\n+        Labels::default()\n     }\n \n     /// `except=` attribute value\n@@ -332,6 +354,18 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n         }\n     }\n \n+    fn assert_loaded_from_disk(&self, item_span: Span, dep_node: DepNode) {\n+        debug!(\"assert_loaded_from_disk({:?})\", dep_node);\n+\n+        if !self.tcx.dep_graph.debug_was_loaded_from_disk(dep_node) {\n+            let dep_node_str = self.dep_node_str(&dep_node);\n+            self.tcx.sess.span_err(\n+                item_span,\n+                &format!(\"`{}` should have been loaded from disk but it was not\", dep_node_str),\n+            );\n+        }\n+    }\n+\n     fn check_item(&mut self, item_id: LocalDefId, item_span: Span) {\n         let def_path_hash = self.tcx.def_path_hash(item_id.to_def_id());\n         for attr in self.tcx.get_attrs(item_id.to_def_id()).iter() {\n@@ -348,6 +382,10 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n                 let dep_node = DepNode::from_label_string(self.tcx, &label, def_path_hash).unwrap();\n                 self.assert_dirty(item_span, dep_node);\n             }\n+            for label in assertion.loaded_from_disk {\n+                let dep_node = DepNode::from_label_string(self.tcx, &label, def_path_hash).unwrap();\n+                self.assert_loaded_from_disk(item_span, dep_node);\n+            }\n         }\n     }\n }\n@@ -382,7 +420,7 @@ fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {\n             let value = expect_associated_value(tcx, &item);\n             debug!(\"check_config: searching for cfg {:?}\", value);\n             cfg = Some(config.contains(&(value, None)));\n-        } else if !item.has_name(EXCEPT) {\n+        } else if !(item.has_name(EXCEPT) || item.has_name(LOADED_FROM_DISK)) {\n             tcx.sess.span_err(attr.span, &format!(\"unknown item `{}`\", item.name_or_empty()));\n         }\n     }"}, {"sha": "7bc3fd718e00901b4f62fbbbfe14ceb4bd27a425", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1d682334d07e125595bb73735b6045bedfb30c4/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d682334d07e125595bb73735b6045bedfb30c4/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=f1d682334d07e125595bb73735b6045bedfb30c4", "patch": "@@ -88,6 +88,11 @@ struct DepGraphData<K: DepKind> {\n     previous_work_products: FxHashMap<WorkProductId, WorkProduct>,\n \n     dep_node_debug: Lock<FxHashMap<DepNode<K>, String>>,\n+\n+    /// Used by incremental compilation tests to assert that\n+    /// a particular query result was decoded from disk\n+    /// (not just marked green)\n+    debug_loaded_from_disk: Lock<FxHashSet<DepNode<K>>>,\n }\n \n pub fn hash_result<R>(hcx: &mut StableHashingContext<'_>, result: &R) -> Fingerprint\n@@ -135,6 +140,7 @@ impl<K: DepKind> DepGraph<K> {\n                 processed_side_effects: Default::default(),\n                 previous: prev_graph,\n                 colors: DepNodeColorMap::new(prev_graph_node_count),\n+                debug_loaded_from_disk: Default::default(),\n             })),\n             virtual_dep_node_index: Lrc::new(AtomicU32::new(0)),\n         }\n@@ -438,6 +444,14 @@ impl<K: DepKind> DepGraph<K> {\n         &self.data.as_ref().unwrap().previous_work_products\n     }\n \n+    pub fn mark_debug_loaded_from_disk(&self, dep_node: DepNode<K>) {\n+        self.data.as_ref().unwrap().debug_loaded_from_disk.lock().insert(dep_node);\n+    }\n+\n+    pub fn debug_was_loaded_from_disk(&self, dep_node: DepNode<K>) -> bool {\n+        self.data.as_ref().unwrap().debug_loaded_from_disk.lock().contains(&dep_node)\n+    }\n+\n     #[inline(always)]\n     pub fn register_dep_node_debug_str<F>(&self, dep_node: DepNode<K>, debug_str_gen: F)\n     where"}, {"sha": "33732f9df73481dca750798adff8af352b9a07e4", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d682334d07e125595bb73735b6045bedfb30c4/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d682334d07e125595bb73735b6045bedfb30c4/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=f1d682334d07e125595bb73735b6045bedfb30c4", "patch": "@@ -519,6 +519,10 @@ where\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n         if let Some(result) = result {\n+            if unlikely!(tcx.dep_context().sess().opts.debugging_opts.query_dep_graph) {\n+                dep_graph.mark_debug_loaded_from_disk(*dep_node)\n+            }\n+\n             let prev_fingerprint = tcx\n                 .dep_context()\n                 .dep_graph()"}, {"sha": "84cf8878af8095fb00b090386bb3cb09f98f543a", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1d682334d07e125595bb73735b6045bedfb30c4/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d682334d07e125595bb73735b6045bedfb30c4/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=f1d682334d07e125595bb73735b6045bedfb30c4", "patch": "@@ -788,6 +788,7 @@ symbols! {\n         literal,\n         llvm_asm,\n         load,\n+        loaded_from_disk,\n         local,\n         local_inner_macros,\n         log10f32,"}, {"sha": "d57267adc6bdc86c3fabfc71619ecf04c6168ea3", "filename": "src/test/incremental/change_private_fn/struct_point.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1d682334d07e125595bb73735b6045bedfb30c4/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d682334d07e125595bb73735b6045bedfb30c4/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs?ref=f1d682334d07e125595bb73735b6045bedfb30c4", "patch": "@@ -51,7 +51,11 @@ pub mod point {\n pub mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    #[rustc_clean(cfg=\"cfail2\")]\n+    // The cached result should actually be loaded from disk\n+    // (not just marked green) - for example, `DeadVisitor`\n+    // always runs during compilation as a \"pass\", and loads\n+    // the typeck results for bodies.\n+    #[rustc_clean(cfg=\"cfail2\", loaded_from_disk=\"typeck\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();"}]}