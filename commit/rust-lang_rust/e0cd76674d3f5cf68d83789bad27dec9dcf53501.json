{"sha": "e0cd76674d3f5cf68d83789bad27dec9dcf53501", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwY2Q3NjY3NGQzZjVjZjY4ZDgzNzg5YmFkMjdkZWM5ZGNmNTM1MDE=", "commit": {"author": {"name": "Alex Burka", "email": "alex@alexburka.com", "date": "2017-04-03T00:09:07Z"}, "committer": {"name": "Alex Burka", "email": "alex@alexburka.com", "date": "2017-04-15T19:06:58Z"}, "message": "feature gate :vis matcher", "tree": {"sha": "2ad22a4ee7ee6dfb04e9350c77c754e7229beafc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ad22a4ee7ee6dfb04e9350c77c754e7229beafc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0cd76674d3f5cf68d83789bad27dec9dcf53501", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0cd76674d3f5cf68d83789bad27dec9dcf53501", "html_url": "https://github.com/rust-lang/rust/commit/e0cd76674d3f5cf68d83789bad27dec9dcf53501", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0cd76674d3f5cf68d83789bad27dec9dcf53501/comments", "author": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d468050574cc28a06ef684727e1106fa660a20c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d468050574cc28a06ef684727e1106fa660a20c", "html_url": "https://github.com/rust-lang/rust/commit/1d468050574cc28a06ef684727e1106fa660a20c"}], "stats": {"total": 101, "additions": 77, "deletions": 24}, "files": [{"sha": "c797c151de67c602f2a71a1cd302a8e3d5da6933", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e0cd76674d3f5cf68d83789bad27dec9dcf53501", "patch": "@@ -521,7 +521,9 @@ impl<'a> Resolver<'a> {\n             LoadedMacro::ProcMacro(ext) => return ext,\n         };\n \n-        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &macro_def));\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess,\n+                                               &self.session.features,\n+                                               &macro_def));\n         self.macro_map.insert(def_id, ext.clone());\n         ext\n     }"}, {"sha": "030e3936de994fb24c436b5bb389e209855afd75", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e0cd76674d3f5cf68d83789bad27dec9dcf53501", "patch": "@@ -671,7 +671,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         let def_id = self.definitions.local_def_id(item.id);\n-        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, item));\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess,\n+                                               &self.session.features,\n+                                               item));\n         self.macro_map.insert(def_id, ext);\n         *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n             parent: Cell::new(*legacy_scope), name: ident.name, def_id: def_id, span: item.span,"}, {"sha": "be979960725a91cfe6c7786ee0eb1d9150b9c2fb", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e0cd76674d3f5cf68d83789bad27dec9dcf53501", "patch": "@@ -18,13 +18,15 @@ use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n use ext::tt::quoted;\n use ext::tt::transcribe::transcribe;\n+use feature_gate::{self, emit_feature_err, Features, GateIssue};\n use parse::{Directory, ParseSess};\n use parse::parser::Parser;\n use parse::token::{self, NtTT};\n use parse::token::Token::*;\n use symbol::Symbol;\n use tokenstream::{TokenStream, TokenTree};\n \n+use std::cell::RefCell;\n use std::collections::{HashMap};\n use std::collections::hash_map::{Entry};\n use std::rc::Rc;\n@@ -154,7 +156,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n // Holy self-referential!\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n+pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item) -> SyntaxExtension {\n     let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n     let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n@@ -208,7 +210,7 @@ pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n                 if let MatchedNonterminal(ref nt) = **m {\n                     if let NtTT(ref tt) = **nt {\n                         let tt = quoted::parse(tt.clone().into(), true, sess).pop().unwrap();\n-                        valid &= check_lhs_nt_follows(sess, &tt);\n+                        valid &= check_lhs_nt_follows(sess, features, &tt);\n                         return tt;\n                     }\n                 }\n@@ -251,11 +253,13 @@ pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n     NormalTT(exp, Some(def.span), attr::contains_name(&def.attrs, \"allow_internal_unstable\"))\n }\n \n-fn check_lhs_nt_follows(sess: &ParseSess, lhs: &quoted::TokenTree) -> bool {\n+fn check_lhs_nt_follows(sess: &ParseSess,\n+                        features: &RefCell<Features>,\n+                        lhs: &quoted::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     match lhs {\n-        &quoted::TokenTree::Delimited(_, ref tts) => check_matcher(sess, &tts.tts),\n+        &quoted::TokenTree::Delimited(_, ref tts) => check_matcher(sess, features, &tts.tts),\n         _ => {\n             let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n             sess.span_diagnostic.span_err(lhs.span(), msg);\n@@ -307,11 +311,13 @@ fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool {\n     false\n }\n \n-fn check_matcher(sess: &ParseSess, matcher: &[quoted::TokenTree]) -> bool {\n+fn check_matcher(sess: &ParseSess,\n+                 features: &RefCell<Features>,\n+                 matcher: &[quoted::TokenTree]) -> bool {\n     let first_sets = FirstSets::new(matcher);\n     let empty_suffix = TokenSet::empty();\n     let err = sess.span_diagnostic.err_count();\n-    check_matcher_core(sess, &first_sets, matcher, &empty_suffix);\n+    check_matcher_core(sess, features, &first_sets, matcher, &empty_suffix);\n     err == sess.span_diagnostic.err_count()\n }\n \n@@ -553,6 +559,7 @@ impl TokenSet {\n // Requires that `first_sets` is pre-computed for `matcher`;\n // see `FirstSets::new`.\n fn check_matcher_core(sess: &ParseSess,\n+                      features: &RefCell<Features>,\n                       first_sets: &FirstSets,\n                       matcher: &[quoted::TokenTree],\n                       follow: &TokenSet) -> TokenSet {\n@@ -583,12 +590,11 @@ fn check_matcher_core(sess: &ParseSess,\n         match *token {\n             TokenTree::Token(..) | TokenTree::MetaVarDecl(..) => {\n                 let can_be_followed_by_any;\n-                if let Err(bad_frag) = has_legal_fragment_specifier(token) {\n+                if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, token) {\n                     let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n                     sess.span_diagnostic.struct_span_err(token.span(), &msg)\n-                        .help(\"valid fragment specifiers are `ident`, `block`, \\\n-                               `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n-                               and `item`\")\n+                        .help(\"valid fragment specifiers are `ident`, `block`, `stmt`, `expr`, \\\n+                              `pat`, `ty`, `path`, `meta`, `tt`, `item` and `vis`\")\n                         .emit();\n                     // (This eliminates false positives and duplicates\n                     // from error messages.)\n@@ -610,7 +616,7 @@ fn check_matcher_core(sess: &ParseSess,\n             }\n             TokenTree::Delimited(span, ref d) => {\n                 let my_suffix = TokenSet::singleton(d.close_tt(span));\n-                check_matcher_core(sess, first_sets, &d.tts, &my_suffix);\n+                check_matcher_core(sess, features, first_sets, &d.tts, &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n \n@@ -642,7 +648,7 @@ fn check_matcher_core(sess: &ParseSess,\n                 // At this point, `suffix_first` is built, and\n                 // `my_suffix` is some TokenSet that we can use\n                 // for checking the interior of `seq_rep`.\n-                let next = check_matcher_core(sess, first_sets, &seq_rep.tts, my_suffix);\n+                let next = check_matcher_core(sess, features, first_sets, &seq_rep.tts, my_suffix);\n                 if next.maybe_empty {\n                     last.add_all(&next);\n                 } else {\n@@ -807,27 +813,44 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n             \"\" => Ok(true), // keywords::Invalid\n             _ => Err((format!(\"invalid fragment specifier `{}`\", frag),\n                      \"valid fragment specifiers are `ident`, `block`, \\\n-                      `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n-                      and `item`\"))\n+                      `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt`, \\\n+                      `item` and `vis`\"))\n         }\n     }\n }\n \n-fn has_legal_fragment_specifier(tok: &quoted::TokenTree) -> Result<(), String> {\n+fn has_legal_fragment_specifier(sess: &ParseSess,\n+                                features: &RefCell<Features>,\n+                                tok: &quoted::TokenTree) -> Result<(), String> {\n     debug!(\"has_legal_fragment_specifier({:?})\", tok);\n-    if let quoted::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n-        let s = &frag_spec.name.as_str();\n-        if !is_legal_fragment_specifier(s) {\n-            return Err(s.to_string());\n+    if let quoted::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n+        let frag_name = frag_spec.name.as_str();\n+        let frag_span = tok.span();\n+        if !is_legal_fragment_specifier(sess, features, &frag_name, frag_span) {\n+            return Err(frag_name.to_string());\n         }\n     }\n     Ok(())\n }\n \n-fn is_legal_fragment_specifier(frag: &str) -> bool {\n-    match frag {\n+fn is_legal_fragment_specifier(sess: &ParseSess,\n+                               features: &RefCell<Features>,\n+                               frag_name: &str,\n+                               frag_span: Span) -> bool {\n+    match frag_name {\n         \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" |\n-        \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"vis\" | \"\" => true,\n+        \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"\" => true,\n+        \"vis\" => {\n+            if !features.borrow().macro_vis_matcher {\n+                let explain = feature_gate::EXPLAIN_VIS_MATCHER;\n+                emit_feature_err(sess,\n+                                 \"macro_vis_matcher\",\n+                                 frag_span,\n+                                 GateIssue::Language,\n+                                 explain);\n+            }\n+            true\n+        },\n         _ => false,\n     }\n }"}, {"sha": "aee6da93e5069e89bc54634b146b69627d8155ca", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e0cd76674d3f5cf68d83789bad27dec9dcf53501", "patch": "@@ -352,6 +352,9 @@ declare_features! (\n \n     // Allows overlapping impls of marker traits\n     (active, overlapping_marker_traits, \"1.18.0\", Some(29864)),\n+    \n+    // Allows use of the :vis macro fragment specifier\n+    (active, macro_vis_matcher, \"1.18.0\", Some(41022)),\n );\n \n declare_features! (\n@@ -1012,6 +1015,9 @@ pub const EXPLAIN_DEPR_CUSTOM_DERIVE: &'static str =\n pub const EXPLAIN_DERIVE_UNDERSCORE: &'static str =\n     \"attributes of the form `#[derive_*]` are reserved for the compiler\";\n \n+pub const EXPLAIN_VIS_MATCHER: &'static str =\n+    \":vis fragment specifier is experimental and subject to change\";\n+\n pub const EXPLAIN_PLACEMENT_IN: &'static str =\n     \"placement-in expression syntax is experimental and subject to change.\";\n "}, {"sha": "5d6f2acea83cea7c31da88f4f36a91de4b8988f1", "filename": "src/test/compile-fail/feature-gate-macro-vis-matcher.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Ftest%2Fcompile-fail%2Ffeature-gate-macro-vis-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Ftest%2Fcompile-fail%2Ffeature-gate-macro-vis-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-macro-vis-matcher.rs?ref=e0cd76674d3f5cf68d83789bad27dec9dcf53501", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the MSP430 interrupt ABI cannot be used when msp430_interrupt\n+// feature gate is not used.\n+\n+macro_rules! m { ($v:vis) => {} }\n+//~^ ERROR :vis fragment specifier is experimental and subject to change\n+\n+fn main() {\n+    m!(pub);\n+}"}, {"sha": "1a7529fe2b41209e7db161545a2e898ae94ae2e4", "filename": "src/test/run-pass/macro-pub-matcher.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0cd76674d3f5cf68d83789bad27dec9dcf53501/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-pub-matcher.rs?ref=e0cd76674d3f5cf68d83789bad27dec9dcf53501", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![allow(dead_code, unused_imports)]\n+#![feature(macro_vis_matcher)]\n \n /**\n Ensure that `:vis` matches can be captured in existing positions, and passed"}]}