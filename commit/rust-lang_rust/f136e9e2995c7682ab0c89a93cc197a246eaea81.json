{"sha": "f136e9e2995c7682ab0c89a93cc197a246eaea81", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMzZlOWUyOTk1Yzc2ODJhYjBjODlhOTNjYzE5N2EyNDZlYWVhODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-22T03:29:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-22T03:29:25Z"}, "message": "Auto merge of #37337 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 10 pull requests\n\n- Successful merges: #37043, #37209, #37211, #37219, #37244, #37253, #37286, #37297, #37309, #37314\n- Failed merges:", "tree": {"sha": "061aaed5771f060ee9c6dd415b17a9228adcec7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/061aaed5771f060ee9c6dd415b17a9228adcec7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f136e9e2995c7682ab0c89a93cc197a246eaea81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f136e9e2995c7682ab0c89a93cc197a246eaea81", "html_url": "https://github.com/rust-lang/rust/commit/f136e9e2995c7682ab0c89a93cc197a246eaea81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f136e9e2995c7682ab0c89a93cc197a246eaea81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6fa57291b2a4e94da00cb078fb7f9f3366bc9cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6fa57291b2a4e94da00cb078fb7f9f3366bc9cb", "html_url": "https://github.com/rust-lang/rust/commit/a6fa57291b2a4e94da00cb078fb7f9f3366bc9cb"}, {"sha": "1c2d2235c976a14c4e17e9d258e3e0a500078409", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2d2235c976a14c4e17e9d258e3e0a500078409", "html_url": "https://github.com/rust-lang/rust/commit/1c2d2235c976a14c4e17e9d258e3e0a500078409"}], "stats": {"total": 396, "additions": 263, "deletions": 133}, "files": [{"sha": "879eca60cc751e8430d8dd62a350d7bef78dc06a", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -36,8 +36,9 @@ fn main() {\n     let args = env::args_os().skip(1).collect::<Vec<_>>();\n     // Detect whether or not we're a build script depending on whether --target\n     // is passed (a bit janky...)\n-    let target = args.windows(2).find(|w| &*w[0] == \"--target\")\n-                                .and_then(|w| w[1].to_str());\n+    let target = args.windows(2)\n+        .find(|w| &*w[0] == \"--target\")\n+        .and_then(|w| w[1].to_str());\n     let version = args.iter().find(|w| &**w == \"-vV\");\n \n     // Build scripts always use the snapshot compiler which is guaranteed to be\n@@ -64,9 +65,10 @@ fn main() {\n \n     let mut cmd = Command::new(rustc);\n     cmd.args(&args)\n-       .arg(\"--cfg\").arg(format!(\"stage{}\", stage))\n-       .env(bootstrap::util::dylib_path_var(),\n-            env::join_paths(&dylib_path).unwrap());\n+        .arg(\"--cfg\")\n+        .arg(format!(\"stage{}\", stage))\n+        .env(bootstrap::util::dylib_path_var(),\n+             env::join_paths(&dylib_path).unwrap());\n \n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we\n@@ -101,9 +103,8 @@ fn main() {\n         // This... is a bit of a hack how we detect this. Ideally this\n         // information should be encoded in the crate I guess? Would likely\n         // require an RFC amendment to RFC 1513, however.\n-        let is_panic_abort = args.windows(2).any(|a| {\n-            &*a[0] == \"--crate-name\" && &*a[1] == \"panic_abort\"\n-        });\n+        let is_panic_abort = args.windows(2)\n+            .any(|a| &*a[0] == \"--crate-name\" && &*a[1] == \"panic_abort\");\n         if is_panic_abort {\n             cmd.arg(\"-C\").arg(\"panic=abort\");\n         }\n@@ -116,7 +117,7 @@ fn main() {\n             cmd.arg(\"-Cdebuginfo=1\");\n         }\n         let debug_assertions = match env::var(\"RUSTC_DEBUG_ASSERTIONS\") {\n-            Ok(s) => if s == \"true\" {\"y\"} else {\"n\"},\n+            Ok(s) => if s == \"true\" { \"y\" } else { \"n\" },\n             Err(..) => \"n\",\n         };\n         cmd.arg(\"-C\").arg(format!(\"debug-assertions={}\", debug_assertions));"}, {"sha": "67358e540dad0c1419745658bb0548d9934ec2d8", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -29,10 +29,12 @@ fn main() {\n \n     let mut cmd = Command::new(rustdoc);\n     cmd.args(&args)\n-       .arg(\"--cfg\").arg(format!(\"stage{}\", stage))\n-       .arg(\"--cfg\").arg(\"dox\")\n-       .env(bootstrap::util::dylib_path_var(),\n-            env::join_paths(&dylib_path).unwrap());\n+        .arg(\"--cfg\")\n+        .arg(format!(\"stage{}\", stage))\n+        .arg(\"--cfg\")\n+        .arg(\"dox\")\n+        .env(bootstrap::util::dylib_path_var(),\n+             env::join_paths(&dylib_path).unwrap());\n     std::process::exit(match cmd.status() {\n         Ok(s) => s.code().unwrap_or(1),\n         Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),"}, {"sha": "38844fb6c9ef0748c100a1756e72191b6c42d1e2", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -25,7 +25,9 @@ pub fn run_silent(cmd: &mut Command) {\n     };\n     if !status.success() {\n         fail(&format!(\"command did not execute successfully: {:?}\\n\\\n-                       expected success, got: {}\", cmd, status));\n+                       expected success, got: {}\",\n+                      cmd,\n+                      status));\n     }\n }\n \n@@ -65,7 +67,9 @@ pub fn output(cmd: &mut Command) -> String {\n     };\n     if !output.status.success() {\n         panic!(\"command did not execute successfully: {:?}\\n\\\n-                expected success, got: {}\", cmd, output.status);\n+                expected success, got: {}\",\n+               cmd,\n+               output.status);\n     }\n     String::from_utf8(output.stdout).unwrap()\n }"}, {"sha": "4e0e3728689417968fc87cdddcd035dc5dee9030", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -276,7 +276,7 @@ displaying the message.\n [expect]: ../std/result/enum.Result.html#method.expect\n [panic]: error-handling.html\n \n-If we leave off calling this method, our program will compile, but\n+If we do not call `expect()`, our program will compile, but\n we\u2019ll get a warning:\n \n ```bash"}, {"sha": "f23ea0ea8bf710dcf7794e2560ca14e7eb6595f6", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -57,11 +57,7 @@ impl<T> RawVec<T> {\n     pub fn new() -> Self {\n         unsafe {\n             // !0 is usize::MAX. This branch should be stripped at compile time.\n-            let cap = if mem::size_of::<T>() == 0 {\n-                !0\n-            } else {\n-                0\n-            };\n+            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n \n             // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n             RawVec {\n@@ -209,11 +205,7 @@ impl<T> RawVec<T> {\n \n             let (new_cap, ptr) = if self.cap == 0 {\n                 // skip to 4 because tiny Vec's are dumb; but not if that would cause overflow\n-                let new_cap = if elem_size > (!0) / 8 {\n-                    1\n-                } else {\n-                    4\n-                };\n+                let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                 let ptr = heap::allocate(new_cap * elem_size, align);\n                 (new_cap, ptr)\n             } else {\n@@ -347,7 +339,7 @@ impl<T> RawVec<T> {\n         let elem_size = mem::size_of::<T>();\n         // Nothing we can really do about these checks :(\n         let required_cap = used_cap.checked_add(needed_extra_cap)\n-                                   .expect(\"capacity overflow\");\n+            .expect(\"capacity overflow\");\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n         let double_cap = self.cap * 2;\n         // `double_cap` guarantees exponential growth."}, {"sha": "369db8e75a398602215d72935f9dc4db2a6f943f", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -35,12 +35,8 @@ fn main() {\n     // that the feature set used by std is the same across all\n     // targets, which means we have to build the alloc_jemalloc crate\n     // for targets like emscripten, even if we don't use it.\n-    if target.contains(\"rumprun\") ||\n-        target.contains(\"bitrig\") ||\n-        target.contains(\"openbsd\") ||\n-        target.contains(\"msvc\") ||\n-        target.contains(\"emscripten\")\n-    {\n+    if target.contains(\"rumprun\") || target.contains(\"bitrig\") || target.contains(\"openbsd\") ||\n+       target.contains(\"msvc\") || target.contains(\"emscripten\") {\n         println!(\"cargo:rustc-cfg=dummy_jemalloc\");\n         return;\n     }\n@@ -64,16 +60,16 @@ fn main() {\n     // only msvc returns None for ar so unwrap is okay\n     let ar = build_helper::cc2ar(compiler.path(), &target).unwrap();\n     let cflags = compiler.args()\n-                         .iter()\n-                         .map(|s| s.to_str().unwrap())\n-                         .collect::<Vec<_>>()\n-                         .join(\" \");\n+        .iter()\n+        .map(|s| s.to_str().unwrap())\n+        .collect::<Vec<_>>()\n+        .join(\" \");\n \n     let mut stack = src_dir.join(\"../jemalloc\")\n-                           .read_dir()\n-                           .unwrap()\n-                           .map(|e| e.unwrap())\n-                           .collect::<Vec<_>>();\n+        .read_dir()\n+        .unwrap()\n+        .map(|e| e.unwrap())\n+        .collect::<Vec<_>>();\n     while let Some(entry) = stack.pop() {\n         let path = entry.path();\n         if entry.file_type().unwrap().is_dir() {\n@@ -155,10 +151,10 @@ fn main() {\n \n     run(&mut cmd);\n     run(Command::new(\"make\")\n-            .current_dir(&build_dir)\n-            .arg(\"build_lib_static\")\n-            .arg(\"-j\")\n-            .arg(env::var(\"NUM_JOBS\").expect(\"NUM_JOBS was not set\")));\n+        .current_dir(&build_dir)\n+        .arg(\"build_lib_static\")\n+        .arg(\"-j\")\n+        .arg(env::var(\"NUM_JOBS\").expect(\"NUM_JOBS was not set\")));\n \n     if target.contains(\"windows\") {\n         println!(\"cargo:rustc-link-lib=static=jemalloc\");"}, {"sha": "b380ba180f40ee865939c28cd6c244f2233d4d21", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -221,11 +221,7 @@ mod imp {\n                                   HEAP_REALLOC_IN_PLACE_ONLY,\n                                   ptr as LPVOID,\n                                   size as SIZE_T) as *mut u8;\n-            if new.is_null() {\n-                old_size\n-            } else {\n-                size\n-            }\n+            if new.is_null() { old_size } else { size }\n         } else {\n             old_size\n         }"}, {"sha": "8f2db950d143c088410454278135a979cf4c3a88", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -335,9 +335,8 @@ mod tests {\n \n         let arena = Wrap(TypedArena::new());\n \n-        let result = arena.alloc_outer(|| {\n-            Outer { inner: arena.alloc_inner(|| Inner { value: 10 }) }\n-        });\n+        let result =\n+            arena.alloc_outer(|| Outer { inner: arena.alloc_inner(|| Inner { value: 10 }) });\n \n         assert_eq!(result.inner.value, 10);\n     }"}, {"sha": "f41f9b2c45a28085086822bc916bdf5edfb8b372", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 85, "deletions": 52, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -16,13 +16,13 @@\n //!\n //! # Examples\n //!\n-//! You can explicitly create a `Vec<T>` with `new()`:\n+//! You can explicitly create a [`Vec<T>`] with [`new()`]:\n //!\n //! ```\n //! let v: Vec<i32> = Vec::new();\n //! ```\n //!\n-//! ...or by using the `vec!` macro:\n+//! ...or by using the [`vec!`] macro:\n //!\n //! ```\n //! let v: Vec<i32> = vec![];\n@@ -32,7 +32,7 @@\n //! let v = vec![0; 10]; // ten zeroes\n //! ```\n //!\n-//! You can `push` values onto the end of a vector (which will grow the vector\n+//! You can [`push`] values onto the end of a vector (which will grow the vector\n //! as needed):\n //!\n //! ```\n@@ -49,13 +49,20 @@\n //! let two = v.pop();\n //! ```\n //!\n-//! Vectors also support indexing (through the `Index` and `IndexMut` traits):\n+//! Vectors also support indexing (through the [`Index`] and [`IndexMut`] traits):\n //!\n //! ```\n //! let mut v = vec![1, 2, 3];\n //! let three = v[2];\n //! v[1] = v[1] + 5;\n //! ```\n+//!\n+//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+//! [`new()`]: ../../std/vec/struct.Vec.html#method.new\n+//! [`push`]: ../../std/vec/struct.Vec.html#method.push\n+//! [`Index`]: ../../std/ops/trait.Index.html\n+//! [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n+//! [`vec!`]: ../../std/macro.vec.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -79,7 +86,7 @@ use core::slice;\n use super::SpecExtend;\n use super::range::RangeArgument;\n \n-/// A contiguous growable array type, written `Vec<T>` but pronounced 'vector.'\n+/// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n ///\n@@ -105,7 +112,7 @@ use super::range::RangeArgument;\n /// assert_eq!(vec, [7, 1, 2, 3]);\n /// ```\n ///\n-/// The `vec!` macro is provided to make initialization more convenient:\n+/// The [`vec!`] macro is provided to make initialization more convenient:\n ///\n /// ```\n /// let mut vec = vec![1, 2, 3];\n@@ -137,15 +144,15 @@ use super::range::RangeArgument;\n ///\n /// # Indexing\n ///\n-/// The Vec type allows to access values by index, because it implements the\n-/// `Index` trait. An example will be more explicit:\n+/// The `Vec` type allows to access values by index, because it implements the\n+/// [`Index`] trait. An example will be more explicit:\n ///\n /// ```\n /// let v = vec!(0, 2, 4, 6);\n /// println!(\"{}\", v[1]); // it will display '2'\n /// ```\n ///\n-/// However be careful: if you try to access an index which isn't in the Vec,\n+/// However be careful: if you try to access an index which isn't in the `Vec`,\n /// your software will panic! You cannot do this:\n ///\n /// ```ignore\n@@ -158,7 +165,7 @@ use super::range::RangeArgument;\n ///\n /// # Slicing\n ///\n-/// A Vec can be mutable. Slices, on the other hand, are read-only objects.\n+/// A `Vec` can be mutable. Slices, on the other hand, are read-only objects.\n /// To get a slice, use \"&\". Example:\n ///\n /// ```\n@@ -175,8 +182,8 @@ use super::range::RangeArgument;\n /// ```\n ///\n /// In Rust, it's more common to pass slices as arguments rather than vectors\n-/// when you just want to provide a read access. The same goes for String and\n-/// &str.\n+/// when you just want to provide a read access. The same goes for [`String`] and\n+/// [`&str`].\n ///\n /// # Capacity and reallocation\n ///\n@@ -191,7 +198,7 @@ use super::range::RangeArgument;\n /// with space for 10 more elements. Pushing 10 or fewer elements onto the\n /// vector will not change its capacity or cause reallocation to occur. However,\n /// if the vector's length is increased to 11, it will have to reallocate, which\n-/// can be slow. For this reason, it is recommended to use `Vec::with_capacity`\n+/// can be slow. For this reason, it is recommended to use [`Vec::with_capacity`]\n /// whenever possible to specify how big the vector is expected to get.\n ///\n /// # Guarantees\n@@ -209,65 +216,83 @@ use super::range::RangeArgument;\n /// The pointer will never be null, so this type is null-pointer-optimized.\n ///\n /// However, the pointer may not actually point to allocated memory. In particular,\n-/// if you construct a Vec with capacity 0 via `Vec::new()`, `vec![]`,\n-/// `Vec::with_capacity(0)`, or by calling `shrink_to_fit()` on an empty Vec, it\n-/// will not allocate memory. Similarly, if you store zero-sized types inside\n-/// a Vec, it will not allocate space for them. *Note that in this case the\n-/// Vec may not report a `capacity()` of 0*. Vec will allocate if and only\n-/// if `mem::size_of::<T>() * capacity() > 0`. In general, Vec's allocation\n+/// if you construct a Vec with capacity 0 via [`Vec::new()`], [`vec![]`][`vec!`],\n+/// [`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit()`]\n+/// on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\n+/// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n+/// the `Vec` may not report a [`capacity()`] of 0*. Vec will allocate if and only\n+/// if [`mem::size_of::<T>()`]` * capacity() > 0`. In general, `Vec`'s allocation\n /// details are subtle enough that it is strongly recommended that you only\n /// free memory allocated by a Vec by creating a new Vec and dropping it.\n ///\n-/// If a Vec *has* allocated memory, then the memory it points to is on the heap\n+/// If a `Vec` *has* allocated memory, then the memory it points to is on the heap\n /// (as defined by the allocator Rust is configured to use by default), and its\n-/// pointer points to `len()` initialized elements in order (what you would see\n-/// if you coerced it to a slice), followed by `capacity() - len()` logically\n-/// uninitialized elements.\n+/// pointer points to [`len()`] initialized elements in order (what you would see\n+/// if you coerced it to a slice), followed by `[capacity()][`capacity()`] -\n+/// [len()][`len()`]` logically uninitialized elements.\n ///\n-/// Vec will never perform a \"small optimization\" where elements are actually\n+/// `Vec` will never perform a \"small optimization\" where elements are actually\n /// stored on the stack for two reasons:\n ///\n /// * It would make it more difficult for unsafe code to correctly manipulate\n-///   a Vec. The contents of a Vec wouldn't have a stable address if it were\n-///   only moved, and it would be more difficult to determine if a Vec had\n+///   a `Vec`. The contents of a `Vec` wouldn't have a stable address if it were\n+///   only moved, and it would be more difficult to determine if a `Vec` had\n ///   actually allocated memory.\n ///\n /// * It would penalize the general case, incurring an additional branch\n ///   on every access.\n ///\n-/// Vec will never automatically shrink itself, even if completely empty. This\n-/// ensures no unnecessary allocations or deallocations occur. Emptying a Vec\n-/// and then filling it back up to the same `len()` should incur no calls to\n-/// the allocator. If you wish to free up unused memory, use `shrink_to_fit`.\n+/// `Vec` will never automatically shrink itself, even if completely empty. This\n+/// ensures no unnecessary allocations or deallocations occur. Emptying a `Vec`\n+/// and then filling it back up to the same [`len()`] should incur no calls to\n+/// the allocator. If you wish to free up unused memory, use\n+/// [`shrink_to_fit`][`shrink_to_fit()`].\n ///\n-/// `push` and `insert` will never (re)allocate if the reported capacity is\n-/// sufficient. `push` and `insert` *will* (re)allocate if `len() == capacity()`.\n-/// That is, the reported capacity is completely accurate, and can be relied on.\n-/// It can even be used to manually free the memory allocated by a Vec if\n-/// desired. Bulk insertion methods *may* reallocate, even when not necessary.\n+/// [`push`] and [`insert`] will never (re)allocate if the reported capacity is\n+/// sufficient. [`push`] and [`insert`] *will* (re)allocate if `[len()][`len()`]\n+/// == [capacity()][`capacity()`]`. That is, the reported capacity is completely\n+/// accurate, and can be relied on. It can even be used to manually free the memory\n+/// allocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\n+/// when not necessary.\n ///\n-/// Vec does not guarantee any particular growth strategy when reallocating\n-/// when full, nor when `reserve` is called. The current strategy is basic\n+/// `Vec` does not guarantee any particular growth strategy when reallocating\n+/// when full, nor when [`reserve`] is called. The current strategy is basic\n /// and it may prove desirable to use a non-constant growth factor. Whatever\n-/// strategy is used will of course guarantee `O(1)` amortized `push`.\n+/// strategy is used will of course guarantee `O(1)` amortized [`push`].\n ///\n-/// `vec![x; n]`, `vec![a, b, c, d]`, and `Vec::with_capacity(n)`, will all\n-/// produce a Vec with exactly the requested capacity. If `len() == capacity()`,\n-/// (as is the case for the `vec!` macro), then a `Vec<T>` can be converted\n-/// to and from a `Box<[T]>` without reallocating or moving the elements.\n+/// `vec![x; n]`, `vec![a, b, c, d]`, and\n+/// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all\n+/// produce a `Vec` with exactly the requested capacity. If `[len()][`len()`] ==\n+/// [capacity()][`capacity()`]`, (as is the case for the [`vec!`] macro), then a\n+/// `Vec<T>` can be converted to and from a [`Box<[T]>`] without reallocating or\n+/// moving the elements.\n ///\n-/// Vec will not specifically overwrite any data that is removed from it,\n+/// `Vec` will not specifically overwrite any data that is removed from it,\n /// but also won't specifically preserve it. Its uninitialized memory is\n /// scratch space that it may use however it wants. It will generally just do\n /// whatever is most efficient or otherwise easy to implement. Do not rely on\n-/// removed data to be erased for security purposes. Even if you drop a Vec, its\n-/// buffer may simply be reused by another Vec. Even if you zero a Vec's memory\n+/// removed data to be erased for security purposes. Even if you drop a `Vec`, its\n+/// buffer may simply be reused by another `Vec`. Even if you zero a `Vec`'s memory\n /// first, that may not actually happen because the optimizer does not consider\n /// this a side-effect that must be preserved.\n ///\n-/// Vec does not currently guarantee the order in which elements are dropped\n+/// `Vec` does not currently guarantee the order in which elements are dropped\n /// (the order has changed in the past, and may change again).\n ///\n+/// [`vec!`]: ../../std/macro.vec.html\n+/// [`Index`]: ../../std/ops/trait.Index.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`&str`]: ../../std/primitive.str.html\n+/// [`Vec::with_capacity`]: ../../std/vec/struct.Vec.html#method.with_capacity\n+/// [`Vec::new()`]: ../../std/vec/struct.Vec.html#method.new\n+/// [`shrink_to_fit()`]: ../../std/vec/struct.Vec.html#method.shrink_to_fit\n+/// [`capacity()`]: ../../std/vec/struct.Vec.html#method.capacity\n+/// [`mem::size_of::<T>()`]: ../../std/mem/fn.size_of.html\n+/// [`len()`]: ../../std/vec/struct.Vec.html#method.len\n+/// [`push`]: ../../std/vec/struct.Vec.html#method.push\n+/// [`insert`]: ../../std/vec/struct.Vec.html#method.insert\n+/// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n+/// [`Box<[T]>`]: ../../std/boxed/struct.Box.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,\n@@ -340,7 +365,7 @@ impl<T> Vec<T> {\n     /// This is highly unsafe, due to the number of invariants that aren't\n     /// checked:\n     ///\n-    /// * `ptr` needs to have been previously allocated via `String`/`Vec<T>`\n+    /// * `ptr` needs to have been previously allocated via [`String`]/`Vec<T>`\n     ///   (at least, it's highly likely to be incorrect if it wasn't).\n     /// * `length` needs to be less than or equal to `capacity`.\n     /// * `capacity` needs to be the capacity that the pointer was allocated with.\n@@ -354,6 +379,8 @@ impl<T> Vec<T> {\n     /// that nothing else uses the pointer after calling this\n     /// function.\n     ///\n+    /// [`String`]: ../../std/string/struct.String.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -470,11 +497,15 @@ impl<T> Vec<T> {\n         self.buf.shrink_to_fit(self.len);\n     }\n \n-    /// Converts the vector into Box<[T]>.\n+    /// Converts the vector into [`Box<[T]>`].\n     ///\n     /// Note that this will drop any excess capacity. Calling this and\n-    /// converting back to a vector with `into_vec()` is equivalent to calling\n-    /// `shrink_to_fit()`.\n+    /// converting back to a vector with [`into_vec()`] is equivalent to calling\n+    /// [`shrink_to_fit()`].\n+    ///\n+    /// [`Box<[T]>`]: ../../std/boxed/struct.Box.html\n+    /// [`into_vec()`]: ../../std/primitive.slice.html#method.into_vec\n+    /// [`shrink_to_fit()`]: #method.shrink_to_fit\n     ///\n     /// # Examples\n     ///\n@@ -673,7 +704,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `index` is greater than the vector's length.\n+    /// Panics if `index` is out of bounds.\n     ///\n     /// # Examples\n     ///\n@@ -933,9 +964,11 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Removes the last element from a vector and returns it, or `None` if it\n+    /// Removes the last element from a vector and returns it, or [`None`] if it\n     /// is empty.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "5a12f5db19ddb6f0a2fe363013d379e688aed645", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -195,13 +195,9 @@ pub trait Iterator {\n         last\n     }\n \n-    /// Consumes the `n` first elements of the iterator, then returns the\n-    /// `next()` one.\n+    /// Returns the `n`th element of the iterator.\n     ///\n-    /// This method will evaluate the iterator `n` times, discarding those elements.\n-    /// After it does so, it will call [`next()`] and return its value.\n-    ///\n-    /// [`next()`]: #tymethod.next\n+    /// Note that all preceding elements will be consumed (i.e. discarded).\n     ///\n     /// Like most indexing operations, the count starts from zero, so `nth(0)`\n     /// returns the first value, `nth(1)` the second, and so on."}, {"sha": "3fa6a97d4cd156204a660c0fadce6741406c6f5a", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -18,36 +18,50 @@\n \n // Reexported core operators\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use marker::{Copy, Send, Sized, Sync};\n+#[doc(no_inline)]\n+pub use marker::{Copy, Send, Sized, Sync};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n+#[doc(no_inline)]\n+pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n // Reexported functions\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use mem::drop;\n+#[doc(no_inline)]\n+pub use mem::drop;\n \n // Reexported types and traits\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use clone::Clone;\n+#[doc(no_inline)]\n+pub use clone::Clone;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n+#[doc(no_inline)]\n+pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use convert::{AsRef, AsMut, Into, From};\n+#[doc(no_inline)]\n+pub use convert::{AsRef, AsMut, Into, From};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use default::Default;\n+#[doc(no_inline)]\n+pub use default::Default;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use iter::{Iterator, Extend, IntoIterator};\n+#[doc(no_inline)]\n+pub use iter::{Iterator, Extend, IntoIterator};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use iter::{DoubleEndedIterator, ExactSizeIterator};\n+#[doc(no_inline)]\n+pub use iter::{DoubleEndedIterator, ExactSizeIterator};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use option::Option::{self, Some, None};\n+#[doc(no_inline)]\n+pub use option::Option::{self, Some, None};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n+#[doc(no_inline)]\n+pub use result::Result::{self, Ok, Err};\n \n // Reexported extension traits for primitive types\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use slice::SliceExt;\n+#[doc(no_inline)]\n+pub use slice::SliceExt;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use str::StrExt;\n+#[doc(no_inline)]\n+pub use str::StrExt;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use char::CharExt;\n+#[doc(no_inline)]\n+pub use char::CharExt;"}, {"sha": "fdb629ca5a578bad8df15fd1b424fde5be5179f8", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -380,7 +380,7 @@ impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n             graph: graph,\n             stack: vec![],\n             visited: visited,\n-            direction: direction\n+            direction: direction,\n         }\n     }\n \n@@ -394,7 +394,7 @@ impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n             graph: graph,\n             stack: vec![start_node],\n             visited: visited,\n-            direction: direction\n+            direction: direction,\n         }\n     }\n "}, {"sha": "2bd76f3ec6de17ca6564f68b5180f72f39a14930", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 101, "deletions": 4, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -1915,6 +1915,45 @@ More details can be found in [RFC 438].\n [RFC 438]: https://github.com/rust-lang/rfcs/pull/438\n \"##,\n \n+E0182: r##\"\n+You bound an associated type in an expression path which is not\n+allowed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0182\n+trait Foo {\n+    type A;\n+    fn bar() -> isize;\n+}\n+\n+impl Foo for isize {\n+    type A = usize;\n+    fn bar() -> isize { 42 }\n+}\n+\n+// error: unexpected binding of associated item in expression path\n+let x: isize = Foo::<A=usize>::bar();\n+```\n+\n+To give a concrete type when using the Universal Function Call Syntax,\n+use \"Type as Trait\". Example:\n+\n+```\n+trait Foo {\n+    type A;\n+    fn bar() -> isize;\n+}\n+\n+impl Foo for isize {\n+    type A = usize;\n+    fn bar() -> isize { 42 }\n+}\n+\n+let x: isize = <isize as Foo>::bar(); // ok!\n+```\n+\"##,\n+\n E0184: r##\"\n Explicitly implementing both Drop and Copy for a type is currently disallowed.\n This feature can make some sense in theory, but the current implementation is\n@@ -2752,6 +2791,30 @@ fn main() {\n ```\n \"##,\n \n+E0230: r##\"\n+The trait has more type parameters specified than appear in its definition.\n+\n+Erroneous example code:\n+\n+```compile_fail,E0230\n+#![feature(on_unimplemented)]\n+#[rustc_on_unimplemented = \"Trait error on `{Self}` with `<{A},{B},{C}>`\"]\n+// error: there is no type parameter C on trait TraitWithThreeParams\n+trait TraitWithThreeParams<A,B>\n+{}\n+```\n+\n+Include the correct number of type parameters and the compilation should\n+proceed:\n+\n+```\n+#![feature(on_unimplemented)]\n+#[rustc_on_unimplemented = \"Trait error on `{Self}` with `<{A},{B},{C}>`\"]\n+trait TraitWithThreeParams<A,B,C> // ok!\n+{}\n+```\n+\"##,\n+\n E0232: r##\"\n The attribute must have a value. Erroneous code example:\n \n@@ -3587,6 +3650,44 @@ fn together_we_will_rule_the_galaxy(son: &A<i32>) {} // Ok!\n ```\n \"##,\n \n+E0399: r##\"\n+You implemented a trait, overriding one or more of its associated types but did\n+not reimplement its default methods.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0399\n+#![feature(associated_type_defaults)]\n+\n+pub trait Foo {\n+    type Assoc = u8;\n+    fn bar(&self) {}\n+}\n+\n+impl Foo for i32 {\n+    // error - the following trait items need to be reimplemented as\n+    //         `Assoc` was overridden: `bar`\n+    type Assoc = i32;\n+}\n+```\n+\n+To fix this, add an implementation for each default method from the trait:\n+\n+```\n+#![feature(associated_type_defaults)]\n+\n+pub trait Foo {\n+    type Assoc = u8;\n+    fn bar(&self) {}\n+}\n+\n+impl Foo for i32 {\n+    type Assoc = i32;\n+    fn bar(&self) {} // ok!\n+}\n+```\n+\"##,\n+\n E0439: r##\"\n The length of the platform-intrinsic function `simd_shuffle`\n wasn't specified. Erroneous code example:\n@@ -4074,7 +4175,6 @@ register_diagnostics! {\n //  E0168,\n //  E0173, // manual implementations of unboxed closure traits are experimental\n //  E0174,\n-    E0182,\n     E0183,\n //  E0187, // can't infer the kind of the closure\n //  E0188, // can not cast an immutable reference to a mutable pointer\n@@ -4098,7 +4198,6 @@ register_diagnostics! {\n     E0226, // only a single explicit lifetime bound is permitted\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required\n     E0228, // explicit lifetime bound required\n-    E0230, // there is no type parameter on trait\n     E0231, // only named substitution parameters are allowed\n //  E0233,\n //  E0234,\n@@ -4120,8 +4219,6 @@ register_diagnostics! {\n //  E0372, // coherence not object safe\n     E0377, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with the same definition\n-    E0399, // trait items need to be implemented because the associated\n-           // type `{}` was overridden\n     E0436, // functional record update requires a struct\n     E0521, // redundant default implementations of trait\n     E0533, // `{}` does not name a unit variant, unit struct or a constant"}, {"sha": "cd36a8eedb482cf385380789583576c5c3468670", "filename": "src/test/run-pass/auxiliary/check_static_recursion_foreign_helper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Ftest%2Frun-pass%2Fauxiliary%2Fcheck_static_recursion_foreign_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f136e9e2995c7682ab0c89a93cc197a246eaea81/src%2Ftest%2Frun-pass%2Fauxiliary%2Fcheck_static_recursion_foreign_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fcheck_static_recursion_foreign_helper.rs?ref=f136e9e2995c7682ab0c89a93cc197a246eaea81", "patch": "@@ -12,8 +12,8 @@\n \n #![feature(libc)]\n \n-#[crate_id = \"check_static_recursion_foreign_helper\"]\n-#[crate_type = \"lib\"]\n+#![crate_name = \"check_static_recursion_foreign_helper\"]\n+#![crate_type = \"lib\"]\n \n extern crate libc;\n "}]}