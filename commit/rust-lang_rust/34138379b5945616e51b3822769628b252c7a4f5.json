{"sha": "34138379b5945616e51b3822769628b252c7a4f5", "node_id": "C_kwDOAAsO6NoAKDM0MTM4Mzc5YjU5NDU2MTZlNTFiMzgyMjc2OTYyOGIyNTJjN2E0ZjU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-01T23:05:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-01T23:05:28Z"}, "message": "Merge #11322\n\n11322: Extract function also extracts comments r=Vannevelj a=Vannevelj\n\nFixes #9011\r\n\r\nThe difficulty I came across is that the original assist works from the concept of a `ast::StmtList`, a node, but that does not allow me to (easily) represent comments, which are tokens. To combat this, I do a whole bunch of roundtrips: from the `ast::StmtList` I retrieve the `NodeOrToken`s it encompasses. \r\n\r\nI then cast all `Node` ones back to a `Stmt` so I can apply indentation to it, after which it is again parsed as a `NodeOrToken`.\r\n\r\nLastly, I add a new `make::` api that accepts `NodeOrToken` rather than `StmtList` so we can write the comment tokens.\n\nCo-authored-by: Jeroen Vannevel <jer_vannevel@outlook.com>", "tree": {"sha": "cf8dfaef80cf25fd7e3cbdb09f7ea3a270979454", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf8dfaef80cf25fd7e3cbdb09f7ea3a270979454"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34138379b5945616e51b3822769628b252c7a4f5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh+by4CRBK7hj4Ov3rIwAAUYsIAIZUcIQvH8gDuEj/o0aOFctM\ne1PaXz+WijC2WCSeS2tcJXaJZGlFoejoz0Gw/D72o2MTbPN1w+IYyFksKzRLVVzm\n89a/lQ52G7bToGJ+pE2Jh4zGenPfqW8xJ+AlydQPf68hauNNaTYrGiUy++iRC1z5\nE9NfRgZVIrrXyjqbW2cRAbSEXhIVXwLqHpO6FR4KbJJUIcv9RaGxRDwv6xUUvyC6\nihZGyw6L/38/TITccbz2svxX2MI1cZBWEvDzi9RCC+VI9mkCPsbGhsau0Ds3OMG8\nD0LRWc0Ebbj2CDdGrRP2nHYKw8i9t3/t//cBLC6rRbmMTzv3tI3Pzcbt/upW0dM=\n=Az18\n-----END PGP SIGNATURE-----\n", "payload": "tree cf8dfaef80cf25fd7e3cbdb09f7ea3a270979454\nparent 498224af18ab68a2c646e6f036946d678bd1752d\nparent 493642ab3a28fc575f699ae381123e6e4f3cec39\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1643756728 +0000\ncommitter GitHub <noreply@github.com> 1643756728 +0000\n\nMerge #11322\n\n11322: Extract function also extracts comments r=Vannevelj a=Vannevelj\n\nFixes #9011\r\n\r\nThe difficulty I came across is that the original assist works from the concept of a `ast::StmtList`, a node, but that does not allow me to (easily) represent comments, which are tokens. To combat this, I do a whole bunch of roundtrips: from the `ast::StmtList` I retrieve the `NodeOrToken`s it encompasses. \r\n\r\nI then cast all `Node` ones back to a `Stmt` so I can apply indentation to it, after which it is again parsed as a `NodeOrToken`.\r\n\r\nLastly, I add a new `make::` api that accepts `NodeOrToken` rather than `StmtList` so we can write the comment tokens.\n\nCo-authored-by: Jeroen Vannevel <jer_vannevel@outlook.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34138379b5945616e51b3822769628b252c7a4f5", "html_url": "https://github.com/rust-lang/rust/commit/34138379b5945616e51b3822769628b252c7a4f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34138379b5945616e51b3822769628b252c7a4f5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "498224af18ab68a2c646e6f036946d678bd1752d", "url": "https://api.github.com/repos/rust-lang/rust/commits/498224af18ab68a2c646e6f036946d678bd1752d", "html_url": "https://github.com/rust-lang/rust/commit/498224af18ab68a2c646e6f036946d678bd1752d"}, {"sha": "493642ab3a28fc575f699ae381123e6e4f3cec39", "url": "https://api.github.com/repos/rust-lang/rust/commits/493642ab3a28fc575f699ae381123e6e4f3cec39", "html_url": "https://github.com/rust-lang/rust/commit/493642ab3a28fc575f699ae381123e6e4f3cec39"}], "stats": {"total": 283, "additions": 254, "deletions": 29}, "files": [{"sha": "877c5b0ceff64b8a4f02924056f3317cda8937d2", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 227, "deletions": 29, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/34138379b5945616e51b3822769628b252c7a4f5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34138379b5945616e51b3822769628b252c7a4f5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=34138379b5945616e51b3822769628b252c7a4f5", "patch": "@@ -34,12 +34,13 @@ use crate::{\n \n // Assist: extract_function\n //\n-// Extracts selected statements into new function.\n+// Extracts selected statements and comments into new function.\n //\n // ```\n // fn main() {\n //     let n = 1;\n //     $0let m = n + 2;\n+//     // calculate\n //     let k = m + n;$0\n //     let g = 3;\n // }\n@@ -54,6 +55,7 @@ use crate::{\n //\n // fn $0fun_name(n: i32) {\n //     let m = n + 2;\n+//     // calculate\n //     let k = m + n;\n // }\n // ```\n@@ -73,6 +75,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         syntax::NodeOrToken::Node(n) => n,\n         syntax::NodeOrToken::Token(t) => t.parent()?,\n     };\n+\n     let body = extraction_target(&node, range)?;\n     let container_info = body.analyze_container(&ctx.sema)?;\n \n@@ -476,11 +479,14 @@ impl FunctionBody {\n     }\n \n     fn from_range(parent: ast::StmtList, selected: TextRange) -> FunctionBody {\n-        let mut text_range = parent\n-            .statements()\n-            .map(|stmt| stmt.syntax().text_range())\n-            .filter(|&stmt| selected.intersect(stmt).filter(|it| !it.is_empty()).is_some())\n+        let full_body = parent.syntax().children_with_tokens();\n+\n+        let mut text_range = full_body\n+            .filter(|it| ast::Stmt::can_cast(it.kind()) || it.kind() == COMMENT)\n+            .map(|element| element.text_range())\n+            .filter(|&range| selected.intersect(range).filter(|it| !it.is_empty()).is_some())\n             .reduce(|acc, stmt| acc.cover(stmt));\n+\n         if let Some(tail_range) = parent\n             .tail_expr()\n             .map(|it| it.syntax().text_range())\n@@ -1420,6 +1426,7 @@ fn make_body(\n     } else {\n         FlowHandler::from_ret_ty(fun, &ret_ty)\n     };\n+\n     let block = match &fun.body {\n         FunctionBody::Expr(expr) => {\n             let expr = rewrite_body_segment(ctx, &fun.params, &handler, expr.syntax());\n@@ -1441,21 +1448,28 @@ fn make_body(\n         FunctionBody::Span { parent, text_range } => {\n             let mut elements: Vec<_> = parent\n                 .syntax()\n-                .children()\n+                .children_with_tokens()\n                 .filter(|it| text_range.contains_range(it.text_range()))\n-                .map(|it| rewrite_body_segment(ctx, &fun.params, &handler, &it))\n+                .map(|it| match &it {\n+                    syntax::NodeOrToken::Node(n) => syntax::NodeOrToken::Node(\n+                        rewrite_body_segment(ctx, &fun.params, &handler, &n),\n+                    ),\n+                    _ => it,\n+                })\n                 .collect();\n \n-            let mut tail_expr = match elements.pop() {\n-                Some(node) => ast::Expr::cast(node.clone()).or_else(|| {\n-                    elements.push(node);\n-                    None\n-                }),\n-                None => None,\n+            let mut tail_expr = match &elements.last() {\n+                Some(syntax::NodeOrToken::Node(node)) if ast::Expr::can_cast(node.kind()) => {\n+                    ast::Expr::cast(node.clone())\n+                }\n+                _ => None,\n             };\n \n-            if tail_expr.is_none() {\n-                match fun.outliving_locals.as_slice() {\n+            match tail_expr {\n+                Some(_) => {\n+                    elements.pop();\n+                }\n+                None => match fun.outliving_locals.as_slice() {\n                     [] => {}\n                     [var] => {\n                         tail_expr = Some(path_expr_from_local(ctx, var.local));\n@@ -1465,22 +1479,27 @@ fn make_body(\n                         let expr = make::expr_tuple(exprs);\n                         tail_expr = Some(expr);\n                     }\n-                }\n-            }\n-\n-            let elements = elements.into_iter().filter_map(|node| match ast::Stmt::cast(node) {\n-                Some(stmt) => Some(stmt),\n-                None => {\n-                    stdx::never!(\"block contains non-statement\");\n-                    None\n-                }\n-            });\n+                },\n+            };\n \n             let body_indent = IndentLevel(1);\n-            let elements = elements.map(|stmt| stmt.dedent(old_indent).indent(body_indent));\n+            let elements = elements\n+                .into_iter()\n+                .map(|node_or_token| match &node_or_token {\n+                    syntax::NodeOrToken::Node(node) => match ast::Stmt::cast(node.clone()) {\n+                        Some(stmt) => {\n+                            let indented = stmt.dedent(old_indent).indent(body_indent);\n+                            let ast_node = indented.syntax().clone_subtree();\n+                            syntax::NodeOrToken::Node(ast_node)\n+                        }\n+                        _ => node_or_token,\n+                    },\n+                    _ => node_or_token,\n+                })\n+                .collect::<Vec<SyntaxElement>>();\n             let tail_expr = tail_expr.map(|expr| expr.dedent(old_indent).indent(body_indent));\n \n-            make::block_expr(elements, tail_expr)\n+            make::hacky_block_expr_with_comments(elements, tail_expr)\n         }\n     };\n \n@@ -4092,14 +4111,35 @@ fn foo() {\n \"#,\n             r#\"\n fn foo() {\n-    /**/\n     fun_name();\n-    /**/\n }\n \n fn $0fun_name() {\n+    /**/\n     foo();\n     foo();\n+    /**/\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_does_not_tear_body_apart() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    $0foo();\n+}$0\n+\"#,\n+            r#\"\n+fn foo() {\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    foo();\n }\n \"#,\n         );\n@@ -4394,6 +4434,164 @@ pub fn testfn(arg: &mut Foo) {\n fn $0fun_name(arg: &mut Foo) {\n     arg.field = 8;\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_function_copies_comment_at_start() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    $0// comment here!\n+    let x = 0;$0\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    // comment here!\n+    let x = 0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_function_copies_comment_in_between() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func() {\n+    let i = 0;$0\n+    let a = 0;\n+    // comment here!\n+    let x = 0;$0\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    let a = 0;\n+    // comment here!\n+    let x = 0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_function_copies_comment_at_end() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    $0let x = 0;\n+    // comment here!$0\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    let x = 0;\n+    // comment here!\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_function_copies_comment_indented() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    $0let x = 0;\n+    while(true) {\n+        // comment here!\n+    }$0\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    let x = 0;\n+    while(true) {\n+        // comment here!\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    // FIXME: we do want to preserve whitespace\n+    #[test]\n+    fn extract_function_does_not_preserve_whitespace() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    $0let a = 0;\n+\n+    let x = 0;$0\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    let a = 0;\n+    let x = 0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_function_long_form_comment() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    $0/* a comment */\n+    let x = 0;$0\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    /* a comment */\n+    let x = 0;\n+}\n \"#,\n         );\n     }"}, {"sha": "0ad4b3bc345c1e1454754e09b26c854a76ca7f90", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34138379b5945616e51b3822769628b252c7a4f5/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34138379b5945616e51b3822769628b252c7a4f5/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=34138379b5945616e51b3822769628b252c7a4f5", "patch": "@@ -507,6 +507,7 @@ fn doctest_extract_function() {\n fn main() {\n     let n = 1;\n     $0let m = n + 2;\n+    // calculate\n     let k = m + n;$0\n     let g = 3;\n }\n@@ -520,6 +521,7 @@ fn main() {\n \n fn $0fun_name(n: i32) {\n     let m = n + 2;\n+    // calculate\n     let k = m + n;\n }\n \"#####,"}, {"sha": "8a1bcebbf678467f8ad2283e31791afcfcb7a479", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/34138379b5945616e51b3822769628b252c7a4f5/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34138379b5945616e51b3822769628b252c7a4f5/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=34138379b5945616e51b3822769628b252c7a4f5", "patch": "@@ -329,6 +329,31 @@ pub fn block_expr(\n     ast_from_text(&format!(\"fn f() {}\", buf))\n }\n \n+/// Ideally this function wouldn't exist since it involves manual indenting.\n+/// It differs from `make::block_expr` by also supporting comments.\n+///\n+/// FIXME: replace usages of this with the mutable syntax tree API\n+pub fn hacky_block_expr_with_comments(\n+    elements: impl IntoIterator<Item = crate::SyntaxElement>,\n+    tail_expr: Option<ast::Expr>,\n+) -> ast::BlockExpr {\n+    let mut buf = \"{\\n\".to_string();\n+    for node_or_token in elements.into_iter() {\n+        match node_or_token {\n+            rowan::NodeOrToken::Node(n) => format_to!(buf, \"    {}\\n\", n),\n+            rowan::NodeOrToken::Token(t) if t.kind() == SyntaxKind::COMMENT => {\n+                format_to!(buf, \"    {}\\n\", t)\n+            }\n+            _ => (),\n+        }\n+    }\n+    if let Some(tail_expr) = tail_expr {\n+        format_to!(buf, \"    {}\\n\", tail_expr);\n+    }\n+    buf += \"}\";\n+    ast_from_text(&format!(\"fn f() {}\", buf))\n+}\n+\n pub fn expr_unit() -> ast::Expr {\n     expr_from_text(\"()\")\n }"}]}