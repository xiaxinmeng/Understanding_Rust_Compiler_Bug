{"sha": "81053b912fab51978f4806cddfc37eb9a9a5afc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMDUzYjkxMmZhYjUxOTc4ZjQ4MDZjZGRmYzM3ZWI5YTlhNWFmYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-11T11:25:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-11T11:25:31Z"}, "message": "Auto merge of #86995 - sexxi-goose:rewrite, r=nikomatsakis\n\n2229: Rewrite/Refactor Closure Capture Analaysis\n\nWhile handling all the differnet edge cases the code for the captur analysis got pretty compicated. Looking at the overall picture of the edge cases the rules can still be layed out simply.\n\nAlogithm: https://hackmd.io/D3I_gwvuT-SPnJ22tgJumw\n\nr? `@nikomatsakis`\n\nCloses https://github.com/rust-lang/project-rfc-2229/issues/52\nImplementation part of https://github.com/rust-lang/project-rfc-2229/issues/53", "tree": {"sha": "16171bcfeca1b8279116bc2381c2b4104ce02ae3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16171bcfeca1b8279116bc2381c2b4104ce02ae3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81053b912fab51978f4806cddfc37eb9a9a5afc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81053b912fab51978f4806cddfc37eb9a9a5afc6", "html_url": "https://github.com/rust-lang/rust/commit/81053b912fab51978f4806cddfc37eb9a9a5afc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81053b912fab51978f4806cddfc37eb9a9a5afc6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4581c4ef6ff388dd624bdceb484fb03c33d7bae4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4581c4ef6ff388dd624bdceb484fb03c33d7bae4", "html_url": "https://github.com/rust-lang/rust/commit/4581c4ef6ff388dd624bdceb484fb03c33d7bae4"}, {"sha": "5055569008fda3ea8424b2b01824d44fca42d830", "url": "https://api.github.com/repos/rust-lang/rust/commits/5055569008fda3ea8424b2b01824d44fca42d830", "html_url": "https://github.com/rust-lang/rust/commit/5055569008fda3ea8424b2b01824d44fca42d830"}], "stats": {"total": 526, "additions": 302, "deletions": 224}, "files": [{"sha": "9a39a32f6d5d312d52dc2ad9f4a746705b748b66", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 160, "deletions": 168, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/81053b912fab51978f4806cddfc37eb9a9a5afc6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81053b912fab51978f4806cddfc37eb9a9a5afc6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=81053b912fab51978f4806cddfc37eb9a9a5afc6", "patch": "@@ -165,9 +165,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             fcx: self,\n             closure_def_id,\n             closure_span: span,\n-            capture_clause,\n-            current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n-            current_origin: None,\n             capture_information: Default::default(),\n             fake_reads: Default::default(),\n         };\n@@ -184,9 +181,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"For closure={:?}, capture_information={:#?}\",\n             closure_def_id, delegate.capture_information\n         );\n+\n         self.log_capture_analysis_first_pass(closure_def_id, &delegate.capture_information, span);\n \n-        self.compute_min_captures(closure_def_id, capture_clause, delegate.capture_information);\n+        let (capture_information, closure_kind, origin) = self\n+            .process_collected_capture_information(capture_clause, delegate.capture_information);\n+\n+        self.compute_min_captures(closure_def_id, capture_information);\n \n         let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n \n@@ -221,22 +222,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             // This will update the min captures based on this new fake information.\n-            self.compute_min_captures(closure_def_id, capture_clause, capture_information);\n+            self.compute_min_captures(closure_def_id, capture_information);\n         }\n \n         let before_feature_tys = self.final_upvar_tys(closure_def_id);\n \n         if let Some(closure_substs) = infer_kind {\n             // Unify the (as yet unbound) type variable in the closure\n             // substs with the kind we inferred.\n-            let inferred_kind = delegate.current_closure_kind;\n             let closure_kind_ty = closure_substs.as_closure().kind_ty();\n-            self.demand_eqtype(span, inferred_kind.to_ty(self.tcx), closure_kind_ty);\n+            self.demand_eqtype(span, closure_kind.to_ty(self.tcx), closure_kind_ty);\n \n             // If we have an origin, store it.\n-            if let Some(origin) = delegate.current_origin.clone() {\n+            if let Some(origin) = origin {\n                 let origin = if enable_precise_capture(self.tcx, span) {\n-                    (origin.0, restrict_capture_precision(capture_clause, origin.1))\n+                    (origin.0, origin.1)\n                 } else {\n                     (origin.0, Place { projections: vec![], ..origin.1 })\n                 };\n@@ -323,6 +323,85 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n+    /// Adjusts the closure capture information to ensure that the operations aren't unsafe,\n+    /// and that the path can be captured with required capture kind (depending on use in closure,\n+    /// move closure etc.)\n+    ///\n+    /// Returns the set of of adjusted information along with the inferred closure kind and span\n+    /// associated with the closure kind inference.\n+    ///\n+    /// Note that we *always* infer a minimal kind, even if\n+    /// we don't always *use* that in the final result (i.e., sometimes\n+    /// we've taken the closure kind from the expectations instead, and\n+    /// for generators we don't even implement the closure traits\n+    /// really).\n+    ///\n+    /// If we inferred that the closure needs to be FnMut/FnOnce, last element of the returned tuple\n+    /// contains a `Some()` with the `Place` that caused us to do so.\n+    fn process_collected_capture_information(\n+        &self,\n+        capture_clause: hir::CaptureBy,\n+        capture_information: InferredCaptureInformation<'tcx>,\n+    ) -> (InferredCaptureInformation<'tcx>, ty::ClosureKind, Option<(Span, Place<'tcx>)>) {\n+        let mut processed: InferredCaptureInformation<'tcx> = Default::default();\n+\n+        let mut closure_kind = ty::ClosureKind::LATTICE_BOTTOM;\n+        let mut origin: Option<(Span, Place<'tcx>)> = None;\n+\n+        for (place, mut capture_info) in capture_information {\n+            // Apply rules for safety before inferring closure kind\n+            let place = restrict_capture_precision(place);\n+\n+            let place = truncate_capture_for_optimization(&place);\n+\n+            let usage_span = if let Some(usage_expr) = capture_info.path_expr_id {\n+                self.tcx.hir().span(usage_expr)\n+            } else {\n+                unreachable!()\n+            };\n+\n+            let updated = match capture_info.capture_kind {\n+                ty::UpvarCapture::ByValue(..) => match closure_kind {\n+                    ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n+                        (ty::ClosureKind::FnOnce, Some((usage_span, place.clone())))\n+                    }\n+                    // If closure is already FnOnce, don't update\n+                    ty::ClosureKind::FnOnce => (closure_kind, origin),\n+                },\n+\n+                ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                    kind: ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n+                    ..\n+                }) => {\n+                    match closure_kind {\n+                        ty::ClosureKind::Fn => {\n+                            (ty::ClosureKind::FnMut, Some((usage_span, place.clone())))\n+                        }\n+                        // Don't update the origin\n+                        ty::ClosureKind::FnMut | ty::ClosureKind::FnOnce => (closure_kind, origin),\n+                    }\n+                }\n+\n+                _ => (closure_kind, origin),\n+            };\n+\n+            closure_kind = updated.0;\n+            origin = updated.1;\n+\n+            let (place, capture_kind) = match capture_clause {\n+                hir::CaptureBy::Value => adjust_for_move_closure(place, capture_info.capture_kind),\n+                hir::CaptureBy::Ref => {\n+                    adjust_for_non_move_closure(place, capture_info.capture_kind)\n+                }\n+            };\n+\n+            capture_info.capture_kind = capture_kind;\n+            processed.insert(place, capture_info);\n+        }\n+\n+        (processed, closure_kind, origin)\n+    }\n+\n     /// Analyzes the information collected by `InferBorrowKind` to compute the min number of\n     /// Places (and corresponding capture kind) that we need to keep track of to support all\n     /// the required captured paths.\n@@ -395,7 +474,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn compute_min_captures(\n         &self,\n         closure_def_id: DefId,\n-        capture_clause: hir::CaptureBy,\n         capture_information: InferredCaptureInformation<'tcx>,\n     ) {\n         if capture_information.is_empty() {\n@@ -413,8 +491,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            let place = restrict_capture_precision(capture_clause, place);\n-\n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n                     let mutability = self.determine_capture_mutability(&typeck_results, &place);\n@@ -1417,20 +1493,6 @@ struct InferBorrowKind<'a, 'tcx> {\n \n     closure_span: Span,\n \n-    capture_clause: hir::CaptureBy,\n-\n-    // The kind that we have inferred that the current closure\n-    // requires. Note that we *always* infer a minimal kind, even if\n-    // we don't always *use* that in the final result (i.e., sometimes\n-    // we've taken the closure kind from the expectations instead, and\n-    // for generators we don't even implement the closure traits\n-    // really).\n-    current_closure_kind: ty::ClosureKind,\n-\n-    // If we modified `current_closure_kind`, this field contains a `Some()` with the\n-    // variable access that caused us to do so.\n-    current_origin: Option<(Span, Place<'tcx>)>,\n-\n     /// For each Place that is captured by the closure, we track the minimal kind of\n     /// access we need (ref, ref mut, move, etc) and the expression that resulted in such access.\n     ///\n@@ -1473,27 +1535,13 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, mode\n         );\n \n-        match (self.capture_clause, mode) {\n-            // In non-move closures, we only care about moves\n-            (hir::CaptureBy::Ref, euv::Copy) => return,\n-\n-            // We want to capture Copy types that read through a ref via a reborrow\n-            (hir::CaptureBy::Value, euv::Copy)\n-                if place_with_id.place.deref_tys().any(ty::TyS::is_ref) =>\n-            {\n-                return;\n-            }\n-\n-            (hir::CaptureBy::Ref, euv::Move) | (hir::CaptureBy::Value, euv::Move | euv::Copy) => {}\n+        // Copy type being used as ByValue are equivalent to ImmBorrow and don't require any\n+        // escalation.\n+        match mode {\n+            euv::ConsumeMode::Copy => return,\n+            euv::ConsumeMode::Move => {}\n         };\n \n-        let place = truncate_capture_for_move(place_with_id.place.clone());\n-        let place_with_id = PlaceWithHirId { place: place.clone(), hir_id: place_with_id.hir_id };\n-\n-        if !self.capture_information.contains_key(&place) {\n-            self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n-        }\n-\n         let tcx = self.fcx.tcx;\n         let upvar_id = if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             upvar_id\n@@ -1505,16 +1553,6 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n         let usage_span = tcx.hir().span(diag_expr_id);\n \n-        if matches!(mode, euv::Move) {\n-            // To move out of an upvar, this must be a FnOnce closure\n-            self.adjust_closure_kind(\n-                upvar_id.closure_expr_id,\n-                ty::ClosureKind::FnOnce,\n-                usage_span,\n-                place.clone(),\n-            );\n-        }\n-\n         let capture_info = ty::CaptureInfo {\n             capture_kind_expr_id: Some(diag_expr_id),\n             path_expr_id: Some(diag_expr_id),\n@@ -1592,22 +1630,11 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             ty::ImmBorrow => false,\n         });\n \n-        let tcx = self.fcx.tcx;\n-\n         // if this is an implicit deref of an\n         // upvar, then we need to modify the\n         // borrow_kind of the upvar to make sure it\n         // is inferred to mutable if necessary\n         self.adjust_upvar_borrow_kind(place_with_id, diag_expr_id, borrow_kind);\n-\n-        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n-            self.adjust_closure_kind(\n-                upvar_id.closure_expr_id,\n-                ty::ClosureKind::FnMut,\n-                tcx.hir().span(diag_expr_id),\n-                place_with_id.place.clone(),\n-            );\n-        }\n     }\n \n     /// We infer the borrow_kind with which to borrow upvars in a stack closure.\n@@ -1646,48 +1673,6 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         };\n     }\n \n-    fn adjust_closure_kind(\n-        &mut self,\n-        closure_id: LocalDefId,\n-        new_kind: ty::ClosureKind,\n-        upvar_span: Span,\n-        place: Place<'tcx>,\n-    ) {\n-        debug!(\n-            \"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, place={:?})\",\n-            closure_id, new_kind, upvar_span, place\n-        );\n-\n-        // Is this the closure whose kind is currently being inferred?\n-        if closure_id.to_def_id() != self.closure_def_id {\n-            debug!(\"adjust_closure_kind: not current closure\");\n-            return;\n-        }\n-\n-        // closures start out as `Fn`.\n-        let existing_kind = self.current_closure_kind;\n-\n-        debug!(\n-            \"adjust_closure_kind: closure_id={:?}, existing_kind={:?}, new_kind={:?}\",\n-            closure_id, existing_kind, new_kind\n-        );\n-\n-        match (existing_kind, new_kind) {\n-            (ty::ClosureKind::Fn, ty::ClosureKind::Fn)\n-            | (ty::ClosureKind::FnMut, ty::ClosureKind::Fn | ty::ClosureKind::FnMut)\n-            | (ty::ClosureKind::FnOnce, _) => {\n-                // no change needed\n-            }\n-\n-            (ty::ClosureKind::Fn, ty::ClosureKind::FnMut | ty::ClosureKind::FnOnce)\n-            | (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-                // new kind is stronger than the old kind\n-                self.current_closure_kind = new_kind;\n-                self.current_origin = Some((upvar_span, place));\n-            }\n-        }\n-    }\n-\n     fn init_capture_info_for_place(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,\n@@ -1696,12 +1681,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             assert_eq!(self.closure_def_id.expect_local(), upvar_id.closure_expr_id);\n \n-            let capture_kind = self.fcx.init_capture_kind_for_place(\n-                &place_with_id.place,\n-                self.capture_clause,\n-                upvar_id,\n-                self.closure_span,\n-            );\n+            // Initialize to ImmBorrow\n+            // We will escalate the CaptureKind based on any uses we see or in `process_collected_capture_information`.\n+            let origin = UpvarRegion(upvar_id, self.closure_span);\n+            let upvar_region = self.fcx.next_region_var(origin);\n+            let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n+            let capture_kind = ty::UpvarCapture::ByRef(upvar_borrow);\n \n             let expr_id = Some(diag_expr_id);\n             let capture_info = ty::CaptureInfo {\n@@ -1724,7 +1709,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(_) = place.base {\n             // We need to restrict Fake Read precision to avoid fake reading unsafe code,\n             // such as deref of a raw pointer.\n-            let place = restrict_capture_precision(self.capture_clause, place);\n+            let place = restrict_capture_precision(place);\n             let place =\n                 restrict_repr_packed_field_ref_capture(self.fcx.tcx, self.fcx.param_env, &place);\n             self.fake_reads.push((place, cause, diag_expr_id));\n@@ -1742,11 +1727,6 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, mode\n         );\n \n-        let place_with_id = PlaceWithHirId {\n-            place: truncate_capture_for_optimization(&place_with_id.place),\n-            ..*place_with_id\n-        };\n-\n         if !self.capture_information.contains_key(&place_with_id.place) {\n             self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n         }\n@@ -1766,16 +1746,14 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         );\n \n         // We only want repr packed restriction to be applied to reading references into a packed\n-        // struct, and not when the data is being moved. There for we call this method here instead\n+        // struct, and not when the data is being moved. Therefore we call this method here instead\n         // of in `restrict_capture_precision`.\n         let place = restrict_repr_packed_field_ref_capture(\n             self.fcx.tcx,\n             self.fcx.param_env,\n             &place_with_id.place,\n         );\n \n-        let place = truncate_capture_for_optimization(&place);\n-\n         let place_with_id = PlaceWithHirId { place, ..*place_with_id };\n \n         if !self.capture_information.contains_key(&place_with_id.place) {\n@@ -1800,46 +1778,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     }\n }\n \n-/// Deref of a box isn't captured in move clousres. This is motivated by:\n-///   1. We only want to capture data that is on the stack\n-///   2. One motivation for the user to use a box might be to reduce the amount of data that gets\n-///      moved (if size of pointer < size of data). We want to make sure that this optimization that\n-///      the user made is respected.\n-fn restrict_precision_for_box<'tcx>(\n-    capture_clause: hir::CaptureBy,\n-    mut place: Place<'tcx>,\n-) -> Place<'tcx> {\n-    match capture_clause {\n-        hir::CaptureBy::Ref => {}\n-        hir::CaptureBy::Value => {\n-            if ty::TyS::is_box(place.base_ty) {\n-                place.projections.truncate(0);\n-            } else {\n-                // Either the box is the last access or there is a deref applied on the box\n-                // In either case we want to stop at the box.\n-                let pos = place.projections.iter().position(|proj| ty::TyS::is_box(proj.ty));\n-                match pos {\n-                    None => {}\n-                    Some(idx) => {\n-                        place.projections.truncate(idx + 1);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    place\n-}\n-\n /// Truncate projections so that following rules are obeyed by the captured `place`:\n /// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n ///   them completely.\n /// - No Index projections are captured, since arrays are captured completely.\n-/// - Deref of a box isn't captured in move clousres.\n-fn restrict_capture_precision<'tcx>(\n-    capture_clause: hir::CaptureBy,\n-    mut place: Place<'tcx>,\n-) -> Place<'tcx> {\n+fn restrict_capture_precision<'tcx>(mut place: Place<'tcx>) -> Place<'tcx> {\n     if place.projections.is_empty() {\n         // Nothing to do here\n         return place;\n@@ -1874,19 +1817,68 @@ fn restrict_capture_precision<'tcx>(\n \n     place.projections.truncate(length);\n \n-    // Dont't capture projections on top of a box in move closures.\n-    restrict_precision_for_box(capture_clause, place)\n+    place\n }\n \n-/// Truncates a place so that the resultant capture doesn't move data out of a reference\n-fn truncate_capture_for_move(mut place: Place<'tcx>) -> Place<'tcx> {\n-    if let Some(i) = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref) {\n-        // We only drop Derefs in case of move closures\n-        // There might be an index projection or raw ptr ahead, so we don't stop here.\n-        place.projections.truncate(i);\n+/// Take ownership if data being accessed is owned by the variable used to access it\n+/// (or if closure attempts to move data that it doesn\u2019t own).\n+/// Note: When taking ownership, only capture data found on the stack.\n+fn adjust_for_move_closure<'tcx>(\n+    mut place: Place<'tcx>,\n+    kind: ty::UpvarCapture<'tcx>,\n+) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    let contains_deref_of_ref = place.deref_tys().any(|ty| ty.is_ref());\n+    let first_deref = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n+\n+    match kind {\n+        ty::UpvarCapture::ByRef(..) if contains_deref_of_ref => (place, kind),\n+\n+        // If there's any Deref and the data needs to be moved into the closure body,\n+        // or it's a Deref of a Box, truncate the path to the first deref\n+        _ if first_deref.is_some() => {\n+            let place = match first_deref {\n+                Some(idx) => {\n+                    place.projections.truncate(idx);\n+                    place\n+                }\n+                None => place,\n+            };\n+\n+            // AMAN: I think we don't need the span inside the ByValue anymore\n+            //       we have more detailed span in CaptureInfo\n+            (place, ty::UpvarCapture::ByValue(None))\n+        }\n+\n+        _ => (place, ty::UpvarCapture::ByValue(None)),\n     }\n+}\n \n-    place\n+/// Adjust closure capture just that if taking ownership of data, only move data\n+/// from enclosing stack frame.\n+fn adjust_for_non_move_closure<'tcx>(\n+    mut place: Place<'tcx>,\n+    kind: ty::UpvarCapture<'tcx>,\n+) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    let contains_deref =\n+        place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n+\n+    match kind {\n+        ty::UpvarCapture::ByValue(..) if contains_deref.is_some() => {\n+            let place = match contains_deref {\n+                Some(idx) => {\n+                    place.projections.truncate(idx);\n+                    place\n+                }\n+                // Because of the if guard on the match on `kind`, we should never get here.\n+                None => unreachable!(),\n+            };\n+\n+            (place, kind)\n+        }\n+\n+        ty::UpvarCapture::ByValue(..) => (place, kind),\n+        ty::UpvarCapture::ByRef(..) => (place, kind),\n+    }\n }\n \n fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {"}, {"sha": "d8d3bbee200db67df8cb258fec03b2097f227601", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs?ref=81053b912fab51978f4806cddfc37eb9a9a5afc6", "patch": "@@ -22,8 +22,7 @@ fn big_box() {\n     //~^ First Pass analysis includes:\n     //~| Min Capture analysis includes:\n         let p = t.0.0;\n-        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n-        //~| NOTE: Capturing t[(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n         //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n         println!(\"{} {:?}\", t.1, p);\n         //~^ NOTE: Capturing t[(1, 0)] -> ImmBorrow"}, {"sha": "097462253aae73f0d3d37ac1f03a6b86c5cc5b2b", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr?ref=81053b912fab51978f4806cddfc37eb9a9a5afc6", "patch": "@@ -19,18 +19,13 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:24:17\n-   |\n-LL |         let p = t.0.0;\n-   |                 ^^^^^\n-note: Capturing t[(0, 0)] -> ByValue\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n   --> $DIR/by_value.rs:24:17\n    |\n LL |         let p = t.0.0;\n    |                 ^^^^^\n note: Capturing t[(1, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:28:29\n+  --> $DIR/by_value.rs:27:29\n    |\n LL |         println!(\"{} {:?}\", t.1, p);\n    |                             ^^^\n@@ -53,7 +48,7 @@ note: Min Capture t[(0, 0)] -> ByValue\n LL |         let p = t.0.0;\n    |                 ^^^^^\n note: Min Capture t[(1, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:28:29\n+  --> $DIR/by_value.rs:27:29\n    |\n LL |         println!(\"{} {:?}\", t.1, p);\n    |                             ^^^"}, {"sha": "3b284eadbd0e3a6ef1073d66481a45e9850b8bf6", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.rs", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs?ref=81053b912fab51978f4806cddfc37eb9a9a5afc6", "patch": "@@ -16,7 +16,7 @@ fn simple_move_closure() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         t.0.0 = \"new S\".into();\n-        //~^ NOTE: Capturing t[(0, 0),(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),(0, 0)] -> MutBorrow\n         //~| NOTE: Min Capture t[(0, 0),(0, 0)] -> ByValue\n     };\n     c();\n@@ -78,7 +78,7 @@ fn struct_contains_ref_to_another_struct_2() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         let _t = t.0.0;\n-        //~^ NOTE: Capturing t[(0, 0),Deref] -> ImmBorrow\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n         //~| NOTE: Min Capture t[(0, 0),Deref] -> ImmBorrow\n     };\n \n@@ -100,8 +100,7 @@ fn struct_contains_ref_to_another_struct_3() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         let _t = t.0.0;\n-        //~^ NOTE: Capturing t[(0, 0),Deref] -> ImmBorrow\n-        //~| NOTE: Capturing t[(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n         //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n     };\n \n@@ -122,8 +121,7 @@ fn truncate_box_derefs() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         let _t = b.0;\n-        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ByValue\n-        //~| NOTE: Capturing b[] -> ByValue\n+        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ImmBorrow\n         //~| NOTE: Min Capture b[] -> ByValue\n     };\n \n@@ -139,7 +137,7 @@ fn truncate_box_derefs() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         println!(\"{}\", b.0);\n-        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ImmBorrow\n         //~| NOTE: Min Capture b[] -> ByValue\n     };\n \n@@ -156,16 +154,54 @@ fn truncate_box_derefs() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         println!(\"{}\", t.1.0);\n-        //~^ NOTE: Capturing t[(1, 0),Deref,(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(1, 0),Deref,(0, 0)] -> ImmBorrow\n         //~| NOTE: Min Capture t[(1, 0)] -> ByValue\n     };\n }\n \n+struct Foo { x: i32 }\n+\n+// Ensure that even in move closures, if the data is not owned by the root variable\n+// then we don't truncate the derefs or a ByValue capture, rather do a reborrow\n+fn box_mut_1() {\n+    let mut foo = Foo { x: 0 } ;\n+\n+    let p_foo = &mut foo;\n+    let box_p_foo = Box::new(p_foo);\n+\n+    let c = #[rustc_capture_analysis] move || box_p_foo.x += 10;\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    //~| First Pass analysis includes:\n+    //~| NOTE: Capturing box_p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+    //~| Min Capture analysis includes:\n+    //~| NOTE: Min Capture box_p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+}\n+\n+// Ensure that even in move closures, if the data is not owned by the root variable\n+// then we don't truncate the derefs or a ByValue capture, rather do a reborrow\n+fn box_mut_2() {\n+    let foo = Foo { x: 0 } ;\n+\n+    let mut box_foo = Box::new(foo);\n+    let p_foo = &mut box_foo;\n+\n+    let c = #[rustc_capture_analysis] move || p_foo.x += 10;\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    //~| First Pass analysis includes:\n+    //~| NOTE: Capturing p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+    //~| Min Capture analysis includes:\n+    //~| NOTE: Min Capture p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+}\n+\n fn main() {\n     simple_move_closure();\n     simple_ref();\n     struct_contains_ref_to_another_struct_1();\n     struct_contains_ref_to_another_struct_2();\n     struct_contains_ref_to_another_struct_3();\n     truncate_box_derefs();\n+    box_mut_2();\n+    box_mut_1();\n }"}, {"sha": "c8e2708feee314a3ef7f765ee1174c6604daaea6", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.stderr", "status": "modified", "additions": 92, "deletions": 36, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr?ref=81053b912fab51978f4806cddfc37eb9a9a5afc6", "patch": "@@ -44,7 +44,7 @@ LL |     let mut c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/move_closure.rs:118:13\n+  --> $DIR/move_closure.rs:117:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -53,7 +53,7 @@ LL |     let c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/move_closure.rs:135:13\n+  --> $DIR/move_closure.rs:133:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -62,14 +62,32 @@ LL |     let c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/move_closure.rs:152:13\n+  --> $DIR/move_closure.rs:150:13\n    |\n LL |     let c = #[rustc_capture_analysis]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:172:13\n+   |\n+LL |     let c = #[rustc_capture_analysis] move || box_p_foo.x += 10;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:189:13\n+   |\n+LL |     let c = #[rustc_capture_analysis] move || p_foo.x += 10;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n error: First Pass analysis includes:\n   --> $DIR/move_closure.rs:15:5\n    |\n@@ -82,7 +100,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),(0, 0)] -> ByValue\n+note: Capturing t[(0, 0),(0, 0)] -> MutBorrow\n   --> $DIR/move_closure.rs:18:9\n    |\n LL |         t.0.0 = \"new S\".into();\n@@ -190,7 +208,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref] -> ImmBorrow\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n   --> $DIR/move_closure.rs:80:18\n    |\n LL |         let _t = t.0.0;\n@@ -221,17 +239,12 @@ LL | /     move || {\n LL | |\n LL | |\n LL | |         let _t = t.0.0;\n-...  |\n+LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref] -> ImmBorrow\n-  --> $DIR/move_closure.rs:102:18\n-   |\n-LL |         let _t = t.0.0;\n-   |                  ^^^^^\n-note: Capturing t[(0, 0)] -> ByValue\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n   --> $DIR/move_closure.rs:102:18\n    |\n LL |         let _t = t.0.0;\n@@ -244,7 +257,7 @@ LL | /     move || {\n LL | |\n LL | |\n LL | |         let _t = t.0.0;\n-...  |\n+LL | |\n LL | |\n LL | |     };\n    | |_____^\n@@ -256,48 +269,43 @@ LL |         let _t = t.0.0;\n    |                  ^^^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/move_closure.rs:121:5\n+  --> $DIR/move_closure.rs:120:5\n    |\n LL | /     move || {\n LL | |\n LL | |\n LL | |         let _t = b.0;\n-...  |\n+LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing b[Deref,(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:124:18\n-   |\n-LL |         let _t = b.0;\n-   |                  ^^^\n-note: Capturing b[] -> ByValue\n-  --> $DIR/move_closure.rs:124:18\n+note: Capturing b[Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:123:18\n    |\n LL |         let _t = b.0;\n    |                  ^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:121:5\n+  --> $DIR/move_closure.rs:120:5\n    |\n LL | /     move || {\n LL | |\n LL | |\n LL | |         let _t = b.0;\n-...  |\n+LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n note: Min Capture b[] -> ByValue\n-  --> $DIR/move_closure.rs:124:18\n+  --> $DIR/move_closure.rs:123:18\n    |\n LL |         let _t = b.0;\n    |                  ^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/move_closure.rs:138:5\n+  --> $DIR/move_closure.rs:136:5\n    |\n LL | /     move || {\n LL | |\n@@ -308,14 +316,14 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing b[Deref,(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:141:24\n+note: Capturing b[Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:139:24\n    |\n LL |         println!(\"{}\", b.0);\n    |                        ^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:138:5\n+  --> $DIR/move_closure.rs:136:5\n    |\n LL | /     move || {\n LL | |\n@@ -327,13 +335,13 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture b[] -> ByValue\n-  --> $DIR/move_closure.rs:141:24\n+  --> $DIR/move_closure.rs:139:24\n    |\n LL |         println!(\"{}\", b.0);\n    |                        ^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/move_closure.rs:155:5\n+  --> $DIR/move_closure.rs:153:5\n    |\n LL | /     move || {\n LL | |\n@@ -344,14 +352,14 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(1, 0),Deref,(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:158:24\n+note: Capturing t[(1, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:156:24\n    |\n LL |         println!(\"{}\", t.1.0);\n    |                        ^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:155:5\n+  --> $DIR/move_closure.rs:153:5\n    |\n LL | /     move || {\n LL | |\n@@ -363,11 +371,59 @@ LL | |     };\n    | |_____^\n    |\n note: Min Capture t[(1, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:158:24\n+  --> $DIR/move_closure.rs:156:24\n    |\n LL |         println!(\"{}\", t.1.0);\n    |                        ^^^^^\n \n-error: aborting due to 24 previous errors\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:172:39\n+   |\n+LL |     let c = #[rustc_capture_analysis] move || box_p_foo.x += 10;\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: Capturing box_p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:172:47\n+   |\n+LL |     let c = #[rustc_capture_analysis] move || box_p_foo.x += 10;\n+   |                                               ^^^^^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:172:39\n+   |\n+LL |     let c = #[rustc_capture_analysis] move || box_p_foo.x += 10;\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: Min Capture box_p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:172:47\n+   |\n+LL |     let c = #[rustc_capture_analysis] move || box_p_foo.x += 10;\n+   |                                               ^^^^^^^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:189:39\n+   |\n+LL |     let c = #[rustc_capture_analysis] move || p_foo.x += 10;\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: Capturing p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:189:47\n+   |\n+LL |     let c = #[rustc_capture_analysis] move || p_foo.x += 10;\n+   |                                               ^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:189:39\n+   |\n+LL |     let c = #[rustc_capture_analysis] move || p_foo.x += 10;\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: Min Capture p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:189:47\n+   |\n+LL |     let c = #[rustc_capture_analysis] move || p_foo.x += 10;\n+   |                                               ^^^^^^^\n+\n+error: aborting due to 30 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "e7edc0bbce39d12d7b68c2b122addd23112a1f57", "filename": "src/test/ui/closures/2229_closure_analysis/optimization/edge_case.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.rs?ref=81053b912fab51978f4806cddfc37eb9a9a5afc6", "patch": "@@ -22,7 +22,7 @@ fn foo<'a, 'b>(m: &'a MyStruct<'b>) -> impl FnMut() + 'static {\n     //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n     //~| ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n-    //~| NOTE: Capturing m[Deref,(0, 0),Deref] -> ImmBorrow\n+    //~| NOTE: Capturing m[Deref,(0, 0),Deref,(0, 0)] -> ImmBorrow\n     //~| NOTE: Min Capture m[Deref,(0, 0),Deref] -> ImmBorrow\n     c\n }"}, {"sha": "87d5d5bee07d84c4b27741c490515112813c442c", "filename": "src/test/ui/closures/2229_closure_analysis/optimization/edge_case.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81053b912fab51978f4806cddfc37eb9a9a5afc6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Foptimization%2Fedge_case.stderr?ref=81053b912fab51978f4806cddfc37eb9a9a5afc6", "patch": "@@ -13,7 +13,7 @@ error: First Pass analysis includes:\n LL |     let c = #[rustc_capture_analysis] || drop(&m.a.0);\n    |                                       ^^^^^^^^^^^^^^^\n    |\n-note: Capturing m[Deref,(0, 0),Deref] -> ImmBorrow\n+note: Capturing m[Deref,(0, 0),Deref,(0, 0)] -> ImmBorrow\n   --> $DIR/edge_case.rs:20:48\n    |\n LL |     let c = #[rustc_capture_analysis] || drop(&m.a.0);"}]}