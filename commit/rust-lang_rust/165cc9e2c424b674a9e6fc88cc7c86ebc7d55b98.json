{"sha": "165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NWNjOWUyYzQyNGI2NzRhOWU2ZmM4OGNjN2M4NmViYzdkNTViOTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-06T05:12:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-06T05:12:38Z"}, "message": "auto merge of #5213 : erickt/rust/vec-ref, r=graydon\n\nThis patch series changes a handful of vec functions to return references instead of copies. The one downside with making this change is that these functions aren't usable in a couple cases now due to some purity complaints. For example, this [change](https://github.com/erickt/rust/commit/c31e81a532fc07e89be33cadb5109d167aa725f4#L1R87). I couldn't figure out a way to get `last` to work on a `@mut ~[...]` type, so I ended up having to use `*crate_cache[crate_cache.len() - 1].metas`.", "tree": {"sha": "43dcf5c92761891df95bc33c2480426708926e73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43dcf5c92761891df95bc33c2480426708926e73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "html_url": "https://github.com/rust-lang/rust/commit/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c9b808d46d6b718cd25a813c9426c0c199b0acb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c9b808d46d6b718cd25a813c9426c0c199b0acb", "html_url": "https://github.com/rust-lang/rust/commit/7c9b808d46d6b718cd25a813c9426c0c199b0acb"}, {"sha": "743cfce7032e3b0649c22bf1c397280192bf9e95", "url": "https://api.github.com/repos/rust-lang/rust/commits/743cfce7032e3b0649c22bf1c397280192bf9e95", "html_url": "https://github.com/rust-lang/rust/commit/743cfce7032e3b0649c22bf1c397280192bf9e95"}], "stats": {"total": 491, "additions": 308, "deletions": 183}, "files": [{"sha": "1be0daf21ba94f94e89ff23e017869a2635625e1", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 167, "deletions": 69, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -211,40 +211,41 @@ pub pure fn build_sized_opt<A>(size: Option<uint>,\n // Accessors\n \n /// Returns the first element of a vector\n-pub pure fn head<T:Copy>(v: &[const T]) -> T { v[0] }\n-\n-/// Returns a vector containing all but the first element of a slice\n-pub pure fn tail<T:Copy>(v: &[const T]) -> ~[T] {\n-    slice(v, 1u, len(v)).to_vec()\n+pub pure fn head<T>(v: &r/[T]) -> &r/T {\n+    if v.len() == 0 { fail!(~\"head: empty vector\") }\n+    &v[0]\n }\n \n-/**\n- * Returns a vector containing all but the first `n` \\\n- * elements of a slice\n- */\n-pub pure fn tailn<T:Copy>(v: &[const T], n: uint) -> ~[T] {\n-    slice(v, n, len(v)).to_vec()\n+/// Returns `Some(x)` where `x` is the first element of the slice `v`,\n+/// or `None` if the vector is empty.\n+pub pure fn head_opt<T>(v: &r/[T]) -> Option<&r/T> {\n+    if v.len() == 0 { None } else { Some(&v[0]) }\n }\n \n+/// Returns a vector containing all but the first element of a slice\n+pub pure fn tail<T>(v: &r/[T]) -> &r/[T] { slice(v, 1, v.len()) }\n+\n+/// Returns a vector containing all but the first `n` elements of a slice\n+pub pure fn tailn<T>(v: &r/[T], n: uint) -> &r/[T] { slice(v, n, v.len()) }\n+\n /// Returns a vector containing all but the last element of a slice\n-pub pure fn init<T:Copy>(v: &[const T]) -> ~[T] {\n-    assert len(v) != 0u;\n-    slice(v, 0u, len(v) - 1u).to_vec()\n+pub pure fn init<T>(v: &r/[T]) -> &r/[T] { slice(v, 0, v.len() - 1) }\n+\n+/// Returns a vector containing all but the last `n' elements of a slice\n+pub pure fn initn<T>(v: &r/[T], n: uint) -> &r/[T] {\n+    slice(v, 0, v.len() - n)\n }\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n-pub pure fn last<T:Copy>(v: &[const T]) -> T {\n-    if len(v) == 0u { fail!(~\"last_unsafe: empty vector\") }\n-    v[len(v) - 1u]\n+pub pure fn last<T>(v: &r/[T]) -> &r/T {\n+    if v.len() == 0 { fail!(~\"last: empty vector\") }\n+    &v[v.len() - 1]\n }\n \n-/**\n- * Returns `Some(x)` where `x` is the last element of the slice `v`,\n- * or `none` if the vector is empty.\n- */\n-pub pure fn last_opt<T:Copy>(v: &[const T]) -> Option<T> {\n-    if len(v) == 0u { return None; }\n-    Some(v[len(v) - 1u])\n+/// Returns `Some(x)` where `x` is the last element of the slice `v`, or\n+/// `None` if the vector is empty.\n+pub pure fn last_opt<T>(v: &r/[T]) -> Option<&r/T> {\n+    if v.len() == 0 { None } else { Some(&v[v.len() - 1]) }\n }\n \n /// Return a slice that points into another slice.\n@@ -1692,41 +1693,29 @@ impl<T> Container for &[const T] {\n }\n \n pub trait CopyableVector<T> {\n-    pure fn head(&self) -> T;\n-    pure fn init(&self) -> ~[T];\n-    pure fn last(&self) -> T;\n     pure fn slice(&self, start: uint, end: uint) -> ~[T];\n-    pure fn tail(&self) -> ~[T];\n }\n \n /// Extension methods for vectors\n-impl<T:Copy> CopyableVector<T> for &[const T] {\n-    /// Returns the first element of a vector\n-    #[inline]\n-    pure fn head(&self) -> T { head(*self) }\n-\n-    /// Returns all but the last elemnt of a vector\n-    #[inline]\n-    pure fn init(&self) -> ~[T] { init(*self) }\n-\n-    /// Returns the last element of a `v`, failing if the vector is empty.\n-    #[inline]\n-    pure fn last(&self) -> T { last(*self) }\n-\n+impl<T: Copy> CopyableVector<T> for &[const T] {\n     /// Returns a copy of the elements from [`start`..`end`) from `v`.\n     #[inline]\n     pure fn slice(&self, start: uint, end: uint) -> ~[T] {\n         slice(*self, start, end).to_vec()\n     }\n-\n-    /// Returns all but the first element of a vector\n-    #[inline]\n-    pure fn tail(&self) -> ~[T] { tail(*self) }\n }\n \n pub trait ImmutableVector<T> {\n     pure fn view(&self, start: uint, end: uint) -> &self/[T];\n-    pure fn foldr<U:Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U;\n+    pure fn head(&self) -> &self/T;\n+    pure fn head_opt(&self) -> Option<&self/T>;\n+    pure fn tail(&self) -> &self/[T];\n+    pure fn tailn(&self, n: uint) -> &self/[T];\n+    pure fn init(&self) -> &self/[T];\n+    pure fn initn(&self, n: uint) -> &self/[T];\n+    pure fn last(&self) -> &self/T;\n+    pure fn last_opt(&self) -> Option<&self/T>;\n+    pure fn foldr<U: Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U;\n     pure fn map<U>(&self, f: fn(t: &T) -> U) -> ~[U];\n     pure fn mapi<U>(&self, f: fn(uint, t: &T) -> U) -> ~[U];\n     fn map_r<U>(&self, f: fn(x: &T) -> U) -> ~[U];\n@@ -1743,6 +1732,38 @@ impl<T> ImmutableVector<T> for &[T] {\n         slice(*self, start, end)\n     }\n \n+    /// Returns the first element of a vector, failing if the vector is empty.\n+    #[inline]\n+    pure fn head(&self) -> &self/T { head(*self) }\n+\n+    /// Returns the first element of a vector\n+    #[inline]\n+    pure fn head_opt(&self) -> Option<&self/T> { head_opt(*self) }\n+\n+    /// Returns all but the first element of a vector\n+    #[inline]\n+    pure fn tail(&self) -> &self/[T] { tail(*self) }\n+\n+    /// Returns all but the first `n' elements of a vector\n+    #[inline]\n+    pure fn tailn(&self, n: uint) -> &self/[T] { tailn(*self, n) }\n+\n+    /// Returns all but the last elemnt of a vector\n+    #[inline]\n+    pure fn init(&self) -> &self/[T] { init(*self) }\n+\n+    /// Returns all but the last `n' elemnts of a vector\n+    #[inline]\n+    pure fn initn(&self, n: uint) -> &self/[T] { initn(*self, n) }\n+\n+    /// Returns the last element of a `v`, failing if the vector is empty.\n+    #[inline]\n+    pure fn last(&self) -> &self/T { last(*self) }\n+\n+    /// Returns the last element of a `v`, failing if the vector is empty.\n+    #[inline]\n+    pure fn last_opt(&self) -> Option<&self/T> { last_opt(*self) }\n+\n     /// Reduce a vector from right to left\n     #[inline]\n     pure fn foldr<U:Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U {\n@@ -2570,27 +2591,117 @@ mod tests {\n \n     #[test]\n     fn test_head() {\n-        let a = ~[11, 12];\n-        assert (head(a) == 11);\n+        let mut a = ~[11];\n+        assert a.head() == &11;\n+        a = ~[11, 12];\n+        assert a.head() == &11;\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_head_empty() {\n+        let a: ~[int] = ~[];\n+        a.head();\n+    }\n+\n+    #[test]\n+    fn test_head_opt() {\n+        let mut a = ~[];\n+        assert a.head_opt() == None;\n+        a = ~[11];\n+        assert a.head_opt().unwrap() == &11;\n+        a = ~[11, 12];\n+        assert a.head_opt().unwrap() == &11;\n     }\n \n     #[test]\n     fn test_tail() {\n         let mut a = ~[11];\n-        assert (tail(a) == ~[]);\n+        assert a.tail() == &[];\n+        a = ~[11, 12];\n+        assert a.tail() == &[12];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_tail_empty() {\n+        let a: ~[int] = ~[];\n+        a.tail();\n+    }\n \n+    #[test]\n+    fn test_tailn() {\n+        let mut a = ~[11, 12, 13];\n+        assert a.tailn(0) == &[11, 12, 13];\n+        a = ~[11, 12, 13];\n+        assert a.tailn(2) == &[13];\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_tailn_empty() {\n+        let a: ~[int] = ~[];\n+        a.tailn(2);\n+    }\n+\n+    #[test]\n+    fn test_init() {\n+        let mut a = ~[11];\n+        assert a.init() == &[];\n         a = ~[11, 12];\n-        assert (tail(a) == ~[12]);\n+        assert a.init() == &[11];\n+    }\n+\n+    #[init]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_init_empty() {\n+        let a: ~[int] = ~[];\n+        a.init();\n+    }\n+\n+    #[test]\n+    fn test_initn() {\n+        let mut a = ~[11, 12, 13];\n+        assert a.initn(0) == &[11, 12, 13];\n+        a = ~[11, 12, 13];\n+        assert a.initn(2) == &[11];\n+    }\n+\n+    #[init]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_initn_empty() {\n+        let a: ~[int] = ~[];\n+        a.initn(2);\n     }\n \n     #[test]\n     fn test_last() {\n-        let mut n = last_opt(~[]);\n-        assert (n.is_none());\n-        n = last_opt(~[1, 2, 3]);\n-        assert (n == Some(3));\n-        n = last_opt(~[1, 2, 3, 4, 5]);\n-        assert (n == Some(5));\n+        let mut a = ~[11];\n+        assert a.last() == &11;\n+        a = ~[11, 12];\n+        assert a.last() == &12;\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_last_empty() {\n+        let a: ~[int] = ~[];\n+        a.last();\n+    }\n+\n+    #[test]\n+    fn test_last_opt() {\n+        let mut a = ~[];\n+        assert a.last_opt() == None;\n+        a = ~[11];\n+        assert a.last_opt().unwrap() == &11;\n+        a = ~[11, 12];\n+        assert a.last_opt().unwrap() == &12;\n     }\n \n     #[test]\n@@ -3262,12 +3373,6 @@ mod tests {\n         assert (v2[1] == 10);\n     }\n \n-    #[test]\n-    fn test_init() {\n-        let v = init(~[1, 2, 3]);\n-        assert v == ~[1, 2];\n-    }\n-\n     #[test]\n     fn test_split() {\n         fn f(x: &int) -> bool { *x == 3 }\n@@ -3332,13 +3437,6 @@ mod tests {\n                (~[], ~[1, 2, 3]);\n     }\n \n-    #[test]\n-    #[should_fail]\n-    #[ignore(cfg(windows))]\n-    fn test_init_empty() {\n-        init::<int>(~[]);\n-    }\n-\n     #[test]\n     fn test_concat() {\n         assert concat(~[~[1], ~[2,3]]) == ~[1, 2, 3];"}, {"sha": "235ed6412a356d624057942affb6faeafa2c5e4b", "filename": "src/librust/rust.rc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -130,7 +130,7 @@ fn cmd_help(args: &[~str]) -> ValidUsage {\n                     UsgExec(commandline) => {\n                         let words = str::words(commandline);\n                         let (prog, args) = (words.head(), words.tail());\n-                        run::run_program(prog, args);\n+                        run::run_program(*prog, args);\n                     }\n                 }\n                 Valid\n@@ -186,7 +186,10 @@ fn do_command(command: &Command, args: &[~str]) -> ValidUsage {\n         Exec(commandline) => {\n             let words = str::words(commandline);\n             let (prog, prog_args) = (words.head(), words.tail());\n-            let exitstatus = run::run_program(prog, prog_args + args);\n+            let exitstatus = run::run_program(\n+                *prog,\n+                vec::append(vec::from_slice(prog_args), args)\n+            );\n             os::set_exit_status(exitstatus);\n             Valid\n         }\n@@ -221,11 +224,12 @@ fn usage() {\n }\n \n pub fn main() {\n-    let args = os::args().tail();\n+    let os_args = os::args();\n+    let args = os_args.tail();\n \n     if !args.is_empty() {\n         for commands.each |command| {\n-            if command.cmd == args.head() {\n+            if command.cmd == *args.head() {\n                 let result = do_command(command, args.tail());\n                 if result.is_valid() { return; }\n             }"}, {"sha": "ff26000af9749e3720aa58e44d6cce2d66d09683", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -65,7 +65,7 @@ struct cache_entry {\n     metas: @~[@ast::meta_item]\n }\n \n-fn dump_crates(+crate_cache: @mut ~[cache_entry]) {\n+fn dump_crates(crate_cache: @mut ~[cache_entry]) {\n     debug!(\"resolved crates:\");\n     for crate_cache.each |entry| {\n         debug!(\"cnum: %?\", entry.cnum);\n@@ -81,7 +81,9 @@ fn warn_if_multiple_versions(e: @mut Env,\n \n     if crate_cache.len() != 0u {\n         let name = loader::crate_name_from_metas(\n-            /*bad*/copy *crate_cache.last().metas);\n+            *crate_cache[crate_cache.len() - 1].metas\n+        );\n+\n         let (matches, non_matches) =\n             partition(crate_cache.map_to_vec(|&entry| {\n                 let othername = loader::crate_name_from_metas("}, {"sha": "0bf1fc3870449e6e2190997643ef05193b788a47", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -558,16 +558,18 @@ pub fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n                        -> csearch::found_ast {\n     debug!(\"Looking up item: %d\", id);\n     let item_doc = lookup_item(id, cdata.data);\n-    let path = vec::init(item_path(intr, item_doc));\n+    let path = {\n+        let item_path = item_path(intr, item_doc);\n+        vec::from_slice(item_path.init())\n+    };\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n       Some(ref ii) => csearch::found((/*bad*/copy *ii)),\n       None => {\n         match item_parent_item(item_doc) {\n           Some(did) => {\n             let did = translate_def_id(cdata, did);\n             let parent_item = lookup_item(did.node, cdata.data);\n-            match decode_inlined_item(cdata, tcx, path,\n-                                               parent_item) {\n+            match decode_inlined_item(cdata, tcx, path, parent_item) {\n               Some(ref ii) => csearch::found_parent(did, (/*bad*/copy *ii)),\n               None => csearch::not_found\n             }"}, {"sha": "d45cefdbf081f2203d407f7caa88167e15c2853d", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -84,19 +84,20 @@ fn libname(cx: Context) -> (~str, ~str) {\n     (str::from_slice(dll_prefix), str::from_slice(dll_suffix))\n }\n \n-fn find_library_crate_aux(cx: Context,\n-                          (prefix, suffix): (~str, ~str),\n-                          filesearch: filesearch::FileSearch) ->\n-   Option<(~str, @~[u8])> {\n-    let crate_name = crate_name_from_metas(/*bad*/copy cx.metas);\n+fn find_library_crate_aux(\n+    cx: Context,\n+    (prefix, suffix): (~str, ~str),\n+    filesearch: filesearch::FileSearch\n+) -> Option<(~str, @~[u8])> {\n+    let crate_name = crate_name_from_metas(cx.metas);\n     let prefix: ~str = prefix + *crate_name + ~\"-\";\n     let suffix: ~str = /*bad*/copy suffix;\n \n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| {\n         debug!(\"inspecting file %s\", path.to_str());\n         let f: ~str = path.filename().get();\n-        if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n+        if !(f.starts_with(prefix) && f.ends_with(suffix)) {\n             debug!(\"skipping %s, doesn't look like %s*%s\", path.to_str(),\n                    prefix, suffix);\n             option::None::<()>\n@@ -140,11 +141,11 @@ fn find_library_crate_aux(cx: Context,\n     }\n }\n \n-pub fn crate_name_from_metas(+metas: &[@ast::meta_item]) -> @~str {\n+pub fn crate_name_from_metas(metas: &[@ast::meta_item]) -> @~str {\n     let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n-    match vec::last_opt(name_items) {\n+    match name_items.last_opt() {\n         Some(i) => {\n-            match attr::get_meta_item_value_str(i) {\n+            match attr::get_meta_item_value_str(*i) {\n                 Some(n) => n,\n                 // FIXME (#2406): Probably want a warning here since the user\n                 // is using the wrong type of meta item."}, {"sha": "cf88a0eb90240b3e46595cabdee3c078c50ceffe", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -105,7 +105,7 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n-                           +path: ast_map::path,\n+                           path: ast_map::path,\n                            par_doc: ebml::Doc)\n                         -> Option<ast::inlined_item> {\n     let dcx = @DecodeContext {"}, {"sha": "f9f655d50218fba390ac9274dcc76306c84d67ee", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -71,7 +71,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n                                             arm.pats);\n         }\n \n-        check_arms(cx, (/*bad*/copy *arms));\n+        check_arms(cx, *arms);\n         /* Check for exhaustiveness */\n          // Check for empty enum, because is_useful only works on inhabited\n          // types.\n@@ -108,12 +108,12 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n }\n \n // Check for unreachable patterns\n-pub fn check_arms(cx: @MatchCheckCtxt, arms: ~[arm]) {\n+pub fn check_arms(cx: @MatchCheckCtxt, arms: &[arm]) {\n     let mut seen = ~[];\n     for arms.each |arm| {\n         for arm.pats.each |pat| {\n             let v = ~[*pat];\n-            match is_useful(cx, copy seen, v) {\n+            match is_useful(cx, &seen, v) {\n               not_useful => {\n                 cx.tcx.sess.span_err(pat.span, ~\"unreachable pattern\");\n               }\n@@ -133,7 +133,7 @@ pub fn raw_pat(p: @pat) -> @pat {\n \n pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n     assert(!pats.is_empty());\n-    let ext = match is_useful(cx, vec::map(pats, |p| ~[*p]), ~[wild()]) {\n+    let ext = match is_useful(cx, &pats.map(|p| ~[*p]), ~[wild()]) {\n         not_useful => {\n             // This is good, wildcard pattern isn't reachable\n             return;\n@@ -165,7 +165,7 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n                 ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n                     match *ctor {\n                         vec(n) => Some(@fmt!(\"vectors of length %u\", n)),\n-                    _ => None\n+                        _ => None\n                     }\n                 }\n                 _ => None\n@@ -205,10 +205,10 @@ pub enum ctor {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-pub fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: &[@pat]) -> useful {\n+pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n-    let real_pat = match vec::find(m, |r| r[0].id != 0) {\n+    let real_pat = match m.find(|r| r[0].id != 0) {\n       Some(r) => r[0], None => v[0]\n     };\n     let left_ty = if real_pat.id == 0 { ty::mk_nil(cx.tcx) }\n@@ -264,8 +264,8 @@ pub fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: &[@pat]) -> useful {\n           }\n           Some(ref ctor) => {\n             match is_useful(cx,\n-                            vec::filter_map(m, |r| default(cx, r)),\n-                            vec::tail(v)) {\n+                            &m.filter_mapped(|r| default(cx, *r)),\n+                            v.tail()) {\n               useful_ => useful(left_ty, (/*bad*/copy *ctor)),\n               ref u => (/*bad*/copy *u)\n             }\n@@ -280,15 +280,15 @@ pub fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: &[@pat]) -> useful {\n }\n \n pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n-                             m: matrix,\n-                             +v: &[@pat],\n+                             m: &matrix,\n+                             v: &[@pat],\n                              +ctor: ctor,\n                              arity: uint,\n                              lty: ty::t)\n                           -> useful {\n     let ms = m.filter_mapped(|r| specialize(cx, *r, ctor, arity, lty));\n     let could_be_useful = is_useful(\n-        cx, ms, specialize(cx, v, ctor, arity, lty).get());\n+        cx, &ms, specialize(cx, v, ctor, arity, lty).get());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n       ref u => (/*bad*/copy *u)\n@@ -347,7 +347,7 @@ pub fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n }\n \n pub fn missing_ctor(cx: @MatchCheckCtxt,\n-                    m: matrix,\n+                    m: &matrix,\n                     left_ty: ty::t)\n                  -> Option<ctor> {\n     match ty::get(left_ty).sty {\n@@ -475,7 +475,7 @@ pub fn wild() -> @pat {\n }\n \n pub fn specialize(cx: @MatchCheckCtxt,\n-                  +r: &[@pat],\n+                  r: &[@pat],\n                   ctor_id: ctor,\n                   arity: uint,\n                   left_ty: ty::t)\n@@ -485,13 +485,17 @@ pub fn specialize(cx: @MatchCheckCtxt,\n     match r0 {\n         pat{id: pat_id, node: n, span: pat_span} =>\n             match n {\n-            pat_wild => Some(vec::append(vec::from_elem(arity, wild()),\n-                                         vec::tail(r))),\n+            pat_wild => {\n+                Some(vec::append(vec::from_elem(arity, wild()), r.tail()))\n+            }\n             pat_ident(_, _, _) => {\n                 match cx.tcx.def_map.find(&pat_id) {\n                     Some(def_variant(_, id)) => {\n-                        if variant(id) == ctor_id { Some(vec::tail(r)) }\n-                        else { None }\n+                        if variant(id) == ctor_id {\n+                            Some(vec::from_slice(r.tail()))\n+                        } else {\n+                            None\n+                        }\n                     }\n                     Some(def_const(did)) => {\n                         let const_expr =\n@@ -506,10 +510,20 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             single => true,\n                             _ => fail!(~\"type error\")\n                         };\n-                        if match_ { Some(vec::tail(r)) } else { None }\n+                        if match_ {\n+                            Some(vec::from_slice(r.tail()))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    _ => {\n+                        Some(\n+                            vec::append(\n+                                vec::from_elem(arity, wild()),\n+                                r.tail()\n+                            )\n+                        )\n                     }\n-                    _ => Some(vec::append(vec::from_elem(arity, wild()),\n-                                          vec::tail(r)))\n                 }\n             }\n             pat_enum(_, args) => {\n@@ -519,7 +533,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             Some(args) => args,\n                             None => vec::from_elem(arity, wild())\n                         };\n-                        Some(vec::append(args, vec::tail(r)))\n+                        Some(vec::append(args, vec::from_slice(r.tail())))\n                     }\n                     def_variant(_, _) => None,\n                     def_struct(*) => {\n@@ -529,7 +543,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             Some(args) => new_args = args,\n                             None => new_args = vec::from_elem(arity, wild())\n                         }\n-                        Some(vec::append(new_args, vec::tail(r)))\n+                        Some(vec::append(new_args, vec::from_slice(r.tail())))\n                     }\n                     _ => None\n                 }\n@@ -545,7 +559,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                         _ => wild()\n                     }\n                 });\n-                Some(vec::append(args, vec::tail(r)))\n+                Some(vec::append(args, vec::from_slice(r.tail())))\n             }\n             pat_struct(_, ref flds, _) => {\n                 // Is this a struct or an enum variant?\n@@ -560,7 +574,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                     _ => wild()\n                                 }\n                             });\n-                            Some(vec::append(args, vec::tail(r)))\n+                            Some(vec::append(args, vec::from_slice(r.tail())))\n                         } else {\n                             None\n                         }\n@@ -587,13 +601,14 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                 _ => wild()\n                             }\n                         });\n-                        Some(vec::append(args, vec::tail(r)))\n+                        Some(vec::append(args, vec::from_slice(r.tail())))\n                     }\n                 }\n             }\n-            pat_tup(args) => Some(vec::append(args, vec::tail(r))),\n-            pat_box(a) | pat_uniq(a) | pat_region(a) =>\n-                Some(vec::append(~[a], vec::tail(r))),\n+            pat_tup(args) => Some(vec::append(args, r.tail())),\n+            pat_box(a) | pat_uniq(a) | pat_region(a) => {\n+                Some(vec::append(~[a], r.tail()))\n+            }\n             pat_lit(expr) => {\n                 let e_v = eval_const_expr(cx.tcx, expr);\n                 let match_ = match ctor_id {\n@@ -605,21 +620,21 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     single => true,\n                     _ => fail!(~\"type error\")\n                 };\n-                if match_ { Some(vec::tail(r)) } else { None }\n+                if match_ { Some(vec::from_slice(r.tail())) } else { None }\n             }\n             pat_range(lo, hi) => {\n                 let (c_lo, c_hi) = match ctor_id {\n                     val(ref v) => ((/*bad*/copy *v), (/*bad*/copy *v)),\n                     range(ref lo, ref hi) =>\n                         ((/*bad*/copy *lo), (/*bad*/copy *hi)),\n-                    single => return Some(vec::tail(r)),\n+                    single => return Some(vec::from_slice(r.tail())),\n                     _ => fail!(~\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo),\n                 v_hi = eval_const_expr(cx.tcx, hi);\n                 let match_ = compare_const_vals(c_lo, v_lo) >= 0 &&\n                     compare_const_vals(c_hi, v_hi) <= 0;\n-          if match_ { Some(vec::tail(r)) } else { None }\n+          if match_ { Some(vec::from_slice(r.tail())) } else { None }\n       }\n             pat_vec(elems, tail) => {\n                 match ctor_id {\n@@ -630,10 +645,10 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                 vec::append(elems, vec::from_elem(\n                                     arity - num_elements, wild()\n                                 )),\n-                                vec::tail(r)\n+                                vec::from_slice(r.tail())\n                             ))\n                         } else if num_elements == arity {\n-                            Some(vec::append(elems, vec::tail(r)))\n+                            Some(vec::append(elems, r.tail()))\n                         } else {\n                             None\n                         }\n@@ -645,8 +660,8 @@ pub fn specialize(cx: @MatchCheckCtxt,\n     }\n }\n \n-pub fn default(cx: @MatchCheckCtxt, r: ~[@pat]) -> Option<~[@pat]> {\n-    if is_wild(cx, r[0]) { Some(vec::tail(r)) }\n+pub fn default(cx: @MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n+    if is_wild(cx, r[0]) { Some(vec::from_slice(r.tail())) }\n     else { None }\n }\n "}, {"sha": "77ad7df53197877461e7ac9e965c220c2c5e30ff", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -26,7 +26,7 @@ pub fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n     do pat_bindings(dm, pat) |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n     };\n-    return map;\n+    map\n }\n \n pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {"}, {"sha": "49898885a66034a5712f4693e8c55a0911cb9ef1", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -1438,7 +1438,7 @@ pub impl Resolver {\n                                 type_value_ns => AnyNS\n                             };\n \n-                            let source_ident = full_path.idents.last();\n+                            let source_ident = *full_path.idents.last();\n                             let subclass = @SingleImport(binding,\n                                                          source_ident,\n                                                          ns);\n@@ -4087,7 +4087,7 @@ pub impl Resolver {\n \n                 // First, check to see whether the name is a primitive type.\n                 if path.idents.len() == 1 {\n-                    let name = path.idents.last();\n+                    let name = *path.idents.last();\n \n                     match self.primitive_type_table\n                             .primitive_types\n@@ -4110,7 +4110,7 @@ pub impl Resolver {\n                                 debug!(\"(resolving type) resolved `%s` to \\\n                                         type %?\",\n                                        *self.session.str_of(\n-                                            path.idents.last()),\n+                                            *path.idents.last()),\n                                        def);\n                                 result_def = Some(def);\n                             }\n@@ -4296,7 +4296,7 @@ pub impl Resolver {\n                                 path.span,\n                                 fmt!(\"not an enum variant: %s\",\n                                      *self.session.str_of(\n-                                         path.idents.last())));\n+                                         *path.idents.last())));\n                         }\n                         None => {\n                             self.session.span_err(path.span,\n@@ -4418,7 +4418,7 @@ pub impl Resolver {\n                                                      namespace);\n         }\n \n-        return self.resolve_identifier(path.idents.last(),\n+        return self.resolve_identifier(*path.idents.last(),\n                                        namespace,\n                                        check_ribs,\n                                        path.span);\n@@ -4552,7 +4552,7 @@ pub impl Resolver {\n             }\n         }\n \n-        let name = path.idents.last();\n+        let name = *path.idents.last();\n         match self.resolve_definition_of_name_in_module(containing_module,\n                                                         name,\n                                                         namespace,\n@@ -4601,7 +4601,7 @@ pub impl Resolver {\n             }\n         }\n \n-        let name = path.idents.last();\n+        let name = *path.idents.last();\n         match self.resolve_definition_of_name_in_module(containing_module,\n                                                         name,\n                                                         namespace,"}, {"sha": "1926b2f2e5df7912915c2fb019cc0ee3e000913c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -2207,7 +2207,7 @@ pub fn register_fn_fuller(ccx: @CrateContext,\n            ast_map::path_to_str(path, ccx.sess.parse_sess.interner));\n \n     let ps = if attr::attrs_contains_name(attrs, \"no_mangle\") {\n-        path_elt_to_str(path.last(), ccx.sess.parse_sess.interner)\n+        path_elt_to_str(*path.last(), ccx.sess.parse_sess.interner)\n     } else {\n         mangle_exported_name(ccx, /*bad*/copy path, node_type)\n     };"}, {"sha": "1d7314f751870e17e98700bb669f32fe422f7b3b", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -71,8 +71,8 @@ pub impl FnType {\n             let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n             let llretloc = Load(bcx, llretptr);\n                 llargvals = ~[llretloc];\n-                atys = vec::tail(atys);\n-                attrs = vec::tail(attrs);\n+                atys = vec::from_slice(atys.tail());\n+                attrs = vec::from_slice(attrs.tail());\n         }\n \n         while i < n {\n@@ -131,8 +131,8 @@ pub impl FnType {\n         let mut attrs = /*bad*/copy self.attrs;\n         let mut j = 0u;\n         let llretptr = if self.sret {\n-            atys = vec::tail(atys);\n-            attrs = vec::tail(attrs);\n+            atys = vec::from_slice(atys.tail());\n+            attrs = vec::from_slice(attrs.tail());\n             j = 1u;\n             get_param(llwrapfn, 0u)\n         } else if self.ret_ty.cast {"}, {"sha": "61d0594d2274f98bee27bf7fc3227a53b5b47cc5", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -792,12 +792,14 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n         match arg.pat.node {\n             ast::pat_ident(_, path, _) => {\n                 // XXX: This is wrong; it should work for multiple bindings.\n-                let mdnode = create_var(tg,\n-                                        context.node,\n-                                        *cx.sess.str_of(path.idents.last()),\n-                                        filemd.node,\n-                                        loc.line as int,\n-                                        tymd.node);\n+                let mdnode = create_var(\n+                    tg,\n+                    context.node,\n+                    *cx.sess.str_of(*path.idents.last()),\n+                    filemd.node,\n+                    loc.line as int,\n+                    tymd.node\n+                );\n \n                 let mdval = @Metadata {\n                     node: mdnode,"}, {"sha": "12a2011ad2560c2d8b284552d7eba1401e4f97f3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -3815,7 +3815,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n           }\n \n           ast_map::node_variant(ref variant, _, path) => {\n-            vec::append_one(vec::init(*path),\n+            vec::append_one(vec::from_slice(vec::init(*path)),\n                             ast_map::path_name((*variant).node.name))\n           }\n "}, {"sha": "83ef5a6f3a85594132a2b78a7be4566efa8f22dc", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -130,18 +130,18 @@ pub fn parse_config_(\n     let args = args.tail();\n     let opts = vec::unzip(opts()).first();\n     match getopts::getopts(args, opts) {\n-        result::Ok(matches) => {\n+        Ok(matches) => {\n             if matches.free.len() == 1 {\n-                let input_crate = Path(vec::head(matches.free));\n+                let input_crate = Path(*matches.free.head());\n                 config_from_opts(&input_crate, &matches, program_output)\n             } else if matches.free.is_empty() {\n-                result::Err(~\"no crates specified\")\n+                Err(~\"no crates specified\")\n             } else {\n-                result::Err(~\"multiple crates specified\")\n+                Err(~\"multiple crates specified\")\n             }\n         }\n-        result::Err(f) => {\n-            result::Err(getopts::fail_str(f))\n+        Err(f) => {\n+            Err(getopts::fail_str(f))\n         }\n     }\n }\n@@ -262,7 +262,7 @@ fn should_find_pandoc() {\n         output_format: PandocHtml,\n         .. default_config(&Path(\"test\"))\n     };\n-    let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |prog, _| {\n+    let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |_, _| {\n         ProgramOutput { status: 0, out: ~\"pandoc 1.8.2.1\", err: ~\"\" }\n     };\n     let result = maybe_find_pandoc(&config, None, mock_program_output);"}, {"sha": "3a4cd9e1379f9c994e671eac573c3897d56eb21f", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -142,16 +142,16 @@ fn parse_desc(desc: ~str) -> Option<~str> {\n }\n \n fn first_sentence(s: ~str) -> Option<~str> {\n-    let paras = paragraphs(copy s);\n+    let paras = paragraphs(s);\n     if !paras.is_empty() {\n-        let first_para = vec::head(paras);\n-        Some(str::replace(first_sentence_(first_para), ~\"\\n\", ~\" \"))\n+        let first_para = paras.head();\n+        Some(str::replace(first_sentence_(*first_para), ~\"\\n\", ~\" \"))\n     } else {\n         None\n     }\n }\n \n-fn first_sentence_(s: ~str) -> ~str {\n+fn first_sentence_(s: &str) -> ~str {\n     let mut dotcount = 0;\n     // The index of the character following a single dot. This allows\n     // Things like [0..1) to appear in the brief description\n@@ -169,20 +169,20 @@ fn first_sentence_(s: ~str) -> ~str {\n         }\n     };\n     match idx {\n-      Some(idx) if idx > 2u => {\n-        str::slice(s, 0u, idx - 1u)\n-      }\n-      _ => {\n-        if str::ends_with(s, ~\".\") {\n-            str::slice(s, 0u, str::len(s))\n-        } else {\n-            copy s\n+        Some(idx) if idx > 2u => {\n+            str::from_slice(str::view(s, 0, idx - 1))\n+        }\n+        _ => {\n+            if str::ends_with(s, ~\".\") {\n+                str::from_slice(s)\n+            } else {\n+                str::from_slice(s)\n+            }\n         }\n-      }\n     }\n }\n \n-fn paragraphs(s: ~str) -> ~[~str] {\n+fn paragraphs(s: &str) -> ~[~str] {\n     let lines = str::lines_any(s);\n     let mut whitespace_lines = 0;\n     let mut accum = ~\"\";"}, {"sha": "06595a23d9612bafc10ef5bdcd893d5b1d1e584a", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -78,8 +78,8 @@ fn unindent(s: &str) -> ~str {\n     };\n \n     if !lines.is_empty() {\n-        let unindented = ~[str::trim(vec::head(lines))]\n-            + do vec::tail(lines).map |line| {\n+        let unindented = ~[lines.head().trim()]\n+            + do lines.tail().map |line| {\n             if str::is_whitespace(*line) {\n                 copy *line\n             } else {"}, {"sha": "d7428ae15e7ef2dcb28629f2a9ec2e30971f9bc1", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -57,7 +57,7 @@ pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n         }\n     }\n \n-    result::Ok(parts.last())\n+    result::Ok(copy *parts.last())\n }\n \n struct ListenerFn {\n@@ -516,9 +516,11 @@ pub fn get_pkg(id: ~str,\n         return result::Err(~\"package not found\");\n     }\n \n-    result::Ok(sort::merge_sort(possibs, |v1, v2| {\n+    let possibs = sort::merge_sort(possibs, |v1, v2| {\n         v1.vers <= v2.vers\n-    }).last())\n+    });\n+\n+    result::Ok(copy *possibs.last())\n }\n \n pub fn add_pkg(pkg: &Package) -> bool {"}, {"sha": "e8836c5866284fecba1e922ee7bca5521f04a48f", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -346,7 +346,7 @@ pub impl BigUint {\n         }\n \n         let mut shift = 0;\n-        let mut n = other.data.last();\n+        let mut n = *other.data.last();\n         while n < (1 << BigDigit::bits - 2) {\n             n <<= 1;\n             shift += 1;\n@@ -384,7 +384,7 @@ pub impl BigUint {\n             }\n \n             let an = vec::slice(a.data, a.data.len() - n, a.data.len());\n-            let bn = b.data.last();\n+            let bn = *b.data.last();\n             let mut d = ~[];\n             let mut carry = 0;\n             for vec::rev_each(an) |elt| {"}, {"sha": "7993f15f622c8566f9fac2f2ead3d086f48733f0", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -759,7 +759,7 @@ pub fn Decoder(json: Json) -> Decoder {\n priv impl Decoder {\n     fn peek(&self) -> &self/Json {\n         if self.stack.len() == 0 { self.stack.push(&self.json); }\n-        vec::last(self.stack)\n+        self.stack[self.stack.len() - 1]\n     }\n \n     fn pop(&self) -> &self/Json {"}, {"sha": "2a2c655cca9eebeaef6c06f85b78ebb2858714ed", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -197,7 +197,7 @@ mod tests {\n         let mut sorted = merge_sort(data, le);\n         let mut heap = from_vec(data);\n         while !heap.is_empty() {\n-            assert *heap.top() == sorted.last();\n+            assert heap.top() == sorted.last();\n             assert heap.pop() == sorted.pop();\n         }\n     }"}, {"sha": "c46c2d17ed0c6f1fab5ab97cf2d77913a4b35feb", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -174,7 +174,7 @@ pub impl Database {\n         let k = json_encode(&(fn_name, declared_inputs));\n         match self.db_cache.find(&k) {\n             None => None,\n-            Some(&v) => Some(json_decode(copy v))\n+            Some(v) => Some(json_decode(*v))\n         }\n     }\n "}, {"sha": "ba683004aeec7ee10069e82c739c35217ce0b298", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -31,7 +31,7 @@ pub pure fn path_name_i(idents: &[ident], intr: @token::ident_interner)\n }\n \n \n-pub pure fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }\n+pub pure fn path_to_ident(p: @path) -> ident { copy *p.idents.last() }\n \n pub pure fn local_def(id: node_id) -> def_id {\n     ast::def_id { crate: local_crate, node: id }"}, {"sha": "fb7143f7c1438012effd31f4f273025c5d8a4f8c", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -229,7 +229,7 @@ fn last_meta_item_by_name(items: &[@ast::meta_item], name: &str)\n     -> Option<@ast::meta_item> {\n \n     let items = attr::find_meta_items_by_name(items, name);\n-    vec::last_opt(items)\n+    items.last_opt().map(|item| **item)\n }\n \n pub fn last_meta_item_value_str_by_name(items: &[@ast::meta_item], name: &str)"}, {"sha": "116ecc37d2e18c0c8a9259a9cece29caebda411f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -167,7 +167,7 @@ pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n     while r.cur.idx >= r.cur.readme.len() {\n         /* done with this set; pop or repeat? */\n         if ! r.cur.dotdotdoted\n-            || r.repeat_idx.last() == r.repeat_len.last() - 1 {\n+            || { *r.repeat_idx.last() == *r.repeat_len.last() - 1 } {\n \n             match r.cur.up {\n               None => {"}, {"sha": "4a372d016f9cf70d8ae2b6d9887eeb16d22fb55a", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -93,7 +93,7 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n                 fn_box: || @Cons((), fn_box()),\n                 tuple: (@Cons((), st.tuple.first()),\n                         ~Cons((), @*st.tuple.second())),\n-                vec: st.vec + ~[@Cons((), st.vec.last())],\n+                vec: st.vec + ~[@Cons((), *st.vec.last())],\n                 res: r(@Cons((), st.res._l))\n             }\n           }"}, {"sha": "fdb6989b7bb37b2adc9b28a53fc6e2c2d77db6a9", "filename": "src/test/run-pass/zip-same-length.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzip-same-length.rs?ref=165cc9e2c424b674a9e6fc88cc7c86ebc7d55b98", "patch": "@@ -10,7 +10,6 @@\n \n // In this case, the code should compile and should\n // succeed at runtime\n-use core::vec::{head, last, same_length, zip};\n \n fn enum_chars(start: u8, end: u8) -> ~[char] {\n     assert start < end;\n@@ -33,8 +32,8 @@ pub fn main() {\n     let chars = enum_chars(a, j);\n     let ints = enum_uints(k, l);\n \n-    let ps = zip(chars, ints);\n+    let ps = vec::zip(chars, ints);\n \n-    assert (head(ps) == ('a', 1u));\n-    assert (last(ps) == (j as char, 10u));\n+    assert (ps.head() == &('a', 1u));\n+    assert (ps.last() == &(j as char, 10u));\n }"}]}