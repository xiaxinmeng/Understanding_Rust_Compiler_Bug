{"sha": "73b08131dff8855c6736ce41867a6a197dfb87af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYjA4MTMxZGZmODg1NWM2NzM2Y2U0MTg2N2E2YTE5N2RmYjg3YWY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-11-09T12:28:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-09T12:28:57Z"}, "message": "Merge #6506\n\n6506: Cleanup assists r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "9ee0820ea9c84dd40c761586cf7efe3ff0f77abc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ee0820ea9c84dd40c761586cf7efe3ff0f77abc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73b08131dff8855c6736ce41867a6a197dfb87af", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfqTYJCRBK7hj4Ov3rIwAAdHIIAFel6MBOQsd8P7W9J3FHJlZh\nl07ELrZYjCrzpK2srAH5zdcBC4I4VGoEwjpmfaL7ReAZq6S5TeA6mhrpt7y5P7b/\nXCM2CFLHzs7LHAHCwBViWx1mYnb/rTXx8v7wGo33IlzS6U6D/hEH9AyZ7Vd3JTwn\nOaW/QVIcloCeHPqPfDfEJ8dqmKmw+3gHjzmTY4ruvxiNNY/5807M4DACihPeG+0X\nt3muPZ3vbsQqlfzSyyGlNKqX0PrcF7La121ecITyAmGEL32Av9GpDP6l5eRW4qmW\n9VLNNqj8dBPIchG78s2QzibjJpBdz1rr4EVgT9cXsbPdtuFl83ewBQMcdiVTXs0=\n=bbJl\n-----END PGP SIGNATURE-----\n", "payload": "tree 9ee0820ea9c84dd40c761586cf7efe3ff0f77abc\nparent 2d3b0571bb02aa85e3aae390e5cfb10b0ada5c38\nparent d31ce3b16cbd23950197d8992720b431e19b6af1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1604924937 +0000\ncommitter GitHub <noreply@github.com> 1604924937 +0000\n\nMerge #6506\n\n6506: Cleanup assists r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73b08131dff8855c6736ce41867a6a197dfb87af", "html_url": "https://github.com/rust-lang/rust/commit/73b08131dff8855c6736ce41867a6a197dfb87af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73b08131dff8855c6736ce41867a6a197dfb87af/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d3b0571bb02aa85e3aae390e5cfb10b0ada5c38", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d3b0571bb02aa85e3aae390e5cfb10b0ada5c38", "html_url": "https://github.com/rust-lang/rust/commit/2d3b0571bb02aa85e3aae390e5cfb10b0ada5c38"}, {"sha": "d31ce3b16cbd23950197d8992720b431e19b6af1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d31ce3b16cbd23950197d8992720b431e19b6af1", "html_url": "https://github.com/rust-lang/rust/commit/d31ce3b16cbd23950197d8992720b431e19b6af1"}], "stats": {"total": 2436, "additions": 1261, "deletions": 1175}, "files": [{"sha": "76f33a5b6d3822b0450675471b72fac5b615f531", "filename": "crates/assists/src/handlers/change_return_type_to_result.rs", "status": "removed", "additions": 0, "deletions": 1091, "changes": 1091, "blob_url": "https://github.com/rust-lang/rust/blob/2d3b0571bb02aa85e3aae390e5cfb10b0ada5c38/crates%2Fassists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3b0571bb02aa85e3aae390e5cfb10b0ada5c38/crates%2Fassists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs?ref=2d3b0571bb02aa85e3aae390e5cfb10b0ada5c38", "patch": "@@ -1,1091 +0,0 @@\n-use std::iter;\n-\n-use syntax::{\n-    ast::{self, make, BlockExpr, Expr, LoopBodyOwner},\n-    match_ast, AstNode, SyntaxNode,\n-};\n-use test_utils::mark;\n-\n-use crate::{AssistContext, AssistId, AssistKind, Assists};\n-\n-// Assist: change_return_type_to_result\n-//\n-// Change the function's return type to Result.\n-//\n-// ```\n-// fn foo() -> i32<|> { 42i32 }\n-// ```\n-// ->\n-// ```\n-// fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n-// ```\n-pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let ret_type = ctx.find_node_at_offset::<ast::RetType>()?;\n-    let parent = ret_type.syntax().parent()?;\n-    let block_expr = match_ast! {\n-        match parent {\n-            ast::Fn(func) => func.body()?,\n-            ast::ClosureExpr(closure) => match closure.body()? {\n-                Expr::BlockExpr(block) => block,\n-                // closures require a block when a return type is specified\n-                _ => return None,\n-            },\n-            _ => return None,\n-        }\n-    };\n-\n-    let type_ref = &ret_type.ty()?;\n-    let ret_type_str = type_ref.syntax().text().to_string();\n-    let first_part_ret_type = ret_type_str.splitn(2, '<').next();\n-    if let Some(ret_type_first_part) = first_part_ret_type {\n-        if ret_type_first_part.ends_with(\"Result\") {\n-            mark::hit!(change_return_type_to_result_simple_return_type_already_result);\n-            return None;\n-        }\n-    }\n-\n-    acc.add(\n-        AssistId(\"change_return_type_to_result\", AssistKind::RefactorRewrite),\n-        \"Wrap return type in Result\",\n-        type_ref.syntax().text_range(),\n-        |builder| {\n-            let mut tail_return_expr_collector = TailReturnCollector::new();\n-            tail_return_expr_collector.collect_jump_exprs(&block_expr, false);\n-            tail_return_expr_collector.collect_tail_exprs(&block_expr);\n-\n-            for ret_expr_arg in tail_return_expr_collector.exprs_to_wrap {\n-                let ok_wrapped = make::expr_call(\n-                    make::expr_path(make::path_unqualified(make::path_segment(make::name_ref(\n-                        \"Ok\",\n-                    )))),\n-                    make::arg_list(iter::once(ret_expr_arg.clone())),\n-                );\n-                builder.replace_ast(ret_expr_arg, ok_wrapped);\n-            }\n-\n-            match ctx.config.snippet_cap {\n-                Some(cap) => {\n-                    let snippet = format!(\"Result<{}, ${{0:_}}>\", type_ref);\n-                    builder.replace_snippet(cap, type_ref.syntax().text_range(), snippet)\n-                }\n-                None => builder\n-                    .replace(type_ref.syntax().text_range(), format!(\"Result<{}, _>\", type_ref)),\n-            }\n-        },\n-    )\n-}\n-\n-struct TailReturnCollector {\n-    exprs_to_wrap: Vec<ast::Expr>,\n-}\n-\n-impl TailReturnCollector {\n-    fn new() -> Self {\n-        Self { exprs_to_wrap: vec![] }\n-    }\n-    /// Collect all`return` expression\n-    fn collect_jump_exprs(&mut self, block_expr: &BlockExpr, collect_break: bool) {\n-        let statements = block_expr.statements();\n-        for stmt in statements {\n-            let expr = match &stmt {\n-                ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n-                ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n-                ast::Stmt::Item(_) => continue,\n-            };\n-            if let Some(expr) = &expr {\n-                self.handle_exprs(expr, collect_break);\n-            }\n-        }\n-\n-        // Browse tail expressions for each block\n-        if let Some(expr) = block_expr.expr() {\n-            if let Some(last_exprs) = get_tail_expr_from_block(&expr) {\n-                for last_expr in last_exprs {\n-                    let last_expr = match last_expr {\n-                        NodeType::Node(expr) => expr,\n-                        NodeType::Leaf(expr) => expr.syntax().clone(),\n-                    };\n-\n-                    if let Some(last_expr) = Expr::cast(last_expr.clone()) {\n-                        self.handle_exprs(&last_expr, collect_break);\n-                    } else if let Some(expr_stmt) = ast::Stmt::cast(last_expr) {\n-                        let expr_stmt = match &expr_stmt {\n-                            ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n-                            ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n-                            ast::Stmt::Item(_) => None,\n-                        };\n-                        if let Some(expr) = &expr_stmt {\n-                            self.handle_exprs(expr, collect_break);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn handle_exprs(&mut self, expr: &Expr, collect_break: bool) {\n-        match expr {\n-            Expr::BlockExpr(block_expr) => {\n-                self.collect_jump_exprs(&block_expr, collect_break);\n-            }\n-            Expr::ReturnExpr(ret_expr) => {\n-                if let Some(ret_expr_arg) = &ret_expr.expr() {\n-                    self.exprs_to_wrap.push(ret_expr_arg.clone());\n-                }\n-            }\n-            Expr::BreakExpr(break_expr) if collect_break => {\n-                if let Some(break_expr_arg) = &break_expr.expr() {\n-                    self.exprs_to_wrap.push(break_expr_arg.clone());\n-                }\n-            }\n-            Expr::IfExpr(if_expr) => {\n-                for block in if_expr.blocks() {\n-                    self.collect_jump_exprs(&block, collect_break);\n-                }\n-            }\n-            Expr::LoopExpr(loop_expr) => {\n-                if let Some(block_expr) = loop_expr.loop_body() {\n-                    self.collect_jump_exprs(&block_expr, collect_break);\n-                }\n-            }\n-            Expr::ForExpr(for_expr) => {\n-                if let Some(block_expr) = for_expr.loop_body() {\n-                    self.collect_jump_exprs(&block_expr, collect_break);\n-                }\n-            }\n-            Expr::WhileExpr(while_expr) => {\n-                if let Some(block_expr) = while_expr.loop_body() {\n-                    self.collect_jump_exprs(&block_expr, collect_break);\n-                }\n-            }\n-            Expr::MatchExpr(match_expr) => {\n-                if let Some(arm_list) = match_expr.match_arm_list() {\n-                    arm_list.arms().filter_map(|match_arm| match_arm.expr()).for_each(|expr| {\n-                        self.handle_exprs(&expr, collect_break);\n-                    });\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn collect_tail_exprs(&mut self, block: &BlockExpr) {\n-        if let Some(expr) = block.expr() {\n-            self.handle_exprs(&expr, true);\n-            self.fetch_tail_exprs(&expr);\n-        }\n-    }\n-\n-    fn fetch_tail_exprs(&mut self, expr: &Expr) {\n-        if let Some(exprs) = get_tail_expr_from_block(expr) {\n-            for node_type in &exprs {\n-                match node_type {\n-                    NodeType::Leaf(expr) => {\n-                        self.exprs_to_wrap.push(expr.clone());\n-                    }\n-                    NodeType::Node(expr) => {\n-                        if let Some(last_expr) = Expr::cast(expr.clone()) {\n-                            self.fetch_tail_exprs(&last_expr);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-enum NodeType {\n-    Leaf(ast::Expr),\n-    Node(SyntaxNode),\n-}\n-\n-/// Get a tail expression inside a block\n-fn get_tail_expr_from_block(expr: &Expr) -> Option<Vec<NodeType>> {\n-    match expr {\n-        Expr::IfExpr(if_expr) => {\n-            let mut nodes = vec![];\n-            for block in if_expr.blocks() {\n-                if let Some(block_expr) = block.expr() {\n-                    if let Some(tail_exprs) = get_tail_expr_from_block(&block_expr) {\n-                        nodes.extend(tail_exprs);\n-                    }\n-                } else if let Some(last_expr) = block.syntax().last_child() {\n-                    nodes.push(NodeType::Node(last_expr));\n-                } else {\n-                    nodes.push(NodeType::Node(block.syntax().clone()));\n-                }\n-            }\n-            Some(nodes)\n-        }\n-        Expr::LoopExpr(loop_expr) => {\n-            loop_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n-        }\n-        Expr::ForExpr(for_expr) => {\n-            for_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n-        }\n-        Expr::WhileExpr(while_expr) => {\n-            while_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n-        }\n-        Expr::BlockExpr(block_expr) => {\n-            block_expr.expr().map(|lc| vec![NodeType::Node(lc.syntax().clone())])\n-        }\n-        Expr::MatchExpr(match_expr) => {\n-            let arm_list = match_expr.match_arm_list()?;\n-            let arms: Vec<NodeType> = arm_list\n-                .arms()\n-                .filter_map(|match_arm| match_arm.expr())\n-                .map(|expr| match expr {\n-                    Expr::ReturnExpr(ret_expr) => NodeType::Node(ret_expr.syntax().clone()),\n-                    Expr::BreakExpr(break_expr) => NodeType::Node(break_expr.syntax().clone()),\n-                    _ => match expr.syntax().last_child() {\n-                        Some(last_expr) => NodeType::Node(last_expr),\n-                        None => NodeType::Node(expr.syntax().clone()),\n-                    },\n-                })\n-                .collect();\n-\n-            Some(arms)\n-        }\n-        Expr::BreakExpr(expr) => expr.expr().map(|e| vec![NodeType::Leaf(e)]),\n-        Expr::ReturnExpr(ret_expr) => Some(vec![NodeType::Node(ret_expr.syntax().clone())]),\n-\n-        Expr::CallExpr(_)\n-        | Expr::Literal(_)\n-        | Expr::TupleExpr(_)\n-        | Expr::ArrayExpr(_)\n-        | Expr::ParenExpr(_)\n-        | Expr::PathExpr(_)\n-        | Expr::RecordExpr(_)\n-        | Expr::IndexExpr(_)\n-        | Expr::MethodCallExpr(_)\n-        | Expr::AwaitExpr(_)\n-        | Expr::CastExpr(_)\n-        | Expr::RefExpr(_)\n-        | Expr::PrefixExpr(_)\n-        | Expr::RangeExpr(_)\n-        | Expr::BinExpr(_)\n-        | Expr::MacroCall(_)\n-        | Expr::BoxExpr(_) => Some(vec![NodeType::Leaf(expr.clone())]),\n-        _ => None,\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::{check_assist, check_assist_not_applicable};\n-\n-    use super::*;\n-\n-    #[test]\n-    fn change_return_type_to_result_simple() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i3<|>2 {\n-                let test = \"test\";\n-                return 42i32;\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let test = \"test\";\n-                return Ok(42i32);\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_closure() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() {\n-                || -> i32<|> {\n-                    let test = \"test\";\n-                    return 42i32;\n-                };\n-            }\"#,\n-            r#\"fn foo() {\n-                || -> Result<i32, ${0:_}> {\n-                    let test = \"test\";\n-                    return Ok(42i32);\n-                };\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_return_type_bad_cursor() {\n-        check_assist_not_applicable(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32 {\n-                let test = \"test\";<|>\n-                return 42i32;\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_return_type_bad_cursor_closure() {\n-        check_assist_not_applicable(\n-            change_return_type_to_result,\n-            r#\"fn foo() {\n-                || -> i32 {\n-                    let test = \"test\";<|>\n-                    return 42i32;\n-                };\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_closure_non_block() {\n-        check_assist_not_applicable(\n-            change_return_type_to_result,\n-            r#\"fn foo() {\n-                || -> i<|>32 3;\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_return_type_already_result_std() {\n-        check_assist_not_applicable(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> std::result::Result<i32<|>, String> {\n-                let test = \"test\";\n-                return 42i32;\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_return_type_already_result() {\n-        mark::check!(change_return_type_to_result_simple_return_type_already_result);\n-        check_assist_not_applicable(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> Result<i32<|>, String> {\n-                let test = \"test\";\n-                return 42i32;\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_return_type_already_result_closure() {\n-        check_assist_not_applicable(\n-            change_return_type_to_result,\n-            r#\"fn foo() {\n-                || -> Result<i32<|>, String> {\n-                    let test = \"test\";\n-                    return 42i32;\n-                };\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_cursor() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> <|>i32 {\n-                let test = \"test\";\n-                return 42i32;\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let test = \"test\";\n-                return Ok(42i32);\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_tail() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -><|> i32 {\n-                let test = \"test\";\n-                42i32\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let test = \"test\";\n-                Ok(42i32)\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_tail_closure() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() {\n-                || -><|> i32 {\n-                    let test = \"test\";\n-                    42i32\n-                };\n-            }\"#,\n-            r#\"fn foo() {\n-                || -> Result<i32, ${0:_}> {\n-                    let test = \"test\";\n-                    Ok(42i32)\n-                };\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_tail_only() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32<|> {\n-                42i32\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                Ok(42i32)\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_tail_block_like() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32<|> {\n-                if true {\n-                    42i32\n-                } else {\n-                    24i32\n-                }\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                if true {\n-                    Ok(42i32)\n-                } else {\n-                    Ok(24i32)\n-                }\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_without_block_closure() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() {\n-                || -> i32<|> {\n-                    if true {\n-                        42i32\n-                    } else {\n-                        24i32\n-                    }\n-                };\n-            }\"#,\n-            r#\"fn foo() {\n-                || -> Result<i32, ${0:_}> {\n-                    if true {\n-                        Ok(42i32)\n-                    } else {\n-                        Ok(24i32)\n-                    }\n-                };\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_nested_if() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32<|> {\n-                if true {\n-                    if false {\n-                        1\n-                    } else {\n-                        2\n-                    }\n-                } else {\n-                    24i32\n-                }\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                if true {\n-                    if false {\n-                        Ok(1)\n-                    } else {\n-                        Ok(2)\n-                    }\n-                } else {\n-                    Ok(24i32)\n-                }\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_await() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"async fn foo() -> i<|>32 {\n-                if true {\n-                    if false {\n-                        1.await\n-                    } else {\n-                        2.await\n-                    }\n-                } else {\n-                    24i32.await\n-                }\n-            }\"#,\n-            r#\"async fn foo() -> Result<i32, ${0:_}> {\n-                if true {\n-                    if false {\n-                        Ok(1.await)\n-                    } else {\n-                        Ok(2.await)\n-                    }\n-                } else {\n-                    Ok(24i32.await)\n-                }\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_array() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> [i32;<|> 3] {\n-                [1, 2, 3]\n-            }\"#,\n-            r#\"fn foo() -> Result<[i32; 3], ${0:_}> {\n-                Ok([1, 2, 3])\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_cast() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -<|>> i32 {\n-                if true {\n-                    if false {\n-                        1 as i32\n-                    } else {\n-                        2 as i32\n-                    }\n-                } else {\n-                    24 as i32\n-                }\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                if true {\n-                    if false {\n-                        Ok(1 as i32)\n-                    } else {\n-                        Ok(2 as i32)\n-                    }\n-                } else {\n-                    Ok(24 as i32)\n-                }\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_tail_block_like_match() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32<|> {\n-                let my_var = 5;\n-                match my_var {\n-                    5 => 42i32,\n-                    _ => 24i32,\n-                }\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let my_var = 5;\n-                match my_var {\n-                    5 => Ok(42i32),\n-                    _ => Ok(24i32),\n-                }\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_loop_with_tail() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32<|> {\n-                let my_var = 5;\n-                loop {\n-                    println!(\"test\");\n-                    5\n-                }\n-\n-                my_var\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let my_var = 5;\n-                loop {\n-                    println!(\"test\");\n-                    5\n-                }\n-\n-                Ok(my_var)\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_loop_in_let_stmt() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32<|> {\n-                let my_var = let x = loop {\n-                    break 1;\n-                };\n-\n-                my_var\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let my_var = let x = loop {\n-                    break 1;\n-                };\n-\n-                Ok(my_var)\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_tail_block_like_match_return_expr() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32<|> {\n-                let my_var = 5;\n-                let res = match my_var {\n-                    5 => 42i32,\n-                    _ => return 24i32,\n-                };\n-\n-                res\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let my_var = 5;\n-                let res = match my_var {\n-                    5 => 42i32,\n-                    _ => return Ok(24i32),\n-                };\n-\n-                Ok(res)\n-            }\"#,\n-        );\n-\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32<|> {\n-                let my_var = 5;\n-                let res = if my_var == 5 {\n-                    42i32\n-                } else {\n-                    return 24i32;\n-                };\n-\n-                res\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let my_var = 5;\n-                let res = if my_var == 5 {\n-                    42i32\n-                } else {\n-                    return Ok(24i32);\n-                };\n-\n-                Ok(res)\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_tail_block_like_match_deeper() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32<|> {\n-                let my_var = 5;\n-                match my_var {\n-                    5 => {\n-                        if true {\n-                            42i32\n-                        } else {\n-                            25i32\n-                        }\n-                    },\n-                    _ => {\n-                        let test = \"test\";\n-                        if test == \"test\" {\n-                            return bar();\n-                        }\n-                        53i32\n-                    },\n-                }\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let my_var = 5;\n-                match my_var {\n-                    5 => {\n-                        if true {\n-                            Ok(42i32)\n-                        } else {\n-                            Ok(25i32)\n-                        }\n-                    },\n-                    _ => {\n-                        let test = \"test\";\n-                        if test == \"test\" {\n-                            return Ok(bar());\n-                        }\n-                        Ok(53i32)\n-                    },\n-                }\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_tail_block_like_early_return() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i<|>32 {\n-                let test = \"test\";\n-                if test == \"test\" {\n-                    return 24i32;\n-                }\n-                53i32\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let test = \"test\";\n-                if test == \"test\" {\n-                    return Ok(24i32);\n-                }\n-                Ok(53i32)\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_closure() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo(the_field: u32) -><|> u32 {\n-                let true_closure = || {\n-                    return true;\n-                };\n-                if the_field < 5 {\n-                    let mut i = 0;\n-\n-\n-                    if true_closure() {\n-                        return 99;\n-                    } else {\n-                        return 0;\n-                    }\n-                }\n-\n-                the_field\n-            }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n-                let true_closure = || {\n-                    return true;\n-                };\n-                if the_field < 5 {\n-                    let mut i = 0;\n-\n-\n-                    if true_closure() {\n-                        return Ok(99);\n-                    } else {\n-                        return Ok(0);\n-                    }\n-                }\n-\n-                Ok(the_field)\n-            }\"#,\n-        );\n-\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo(the_field: u32) -> u32<|> {\n-                let true_closure = || {\n-                    return true;\n-                };\n-                if the_field < 5 {\n-                    let mut i = 0;\n-\n-\n-                    if true_closure() {\n-                        return 99;\n-                    } else {\n-                        return 0;\n-                    }\n-                }\n-                let t = None;\n-\n-                t.unwrap_or_else(|| the_field)\n-            }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n-                let true_closure = || {\n-                    return true;\n-                };\n-                if the_field < 5 {\n-                    let mut i = 0;\n-\n-\n-                    if true_closure() {\n-                        return Ok(99);\n-                    } else {\n-                        return Ok(0);\n-                    }\n-                }\n-                let t = None;\n-\n-                Ok(t.unwrap_or_else(|| the_field))\n-            }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn change_return_type_to_result_simple_with_weird_forms() {\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32<|> {\n-                let test = \"test\";\n-                if test == \"test\" {\n-                    return 24i32;\n-                }\n-                let mut i = 0;\n-                loop {\n-                    if i == 1 {\n-                        break 55;\n-                    }\n-                    i += 1;\n-                }\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let test = \"test\";\n-                if test == \"test\" {\n-                    return Ok(24i32);\n-                }\n-                let mut i = 0;\n-                loop {\n-                    if i == 1 {\n-                        break Ok(55);\n-                    }\n-                    i += 1;\n-                }\n-            }\"#,\n-        );\n-\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i32<|> {\n-                let test = \"test\";\n-                if test == \"test\" {\n-                    return 24i32;\n-                }\n-                let mut i = 0;\n-                loop {\n-                    loop {\n-                        if i == 1 {\n-                            break 55;\n-                        }\n-                        i += 1;\n-                    }\n-                }\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let test = \"test\";\n-                if test == \"test\" {\n-                    return Ok(24i32);\n-                }\n-                let mut i = 0;\n-                loop {\n-                    loop {\n-                        if i == 1 {\n-                            break Ok(55);\n-                        }\n-                        i += 1;\n-                    }\n-                }\n-            }\"#,\n-        );\n-\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo() -> i3<|>2 {\n-                let test = \"test\";\n-                let other = 5;\n-                if test == \"test\" {\n-                    let res = match other {\n-                        5 => 43,\n-                        _ => return 56,\n-                    };\n-                }\n-                let mut i = 0;\n-                loop {\n-                    loop {\n-                        if i == 1 {\n-                            break 55;\n-                        }\n-                        i += 1;\n-                    }\n-                }\n-            }\"#,\n-            r#\"fn foo() -> Result<i32, ${0:_}> {\n-                let test = \"test\";\n-                let other = 5;\n-                if test == \"test\" {\n-                    let res = match other {\n-                        5 => 43,\n-                        _ => return Ok(56),\n-                    };\n-                }\n-                let mut i = 0;\n-                loop {\n-                    loop {\n-                        if i == 1 {\n-                            break Ok(55);\n-                        }\n-                        i += 1;\n-                    }\n-                }\n-            }\"#,\n-        );\n-\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo(the_field: u32) -> u32<|> {\n-                if the_field < 5 {\n-                    let mut i = 0;\n-                    loop {\n-                        if i > 5 {\n-                            return 55u32;\n-                        }\n-                        i += 3;\n-                    }\n-\n-                    match i {\n-                        5 => return 99,\n-                        _ => return 0,\n-                    };\n-                }\n-\n-                the_field\n-            }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n-                if the_field < 5 {\n-                    let mut i = 0;\n-                    loop {\n-                        if i > 5 {\n-                            return Ok(55u32);\n-                        }\n-                        i += 3;\n-                    }\n-\n-                    match i {\n-                        5 => return Ok(99),\n-                        _ => return Ok(0),\n-                    };\n-                }\n-\n-                Ok(the_field)\n-            }\"#,\n-        );\n-\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo(the_field: u32) -> u3<|>2 {\n-                if the_field < 5 {\n-                    let mut i = 0;\n-\n-                    match i {\n-                        5 => return 99,\n-                        _ => return 0,\n-                    }\n-                }\n-\n-                the_field\n-            }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n-                if the_field < 5 {\n-                    let mut i = 0;\n-\n-                    match i {\n-                        5 => return Ok(99),\n-                        _ => return Ok(0),\n-                    }\n-                }\n-\n-                Ok(the_field)\n-            }\"#,\n-        );\n-\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo(the_field: u32) -> u32<|> {\n-                if the_field < 5 {\n-                    let mut i = 0;\n-\n-                    if i == 5 {\n-                        return 99\n-                    } else {\n-                        return 0\n-                    }\n-                }\n-\n-                the_field\n-            }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n-                if the_field < 5 {\n-                    let mut i = 0;\n-\n-                    if i == 5 {\n-                        return Ok(99)\n-                    } else {\n-                        return Ok(0)\n-                    }\n-                }\n-\n-                Ok(the_field)\n-            }\"#,\n-        );\n-\n-        check_assist(\n-            change_return_type_to_result,\n-            r#\"fn foo(the_field: u32) -> <|>u32 {\n-                if the_field < 5 {\n-                    let mut i = 0;\n-\n-                    if i == 5 {\n-                        return 99;\n-                    } else {\n-                        return 0;\n-                    }\n-                }\n-\n-                the_field\n-            }\"#,\n-            r#\"fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n-                if the_field < 5 {\n-                    let mut i = 0;\n-\n-                    if i == 5 {\n-                        return Ok(99);\n-                    } else {\n-                        return Ok(0);\n-                    }\n-                }\n-\n-                Ok(the_field)\n-            }\"#,\n-        );\n-    }\n-}"}, {"sha": "82625516c211a2f05724867a7ab9dc67c98be44a", "filename": "crates/assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "renamed", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/73b08131dff8855c6736ce41867a6a197dfb87af/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b08131dff8855c6736ce41867a6a197dfb87af/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=73b08131dff8855c6736ce41867a6a197dfb87af", "patch": "@@ -16,24 +16,31 @@ use crate::{\n     AssistId, AssistKind,\n };\n \n-// Assist: add_custom_impl\n+// Assist: replace_derive_with_manual_impl\n //\n-// Adds impl block for derived trait.\n+// Converts a `derive` impl into a manual one.\n //\n // ```\n+// # trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }\n // #[derive(Deb<|>ug, Display)]\n // struct S;\n // ```\n // ->\n // ```\n+// # trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }\n // #[derive(Display)]\n // struct S;\n //\n // impl Debug for S {\n-//     $0\n+//     fn fmt(&self, f: &mut Formatter) -> Result<()> {\n+//         ${0:todo!()}\n+//     }\n // }\n // ```\n-pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn replace_derive_with_manual_impl(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n     let attr = ctx.find_node_at_offset::<ast::Attr>()?;\n \n     let attr_name = attr\n@@ -90,43 +97,49 @@ fn add_assist(\n ) -> Option<()> {\n     let target = attr.syntax().text_range();\n     let input = attr.token_tree()?;\n-    let label = format!(\"Add custom impl `{}` for `{}`\", trait_path, annotated_name);\n+    let label = format!(\"Convert to manual  `impl {} for {}`\", trait_path, annotated_name);\n     let trait_name = trait_path.segment().and_then(|seg| seg.name_ref())?;\n \n-    acc.add(AssistId(\"add_custom_impl\", AssistKind::Refactor), label, target, |builder| {\n-        let impl_def_with_items =\n-            impl_def_from_trait(&ctx.sema, annotated_name, trait_, trait_path);\n-        update_attribute(builder, &input, &trait_name, &attr);\n-        match (ctx.config.snippet_cap, impl_def_with_items) {\n-            (None, _) => builder.insert(\n-                insert_pos,\n-                format!(\"\\n\\nimpl {} for {} {{\\n\\n}}\", trait_path, annotated_name),\n-            ),\n-            (Some(cap), None) => builder.insert_snippet(\n-                cap,\n-                insert_pos,\n-                format!(\"\\n\\nimpl {} for {} {{\\n    $0\\n}}\", trait_path, annotated_name),\n-            ),\n-            (Some(cap), Some((impl_def, first_assoc_item))) => {\n-                let mut cursor = Cursor::Before(first_assoc_item.syntax());\n-                let placeholder;\n-                if let ast::AssocItem::Fn(ref func) = first_assoc_item {\n-                    if let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast) {\n-                        if m.syntax().text() == \"todo!()\" {\n-                            placeholder = m;\n-                            cursor = Cursor::Replace(placeholder.syntax());\n+    acc.add(\n+        AssistId(\"replace_derive_with_manual_impl\", AssistKind::Refactor),\n+        label,\n+        target,\n+        |builder| {\n+            let impl_def_with_items =\n+                impl_def_from_trait(&ctx.sema, annotated_name, trait_, trait_path);\n+            update_attribute(builder, &input, &trait_name, &attr);\n+            match (ctx.config.snippet_cap, impl_def_with_items) {\n+                (None, _) => builder.insert(\n+                    insert_pos,\n+                    format!(\"\\n\\nimpl {} for {} {{\\n\\n}}\", trait_path, annotated_name),\n+                ),\n+                (Some(cap), None) => builder.insert_snippet(\n+                    cap,\n+                    insert_pos,\n+                    format!(\"\\n\\nimpl {} for {} {{\\n    $0\\n}}\", trait_path, annotated_name),\n+                ),\n+                (Some(cap), Some((impl_def, first_assoc_item))) => {\n+                    let mut cursor = Cursor::Before(first_assoc_item.syntax());\n+                    let placeholder;\n+                    if let ast::AssocItem::Fn(ref func) = first_assoc_item {\n+                        if let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast)\n+                        {\n+                            if m.syntax().text() == \"todo!()\" {\n+                                placeholder = m;\n+                                cursor = Cursor::Replace(placeholder.syntax());\n+                            }\n                         }\n                     }\n-                }\n \n-                builder.insert_snippet(\n-                    cap,\n-                    insert_pos,\n-                    format!(\"\\n\\n{}\", render_snippet(cap, impl_def.syntax(), cursor)),\n-                )\n-            }\n-        };\n-    })\n+                    builder.insert_snippet(\n+                        cap,\n+                        insert_pos,\n+                        format!(\"\\n\\n{}\", render_snippet(cap, impl_def.syntax(), cursor)),\n+                    )\n+                }\n+            };\n+        },\n+    )\n }\n \n fn impl_def_from_trait(\n@@ -192,7 +205,7 @@ mod tests {\n     #[test]\n     fn add_custom_impl_debug() {\n         check_assist(\n-            add_custom_impl,\n+            replace_derive_with_manual_impl,\n             \"\n mod fmt {\n     pub struct Error;\n@@ -233,7 +246,7 @@ impl fmt::Debug for Foo {\n     #[test]\n     fn add_custom_impl_all() {\n         check_assist(\n-            add_custom_impl,\n+            replace_derive_with_manual_impl,\n             \"\n mod foo {\n     pub trait Bar {\n@@ -282,7 +295,7 @@ impl foo::Bar for Foo {\n     #[test]\n     fn add_custom_impl_for_unique_input() {\n         check_assist(\n-            add_custom_impl,\n+            replace_derive_with_manual_impl,\n             \"\n #[derive(Debu<|>g)]\n struct Foo {\n@@ -304,7 +317,7 @@ impl Debug for Foo {\n     #[test]\n     fn add_custom_impl_for_with_visibility_modifier() {\n         check_assist(\n-            add_custom_impl,\n+            replace_derive_with_manual_impl,\n             \"\n #[derive(Debug<|>)]\n pub struct Foo {\n@@ -326,7 +339,7 @@ impl Debug for Foo {\n     #[test]\n     fn add_custom_impl_when_multiple_inputs() {\n         check_assist(\n-            add_custom_impl,\n+            replace_derive_with_manual_impl,\n             \"\n #[derive(Display, Debug<|>, Serialize)]\n struct Foo {}\n@@ -345,7 +358,7 @@ impl Debug for Foo {\n     #[test]\n     fn test_ignore_derive_macro_without_input() {\n         check_assist_not_applicable(\n-            add_custom_impl,\n+            replace_derive_with_manual_impl,\n             \"\n #[derive(<|>)]\n struct Foo {}\n@@ -356,15 +369,15 @@ struct Foo {}\n     #[test]\n     fn test_ignore_if_cursor_on_param() {\n         check_assist_not_applicable(\n-            add_custom_impl,\n+            replace_derive_with_manual_impl,\n             \"\n #[derive<|>(Debug)]\n struct Foo {}\n             \",\n         );\n \n         check_assist_not_applicable(\n-            add_custom_impl,\n+            replace_derive_with_manual_impl,\n             \"\n #[derive(Debug)<|>]\n struct Foo {}\n@@ -375,7 +388,7 @@ struct Foo {}\n     #[test]\n     fn test_ignore_if_not_derive() {\n         check_assist_not_applicable(\n-            add_custom_impl,\n+            replace_derive_with_manual_impl,\n             \"\n #[allow(non_camel_<|>case_types)]\n struct Foo {}", "previous_filename": "crates/assists/src/handlers/add_custom_impl.rs"}, {"sha": "59e5debb13f9defc4696db2b95ddb1ae56e3f181", "filename": "crates/assists/src/handlers/wrap_return_type_in_result.rs", "status": "added", "additions": 1158, "deletions": 0, "changes": 1158, "blob_url": "https://github.com/rust-lang/rust/blob/73b08131dff8855c6736ce41867a6a197dfb87af/crates%2Fassists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b08131dff8855c6736ce41867a6a197dfb87af/crates%2Fassists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs?ref=73b08131dff8855c6736ce41867a6a197dfb87af", "patch": "@@ -0,0 +1,1158 @@\n+use std::iter;\n+\n+use syntax::{\n+    ast::{self, make, BlockExpr, Expr, LoopBodyOwner},\n+    match_ast, AstNode, SyntaxNode,\n+};\n+use test_utils::mark;\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: wrap_return_type_in_result\n+//\n+// Wrap the function's return type into Result.\n+//\n+// ```\n+// fn foo() -> i32<|> { 42i32 }\n+// ```\n+// ->\n+// ```\n+// fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n+// ```\n+pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let ret_type = ctx.find_node_at_offset::<ast::RetType>()?;\n+    let parent = ret_type.syntax().parent()?;\n+    let block_expr = match_ast! {\n+        match parent {\n+            ast::Fn(func) => func.body()?,\n+            ast::ClosureExpr(closure) => match closure.body()? {\n+                Expr::BlockExpr(block) => block,\n+                // closures require a block when a return type is specified\n+                _ => return None,\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    let type_ref = &ret_type.ty()?;\n+    let ret_type_str = type_ref.syntax().text().to_string();\n+    let first_part_ret_type = ret_type_str.splitn(2, '<').next();\n+    if let Some(ret_type_first_part) = first_part_ret_type {\n+        if ret_type_first_part.ends_with(\"Result\") {\n+            mark::hit!(wrap_return_type_in_result_simple_return_type_already_result);\n+            return None;\n+        }\n+    }\n+\n+    acc.add(\n+        AssistId(\"wrap_return_type_in_result\", AssistKind::RefactorRewrite),\n+        \"Wrap return type in Result\",\n+        type_ref.syntax().text_range(),\n+        |builder| {\n+            let mut tail_return_expr_collector = TailReturnCollector::new();\n+            tail_return_expr_collector.collect_jump_exprs(&block_expr, false);\n+            tail_return_expr_collector.collect_tail_exprs(&block_expr);\n+\n+            for ret_expr_arg in tail_return_expr_collector.exprs_to_wrap {\n+                let ok_wrapped = make::expr_call(\n+                    make::expr_path(make::path_unqualified(make::path_segment(make::name_ref(\n+                        \"Ok\",\n+                    )))),\n+                    make::arg_list(iter::once(ret_expr_arg.clone())),\n+                );\n+                builder.replace_ast(ret_expr_arg, ok_wrapped);\n+            }\n+\n+            match ctx.config.snippet_cap {\n+                Some(cap) => {\n+                    let snippet = format!(\"Result<{}, ${{0:_}}>\", type_ref);\n+                    builder.replace_snippet(cap, type_ref.syntax().text_range(), snippet)\n+                }\n+                None => builder\n+                    .replace(type_ref.syntax().text_range(), format!(\"Result<{}, _>\", type_ref)),\n+            }\n+        },\n+    )\n+}\n+\n+struct TailReturnCollector {\n+    exprs_to_wrap: Vec<ast::Expr>,\n+}\n+\n+impl TailReturnCollector {\n+    fn new() -> Self {\n+        Self { exprs_to_wrap: vec![] }\n+    }\n+    /// Collect all`return` expression\n+    fn collect_jump_exprs(&mut self, block_expr: &BlockExpr, collect_break: bool) {\n+        let statements = block_expr.statements();\n+        for stmt in statements {\n+            let expr = match &stmt {\n+                ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n+                ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+                ast::Stmt::Item(_) => continue,\n+            };\n+            if let Some(expr) = &expr {\n+                self.handle_exprs(expr, collect_break);\n+            }\n+        }\n+\n+        // Browse tail expressions for each block\n+        if let Some(expr) = block_expr.expr() {\n+            if let Some(last_exprs) = get_tail_expr_from_block(&expr) {\n+                for last_expr in last_exprs {\n+                    let last_expr = match last_expr {\n+                        NodeType::Node(expr) => expr,\n+                        NodeType::Leaf(expr) => expr.syntax().clone(),\n+                    };\n+\n+                    if let Some(last_expr) = Expr::cast(last_expr.clone()) {\n+                        self.handle_exprs(&last_expr, collect_break);\n+                    } else if let Some(expr_stmt) = ast::Stmt::cast(last_expr) {\n+                        let expr_stmt = match &expr_stmt {\n+                            ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n+                            ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+                            ast::Stmt::Item(_) => None,\n+                        };\n+                        if let Some(expr) = &expr_stmt {\n+                            self.handle_exprs(expr, collect_break);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn handle_exprs(&mut self, expr: &Expr, collect_break: bool) {\n+        match expr {\n+            Expr::BlockExpr(block_expr) => {\n+                self.collect_jump_exprs(&block_expr, collect_break);\n+            }\n+            Expr::ReturnExpr(ret_expr) => {\n+                if let Some(ret_expr_arg) = &ret_expr.expr() {\n+                    self.exprs_to_wrap.push(ret_expr_arg.clone());\n+                }\n+            }\n+            Expr::BreakExpr(break_expr) if collect_break => {\n+                if let Some(break_expr_arg) = &break_expr.expr() {\n+                    self.exprs_to_wrap.push(break_expr_arg.clone());\n+                }\n+            }\n+            Expr::IfExpr(if_expr) => {\n+                for block in if_expr.blocks() {\n+                    self.collect_jump_exprs(&block, collect_break);\n+                }\n+            }\n+            Expr::LoopExpr(loop_expr) => {\n+                if let Some(block_expr) = loop_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::ForExpr(for_expr) => {\n+                if let Some(block_expr) = for_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::WhileExpr(while_expr) => {\n+                if let Some(block_expr) = while_expr.loop_body() {\n+                    self.collect_jump_exprs(&block_expr, collect_break);\n+                }\n+            }\n+            Expr::MatchExpr(match_expr) => {\n+                if let Some(arm_list) = match_expr.match_arm_list() {\n+                    arm_list.arms().filter_map(|match_arm| match_arm.expr()).for_each(|expr| {\n+                        self.handle_exprs(&expr, collect_break);\n+                    });\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn collect_tail_exprs(&mut self, block: &BlockExpr) {\n+        if let Some(expr) = block.expr() {\n+            self.handle_exprs(&expr, true);\n+            self.fetch_tail_exprs(&expr);\n+        }\n+    }\n+\n+    fn fetch_tail_exprs(&mut self, expr: &Expr) {\n+        if let Some(exprs) = get_tail_expr_from_block(expr) {\n+            for node_type in &exprs {\n+                match node_type {\n+                    NodeType::Leaf(expr) => {\n+                        self.exprs_to_wrap.push(expr.clone());\n+                    }\n+                    NodeType::Node(expr) => {\n+                        if let Some(last_expr) = Expr::cast(expr.clone()) {\n+                            self.fetch_tail_exprs(&last_expr);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum NodeType {\n+    Leaf(ast::Expr),\n+    Node(SyntaxNode),\n+}\n+\n+/// Get a tail expression inside a block\n+fn get_tail_expr_from_block(expr: &Expr) -> Option<Vec<NodeType>> {\n+    match expr {\n+        Expr::IfExpr(if_expr) => {\n+            let mut nodes = vec![];\n+            for block in if_expr.blocks() {\n+                if let Some(block_expr) = block.expr() {\n+                    if let Some(tail_exprs) = get_tail_expr_from_block(&block_expr) {\n+                        nodes.extend(tail_exprs);\n+                    }\n+                } else if let Some(last_expr) = block.syntax().last_child() {\n+                    nodes.push(NodeType::Node(last_expr));\n+                } else {\n+                    nodes.push(NodeType::Node(block.syntax().clone()));\n+                }\n+            }\n+            Some(nodes)\n+        }\n+        Expr::LoopExpr(loop_expr) => {\n+            loop_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::ForExpr(for_expr) => {\n+            for_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::WhileExpr(while_expr) => {\n+            while_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n+        }\n+        Expr::BlockExpr(block_expr) => {\n+            block_expr.expr().map(|lc| vec![NodeType::Node(lc.syntax().clone())])\n+        }\n+        Expr::MatchExpr(match_expr) => {\n+            let arm_list = match_expr.match_arm_list()?;\n+            let arms: Vec<NodeType> = arm_list\n+                .arms()\n+                .filter_map(|match_arm| match_arm.expr())\n+                .map(|expr| match expr {\n+                    Expr::ReturnExpr(ret_expr) => NodeType::Node(ret_expr.syntax().clone()),\n+                    Expr::BreakExpr(break_expr) => NodeType::Node(break_expr.syntax().clone()),\n+                    _ => match expr.syntax().last_child() {\n+                        Some(last_expr) => NodeType::Node(last_expr),\n+                        None => NodeType::Node(expr.syntax().clone()),\n+                    },\n+                })\n+                .collect();\n+\n+            Some(arms)\n+        }\n+        Expr::BreakExpr(expr) => expr.expr().map(|e| vec![NodeType::Leaf(e)]),\n+        Expr::ReturnExpr(ret_expr) => Some(vec![NodeType::Node(ret_expr.syntax().clone())]),\n+\n+        Expr::CallExpr(_)\n+        | Expr::Literal(_)\n+        | Expr::TupleExpr(_)\n+        | Expr::ArrayExpr(_)\n+        | Expr::ParenExpr(_)\n+        | Expr::PathExpr(_)\n+        | Expr::RecordExpr(_)\n+        | Expr::IndexExpr(_)\n+        | Expr::MethodCallExpr(_)\n+        | Expr::AwaitExpr(_)\n+        | Expr::CastExpr(_)\n+        | Expr::RefExpr(_)\n+        | Expr::PrefixExpr(_)\n+        | Expr::RangeExpr(_)\n+        | Expr::BinExpr(_)\n+        | Expr::MacroCall(_)\n+        | Expr::BoxExpr(_) => Some(vec![NodeType::Leaf(expr.clone())]),\n+        _ => None,\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i3<|>2 {\n+    let test = \"test\";\n+    return 42i32;\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let test = \"test\";\n+    return Ok(42i32);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_closure() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() {\n+    || -> i32<|> {\n+        let test = \"test\";\n+        return 42i32;\n+    };\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    || -> Result<i32, ${0:_}> {\n+        let test = \"test\";\n+        return Ok(42i32);\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_return_type_bad_cursor() {\n+        check_assist_not_applicable(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i32 {\n+    let test = \"test\";<|>\n+    return 42i32;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_return_type_bad_cursor_closure() {\n+        check_assist_not_applicable(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() {\n+    || -> i32 {\n+        let test = \"test\";<|>\n+        return 42i32;\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_closure_non_block() {\n+        check_assist_not_applicable(wrap_return_type_in_result, r#\"fn foo() { || -> i<|>32 3; }\"#);\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_return_type_already_result_std() {\n+        check_assist_not_applicable(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> std::result::Result<i32<|>, String> {\n+    let test = \"test\";\n+    return 42i32;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_return_type_already_result() {\n+        mark::check!(wrap_return_type_in_result_simple_return_type_already_result);\n+        check_assist_not_applicable(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> Result<i32<|>, String> {\n+    let test = \"test\";\n+    return 42i32;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_return_type_already_result_closure() {\n+        check_assist_not_applicable(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() {\n+    || -> Result<i32<|>, String> {\n+        let test = \"test\";\n+        return 42i32;\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_cursor() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> <|>i32 {\n+    let test = \"test\";\n+    return 42i32;\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let test = \"test\";\n+    return Ok(42i32);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_tail() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -><|> i32 {\n+    let test = \"test\";\n+    42i32\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let test = \"test\";\n+    Ok(42i32)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_tail_closure() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() {\n+    || -><|> i32 {\n+        let test = \"test\";\n+        42i32\n+    };\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    || -> Result<i32, ${0:_}> {\n+        let test = \"test\";\n+        Ok(42i32)\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_tail_only() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"fn foo() -> i32<|> { 42i32 }\"#,\n+            r#\"fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_tail_block_like() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i32<|> {\n+    if true {\n+        42i32\n+    } else {\n+        24i32\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    if true {\n+        Ok(42i32)\n+    } else {\n+        Ok(24i32)\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_without_block_closure() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() {\n+    || -> i32<|> {\n+        if true {\n+            42i32\n+        } else {\n+            24i32\n+        }\n+    };\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    || -> Result<i32, ${0:_}> {\n+        if true {\n+            Ok(42i32)\n+        } else {\n+            Ok(24i32)\n+        }\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_nested_if() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i32<|> {\n+    if true {\n+        if false {\n+            1\n+        } else {\n+            2\n+        }\n+    } else {\n+        24i32\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    if true {\n+        if false {\n+            Ok(1)\n+        } else {\n+            Ok(2)\n+        }\n+    } else {\n+        Ok(24i32)\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_await() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+async fn foo() -> i<|>32 {\n+    if true {\n+        if false {\n+            1.await\n+        } else {\n+            2.await\n+        }\n+    } else {\n+        24i32.await\n+    }\n+}\n+\"#,\n+            r#\"\n+async fn foo() -> Result<i32, ${0:_}> {\n+    if true {\n+        if false {\n+            Ok(1.await)\n+        } else {\n+            Ok(2.await)\n+        }\n+    } else {\n+        Ok(24i32.await)\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_array() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"fn foo() -> [i32;<|> 3] { [1, 2, 3] }\"#,\n+            r#\"fn foo() -> Result<[i32; 3], ${0:_}> { Ok([1, 2, 3]) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_cast() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -<|>> i32 {\n+    if true {\n+        if false {\n+            1 as i32\n+        } else {\n+            2 as i32\n+        }\n+    } else {\n+        24 as i32\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    if true {\n+        if false {\n+            Ok(1 as i32)\n+        } else {\n+            Ok(2 as i32)\n+        }\n+    } else {\n+        Ok(24 as i32)\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_tail_block_like_match() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i32<|> {\n+    let my_var = 5;\n+    match my_var {\n+        5 => 42i32,\n+        _ => 24i32,\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let my_var = 5;\n+    match my_var {\n+        5 => Ok(42i32),\n+        _ => Ok(24i32),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_loop_with_tail() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i32<|> {\n+    let my_var = 5;\n+    loop {\n+        println!(\"test\");\n+        5\n+    }\n+    my_var\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let my_var = 5;\n+    loop {\n+        println!(\"test\");\n+        5\n+    }\n+    Ok(my_var)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_loop_in_let_stmt() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i32<|> {\n+    let my_var = let x = loop {\n+        break 1;\n+    };\n+    my_var\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let my_var = let x = loop {\n+        break 1;\n+    };\n+    Ok(my_var)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_tail_block_like_match_return_expr() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i32<|> {\n+    let my_var = 5;\n+    let res = match my_var {\n+        5 => 42i32,\n+        _ => return 24i32,\n+    };\n+    res\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let my_var = 5;\n+    let res = match my_var {\n+        5 => 42i32,\n+        _ => return Ok(24i32),\n+    };\n+    Ok(res)\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i32<|> {\n+    let my_var = 5;\n+    let res = if my_var == 5 {\n+        42i32\n+    } else {\n+        return 24i32;\n+    };\n+    res\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let my_var = 5;\n+    let res = if my_var == 5 {\n+        42i32\n+    } else {\n+        return Ok(24i32);\n+    };\n+    Ok(res)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_tail_block_like_match_deeper() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i32<|> {\n+    let my_var = 5;\n+    match my_var {\n+        5 => {\n+            if true {\n+                42i32\n+            } else {\n+                25i32\n+            }\n+        },\n+        _ => {\n+            let test = \"test\";\n+            if test == \"test\" {\n+                return bar();\n+            }\n+            53i32\n+        },\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let my_var = 5;\n+    match my_var {\n+        5 => {\n+            if true {\n+                Ok(42i32)\n+            } else {\n+                Ok(25i32)\n+            }\n+        },\n+        _ => {\n+            let test = \"test\";\n+            if test == \"test\" {\n+                return Ok(bar());\n+            }\n+            Ok(53i32)\n+        },\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_tail_block_like_early_return() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i<|>32 {\n+    let test = \"test\";\n+    if test == \"test\" {\n+        return 24i32;\n+    }\n+    53i32\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let test = \"test\";\n+    if test == \"test\" {\n+        return Ok(24i32);\n+    }\n+    Ok(53i32)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_closure() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo(the_field: u32) -><|> u32 {\n+    let true_closure = || { return true; };\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if true_closure() {\n+            return 99;\n+        } else {\n+            return 0;\n+        }\n+    }\n+    the_field\n+}\n+\"#,\n+            r#\"\n+fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+    let true_closure = || { return true; };\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if true_closure() {\n+            return Ok(99);\n+        } else {\n+            return Ok(0);\n+        }\n+    }\n+    Ok(the_field)\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+            fn foo(the_field: u32) -> u32<|> {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return 99;\n+                    } else {\n+                        return 0;\n+                    }\n+                }\n+                let t = None;\n+\n+                t.unwrap_or_else(|| the_field)\n+            }\n+            \"#,\n+            r#\"\n+            fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+                let true_closure = || {\n+                    return true;\n+                };\n+                if the_field < 5 {\n+                    let mut i = 0;\n+\n+\n+                    if true_closure() {\n+                        return Ok(99);\n+                    } else {\n+                        return Ok(0);\n+                    }\n+                }\n+                let t = None;\n+\n+                Ok(t.unwrap_or_else(|| the_field))\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn wrap_return_type_in_result_simple_with_weird_forms() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i32<|> {\n+    let test = \"test\";\n+    if test == \"test\" {\n+        return 24i32;\n+    }\n+    let mut i = 0;\n+    loop {\n+        if i == 1 {\n+            break 55;\n+        }\n+        i += 1;\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let test = \"test\";\n+    if test == \"test\" {\n+        return Ok(24i32);\n+    }\n+    let mut i = 0;\n+    loop {\n+        if i == 1 {\n+            break Ok(55);\n+        }\n+        i += 1;\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i32<|> {\n+    let test = \"test\";\n+    if test == \"test\" {\n+        return 24i32;\n+    }\n+    let mut i = 0;\n+    loop {\n+        loop {\n+            if i == 1 {\n+                break 55;\n+            }\n+            i += 1;\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let test = \"test\";\n+    if test == \"test\" {\n+        return Ok(24i32);\n+    }\n+    let mut i = 0;\n+    loop {\n+        loop {\n+            if i == 1 {\n+                break Ok(55);\n+            }\n+            i += 1;\n+        }\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i3<|>2 {\n+    let test = \"test\";\n+    let other = 5;\n+    if test == \"test\" {\n+        let res = match other {\n+            5 => 43,\n+            _ => return 56,\n+        };\n+    }\n+    let mut i = 0;\n+    loop {\n+        loop {\n+            if i == 1 {\n+                break 55;\n+            }\n+            i += 1;\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    let test = \"test\";\n+    let other = 5;\n+    if test == \"test\" {\n+        let res = match other {\n+            5 => 43,\n+            _ => return Ok(56),\n+        };\n+    }\n+    let mut i = 0;\n+    loop {\n+        loop {\n+            if i == 1 {\n+                break Ok(55);\n+            }\n+            i += 1;\n+        }\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo(the_field: u32) -> u32<|> {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        loop {\n+            if i > 5 {\n+                return 55u32;\n+            }\n+            i += 3;\n+        }\n+        match i {\n+            5 => return 99,\n+            _ => return 0,\n+        };\n+    }\n+    the_field\n+}\n+\"#,\n+            r#\"\n+fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        loop {\n+            if i > 5 {\n+                return Ok(55u32);\n+            }\n+            i += 3;\n+        }\n+        match i {\n+            5 => return Ok(99),\n+            _ => return Ok(0),\n+        };\n+    }\n+    Ok(the_field)\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo(the_field: u32) -> u3<|>2 {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        match i {\n+            5 => return 99,\n+            _ => return 0,\n+        }\n+    }\n+    the_field\n+}\n+\"#,\n+            r#\"\n+fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        match i {\n+            5 => return Ok(99),\n+            _ => return Ok(0),\n+        }\n+    }\n+    Ok(the_field)\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo(the_field: u32) -> u32<|> {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if i == 5 {\n+            return 99\n+        } else {\n+            return 0\n+        }\n+    }\n+    the_field\n+}\n+\"#,\n+            r#\"\n+fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if i == 5 {\n+            return Ok(99)\n+        } else {\n+            return Ok(0)\n+        }\n+    }\n+    Ok(the_field)\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo(the_field: u32) -> <|>u32 {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if i == 5 {\n+            return 99;\n+        } else {\n+            return 0;\n+        }\n+    }\n+    the_field\n+}\n+\"#,\n+            r#\"\n+fn foo(the_field: u32) -> Result<u32, ${0:_}> {\n+    if the_field < 5 {\n+        let mut i = 0;\n+        if i == 5 {\n+            return Ok(99);\n+        } else {\n+            return Ok(0);\n+        }\n+    }\n+    Ok(the_field)\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "e8d81b33d76e833428d9c2215596192142466180", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73b08131dff8855c6736ce41867a6a197dfb87af/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b08131dff8855c6736ce41867a6a197dfb87af/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=73b08131dff8855c6736ce41867a6a197dfb87af", "patch": "@@ -120,13 +120,11 @@ mod handlers {\n \n     pub(crate) type Handler = fn(&mut Assists, &AssistContext) -> Option<()>;\n \n-    mod add_custom_impl;\n     mod add_explicit_type;\n     mod add_missing_impl_members;\n     mod add_turbo_fish;\n     mod apply_demorgan;\n     mod auto_import;\n-    mod change_return_type_to_result;\n     mod change_visibility;\n     mod convert_integer_literal;\n     mod early_return;\n@@ -157,6 +155,7 @@ mod handlers {\n     mod remove_mut;\n     mod remove_unused_param;\n     mod reorder_fields;\n+    mod replace_derive_with_manual_impl;\n     mod replace_if_let_with_match;\n     mod replace_impl_trait_with_generic;\n     mod replace_let_with_if_let;\n@@ -165,16 +164,15 @@ mod handlers {\n     mod replace_unwrap_with_match;\n     mod split_import;\n     mod unwrap_block;\n+    mod wrap_return_type_in_result;\n \n     pub(crate) fn all() -> &'static [Handler] {\n         &[\n             // These are alphabetic for the foolish consistency\n-            add_custom_impl::add_custom_impl,\n             add_explicit_type::add_explicit_type,\n             add_turbo_fish::add_turbo_fish,\n             apply_demorgan::apply_demorgan,\n             auto_import::auto_import,\n-            change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n             convert_integer_literal::convert_integer_literal,\n             early_return::convert_to_guarded_return,\n@@ -208,13 +206,15 @@ mod handlers {\n             remove_mut::remove_mut,\n             remove_unused_param::remove_unused_param,\n             reorder_fields::reorder_fields,\n+            replace_derive_with_manual_impl::replace_derive_with_manual_impl,\n             replace_if_let_with_match::replace_if_let_with_match,\n             replace_impl_trait_with_generic::replace_impl_trait_with_generic,\n             replace_let_with_if_let::replace_let_with_if_let,\n             replace_qualified_name_with_use::replace_qualified_name_with_use,\n             replace_unwrap_with_match::replace_unwrap_with_match,\n             split_import::split_import,\n             unwrap_block::unwrap_block,\n+            wrap_return_type_in_result::wrap_return_type_in_result,\n             // These are manually sorted for better priorities\n             add_missing_impl_members::add_missing_impl_members,\n             add_missing_impl_members::add_missing_default_members,"}, {"sha": "dbf4f21aa55e7da160b29e81ec3a4b44f6b0c036", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/73b08131dff8855c6736ce41867a6a197dfb87af/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b08131dff8855c6736ce41867a6a197dfb87af/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=73b08131dff8855c6736ce41867a6a197dfb87af", "patch": "@@ -2,25 +2,6 @@\n \n use super::check_doc_test;\n \n-#[test]\n-fn doctest_add_custom_impl() {\n-    check_doc_test(\n-        \"add_custom_impl\",\n-        r#####\"\n-#[derive(Deb<|>ug, Display)]\n-struct S;\n-\"#####,\n-        r#####\"\n-#[derive(Display)]\n-struct S;\n-\n-impl Debug for S {\n-    $0\n-}\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_add_explicit_type() {\n     check_doc_test(\n@@ -177,19 +158,6 @@ pub mod std { pub mod collections { pub struct HashMap { } } }\n     )\n }\n \n-#[test]\n-fn doctest_change_return_type_to_result() {\n-    check_doc_test(\n-        \"change_return_type_to_result\",\n-        r#####\"\n-fn foo() -> i32<|> { 42i32 }\n-\"#####,\n-        r#####\"\n-fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_change_visibility() {\n     check_doc_test(\n@@ -831,6 +799,29 @@ const test: Foo = Foo {foo: 1, bar: 0}\n     )\n }\n \n+#[test]\n+fn doctest_replace_derive_with_manual_impl() {\n+    check_doc_test(\n+        \"replace_derive_with_manual_impl\",\n+        r#####\"\n+trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }\n+#[derive(Deb<|>ug, Display)]\n+struct S;\n+\"#####,\n+        r#####\"\n+trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }\n+#[derive(Display)]\n+struct S;\n+\n+impl Debug for S {\n+    fn fmt(&self, f: &mut Formatter) -> Result<()> {\n+        ${0:todo!()}\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_replace_if_let_with_match() {\n     check_doc_test(\n@@ -985,3 +976,16 @@ fn foo() {\n \"#####,\n     )\n }\n+\n+#[test]\n+fn doctest_wrap_return_type_in_result() {\n+    check_doc_test(\n+        \"wrap_return_type_in_result\",\n+        r#####\"\n+fn foo() -> i32<|> { 42i32 }\n+\"#####,\n+        r#####\"\n+fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n+\"#####,\n+    )\n+}"}, {"sha": "99652e76b64658577d25a8677f3041a41ce19c05", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73b08131dff8855c6736ce41867a6a197dfb87af/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b08131dff8855c6736ce41867a6a197dfb87af/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=73b08131dff8855c6736ce41867a6a197dfb87af", "patch": "@@ -214,9 +214,6 @@ fn check_todo(path: &Path, text: &str) {\n         // This file itself obviously needs to use todo (<- like this!).\n         \"tests/cli.rs\",\n         // Some of our assists generate `todo!()`.\n-        \"tests/generated.rs\",\n-        \"handlers/add_custom_impl.rs\",\n-        \"handlers/add_missing_impl_members.rs\",\n         \"handlers/add_turbo_fish.rs\",\n         \"handlers/generate_function.rs\",\n         // To support generating `todo!()` in assists, we have `expr_todo()` in\n@@ -229,6 +226,11 @@ fn check_todo(path: &Path, text: &str) {\n         return;\n     }\n     if text.contains(\"TODO\") || text.contains(\"TOOD\") || text.contains(\"todo!\") {\n+        // Generated by an assist\n+        if text.contains(\"${0:todo!()}\") {\n+            return;\n+        }\n+\n         panic!(\n             \"\\nTODO markers or todo! macros should not be committed to the master branch,\\n\\\n              use FIXME instead\\n\\"}]}