{"sha": "e57b6775c3a2d9dbe7fae69c189b8ae9032315cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1N2I2Nzc1YzNhMmQ5ZGJlN2ZhZTY5YzE4OWI4YWU5MDMyMzE1Y2I=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-22T10:16:25Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-22T10:16:25Z"}, "message": "Clean up small things in syntax submodules", "tree": {"sha": "6f07cb4bd6ce573cadbdc89ac559c95c729b366f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f07cb4bd6ce573cadbdc89ac559c95c729b366f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb", "html_url": "https://github.com/rust-lang/rust/commit/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40cd1a7c455afc55be01a988ae0c55f3d07fbcf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/40cd1a7c455afc55be01a988ae0c55f3d07fbcf5", "html_url": "https://github.com/rust-lang/rust/commit/40cd1a7c455afc55be01a988ae0c55f3d07fbcf5"}], "stats": {"total": 78, "additions": 27, "deletions": 51}, "files": [{"sha": "1baf5f97d20b82ea9912a27ac3274ce1c060c930", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=e57b6775c3a2d9dbe7fae69c189b8ae9032315cb", "patch": "@@ -459,7 +459,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n               }\n             }\n           }\n-          /* TODO: handle embedded types and blocks, at least */\n+          /* FIXME: handle embedded types and blocks, at least */\n           expr_mac(mac) {\n             p_t_s_r_mac(cx, mac, s, b);\n           }"}, {"sha": "a6f56b611d7b68f84759fbeb0fda220db2ab529f", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=e57b6775c3a2d9dbe7fae69c189b8ae9032315cb", "patch": "@@ -1581,7 +1581,7 @@ fn parse_local(p: parser, allow_init: bool) -> @ast::local {\n \n fn parse_let(p: parser) -> @ast::decl {\n     if eat_word(p, \"mut\") {\n-        /* TODO */\n+        /* FIXME */\n     }\n     let lo = p.span.lo;\n     let locals = [parse_local(p, true)];\n@@ -2027,7 +2027,7 @@ enum class_contents { ctor_decl(ast::fn_decl, ast::blk),\n         let body = parse_block(p);\n         ret ctor_decl(decl, body);\n     }\n-    // TODO: refactor\n+    // FIXME: refactor\n     else if eat_word(p, \"priv\") {\n             expect(p, token::LBRACE);\n             let results = [];"}, {"sha": "2b29bf57eaa10cef5a98f77ce1e0db41c21ee257", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 24, "deletions": 48, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=e57b6775c3a2d9dbe7fae69c189b8ae9032315cb", "patch": "@@ -8,7 +8,6 @@ import pp::{break_offset, word, printer,\n import driver::diagnostic;\n \n // The ps is stored here to prevent recursive type.\n-// FIXME use a nominal enum instead\n enum ann_node {\n     node_block(ps, ast::blk),\n     node_item(ps, @ast::item),\n@@ -357,7 +356,7 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n       ast::ty_constr(t, cs) {\n         print_type(s, t);\n         space(s.s);\n-        word(s.s, ast_ty_constrs_str(cs));\n+        word(s.s, constrs_str(cs, ty_constr_to_str));\n       }\n       ast::ty_mac(_) {\n           fail \"print_type doesn't know how to print a ty_mac\";\n@@ -482,7 +481,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n           print_block(s, ctor_body);\n           for ci in items {\n                   /*\n-                     TODO: collect all private items and print them\n+                     FIXME: collect all private items and print them\n                      in a single \"priv\" section\n                    */\n              hardbreak_if_not_bol(s);\n@@ -1249,7 +1248,10 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl) {\n     }\n     commasep(s, inconsistent, decl.inputs, print_arg);\n     pclose(s);\n-    word(s.s, ast_fn_constrs_str(decl, decl.constraints));\n+    word(s.s, constrs_str(decl.constraints, {|c|\n+        ast_fn_constr_to_str(decl, c)\n+    }));\n+\n     maybe_print_comment(s, decl.output.span.lo);\n     if decl.output.node != ast::ty_nil {\n         space_if_not_bol(s);\n@@ -1479,7 +1481,7 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n         else { print_type(s, decl.output); }\n         end(s);\n     }\n-    word(s.s, ast_ty_fn_constrs_str(decl.constraints));\n+    word(s.s, constrs_str(decl.constraints, ast_ty_fn_constr_to_str));\n     end(s);\n }\n \n@@ -1684,8 +1686,6 @@ fn next_comment(s: ps) -> option<lexer::cmnt> {\n     }\n }\n \n-// Removing the aliases from the type of f in the next two functions\n-// triggers memory corruption, but I haven't isolated the bug yet. FIXME\n fn constr_args_to_str<T>(f: fn@(T) -> str, args: [@ast::sp_constr_arg<T>]) ->\n    str {\n     let comma = false;\n@@ -1712,43 +1712,38 @@ fn constr_arg_to_str<T>(f: fn@(T) -> str, c: ast::constr_arg_general_<T>) ->\n // (argh)\n fn uint_to_str(&&i: uint) -> str { ret uint::str(i); }\n \n-fn ast_ty_fn_constr_to_str(c: @ast::constr) -> str {\n+fn ast_ty_fn_constr_to_str(&&c: @ast::constr) -> str {\n     ret path_to_str(c.node.path) +\n             constr_args_to_str(uint_to_str, c.node.args);\n }\n \n-// FIXME: fix repeated code\n-fn ast_ty_fn_constrs_str(constrs: [@ast::constr]) -> str {\n-    let s = \"\";\n-    let colon = true;\n-    for c: @ast::constr in constrs {\n-        if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n-        s += ast_ty_fn_constr_to_str(c);\n-    }\n-    ret s;\n+fn ast_fn_constr_to_str(decl: ast::fn_decl, &&c: @ast::constr) -> str {\n+    let arg_to_str = bind fn_arg_idx_to_str(decl, _);\n+    ret path_to_str(c.node.path) +\n+            constr_args_to_str(arg_to_str, c.node.args);\n }\n \n-fn fn_arg_idx_to_str(decl: ast::fn_decl, &&idx: uint) -> str {\n-    decl.inputs[idx].ident\n-}\n+fn ty_constr_to_str(&&c: @ast::ty_constr) -> str {\n+    fn ty_constr_path_to_str(&&p: @ast::path) -> str { \"*.\" + path_to_str(p) }\n \n-fn ast_fn_constr_to_str(decl: ast::fn_decl, c: @ast::constr) -> str {\n-    let arg_to_str = bind fn_arg_idx_to_str(decl, _);\n     ret path_to_str(c.node.path) +\n-            constr_args_to_str(arg_to_str, c.node.args);\n+            constr_args_to_str::<@ast::path>(ty_constr_path_to_str,\n+                                             c.node.args);\n }\n \n-// FIXME: fix repeated code\n-fn ast_fn_constrs_str(decl: ast::fn_decl, constrs: [@ast::constr]) -> str {\n-    let s = \"\";\n-    let colon = true;\n-    for c: @ast::constr in constrs {\n+fn constrs_str<T>(constrs: [T], elt: fn(T) -> str) -> str {\n+    let s = \"\", colon = true;\n+    for c in constrs {\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n-        s += ast_fn_constr_to_str(decl, c);\n+        s += elt(c);\n     }\n     ret s;\n }\n \n+fn fn_arg_idx_to_str(decl: ast::fn_decl, &&idx: uint) -> str {\n+    decl.inputs[idx].ident\n+}\n+\n fn opt_proto_to_str(opt_p: option<ast::proto>) -> str {\n     alt opt_p {\n       none { \"fn\" }\n@@ -1766,25 +1761,6 @@ fn proto_to_str(p: ast::proto) -> str {\n     };\n }\n \n-fn ty_constr_to_str(c: @ast::ty_constr) -> str {\n-    fn ty_constr_path_to_str(&&p: @ast::path) -> str { \"*.\" + path_to_str(p) }\n-\n-    ret path_to_str(c.node.path) +\n-            constr_args_to_str::<@ast::path>(ty_constr_path_to_str,\n-                                             c.node.args);\n-}\n-\n-\n-fn ast_ty_constrs_str(constrs: [@ast::ty_constr]) -> str {\n-    let s = \"\";\n-    let colon = true;\n-    for c: @ast::ty_constr in constrs {\n-        if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n-        s += ty_constr_to_str(c);\n-    }\n-    ret s;\n-}\n-\n fn ends_in_lit_int(ex: @ast::expr) -> bool {\n     alt ex.node {\n       ast::expr_lit(@{node: ast::lit_int(_, ast::ty_i), _}) { true }"}]}