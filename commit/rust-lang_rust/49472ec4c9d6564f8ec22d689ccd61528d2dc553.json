{"sha": "49472ec4c9d6564f8ec22d689ccd61528d2dc553", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NDcyZWM0YzlkNjU2NGY4ZWMyMmQ2ODljY2Q2MTUyOGQyZGM1NTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-31T01:20:02Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-31T02:11:43Z"}, "message": "librustc: Remove legacy exports from the language. r=brson", "tree": {"sha": "421550a9d42763d2dceda339dedaf906f2ede3a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/421550a9d42763d2dceda339dedaf906f2ede3a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49472ec4c9d6564f8ec22d689ccd61528d2dc553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49472ec4c9d6564f8ec22d689ccd61528d2dc553", "html_url": "https://github.com/rust-lang/rust/commit/49472ec4c9d6564f8ec22d689ccd61528d2dc553", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49472ec4c9d6564f8ec22d689ccd61528d2dc553/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "040035cd08f9c250d523c9832b25275153d11c3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/040035cd08f9c250d523c9832b25275153d11c3c", "html_url": "https://github.com/rust-lang/rust/commit/040035cd08f9c250d523c9832b25275153d11c3c"}], "stats": {"total": 462, "additions": 75, "deletions": 387}, "files": [{"sha": "ebedc341319173ed6b65614c7b3ad6d8d13fe6a7", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -331,12 +331,11 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             item_impl(*) | item_struct(*) => {\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl %s \\\n-                        (%?/%?), exported? %?\",\n+                        (%?/%?)\",\n                         ecx.tcx.sess.str_of(ident),\n                         did,\n                         ast_map::node_id_to_str(ecx.tcx.items, did, ecx.tcx\n-                                                .sess.parse_sess.interner),\n-                        ast_util::is_exported(ident, md));\n+                                                .sess.parse_sess.interner));\n \n                 ebml_w.start_tag(tag_mod_impl);\n                 ebml_w.wr_str(def_to_str(local_def(did)));"}, {"sha": "eb90acb2d36bfd28b6a9fc9508a73dc6d848db92", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -29,16 +29,15 @@ use syntax::ast::{provided, required};\n use syntax::ast;\n use syntax::ast_map::{node_item, node_method};\n use syntax::ast_map;\n-use syntax::ast_util::{Private, Public, has_legacy_export_attr, is_local};\n-use syntax::ast_util::{visibility_to_privacy};\n+use syntax::ast_util::{Private, Public, is_local};\n+use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n use syntax::codemap::span;\n use syntax::visit;\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: &method_map,\n                    crate: @ast::crate) {\n     let privileged_items = @DVec();\n-    let legacy_exports = has_legacy_export_attr(crate.node.attrs);\n \n     // Adds structs that are privileged to this scope.\n     let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {\n@@ -65,20 +64,20 @@ pub fn check_crate(tcx: ty::ctxt,\n                                    |it| { it.vis },\n                                    ~\"unbound enum parent when checking \\\n                                     dereference of enum type\");\n-            visibility_to_privacy(parent_vis, legacy_exports)\n+            visibility_to_privacy(parent_vis)\n         }\n         else {\n             // WRONG\n             Public\n         };\n         debug!(\"parental_privacy = %?\", parental_privacy);\n-        debug!(\"vis = %?, priv = %?, legacy_exports = %?\",\n+        debug!(\"vis = %?, priv = %?\",\n                variant_info.vis,\n-               visibility_to_privacy(variant_info.vis, legacy_exports),\n-               legacy_exports);\n+               visibility_to_privacy(variant_info.vis))\n         // inherited => privacy of the enum item\n-        if visibility_to_privacy(variant_info.vis,\n-                                 parental_privacy == Public) == Private {\n+        if variant_visibility_to_privacy(variant_info.vis,\n+                                         parental_privacy == Public)\n+                                         == Private {\n             tcx.sess.span_err(span,\n                 ~\"can only dereference enums \\\n                   with a single, public variant\");"}, {"sha": "3c1b7b3c1f90c32716bf2b9b31fb5f294b55c94e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 28, "deletions": 209, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -54,14 +54,14 @@ use syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n use syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, ty_param, ty_path};\n use syntax::ast::{ty_str, ty_u, ty_u16, ty_u32, ty_u64, ty_u8, ty_uint};\n use syntax::ast::{type_value_ns, ty_param_bound, unnamed_field};\n-use syntax::ast::{variant, view_item, view_item_export, view_item_import};\n+use syntax::ast::{variant, view_item, view_item_import};\n use syntax::ast::{view_item_use, view_path_glob, view_path_list};\n use syntax::ast::{view_path_simple, visibility, anonymous, named, not};\n use syntax::ast::{unsafe_fn};\n use syntax::ast_util::{def_id_of_def, dummy_sp, local_def};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n-use syntax::ast_util::{Privacy, Public, Private, visibility_to_privacy};\n-use syntax::ast_util::has_legacy_export_attr;\n+use syntax::ast_util::{Privacy, Public, Private};\n+use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n use syntax::attr::{attr_metas, contains_name, attrs_contains_name};\n use syntax::parse::token::ident_interner;\n use syntax::parse::token::special_idents;\n@@ -469,13 +469,6 @@ pub struct Module {\n \n     exported_names: HashMap<ident,node_id>,\n \n-    // XXX: This is a transition measure to let us switch export-evaluation\n-    // logic when compiling modules that have transitioned to listing their\n-    // pub/priv qualifications on items, explicitly, rather than using the\n-    // old export rule.\n-\n-    legacy_exports: bool,\n-\n     // The status of resolving each import in this module.\n     import_resolutions: HashMap<ident,@ImportResolution>,\n \n@@ -488,8 +481,7 @@ pub struct Module {\n \n pub fn Module(parent_link: ParentLink,\n               def_id: Option<def_id>,\n-              kind: ModuleKind,\n-              legacy_exports: bool)\n+              kind: ModuleKind)\n            -> Module {\n     Module {\n         parent_link: parent_link,\n@@ -499,7 +491,6 @@ pub fn Module(parent_link: ParentLink,\n         imports: DVec(),\n         anonymous_children: HashMap(),\n         exported_names: HashMap(),\n-        legacy_exports: legacy_exports,\n         import_resolutions: HashMap(),\n         glob_count: 0,\n         resolved_import_count: 0\n@@ -553,10 +544,9 @@ pub impl NameBindings {\n                      parent_link: ParentLink,\n                      def_id: Option<def_id>,\n                      kind: ModuleKind,\n-                     legacy_exports: bool,\n                      sp: span) {\n         // Merges the module with the existing type def or creates a new one.\n-        let module_ = @Module(parent_link, def_id, kind, legacy_exports);\n+        let module_ = @Module(parent_link, def_id, kind);\n         match self.type_def {\n             None => {\n                 self.type_def = Some(TypeNsDef {\n@@ -760,7 +750,6 @@ pub fn Resolver(session: Session,\n                                 NoParentLink,\n                                 Some(def_id { crate: 0, node: 0 }),\n                                 NormalModuleKind,\n-                                has_legacy_export_attr(crate.node.attrs),\n                                 crate.span);\n \n     let current_module = (*graph_root).get_module();\n@@ -1076,14 +1065,10 @@ pub impl Resolver {\n                                     &&visitor: vt<ReducedGraphParent>) {\n         let ident = item.ident;\n         let sp = item.span;\n-        let legacy = match parent {\n-          ModuleReducedGraphParent(m) => m.legacy_exports\n-        };\n-        let privacy = visibility_to_privacy(item.vis, legacy);\n+        let privacy = visibility_to_privacy(item.vis);\n \n         match /*bad*/copy item.node {\n             item_mod(module_) => {\n-                let legacy = has_legacy_export_attr(item.attrs);\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateModules, sp);\n \n@@ -1093,7 +1078,6 @@ pub impl Resolver {\n                                                parent_link,\n                                                Some(def_id),\n                                                NormalModuleKind,\n-                                               legacy,\n                                                sp);\n \n                 let new_parent =\n@@ -1103,7 +1087,6 @@ pub impl Resolver {\n             }\n \n             item_foreign_mod(fm) => {\n-                let legacy = has_legacy_export_attr(item.attrs);\n                 let new_parent = match fm.sort {\n                     named => {\n                         let (name_bindings, new_parent) =\n@@ -1117,7 +1100,6 @@ pub impl Resolver {\n                                                        parent_link,\n                                                        Some(def_id),\n                                                        ExternModuleKind,\n-                                                       legacy,\n                                                        sp);\n \n                         ModuleReducedGraphParent(name_bindings.get_module())\n@@ -1168,9 +1150,10 @@ pub impl Resolver {\n                     self.build_reduced_graph_for_variant(*variant,\n                         local_def(item.id),\n                         // inherited => privacy of the enum item\n-                        visibility_to_privacy(variant.node.vis,\n-                                              privacy == Public),\n-                        new_parent, visitor);\n+                        variant_visibility_to_privacy(variant.node.vis,\n+                                                      privacy == Public),\n+                        new_parent,\n+                        visitor);\n                 }\n             }\n \n@@ -1238,7 +1221,6 @@ pub impl Resolver {\n                                                     parent_link,\n                                                     Some(def_id),\n                                                     TraitModuleKind,\n-                                                    false,\n                                                     sp);\n \n                         let new_parent = ModuleReducedGraphParent(\n@@ -1301,7 +1283,6 @@ pub impl Resolver {\n                                                 parent_link,\n                                                 Some(local_def(item.id)),\n                                                 TraitModuleKind,\n-                                                false,\n                                                 sp);\n                     module_parent_opt = Some(ModuleReducedGraphParent(\n                         name_bindings.get_module()));\n@@ -1408,11 +1389,7 @@ pub impl Resolver {\n     fn build_reduced_graph_for_view_item(view_item: @view_item,\n                                          parent: ReducedGraphParent,\n                                          &&_visitor: vt<ReducedGraphParent>) {\n-\n-        let legacy = match parent {\n-          ModuleReducedGraphParent(m) => m.legacy_exports\n-        };\n-        let privacy = visibility_to_privacy(view_item.vis, legacy);\n+        let privacy = visibility_to_privacy(view_item.vis);\n         match /*bad*/copy view_item.node {\n             view_item_import(view_paths) => {\n                 for view_paths.each |view_path| {\n@@ -1484,64 +1461,6 @@ pub impl Resolver {\n                 }\n             }\n \n-            view_item_export(view_paths) => {\n-                let module_ = self.get_module_from_parent(parent);\n-                for view_paths.each |view_path| {\n-                    match view_path.node {\n-                        view_path_simple(ident, full_path, _, ident_id) => {\n-                            let last_ident = full_path.idents.last();\n-                            if last_ident != ident {\n-                                self.session.span_err(view_item.span,\n-                                                      ~\"cannot export under \\\n-                                                       a new name\");\n-                            }\n-                            if full_path.idents.len() != 1u {\n-                                self.session.span_err(\n-                                    view_item.span,\n-                                    ~\"cannot export an item \\\n-                                      that is not in this \\\n-                                      module\");\n-                            }\n-\n-                            module_.exported_names.insert(ident, ident_id);\n-                        }\n-\n-                        view_path_glob(*) => {\n-                            self.session.span_err(view_item.span,\n-                                                  ~\"export globs are \\\n-                                                   unsupported\");\n-                        }\n-\n-                        view_path_list(path, ref path_list_idents, _) => {\n-                            if path.idents.len() == 1u &&\n-                                    (*path_list_idents).len() == 0 {\n-\n-                                self.session.span_warn(view_item.span,\n-                                                       ~\"this syntax for \\\n-                                                        exporting no \\\n-                                                        variants is \\\n-                                                        unsupported; export \\\n-                                                        variants \\\n-                                                        individually\");\n-                            } else {\n-                                if path.idents.len() != 0 {\n-                                    self.session.span_err(view_item.span,\n-                                                          ~\"cannot export an \\\n-                                                           item that is not \\\n-                                                           in this module\");\n-                                }\n-\n-                                for path_list_idents.each |path_list_ident| {\n-                                    let ident = path_list_ident.node.name;\n-                                    let id = path_list_ident.node.id;\n-                                    module_.exported_names.insert(ident, id);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n             view_item_use(name, _, node_id) => {\n                 match find_use_stmt_cnum(self.session.cstore, node_id) {\n                     Some(crate_id) => {\n@@ -1553,12 +1472,11 @@ pub impl Resolver {\n                         let parent_link = ModuleParentLink\n                             (self.get_module_from_parent(new_parent), name);\n \n-                        (*child_name_bindings).define_module(privacy,\n-                                                             parent_link,\n-                                                             Some(def_id),\n-                                                             NormalModuleKind,\n-                                                             false,\n-                                                             view_item.span);\n+                        child_name_bindings.define_module(privacy,\n+                                                          parent_link,\n+                                                          Some(def_id),\n+                                                          NormalModuleKind,\n+                                                          view_item.span);\n                         self.build_reduced_graph_for_external_crate\n                             ((*child_name_bindings).get_module());\n                     }\n@@ -1616,8 +1534,7 @@ pub impl Resolver {\n             let parent_module = self.get_module_from_parent(parent);\n             let new_module = @Module(BlockParentLink(parent_module, block_id),\n                                      None,\n-                                     AnonymousModuleKind,\n-                                     false);\n+                                     AnonymousModuleKind);\n             parent_module.anonymous_children.insert(block_id, new_module);\n             new_parent = ModuleReducedGraphParent(new_module);\n         } else {\n@@ -1652,7 +1569,6 @@ pub impl Resolver {\n                                                       parent_link,\n                                                       Some(def_id),\n                                                       NormalModuleKind,\n-                                                      false,\n                                                       dummy_sp());\n                     modules.insert(def_id,\n                                    child_name_bindings.get_module());\n@@ -1779,12 +1695,11 @@ pub impl Resolver {\n                                 *ident_str);\n                         let parent_link = self.get_parent_link(new_parent,\n                                                                ident);\n-                        (*child_name_bindings).define_module(Public,\n-                                                             parent_link,\n-                                                             None,\n-                                                             NormalModuleKind,\n-                                                             false,\n-                                                             dummy_sp());\n+                        child_name_bindings.define_module(Public,\n+                                                          parent_link,\n+                                                          None,\n+                                                          NormalModuleKind,\n+                                                          dummy_sp());\n                     }\n                     Some(copy type_ns_def)\n                             if type_ns_def.module_def.is_none() => {\n@@ -1793,12 +1708,11 @@ pub impl Resolver {\n                                 *ident_str);\n                         let parent_link = self.get_parent_link(new_parent,\n                                                                ident);\n-                        (*child_name_bindings).define_module(Public,\n-                                                             parent_link,\n-                                                             None,\n-                                                             NormalModuleKind,\n-                                                             false,\n-                                                             dummy_sp());\n+                        child_name_bindings.define_module(Public,\n+                                                          parent_link,\n+                                                          None,\n+                                                          NormalModuleKind,\n+                                                          dummy_sp());\n                     }\n                     _ => {} // Fall through.\n                 }\n@@ -1865,7 +1779,6 @@ pub impl Resolver {\n                                                 parent_link,\n                                                 Some(def),\n                                                 NormalModuleKind,\n-                                                false,\n                                                 dummy_sp());\n                                             type_module =\n                                                 child_name_bindings.\n@@ -2110,7 +2023,6 @@ pub impl Resolver {\n             // First, resolve the module path for the directive, if necessary.\n             match self.resolve_module_path_for_import(module_,\n                                                       module_path,\n-                                                      NoXray,\n                                                       DontUseLexicalScope,\n                                                       import_directive.span) {\n \n@@ -2196,12 +2108,6 @@ pub impl Resolver {\n                self.session.str_of(source),\n                self.module_to_str(module_));\n \n-        if !self.name_is_exported(containing_module, source) {\n-            debug!(\"(resolving single import) name `%s` is unexported\",\n-                   self.session.str_of(source));\n-            return Failed;\n-        }\n-\n         // We need to resolve both namespaces for this to succeed.\n         //\n         // XXX: See if there's some way of handling namespaces in a more\n@@ -2392,12 +2298,6 @@ pub impl Resolver {\n                self.session.str_of(source),\n                self.module_to_str(module_));\n \n-        if !self.name_is_exported(containing_module, source) {\n-            debug!(\"(resolving single import) name `%s` is unexported\",\n-                   self.session.str_of(source));\n-            return Failed;\n-        }\n-\n         // We need to resolve the module namespace for this to succeed.\n         let mut module_result = UnknownResult;\n \n@@ -2538,12 +2438,6 @@ pub impl Resolver {\n         for containing_module.import_resolutions.each\n                 |ident, target_import_resolution| {\n \n-            if !self.name_is_exported(containing_module, ident) {\n-                debug!(\"(resolving glob import) name `%s` is unexported\",\n-                       self.session.str_of(ident));\n-                loop;\n-            }\n-\n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n                    is_none(&target_import_resolution.type_target),\n@@ -2592,12 +2486,6 @@ pub impl Resolver {\n \n         // Add all children from the containing module.\n         for containing_module.children.each |ident, name_bindings| {\n-            if !self.name_is_exported(containing_module, ident) {\n-                debug!(\"(resolving glob import) name `%s` is unexported\",\n-                       self.session.str_of(ident));\n-                loop;\n-            }\n-\n             let mut dest_import_resolution;\n             match module_.import_resolutions.find(ident) {\n                 None => {\n@@ -2639,7 +2527,6 @@ pub impl Resolver {\n     fn resolve_module_path_from_root(module_: @Module,\n                                      module_path: @DVec<ident>,\n                                      index: uint,\n-                                     xray: XrayFlag,\n                                      span: span)\n                                   -> ResolveResult<@Module> {\n         let mut search_module = module_;\n@@ -2655,7 +2542,6 @@ pub impl Resolver {\n             match self.resolve_name_in_module(search_module,\n                                               name,\n                                               TypeNS,\n-                                              xray,\n                                               false) {\n                 Failed => {\n                     self.session.span_err(span, ~\"unresolved name\");\n@@ -2712,7 +2598,6 @@ pub impl Resolver {\n      */\n     fn resolve_module_path_for_import(module_: @Module,\n                                       module_path: @DVec<ident>,\n-                                      xray: XrayFlag,\n                                       use_lexical_scope: UseLexicalScopeFlag,\n                                       span: span)\n                                    -> ResolveResult<@Module> {\n@@ -2787,7 +2672,6 @@ pub impl Resolver {\n         return self.resolve_module_path_from_root(search_module,\n                                                   module_path,\n                                                   start_index,\n-                                                  xray,\n                                                   span);\n     }\n \n@@ -2884,7 +2768,6 @@ pub impl Resolver {\n             match self.resolve_name_in_module(search_module,\n                                               name,\n                                               namespace,\n-                                              Xray,\n                                               false) {\n                 Failed => {\n                     // Continue up the search chain.\n@@ -3030,12 +2913,6 @@ pub impl Resolver {\n         return Success(PrefixFound(containing_module, i));\n     }\n \n-    fn name_is_exported(module_: @Module, name: ident) -> bool {\n-        return !module_.legacy_exports ||\n-            module_.exported_names.size() == 0 ||\n-            module_.exported_names.contains_key(name);\n-    }\n-\n     /**\n      * Attempts to resolve the supplied name in the given module for the\n      * given namespace. If successful, returns the target corresponding to\n@@ -3044,19 +2921,12 @@ pub impl Resolver {\n     fn resolve_name_in_module(module_: @Module,\n                               name: ident,\n                               namespace: Namespace,\n-                              xray: XrayFlag,\n                               allow_globs: bool)\n                            -> ResolveResult<Target> {\n         debug!(\"(resolving name in module) resolving `%s` in `%s`\",\n                self.session.str_of(name),\n                self.module_to_str(module_));\n \n-        if xray == NoXray && !self.name_is_exported(module_, name) {\n-            debug!(\"(resolving name in module) name `%s` is unexported\",\n-                   self.session.str_of(name));\n-            return Failed;\n-        }\n-\n         // First, check the direct children of the module.\n         match module_.children.find(name) {\n             Some(name_bindings)\n@@ -3358,11 +3228,7 @@ pub impl Resolver {\n     fn record_exports_for_module(module_: @Module) {\n         let mut exports2 = ~[];\n \n-        if module_.legacy_exports {\n-            self.add_exports_for_legacy_module(&mut exports2, module_);\n-        } else {\n-            self.add_exports_for_module(&mut exports2, module_);\n-        }\n+        self.add_exports_for_module(&mut exports2, module_);\n         match copy module_.def_id {\n             Some(def_id) => {\n                 self.export_map2.insert(def_id.node, move exports2);\n@@ -3440,44 +3306,6 @@ pub impl Resolver {\n         }\n     }\n \n-    fn add_exports_for_legacy_module(exports2: &mut ~[Export2],\n-                                     module_: @Module) {\n-        for module_.exported_names.each |name, _exp_node_id| {\n-            for self.namespaces.each |namespace| {\n-                match self.resolve_definition_of_name_in_module(module_,\n-                                                                name,\n-                                                                *namespace,\n-                                                                Xray) {\n-                    NoNameDefinition => {\n-                        // Nothing to do.\n-                    }\n-                    ChildNameDefinition(target_def) => {\n-                        debug!(\"(computing exports) legacy export '%s' \\\n-                                for %?\",\n-                               self.session.str_of(name),\n-                               module_.def_id);\n-                        exports2.push(Export2 {\n-                            reexport: false,\n-                            name: self.session.str_of(name),\n-                            def_id: def_id_of_def(target_def)\n-                        });\n-                    }\n-                    ImportNameDefinition(target_def) => {\n-                        debug!(\"(computing exports) legacy reexport '%s' for \\\n-                                %?\",\n-                               self.session.str_of(name),\n-                               module_.def_id);\n-                        exports2.push(Export2 {\n-                            reexport: true,\n-                            name: self.session.str_of(name),\n-                            def_id: def_id_of_def(target_def)\n-                        });\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     // AST resolution\n     //\n     // We maintain a list of value ribs and type ribs.\n@@ -4730,13 +4558,6 @@ pub impl Resolver {\n                                             xray: XrayFlag)\n                                          -> NameDefinition {\n \n-        if xray == NoXray && !self.name_is_exported(containing_module, name) {\n-            debug!(\"(resolving definition of name in module) name `%s` is \\\n-                    unexported\",\n-                   self.session.str_of(name));\n-            return NoNameDefinition;\n-        }\n-\n         // First, search children.\n         match containing_module.children.find(name) {\n             Some(child_name_bindings) => {\n@@ -4816,7 +4637,6 @@ pub impl Resolver {\n         let mut containing_module;\n         match self.resolve_module_path_for_import(self.current_module,\n                                                   module_path_idents,\n-                                                  xray,\n                                                   UseLexicalScope,\n                                                   path.span) {\n             Failed => {\n@@ -4864,7 +4684,6 @@ pub impl Resolver {\n         match self.resolve_module_path_from_root(root_module,\n                                                  module_path_idents,\n                                                  0,\n-                                                 xray,\n                                                  path.span) {\n \n             Failed => {"}, {"sha": "60b4057d4487a8b7c70d5c0ac9b6f6111cd054ba", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -111,9 +111,6 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n       ast_map::node_stmt(*) => {\n         ccx.tcx.sess.bug(~\"Can't monomorphize a stmt\")\n       }\n-      ast_map::node_export(*) => {\n-          ccx.tcx.sess.bug(~\"Can't monomorphize an export\")\n-      }\n       ast_map::node_arg(*) => ccx.tcx.sess.bug(~\"Can't monomorphize an arg\"),\n       ast_map::node_block(*) => {\n           ccx.tcx.sess.bug(~\"Can't monomorphize a block\")\n@@ -255,7 +252,6 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n       ast_map::node_expr(*) |\n       ast_map::node_stmt(*) |\n       ast_map::node_trait_method(*) |\n-      ast_map::node_export(*) |\n       ast_map::node_arg(*) |\n       ast_map::node_block(*) |\n       ast_map::node_local(*) => {"}, {"sha": "2dd70f2f57d9419b30b6858dbbe77445e6551f4f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -3756,7 +3756,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n \n           ast_map::node_stmt(*) | ast_map::node_expr(*) |\n           ast_map::node_arg(*) | ast_map::node_local(*) |\n-          ast_map::node_export(*) | ast_map::node_block(*) => {\n+          ast_map::node_block(*) => {\n             cx.sess.bug(fmt!(\"cannot find item_path for node %?\", node));\n           }\n         }"}, {"sha": "ae57cd90bd7ce4e75257663767f9165cb3d681b9", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -72,7 +72,6 @@ use std::map;\n use std::smallintmap;\n use syntax::ast::{provided, required, spanned};\n use syntax::ast_map::node_id_to_str;\n-use syntax::ast_util::{has_legacy_export_attr};\n use syntax::ast_util::{local_def, respan, split_trait_methods};\n use syntax::codemap::span;\n use syntax::print::pprust::*;"}, {"sha": "0b250c2e42134bb75114b2ffb58ca4739110c265", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -1504,7 +1504,6 @@ pub struct view_item {\n pub enum view_item_ {\n     view_item_use(ident, ~[@meta_item], node_id),\n     view_item_import(~[@view_path]),\n-    view_item_export(~[@view_path])\n }\n \n // Meta-data associated with an item"}, {"sha": "a96829ed06310215c7741aa8ddc39a1d4b03bc6f", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -96,7 +96,6 @@ pub enum ast_node {\n     node_variant(variant, @item, @path),\n     node_expr(@expr),\n     node_stmt(@stmt),\n-    node_export(@view_path, @path),\n     // Locals are numbered, because the alias analysis needs to know in which\n     // order they are introduced.\n     node_arg(arg, uint),\n@@ -128,7 +127,6 @@ pub fn mk_ast_map_visitor() -> vt {\n         visit_fn: map_fn,\n         visit_local: map_local,\n         visit_arm: map_arm,\n-        visit_view_item: map_view_item,\n         visit_block: map_block,\n         .. *visit::default_visitor()\n     });\n@@ -324,23 +322,6 @@ pub fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n     }\n }\n \n-pub fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n-    match vi.node {\n-      view_item_export(vps) => for vps.each |vp| {\n-        let (id, name) = match vp.node {\n-          view_path_simple(nm, _, _, id) => {\n-            (id, /* FIXME (#2543) */ copy nm)\n-          }\n-          view_path_glob(pth, id) | view_path_list(pth, _, id) => {\n-            (id, path_to_ident(pth))\n-          }\n-        };\n-        cx.map.insert(id, node_export(*vp, extend(cx, name)));\n-      },\n-      _ => ()\n-    }\n-}\n-\n pub fn map_expr(ex: @expr, cx: ctx, v: vt) {\n     cx.map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, cx, v);\n@@ -396,11 +377,6 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n         fmt!(\"stmt %s (id=%?)\",\n              pprust::stmt_to_str(*stmt, itr), id)\n       }\n-      // FIXMEs are as per #2410\n-      Some(node_export(_, path)) => {\n-        fmt!(\"export %s (id=%?)\", // add more info here\n-             path_to_str(*path, itr), id)\n-      }\n       Some(node_arg(_, _)) => { // add more info here\n         fmt!(\"arg (id=%?)\", id)\n       }"}, {"sha": "7b742019f0e3ec7298afdd33979af38a9833cd76", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 14, "deletions": 86, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -215,64 +215,6 @@ pub pure fn float_ty_to_str(t: float_ty) -> ~str {\n     match t { ty_f => ~\"f\", ty_f32 => ~\"f32\", ty_f64 => ~\"f64\" }\n }\n \n-pub fn is_exported(i: ident, m: _mod) -> bool {\n-    let mut local = false;\n-    let mut parent_enum : Option<ident> = None;\n-    for m.items.each |it| {\n-        if it.ident == i { local = true; }\n-        match it.node {\n-          item_enum(ref enum_definition, _) =>\n-            for (*enum_definition).variants.each |v| {\n-                if v.node.name == i {\n-                    local = true;\n-                    parent_enum = Some(/* FIXME (#2543) */ copy it.ident);\n-                }\n-            },\n-          _ => ()\n-        }\n-        if local { break; }\n-    }\n-    let mut has_explicit_exports = false;\n-    for m.view_items.each |vi| {\n-        match vi.node {\n-          view_item_export(vps) => {\n-            has_explicit_exports = true;\n-            for vps.each |vp| {\n-                match vp.node {\n-                  ast::view_path_simple(id, _, _, _) => {\n-                    if id == i { return true; }\n-                    match parent_enum {\n-                      Some(parent_enum_id) => {\n-                        if id == parent_enum_id { return true; }\n-                      }\n-                      _ => ()\n-                    }\n-                  }\n-\n-                  ast::view_path_list(path, ref ids, _) => {\n-                    if vec::len(path.idents) == 1u {\n-                        if i == path.idents[0] { return true; }\n-                        for (*ids).each |id| {\n-                            if id.node.name == i { return true; }\n-                        }\n-                    } else {\n-                        fail ~\"export of path-qualified list\";\n-                    }\n-                  }\n-\n-                  _ => ()\n-                }\n-            }\n-          }\n-          _ => ()\n-        }\n-    }\n-    // If there are no declared exports then\n-    // everything not imported is exported\n-    // even if it's local (since it's explicit)\n-    return !has_explicit_exports && local;\n-}\n-\n pub pure fn is_call_expr(e: @expr) -> bool {\n     match e.node { expr_call(_, _, _) => true, _ => false }\n }\n@@ -476,7 +418,7 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_view_item: fn@(vi: @view_item) {\n             match vi.node {\n               view_item_use(_, _, id) => vfn(id),\n-              view_item_import(vps) | view_item_export(vps) => {\n+              view_item_import(vps) => {\n                   for vec::each(vps) |vp| {\n                       match vp.node {\n                           view_path_simple(_, _, _, id) => vfn(id),\n@@ -662,46 +604,32 @@ pub fn struct_def_is_tuple_like(struct_def: @ast::struct_def) -> bool {\n     struct_def.ctor_id.is_some()\n }\n \n+pub fn visibility_to_privacy(visibility: visibility) -> Privacy {\n+    match visibility {\n+        public => Public,\n+        inherited | private => Private\n+    }\n+}\n \n-pub fn visibility_to_privacy(visibility: visibility,\n-                             legacy_exports: bool) -> Privacy {\n-    if legacy_exports {\n+pub fn variant_visibility_to_privacy(visibility: visibility,\n+                                     enclosing_is_public: bool)\n+                                  -> Privacy {\n+    if enclosing_is_public {\n         match visibility {\n-            inherited | public => Public,\n+            public | inherited => Public,\n             private => Private\n         }\n     } else {\n-        match visibility {\n-            public => Public,\n-            inherited | private => Private\n-        }\n+        visibility_to_privacy(visibility)\n     }\n }\n \n+#[deriving_eq]\n pub enum Privacy {\n     Private,\n     Public\n }\n \n-pub impl Privacy : cmp::Eq {\n-    pure fn eq(&self, other: &Privacy) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &Privacy) -> bool { !(*self).eq(other) }\n-}\n-\n-pub fn has_legacy_export_attr(attrs: &[attribute]) -> bool {\n-    for attrs.each |attribute| {\n-        match attribute.node.value.node {\n-          meta_word(ref w) if (*w) == ~\"legacy_exports\" => {\n-            return true;\n-          }\n-          _ => {}\n-        }\n-    }\n-    return false;\n-}\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "d41fedebde3a15bc33dfe5b5f5a25f8447d5e721", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -50,7 +50,7 @@ use ast::{ty_field, ty_fixed_length_vec, ty_fn, ty_infer, ty_mac, ty_method};\n use ast::{ty_nil, ty_param, ty_param_bound, ty_path, ty_ptr, ty_rec, ty_rptr};\n use ast::{ty_tup, ty_u32, ty_uniq, ty_vec, type_value_ns, uniq};\n use ast::{unnamed_field, unsafe_blk, unsafe_fn, variant, view_item};\n-use ast::{view_item_, view_item_export, view_item_import, view_item_use};\n+use ast::{view_item_, view_item_import, view_item_use};\n use ast::{view_path, view_path_glob, view_path_list, view_path_simple};\n use ast::{visibility, vstore, vstore_box, vstore_fixed, vstore_slice};\n use ast::{vstore_uniq};\n@@ -88,6 +88,7 @@ use core::vec::push;\n use core::vec;\n use std::map::HashMap;\n \n+#[deriving_eq]\n enum restriction {\n     UNRESTRICTED,\n     RESTRICT_STMT_EXPR,\n@@ -3735,15 +3736,6 @@ pub impl Parser {\n                 vis: visibility,\n                 span: mk_sp(lo, self.last_span.hi)\n             });\n-        } else if self.eat_keyword(~\"export\") {\n-            let view_paths = self.parse_view_paths();\n-            self.expect(token::SEMI);\n-            return iovi_view_item(@ast::view_item {\n-                node: view_item_export(view_paths),\n-                attrs: attrs,\n-                vis: visibility,\n-                span: mk_sp(lo, self.last_span.hi)\n-            });\n         } else if macros_allowed && !self.is_any_keyword(copy self.token)\n                 && self.look_ahead(1) == token::NOT\n                 && (is_plain_ident(self.look_ahead(2))\n@@ -3916,7 +3908,6 @@ pub impl Parser {\n             next_tok = self.look_ahead(2);\n         };\n         self.token_is_keyword(~\"use\", tok)\n-            || self.token_is_keyword(~\"export\", tok)\n             || (self.token_is_keyword(~\"extern\", tok) &&\n                 self.token_is_keyword(~\"mod\", next_tok))\n     }\n@@ -3925,8 +3916,6 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let node = if self.eat_keyword(~\"use\") {\n             self.parse_use()\n-        } else if self.eat_keyword(~\"export\") {\n-            view_item_export(self.parse_view_paths())\n         } else if self.eat_keyword(~\"extern\") {\n             self.expect_keyword(~\"mod\");\n             let ident = self.parse_ident();\n@@ -3979,8 +3968,8 @@ pub impl Parser {\n                     if restricted_to_imports {\n                             match view_item.node {\n                                 view_item_import(_) => {}\n-                                view_item_export(_) | view_item_use(*) =>\n-                                    self.fatal(~\"exports and \\\"extern mod\\\" \\\n+                                view_item_use(*) =>\n+                                    self.fatal(~\"\\\"extern mod\\\" \\\n                                                  declarations are not \\\n                                                  allowed here\")\n                             }\n@@ -4025,13 +4014,6 @@ pub impl Parser {\n     }\n }\n \n-impl restriction : cmp::Eq {\n-    pure fn eq(&self, other: &restriction) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &restriction) -> bool { !(*self).eq(other) }\n-}\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "2093b5caebddf3d9f0007033cd557c14c6ab73d0", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -486,7 +486,7 @@ pub fn strict_keyword_table() -> HashMap<~str, ()> {\n         ~\"break\",\n         ~\"const\", ~\"copy\",\n         ~\"do\", ~\"drop\",\n-        ~\"else\", ~\"enum\", ~\"export\", ~\"extern\",\n+        ~\"else\", ~\"enum\", ~\"extern\",\n         ~\"fail\", ~\"false\", ~\"fn\", ~\"for\",\n         ~\"if\", ~\"impl\",\n         ~\"let\", ~\"log\", ~\"loop\","}, {"sha": "7f03158a4df890a1de1cccc43ea2d3d789f9a09c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -1865,25 +1865,20 @@ pub fn print_view_item(s: ps, item: @ast::view_item) {\n     print_outer_attributes(s, item.attrs);\n     print_visibility(s, item.vis);\n     match item.node {\n-      ast::view_item_use(id, mta, _) => {\n-        head(s, ~\"extern mod\");\n-        print_ident(s, id);\n-        if !mta.is_empty() {\n-            popen(s);\n-            commasep(s, consistent, mta, print_meta_item);\n-            pclose(s);\n+        ast::view_item_use(id, mta, _) => {\n+            head(s, ~\"extern mod\");\n+            print_ident(s, id);\n+            if !mta.is_empty() {\n+                popen(s);\n+                commasep(s, consistent, mta, print_meta_item);\n+                pclose(s);\n+            }\n         }\n-      }\n-\n-      ast::view_item_import(vps) => {\n-        head(s, ~\"use\");\n-        print_view_paths(s, vps);\n-      }\n \n-      ast::view_item_export(vps) => {\n-        head(s, ~\"export\");\n-        print_view_paths(s, vps);\n-      }\n+        ast::view_item_import(vps) => {\n+            head(s, ~\"use\");\n+            print_view_paths(s, vps);\n+        }\n     }\n     word(s.s, ~\";\");\n     end(s); // end inner head-block"}, {"sha": "4e07de771e5bacfa9cd59780828473c69215b913", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -15,8 +15,6 @@\n \n extern mod std;\n \n-export context;\n-\n struct arc_destruct<T> {\n   _data: int,\n }\n@@ -55,8 +53,8 @@ fn context_res() -> context_res {\n     }\n }\n \n-type context = arc_destruct<context_res>;\n+pub type context = arc_destruct<context_res>;\n \n-impl context {\n+pub impl context {\n     fn socket() { }\n }"}, {"sha": "bf5a6643204294526cb464f7f8574662d3932c9a", "filename": "src/test/auxiliary/issue2170lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Ftest%2Fauxiliary%2Fissue2170lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49472ec4c9d6564f8ec22d689ccd61528d2dc553/src%2Ftest%2Fauxiliary%2Fissue2170lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2170lib.rs?ref=49472ec4c9d6564f8ec22d689ccd61528d2dc553", "patch": "@@ -8,22 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-export rsrc;\n-\n fn foo(_x: i32) {\n }\n \n-struct rsrc {\n+pub struct rsrc {\n   x: i32,\n }\n \n-impl rsrc : Drop {\n+pub impl rsrc : Drop {\n     fn finalize(&self) {\n         foo(self.x);\n     }\n }\n \n-fn rsrc(x: i32) -> rsrc {\n+pub fn rsrc(x: i32) -> rsrc {\n     rsrc {\n         x: x\n     }"}]}