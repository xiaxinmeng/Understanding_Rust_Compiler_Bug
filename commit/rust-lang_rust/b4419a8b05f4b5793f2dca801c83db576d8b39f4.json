{"sha": "b4419a8b05f4b5793f2dca801c83db576d8b39f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NDE5YThiMDVmNGI1NzkzZjJkY2E4MDFjODNkYjU3NmQ4YjM5ZjQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-11T15:13:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-11T15:13:59Z"}, "message": "Rollup merge of #61606 - petrochenkov:legclean, r=pnkfelix\n\nRemove some legacy proc macro flavors\n\nNamely\n- `IdentTT` (`foo! ident { ... }`). Can be replaced with `foo! { ident ... }` or something similar.\n- `MultiDecorator`. Can be replaced by `MultiModifier` (aka `LegacyAttr` after renaming).\n- `DeclMacro`. It was a less powerful duplicate of `NormalTT` (aka `LegacyBang` after renaming) and can be replaced by it.\n\nStuff like this slows down any attempts to refactor the expansion infra, so it's desirable to retire it already.\nI'm not sure whether a lang team decision is necessary, but would be nice to land this sooner because I have some further work in this area scheduled.\n\nThe documentation commit (https://github.com/rust-lang/rust/commit/a9397fd0d5eede4bbc0ada94bf92657ca8084cb3) describes how the remaining variants are different from each other and shows that there's actually some system behind them.\n\nThe last commit renames variants of `SyntaxExtension` in more systematic way.\n- `ProcMacro` -> `Bang`\n- `NormalTT` -> `LegacyBang`\n- `AttrProcMacro` -> `Attr`\n- `MultiModifier` -> `LegacyAttr`\n- `ProcMacroDerive` -> `Derive`\n- `BuiltinDerive` -> `LegacyDerive`\n\nAll the `Legacy*` variants are AST-based, as opposed to \"modern\" token-based variants.", "tree": {"sha": "b8bba067cd3298444273c926f3ae1ff302e4e467", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8bba067cd3298444273c926f3ae1ff302e4e467"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4419a8b05f4b5793f2dca801c83db576d8b39f4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc/8U3CRBK7hj4Ov3rIwAAdHIIAK9PBDF62jbduQeEwZjLOwnq\nyIVs6VIQvegpCy26ZHmp0qBYiPaN3ojmeotwVAaMrrekEUxv7D/l2T7jFmk7JfWi\nNjquzeDAtb38d526erffXOBFM+Vvb1YXZlRD+D4BN+rn3weNtg85W16B1UYbcgC/\nzNnnyxQ0en++56NqsQQCsGwuicGpQKjK8X8BG8SJmfpGXLQnsXQviWB/UOo6++QK\n3H+q6q7AVgcsGgUzIy0Fp+oZlAdVNmv1CQ/LjkN4UA/cmiOiO+vNLwUKrWXeN8Ys\na2zVLQBgyfz9ZeFPyZEomgHZ/lh7pEOP4w0sfrgVNOmiwK0+PtCQNsoasMUPWlw=\n=DgTU\n-----END PGP SIGNATURE-----\n", "payload": "tree b8bba067cd3298444273c926f3ae1ff302e4e467\nparent b81986c2af9c2569828f1234d4c4772cc8cb8950\nparent 93eb63c9a540e8721adf8b97085301b7b692785d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1560266039 +0200\ncommitter GitHub <noreply@github.com> 1560266039 +0200\n\nRollup merge of #61606 - petrochenkov:legclean, r=pnkfelix\n\nRemove some legacy proc macro flavors\n\nNamely\n- `IdentTT` (`foo! ident { ... }`). Can be replaced with `foo! { ident ... }` or something similar.\n- `MultiDecorator`. Can be replaced by `MultiModifier` (aka `LegacyAttr` after renaming).\n- `DeclMacro`. It was a less powerful duplicate of `NormalTT` (aka `LegacyBang` after renaming) and can be replaced by it.\n\nStuff like this slows down any attempts to refactor the expansion infra, so it's desirable to retire it already.\nI'm not sure whether a lang team decision is necessary, but would be nice to land this sooner because I have some further work in this area scheduled.\n\nThe documentation commit (https://github.com/rust-lang/rust/commit/a9397fd0d5eede4bbc0ada94bf92657ca8084cb3) describes how the remaining variants are different from each other and shows that there's actually some system behind them.\n\nThe last commit renames variants of `SyntaxExtension` in more systematic way.\n- `ProcMacro` -> `Bang`\n- `NormalTT` -> `LegacyBang`\n- `AttrProcMacro` -> `Attr`\n- `MultiModifier` -> `LegacyAttr`\n- `ProcMacroDerive` -> `Derive`\n- `BuiltinDerive` -> `LegacyDerive`\n\nAll the `Legacy*` variants are AST-based, as opposed to \"modern\" token-based variants.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4419a8b05f4b5793f2dca801c83db576d8b39f4", "html_url": "https://github.com/rust-lang/rust/commit/b4419a8b05f4b5793f2dca801c83db576d8b39f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4419a8b05f4b5793f2dca801c83db576d8b39f4/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b81986c2af9c2569828f1234d4c4772cc8cb8950", "url": "https://api.github.com/repos/rust-lang/rust/commits/b81986c2af9c2569828f1234d4c4772cc8cb8950", "html_url": "https://github.com/rust-lang/rust/commit/b81986c2af9c2569828f1234d4c4772cc8cb8950"}, {"sha": "93eb63c9a540e8721adf8b97085301b7b692785d", "url": "https://api.github.com/repos/rust-lang/rust/commits/93eb63c9a540e8721adf8b97085301b7b692785d", "html_url": "https://github.com/rust-lang/rust/commit/93eb63c9a540e8721adf8b97085301b7b692785d"}], "stats": {"total": 919, "additions": 224, "deletions": 695}, "files": [{"sha": "7ffba41e2569a4f32e3077e4622ffc9e17596fa2", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -614,7 +614,7 @@ impl<'a> CrateLoader<'a> {\n             match decl {\n                 ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                     let attrs = attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n-                    (trait_name, SyntaxExtension::ProcMacroDerive(\n+                    (trait_name, SyntaxExtension::Derive(\n                         Box::new(ProcMacroDerive {\n                             client,\n                             attrs: attrs.clone(),\n@@ -624,13 +624,13 @@ impl<'a> CrateLoader<'a> {\n                     ))\n                 }\n                 ProcMacro::Attr { name, client } => {\n-                    (name, SyntaxExtension::AttrProcMacro(\n+                    (name, SyntaxExtension::Attr(\n                         Box::new(AttrProcMacro { client }),\n                         root.edition,\n                     ))\n                 }\n                 ProcMacro::Bang { name, client } => {\n-                    (name, SyntaxExtension::ProcMacro {\n+                    (name, SyntaxExtension::Bang {\n                         expander: Box::new(BangProcMacro { client }),\n                         allow_internal_unstable: None,\n                         edition: root.edition,"}, {"sha": "35faa1df82b845f3a4ef0cf18b1a86cae2d174b3", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -430,7 +430,7 @@ impl cstore::CStore {\n             use syntax_ext::proc_macro_impl::BangProcMacro;\n \n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-            let ext = SyntaxExtension::ProcMacro {\n+            let ext = SyntaxExtension::Bang {\n                 expander: Box::new(BangProcMacro { client }),\n                 allow_internal_unstable: Some(vec![sym::proc_macro_def_site].into()),\n                 edition: data.root.edition,"}, {"sha": "dd5e42684c4276581471ff68738e55078e4c8e44", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -4,8 +4,9 @@ use rustc::lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n \n-use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT, IdentTT};\n+use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension};\n use syntax::ext::base::MacroExpanderFn;\n+use syntax::ext::hygiene::Transparency;\n use syntax::symbol::{Symbol, sym};\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n@@ -84,47 +85,26 @@ impl<'a> Registry<'a> {\n     /// Register a syntax extension of any kind.\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n-    pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n+    pub fn register_syntax_extension(&mut self, name: ast::Name, mut extension: SyntaxExtension) {\n         if name == sym::macro_rules {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n-        self.syntax_exts.push((name, match extension {\n-            NormalTT {\n-                expander,\n-                def_info: _,\n-                allow_internal_unstable,\n-                allow_internal_unsafe,\n-                local_inner_macros,\n-                unstable_feature,\n-                edition,\n-            } => {\n-                let nid = ast::CRATE_NODE_ID;\n-                NormalTT {\n-                    expander,\n-                    def_info: Some((nid, self.krate_span)),\n-                    allow_internal_unstable,\n-                    allow_internal_unsafe,\n-                    local_inner_macros,\n-                    unstable_feature,\n-                    edition,\n-                }\n-            }\n-            IdentTT { expander, span: _, allow_internal_unstable } => {\n-                IdentTT { expander, span: Some(self.krate_span), allow_internal_unstable }\n-            }\n-            _ => extension,\n-        }));\n+        if let SyntaxExtension::LegacyBang { def_info: ref mut def_info @ None, .. } = extension {\n+            *def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n+        }\n+        self.syntax_exts.push((name, extension));\n     }\n \n     /// Register a macro of the usual kind.\n     ///\n     /// This is a convenience wrapper for `register_syntax_extension`.\n-    /// It builds for you a `NormalTT` that calls `expander`,\n+    /// It builds for you a `SyntaxExtension::LegacyBang` that calls `expander`,\n     /// and also takes care of interning the macro's name.\n     pub fn register_macro(&mut self, name: &str, expander: MacroExpanderFn) {\n-        self.register_syntax_extension(Symbol::intern(name), NormalTT {\n+        self.register_syntax_extension(Symbol::intern(name), SyntaxExtension::LegacyBang {\n             expander: Box::new(expander),\n             def_info: None,\n+            transparency: Transparency::SemiTransparent,\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,"}, {"sha": "2369bddf4f75fca13ae27304aa474f65e4dc9c21", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -242,8 +242,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn check_unused_macros(&self) {\n         for did in self.unused_macros.iter() {\n             let id_span = match *self.macro_map[did] {\n-                SyntaxExtension::NormalTT { def_info, .. } |\n-                SyntaxExtension::DeclMacro { def_info, .. } => def_info,\n+                SyntaxExtension::LegacyBang { def_info, .. } => def_info,\n                 _ => None,\n             };\n             if let Some((id, span)) = id_span {\n@@ -587,7 +586,7 @@ impl<'a> Resolver<'a> {\n                         match self.resolve_macro_to_res(derive, MacroKind::Derive,\n                                                         &parent_scope, true, force) {\n                             Ok((_, ext)) => {\n-                                if let SyntaxExtension::ProcMacroDerive(_, helpers, _) = &*ext {\n+                                if let SyntaxExtension::Derive(_, helpers, _) = &*ext {\n                                     if helpers.contains(&ident.name) {\n                                         let binding =\n                                             (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),"}, {"sha": "5a5540e7e38556096e7f0206aa626d407de3d59f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -471,7 +471,7 @@ fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemE\n         }\n         LoadedMacro::ProcMacro(ext) => {\n             let helpers = match &*ext {\n-                &SyntaxExtension::ProcMacroDerive(_, ref syms, ..) => { syms.clean(cx) }\n+                &SyntaxExtension::Derive(_, ref syms, ..) => { syms.clean(cx) }\n                 _ => Vec::new(),\n             };\n "}, {"sha": "7fbfc3e1fc0f4a1030de025ee972c1a7582da564", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -433,7 +433,7 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n             if let Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) = res {\n                 // skip proc-macro stubs, they'll cause `get_macro` to crash\n             } else {\n-                if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(res) {\n+                if let SyntaxExtension::LegacyBang { .. } = *resolver.get_macro(res) {\n                     return Some(res.map_id(|_| panic!(\"unexpected id\")));\n                 }\n             }"}, {"sha": "38b7dee40c447f52a09ba554340a4d79cb6481b6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 77, "deletions": 146, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -1,6 +1,4 @@\n-pub use SyntaxExtension::*;\n-\n-use crate::ast::{self, Attribute, Name, PatKind, MetaItem};\n+use crate::ast::{self, Attribute, Name, PatKind};\n use crate::attr::HasAttrs;\n use crate::source_map::{SourceMap, Spanned, respan};\n use crate::edition::Edition;\n@@ -137,29 +135,6 @@ impl Annotatable {\n     }\n }\n \n-// A more flexible ItemDecorator.\n-pub trait MultiItemDecorator {\n-    fn expand(&self,\n-              ecx: &mut ExtCtxt<'_>,\n-              sp: Span,\n-              meta_item: &ast::MetaItem,\n-              item: &Annotatable,\n-              push: &mut dyn FnMut(Annotatable));\n-}\n-\n-impl<F> MultiItemDecorator for F\n-    where F : Fn(&mut ExtCtxt<'_>, Span, &ast::MetaItem, &Annotatable, &mut dyn FnMut(Annotatable))\n-{\n-    fn expand(&self,\n-              ecx: &mut ExtCtxt<'_>,\n-              sp: Span,\n-              meta_item: &ast::MetaItem,\n-              item: &Annotatable,\n-              push: &mut dyn FnMut(Annotatable)) {\n-        (*self)(ecx, sp, meta_item, item, push)\n-    }\n-}\n-\n // `meta_item` is the annotation, and `item` is the item being modified.\n // FIXME Decorators should follow the same pattern too.\n pub trait MultiItemModifier {\n@@ -288,34 +263,6 @@ impl<F> TTMacroExpander for F\n     }\n }\n \n-pub trait IdentMacroExpander {\n-    fn expand<'cx>(&self,\n-                   cx: &'cx mut ExtCtxt<'_>,\n-                   sp: Span,\n-                   ident: ast::Ident,\n-                   token_tree: Vec<tokenstream::TokenTree>)\n-                   -> Box<dyn MacResult+'cx>;\n-}\n-\n-pub type IdentMacroExpanderFn =\n-    for<'cx> fn(&'cx mut ExtCtxt<'_>, Span, ast::Ident, Vec<tokenstream::TokenTree>)\n-                -> Box<dyn MacResult+'cx>;\n-\n-impl<F> IdentMacroExpander for F\n-    where F : for<'cx> Fn(&'cx mut ExtCtxt<'_>, Span, ast::Ident,\n-                          Vec<tokenstream::TokenTree>) -> Box<dyn MacResult+'cx>\n-{\n-    fn expand<'cx>(&self,\n-                   cx: &'cx mut ExtCtxt<'_>,\n-                   sp: Span,\n-                   ident: ast::Ident,\n-                   token_tree: Vec<tokenstream::TokenTree>)\n-                   -> Box<dyn MacResult+'cx>\n-    {\n-        (*self)(cx, sp, ident, token_tree)\n-    }\n-}\n-\n // Use a macro because forwarding to a simple function has type system issues\n macro_rules! make_stmts_default {\n     ($me:expr) => {\n@@ -570,9 +517,6 @@ impl MacResult for DummyResult {\n     }\n }\n \n-pub type BuiltinDeriveFn =\n-    for<'cx> fn(&'cx mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable));\n-\n /// Represents different kinds of macro invocations that can be resolved.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MacroKind {\n@@ -606,129 +550,116 @@ impl MacroKind {\n \n /// An enum representing the different kinds of syntax extensions.\n pub enum SyntaxExtension {\n-    /// A trivial \"extension\" that does nothing, only keeps the attribute and marks it as known.\n-    NonMacroAttr { mark_used: bool },\n-\n-    /// A syntax extension that is attached to an item and creates new items\n-    /// based upon it.\n-    ///\n-    /// `#[derive(...)]` is a `MultiItemDecorator`.\n-    ///\n-    /// Prefer ProcMacro or MultiModifier since they are more flexible.\n-    MultiDecorator(Box<dyn MultiItemDecorator + sync::Sync + sync::Send>),\n-\n-    /// A syntax extension that is attached to an item and modifies it\n-    /// in-place. Also allows decoration, i.e., creating new items.\n-    MultiModifier(Box<dyn MultiItemModifier + sync::Sync + sync::Send>),\n-\n-    /// A function-like procedural macro. TokenStream -> TokenStream.\n-    ProcMacro {\n+    /// A token-based function-like macro.\n+    Bang {\n+        /// An expander with signature TokenStream -> TokenStream.\n         expander: Box<dyn ProcMacro + sync::Sync + sync::Send>,\n-        /// Whitelist of unstable features that are treated as stable inside this macro\n+        /// Whitelist of unstable features that are treated as stable inside this macro.\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+        /// Edition of the crate in which this macro is defined.\n         edition: Edition,\n     },\n \n-    /// An attribute-like procedural macro. TokenStream, TokenStream -> TokenStream.\n-    /// The first TokenSteam is the attribute, the second is the annotated item.\n-    /// Allows modification of the input items and adding new items, similar to\n-    /// MultiModifier, but uses TokenStreams, rather than AST nodes.\n-    AttrProcMacro(Box<dyn AttrProcMacro + sync::Sync + sync::Send>, Edition),\n-\n-    /// A normal, function-like syntax extension.\n-    ///\n-    /// `bytes!` is a `NormalTT`.\n-    NormalTT {\n+    /// An AST-based function-like macro.\n+    LegacyBang {\n+        /// An expander with signature TokenStream -> AST.\n         expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n+        /// Some info about the macro's definition point.\n         def_info: Option<(ast::NodeId, Span)>,\n-        /// Whether the contents of the macro can\n-        /// directly use `#[unstable]` things.\n-        ///\n-        /// Only allows things that require a feature gate in the given whitelist\n+        /// Hygienic properties of identifiers produced by this macro.\n+        transparency: Transparency,\n+        /// Whitelist of unstable features that are treated as stable inside this macro.\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-        /// Whether the contents of the macro can use `unsafe`\n-        /// without triggering the `unsafe_code` lint.\n+        /// Suppresses the `unsafe_code` lint for code produced by this macro.\n         allow_internal_unsafe: bool,\n-        /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`)\n-        /// for a given macro.\n+        /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n         local_inner_macros: bool,\n-        /// The macro's feature name if it is unstable, and the stability feature\n+        /// The macro's feature name and tracking issue number if it is unstable.\n         unstable_feature: Option<(Symbol, u32)>,\n-        /// Edition of the crate in which the macro is defined\n+        /// Edition of the crate in which this macro is defined.\n         edition: Edition,\n     },\n \n-    /// A function-like syntax extension that has an extra ident before\n-    /// the block.\n-    IdentTT {\n-        expander: Box<dyn IdentMacroExpander + sync::Sync + sync::Send>,\n-        span: Option<Span>,\n-        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    /// A token-based attribute macro.\n+    Attr(\n+        /// An expander with signature (TokenStream, TokenStream) -> TokenStream.\n+        /// The first TokenSteam is the attribute itself, the second is the annotated item.\n+        /// The produced TokenSteam replaces the input TokenSteam.\n+        Box<dyn AttrProcMacro + sync::Sync + sync::Send>,\n+        /// Edition of the crate in which this macro is defined.\n+        Edition,\n+    ),\n+\n+    /// An AST-based attribute macro.\n+    LegacyAttr(\n+        /// An expander with signature (AST, AST) -> AST.\n+        /// The first AST fragment is the attribute itself, the second is the annotated item.\n+        /// The produced AST fragment replaces the input AST fragment.\n+        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+    ),\n+\n+    /// A trivial attribute \"macro\" that does nothing,\n+    /// only keeps the attribute and marks it as known.\n+    NonMacroAttr {\n+        /// Suppresses the `unused_attributes` lint for this attribute.\n+        mark_used: bool,\n     },\n \n-    /// An attribute-like procedural macro. TokenStream -> TokenStream.\n-    /// The input is the annotated item.\n-    /// Allows generating code to implement a Trait for a given struct\n-    /// or enum item.\n-    ProcMacroDerive(Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n-                    Vec<Symbol> /* inert attribute names */, Edition),\n-\n-    /// An attribute-like procedural macro that derives a builtin trait.\n-    BuiltinDerive(BuiltinDeriveFn),\n-\n-    /// A declarative macro, e.g., `macro m() {}`.\n-    DeclMacro {\n-        expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n-        def_info: Option<(ast::NodeId, Span)>,\n-        is_transparent: bool,\n-        edition: Edition,\n-    }\n+    /// A token-based derive macro.\n+    Derive(\n+        /// An expander with signature TokenStream -> TokenStream (not yet).\n+        /// The produced TokenSteam is appended to the input TokenSteam.\n+        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+        /// Names of helper attributes registered by this macro.\n+        Vec<Symbol>,\n+        /// Edition of the crate in which this macro is defined.\n+        Edition,\n+    ),\n+\n+    /// An AST-based derive macro.\n+    LegacyDerive(\n+        /// An expander with signature AST -> AST.\n+        /// The produced AST fragment is appended to the input AST fragment.\n+        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+    ),\n }\n \n impl SyntaxExtension {\n     /// Returns which kind of macro calls this syntax extension.\n     pub fn kind(&self) -> MacroKind {\n         match *self {\n-            SyntaxExtension::DeclMacro { .. } |\n-            SyntaxExtension::NormalTT { .. } |\n-            SyntaxExtension::IdentTT { .. } |\n-            SyntaxExtension::ProcMacro { .. } =>\n-                MacroKind::Bang,\n-            SyntaxExtension::NonMacroAttr { .. } |\n-            SyntaxExtension::MultiDecorator(..) |\n-            SyntaxExtension::MultiModifier(..) |\n-            SyntaxExtension::AttrProcMacro(..) =>\n-                MacroKind::Attr,\n-            SyntaxExtension::ProcMacroDerive(..) |\n-            SyntaxExtension::BuiltinDerive(..) =>\n-                MacroKind::Derive,\n+            SyntaxExtension::Bang { .. } |\n+            SyntaxExtension::LegacyBang { .. } => MacroKind::Bang,\n+            SyntaxExtension::Attr(..) |\n+            SyntaxExtension::LegacyAttr(..) |\n+            SyntaxExtension::NonMacroAttr { .. } => MacroKind::Attr,\n+            SyntaxExtension::Derive(..) |\n+            SyntaxExtension::LegacyDerive(..) => MacroKind::Derive,\n         }\n     }\n \n     pub fn default_transparency(&self) -> Transparency {\n         match *self {\n-            SyntaxExtension::ProcMacro { .. } |\n-            SyntaxExtension::AttrProcMacro(..) |\n-            SyntaxExtension::ProcMacroDerive(..) |\n-            SyntaxExtension::DeclMacro { is_transparent: false, .. } => Transparency::Opaque,\n-            SyntaxExtension::DeclMacro { is_transparent: true, .. } => Transparency::Transparent,\n-            _ => Transparency::SemiTransparent,\n+            SyntaxExtension::LegacyBang { transparency, .. } => transparency,\n+            SyntaxExtension::Bang { .. } |\n+            SyntaxExtension::Attr(..) |\n+            SyntaxExtension::Derive(..) |\n+            SyntaxExtension::NonMacroAttr { .. } => Transparency::Opaque,\n+            SyntaxExtension::LegacyAttr(..) |\n+            SyntaxExtension::LegacyDerive(..) => Transparency::SemiTransparent,\n         }\n     }\n \n     pub fn edition(&self, default_edition: Edition) -> Edition {\n         match *self {\n-            SyntaxExtension::NormalTT { edition, .. } |\n-            SyntaxExtension::DeclMacro { edition, .. } |\n-            SyntaxExtension::ProcMacro { edition, .. } |\n-            SyntaxExtension::AttrProcMacro(.., edition) |\n-            SyntaxExtension::ProcMacroDerive(.., edition) => edition,\n+            SyntaxExtension::Bang { edition, .. } |\n+            SyntaxExtension::LegacyBang { edition, .. } |\n+            SyntaxExtension::Attr(.., edition) |\n+            SyntaxExtension::Derive(.., edition) => edition,\n             // Unstable legacy stuff\n             SyntaxExtension::NonMacroAttr { .. } |\n-            SyntaxExtension::IdentTT { .. } |\n-            SyntaxExtension::MultiDecorator(..) |\n-            SyntaxExtension::MultiModifier(..) |\n-            SyntaxExtension::BuiltinDerive(..) => default_edition,\n+            SyntaxExtension::LegacyAttr(..) |\n+            SyntaxExtension::LegacyDerive(..) => default_edition,\n         }\n     }\n }"}, {"sha": "084d4fd3820172258374abbf414471d5a82fb624", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 33, "deletions": 71, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -389,7 +389,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         let item = match self.cx.resolver.resolve_macro_path(\n                                 path, MacroKind::Derive, Mark::root(), Vec::new(), false) {\n                             Ok(ext) => match *ext {\n-                                BuiltinDerive(..) => item_with_markers.clone(),\n+                                SyntaxExtension::LegacyDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),\n                             },\n                             _ => item.clone(),\n@@ -548,7 +548,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        if let NonMacroAttr { mark_used: false } = *ext {} else {\n+        if let SyntaxExtension::NonMacroAttr { mark_used: false } = *ext {} else {\n             // Macro attrs are always used when expanded,\n             // non-macro attrs are considered used when the field says so.\n             attr::mark_used(&attr);\n@@ -564,26 +564,18 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         });\n \n         match *ext {\n-            NonMacroAttr { .. } => {\n+            SyntaxExtension::NonMacroAttr { .. } => {\n                 attr::mark_known(&attr);\n                 item.visit_attrs(|attrs| attrs.push(attr));\n                 Some(invoc.fragment_kind.expect_from_annotatables(iter::once(item)))\n             }\n-            MultiModifier(ref mac) => {\n+            SyntaxExtension::LegacyAttr(ref mac) => {\n                 let meta = attr.parse_meta(self.cx.parse_sess)\n                                .map_err(|mut e| { e.emit(); }).ok()?;\n                 let item = mac.expand(self.cx, attr.span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(item))\n             }\n-            MultiDecorator(ref mac) => {\n-                let mut items = Vec::new();\n-                let meta = attr.parse_meta(self.cx.parse_sess)\n-                               .expect(\"derive meta should already have been parsed\");\n-                mac.expand(self.cx, attr.span, &meta, &item, &mut |item| items.push(item));\n-                items.push(item);\n-                Some(invoc.fragment_kind.expect_from_annotatables(items))\n-            }\n-            AttrProcMacro(ref mac, ..) => {\n+            SyntaxExtension::Attr(ref mac, ..) => {\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n                 let item_tok = TokenTree::token(token::Interpolated(Lrc::new(match item {\n                     Annotatable::Item(item) => token::NtItem(item),\n@@ -600,7 +592,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 self.gate_proc_macro_expansion(attr.span, &res);\n                 res\n             }\n-            ProcMacroDerive(..) | BuiltinDerive(..) => {\n+            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n                 self.cx.span_err(attr.span, &format!(\"`{}` is a derive macro\", attr.path));\n                 self.cx.trace_macros_diag();\n                 invoc.fragment_kind.dummy(attr.span)\n@@ -755,24 +747,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         let opt_expanded = match *ext {\n-            DeclMacro { ref expander, def_info, edition, .. } => {\n-                if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n-                                                                    None, false, false, None,\n-                                                                    edition) {\n-                    dummy_span\n-                } else {\n-                    kind.make_from(expander.expand(self.cx, span, mac.node.stream(), None))\n-                }\n-            }\n-\n-            NormalTT {\n+            SyntaxExtension::LegacyBang {\n                 ref expander,\n                 def_info,\n                 ref allow_internal_unstable,\n                 allow_internal_unsafe,\n                 local_inner_macros,\n                 unstable_feature,\n                 edition,\n+                ..\n             } => {\n                 if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n                                                                     allow_internal_unstable.clone(),\n@@ -791,43 +774,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n             }\n \n-            IdentTT { ref expander, span: tt_span, ref allow_internal_unstable } => {\n-                if ident.name == kw::Invalid {\n-                    self.cx.span_err(path.span,\n-                                    &format!(\"macro {}! expects an ident argument\", path));\n-                    self.cx.trace_macros_diag();\n-                    kind.dummy(span)\n-                } else {\n-                    invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                        call_site: span,\n-                        def_site: tt_span,\n-                        format: macro_bang_format(path),\n-                        allow_internal_unstable: allow_internal_unstable.clone(),\n-                        allow_internal_unsafe: false,\n-                        local_inner_macros: false,\n-                        edition: self.cx.parse_sess.edition,\n-                    });\n-\n-                    let input: Vec<_> = mac.node.stream().into_trees().collect();\n-                    kind.make_from(expander.expand(self.cx, span, ident, input))\n-                }\n-            }\n-\n-            MultiDecorator(..) | MultiModifier(..) |\n-            AttrProcMacro(..) | SyntaxExtension::NonMacroAttr { .. } => {\n+            SyntaxExtension::Attr(..) |\n+            SyntaxExtension::LegacyAttr(..) |\n+            SyntaxExtension::NonMacroAttr { .. } => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            ProcMacroDerive(..) | BuiltinDerive(..) => {\n+            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n                 self.cx.span_err(path.span, &format!(\"`{}` is a derive macro\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            SyntaxExtension::ProcMacro { ref expander, ref allow_internal_unstable, edition } => {\n+            SyntaxExtension::Bang { ref expander, ref allow_internal_unstable, edition } => {\n                 if ident.name != kw::Invalid {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n@@ -924,29 +886,29 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             edition: ext.edition(self.cx.parse_sess.edition),\n         };\n \n-        match *ext {\n-            ProcMacroDerive(ref ext, ..) => {\n-                invoc.expansion_data.mark.set_expn_info(expn_info);\n-                let span = span.with_ctxt(self.cx.backtrace());\n-                let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n-                    path: Path::from_ident(Ident::invalid()),\n-                    span: DUMMY_SP,\n-                    node: ast::MetaItemKind::Word,\n+        match ext {\n+            SyntaxExtension::Derive(expander, ..) | SyntaxExtension::LegacyDerive(expander) => {\n+                let meta = match ext {\n+                    SyntaxExtension::Derive(..) => ast::MetaItem { // FIXME(jseyfried) avoid this\n+                        path: Path::from_ident(Ident::invalid()),\n+                        span: DUMMY_SP,\n+                        node: ast::MetaItemKind::Word,\n+                    },\n+                    _ => {\n+                        expn_info.allow_internal_unstable = Some(vec![\n+                            sym::rustc_attrs,\n+                            Symbol::intern(\"derive_clone_copy\"),\n+                            Symbol::intern(\"derive_eq\"),\n+                            // RustcDeserialize and RustcSerialize\n+                            Symbol::intern(\"libstd_sys_internals\"),\n+                        ].into());\n+                        attr.meta()?\n+                    }\n                 };\n-                let items = ext.expand(self.cx, span, &dummy, item);\n-                Some(invoc.fragment_kind.expect_from_annotatables(items))\n-            }\n-            BuiltinDerive(func) => {\n-                expn_info.allow_internal_unstable = Some(vec![\n-                    sym::rustc_attrs,\n-                    Symbol::intern(\"derive_clone_copy\"),\n-                    Symbol::intern(\"derive_eq\"),\n-                    Symbol::intern(\"libstd_sys_internals\"), // RustcDeserialize and RustcSerialize\n-                ].into());\n+\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n-                let mut items = Vec::new();\n-                func(self.cx, span, &attr.meta()?, &item, &mut |a| items.push(a));\n+                let items = expander.expand(self.cx, span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             _ => {"}, {"sha": "5dbf21867afa6df02811e60f539ef32559878ec2", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -1,8 +1,8 @@\n use crate::{ast, attr};\n use crate::edition::Edition;\n-use crate::ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n-use crate::ext::base::{NormalTT, TTMacroExpander};\n+use crate::ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension, TTMacroExpander};\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n+use crate::ext::hygiene::Transparency;\n use crate::ext::tt::macro_parser::{Success, Error, Failure};\n use crate::ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use crate::ext::tt::macro_parser::{parse, parse_failure_msg};\n@@ -374,65 +374,65 @@ pub fn compile(\n         valid,\n     });\n \n-    if body.legacy {\n-        let allow_internal_unstable = attr::find_by_name(&def.attrs, sym::allow_internal_unstable)\n-            .map(|attr| attr\n-                .meta_item_list()\n-                .map(|list| list.iter()\n-                    .filter_map(|it| {\n-                        let name = it.ident().map(|ident| ident.name);\n-                        if name.is_none() {\n-                            sess.span_diagnostic.span_err(it.span(),\n-                                \"allow internal unstable expects feature names\")\n-                        }\n-                        name\n-                    })\n-                    .collect::<Vec<Symbol>>().into()\n-                )\n-                .unwrap_or_else(|| {\n-                    sess.span_diagnostic.span_warn(\n-                        attr.span, \"allow_internal_unstable expects list of feature names. In the \\\n-                        future this will become a hard error. Please use `allow_internal_unstable(\\\n-                        foo, bar)` to only allow the `foo` and `bar` features\",\n-                    );\n-                    vec![sym::allow_internal_unstable_backcompat_hack].into()\n+    let transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n+        Transparency::Transparent\n+    } else if body.legacy {\n+        Transparency::SemiTransparent\n+    } else {\n+        Transparency::Opaque\n+    };\n+\n+    let allow_internal_unstable = attr::find_by_name(&def.attrs, sym::allow_internal_unstable)\n+        .map(|attr| attr\n+            .meta_item_list()\n+            .map(|list| list.iter()\n+                .filter_map(|it| {\n+                    let name = it.ident().map(|ident| ident.name);\n+                    if name.is_none() {\n+                        sess.span_diagnostic.span_err(it.span(),\n+                            \"allow internal unstable expects feature names\")\n+                    }\n+                    name\n                 })\n-            );\n-        let allow_internal_unsafe = attr::contains_name(&def.attrs, sym::allow_internal_unsafe);\n-        let mut local_inner_macros = false;\n-        if let Some(macro_export) = attr::find_by_name(&def.attrs, sym::macro_export) {\n-            if let Some(l) = macro_export.meta_item_list() {\n-                local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n-            }\n-        }\n+                .collect::<Vec<Symbol>>().into()\n+            )\n+            .unwrap_or_else(|| {\n+                sess.span_diagnostic.span_warn(\n+                    attr.span, \"allow_internal_unstable expects list of feature names. In the \\\n+                    future this will become a hard error. Please use `allow_internal_unstable(\\\n+                    foo, bar)` to only allow the `foo` and `bar` features\",\n+                );\n+                vec![sym::allow_internal_unstable_backcompat_hack].into()\n+            })\n+        );\n \n-        let unstable_feature = attr::find_stability(&sess,\n-                                                    &def.attrs, def.span).and_then(|stability| {\n-            if let attr::StabilityLevel::Unstable { issue, .. } = stability.level {\n-                Some((stability.feature, issue))\n-            } else {\n-                None\n-            }\n-        });\n-\n-        NormalTT {\n-            expander,\n-            def_info: Some((def.id, def.span)),\n-            allow_internal_unstable,\n-            allow_internal_unsafe,\n-            local_inner_macros,\n-            unstable_feature,\n-            edition,\n+    let allow_internal_unsafe = attr::contains_name(&def.attrs, sym::allow_internal_unsafe);\n+\n+    let mut local_inner_macros = false;\n+    if let Some(macro_export) = attr::find_by_name(&def.attrs, sym::macro_export) {\n+        if let Some(l) = macro_export.meta_item_list() {\n+            local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n         }\n-    } else {\n-        let is_transparent = attr::contains_name(&def.attrs, sym::rustc_transparent_macro);\n+    }\n \n-        SyntaxExtension::DeclMacro {\n-            expander,\n-            def_info: Some((def.id, def.span)),\n-            is_transparent,\n-            edition,\n+    let unstable_feature = attr::find_stability(&sess,\n+                                                &def.attrs, def.span).and_then(|stability| {\n+        if let attr::StabilityLevel::Unstable { issue, .. } = stability.level {\n+            Some((stability.feature, issue))\n+        } else {\n+            None\n         }\n+    });\n+\n+    SyntaxExtension::LegacyBang {\n+        expander,\n+        def_info: Some((def.id, def.span)),\n+        transparency,\n+        allow_internal_unstable,\n+        allow_internal_unsafe,\n+        local_inner_macros,\n+        unstable_feature,\n+        edition,\n     }\n }\n "}, {"sha": "cf54eacc3d46c8d715218c557f79a9c603750881", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -1,8 +1,8 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n use rustc_data_structures::sync::Lrc;\n-use syntax::ast;\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver};\n+use syntax::ast::{self, MetaItem};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver, MultiItemModifier};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n@@ -39,9 +39,25 @@ pub mod partial_ord;\n #[path=\"cmp/ord.rs\"]\n pub mod ord;\n \n-\n pub mod generic;\n \n+struct BuiltinDerive(\n+    fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable))\n+);\n+\n+impl MultiItemModifier for BuiltinDerive {\n+    fn expand(&self,\n+              ecx: &mut ExtCtxt<'_>,\n+              span: Span,\n+              meta_item: &MetaItem,\n+              item: Annotatable)\n+              -> Vec<Annotatable> {\n+        let mut items = Vec::new();\n+        (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n+        items\n+    }\n+}\n+\n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n         pub fn is_builtin_trait(name: ast::Name) -> bool {\n@@ -55,7 +71,7 @@ macro_rules! derive_traits {\n             $(\n                 resolver.add_builtin(\n                     ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n-                    Lrc::new(SyntaxExtension::BuiltinDerive($func))\n+                    Lrc::new(SyntaxExtension::LegacyDerive(Box::new(BuiltinDerive($func))))\n                 );\n             )*\n         }"}, {"sha": "7c4085aa09653326dafcf09902b055d346a5f7c6", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -41,7 +41,9 @@ pub mod proc_macro_impl;\n \n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension, MultiModifier};\n+\n+use syntax::ext::base::{MacroExpanderFn, NamedSyntaxExtension, SyntaxExtension};\n+use syntax::ext::hygiene::Transparency;\n use syntax::edition::Edition;\n use syntax::symbol::{sym, Symbol};\n \n@@ -56,9 +58,10 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n             register(Symbol::intern(stringify!($name)),\n-                     NormalTT {\n+                     SyntaxExtension::LegacyBang {\n                         expander: Box::new($f as MacroExpanderFn),\n                         def_info: None,\n+                        transparency: Transparency::SemiTransparent,\n                         allow_internal_unstable: None,\n                         allow_internal_unsafe: false,\n                         local_inner_macros: false,\n@@ -93,25 +96,27 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n         assert: assert::expand_assert,\n     }\n \n-    register(sym::test_case, MultiModifier(Box::new(test_case::expand)));\n-    register(sym::test, MultiModifier(Box::new(test::expand_test)));\n-    register(sym::bench, MultiModifier(Box::new(test::expand_bench)));\n+    register(sym::test_case, SyntaxExtension::LegacyAttr(Box::new(test_case::expand)));\n+    register(sym::test, SyntaxExtension::LegacyAttr(Box::new(test::expand_test)));\n+    register(sym::bench, SyntaxExtension::LegacyAttr(Box::new(test::expand_bench)));\n \n     // format_args uses `unstable` things internally.\n     register(Symbol::intern(\"format_args\"),\n-             NormalTT {\n+             SyntaxExtension::LegacyBang {\n                 expander: Box::new(format::expand_format_args),\n                 def_info: None,\n+                transparency: Transparency::SemiTransparent,\n                 allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n                 allow_internal_unsafe: false,\n                 local_inner_macros: false,\n                 unstable_feature: None,\n                 edition,\n             });\n     register(sym::format_args_nl,\n-             NormalTT {\n+             SyntaxExtension::LegacyBang {\n                  expander: Box::new(format::expand_format_args_nl),\n                  def_info: None,\n+                 transparency: Transparency::SemiTransparent,\n                  allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n                  allow_internal_unsafe: false,\n                  local_inner_macros: false,"}, {"sha": "4d6ff47a3ee918666b944fd64676f1043982221d", "filename": "src/test/run-pass-fulldeps/auxiliary/custom-derive-partial-eq.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-partial-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-partial-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-partial-eq.rs?ref=b81986c2af9c2569828f1234d4c4772cc8cb8950", "patch": "@@ -1,71 +0,0 @@\n-// force-host\n-\n-#![feature(plugin_registrar, rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_ext;\n-extern crate rustc_plugin;\n-\n-use syntax_ext::deriving;\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n-\n-use rustc_plugin::Registry;\n-use syntax::ast::*;\n-use syntax::source_map::Span;\n-use syntax::ext::base::*;\n-use syntax::ext::build::AstBuilder;\n-use syntax::symbol::Symbol;\n-use syntax::ptr::P;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(Symbol::intern(\"derive_CustomPartialEq\"),\n-                                  MultiDecorator(Box::new(expand_deriving_partial_eq)));\n-}\n-\n-fn expand_deriving_partial_eq(cx: &mut ExtCtxt, span: Span, mitem: &MetaItem, item: &Annotatable,\n-                              push: &mut FnMut(Annotatable)) {\n-    // structures are equal if all fields are equal, and non equal, if\n-    // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_fold(true,\n-                |cx, span, subexpr, self_f, other_fs| {\n-                    let other_f = (other_fs.len(), other_fs.get(0)).1.unwrap();\n-                    let eq = cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone());\n-                    cx.expr_binary(span, BinOpKind::And, subexpr, eq)\n-                },\n-                cx.expr_bool(span, true),\n-                Box::new(|cx, span, _, _| cx.expr_bool(span, false)),\n-                cx,\n-                span,\n-                substr)\n-    }\n-\n-    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n-    let attrs = vec![cx.attribute(span, inline)];\n-    let methods = vec![MethodDef {\n-        name: \"eq\",\n-        generics: LifetimeBounds::empty(),\n-        explicit_self: borrowed_explicit_self(),\n-        args: vec![(borrowed_self(), \"other\")],\n-        ret_ty: Literal(deriving::generic::ty::Path::new_local(\"bool\")),\n-        attributes: attrs,\n-        is_unsafe: false,\n-        unify_fieldless_variants: true,\n-        combine_substructure: combine_substructure(Box::new(cs_eq)),\n-    }];\n-\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: Vec::new(),\n-        path: deriving::generic::ty::Path::new(vec![\"cmp\", \"PartialEq\"]),\n-        additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n-        is_unsafe: false,\n-        supports_unions: false,\n-        methods: methods,\n-        associated_types: Vec::new(),\n-    };\n-    trait_def.expand(cx, mitem, item, push)\n-}"}, {"sha": "c6b33fbc75ee23dbd29e30c3a5c2ff325eea6a95", "filename": "src/test/run-pass-fulldeps/auxiliary/custom-derive-plugin-attr.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs?ref=b81986c2af9c2569828f1234d4c4772cc8cb8950", "patch": "@@ -1,84 +0,0 @@\n-// force-host\n-\n-#![feature(plugin_registrar)]\n-#![feature(box_syntax)]\n-#![feature(rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_ext;\n-extern crate syntax_pos;\n-extern crate rustc;\n-extern crate rustc_plugin;\n-\n-use syntax::ast;\n-use syntax::attr;\n-use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n-use syntax::ext::build::AstBuilder;\n-use syntax::symbol::{Symbol, sym};\n-use syntax::ptr::P;\n-use syntax_ext::deriving::generic::{TraitDef, MethodDef, combine_substructure};\n-use syntax_ext::deriving::generic::{Substructure, Struct, EnumMatching};\n-use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n-use syntax_pos::Span;\n-use rustc_plugin::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"rustc_derive_TotalSum\"),\n-        MultiDecorator(box expand));\n-}\n-\n-fn expand(cx: &mut ExtCtxt,\n-          span: Span,\n-          mitem: &ast::MetaItem,\n-          item: &Annotatable,\n-          push: &mut FnMut(Annotatable)) {\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: vec![],\n-        path: Path::new_local(\"TotalSum\"),\n-        additional_bounds: vec![],\n-        generics: LifetimeBounds::empty(),\n-        associated_types: vec![],\n-        is_unsafe: false,\n-        supports_unions: false,\n-        methods: vec![\n-            MethodDef {\n-                name: \"total_sum\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec![],\n-                ret_ty: Literal(Path::new_local(\"isize\")),\n-                attributes: vec![],\n-                is_unsafe: false,\n-                unify_fieldless_variants: true,\n-                combine_substructure: combine_substructure(Box::new(totalsum_substructure)),\n-            },\n-        ],\n-    };\n-\n-    trait_def.expand(cx, mitem, item, push)\n-}\n-\n-// Mostly copied from syntax::ext::deriving::hash\n-/// Defines how the implementation for `trace()` is to be generated\n-fn totalsum_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                         substr: &Substructure) -> P<ast::Expr> {\n-    let fields = match *substr.fields {\n-        Struct(_, ref fs) | EnumMatching(.., ref fs) => fs,\n-        _ => cx.span_bug(trait_span, \"impossible substructure\")\n-    };\n-\n-    fields.iter().fold(cx.expr_isize(trait_span, 0), |acc, ref item| {\n-        if attr::contains_name(&item.attrs, sym::ignore) {\n-            acc\n-        } else {\n-            cx.expr_binary(item.span, ast::BinOpKind::Add, acc,\n-                           cx.expr_method_call(item.span,\n-                                               item.self_.clone(),\n-                                               substr.method_ident,\n-                                               Vec::new()))\n-        }\n-    })\n-}"}, {"sha": "874a0ec7c13fba640680bc324d34e4521b1fd89e", "filename": "src/test/run-pass-fulldeps/auxiliary/custom-derive-plugin.rs", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin.rs?ref=b81986c2af9c2569828f1234d4c4772cc8cb8950", "patch": "@@ -1,76 +0,0 @@\n-// force-host\n-\n-#![feature(plugin_registrar)]\n-#![feature(box_syntax)]\n-#![feature(rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_ext;\n-extern crate syntax_pos;\n-extern crate rustc;\n-extern crate rustc_plugin;\n-\n-use syntax::ast;\n-use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n-use syntax::ext::build::AstBuilder;\n-use syntax::symbol::Symbol;\n-use syntax_ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n-use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n-use syntax_pos::Span;\n-use rustc_plugin::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"derive_TotalSum\"),\n-        MultiDecorator(box expand));\n-\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"derive_Nothing\"),\n-        MultiDecorator(box noop));\n-}\n-\n-fn noop(_: &mut ExtCtxt, _: Span, _: &ast::MetaItem, _: &Annotatable, _: &mut FnMut(Annotatable)) {}\n-\n-fn expand(cx: &mut ExtCtxt,\n-          span: Span,\n-          mitem: &ast::MetaItem,\n-          item: &Annotatable,\n-          push: &mut FnMut(Annotatable)) {\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: vec![],\n-        path: Path::new_local(\"TotalSum\"),\n-        additional_bounds: vec![],\n-        generics: LifetimeBounds::empty(),\n-        associated_types: vec![],\n-        is_unsafe: false,\n-        supports_unions: false,\n-        methods: vec![\n-            MethodDef {\n-                name: \"total_sum\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec![],\n-                ret_ty: Literal(Path::new_local(\"isize\")),\n-                attributes: vec![],\n-                is_unsafe: false,\n-                unify_fieldless_variants: true,\n-                combine_substructure: combine_substructure(box |cx, span, substr| {\n-                    let zero = cx.expr_isize(span, 0);\n-                    cs_fold(false,\n-                            |cx, span, subexpr, field, _| {\n-                                cx.expr_binary(span, ast::BinOpKind::Add, subexpr,\n-                                    cx.expr_method_call(span, field,\n-                                        ast::Ident::from_str(\"total_sum\"), vec![]))\n-                            },\n-                            zero,\n-                            box |cx, span, _, _| { cx.span_bug(span, \"wtf??\"); },\n-                            cx, span, substr)\n-                }),\n-            },\n-        ],\n-    };\n-\n-    trait_def.expand(cx, mitem, item, push)\n-}"}, {"sha": "330459fc08f551cfdb9b099c46009898458cd1fd", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin-args.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -10,11 +10,10 @@ extern crate rustc_plugin;\n \n use std::borrow::ToOwned;\n use syntax::ast;\n-use syntax::ext::hygiene;\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacEager, NormalTT};\n+use syntax::ext::base::{SyntaxExtension, TTMacroExpander, ExtCtxt, MacResult, MacEager};\n+use syntax::ext::hygiene::Transparency;\n use syntax::print::pprust;\n-use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenStream;\n@@ -29,7 +28,7 @@ impl TTMacroExpander for Expander {\n                    ecx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    _: TokenStream,\n-                   _: Option<Span>) -> Box<MacResult+'cx> {\n+                   _: Option<Span>) -> Box<dyn MacResult+'cx> {\n         let args = self.args.iter().map(|i| pprust::meta_list_item_to_string(i))\n             .collect::<Vec<_>>().join(\", \");\n         MacEager::expr(ecx.expr_str(sp, Symbol::intern(&args)))\n@@ -40,9 +39,10 @@ impl TTMacroExpander for Expander {\n pub fn plugin_registrar(reg: &mut Registry) {\n     let args = reg.args().to_owned();\n     reg.register_syntax_extension(Symbol::intern(\"plugin_args\"),\n-        NormalTT {\n+        SyntaxExtension::LegacyBang {\n             expander: Box::new(Expander { args: args, }),\n             def_info: None,\n+            transparency: Transparency::SemiTransparent,\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,"}, {"sha": "ac8fff4f6bfad0c49b0407dc389117163c79d51b", "filename": "src/test/run-pass-fulldeps/custom-derive-partial-eq.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs?ref=b81986c2af9c2569828f1234d4c4772cc8cb8950", "patch": "@@ -1,10 +0,0 @@\n-// aux-build:custom-derive-partial-eq.rs\n-// ignore-stage1\n-#![feature(plugin)]\n-#![plugin(custom_derive_partial_eq)]\n-#![allow(unused)]\n-\n-#[derive_CustomPartialEq] // Check that this is not a stability error.\n-enum E { V1, V2 }\n-\n-fn main() {}"}, {"sha": "38eaa71dd6abaa8fd455ac27c7b229b6cdd85864", "filename": "src/test/run-pass-fulldeps/derive-totalsum-attr.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs?ref=b81986c2af9c2569828f1234d4c4772cc8cb8950", "patch": "@@ -1,64 +0,0 @@\n-// aux-build:custom-derive-plugin-attr.rs\n-// ignore-stage1\n-\n-#![feature(plugin, rustc_attrs)]\n-#![plugin(custom_derive_plugin_attr)]\n-\n-trait TotalSum {\n-    fn total_sum(&self) -> isize;\n-}\n-\n-impl TotalSum for isize {\n-    fn total_sum(&self) -> isize {\n-        *self\n-    }\n-}\n-\n-struct Seven;\n-\n-impl TotalSum for Seven {\n-    fn total_sum(&self) -> isize {\n-        7\n-    }\n-}\n-\n-#[rustc_derive_TotalSum]\n-struct Foo {\n-    seven: Seven,\n-    bar: Bar,\n-    baz: isize,\n-    #[ignore]\n-    nan: NaN,\n-}\n-\n-#[rustc_derive_TotalSum]\n-struct Bar {\n-    quux: isize,\n-    bleh: isize,\n-    #[ignore]\n-    nan: NaN2\n-}\n-\n-struct NaN;\n-\n-impl TotalSum for NaN {\n-    fn total_sum(&self) -> isize {\n-        panic!();\n-    }\n-}\n-\n-struct NaN2;\n-\n-pub fn main() {\n-    let v = Foo {\n-        seven: Seven,\n-        bar: Bar {\n-            quux: 9,\n-            bleh: 3,\n-            nan: NaN2\n-        },\n-        baz: 80,\n-        nan: NaN\n-    };\n-    assert_eq!(v.total_sum(), 99);\n-}"}, {"sha": "2b0bb51d90aec59a345e384140c3074aaada1613", "filename": "src/test/run-pass-fulldeps/derive-totalsum.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum.rs?ref=b81986c2af9c2569828f1234d4c4772cc8cb8950", "patch": "@@ -1,49 +0,0 @@\n-// aux-build:custom-derive-plugin.rs\n-// ignore-stage1\n-\n-#![feature(plugin)]\n-#![plugin(custom_derive_plugin)]\n-\n-trait TotalSum {\n-    fn total_sum(&self) -> isize;\n-}\n-\n-impl TotalSum for isize {\n-    fn total_sum(&self) -> isize {\n-        *self\n-    }\n-}\n-\n-struct Seven;\n-\n-impl TotalSum for Seven {\n-    fn total_sum(&self) -> isize {\n-        7\n-    }\n-}\n-\n-#[derive_TotalSum]\n-struct Foo {\n-    seven: Seven,\n-    bar: Bar,\n-    baz: isize,\n-}\n-\n-#[derive_TotalSum]\n-struct Bar {\n-    quux: isize,\n-    bleh: isize,\n-}\n-\n-\n-pub fn main() {\n-    let v = Foo {\n-        seven: Seven,\n-        bar: Bar {\n-            quux: 9,\n-            bleh: 3,\n-        },\n-        baz: 80,\n-    };\n-    assert_eq!(v.total_sum(), 99);\n-}"}, {"sha": "133f6302bde57cf15834f7801b95f6f9e2c526d3", "filename": "src/test/run-pass-fulldeps/issue-40663.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fissue-40663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81986c2af9c2569828f1234d4c4772cc8cb8950/src%2Ftest%2Frun-pass-fulldeps%2Fissue-40663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-40663.rs?ref=b81986c2af9c2569828f1234d4c4772cc8cb8950", "patch": "@@ -1,13 +0,0 @@\n-#![allow(dead_code)]\n-// aux-build:custom-derive-plugin.rs\n-// ignore-stage1\n-\n-#![feature(plugin)]\n-#![plugin(custom_derive_plugin)]\n-\n-#[derive_Nothing]\n-#[derive_Nothing]\n-#[derive_Nothing]\n-struct S;\n-\n-fn main() {}"}, {"sha": "93cc97d45830b2a9ae9a651c535eb272fb4be198", "filename": "src/test/ui/macros/nonterminal-matching.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Ftest%2Fui%2Fmacros%2Fnonterminal-matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4419a8b05f4b5793f2dca801c83db576d8b39f4/src%2Ftest%2Fui%2Fmacros%2Fnonterminal-matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fnonterminal-matching.stderr?ref=b4419a8b05f4b5793f2dca801c83db576d8b39f4", "patch": "@@ -1,6 +1,9 @@\n error: no rules expected the token `enum E { }`\n   --> $DIR/nonterminal-matching.rs:19:10\n    |\n+LL |     macro n(a $nt_item b) {\n+   |     --------------------- when calling this macro\n+...\n LL |     n!(a $nt_item b);\n    |          ^^^^^^^^ no rules expected this token in macro call\n ..."}]}