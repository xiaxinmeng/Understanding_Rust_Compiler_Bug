{"sha": "82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZGJhM2Q0MTlkM2NmYWMwMGNjOTBiYzhkMDc4ZTZhZTBhNzI0ZjU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-25T23:27:54Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-20T11:21:07Z"}, "message": "Refactor hir::GenericParam as a struct", "tree": {"sha": "a9957cd9109080725a5ffd4e8615901ed16443b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9957cd9109080725a5ffd4e8615901ed16443b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "html_url": "https://github.com/rust-lang/rust/commit/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d643946550fa349729184a4f70abc01e21ceddc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d643946550fa349729184a4f70abc01e21ceddc0", "html_url": "https://github.com/rust-lang/rust/commit/d643946550fa349729184a4f70abc01e21ceddc0"}], "stats": {"total": 1270, "additions": 704, "deletions": 566}, "files": [{"sha": "4c24c7afd735cbca702c47b15d171f02e01ea4b1", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -743,26 +743,25 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v TyPar\n }\n \n pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam) {\n-    match *param {\n-        GenericParam::Lifetime(ref ld) => {\n-            visitor.visit_id(ld.lifetime.id);\n-            match ld.lifetime.name {\n+    visitor.visit_id(param.id);\n+    match param.kind {\n+        GenericParamKind::Lifetime { ref bounds, ref lifetime_deprecated, .. } => {\n+            match lifetime_deprecated.name {\n                 LifetimeName::Name(name) => {\n-                    visitor.visit_name(ld.lifetime.span, name);\n+                    visitor.visit_name(param.span, name);\n                 }\n                 LifetimeName::Fresh(_) |\n                 LifetimeName::Static |\n                 LifetimeName::Implicit |\n                 LifetimeName::Underscore => {}\n             }\n-            walk_list!(visitor, visit_lifetime, &ld.bounds);\n-        }\n-        GenericParam::Type(ref ty_param) => {\n-            visitor.visit_id(ty_param.id);\n-            visitor.visit_name(ty_param.span, ty_param.name);\n-            walk_list!(visitor, visit_ty_param_bound, &ty_param.bounds);\n-            walk_list!(visitor, visit_ty, &ty_param.default);\n-            walk_list!(visitor, visit_attribute, ty_param.attrs.iter());\n+            walk_list!(visitor, visit_lifetime, bounds);\n+        }\n+        GenericParamKind::Type { name, ref bounds, ref default, ref attrs, .. } => {\n+            visitor.visit_name(param.span, name);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_ty, default);\n+            walk_list!(visitor, visit_attribute, attrs.iter());\n         }\n     }\n }"}, {"sha": "0c5c79e8e600d22505d18ba66af7757e70453698", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 110, "deletions": 101, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -116,7 +116,7 @@ pub struct LoweringContext<'a> {\n     // When traversing a signature such as `fn foo(x: impl Trait)`,\n     // we record `impl Trait` as a new type parameter, then later\n     // add it on to `foo`s generics.\n-    in_band_ty_params: Vec<hir::TyParam>,\n+    in_band_ty_params: Vec<hir::GenericParam>,\n \n     // Used to create lifetime definitions from in-band lifetime usages.\n     // e.g. `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n@@ -695,22 +695,23 @@ impl<'a> LoweringContext<'a> {\n                     span,\n                 );\n \n-                hir::GenericParam::Lifetime(hir::LifetimeDef {\n-                    lifetime: hir::Lifetime {\n-                        id: def_node_id,\n-                        span,\n-                        name: hir_name,\n-                    },\n-                    bounds: Vec::new().into(),\n+                hir::GenericParam {\n+                    id: def_node_id,\n+                    span,\n                     pure_wrt_drop: false,\n-                    in_band: true,\n-                })\n+                    kind: hir::GenericParamKind::Lifetime {\n+                        name: hir_name,\n+                        bounds: vec![].into(),\n+                        in_band: true,\n+                        lifetime_deprecated: hir::Lifetime {\n+                            id: def_node_id,\n+                            span,\n+                            name: hir_name,\n+                        }\n+                    }\n+                }\n             })\n-            .chain(\n-                in_band_ty_params\n-                    .into_iter()\n-                    .map(|tp| hir::GenericParam::Type(tp)),\n-            )\n+            .chain(in_band_ty_params.into_iter())\n             .collect();\n \n         (params, res)\n@@ -778,12 +779,12 @@ impl<'a> LoweringContext<'a> {\n     // This should only be used with generics that have already had their\n     // in-band lifetimes added. In practice, this means that this function is\n     // only used when lowering a child item of a trait or impl.\n-    fn with_parent_impl_lifetime_defs<T, F>(&mut self, lt_defs: &[hir::LifetimeDef], f: F) -> T\n+    fn with_parent_impl_lifetime_defs<T, F>(&mut self, params: &[hir::GenericParam], f: F) -> T\n     where\n         F: FnOnce(&mut LoweringContext) -> T,\n     {\n         let old_len = self.in_scope_lifetimes.len();\n-        let lt_def_names = lt_defs.iter().map(|lt_def| lt_def.lifetime.name.name());\n+        let lt_def_names = params.iter().map(|param| param.name());\n         self.in_scope_lifetimes.extend(lt_def_names);\n \n         let res = f(self);\n@@ -1252,15 +1253,17 @@ impl<'a> LoweringContext<'a> {\n                         let hir_bounds = self.lower_bounds(bounds, itctx);\n                         // Set the name to `impl Bound1 + Bound2`\n                         let name = Symbol::intern(&pprust::ty_to_string(t));\n-                        self.in_band_ty_params.push(hir::TyParam {\n-                            name,\n+                        self.in_band_ty_params.push(hir::GenericParam {\n                             id: def_node_id,\n-                            bounds: hir_bounds,\n-                            default: None,\n                             span,\n                             pure_wrt_drop: false,\n-                            synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                            attrs: P::new(),\n+                            kind: hir::GenericParamKind::Type {\n+                                name,\n+                                bounds: hir_bounds,\n+                                default: None,\n+                                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                                attrs: P::new(),\n+                            }\n                         });\n \n                         hir::TyPath(hir::QPath::Resolved(\n@@ -1367,10 +1370,10 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_generic_param(&mut self, param: &'v hir::GenericParam) {\n                 // Record the introduction of 'a in `for<'a> ...`\n-                if let hir::GenericParam::Lifetime(ref lt_def) = *param {\n+                if let hir::GenericParamKind::Lifetime { name, .. } = param.kind {\n                     // Introduce lifetimes one at a time so that we can handle\n                     // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n-                    self.currently_bound_lifetimes.push(lt_def.lifetime.name);\n+                    self.currently_bound_lifetimes.push(name);\n                 }\n \n                 hir::intravisit::walk_generic_param(self, param);\n@@ -1416,18 +1419,22 @@ impl<'a> LoweringContext<'a> {\n                         Mark::root(),\n                         lifetime.span,\n                     );\n-                    let def_lifetime = hir::Lifetime {\n+\n+                    self.output_lifetime_params.push(hir::GenericParam {\n                         id: def_node_id,\n                         span: lifetime.span,\n-                        name,\n-                    };\n-                    self.output_lifetime_params\n-                        .push(hir::GenericParam::Lifetime(hir::LifetimeDef {\n-                            lifetime: def_lifetime,\n-                            bounds: Vec::new().into(),\n-                            pure_wrt_drop: false,\n+                        pure_wrt_drop: false,\n+                        kind: hir::GenericParamKind::Lifetime {\n+                            name,\n+                            bounds: vec![].into(),\n                             in_band: false,\n-                        }));\n+                            lifetime_deprecated: hir::Lifetime {\n+                                id: def_node_id,\n+                                span: lifetime.span,\n+                                name,\n+                            }\n+                        }\n+                    });\n                 }\n             }\n         }\n@@ -1887,47 +1894,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ty_param(\n-        &mut self,\n-        tp: &TyParam,\n-        add_bounds: &[TyParamBound],\n-        itctx: ImplTraitContext,\n-    ) -> hir::TyParam {\n-        let mut name = self.lower_ident(tp.ident);\n-\n-        // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n-        // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n-        // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n-        if name == keywords::SelfType.name() {\n-            name = Symbol::gensym(\"Self\");\n-        }\n-\n-        let mut bounds = self.lower_bounds(&tp.bounds, itctx);\n-        if !add_bounds.is_empty() {\n-            bounds = bounds\n-                .into_iter()\n-                .chain(self.lower_bounds(add_bounds, itctx).into_iter())\n-                .collect();\n-        }\n-\n-        hir::TyParam {\n-            id: self.lower_node_id(tp.id).node_id,\n-            name,\n-            bounds,\n-            default: tp.default\n-                .as_ref()\n-                .map(|x| self.lower_ty(x, ImplTraitContext::Disallowed)),\n-            span: tp.ident.span,\n-            pure_wrt_drop: attr::contains_name(&tp.attrs, \"may_dangle\"),\n-            synthetic: tp.attrs\n-                .iter()\n-                .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n-                .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n-                .nth(0),\n-            attrs: self.lower_attrs(&tp.attrs),\n-        }\n-    }\n-\n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         let span = l.ident.span;\n         match self.lower_ident(l.ident) {\n@@ -1962,20 +1928,75 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_lifetime_def(&mut self, l: &LifetimeDef) -> hir::LifetimeDef {\n-        let was_collecting_in_band = self.is_collecting_in_band_lifetimes;\n-        self.is_collecting_in_band_lifetimes = false;\n+    fn lower_generic_param(&mut self,\n+                           param: &GenericParamAST,\n+                           add_bounds: &NodeMap<Vec<TyParamBound>>,\n+                           itctx: ImplTraitContext)\n+                           -> hir::GenericParam {\n+        match param {\n+            GenericParamAST::Lifetime(ref lifetime_def) => {\n+                let was_collecting_in_band = self.is_collecting_in_band_lifetimes;\n+                self.is_collecting_in_band_lifetimes = false;\n+\n+                let lifetime = self.lower_lifetime(&lifetime_def.lifetime);\n+                let param = hir::GenericParam {\n+                    id: lifetime.id,\n+                    span: lifetime.span,\n+                    pure_wrt_drop: attr::contains_name(&lifetime_def.attrs, \"may_dangle\"),\n+                    kind: hir::GenericParamKind::Lifetime {\n+                        name: lifetime.name,\n+                        bounds: lifetime_def.bounds\n+                                            .iter()\n+                                            .map(|lt| self.lower_lifetime(lt)).collect(),\n+                        in_band: false,\n+                        lifetime_deprecated: lifetime,\n+                    }\n+                };\n \n-        let def = hir::LifetimeDef {\n-            lifetime: self.lower_lifetime(&l.lifetime),\n-            bounds: l.bounds.iter().map(|l| self.lower_lifetime(l)).collect(),\n-            pure_wrt_drop: attr::contains_name(&l.attrs, \"may_dangle\"),\n-            in_band: false,\n-        };\n+                self.is_collecting_in_band_lifetimes = was_collecting_in_band;\n \n-        self.is_collecting_in_band_lifetimes = was_collecting_in_band;\n+                param\n+            }\n+            GenericParamAST::Type(ref ty_param) => {\n+                let mut name = self.lower_ident(ty_param.ident);\n+\n+                // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n+                // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n+                // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n+                if name == keywords::SelfType.name() {\n+                    name = Symbol::gensym(\"Self\");\n+                }\n+\n+                let mut bounds = self.lower_bounds(&ty_param.bounds, itctx);\n+                let add_bounds = add_bounds.get(&ty_param.id).map_or(&[][..], |x| &x);\n+                if !add_bounds.is_empty() {\n+                    bounds = bounds\n+                        .into_iter()\n+                        .chain(self.lower_bounds(add_bounds, itctx).into_iter())\n+                        .collect();\n+                }\n \n-        def\n+                hir::GenericParam {\n+                    id: self.lower_node_id(ty_param.id).node_id,\n+                    span: ty_param.ident.span,\n+                    pure_wrt_drop: attr::contains_name(&ty_param.attrs, \"may_dangle\"),\n+                    kind: hir::GenericParamKind::Type {\n+                        name,\n+                        bounds,\n+                        default: ty_param.default.as_ref()\n+                                         .map(|x| {\n+                                             self.lower_ty(x, ImplTraitContext::Disallowed)\n+                                         }),\n+                        synthetic: ty_param.attrs\n+                                           .iter()\n+                                           .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n+                                           .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n+                                           .nth(0),\n+                        attrs: self.lower_attrs(&ty_param.attrs),\n+                    }\n+                }\n+            }\n+        }\n     }\n \n     fn lower_generic_params(\n@@ -1984,19 +2005,7 @@ impl<'a> LoweringContext<'a> {\n         add_bounds: &NodeMap<Vec<TyParamBound>>,\n         itctx: ImplTraitContext,\n     ) -> hir::HirVec<hir::GenericParam> {\n-        params\n-            .iter()\n-            .map(|param| match *param {\n-                GenericParamAST::Lifetime(ref lifetime_def) => {\n-                    hir::GenericParam::Lifetime(self.lower_lifetime_def(lifetime_def))\n-                }\n-                GenericParamAST::Type(ref ty_param) => hir::GenericParam::Type(self.lower_ty_param(\n-                    ty_param,\n-                    add_bounds.get(&ty_param.id).map_or(&[][..], |x| &x),\n-                    itctx,\n-                )),\n-            })\n-            .collect()\n+        params.iter().map(|param| self.lower_generic_param(param, add_bounds, itctx)).collect()\n     }\n \n     fn lower_generics(&mut self, g: &Generics, itctx: ImplTraitContext) -> hir::Generics {\n@@ -2175,8 +2184,8 @@ impl<'a> LoweringContext<'a> {\n         let trait_ref = self.with_parent_impl_lifetime_defs(\n             &bound_generic_params\n                 .iter()\n-                .filter_map(|p| match *p {\n-                    hir::GenericParam::Lifetime(ref ld) => Some(ld.clone()),\n+                .filter_map(|param| match param.kind {\n+                    hir::GenericParamKind::Lifetime { .. } => Some(param.clone()),\n                     _ => None,\n                 })\n                 .collect::<Vec<_>>(),"}, {"sha": "d34924547ed66459f62014ce32a6ff6b949688d2", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             NodeBlock(n) => EntryBlock(parent, dep_node_index, n),\n             NodeStructCtor(n) => EntryStructCtor(parent, dep_node_index, n),\n             NodeLifetime(n) => EntryLifetime(parent, dep_node_index, n),\n-            NodeTyParam(n) => EntryTyParam(parent, dep_node_index, n),\n+            NodeGenericParam(n) => EntryGenericParam(parent, dep_node_index, n),\n             NodeVisibility(n) => EntryVisibility(parent, dep_node_index, n),\n             NodeLocal(n) => EntryLocal(parent, dep_node_index, n),\n             NodeMacroDef(n) => EntryMacroDef(dep_node_index, n),\n@@ -347,12 +347,12 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_generic_param(&mut self, param: &'hir GenericParam) {\n-        match *param {\n-            GenericParam::Lifetime(ref ld) => {\n-                self.insert(ld.lifetime.id, NodeLifetime(&ld.lifetime));\n+        match param.kind {\n+            GenericParamKind::Lifetime { ref lifetime_deprecated, .. } => {\n+                self.insert(param.id, NodeLifetime(lifetime_deprecated));\n             }\n-            GenericParam::Type(ref ty_param) => {\n-                self.insert(ty_param.id, NodeTyParam(ty_param));\n+            GenericParamKind::Type { .. } => {\n+                self.insert(param.id, NodeGenericParam(param));\n             }\n         }\n         intravisit::walk_generic_param(self, param);"}, {"sha": "c46f58137540f1a6e0ac34786346fecf96f08da1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -68,7 +68,7 @@ pub enum Node<'hir> {\n     NodeStructCtor(&'hir VariantData),\n \n     NodeLifetime(&'hir Lifetime),\n-    NodeTyParam(&'hir TyParam),\n+    NodeGenericParam(&'hir GenericParam),\n     NodeVisibility(&'hir Visibility),\n }\n \n@@ -96,7 +96,7 @@ enum MapEntry<'hir> {\n     EntryBlock(NodeId, DepNodeIndex, &'hir Block),\n     EntryStructCtor(NodeId, DepNodeIndex, &'hir VariantData),\n     EntryLifetime(NodeId, DepNodeIndex, &'hir Lifetime),\n-    EntryTyParam(NodeId, DepNodeIndex, &'hir TyParam),\n+    EntryGenericParam(NodeId, DepNodeIndex, &'hir GenericParam),\n     EntryVisibility(NodeId, DepNodeIndex, &'hir Visibility),\n     EntryLocal(NodeId, DepNodeIndex, &'hir Local),\n \n@@ -132,7 +132,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryBlock(id, _, _) => id,\n             EntryStructCtor(id, _, _) => id,\n             EntryLifetime(id, _, _) => id,\n-            EntryTyParam(id, _, _) => id,\n+            EntryGenericParam(id, _, _) => id,\n             EntryVisibility(id, _, _) => id,\n             EntryLocal(id, _, _) => id,\n \n@@ -160,7 +160,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryBlock(_, _, n) => NodeBlock(n),\n             EntryStructCtor(_, _, n) => NodeStructCtor(n),\n             EntryLifetime(_, _, n) => NodeLifetime(n),\n-            EntryTyParam(_, _, n) => NodeTyParam(n),\n+            EntryGenericParam(_, _, n) => NodeGenericParam(n),\n             EntryVisibility(_, _, n) => NodeVisibility(n),\n             EntryLocal(_, _, n) => NodeLocal(n),\n             EntryMacroDef(_, n) => NodeMacroDef(n),\n@@ -328,7 +328,7 @@ impl<'hir> Map<'hir> {\n             EntryBlock(_, dep_node_index, _) |\n             EntryStructCtor(_, dep_node_index, _) |\n             EntryLifetime(_, dep_node_index, _) |\n-            EntryTyParam(_, dep_node_index, _) |\n+            EntryGenericParam(_, dep_node_index, _) |\n             EntryVisibility(_, dep_node_index, _) |\n             EntryAnonConst(_, dep_node_index, _) |\n             EntryExpr(_, dep_node_index, _) |\n@@ -494,7 +494,7 @@ impl<'hir> Map<'hir> {\n                 Some(Def::Macro(self.local_def_id(macro_def.id),\n                                 MacroKind::Bang))\n             }\n-            NodeTyParam(param) => {\n+            NodeGenericParam(param) => {\n                 Some(Def::TyParam(self.local_def_id(param.id)))\n             }\n         }\n@@ -600,7 +600,7 @@ impl<'hir> Map<'hir> {\n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n             NodeItem(&Item { node: ItemTrait(..), .. }) => id,\n-            NodeTyParam(_) => self.get_parent_node(id),\n+            NodeGenericParam(_) => self.get_parent_node(id),\n             _ => {\n                 bug!(\"ty_param_owner: {} not a type parameter\",\n                     self.node_to_string(id))\n@@ -613,7 +613,7 @@ impl<'hir> Map<'hir> {\n             NodeItem(&Item { node: ItemTrait(..), .. }) => {\n                 keywords::SelfType.name()\n             }\n-            NodeTyParam(tp) => tp.name,\n+            NodeGenericParam(param) => param.name(),\n             _ => {\n                 bug!(\"ty_param_name: {} not a type parameter\",\n                     self.node_to_string(id))\n@@ -954,7 +954,7 @@ impl<'hir> Map<'hir> {\n             NodeVariant(v) => v.node.name,\n             NodeField(f) => f.ident.name,\n             NodeLifetime(lt) => lt.name.name(),\n-            NodeTyParam(tp) => tp.name,\n+            NodeGenericParam(param) => param.name(),\n             NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n@@ -974,7 +974,12 @@ impl<'hir> Map<'hir> {\n             Some(NodeField(ref f)) => Some(&f.attrs[..]),\n             Some(NodeExpr(ref e)) => Some(&*e.attrs),\n             Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n-            Some(NodeTyParam(tp)) => Some(&tp.attrs[..]),\n+            Some(NodeGenericParam(param)) => {\n+                match param.kind {\n+                    GenericParamKind::Type { ref attrs, .. } => Some(&attrs[..]),\n+                    _ => bug!(\"unexpected non-type NodeGenericParam\")\n+                }\n+            }\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n             Some(NodeStructCtor(_)) => {\n@@ -1021,7 +1026,7 @@ impl<'hir> Map<'hir> {\n             Some(EntryBlock(_, _, block)) => block.span,\n             Some(EntryStructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n             Some(EntryLifetime(_, _, lifetime)) => lifetime.span,\n-            Some(EntryTyParam(_, _, ty_param)) => ty_param.span,\n+            Some(EntryGenericParam(_, _, param)) => param.span,\n             Some(EntryVisibility(_, _, &Visibility::Restricted { ref path, .. })) => path.span,\n             Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(EntryLocal(_, _, local)) => local.span,\n@@ -1226,19 +1231,19 @@ impl<'hir> print::PpAnn for Map<'hir> {\n impl<'a> print::State<'a> {\n     pub fn print_node(&mut self, node: Node) -> io::Result<()> {\n         match node {\n-            NodeItem(a)        => self.print_item(&a),\n-            NodeForeignItem(a) => self.print_foreign_item(&a),\n-            NodeTraitItem(a)   => self.print_trait_item(a),\n-            NodeImplItem(a)    => self.print_impl_item(a),\n-            NodeVariant(a)     => self.print_variant(&a),\n-            NodeAnonConst(a)   => self.print_anon_const(&a),\n-            NodeExpr(a)        => self.print_expr(&a),\n-            NodeStmt(a)        => self.print_stmt(&a),\n-            NodeTy(a)          => self.print_type(&a),\n-            NodeTraitRef(a)    => self.print_trait_ref(&a),\n+            NodeItem(a)         => self.print_item(&a),\n+            NodeForeignItem(a)  => self.print_foreign_item(&a),\n+            NodeTraitItem(a)    => self.print_trait_item(a),\n+            NodeImplItem(a)     => self.print_impl_item(a),\n+            NodeVariant(a)      => self.print_variant(&a),\n+            NodeAnonConst(a)    => self.print_anon_const(&a),\n+            NodeExpr(a)         => self.print_expr(&a),\n+            NodeStmt(a)         => self.print_stmt(&a),\n+            NodeTy(a)           => self.print_type(&a),\n+            NodeTraitRef(a)     => self.print_trait_ref(&a),\n             NodeBinding(a)       |\n-            NodePat(a)         => self.print_pat(&a),\n-            NodeBlock(a)       => {\n+            NodePat(a)          => self.print_pat(&a),\n+            NodeBlock(a)        => {\n                 use syntax::print::pprust::PrintState;\n \n                 // containing cbox, will be closed by print-block at }\n@@ -1247,16 +1252,16 @@ impl<'a> print::State<'a> {\n                 self.ibox(0)?;\n                 self.print_block(&a)\n             }\n-            NodeLifetime(a)    => self.print_lifetime(&a),\n-            NodeVisibility(a)  => self.print_visibility(&a),\n-            NodeTyParam(_)     => bug!(\"cannot print TyParam\"),\n-            NodeField(_)       => bug!(\"cannot print StructField\"),\n+            NodeLifetime(a)     => self.print_lifetime(&a),\n+            NodeVisibility(a)   => self.print_visibility(&a),\n+            NodeGenericParam(_) => bug!(\"cannot print NodeGenericParam\"),\n+            NodeField(_)        => bug!(\"cannot print StructField\"),\n             // these cases do not carry enough information in the\n             // hir_map to reconstruct their full structure for pretty\n             // printing.\n-            NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n-            NodeLocal(a)       => self.print_local_decl(&a),\n-            NodeMacroDef(_)    => bug!(\"cannot print MacroDef\"),\n+            NodeStructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n+            NodeLocal(a)        => self.print_local_decl(&a),\n+            NodeMacroDef(_)     => bug!(\"cannot print MacroDef\"),\n         }\n     }\n }\n@@ -1371,8 +1376,8 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeLifetime(_)) => {\n             format!(\"lifetime {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeTyParam(ref ty_param)) => {\n-            format!(\"typaram {:?}{}\", ty_param, id_str)\n+        Some(NodeGenericParam(ref param)) => {\n+            format!(\"genericparam {:?}{}\", param, id_str)\n         }\n         Some(NodeVisibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)"}, {"sha": "6a0301a556fb103d0c1f9c49cc983eecad06a0cd", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 84, "deletions": 113, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -53,8 +53,6 @@ use rustc_data_structures::sync::{ParallelIterator, par_iter, Send, Sync, scope}\n use serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::BTreeMap;\n use std::fmt;\n-use std::iter;\n-use std::slice;\n \n /// HIR doesn't commit to a concrete storage type and has its own alias for a vector.\n /// It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar\n@@ -242,6 +240,24 @@ impl LifetimeName {\n             Name(name) => name,\n         }\n     }\n+\n+    fn is_elided(&self) -> bool {\n+        use self::LifetimeName::*;\n+        match self {\n+            Implicit | Underscore => true,\n+\n+            // It might seem surprising that `Fresh(_)` counts as\n+            // *not* elided -- but this is because, as far as the code\n+            // in the compiler is concerned -- `Fresh(_)` variants act\n+            // equivalently to \"some fresh name\". They correspond to\n+            // early-bound regions on an impl, in other words.\n+            Fresh(_) | Static | Name(_) => false,\n+        }\n+    }\n+\n+    fn is_static(&self) -> bool {\n+        self == &LifetimeName::Static\n+    }\n }\n \n impl fmt::Debug for Lifetime {\n@@ -255,36 +271,14 @@ impl fmt::Debug for Lifetime {\n \n impl Lifetime {\n     pub fn is_elided(&self) -> bool {\n-        use self::LifetimeName::*;\n-        match self.name {\n-            Implicit | Underscore => true,\n-\n-            // It might seem surprising that `Fresh(_)` counts as\n-            // *not* elided -- but this is because, as far as the code\n-            // in the compiler is concerned -- `Fresh(_)` variants act\n-            // equivalently to \"some fresh name\". They correspond to\n-            // early-bound regions on an impl, in other words.\n-            Fresh(_) | Static | Name(_) => false,\n-        }\n+        self.name.is_elided()\n     }\n \n     pub fn is_static(&self) -> bool {\n-        self.name == LifetimeName::Static\n+        self.name.is_static()\n     }\n }\n \n-/// A lifetime definition, eg `'a: 'b+'c+'d`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct LifetimeDef {\n-    pub lifetime: Lifetime,\n-    pub bounds: HirVec<Lifetime>,\n-    pub pure_wrt_drop: bool,\n-    // Indicates that the lifetime definition was synthetically added\n-    // as a result of an in-band lifetime usage like\n-    // `fn foo(x: &'a u8) -> &'a u8 { x }`\n-    pub in_band: bool,\n-}\n-\n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n@@ -466,70 +460,62 @@ pub enum TraitBoundModifier {\n pub type TyParamBounds = HirVec<TyParamBound>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct TyParam {\n-    pub name: Name,\n+pub enum GenericParamKind {\n+    /// A lifetime definition, eg `'a: 'b + 'c + 'd`.\n+    Lifetime {\n+        /// Either \"'a\", referring to a named lifetime definition,\n+        /// or \"\" (aka keywords::Invalid), for elision placeholders.\n+        ///\n+        /// HIR lowering inserts these placeholders in type paths that\n+        /// refer to type definitions needing lifetime parameters,\n+        /// `&T` and `&mut T`, and trait objects without `... + 'a`.\n+        name: LifetimeName,\n+        bounds: HirVec<Lifetime>,\n+        // Indicates that the lifetime definition was synthetically added\n+        // as a result of an in-band lifetime usage like:\n+        // `fn foo(x: &'a u8) -> &'a u8 { x }`\n+        in_band: bool,\n+        // We keep a `Lifetime` around for now just so we can `visit_lifetime`.\n+        lifetime_deprecated: Lifetime,\n+    },\n+    Type {\n+        name: Name,\n+        bounds: TyParamBounds,\n+        default: Option<P<Ty>>,\n+        synthetic: Option<SyntheticTyParamKind>,\n+        attrs: HirVec<Attribute>,\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct GenericParam {\n     pub id: NodeId,\n-    pub bounds: TyParamBounds,\n-    pub default: Option<P<Ty>>,\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n-    pub synthetic: Option<SyntheticTyParamKind>,\n-    pub attrs: HirVec<Attribute>,\n-}\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum GenericParam {\n-    Lifetime(LifetimeDef),\n-    Type(TyParam),\n+    pub kind: GenericParamKind,\n }\n \n impl GenericParam {\n     pub fn is_lifetime_param(&self) -> bool {\n-        match *self {\n-            GenericParam::Lifetime(_) => true,\n+        match self.kind {\n+            GenericParamKind::Lifetime { .. } => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_type_param(&self) -> bool {\n-        match *self {\n-            GenericParam::Type(_) => true,\n+        match self.kind {\n+            GenericParamKind::Type { .. } => true,\n             _ => false,\n         }\n     }\n-}\n \n-pub trait GenericParamsExt {\n-    fn lifetimes<'a>(&'a self) -> iter::FilterMap<\n-        slice::Iter<GenericParam>,\n-        fn(&GenericParam) -> Option<&LifetimeDef>,\n-    >;\n-\n-    fn ty_params<'a>(&'a self) -> iter::FilterMap<\n-        slice::Iter<GenericParam>,\n-        fn(&GenericParam) -> Option<&TyParam>,\n-    >;\n-}\n-\n-impl GenericParamsExt for [GenericParam] {\n-    fn lifetimes<'a>(&'a self) -> iter::FilterMap<\n-        slice::Iter<GenericParam>,\n-        fn(&GenericParam) -> Option<&LifetimeDef>,\n-    > {\n-        self.iter().filter_map(|param| match *param {\n-            GenericParam::Lifetime(ref l) => Some(l),\n-            _ => None,\n-        })\n-    }\n-\n-    fn ty_params<'a>(&'a self) -> iter::FilterMap<\n-        slice::Iter<GenericParam>,\n-        fn(&GenericParam) -> Option<&TyParam>,\n-    > {\n-        self.iter().filter_map(|param| match *param {\n-            GenericParam::Type(ref t) => Some(t),\n-            _ => None,\n-        })\n+    pub fn name(&self) -> Name {\n+        match self.kind {\n+            GenericParamKind::Lifetime { name, .. } => name.name(),\n+            GenericParamKind::Type { name, .. } => name,\n+        }\n     }\n }\n \n@@ -555,54 +541,39 @@ impl Generics {\n     }\n \n     pub fn is_lt_parameterized(&self) -> bool {\n-        self.params.iter().any(|param| param.is_lifetime_param())\n+        self.params.iter().any(|param| {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => true,\n+                _ => false,\n+            }\n+        })\n     }\n \n     pub fn is_type_parameterized(&self) -> bool {\n-        self.params.iter().any(|param| param.is_type_param())\n-    }\n-\n-    pub fn lifetimes<'a>(&'a self) -> impl DoubleEndedIterator<Item = &'a LifetimeDef> {\n-        self.params.lifetimes()\n-    }\n-\n-    pub fn ty_params<'a>(&'a self) -> impl DoubleEndedIterator<Item = &'a TyParam> {\n-        self.params.ty_params()\n+        self.params.iter().any(|param| {\n+            match param.kind {\n+                GenericParamKind::Type { .. } => true,\n+                _ => false,\n+            }\n+        })\n     }\n-}\n-\n-pub enum UnsafeGeneric {\n-    Region(LifetimeDef, &'static str),\n-    Type(TyParam, &'static str),\n-}\n \n-impl UnsafeGeneric {\n-    pub fn attr_name(&self) -> &'static str {\n-        match *self {\n-            UnsafeGeneric::Region(_, s) => s,\n-            UnsafeGeneric::Type(_, s) => s,\n-        }\n+    pub fn lifetimes<'a>(&'a self) -> impl DoubleEndedIterator<Item = &'a GenericParam> {\n+        self.params.iter().filter(|param| {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => true,\n+                _ => false,\n+            }\n+        })\n     }\n-}\n \n-impl Generics {\n-    pub fn carries_unsafe_attr(&self) -> Option<UnsafeGeneric> {\n-        for param in &self.params {\n-            match *param {\n-                GenericParam::Lifetime(ref l) => {\n-                    if l.pure_wrt_drop {\n-                        return Some(UnsafeGeneric::Region(l.clone(), \"may_dangle\"));\n-                    }\n-                }\n-                GenericParam::Type(ref t) => {\n-                    if t.pure_wrt_drop {\n-                        return Some(UnsafeGeneric::Type(t.clone(), \"may_dangle\"));\n-                    }\n-                }\n+    pub fn ty_params<'a>(&'a self) -> impl DoubleEndedIterator<Item = &'a GenericParam> {\n+        self.params.iter().filter(|param| {\n+            match param.kind {\n+                GenericParamKind::Type { .. } => true,\n+                _ => false,\n             }\n-        }\n-\n-        None\n+        })\n     }\n }\n "}, {"sha": "afb3a6d0e6c48c554c80f2ba03bd23db98a93b38", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -25,7 +25,7 @@ use syntax_pos::{self, BytePos, FileName};\n \n use hir;\n use hir::{PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier, RangeEnd};\n-use hir::GenericArg;\n+use hir::{GenericParam, GenericParamKind, GenericArg};\n \n use std::cell::Cell;\n use std::io::{self, Write, Read};\n@@ -2094,50 +2094,49 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_lifetime(&mut self, lifetime: &hir::Lifetime) -> io::Result<()> {\n-        self.print_name(lifetime.name.name())\n-    }\n-\n-    pub fn print_lifetime_def(&mut self, lifetime: &hir::LifetimeDef) -> io::Result<()> {\n-        self.print_lifetime(&lifetime.lifetime)?;\n-        let mut sep = \":\";\n-        for v in &lifetime.bounds {\n-            self.s.word(sep)?;\n-            self.print_lifetime(v)?;\n-            sep = \"+\";\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn print_generic_params(&mut self, generic_params: &[hir::GenericParam]) -> io::Result<()> {\n+    pub fn print_generic_params(&mut self, generic_params: &[GenericParam]) -> io::Result<()> {\n         if !generic_params.is_empty() {\n             self.s.word(\"<\")?;\n \n             self.commasep(Inconsistent, generic_params, |s, param| {\n-                match *param {\n-                    hir::GenericParam::Lifetime(ref ld) => s.print_lifetime_def(ld),\n-                    hir::GenericParam::Type(ref tp) => s.print_ty_param(tp),\n-                }\n+                s.print_generic_param(param)\n             })?;\n \n             self.s.word(\">\")?;\n         }\n         Ok(())\n     }\n \n-    pub fn print_ty_param(&mut self, param: &hir::TyParam) -> io::Result<()> {\n-        self.print_name(param.name)?;\n-        self.print_bounds(\":\", &param.bounds)?;\n-        match param.default {\n-            Some(ref default) => {\n-                self.s.space()?;\n-                self.word_space(\"=\")?;\n-                self.print_type(&default)\n+    pub fn print_generic_param(&mut self, param: &GenericParam) -> io::Result<()> {\n+        self.print_name(param.name())?;\n+        match param.kind {\n+            GenericParamKind::Lifetime { ref bounds, .. } => {\n+                let mut sep = \":\";\n+                for bound in bounds {\n+                    self.s.word(sep)?;\n+                    self.print_lifetime(bound)?;\n+                    sep = \"+\";\n+                }\n+                Ok(())\n+            }\n+            GenericParamKind::Type { ref bounds, ref default, .. } => {\n+                self.print_bounds(\":\", bounds)?;\n+                match default {\n+                    Some(default) => {\n+                        self.s.space()?;\n+                        self.word_space(\"=\")?;\n+                        self.print_type(&default)\n+                    }\n+                    _ => Ok(()),\n+                }\n             }\n-            _ => Ok(()),\n         }\n     }\n \n+    pub fn print_lifetime(&mut self, lifetime: &hir::Lifetime) -> io::Result<()> {\n+        self.print_name(lifetime.name.name())\n+    }\n+\n     pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause) -> io::Result<()> {\n         if where_clause.predicates.is_empty() {\n             return Ok(());"}, {"sha": "ea12db8681c716ee37bf59636d7934ef983a1173", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -161,13 +161,6 @@ impl_stable_hash_for!(struct hir::Lifetime {\n     name\n });\n \n-impl_stable_hash_for!(struct hir::LifetimeDef {\n-    lifetime,\n-    bounds,\n-    pure_wrt_drop,\n-    in_band\n-});\n-\n impl_stable_hash_for!(struct hir::Path {\n     span,\n     def,\n@@ -201,21 +194,36 @@ impl_stable_hash_for!(enum hir::TraitBoundModifier {\n     Maybe\n });\n \n-impl_stable_hash_for!(struct hir::TyParam {\n-    name,\n+impl_stable_hash_for!(struct hir::GenericParam {\n     id,\n-    bounds,\n-    default,\n     span,\n     pure_wrt_drop,\n-    synthetic,\n-    attrs\n+    kind\n });\n \n-impl_stable_hash_for!(enum hir::GenericParam {\n-    Lifetime(lifetime_def),\n-    Type(ty_param)\n-});\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::GenericParamKind {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            hir::GenericParamKind::Lifetime { name, ref bounds, in_band,\n+                                              ref lifetime_deprecated } => {\n+                name.hash_stable(hcx, hasher);\n+                bounds.hash_stable(hcx, hasher);\n+                in_band.hash_stable(hcx, hasher);\n+                lifetime_deprecated.hash_stable(hcx, hasher);\n+            }\n+            hir::GenericParamKind::Type { name, ref bounds, ref default, synthetic, attrs } => {\n+                name.hash_stable(hcx, hasher);\n+                bounds.hash_stable(hcx, hasher);\n+                default.hash_stable(hcx, hasher);\n+                synthetic.hash_stable(hcx, hasher);\n+                attrs.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n \n impl_stable_hash_for!(struct hir::Generics {\n     params,"}, {"sha": "af38e8ba2d492a1b2aa4ffc1f1536bc475fce297", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -61,7 +61,7 @@ use super::region_constraints::GenericKind;\n use super::lexical_region_resolve::RegionResolutionError;\n \n use std::fmt;\n-use hir;\n+use hir::{self, GenericParamKind};\n use hir::map as hir_map;\n use hir::def_id::DefId;\n use middle::region;\n@@ -1036,8 +1036,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // Get the `hir::TyParam` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n-                            let has_lifetimes = if let hir_map::NodeTyParam(ref p) = hir.get(id) {\n-                                p.bounds.len() > 0\n+                            let has_lifetimes =\n+                                if let hir_map::NodeGenericParam(ref param) = hir.get(id) {\n+                                match param.kind {\n+                                    GenericParamKind::Type { ref bounds, .. } => {\n+                                        !bounds.is_empty()\n+                                    }\n+                                    _ => bug!(\"unexpected non-type NodeGenericParam\"),\n+                                }\n                             } else {\n                                 false\n                             };"}, {"sha": "76680b205355b5853236eb477d27d24741d59a58", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 178, "deletions": 117, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -35,7 +35,7 @@ use syntax_pos::Span;\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n \n use hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use hir::{self, GenericParamsExt};\n+use hir::{self, GenericParamKind};\n \n /// The origin of a named lifetime definition.\n ///\n@@ -86,28 +86,38 @@ impl Region {\n     fn early(\n         hir_map: &Map,\n         index: &mut u32,\n-        def: &hir::LifetimeDef,\n+        param: &hir::GenericParam,\n     ) -> (hir::LifetimeName, Region) {\n         let i = *index;\n         *index += 1;\n-        let def_id = hir_map.local_def_id(def.lifetime.id);\n-        let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n+        let def_id = hir_map.local_def_id(param.id);\n+        let (name, origin) = match param.kind {\n+            GenericParamKind::Lifetime { name, in_band, .. } => {\n+                (name, LifetimeDefOrigin::from_is_in_band(in_band))\n+            }\n+            _ => bug!(\"expected a lifetime param\"),\n+        };\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (def.lifetime.name, Region::EarlyBound(i, def_id, origin))\n+        (name, Region::EarlyBound(i, def_id, origin))\n     }\n \n-    fn late(hir_map: &Map, def: &hir::LifetimeDef) -> (hir::LifetimeName, Region) {\n+    fn late(hir_map: &Map, param: &hir::GenericParam) -> (hir::LifetimeName, Region) {\n         let depth = ty::INNERMOST;\n-        let def_id = hir_map.local_def_id(def.lifetime.id);\n-        let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n+        let def_id = hir_map.local_def_id(param.id);\n+        let (name, origin) = match param.kind {\n+            GenericParamKind::Lifetime { name, in_band, .. } => {\n+                (name, LifetimeDefOrigin::from_is_in_band(in_band))\n+            }\n+            _ => bug!(\"expected a lifetime param\"),\n+        };\n         debug!(\n             \"Region::late: def={:?} depth={:?} def_id={:?} origin={:?}\",\n             def,\n             depth,\n             def_id,\n             origin,\n         );\n-        (def.lifetime.name, Region::LateBound(depth, def_id, origin))\n+        (name, Region::LateBound(depth, def_id, origin))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -567,9 +577,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.is_in_fn_syntax = true;\n                 let scope = Scope::Binder {\n                     lifetimes: c.generic_params\n-                        .lifetimes()\n-                        .map(|def| Region::late(&self.tcx.hir, def))\n-                        .collect(),\n+                                .iter()\n+                                .filter_map(|param| {\n+                                    match param.kind {\n+                                        GenericParamKind::Lifetime { .. } => {\n+                                            Some(Region::late(&self.tcx.hir, param))\n+                                        }\n+                                        _ => None,\n+                                    }\n+                                })\n+                                .collect(),\n                     s: self.scope,\n                     next_early_index,\n                     track_lifetime_uses: true,\n@@ -850,10 +867,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             self.tcx,\n             &generics.lifetimes().cloned().collect::<Vec<_>>(),\n         );\n-        for ty_param in generics.ty_params() {\n-            walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n-            if let Some(ref ty) = ty_param.default {\n-                self.visit_ty(&ty);\n+        for param in &generics.params {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => {}\n+                GenericParamKind::Type { ref bounds, ref default, .. } => {\n+                    walk_list!(self, visit_ty_param_bound, bounds);\n+                    if let Some(ref ty) = default {\n+                        self.visit_ty(&ty);\n+                    }\n+                }\n             }\n         }\n         for predicate in &generics.where_clause.predicates {\n@@ -869,8 +891,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n                             lifetimes: bound_generic_params\n-                                .lifetimes()\n-                                .map(|def| Region::late(&self.tcx.hir, def))\n+                                .iter()\n+                                .filter_map(|param| {\n+                                    match param.kind {\n+                                        GenericParamKind::Lifetime { .. } => {\n+                                            Some(Region::late(&self.tcx.hir, param))\n+                                        }\n+                                        _ => None,\n+                                    }\n+                                })\n                                 .collect(),\n                             s: self.scope,\n                             next_early_index,\n@@ -936,8 +965,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             let scope = Scope::Binder {\n                 lifetimes: trait_ref\n                     .bound_generic_params\n-                    .lifetimes()\n-                    .map(|def| Region::late(&self.tcx.hir, def))\n+                    .iter()\n+                    .filter_map(|param| {\n+                        match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {\n+                                Some(Region::late(&self.tcx.hir, param))\n+                            }\n+                            _ => None,\n+                        }\n+                    })\n                     .collect(),\n                 s: self.scope,\n                 next_early_index,\n@@ -987,10 +1023,10 @@ fn original_lifetime(span: Span) -> Original {\n         span: span,\n     }\n }\n-fn shadower_lifetime(l: &hir::Lifetime) -> Shadower {\n+fn shadower_lifetime(param: &hir::GenericParam) -> Shadower {\n     Shadower {\n         kind: ShadowKind::Lifetime,\n-        span: l.span,\n+        span: param.span,\n     }\n }\n \n@@ -1005,23 +1041,29 @@ impl ShadowKind {\n \n fn check_mixed_explicit_and_in_band_defs(\n     tcx: TyCtxt<'_, '_, '_>,\n-    lifetime_defs: &[hir::LifetimeDef],\n+    params: &[hir::GenericParam],\n ) {\n-    let oob_def = lifetime_defs.iter().find(|lt| !lt.in_band);\n-    let in_band_def = lifetime_defs.iter().find(|lt| lt.in_band);\n+    let in_bands: Vec<_> = params.iter().map(|param| {\n+        match param.kind {\n+            GenericParamKind::Lifetime { in_band, .. } => (in_band, param.span),\n+            _ => bug!(\"expected lifetime param\"),\n+        }\n+    }).collect();\n+    let out_of_band = in_bands.iter().find(|(in_band, _)| !in_band);\n+    let in_band = in_bands.iter().find(|(in_band, _)| *in_band);\n \n-    if let (Some(oob_def), Some(in_band_def)) = (oob_def, in_band_def) {\n+    if let (Some((_, out_of_band_span)), Some((_, in_band_span)))\n+        = (out_of_band, in_band) {\n         struct_span_err!(\n             tcx.sess,\n-            in_band_def.lifetime.span,\n+            *in_band_span,\n             E0688,\n             \"cannot mix in-band and explicit lifetime definitions\"\n         ).span_label(\n-            in_band_def.lifetime.span,\n+            *in_band_span,\n             \"in-band lifetime definition here\",\n-        )\n-            .span_label(oob_def.lifetime.span, \"explicit lifetime definition here\")\n-            .emit();\n+        ).span_label(*out_of_band_span, \"explicit lifetime definition here\")\n+        .emit();\n     }\n }\n \n@@ -1178,8 +1220,6 @@ fn compute_object_lifetime_defaults(\n                                 .lifetimes()\n                                 .nth(i as usize)\n                                 .unwrap()\n-                                .lifetime\n-                                .name\n                                 .name()\n                                 .to_string(),\n                             Set1::One(_) => bug!(),\n@@ -1213,58 +1253,67 @@ fn object_lifetime_defaults_for_item(\n         }\n     }\n \n-    generics\n-        .ty_params()\n-        .map(|param| {\n-            let mut set = Set1::Empty;\n+    generics.params.iter().filter_map(|param| {\n+        match param.kind {\n+            GenericParamKind::Lifetime { .. } => None,\n+            GenericParamKind::Type { ref bounds, .. } => {\n+                let mut set = Set1::Empty;\n \n-            add_bounds(&mut set, &param.bounds);\n+                add_bounds(&mut set, &bounds);\n \n-            let param_def_id = tcx.hir.local_def_id(param.id);\n-            for predicate in &generics.where_clause.predicates {\n-                // Look for `type: ...` where clauses.\n-                let data = match *predicate {\n-                    hir::WherePredicate::BoundPredicate(ref data) => data,\n-                    _ => continue,\n-                };\n+                let param_def_id = tcx.hir.local_def_id(param.id);\n+                for predicate in &generics.where_clause.predicates {\n+                    // Look for `type: ...` where clauses.\n+                    let data = match *predicate {\n+                        hir::WherePredicate::BoundPredicate(ref data) => data,\n+                        _ => continue,\n+                    };\n \n-                // Ignore `for<'a> type: ...` as they can change what\n-                // lifetimes mean (although we could \"just\" handle it).\n-                if !data.bound_generic_params.is_empty() {\n-                    continue;\n-                }\n+                    // Ignore `for<'a> type: ...` as they can change what\n+                    // lifetimes mean (although we could \"just\" handle it).\n+                    if !data.bound_generic_params.is_empty() {\n+                        continue;\n+                    }\n \n-                let def = match data.bounded_ty.node {\n-                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n-                    _ => continue,\n-                };\n+                    let def = match data.bounded_ty.node {\n+                        hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n+                        _ => continue,\n+                    };\n \n-                if def == Def::TyParam(param_def_id) {\n-                    add_bounds(&mut set, &data.bounds);\n+                    if def == Def::TyParam(param_def_id) {\n+                        add_bounds(&mut set, &data.bounds);\n+                    }\n                 }\n-            }\n \n-            match set {\n-                Set1::Empty => Set1::Empty,\n-                Set1::One(name) => {\n-                    if name == hir::LifetimeName::Static {\n-                        Set1::One(Region::Static)\n-                    } else {\n-                        generics\n-                            .lifetimes()\n+                Some(match set {\n+                    Set1::Empty => Set1::Empty,\n+                    Set1::One(name) => {\n+                        if name == hir::LifetimeName::Static {\n+                            Set1::One(Region::Static)\n+                        } else {\n+                            generics.params.iter().filter_map(|param| {\n+                                match param.kind {\n+                                    GenericParamKind::Lifetime { name, in_band, .. } => {\n+                                       Some((param.id, name, in_band))\n+                                    }\n+                                    _ => None,\n+                                }\n+                            })\n                             .enumerate()\n-                            .find(|&(_, def)| def.lifetime.name == name)\n-                            .map_or(Set1::Many, |(i, def)| {\n-                                let def_id = tcx.hir.local_def_id(def.lifetime.id);\n-                                let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n+                            .find(|&(_, (_, lt_name, _))| lt_name == name)\n+                            .map_or(Set1::Many, |(i, (id, _, in_band))| {\n+                                let def_id = tcx.hir.local_def_id(id);\n+                                let origin = LifetimeDefOrigin::from_is_in_band(in_band);\n                                 Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n                             })\n+                        }\n                     }\n-                }\n-                Set1::Many => Set1::Many,\n+                    Set1::Many => Set1::Many,\n+                })\n             }\n-        })\n-        .collect()\n+        }\n+    })\n+    .collect()\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n@@ -1438,11 +1487,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let lifetimes = generics\n             .lifetimes()\n-            .map(|def| {\n-                if self.map.late_bound.contains(&def.lifetime.id) {\n-                    Region::late(&self.tcx.hir, def)\n+            .map(|param| {\n+                if self.map.late_bound.contains(&param.id) {\n+                    Region::late(&self.tcx.hir, param)\n                 } else {\n-                    Region::early(&self.tcx.hir, &mut index, def)\n+                    Region::early(&self.tcx.hir, &mut index, param)\n                 }\n             })\n             .collect();\n@@ -1943,7 +1992,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             fn visit_generic_param(&mut self, param: &hir::GenericParam) {\n-                if let hir::GenericParam::Lifetime(_) = *param {\n+                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n                     // FIXME(eddyb) Do we want this? It only makes a difference\n                     // if this `for<'a>` lifetime parameter is never used.\n                     self.have_bound_regions = true;\n@@ -2160,20 +2209,26 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn check_lifetime_params(&mut self, old_scope: ScopeRef, params: &'tcx [hir::GenericParam]) {\n-        for (i, lifetime_i) in params.lifetimes().enumerate() {\n-            match lifetime_i.lifetime.name {\n+        let lifetimes: Vec<_> = params.iter().filter_map(|param| {\n+            match param.kind {\n+                GenericParamKind::Lifetime { name, .. } => Some((param, name)),\n+                _ => None,\n+            }\n+        }).collect();\n+        for (i, (lifetime_i, lifetime_i_name)) in lifetimes.iter().enumerate() {\n+            match lifetime_i_name {\n                 hir::LifetimeName::Static | hir::LifetimeName::Underscore => {\n                     let lifetime = lifetime_i.lifetime;\n-                    let name = lifetime.name.name();\n+                    let name = lifetime_i.name();\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n-                        lifetime.span,\n+                        lifetime_i.span,\n                         E0262,\n                         \"invalid lifetime parameter name: `{}`\",\n                         name\n                     );\n                     err.span_label(\n-                        lifetime.span,\n+                        lifetime_i.span,\n                         format!(\"{} is a reserved lifetime name\", name),\n                     );\n                     err.emit();\n@@ -2184,24 +2239,28 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             // It is a hard error to shadow a lifetime within the same scope.\n-            for lifetime_j in params.lifetimes().skip(i + 1) {\n-                if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n+            for (lifetime_j, lifetime_j_name) in lifetimes.iter().skip(i + 1) {\n+                if lifetime_i_name == lifetime_j_name {\n                     struct_span_err!(\n                         self.tcx.sess,\n-                        lifetime_j.lifetime.span,\n+                        lifetime_j.span,\n                         E0263,\n                         \"lifetime name `{}` declared twice in the same scope\",\n-                        lifetime_j.lifetime.name.name()\n-                    ).span_label(lifetime_j.lifetime.span, \"declared twice\")\n-                        .span_label(lifetime_i.lifetime.span, \"previous declaration here\")\n+                        lifetime_j.name()\n+                    ).span_label(lifetime_j.span, \"declared twice\")\n+                        .span_label(lifetime_i.span, \"previous declaration here\")\n                         .emit();\n                 }\n             }\n \n             // It is a soft error to shadow a lifetime within a parent scope.\n-            self.check_lifetime_def_for_shadowing(old_scope, &lifetime_i.lifetime);\n+            self.check_lifetime_param_for_shadowing(old_scope, &lifetime_i);\n \n-            for bound in &lifetime_i.bounds {\n+            let bounds = match lifetime_i.kind {\n+                GenericParamKind::Lifetime { ref bounds, .. } => bounds,\n+                _ => bug!(),\n+            };\n+            for bound in bounds {\n                 match bound.name {\n                     hir::LifetimeName::Underscore => {\n                         let mut err = struct_span_err!(\n@@ -2218,16 +2277,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         self.tcx\n                             .sess\n                             .struct_span_warn(\n-                                lifetime_i.lifetime.span.to(bound.span),\n+                                lifetime_i.span.to(bound.span),\n                                 &format!(\n                                     \"unnecessary lifetime parameter `{}`\",\n-                                    lifetime_i.lifetime.name.name()\n+                                    lifetime_i.name()\n                                 ),\n                             )\n                             .help(&format!(\n                                 \"you can use the `'static` lifetime directly, in place \\\n                                  of `{}`\",\n-                                lifetime_i.lifetime.name.name()\n+                                lifetime_i.name()\n                             ))\n                             .emit();\n                     }\n@@ -2241,24 +2300,29 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn check_lifetime_def_for_shadowing(\n+    fn check_lifetime_param_for_shadowing(\n         &self,\n         mut old_scope: ScopeRef,\n-        lifetime: &'tcx hir::Lifetime,\n+        param: &'tcx hir::GenericParam,\n     ) {\n         for &(label, label_span) in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n-            if lifetime.name.name() == label {\n+            if param.name() == label {\n                 signal_shadowing_problem(\n                     self.tcx,\n                     label,\n                     original_label(label_span),\n-                    shadower_lifetime(&lifetime),\n+                    shadower_lifetime(&param),\n                 );\n                 return;\n             }\n         }\n \n+        let name = match param.kind {\n+            GenericParamKind::Lifetime { name, .. } => name,\n+            _ => bug!(\"expected lifetime param\"),\n+        };\n+\n         loop {\n             match *old_scope {\n                 Scope::Body { s, .. }\n@@ -2274,14 +2338,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder {\n                     ref lifetimes, s, ..\n                 } => {\n-                    if let Some(&def) = lifetimes.get(&lifetime.name) {\n+                    if let Some(&def) = lifetimes.get(&name) {\n                         let node_id = self.tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             self.tcx,\n-                            lifetime.name.name(),\n+                            param.name(),\n                             original_lifetime(self.tcx.hir.span(node_id)),\n-                            shadower_lifetime(&lifetime),\n+                            shadower_lifetime(&param),\n                         );\n                         return;\n                     }\n@@ -2429,14 +2493,14 @@ fn insert_late_bound_lifetimes(\n     appears_in_where_clause.visit_generics(generics);\n \n     for param in &generics.params {\n-        match *param {\n-            hir::GenericParam::Lifetime(ref lifetime_def) => {\n-                if !lifetime_def.bounds.is_empty() {\n+        match param.kind {\n+            hir::GenericParamKind::Lifetime { ref bounds, .. } => {\n+                if !bounds.is_empty() {\n                     // `'a: 'b` means both `'a` and `'b` are referenced\n                     appears_in_where_clause.regions.insert(lifetime_def.lifetime.name);\n                 }\n             }\n-            hir::GenericParam::Type(_) => {}\n+            hir::GenericParamKind::Type { .. } => {}\n         }\n     }\n \n@@ -2450,7 +2514,10 @@ fn insert_late_bound_lifetimes(\n     // - do not appear in the where-clauses\n     // - are not implicitly captured by `impl Trait`\n     for lifetime in generics.lifetimes() {\n-        let name = lifetime.lifetime.name;\n+        let name = match lifetime.kind {\n+            GenericParamKind::Lifetime { name, .. } => name,\n+            _ => bug!(),\n+        };\n \n         // appears in the where clauses? early-bound.\n         if appears_in_where_clause.regions.contains(&name) {\n@@ -2464,18 +2531,12 @@ fn insert_late_bound_lifetimes(\n             continue;\n         }\n \n-        debug!(\n-            \"insert_late_bound_lifetimes: \\\n-             lifetime {:?} with id {:?} is late-bound\",\n-            lifetime.lifetime.name, lifetime.lifetime.id\n-        );\n+        debug!(\"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n+               name,\n+               lifetime.id);\n \n-        let inserted = map.late_bound.insert(lifetime.lifetime.id);\n-        assert!(\n-            inserted,\n-            \"visited lifetime {:?} twice\",\n-            lifetime.lifetime.id\n-        );\n+        let inserted = map.late_bound.insert(lifetime.id);\n+        assert!(inserted, \"visited lifetime {:?} twice\", lifetime.id);\n     }\n \n     return;"}, {"sha": "f456ab36799881bbe12e915ea24416e130ca0bda", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -18,7 +18,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax_pos::Span;\n \n-use rustc::hir::{self, PatKind};\n+use rustc::hir::{self, GenericParamKind, PatKind};\n use rustc::hir::intravisit::FnKind;\n \n #[derive(PartialEq)]\n@@ -147,9 +147,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n     }\n \n     fn check_generic_param(&mut self, cx: &LateContext, param: &hir::GenericParam) {\n-        if let hir::GenericParam::Type(ref gen) = *param {\n-            if gen.synthetic.is_none() {\n-                self.check_case(cx, \"type parameter\", gen.name, gen.span);\n+        match param.kind {\n+            GenericParamKind::Lifetime { .. } => {}\n+            GenericParamKind::Type { synthetic, .. } => {\n+                if synthetic.is_none() {\n+                    self.check_case(cx, \"type parameter\", param.name(), param.span);\n+                }\n             }\n         }\n     }\n@@ -253,13 +256,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_generic_param(&mut self, cx: &LateContext, param: &hir::GenericParam) {\n-        if let hir::GenericParam::Lifetime(ref ld) = *param {\n-            self.check_snake_case(\n-                cx,\n-                \"lifetime\",\n-                &ld.lifetime.name.name().as_str(),\n-                Some(ld.lifetime.span)\n-            );\n+        match param.kind {\n+            GenericParamKind::Lifetime { .. } => {\n+                self.check_snake_case(cx, \"lifetime\", &param.name().as_str(), Some(param.span));\n+            }\n+            GenericParamKind::Type { .. } => {}\n         }\n     }\n "}, {"sha": "b981d075d5344a0184a05c3eb01d3fc96f757b9d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -49,7 +49,7 @@ use syntax_pos::{BytePos, Span, SyntaxContext};\n use syntax::symbol::keywords;\n use syntax::errors::{Applicability, DiagnosticBuilder};\n \n-use rustc::hir::{self, PatKind};\n+use rustc::hir::{self, GenericParamKind, PatKind};\n use rustc::hir::intravisit::FnKind;\n \n use bad_style::{MethodLateContext, method_context};\n@@ -1531,9 +1531,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n         }\n         // The parameters must not have bounds\n         for param in type_alias_generics.params.iter() {\n-            let spans : Vec<_> = match param {\n-                &hir::GenericParam::Lifetime(ref l) => l.bounds.iter().map(|b| b.span).collect(),\n-                &hir::GenericParam::Type(ref ty) => ty.bounds.iter().map(|b| b.span()).collect(),\n+            let spans: Vec<_> = match param.kind {\n+                GenericParamKind::Lifetime { ref bounds, .. } => {\n+                    bounds.iter().map(|b| b.span).collect()\n+                }\n+                GenericParamKind::Type { ref bounds, .. } => {\n+                    bounds.iter().map(|b| b.span()).collect()\n+                }\n             };\n             if !spans.is_empty() {\n                 let mut err = cx.struct_span_lint("}, {"sha": "c1a22c353c7a88670de0ef4ea9336bbfdd0aaefc", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -1645,10 +1645,17 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n-        for ty_param in generics.ty_params() {\n-            let def_id = self.tcx.hir.local_def_id(ty_param.id);\n-            let has_default = Untracked(ty_param.default.is_some());\n-            self.record(def_id, IsolatedEncoder::encode_info_for_ty_param, (def_id, has_default));\n+        for param in &generics.params {\n+            match param.kind {\n+                hir::GenericParamKind::Lifetime { .. } => {}\n+                hir::GenericParamKind::Type { ref default, .. } => {\n+                    let def_id = self.tcx.hir.local_def_id(param.id);\n+                    let has_default = Untracked(default.is_some());\n+                    self.record(def_id,\n+                                IsolatedEncoder::encode_info_for_ty_param,\n+                                (def_id, has_default));\n+                }\n+            }\n         }\n     }\n "}, {"sha": "19ed04a7968430ad9e131c3ed6b2790ba5414300", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -22,7 +22,7 @@ extern crate rustc_typeck;\n extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n-use rustc::hir::{self, PatKind};\n+use rustc::hir::{self, GenericParamKind, PatKind};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -1268,9 +1268,14 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        for ty_param in generics.ty_params() {\n-            for bound in ty_param.bounds.iter() {\n-                self.check_ty_param_bound(bound)\n+        for param in &generics.params {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => {}\n+                GenericParamKind::Type { ref bounds, .. } => {\n+                    for bound in bounds {\n+                        self.check_ty_param_bound(bound);\n+                    }\n+                }\n             }\n         }\n         for predicate in &generics.where_clause.predicates {"}, {"sha": "f573ad7ef2753f7c2250039c306d1b320e3ddac7", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir::{self, ImplItemKind, TraitItemKind};\n+use rustc::hir::{self, GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc::infer::{self, InferOk};\n use rustc::ty::{self, TyCtxt, GenericParamDefKind};\n use rustc::ty::util::ExplicitSelf;\n@@ -843,19 +843,19 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         }\n                         let span = visitor.0?;\n \n-                        let param = impl_m.generics.params.iter().filter_map(|param| {\n-                            match param {\n-                                hir::GenericParam::Type(param) => {\n+                        let bounds = impl_m.generics.params.iter().find_map(|param| {\n+                            match param.kind {\n+                                GenericParamKind::Lifetime { .. } => None,\n+                                GenericParamKind::Type { ref bounds, .. } => {\n                                     if param.id == impl_node_id {\n-                                        Some(param)\n+                                        Some(bounds)\n                                     } else {\n                                         None\n                                     }\n-                                },\n-                                hir::GenericParam::Lifetime(..) => None,\n+                                }\n                             }\n-                        }).next()?;\n-                        let bounds = param.bounds.first()?.span().to(param.bounds.last()?.span());\n+                        })?;\n+                        let bounds = bounds.first()?.span().to(bounds.last()?.span());\n                         let bounds = tcx\n                             .sess\n                             .codemap()"}, {"sha": "0066e3ce846695564cb51b64f1bddc3cf96c6db9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -5188,9 +5188,8 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for (&used, param) in tps_used.iter().zip(generics.ty_params()) {\n         if !used {\n-            struct_span_err!(tcx.sess, param.span, E0091,\n-                \"type parameter `{}` is unused\",\n-                param.name)\n+            struct_span_err!(tcx.sess, param.span, E0091, \"type parameter `{}` is unused\",\n+                             param.name())\n                 .span_label(param.span, \"unused type parameter\")\n                 .emit();\n         }"}, {"sha": "8d2c1e07ec8e0dd7db821b5a5bf218b91ea99b4b", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -631,11 +631,8 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             continue;\n         }\n \n-        let (span, name) = match ast_generics.params[index] {\n-            hir::GenericParam::Lifetime(ref ld) => (ld.lifetime.span, ld.lifetime.name.name()),\n-            hir::GenericParam::Type(ref tp) => (tp.span, tp.name),\n-        };\n-        report_bivariance(tcx, span, name);\n+        let param = &ast_generics.params[index];\n+        report_bivariance(tcx, param.span, param.name());\n     }\n }\n "}, {"sha": "007ef4dee559ca69420b2d18be5a9eeaf989eefd", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -35,7 +35,14 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n \n             Some(trait_ref) => {\n                 let trait_def = self.tcx.trait_def(trait_ref.def_id);\n-                let unsafe_attr = impl_generics.and_then(|g| g.carries_unsafe_attr());\n+                let unsafe_attr = impl_generics.and_then(|g| {\n+                    for param in &g.params {\n+                        if param.pure_wrt_drop {\n+                            return Some(\"may_dangle\");\n+                        }\n+                    }\n+                    None\n+                });\n                 match (trait_def.unsafety, unsafe_attr, unsafety, polarity) {\n                     (Unsafety::Normal, None, Unsafety::Unsafe, hir::ImplPolarity::Positive) => {\n                         span_err!(self.tcx.sess,\n@@ -53,13 +60,14 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                                   trait_ref);\n                     }\n \n-                    (Unsafety::Normal, Some(g), Unsafety::Normal, hir::ImplPolarity::Positive) =>\n+                    (Unsafety::Normal, Some(attr_name), Unsafety::Normal,\n+                        hir::ImplPolarity::Positive) =>\n                     {\n                         span_err!(self.tcx.sess,\n                                   item.span,\n                                   E0569,\n                                   \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n-                                  g.attr_name());\n+                                  attr_name);\n                     }\n \n                     (_, _, Unsafety::Unsafe, hir::ImplPolarity::Negative) => {"}, {"sha": "36436d95e9f175c1b4977bfe0561ab106757c13c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 98, "deletions": 57, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -49,6 +49,7 @@ use syntax::feature_gate;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::{self, map as hir_map, CodegenFnAttrs, CodegenFnAttrFlags, Unsafety};\n+use rustc::hir::GenericParamKind;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n@@ -113,10 +114,15 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        for param in generics.ty_params() {\n-            if param.default.is_some() {\n-                let def_id = self.tcx.hir.local_def_id(param.id);\n-                self.tcx.type_of(def_id);\n+        for param in &generics.params {\n+            match param.kind {\n+                hir::GenericParamKind::Lifetime { .. } => {}\n+                hir::GenericParamKind::Type { ref default, .. } => {\n+                    if default.is_some() {\n+                        let def_id = self.tcx.hir.local_def_id(param.id);\n+                        self.tcx.type_of(def_id);\n+                    }\n+                }\n             }\n         }\n         intravisit::walk_generics(self, generics);\n@@ -308,9 +314,20 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n                                          -> Vec<ty::Predicate<'tcx>>\n     {\n         let from_ty_params =\n-            ast_generics.ty_params()\n-                .filter(|p| p.id == param_id)\n-                .flat_map(|p| p.bounds.iter())\n+            ast_generics.params.iter()\n+                .filter_map(|param| {\n+                    match param.kind {\n+                        GenericParamKind::Type { ref bounds, .. } => {\n+                            if param.id == param_id {\n+                                Some(bounds)\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                        _ => None\n+                    }\n+                })\n+                .flat_map(|bounds| bounds.iter())\n                 .flat_map(|b| predicates_from_bound(self, ty, b));\n \n         let from_where_clauses =\n@@ -740,9 +757,9 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             has_late_bound_regions: None,\n         };\n         for lifetime in generics.lifetimes() {\n-            let hir_id = tcx.hir.node_to_hir_id(lifetime.lifetime.id);\n+            let hir_id = tcx.hir.node_to_hir_id(lifetime.id);\n             if tcx.is_late_bound(hir_id) {\n-                return Some(lifetime.lifetime.span);\n+                return Some(lifetime.span);\n             }\n         }\n         visitor.visit_fn_decl(decl);\n@@ -883,12 +900,12 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut params: Vec<_> = opt_self.into_iter().collect();\n \n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n-    params.extend(early_lifetimes.enumerate().map(|(i, l)| {\n+    params.extend(early_lifetimes.enumerate().map(|(i, param)| {\n         ty::GenericParamDef {\n-            name: l.lifetime.name.name().as_interned_str(),\n+            name: param.name().as_interned_str(),\n             index: own_start + i as u32,\n-            def_id: tcx.hir.local_def_id(l.lifetime.id),\n-            pure_wrt_drop: l.pure_wrt_drop,\n+            def_id: tcx.hir.local_def_id(param.id),\n+            pure_wrt_drop: param.pure_wrt_drop,\n             kind: ty::GenericParamDefKind::Lifetime,\n         }\n     }));\n@@ -898,33 +915,39 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Now create the real type parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n-    params.extend(ast_generics.ty_params().enumerate().map(|(i, p)| {\n-        if p.name == keywords::SelfType.name() {\n-            span_bug!(p.span, \"`Self` should not be the name of a regular parameter\");\n-        }\n-\n-        if !allow_defaults && p.default.is_some() {\n-            if !tcx.features().default_type_parameter_fallback {\n-                tcx.lint_node(\n-                    lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n-                    p.id,\n-                    p.span,\n-                    &format!(\"defaults for type parameters are only allowed in `struct`, \\\n-                              `enum`, `type`, or `trait` definitions.\"));\n-            }\n-        }\n+    params.extend(ast_generics.ty_params().enumerate().map(|(i, param)| {\n+        match param.kind {\n+            GenericParamKind::Type { ref default, synthetic, .. } => {\n+                if param.name() == keywords::SelfType.name() {\n+                    span_bug!(param.span,\n+                              \"`Self` should not be the name of a regular parameter\");\n+                }\n \n-        ty::GenericParamDef {\n-            index: type_start + i as u32,\n-            name: p.name.as_interned_str(),\n-            def_id: tcx.hir.local_def_id(p.id),\n-            pure_wrt_drop: p.pure_wrt_drop,\n-            kind: ty::GenericParamDefKind::Type {\n-                has_default: p.default.is_some(),\n-                object_lifetime_default:\n-                    object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n-                synthetic: p.synthetic,\n-            },\n+                if !allow_defaults && default.is_some() {\n+                    if !tcx.features().default_type_parameter_fallback {\n+                        tcx.lint_node(\n+                            lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n+                            param.id,\n+                            param.span,\n+                            &format!(\"defaults for type parameters are only allowed in \\\n+                                      `struct`, `enum`, `type`, or `trait` definitions.\"));\n+                    }\n+                }\n+\n+                ty::GenericParamDef {\n+                    index: type_start + i as u32,\n+                    name: param.name().as_interned_str(),\n+                    def_id: tcx.hir.local_def_id(param.id),\n+                    pure_wrt_drop: param.pure_wrt_drop,\n+                    kind: ty::GenericParamDefKind::Type {\n+                        has_default: default.is_some(),\n+                        object_lifetime_default:\n+                            object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n+                        synthetic,\n+                    },\n+                }\n+            }\n+            _ => bug!()\n         }\n     }));\n \n@@ -1119,8 +1142,13 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         },\n \n-        NodeTyParam(&hir::TyParam { default: Some(ref ty), .. }) => {\n-            icx.to_ty(ty)\n+        NodeGenericParam(param) => {\n+            match param.kind {\n+                hir::GenericParamKind::Type { default: Some(ref ty), .. } => {\n+                    icx.to_ty(ty)\n+                }\n+                _ => bug!(\"unexpected non-type NodeGenericParam\"),\n+            }\n         }\n \n         x => {\n@@ -1274,15 +1302,18 @@ fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n /// `resolve_lifetime::early_bound_lifetimes`.\n fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    ast_generics: &'a hir::Generics)\n-    -> impl Iterator<Item=&'a hir::LifetimeDef> + Captures<'tcx>\n+    generics: &'a hir::Generics)\n+    -> impl Iterator<Item=&'a hir::GenericParam> + Captures<'tcx>\n {\n-    ast_generics\n-        .lifetimes()\n-        .filter(move |l| {\n-            let hir_id = tcx.hir.node_to_hir_id(l.lifetime.id);\n-            !tcx.is_late_bound(hir_id)\n-        })\n+    generics.params.iter().filter(move |param| {\n+        match param.kind {\n+            GenericParamKind::Lifetime { .. } => {\n+                let hir_id = tcx.hir.node_to_hir_id(param.id);\n+                !tcx.is_late_bound(hir_id)\n+            }\n+            _ => false,\n+        }\n+    })\n }\n \n fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1410,28 +1441,38 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut index = parent_count + has_own_self as u32;\n     for param in early_bound_lifetimes_from_generics(tcx, ast_generics) {\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: tcx.hir.local_def_id(param.lifetime.id),\n+            def_id: tcx.hir.local_def_id(param.id),\n             index,\n-            name: param.lifetime.name.name().as_interned_str(),\n+            name: param.name().as_interned_str(),\n         }));\n         index += 1;\n \n-        for bound in &param.bounds {\n-            let bound_region = AstConv::ast_region_to_region(&icx, bound, None);\n-            let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound_region));\n-            predicates.push(outlives.to_predicate());\n+        match param.kind {\n+            GenericParamKind::Lifetime { ref bounds, .. } => {\n+                for bound in bounds {\n+                    let bound_region = AstConv::ast_region_to_region(&icx, bound, None);\n+                    let outlives =\n+                        ty::Binder::bind(ty::OutlivesPredicate(region, bound_region));\n+                    predicates.push(outlives.to_predicate());\n+                }\n+            },\n+            _ => bug!(),\n         }\n     }\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n     for param in ast_generics.ty_params() {\n-        let param_ty = ty::ParamTy::new(index, param.name.as_interned_str()).to_ty(tcx);\n+        let param_ty = ty::ParamTy::new(index, param.name().as_interned_str()).to_ty(tcx);\n         index += 1;\n \n+        let bounds = match param.kind {\n+            GenericParamKind::Type { ref bounds, .. } => bounds,\n+            _ => bug!(),\n+        };\n         let bounds = compute_bounds(&icx,\n                                     param_ty,\n-                                    &param.bounds,\n+                                    bounds,\n                                     SizedByDefault::Yes,\n                                     param.span);\n         predicates.extend(bounds.predicates(tcx, param_ty));"}, {"sha": "fb005ba18e9f819c360c1522cda124e3381004c1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -76,6 +76,7 @@ This API is completely unstable and subject to change.\n #![feature(crate_visibility_modifier)]\n #![feature(from_ref)]\n #![feature(exhaustive_patterns)]\n+#![feature(iterator_find_map)]\n #![feature(quote)]\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "40fdd6d8d2de73bd66fc030cf3c836ffc7080855", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -1466,14 +1466,19 @@ pub struct TyParam {\n     pub synthetic: Option<hir::SyntheticTyParamKind>,\n }\n \n-impl Clean<TyParam> for hir::TyParam {\n+impl Clean<TyParam> for hir::GenericParam {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n-        TyParam {\n-            name: self.name.clean(cx),\n-            did: cx.tcx.hir.local_def_id(self.id),\n-            bounds: self.bounds.clean(cx),\n-            default: self.default.clean(cx),\n-            synthetic: self.synthetic,\n+        match self.kind {\n+            hir::GenericParamKind::Type { ref bounds, ref default, synthetic, .. } => {\n+                TyParam {\n+                    name: self.name().clean(cx),\n+                    did: cx.tcx.hir.local_def_id(self.id),\n+                    bounds: bounds.clean(cx),\n+                    default: default.clean(cx),\n+                    synthetic: synthetic,\n+                }\n+            }\n+            _ => panic!(),\n         }\n     }\n }\n@@ -1707,18 +1712,21 @@ impl Clean<Lifetime> for hir::Lifetime {\n     }\n }\n \n-impl Clean<Lifetime> for hir::LifetimeDef {\n+impl Clean<Lifetime> for hir::GenericParam {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n-        if self.bounds.len() > 0 {\n-            let mut s = format!(\"{}: {}\",\n-                                self.lifetime.name.name(),\n-                                self.bounds[0].name.name());\n-            for bound in self.bounds.iter().skip(1) {\n-                s.push_str(&format!(\" + {}\", bound.name.name()));\n+        match self.kind {\n+            hir::GenericParamKind::Lifetime { ref bounds, .. } => {\n+                if bounds.len() > 0 {\n+                    let mut s = format!(\"{}: {}\", self.name(), bounds[0].name.name());\n+                    for bound in bounds.iter().skip(1) {\n+                        s.push_str(&format!(\" + {}\", bound.name.name()));\n+                    }\n+                    Lifetime(s)\n+                } else {\n+                    Lifetime(self.name().to_string())\n+                }\n             }\n-            Lifetime(s)\n-        } else {\n-            Lifetime(self.lifetime.name.name().to_string())\n+            _ => panic!(),\n         }\n     }\n }\n@@ -1880,9 +1888,11 @@ impl GenericParamDef {\n \n impl Clean<GenericParamDef> for hir::GenericParam {\n     fn clean(&self, cx: &DocContext) -> GenericParamDef {\n-        match *self {\n-            hir::GenericParam::Lifetime(ref l) => GenericParamDef::Lifetime(l.clean(cx)),\n-            hir::GenericParam::Type(ref t) => GenericParamDef::Type(t.clean(cx)),\n+        match self.kind {\n+            hir::GenericParamKind::Lifetime { .. } => {\n+                GenericParamDef::Lifetime(self.clean(cx))\n+            }\n+            hir::GenericParamKind::Type { .. } => GenericParamDef::Type(self.clean(cx)),\n         }\n     }\n }\n@@ -1900,10 +1910,11 @@ impl Clean<Generics> for hir::Generics {\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n         fn is_impl_trait(param: &hir::GenericParam) -> bool {\n-            if let hir::GenericParam::Type(ref tp) = param {\n-                tp.synthetic == Some(hir::SyntheticTyParamKind::ImplTrait)\n-            } else {\n-                false\n+            match param.kind {\n+                hir::GenericParamKind::Type { synthetic, .. } => {\n+                    synthetic == Some(hir::SyntheticTyParamKind::ImplTrait)\n+                }\n+                _ => false,\n             }\n         }\n         let impl_trait_params = self.params\n@@ -2857,25 +2868,25 @@ impl Clean<Type> for hir::Ty {\n                             types: 0\n                         };\n                         for param in generics.params.iter() {\n-                            match param {\n-                                hir::GenericParam::Lifetime(lt_param) => {\n+                            match param.kind {\n+                                hir::GenericParamKind::Lifetime { .. } => {\n                                     if let Some(lt) = generic_args.lifetimes()\n                                         .nth(indices.lifetimes).cloned() {\n                                         if !lt.is_elided() {\n                                             let lt_def_id =\n-                                                cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n+                                                cx.tcx.hir.local_def_id(param.id);\n                                             lt_substs.insert(lt_def_id, lt.clean(cx));\n                                         }\n                                     }\n                                     indices.lifetimes += 1;\n                                 }\n-                                hir::GenericParam::Type(ty_param) => {\n+                                hir::GenericParamKind::Type { ref default, .. } => {\n                                     let ty_param_def =\n-                                        Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n+                                        Def::TyParam(cx.tcx.hir.local_def_id(param.id));\n                                     if let Some(ty) = generic_args.types()\n                                         .nth(indices.types).cloned() {\n                                         ty_substs.insert(ty_param_def, ty.into_inner().clean(cx));\n-                                    } else if let Some(default) = ty_param.default.clone() {\n+                                    } else if let Some(default) = default.clone() {\n                                         ty_substs.insert(ty_param_def,\n                                                          default.into_inner().clean(cx));\n                                     }"}, {"sha": "091673bfba99696ea8a90fbfebaf129e52b65d69", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -73,7 +73,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_expr(&mut self, ex: &'ast Expr) { walk_expr(self, ex) }\n     fn visit_expr_post(&mut self, _ex: &'ast Expr) { }\n     fn visit_ty(&mut self, t: &'ast Ty) { walk_ty(self, t) }\n-    fn visit_generic_param(&mut self, param: &'ast GenericParamAST) { walk_generic_param(self, param) }\n+    fn visit_generic_param(&mut self, param: &'ast GenericParamAST) {\n+        walk_generic_param(self, param)\n+    }\n     fn visit_generics(&mut self, g: &'ast Generics) { walk_generics(self, g) }\n     fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n         walk_where_predicate(self, p)"}, {"sha": "4bc8d208bab91fb5dabb9a6710e53ed6c33c9716", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -568,7 +568,8 @@ impl<'a> TraitDef<'a> {\n                         bounds.push((*declared_bound).clone());\n                     }\n \n-                    GenericParamAST::Type(cx.typaram(self.span, ty_param.ident, vec![], bounds, None))\n+                    let ty_param = cx.typaram(self.span, ty_param.ident, vec![], bounds, None);\n+                    GenericParamAST::Type(ty_param)\n                 }\n             }\n         }));"}, {"sha": "22487e7bfe398f80198dbd6adaca172f7de8567e", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "patch": "@@ -192,7 +192,9 @@ impl<'a> Ty<'a> {\n                 let ty_params: Vec<P<ast::Ty>> = self_generics.params\n                     .iter()\n                     .filter_map(|param| match *param {\n-                        GenericParamAST::Type(ref ty_param) => Some(cx.ty_ident(span, ty_param.ident)),\n+                        GenericParamAST::Type(ref ty_param) => {\n+                            Some(cx.ty_ident(span, ty_param.ident))\n+                        }\n                         _ => None,\n                     })\n                     .collect();\n@@ -280,7 +282,8 @@ impl<'a> LifetimeBounds<'a> {\n                 let bounds = bounds.iter()\n                     .map(|b| cx.lifetime(span, Ident::from_str(b)))\n                     .collect();\n-                GenericParamAST::Lifetime(cx.lifetime_def(span, Ident::from_str(lt), vec![], bounds))\n+                let lifetime_def = cx.lifetime_def(span, Ident::from_str(lt), vec![], bounds);\n+                GenericParamAST::Lifetime(lifetime_def)\n             })\n             .chain(self.bounds\n                 .iter()"}]}