{"sha": "0fb5d9d87a1d23563b8311feb4f97cb85894b8f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmYjVkOWQ4N2ExZDIzNTYzYjgzMTFmZWI0Zjk3Y2I4NTg5NGI4ZjA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-28T11:03:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-28T11:03:47Z"}, "message": "Merge #6033\n\n6033: Make name resolution resolve proc macros instead of relying purely on the build system r=matklad a=jonas-schievink\n\nThis makes name resolution look at proc-macro declaration attributes like `#[proc_macro_derive]` and defines the right proc macro in the macro namespace, fixing unresolved custom derives like `thiserror::Error` (which can cause false positives, now that we emit diagnostics for unresolved imports).\r\n\r\nThis works even when proc-macro support is turned off, in which case we fall back to a dummy expander that always returns an error. IMO this is the right way to handle at least the name resolution part of proc. macros, while the *expansion* itself should rely on the build system to build and provide the macro DLL. It does mean that they may go out of sync, but we can provide diagnostics if that happens (something like \"could not find macro X in crate Y \u2013 ensure that all files of crate Y are saved\").\r\n\r\nI think it is valuable to be able to reason about proc macros even when we can't expand them, since proc macro expansion can break between Rust releases or users might not want to turn it on for performance reasons. It allows us to provide better diagnostics on any proc macro invocation we're not expanding (like a weak warning that informs the user that proc macro support is turned off, or that it has been disabled because the server crashed).\r\n\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/5763\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "603f01dfa58140033c8902f3d2ba3098e87be858", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/603f01dfa58140033c8902f3d2ba3098e87be858"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfccMTCRBK7hj4Ov3rIwAAdHIIAGURQgMV/eUFg5tb8/6rrdoK\nuOrx7vGsppE5otW45qNEwR3qO/ib7geEuqq4CEejUDh7Ynp8P88yB/FnP8AJR5E2\n3emMa038tex1BQitRb9eyDY4CMBbmW33JqwcMYZOAJJXX+XEWGCclQ2G8e9niKQ8\nI3uyIDwWlHlqvofLfCmlUBj73YReNVC4la44KvtzAEWgilqlVXd2aywaPAygSXaP\nOWhxi679+D2sjioNKhJhhVMFtdUl0qW9gIS8gx99CHwmfGh5xpSLHS3wLUvy0+aj\n6J9CpB6/CqioKTVjJrgGbZZGgOK1T+OBL15YKTjUdX9zUeXe2yyWzIHaKhuX6to=\n=ui0j\n-----END PGP SIGNATURE-----\n", "payload": "tree 603f01dfa58140033c8902f3d2ba3098e87be858\nparent 000046cfa08948803607538e27808b6bf9dc7afb\nparent e88e4fbb7bb32065c6a7570057de248c2ea3a514\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1601291027 +0000\ncommitter GitHub <noreply@github.com> 1601291027 +0000\n\nMerge #6033\n\n6033: Make name resolution resolve proc macros instead of relying purely on the build system r=matklad a=jonas-schievink\n\nThis makes name resolution look at proc-macro declaration attributes like `#[proc_macro_derive]` and defines the right proc macro in the macro namespace, fixing unresolved custom derives like `thiserror::Error` (which can cause false positives, now that we emit diagnostics for unresolved imports).\r\n\r\nThis works even when proc-macro support is turned off, in which case we fall back to a dummy expander that always returns an error. IMO this is the right way to handle at least the name resolution part of proc. macros, while the *expansion* itself should rely on the build system to build and provide the macro DLL. It does mean that they may go out of sync, but we can provide diagnostics if that happens (something like \"could not find macro X in crate Y \u2013 ensure that all files of crate Y are saved\").\r\n\r\nI think it is valuable to be able to reason about proc macros even when we can't expand them, since proc macro expansion can break between Rust releases or users might not want to turn it on for performance reasons. It allows us to provide better diagnostics on any proc macro invocation we're not expanding (like a weak warning that informs the user that proc macro support is turned off, or that it has been disabled because the server crashed).\r\n\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/5763\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0", "html_url": "https://github.com/rust-lang/rust/commit/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "000046cfa08948803607538e27808b6bf9dc7afb", "url": "https://api.github.com/repos/rust-lang/rust/commits/000046cfa08948803607538e27808b6bf9dc7afb", "html_url": "https://github.com/rust-lang/rust/commit/000046cfa08948803607538e27808b6bf9dc7afb"}, {"sha": "e88e4fbb7bb32065c6a7570057de248c2ea3a514", "url": "https://api.github.com/repos/rust-lang/rust/commits/e88e4fbb7bb32065c6a7570057de248c2ea3a514", "html_url": "https://github.com/rust-lang/rust/commit/e88e4fbb7bb32065c6a7570057de248c2ea3a514"}], "stats": {"total": 230, "additions": 201, "deletions": 29}, "files": [{"sha": "12c24e1ca3fec3feaa98b5f1ac2525fabbfc29ef", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=0fb5d9d87a1d23563b8311feb4f97cb85894b8f0", "patch": "@@ -5,10 +5,12 @@ use std::collections::hash_map::Entry;\n \n use base_db::CrateId;\n use hir_expand::name::Name;\n+use hir_expand::MacroDefKind;\n use once_cell::sync::Lazy;\n use rustc_hash::{FxHashMap, FxHashSet};\n use test_utils::mark;\n \n+use crate::ModuleId;\n use crate::{\n     db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, HasModule, ImplId,\n     LocalModuleId, Lookup, MacroDefId, ModuleDefId, TraitId,\n@@ -265,6 +267,26 @@ impl ItemScope {\n     pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroDefId> {\n         self.legacy_macros.clone()\n     }\n+\n+    /// Marks everything that is not a procedural macro as private to `this_module`.\n+    pub(crate) fn censor_non_proc_macros(&mut self, this_module: ModuleId) {\n+        self.types\n+            .values_mut()\n+            .chain(self.values.values_mut())\n+            .map(|(_, v)| v)\n+            .chain(self.unnamed_trait_imports.values_mut())\n+            .for_each(|vis| *vis = Visibility::Module(this_module));\n+\n+        for (mac, vis) in self.macros.values_mut() {\n+            if let MacroDefKind::ProcMacro(_) = mac.kind {\n+                // FIXME: Technically this is insufficient since reexports of proc macros are also\n+                // forbidden. Practically nobody does that.\n+                continue;\n+            }\n+\n+            *vis = Visibility::Module(this_module);\n+        }\n+    }\n }\n \n impl PerNs {"}, {"sha": "100e25ffcf05733fe05a1284628870c0ce64c558", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 81, "deletions": 15, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=0fb5d9d87a1d23563b8311feb4f97cb85894b8f0", "patch": "@@ -16,10 +16,10 @@ use hir_expand::{\n     proc_macro::ProcMacroExpander,\n     HirFileId, MacroCallId, MacroDefId, MacroDefKind,\n };\n-use rustc_hash::FxHashMap;\n-use rustc_hash::FxHashSet;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n use test_utils::mark;\n+use tt::{Leaf, TokenTree};\n \n use crate::{\n     attr::Attrs,\n@@ -87,6 +87,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: CrateDefMap) -> Cr\n         mod_dirs: FxHashMap::default(),\n         cfg_options,\n         proc_macros,\n+        exports_proc_macros: false,\n         from_glob_import: Default::default(),\n     };\n     collector.collect();\n@@ -202,7 +203,12 @@ struct DefCollector<'a> {\n     unexpanded_attribute_macros: Vec<DeriveDirective>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n     cfg_options: &'a CfgOptions,\n+    /// List of procedural macros defined by this crate. This is read from the dynamic library\n+    /// built by the build system, and is the list of proc. macros we can actually expand. It is\n+    /// empty when proc. macro support is disabled (in which case we still do name resolution for\n+    /// them).\n     proc_macros: Vec<(Name, ProcMacroExpander)>,\n+    exports_proc_macros: bool,\n     from_glob_import: PerNsGlobImports,\n }\n \n@@ -261,24 +267,56 @@ impl DefCollector<'_> {\n         }\n         self.unresolved_imports = unresolved_imports;\n \n-        // Record proc-macros\n-        self.collect_proc_macro();\n+        // FIXME: This condition should instead check if this is a `proc-macro` type crate.\n+        if self.exports_proc_macros {\n+            // A crate exporting procedural macros is not allowed to export anything else.\n+            //\n+            // Additionally, while the proc macro entry points must be `pub`, they are not publicly\n+            // exported in type/value namespace. This function reduces the visibility of all items\n+            // in the crate root that aren't proc macros.\n+            let root = self.def_map.root;\n+            let root = &mut self.def_map.modules[root];\n+            root.scope.censor_non_proc_macros(ModuleId {\n+                krate: self.def_map.krate,\n+                local_id: self.def_map.root,\n+            });\n+        }\n     }\n \n-    fn collect_proc_macro(&mut self) {\n-        let proc_macros = std::mem::take(&mut self.proc_macros);\n-        for (name, expander) in proc_macros {\n-            let krate = self.def_map.krate;\n-\n-            let macro_id = MacroDefId {\n+    /// Adds a definition of procedural macro `name` to the root module.\n+    ///\n+    /// # Notes on procedural macro resolution\n+    ///\n+    /// Procedural macro functionality is provided by the build system: It has to build the proc\n+    /// macro and pass the resulting dynamic library to rust-analyzer.\n+    ///\n+    /// When procedural macro support is enabled, the list of proc macros exported by a crate is\n+    /// known before we resolve names in the crate. This list is stored in `self.proc_macros` and is\n+    /// derived from the dynamic library.\n+    ///\n+    /// However, we *also* would like to be able to at least *resolve* macros on our own, without\n+    /// help by the build system. So, when the macro isn't found in `self.proc_macros`, we instead\n+    /// use a dummy expander that always errors. This comes with the drawback of macros potentially\n+    /// going out of sync with what the build system sees (since we resolve using VFS state, but\n+    /// Cargo builds only on-disk files). We could and probably should add diagnostics for that.\n+    fn resolve_proc_macro(&mut self, name: &Name) {\n+        self.exports_proc_macros = true;\n+        let macro_def = match self.proc_macros.iter().find(|(n, _)| n == name) {\n+            Some((_, expander)) => MacroDefId {\n+                ast_id: None,\n+                krate: Some(self.def_map.krate),\n+                kind: MacroDefKind::ProcMacro(*expander),\n+                local_inner: false,\n+            },\n+            None => MacroDefId {\n                 ast_id: None,\n-                krate: Some(krate),\n-                kind: MacroDefKind::ProcMacro(expander),\n+                krate: Some(self.def_map.krate),\n+                kind: MacroDefKind::ProcMacro(ProcMacroExpander::dummy(self.def_map.krate)),\n                 local_inner: false,\n-            };\n+            },\n+        };\n \n-            self.define_proc_macro(name.clone(), macro_id);\n-        }\n+        self.define_proc_macro(name.clone(), macro_def);\n     }\n \n     /// Define a macro with `macro_rules`.\n@@ -917,6 +955,9 @@ impl ModCollector<'_, '_> {\n                 }\n                 ModItem::Function(id) => {\n                     let func = &self.item_tree[id];\n+\n+                    self.collect_proc_macro_def(&func.name, attrs);\n+\n                     def = Some(DefData {\n                         id: FunctionLoc {\n                             container: container.into(),\n@@ -1177,6 +1218,30 @@ impl ModCollector<'_, '_> {\n         }\n     }\n \n+    /// If `attrs` registers a procedural macro, collects its definition.\n+    fn collect_proc_macro_def(&mut self, func_name: &Name, attrs: &Attrs) {\n+        // FIXME: this should only be done in the root module of `proc-macro` crates, not everywhere\n+        // FIXME: distinguish the type of macro\n+        let macro_name = if attrs.by_key(\"proc_macro\").exists()\n+            || attrs.by_key(\"proc_macro_attribute\").exists()\n+        {\n+            func_name.clone()\n+        } else {\n+            let derive = attrs.by_key(\"proc_macro_derive\");\n+            if let Some(arg) = derive.tt_values().next() {\n+                if let [TokenTree::Leaf(Leaf::Ident(trait_name))] = &*arg.token_trees {\n+                    trait_name.as_name()\n+                } else {\n+                    return;\n+                }\n+            } else {\n+                return;\n+            }\n+        };\n+\n+        self.def_collector.resolve_proc_macro(&macro_name);\n+    }\n+\n     fn collect_macro(&mut self, mac: &MacroCall) {\n         let mut ast_id = AstIdWithPath::new(self.file_id, mac.ast_id, mac.path.clone());\n \n@@ -1283,6 +1348,7 @@ mod tests {\n             mod_dirs: FxHashMap::default(),\n             cfg_options: &CfgOptions::default(),\n             proc_macros: Default::default(),\n+            exports_proc_macros: false,\n             from_glob_import: Default::default(),\n         };\n         collector.collect();"}, {"sha": "0851c3b7d89524edf5cf8cb33c3622f571f12141", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=0fb5d9d87a1d23563b8311feb4f97cb85894b8f0", "patch": "@@ -667,3 +667,76 @@ b! { static = #[] (); }\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn resolves_proc_macros() {\n+    check(\n+        r\"\n+        struct TokenStream;\n+\n+        #[proc_macro]\n+        pub fn function_like_macro(args: TokenStream) -> TokenStream {\n+            args\n+        }\n+\n+        #[proc_macro_attribute]\n+        pub fn attribute_macro(_args: TokenStream, item: TokenStream) -> TokenStream {\n+            item\n+        }\n+\n+        #[proc_macro_derive(DummyTrait)]\n+        pub fn derive_macro(_item: TokenStream) -> TokenStream {\n+            TokenStream\n+        }\n+        \",\n+        expect![[r#\"\n+            crate\n+            DummyTrait: m\n+            TokenStream: t v\n+            attribute_macro: v m\n+            derive_macro: v\n+            function_like_macro: v m\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn proc_macro_censoring() {\n+    // Make sure that only proc macros are publicly exported from proc-macro crates.\n+\n+    check(\n+        r\"\n+        //- /main.rs crate:main deps:macros\n+        pub use macros::*;\n+\n+        //- /macros.rs crate:macros\n+        pub struct TokenStream;\n+\n+        #[proc_macro]\n+        pub fn function_like_macro(args: TokenStream) -> TokenStream {\n+            args\n+        }\n+\n+        #[proc_macro_attribute]\n+        pub fn attribute_macro(_args: TokenStream, item: TokenStream) -> TokenStream {\n+            item\n+        }\n+\n+        #[proc_macro_derive(DummyTrait)]\n+        pub fn derive_macro(_item: TokenStream) -> TokenStream {\n+            TokenStream\n+        }\n+\n+        #[macro_export]\n+        macro_rules! mbe {\n+            () => {};\n+        }\n+        \",\n+        expect![[r#\"\n+            crate\n+            DummyTrait: m\n+            attribute_macro: m\n+            function_like_macro: m\n+        \"#]],\n+    );\n+}"}, {"sha": "7505cb061bf9e62ee4385fcc4ee50db1ca876501", "filename": "crates/hir_expand/src/proc_macro.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fb5d9d87a1d23563b8311feb4f97cb85894b8f0/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs?ref=0fb5d9d87a1d23563b8311feb4f97cb85894b8f0", "patch": "@@ -7,7 +7,7 @@ use tt::buffer::{Cursor, TokenBuffer};\n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub struct ProcMacroExpander {\n     krate: CrateId,\n-    proc_macro_id: ProcMacroId,\n+    proc_macro_id: Option<ProcMacroId>,\n }\n \n macro_rules! err {\n@@ -20,8 +20,14 @@ macro_rules! err {\n }\n \n impl ProcMacroExpander {\n-    pub fn new(krate: CrateId, proc_macro_id: ProcMacroId) -> ProcMacroExpander {\n-        ProcMacroExpander { krate, proc_macro_id }\n+    pub fn new(krate: CrateId, proc_macro_id: ProcMacroId) -> Self {\n+        Self { krate, proc_macro_id: Some(proc_macro_id) }\n+    }\n+\n+    pub fn dummy(krate: CrateId) -> Self {\n+        // FIXME: Should store the name for better errors\n+        // FIXME: I think this is the second layer of \"dummy\" expansion, we should reduce that\n+        Self { krate, proc_macro_id: None }\n     }\n \n     pub fn expand(\n@@ -30,17 +36,22 @@ impl ProcMacroExpander {\n         _id: LazyMacroId,\n         tt: &tt::Subtree,\n     ) -> Result<tt::Subtree, mbe::ExpandError> {\n-        let krate_graph = db.crate_graph();\n-        let proc_macro = krate_graph[self.krate]\n-            .proc_macro\n-            .get(self.proc_macro_id.0 as usize)\n-            .clone()\n-            .ok_or_else(|| err!(\"No derive macro found.\"))?;\n-\n-        let tt = remove_derive_attrs(tt)\n-            .ok_or_else(|| err!(\"Fail to remove derive for custom derive\"))?;\n-\n-        proc_macro.expander.expand(&tt, None).map_err(mbe::ExpandError::from)\n+        match self.proc_macro_id {\n+            Some(id) => {\n+                let krate_graph = db.crate_graph();\n+                let proc_macro = krate_graph[self.krate]\n+                    .proc_macro\n+                    .get(id.0 as usize)\n+                    .clone()\n+                    .ok_or_else(|| err!(\"No derive macro found.\"))?;\n+\n+                let tt = remove_derive_attrs(tt)\n+                    .ok_or_else(|| err!(\"Fail to remove derive for custom derive\"))?;\n+\n+                proc_macro.expander.expand(&tt, None).map_err(mbe::ExpandError::from)\n+            }\n+            None => Err(err!(\"Unresolved proc macro\")),\n+        }\n     }\n }\n "}]}