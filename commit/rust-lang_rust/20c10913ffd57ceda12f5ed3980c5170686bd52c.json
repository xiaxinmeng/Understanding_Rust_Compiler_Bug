{"sha": "20c10913ffd57ceda12f5ed3980c5170686bd52c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwYzEwOTEzZmZkNTdjZWRhMTJmNWVkMzk4MGM1MTcwNjg2YmQ1MmM=", "commit": {"author": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2016-09-23T03:52:06Z"}, "committer": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2016-09-23T03:52:06Z"}, "message": "Merge branch 'master' into 35123-map3", "tree": {"sha": "b511918a33c41751f6f0434d8cd558aeb81ff7b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b511918a33c41751f6f0434d8cd558aeb81ff7b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20c10913ffd57ceda12f5ed3980c5170686bd52c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20c10913ffd57ceda12f5ed3980c5170686bd52c", "html_url": "https://github.com/rust-lang/rust/commit/20c10913ffd57ceda12f5ed3980c5170686bd52c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20c10913ffd57ceda12f5ed3980c5170686bd52c/comments", "author": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da3c6b7646fb94a747583f34cfa5c63ee4ea094a", "url": "https://api.github.com/repos/rust-lang/rust/commits/da3c6b7646fb94a747583f34cfa5c63ee4ea094a", "html_url": "https://github.com/rust-lang/rust/commit/da3c6b7646fb94a747583f34cfa5c63ee4ea094a"}, {"sha": "a09cb57a737fcea6bad33ca4e4ec8e3e97c712e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a09cb57a737fcea6bad33ca4e4ec8e3e97c712e2", "html_url": "https://github.com/rust-lang/rust/commit/a09cb57a737fcea6bad33ca4e4ec8e3e97c712e2"}], "stats": {"total": 43767, "additions": 23645, "deletions": 20122}, "files": [{"sha": "c5d8a94f39b052df9b2a497047f55549c5c8a833", "filename": ".travis.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -15,9 +15,9 @@ before_install:\n script:\n   - docker run -v `pwd`:/build rust\n     sh -c \"\n-      ./configure --llvm-root=/usr/lib/llvm-3.7 &&\n+      ./configure --enable-rustbuild --llvm-root=/usr/lib/llvm-3.7 &&\n       make tidy &&\n-      make check-notidy -j4\n+      make check -j4\n     \"\n \n # Real testing happens on http://buildbot.rust-lang.org/"}, {"sha": "4c0f93c3703a59259014e294ee1acaa9faa4b1d6", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -151,6 +151,10 @@ Some common make targets are:\n   command above as we only build the stage1 compiler, not the entire thing).\n   You can also leave off the `-rpass` to run all stage1 test types.\n - `make check-stage1-coretest` - Run stage1 tests in `libcore`.\n+- `make tidy` - Check that the source code is in compliance with Rust's style\n+  guidelines. There is no official document describing Rust's full guidelines \n+  as of yet, but basic rules like 4 spaces for indentation and no more than 99\n+  characters in a single line should be kept in mind when writing code.\n \n ## Pull Requests\n \n@@ -177,6 +181,15 @@ you\u2019re adding something to the standard library, try\n \n This will not rebuild the compiler, but will run the tests.\n \n+Please make sure your pull request is in compliance with Rust's style\n+guidelines by running\n+\n+    $ make tidy\n+\n+Make this check before every pull request (and every new commit in a pull\n+request) ; you can add [git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)\n+before every push to make sure you never forget to make this check.\n+\n All pull requests are reviewed by another person. We have a bot,\n @rust-highfive, that will automatically assign a random person to review your\n request."}, {"sha": "f2385f315186fa37bea59f84901753817bd6d5a1", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -170,7 +170,7 @@ fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n Snapshot binaries are currently built and tested on several platforms:\n \n-| Platform \\ Architecture        | x86 | x86_64 |\n+| Platform / Architecture        | x86 | x86_64 |\n |--------------------------------|-----|--------|\n | Windows (7, 8, Server 2008 R2) | \u2713   | \u2713      |\n | Linux (2.6.18 or later)        | \u2713   | \u2713      |"}, {"sha": "a8bd3acdff1ac2b5154bd899db15f31baf3b1740", "filename": "configure", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/configure", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -360,6 +360,13 @@ abs_path() {\n     (unset CDPATH && cd \"$_path\" > /dev/null && pwd)\n }\n \n+HELP=0\n+for arg; do\n+    case \"$arg\" in\n+        --help) HELP=1;;\n+    esac\n+done\n+\n msg \"looking for configure programs\"\n need_cmd cmp\n need_cmd mkdir\n@@ -517,6 +524,10 @@ case $CFG_CPUTYPE in\n         CFG_CPUTYPE=powerpc64le\n         ;;\n \n+    s390x)\n+        CFG_CPUTYPE=s390x\n+        ;;\n+\n     x86_64 | x86-64 | x64 | amd64)\n         CFG_CPUTYPE=x86_64\n         ;;\n@@ -566,11 +577,8 @@ esac\n \n \n OPTIONS=\"\"\n-HELP=0\n-if [ \"$1\" = \"--help\" ]\n+if [ \"$HELP\" -eq 1 ]\n then\n-    HELP=1\n-    shift\n     echo\n     echo \"Usage: $CFG_SELF [options]\"\n     echo\n@@ -609,7 +617,6 @@ opt dist-host-only 0 \"only install bins for the host architecture\"\n opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n opt llvm-version-check 1 \"check if the LLVM version is supported, build anyway\"\n opt rustbuild 0 \"use the rust and cargo based build system\"\n-opt orbit 1 \"get MIR where it belongs - everywhere; most importantly, in orbit\"\n opt codegen-tests 1 \"run the src/test/codegen tests\"\n opt option-checking 1 \"complain about unrecognized options in this configure script\"\n opt ninja 0 \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\"\n@@ -630,6 +637,7 @@ valopt datadir \"${CFG_PREFIX}/share\" \"install data\"\n valopt infodir \"${CFG_PREFIX}/share/info\" \"install additional info\"\n valopt llvm-root \"\" \"set LLVM root\"\n valopt python \"\" \"set path to python\"\n+valopt nodejs \"\" \"set path to nodejs\"\n valopt jemalloc-root \"\" \"set directory where libjemalloc_pic.a is located\"\n valopt build \"${DEFAULT_BUILD}\" \"GNUs ./configure syntax LLVM build triple\"\n valopt android-cross-path \"\" \"Android NDK standalone path (deprecated)\"\n@@ -668,6 +676,7 @@ valopt_nosave local-rust-root \"/usr/local\" \"set prefix for local rust binary\"\n valopt_nosave host \"${CFG_BUILD}\" \"GNUs ./configure syntax LLVM host triples\"\n valopt_nosave target \"${CFG_HOST}\" \"GNUs ./configure syntax LLVM target triples\"\n valopt_nosave mandir \"${CFG_PREFIX}/share/man\" \"install man pages in PATH\"\n+valopt_nosave docdir \"${CFG_PREFIX}/share/doc/rust\" \"install man pages in PATH\"\n \n # On Windows this determines root of the subtree for target libraries.\n # Host runtime libs always go to 'bin'.\n@@ -745,6 +754,9 @@ if [ $(echo $python_version | grep -c '^Python 2\\.7') -ne 1 ]; then\n     err \"Found $python_version, but Python 2.7 is required\"\n fi\n \n+# Checking for node, but not required\n+probe CFG_NODEJS nodejs node\n+\n # If we have no git directory then we are probably a tarball distribution\n # and shouldn't attempt to load submodules\n if [ ! -e ${CFG_SRC_DIR}.git ]\n@@ -897,7 +909,7 @@ then\n     fi\n \n     CMD=\"${CFG_LOCAL_RUST_ROOT}/bin/rustc${BIN_SUF}\"\n-    LRV=`$CMD --version`\n+    LRV=`LD_LIBRARY_PATH=${CFG_LOCAL_RUST_ROOT}/lib $CMD --version`\n     if [ $? -ne 0 ]\n     then\n         step_msg \"failure while running $CMD --version\"\n@@ -1113,6 +1125,7 @@ putvar CFG_STDCPP_NAME\n # a little post-processing of various config values\n CFG_PREFIX=${CFG_PREFIX%/}\n CFG_MANDIR=${CFG_MANDIR%/}\n+CFG_DOCDIR=${CFG_DOCDIR%/}\n CFG_HOST=\"$(echo $CFG_HOST | tr ',' ' ')\"\n CFG_TARGET=\"$(echo $CFG_TARGET | tr ',' ' ')\"\n CFG_SUPPORTED_TARGET=\"\"\n@@ -1794,6 +1807,7 @@ putvar CFG_ARMV7_LINUX_ANDROIDEABI_NDK\n putvar CFG_I686_LINUX_ANDROID_NDK\n putvar CFG_NACL_CROSS_PATH\n putvar CFG_MANDIR\n+putvar CFG_DOCDIR\n putvar CFG_USING_LIBCPP\n \n # Avoid spurious warnings from clang by feeding it original source on"}, {"sha": "34aee77ae2107fbe45fcb960d74d2ffdd5c57bf1", "filename": "mk/cfg/mips64-unknown-linux-gnuabi64.mk", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fcfg%2Fmips64-unknown-linux-gnuabi64.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fcfg%2Fmips64-unknown-linux-gnuabi64.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmips64-unknown-linux-gnuabi64.mk?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -0,0 +1 @@\n+# rustbuild-only target"}, {"sha": "34aee77ae2107fbe45fcb960d74d2ffdd5c57bf1", "filename": "mk/cfg/mips64el-unknown-linux-gnuabi64.mk", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fcfg%2Fmips64el-unknown-linux-gnuabi64.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fcfg%2Fmips64el-unknown-linux-gnuabi64.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmips64el-unknown-linux-gnuabi64.mk?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -0,0 +1 @@\n+# rustbuild-only target"}, {"sha": "eb1cb2329c4f35412029638a3d252ab4b0398c93", "filename": "mk/cfg/s390x-unknown-linux-gnu.mk", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fcfg%2Fs390x-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fcfg%2Fs390x-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fs390x-unknown-linux-gnu.mk?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -1 +1,24 @@\n-# rustbuild-only target\n+# s390x-unknown-linux-gnu configuration\n+CROSS_PREFIX_s390x-unknown-linux-gnu=s390x-linux-gnu-\n+CC_s390x-unknown-linux-gnu=$(CC)\n+CXX_s390x-unknown-linux-gnu=$(CXX)\n+CPP_s390x-unknown-linux-gnu=$(CPP)\n+AR_s390x-unknown-linux-gnu=$(AR)\n+CFG_LIB_NAME_s390x-unknown-linux-gnu=lib$(1).so\n+CFG_STATIC_LIB_NAME_s390x-unknown-linux-gnu=lib$(1).a\n+CFG_LIB_GLOB_s390x-unknown-linux-gnu=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_s390x-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_s390x-unknown-linux-gnu := -m64 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_s390x-unknown-linux-gnu :=  -g -fPIC -m64 $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_s390x-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_s390x-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m64\n+CFG_GCCISH_DEF_FLAG_s390x-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list=\n+CFG_LLC_FLAGS_s390x-unknown-linux-gnu :=\n+CFG_INSTALL_NAME_s390x-unknown-linux-gnu =\n+CFG_EXE_SUFFIX_s390x-unknown-linux-gnu =\n+CFG_WINDOWSY_s390x-unknown-linux-gnu :=\n+CFG_UNIXY_s390x-unknown-linux-gnu := 1\n+CFG_LDPATH_s390x-unknown-linux-gnu :=\n+CFG_RUN_s390x-unknown-linux-gnu=$(2)\n+CFG_RUN_TARG_s390x-unknown-linux-gnu=$(call CFG_RUN_s390x-unknown-linux-gnu,,$(2))\n+CFG_GNU_TRIPLE_s390x-unknown-linux-gnu := s390x-unknown-linux-gnu"}, {"sha": "3574f25d9b7442b1e8e0133a4806a2f29e6985b4", "filename": "mk/clean.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -102,7 +102,6 @@ define CLEAN_TARGET_STAGE_N\n clean$(1)_T_$(2)_H_$(3): \\\n \t    $$(foreach crate,$$(CRATES),clean$(1)_T_$(2)_H_$(3)-lib-$$(crate)) \\\n \t    $$(foreach tool,$$(TOOLS) $$(DEBUGGER_BIN_SCRIPTS_ALL),clean$(1)_T_$(2)_H_$(3)-tool-$$(tool))\n-\t$$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libcompiler-rt.a\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/librun_pass_stage* # For unix\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/run_pass_stage* # For windows\n "}, {"sha": "86bb3a8ca0ccc8b09ec4bf277ed59b0513732516", "filename": "mk/crates.mk", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -51,20 +51,21 @@\n \n TARGET_CRATES := libc std term \\\n                  getopts collections test rand \\\n-                 core alloc \\\n+                 compiler_builtins core alloc \\\n                  rustc_unicode rustc_bitflags \\\n \t\t alloc_system alloc_jemalloc \\\n \t\t panic_abort panic_unwind unwind\n RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_platform_intrinsics rustc_errors \\\n                 rustc_plugin rustc_metadata rustc_passes rustc_save_analysis \\\n-                rustc_const_eval rustc_const_math rustc_incremental\n+                rustc_const_eval rustc_const_math rustc_incremental rustc_macro\n HOST_CRATES := syntax syntax_ext proc_macro syntax_pos $(RUSTC_CRATES) rustdoc fmt_macros \\\n-\t\tflate arena graphviz rbml log serialize\n+\t\tflate arena graphviz log serialize\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n \n DEPS_core :=\n+DEPS_compiler_builtins := core\n DEPS_alloc := core libc alloc_system\n DEPS_alloc_system := core libc\n DEPS_alloc_jemalloc := core libc native:jemalloc\n@@ -77,12 +78,14 @@ DEPS_panic_abort := libc alloc\n DEPS_panic_unwind := libc alloc unwind\n DEPS_unwind := libc\n \n+RUSTFLAGS_compiler_builtins := -lstatic=compiler-rt\n+\n # FIXME(stage0): change this to just `RUSTFLAGS_panic_abort := ...`\n RUSTFLAGS1_panic_abort := -C panic=abort\n RUSTFLAGS2_panic_abort := -C panic=abort\n RUSTFLAGS3_panic_abort := -C panic=abort\n \n-DEPS_std := core libc rand alloc collections rustc_unicode \\\n+DEPS_std := core libc rand alloc collections compiler_builtins rustc_unicode \\\n \tnative:backtrace \\\n \talloc_system panic_abort panic_unwind unwind\n DEPS_arena := std\n@@ -93,21 +96,20 @@ DEPS_getopts := std\n DEPS_graphviz := std\n DEPS_log := std\n DEPS_num := std\n-DEPS_rbml := std log serialize\n DEPS_serialize := std log\n DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n \n DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos\n-DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros\n+DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros rustc_macro\n DEPS_proc_macro := syntax syntax_pos rustc_plugin log\n DEPS_syntax_pos := serialize\n \n DEPS_rustc_const_math := std syntax log serialize\n DEPS_rustc_const_eval := rustc_const_math rustc syntax log serialize \\\n \t\t\t     rustc_back graphviz syntax_pos\n \n-DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml \\\n+DEPS_rustc := syntax fmt_macros flate arena serialize getopts \\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\\\n \t      rustc_const_math syntax_pos rustc_errors\n DEPS_rustc_back := std syntax flate log libc\n@@ -118,11 +120,13 @@ DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_bo\n                      rustc_trans rustc_privacy rustc_lint rustc_plugin \\\n                      rustc_metadata syntax_ext proc_macro \\\n                      rustc_passes rustc_save_analysis rustc_const_eval \\\n-                     rustc_incremental syntax_pos rustc_errors\n+                     rustc_incremental syntax_pos rustc_errors rustc_macro\n DEPS_rustc_errors := log libc serialize syntax_pos\n DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n-DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rbml rustc_const_math\n+DEPS_rustc_macro := std syntax\n+DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rustc_const_math \\\n+\t\t\trustc_macro syntax_ext\n DEPS_rustc_passes := syntax syntax_pos rustc core rustc_const_eval rustc_errors\n DEPS_rustc_mir := rustc syntax syntax_pos rustc_const_math rustc_const_eval rustc_bitflags\n DEPS_rustc_resolve := arena rustc log syntax syntax_pos rustc_errors\n@@ -132,7 +136,7 @@ DEPS_rustc_privacy := rustc log syntax syntax_pos\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n                     log syntax serialize rustc_llvm rustc_platform_intrinsics \\\n                     rustc_const_math rustc_const_eval rustc_incremental rustc_errors syntax_pos\n-DEPS_rustc_incremental := rbml rustc syntax_pos serialize rustc_data_structures\n+DEPS_rustc_incremental := rustc syntax_pos serialize rustc_data_structures\n DEPS_rustc_save_analysis := rustc log syntax syntax_pos serialize\n DEPS_rustc_typeck := rustc syntax syntax_pos rustc_platform_intrinsics rustc_const_math \\\n                      rustc_const_eval rustc_errors\n@@ -151,6 +155,7 @@ TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustbook := $(S)src/tools/rustbook/main.rs\n TOOL_SOURCE_error_index_generator := $(S)src/tools/error_index_generator/main.rs\n \n+ONLY_RLIB_compiler_builtins := 1\n ONLY_RLIB_core := 1\n ONLY_RLIB_libc := 1\n ONLY_RLIB_alloc := 1"}, {"sha": "cb0bca01e6c4a7582ff7ba6d4350360d5aa50f05", "filename": "mk/dist.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -76,6 +76,7 @@ tmp/dist/$$(SRC_PKG_NAME)-image: $(PKG_FILES)\n \t@$(call E, making src image)\n \t$(Q)rm -Rf tmp/dist/$(SRC_PKG_NAME)-image\n \t$(Q)mkdir -p tmp/dist/$(SRC_PKG_NAME)-image/lib/rustlib/src/rust\n+\t$(Q)echo \"$(CFG_VERSION)\" > tmp/dist/$(SRC_PKG_NAME)-image/lib/rustlib/src/rust/version\n \t$(Q)tar \\\n          -C $(S) \\\n          -f - \\"}, {"sha": "be212869f0103517b8856b0ff1bed4b65e58ed86", "filename": "mk/install.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -12,7 +12,8 @@ RUN_INSTALLER = cd tmp/empty_dir && \\\n \tsh ../../tmp/dist/$(1)/install.sh \\\n \t\t--prefix=\"$(DESTDIR)$(CFG_PREFIX)\" \\\n \t\t--libdir=\"$(DESTDIR)$(CFG_LIBDIR)\" \\\n-\t\t--mandir=\"$(DESTDIR)$(CFG_MANDIR)\"\n+\t\t--mandir=\"$(DESTDIR)$(CFG_MANDIR)\" \\\n+\t\t--docdir=\"$(DESTDIR)$(CFG_DOCDIR)\"\n \n install:\n ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))"}, {"sha": "7dcf3a7f3acd4bd28fa2efd18f24cb5322773523", "filename": "mk/main.mk", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -348,6 +348,7 @@ LLVM_AS_$(1)=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-as$$(X_$(1))\n LLC_$(1)=$$(CFG_LLVM_INST_DIR_$(1))/bin/llc$$(X_$(1))\n \n LLVM_ALL_COMPONENTS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --components)\n+LLVM_VERSION_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --version)\n \n endef\n \n@@ -454,7 +455,10 @@ endif\n TSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(HSREQ$(1)_H_$(3)) \\\n \t$$(foreach obj,$$(REQUIRED_OBJECTS_$(2)),\\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(obj))\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(obj)) \\\n+\t$$(TLIB0_T_$(2)_H_$(3))/$$(call CFG_STATIC_LIB_NAME_$(2),compiler-rt)\n+# ^ This copies `libcompiler-rt.a` to the stage0 sysroot\n+# ^ TODO(stage0) update this to not copy `libcompiler-rt.a` to stage0\n \n # Prerequisites for a working stageN compiler and libraries, for a specific\n # target\n@@ -629,7 +633,8 @@ ALL_TARGET_RULES = $(foreach target,$(CFG_TARGET), \\\n \t$(foreach host,$(CFG_HOST), \\\n  all-target-$(target)-host-$(host)))\n \n-all: $(ALL_TARGET_RULES) $(GENERATED) docs\n+all-no-docs: $(ALL_TARGET_RULES) $(GENERATED)\n+all: all-no-docs docs\n \n ######################################################################\n # Build system documentation"}, {"sha": "6a7a20cbfdb99b1b77f4049adc913b1b7fe07bc8", "filename": "mk/platform.mk", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -102,8 +102,6 @@ include $(wildcard $(CFG_SRC_DIR)mk/cfg/*.mk)\n define ADD_INSTALLED_OBJECTS\n   INSTALLED_OBJECTS_$(1) += $$(CFG_INSTALLED_OBJECTS_$(1))\n   REQUIRED_OBJECTS_$(1) += $$(CFG_THIRD_PARTY_OBJECTS_$(1))\n-  INSTALLED_OBJECTS_$(1) += $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n-  REQUIRED_OBJECTS_$(1) += $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n endef\n \n $(foreach target,$(CFG_TARGET), \\"}, {"sha": "a67bded288e20405c990dc77cc92d0606b5031d9", "filename": "mk/rt.mk", "status": "modified", "additions": 177, "deletions": 161, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -37,6 +37,16 @@\n ################################################################################\n NATIVE_LIBS := hoedown miniz rust_test_helpers\n \n+# A macro to add a generic implementation of intrinsics iff a arch optimized implementation is not\n+# already in the list.\n+# $(1) is the target\n+# $(2) is the intrinsic\n+define ADD_INTRINSIC\n+  ifeq ($$(findstring X,$$(foreach intrinsic,$$(COMPRT_OBJS_$(1)),$$(if $$(findstring $(2),$$(intrinsic)),X,))),)\n+    COMPRT_OBJS_$(1) += $(2)\n+  endif\n+endef\n+\n # $(1) is the target triple\n define NATIVE_LIBRARIES\n \n@@ -230,167 +240,15 @@ COMPRT_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n COMPRT_LIB_$(1) := $$(RT_OUTPUT_DIR_$(1))/$$(COMPRT_NAME_$(1))\n COMPRT_BUILD_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/compiler-rt\n \n-# GENERIC_SOURCES in CMakeLists.txt\n-COMPRT_OBJS_$(1) := \\\n-  absvdi2.o \\\n-  absvsi2.o \\\n-  adddf3.o \\\n-  addsf3.o \\\n-  addvdi3.o \\\n-  addvsi3.o \\\n-  apple_versioning.o \\\n-  ashldi3.o \\\n-  ashrdi3.o \\\n-  clear_cache.o \\\n-  clzdi2.o \\\n-  clzsi2.o \\\n-  cmpdi2.o \\\n-  comparedf2.o \\\n-  comparesf2.o \\\n-  ctzdi2.o \\\n-  ctzsi2.o \\\n-  divdc3.o \\\n-  divdf3.o \\\n-  divdi3.o \\\n-  divmoddi4.o \\\n-  divmodsi4.o \\\n-  divsc3.o \\\n-  divsf3.o \\\n-  divsi3.o \\\n-  divxc3.o \\\n-  extendsfdf2.o \\\n-  extendhfsf2.o \\\n-  ffsdi2.o \\\n-  fixdfdi.o \\\n-  fixdfsi.o \\\n-  fixsfdi.o \\\n-  fixsfsi.o \\\n-  fixunsdfdi.o \\\n-  fixunsdfsi.o \\\n-  fixunssfdi.o \\\n-  fixunssfsi.o \\\n-  fixunsxfdi.o \\\n-  fixunsxfsi.o \\\n-  fixxfdi.o \\\n-  floatdidf.o \\\n-  floatdisf.o \\\n-  floatdixf.o \\\n-  floatsidf.o \\\n-  floatsisf.o \\\n-  floatundidf.o \\\n-  floatundisf.o \\\n-  floatundixf.o \\\n-  floatunsidf.o \\\n-  floatunsisf.o \\\n-  int_util.o \\\n-  lshrdi3.o \\\n-  moddi3.o \\\n-  modsi3.o \\\n-  muldc3.o \\\n-  muldf3.o \\\n-  muldi3.o \\\n-  mulodi4.o \\\n-  mulosi4.o \\\n-  muloti4.o \\\n-  mulsc3.o \\\n-  mulsf3.o \\\n-  mulvdi3.o \\\n-  mulvsi3.o \\\n-  mulxc3.o \\\n-  negdf2.o \\\n-  negdi2.o \\\n-  negsf2.o \\\n-  negvdi2.o \\\n-  negvsi2.o \\\n-  paritydi2.o \\\n-  paritysi2.o \\\n-  popcountdi2.o \\\n-  popcountsi2.o \\\n-  powidf2.o \\\n-  powisf2.o \\\n-  powixf2.o \\\n-  subdf3.o \\\n-  subsf3.o \\\n-  subvdi3.o \\\n-  subvsi3.o \\\n-  truncdfhf2.o \\\n-  truncdfsf2.o \\\n-  truncsfhf2.o \\\n-  ucmpdi2.o \\\n-  udivdi3.o \\\n-  udivmoddi4.o \\\n-  udivmodsi4.o \\\n-  udivsi3.o \\\n-  umoddi3.o \\\n-  umodsi3.o\n-\n-ifeq ($$(findstring ios,$(1)),)\n-COMPRT_OBJS_$(1) += \\\n-  absvti2.o \\\n-  addtf3.o \\\n-  addvti3.o \\\n-  ashlti3.o \\\n-  ashrti3.o \\\n-  clzti2.o \\\n-  cmpti2.o \\\n-  ctzti2.o \\\n-  divtf3.o \\\n-  divti3.o \\\n-  ffsti2.o \\\n-  fixdfti.o \\\n-  fixsfti.o \\\n-  fixunsdfti.o \\\n-  fixunssfti.o \\\n-  fixunsxfti.o \\\n-  fixxfti.o \\\n-  floattidf.o \\\n-  floattisf.o \\\n-  floattixf.o \\\n-  floatuntidf.o \\\n-  floatuntisf.o \\\n-  floatuntixf.o \\\n-  lshrti3.o \\\n-  modti3.o \\\n-  multf3.o \\\n-  multi3.o \\\n-  mulvti3.o \\\n-  negti2.o \\\n-  negvti2.o \\\n-  parityti2.o \\\n-  popcountti2.o \\\n-  powitf2.o \\\n-  subtf3.o \\\n-  subvti3.o \\\n-  trampoline_setup.o \\\n-  ucmpti2.o \\\n-  udivmodti4.o \\\n-  udivti3.o \\\n-  umodti3.o\n-endif\n-\n-ifeq ($$(findstring apple,$(1)),apple)\n-COMPRT_OBJS_$(1) +=  \\\n-\t    atomic_flag_clear.o \\\n-\t    atomic_flag_clear_explicit.o \\\n-\t    atomic_flag_test_and_set.o \\\n-\t    atomic_flag_test_and_set_explicit.o \\\n-\t    atomic_signal_fence.o \\\n-\t    atomic_thread_fence.o\n-endif\n-\n+# We must avoid compiling both a generic implementation (e.g. `floatdidf.c) and an arch optimized\n+# implementation (e.g. `x86_64/floatdidf.S) of the same symbol (e.g. `floatdidf) because that causes\n+# linker errors. To avoid that, we first add all the arch optimized implementations and then add the\n+# generic implementations if and only if its arch optimized version is not already in the list. This\n+# last part is handled by the ADD_INTRINSIC macro.\n \n-ifeq ($$(findstring windows,$(1)),)\n-COMPRT_OBJS_$(1) += emutls.o\n-endif\n+COMPRT_OBJS_$(1) :=\n \n ifeq ($$(findstring msvc,$(1)),)\n-\n-ifeq ($$(findstring freebsd,$(1)),)\n-COMPRT_OBJS_$(1) += gcc_personality_v0.o\n-endif\n-\n-COMPRT_OBJS_$(1) += emutls.o\n-\n ifeq ($$(findstring x86_64,$(1)),x86_64)\n COMPRT_OBJS_$(1) += \\\n       x86_64/chkstk.o \\\n@@ -540,9 +398,166 @@ COMPRT_OBJS_$(1) += \\\n   arm/unordsf2vfp.o\n endif\n \n+$(foreach intrinsic,absvdi2.o \\\n+  absvsi2.o \\\n+  adddf3.o \\\n+  addsf3.o \\\n+  addvdi3.o \\\n+  addvsi3.o \\\n+  apple_versioning.o \\\n+  ashldi3.o \\\n+  ashrdi3.o \\\n+  clear_cache.o \\\n+  clzdi2.o \\\n+  clzsi2.o \\\n+  cmpdi2.o \\\n+  comparedf2.o \\\n+  comparesf2.o \\\n+  ctzdi2.o \\\n+  ctzsi2.o \\\n+  divdc3.o \\\n+  divdf3.o \\\n+  divdi3.o \\\n+  divmoddi4.o \\\n+  divmodsi4.o \\\n+  divsc3.o \\\n+  divsf3.o \\\n+  divsi3.o \\\n+  divxc3.o \\\n+  extendsfdf2.o \\\n+  extendhfsf2.o \\\n+  ffsdi2.o \\\n+  fixdfdi.o \\\n+  fixdfsi.o \\\n+  fixsfdi.o \\\n+  fixsfsi.o \\\n+  fixunsdfdi.o \\\n+  fixunsdfsi.o \\\n+  fixunssfdi.o \\\n+  fixunssfsi.o \\\n+  fixunsxfdi.o \\\n+  fixunsxfsi.o \\\n+  fixxfdi.o \\\n+  floatdidf.o \\\n+  floatdisf.o \\\n+  floatdixf.o \\\n+  floatsidf.o \\\n+  floatsisf.o \\\n+  floatundidf.o \\\n+  floatundisf.o \\\n+  floatundixf.o \\\n+  floatunsidf.o \\\n+  floatunsisf.o \\\n+  int_util.o \\\n+  lshrdi3.o \\\n+  moddi3.o \\\n+  modsi3.o \\\n+  muldc3.o \\\n+  muldf3.o \\\n+  muldi3.o \\\n+  mulodi4.o \\\n+  mulosi4.o \\\n+  muloti4.o \\\n+  mulsc3.o \\\n+  mulsf3.o \\\n+  mulvdi3.o \\\n+  mulvsi3.o \\\n+  mulxc3.o \\\n+  negdf2.o \\\n+  negdi2.o \\\n+  negsf2.o \\\n+  negvdi2.o \\\n+  negvsi2.o \\\n+  paritydi2.o \\\n+  paritysi2.o \\\n+  popcountdi2.o \\\n+  popcountsi2.o \\\n+  powidf2.o \\\n+  powisf2.o \\\n+  powixf2.o \\\n+  subdf3.o \\\n+  subsf3.o \\\n+  subvdi3.o \\\n+  subvsi3.o \\\n+  truncdfhf2.o \\\n+  truncdfsf2.o \\\n+  truncsfhf2.o \\\n+  ucmpdi2.o \\\n+  udivdi3.o \\\n+  udivmoddi4.o \\\n+  udivmodsi4.o \\\n+  udivsi3.o \\\n+  umoddi3.o \\\n+  umodsi3.o,\n+  $(call ADD_INTRINSIC,$(1),$(intrinsic)))\n+\n+ifeq ($$(findstring ios,$(1)),)\n+$(foreach intrinsic,absvti2.o \\\n+  addtf3.o \\\n+  addvti3.o \\\n+  ashlti3.o \\\n+  ashrti3.o \\\n+  clzti2.o \\\n+  cmpti2.o \\\n+  ctzti2.o \\\n+  divtf3.o \\\n+  divti3.o \\\n+  ffsti2.o \\\n+  fixdfti.o \\\n+  fixsfti.o \\\n+  fixunsdfti.o \\\n+  fixunssfti.o \\\n+  fixunsxfti.o \\\n+  fixxfti.o \\\n+  floattidf.o \\\n+  floattisf.o \\\n+  floattixf.o \\\n+  floatuntidf.o \\\n+  floatuntisf.o \\\n+  floatuntixf.o \\\n+  lshrti3.o \\\n+  modti3.o \\\n+  multf3.o \\\n+  multi3.o \\\n+  mulvti3.o \\\n+  negti2.o \\\n+  negvti2.o \\\n+  parityti2.o \\\n+  popcountti2.o \\\n+  powitf2.o \\\n+  subtf3.o \\\n+  subvti3.o \\\n+  trampoline_setup.o \\\n+  ucmpti2.o \\\n+  udivmodti4.o \\\n+  udivti3.o \\\n+  umodti3.o,\n+  $(call ADD_INTRINSIC,$(1),$(intrinsic)))\n+endif\n+\n+ifeq ($$(findstring apple,$(1)),apple)\n+$(foreach intrinsic,atomic_flag_clear.o \\\n+  atomic_flag_clear_explicit.o \\\n+  atomic_flag_test_and_set.o \\\n+  atomic_flag_test_and_set_explicit.o \\\n+  atomic_signal_fence.o \\\n+  atomic_thread_fence.o,\n+  $(call ADD_INTRINSIC,$(1),$(intrinsic)))\n+endif\n+\n+ifeq ($$(findstring windows,$(1)),)\n+$(call ADD_INTRINSIC,$(1),emutls.o)\n+endif\n+\n+ifeq ($$(findstring msvc,$(1)),)\n+\n+ifeq ($$(findstring freebsd,$(1)),)\n+$(call ADD_INTRINSIC,$(1),gcc_personality_v0.o)\n+endif\n+endif\n+\n ifeq ($$(findstring aarch64,$(1)),aarch64)\n-COMPRT_OBJS_$(1) += \\\n-  comparetf2.o \\\n+$(foreach intrinsic,comparetf2.o \\\n   extenddftf2.o \\\n   extendsftf2.o \\\n   fixtfdi.o \\\n@@ -557,7 +572,8 @@ COMPRT_OBJS_$(1) += \\\n   floatunsitf.o \\\n   multc3.o \\\n   trunctfdf2.o \\\n-  trunctfsf2.o\n+  trunctfsf2.o,\n+  $(call ADD_INTRINSIC,$(1),$(intrinsic)))\n endif\n \n ifeq ($$(findstring msvc,$(1)),msvc)"}, {"sha": "fc1f4b5561a78c7742bc13e830c62a1bf0caaf9f", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -27,7 +27,7 @@ TEST_TARGET_CRATES = $(filter-out core rustc_unicode alloc_system libc \\\n \t\t\t\t  panic_abort,$(TARGET_CRATES)) \\\n \t\t\tcollectionstest coretest\n TEST_DOC_CRATES = $(DOC_CRATES) arena flate fmt_macros getopts graphviz \\\n-                log rand rbml serialize syntax term test\n+                log rand serialize syntax term test\n TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_resolve \\\n \t\t   \t\trustc_trans rustc_lint,\\\n                      $(HOST_CRATES))\n@@ -649,6 +649,7 @@ CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3) = \\\n \t--lldb-python $$(CFG_LLDB_PYTHON) \\\n         --gdb-version=\"$(CFG_GDB_VERSION)\" \\\n         --lldb-version=\"$(CFG_LLDB_VERSION)\" \\\n+        --llvm-version=\"$$(LLVM_VERSION_$(3))\" \\\n         --android-cross-path=$(CFG_ARM_LINUX_ANDROIDEABI_NDK) \\\n         --adb-path=$(CFG_ADB) \\\n         --adb-test-dir=$(CFG_ADB_TEST_DIR) \\"}, {"sha": "14a985e93ce01b6d3f3a8d46f41d650467bf0fd9", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -269,15 +269,16 @@ def run(self, args, env):\n             sys.exit(ret)\n \n     def build_triple(self):\n+        default_encoding = sys.getdefaultencoding()\n         config = self.get_toml('build')\n         if config:\n             return config\n         config = self.get_mk('CFG_BUILD')\n         if config:\n             return config\n         try:\n-            ostype = subprocess.check_output(['uname', '-s']).strip()\n-            cputype = subprocess.check_output(['uname', '-m']).strip()\n+            ostype = subprocess.check_output(['uname', '-s']).strip().decode(default_encoding)\n+            cputype = subprocess.check_output(['uname', '-m']).strip().decode(default_encoding)\n         except (subprocess.CalledProcessError, WindowsError):\n             if sys.platform == 'win32':\n                 return 'x86_64-pc-windows-msvc'\n@@ -289,7 +290,8 @@ def build_triple(self):\n         # Darwin's `uname -s` lies and always returns i386. We have to use\n         # sysctl instead.\n         if ostype == 'Darwin' and cputype == 'i686':\n-            sysctl = subprocess.check_output(['sysctl', 'hw.optional.x86_64'])\n+            args = ['sysctl', 'hw.optional.x86_64']\n+            sysctl = subprocess.check_output(args).decode(default_encoding)\n             if ': 1' in sysctl:\n                 cputype = 'x86_64'\n "}, {"sha": "2b9d717cbd48dbaa3365257cb80916b32a10c393", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -148,6 +148,9 @@ pub fn compiletest(build: &Build,\n     if let Some(ref dir) = build.lldb_python_dir {\n         cmd.arg(\"--lldb-python-dir\").arg(dir);\n     }\n+    let llvm_config = build.llvm_config(target);\n+    let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+    cmd.arg(\"--llvm-version\").arg(llvm_version);\n \n     cmd.args(&build.flags.args);\n \n@@ -158,7 +161,6 @@ pub fn compiletest(build: &Build,\n     // Only pass correct values for these flags for the `run-make` suite as it\n     // requires that a C++ compiler was configured which isn't always the case.\n     if suite == \"run-make\" {\n-        let llvm_config = build.llvm_config(target);\n         let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n         let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n         cmd.arg(\"--cc\").arg(build.cc(target))"}, {"sha": "a1e286e162ffa2ba5b92f47b0bf751c2e5bc8cb6", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -28,7 +28,6 @@ pub fn clean(build: &Build) {\n \n         let out = build.out.join(host);\n \n-        rm_rf(build, &out.join(\"compiler-rt\"));\n         rm_rf(build, &out.join(\"doc\"));\n \n         for stage in 0..4 {"}, {"sha": "9de438cfa7d504756e1211fdcf2c8733c9ce57d2", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 68, "deletions": 25, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -16,12 +16,14 @@\n //! compiler. This module is also responsible for assembling the sysroot as it\n //! goes along from the output of the previous stage.\n \n+use std::cmp;\n use std::collections::HashMap;\n-use std::fs;\n+use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use build_helper::output;\n+use filetime::FileTime;\n \n use util::{exe, staticlib, libdir, mtime, is_dylib, copy};\n use {Build, Compiler, Mode};\n@@ -35,13 +37,23 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n              compiler.host, target);\n \n-    // Move compiler-rt into place as it'll be required by the compiler when\n-    // building the standard library to link the dylib of libstd\n     let libdir = build.sysroot_libdir(compiler, target);\n     let _ = fs::remove_dir_all(&libdir);\n     t!(fs::create_dir_all(&libdir));\n-    copy(&build.compiler_rt_built.borrow()[target],\n-         &libdir.join(staticlib(\"compiler-rt\", target)));\n+    // FIXME(stage0) remove this `if` after the next snapshot\n+    // The stage0 compiler still passes the `-lcompiler-rt` flag to the linker but now `bootstrap`\n+    // never builds a `libcopmiler-rt.a`! We'll fill the hole by simply copying stage0's\n+    // `libcompiler-rt.a` to where the stage1's one is expected (though we could as well just use\n+    // an empty `.a` archive). Note that the symbols of that stage0 `libcompiler-rt.a` won't make\n+    // it to the final binary because now `libcore.rlib` also contains the symbols that\n+    // `libcompiler-rt.a` provides. Since that rlib appears first in the linker arguments, its\n+    // symbols are used instead of `libcompiler-rt.a`'s.\n+    if compiler.stage == 0 {\n+        let rtlib = &staticlib(\"compiler-rt\", target);\n+        let src = build.rustc.parent().unwrap().parent().unwrap().join(\"lib\").join(\"rustlib\")\n+            .join(target).join(\"lib\").join(rtlib);\n+        copy(&src, &libdir.join(rtlib));\n+    }\n \n     // Some platforms have startup objects that may be required to produce the\n     // libstd dynamic library, for example.\n@@ -59,13 +71,14 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n             cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n         }\n     }\n-    if let Some(ref p) = build.config.musl_root {\n-        if target.contains(\"musl\") {\n+    if target.contains(\"musl\") {\n+        if let Some(p) = build.musl_root(target) {\n             cargo.env(\"MUSL_ROOT\", p);\n         }\n     }\n \n     build.run(&mut cargo);\n+    update_mtime(&libstd_stamp(build, compiler, target));\n     std_link(build, target, compiler, compiler.host);\n }\n \n@@ -83,26 +96,24 @@ pub fn std_link(build: &Build,\n \n     // If we're linking one compiler host's output into another, then we weren't\n     // called from the `std` method above. In that case we clean out what's\n-    // already there and then also link compiler-rt into place.\n+    // already there.\n     if host != compiler.host {\n         let _ = fs::remove_dir_all(&libdir);\n         t!(fs::create_dir_all(&libdir));\n-        copy(&build.compiler_rt_built.borrow()[target],\n-             &libdir.join(staticlib(\"compiler-rt\", target)));\n     }\n     add_to_sysroot(&out_dir, &libdir);\n \n     if target.contains(\"musl\") && !target.contains(\"mips\") {\n-        copy_third_party_objects(build, target, &libdir);\n+        copy_musl_third_party_objects(build, &libdir);\n     }\n }\n \n /// Copies the crt(1,i,n).o startup objects\n ///\n /// Only required for musl targets that statically link to libc\n-fn copy_third_party_objects(build: &Build, target: &str, into: &Path) {\n+fn copy_musl_third_party_objects(build: &Build, into: &Path) {\n     for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-        copy(&compiler_file(build.cc(target), obj), &into.join(obj));\n+        copy(&build.config.musl_root.as_ref().unwrap().join(\"lib\").join(obj), &into.join(obj));\n     }\n }\n \n@@ -117,14 +128,16 @@ fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n         return\n     }\n     let compiler = Compiler::new(0, &build.config.build);\n-    let compiler = build.compiler_path(&compiler);\n+    let compiler_path = build.compiler_path(&compiler);\n \n     for file in t!(fs::read_dir(build.src.join(\"src/rtstartup\"))) {\n         let file = t!(file);\n-        build.run(Command::new(&compiler)\n-                          .arg(\"--emit=obj\")\n-                          .arg(\"--out-dir\").arg(into)\n-                          .arg(file.path()));\n+        let mut cmd = Command::new(&compiler_path);\n+        build.add_bootstrap_key(&compiler, &mut cmd);\n+        build.run(cmd.arg(\"--target\").arg(target)\n+                     .arg(\"--emit=obj\")\n+                     .arg(\"--out-dir\").arg(into)\n+                     .arg(file.path()));\n     }\n \n     for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n@@ -141,11 +154,12 @@ pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n              compiler.host, target);\n     let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n-    build.clear_if_dirty(&out_dir, &libstd_shim(build, compiler, target));\n+    build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n     let mut cargo = build.cargo(compiler, Mode::Libtest, target, \"build\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/test_shim/Cargo.toml\"));\n     build.run(&mut cargo);\n+    update_mtime(&libtest_stamp(build, compiler, target));\n     test_link(build, target, compiler, compiler.host);\n }\n \n@@ -173,7 +187,7 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n              compiler.stage, compiler.host, target);\n \n     let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n-    build.clear_if_dirty(&out_dir, &libtest_shim(build, compiler, target));\n+    build.clear_if_dirty(&out_dir, &libtest_stamp(build, compiler, target));\n \n     let mut cargo = build.cargo(compiler, Mode::Librustc, target, \"build\");\n     cargo.arg(\"--features\").arg(build.rustc_features())\n@@ -203,6 +217,10 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n         cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n     }\n     cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n+    let target_config = build.config.target_config.get(target);\n+    if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+        cargo.env(\"CFG_LLVM_ROOT\", s);\n+    }\n     if build.config.llvm_static_stdcpp {\n         cargo.env(\"LLVM_STATIC_STDCPP\",\n                   compiler_file(build.cxx(target), \"libstdc++.a\"));\n@@ -234,14 +252,14 @@ pub fn rustc_link(build: &Build,\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-fn libstd_shim(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Libstd, target).join(\"libstd_shim.rlib\")\n+fn libstd_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Libstd, target).join(\".libstd.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n-fn libtest_shim(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Libtest, target).join(\"libtest_shim.rlib\")\n+fn libtest_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Libtest, target).join(\".libtest.stamp\")\n }\n \n fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n@@ -354,10 +372,35 @@ pub fn tool(build: &Build, stage: u32, host: &str, tool: &str) {\n     //        Maybe when libstd is compiled it should clear out the rustc of the\n     //        corresponding stage?\n     // let out_dir = build.cargo_out(stage, &host, Mode::Librustc, target);\n-    // build.clear_if_dirty(&out_dir, &libstd_shim(build, stage, &host, target));\n+    // build.clear_if_dirty(&out_dir, &libstd_stamp(build, stage, &host, target));\n \n     let mut cargo = build.cargo(&compiler, Mode::Tool, host, \"build\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(format!(\"src/tools/{}/Cargo.toml\", tool)));\n     build.run(&mut cargo);\n }\n+\n+/// Updates the mtime of a stamp file if necessary, only changing it if it's\n+/// older than some other file in the same directory.\n+///\n+/// We don't know what file Cargo is going to output (because there's a hash in\n+/// the file name) but we know where it's going to put it. We use this helper to\n+/// detect changes to that output file by looking at the modification time for\n+/// all files in a directory and updating the stamp if any are newer.\n+fn update_mtime(path: &Path) {\n+    let mut max = None;\n+    if let Ok(entries) = path.parent().unwrap().read_dir() {\n+        for entry in entries.map(|e| t!(e)) {\n+            if t!(entry.file_type()).is_file() {\n+                let meta = t!(entry.metadata());\n+                let time = FileTime::from_last_modification_time(&meta);\n+                max = cmp::max(max, Some(time));\n+            }\n+        }\n+    }\n+\n+    if !max.is_none() && max <= Some(mtime(path)) {\n+        return\n+    }\n+    t!(File::create(path));\n+}"}, {"sha": "0f69bcfbb649da101c12e05e574e7f5a371a2732", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -76,9 +76,11 @@ pub struct Config {\n \n     // misc\n     pub channel: String,\n+    // Fallback musl-root for all targets\n     pub musl_root: Option<PathBuf>,\n     pub prefix: Option<String>,\n     pub codegen_tests: bool,\n+    pub nodejs: Option<PathBuf>,\n }\n \n /// Per-target configuration stored in the global configuration structure.\n@@ -89,6 +91,7 @@ pub struct Target {\n     pub cc: Option<PathBuf>,\n     pub cxx: Option<PathBuf>,\n     pub ndk: Option<PathBuf>,\n+    pub musl_root: Option<PathBuf>,\n }\n \n /// Structure of the `config.toml` file that configuration is read from.\n@@ -144,6 +147,7 @@ struct Rust {\n     rpath: Option<bool>,\n     optimize_tests: Option<bool>,\n     debuginfo_tests: Option<bool>,\n+    codegen_tests: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -232,6 +236,7 @@ impl Config {\n             set(&mut config.rust_optimize, rust.optimize);\n             set(&mut config.rust_optimize_tests, rust.optimize_tests);\n             set(&mut config.rust_debuginfo_tests, rust.debuginfo_tests);\n+            set(&mut config.codegen_tests, rust.codegen_tests);\n             set(&mut config.rust_rpath, rust.rpath);\n             set(&mut config.debug_jemalloc, rust.debug_jemalloc);\n             set(&mut config.use_jemalloc, rust.use_jemalloc);\n@@ -391,6 +396,9 @@ impl Config {\n                     self.rustc = Some(PathBuf::from(value).join(\"bin/rustc\"));\n                     self.cargo = Some(PathBuf::from(value).join(\"bin/cargo\"));\n                 }\n+                \"CFG_NODEJS\" if value.len() > 0 => {\n+                    self.nodejs = Some(PathBuf::from(value));\n+                }\n                 _ => {}\n             }\n         }"}, {"sha": "f054b29d0b1406cb2a7d94b979f40bc277a16ff6", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -1,5 +1,8 @@\n # Sample TOML configuration file for building Rust.\n #\n+# To configure rustbuild, copy this file to the directory from which you will be\n+# running the build, and name it config.toml.\n+#\n # All options are commented out by default in this file, and they're commented\n # out with their default values. The build system by default looks for\n # `config.toml` in the current directory of a build for build configuration, but\n@@ -115,10 +118,6 @@\n # nightly features\n #channel = \"dev\"\n \n-# The root location of the MUSL installation directory. The library directory\n-# will also need to contain libunwind.a for an unwinding implementation.\n-#musl-root = \"...\"\n-\n # By default the `rustc` executable is built with `-Wl,-rpath` flags on Unix\n # platforms to ensure that the compiler is usable by default from the build\n # directory (as it links to a number of dynamic libraries). This may not be\n@@ -130,6 +129,10 @@\n #optimize-tests = true\n #debuginfo-tests = true\n \n+# Flag indicating whether codegen tests will be run or not. If you get an error\n+# saying that the FileCheck executable is missing, you may want to disable this.\n+#codegen-tests = true\n+\n # =============================================================================\n # Options for specific targets\n #\n@@ -160,3 +163,9 @@\n # the NDK for the target lives. This is used to find the C compiler to link and\n # build native code.\n #android-ndk = \"/path/to/ndk\"\n+\n+# The root location of the MUSL installation directory. The library directory\n+# will also need to contain libunwind.a for an unwinding implementation. Note\n+# that this option only makes sense for MUSL targets that produce statically\n+# linked binaries\n+#musl-root = \"...\""}, {"sha": "31b7db168b48fd4ebb7f6317ae07376e88388841", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -388,6 +388,9 @@ pub fn rust_src(build: &Build) {\n     // Rename directory, so that root folder of tarball has the correct name\n     t!(fs::rename(&dst_src, &plain_dst_src));\n \n+    // Create the version file\n+    write_file(&plain_dst_src.join(\"version\"), build.version.as_bytes());\n+\n     // Create plain source tarball\n     let mut cmd = Command::new(\"tar\");\n     cmd.arg(\"-czf\").arg(sanitize_sh(&distdir(build).join(&format!(\"{}.tar.gz\", plain_name))))\n@@ -431,3 +434,8 @@ fn sanitize_sh(path: &Path) -> String {\n         Some(format!(\"/{}/{}\", drive, &s[drive.len_utf8() + 2..]))\n     }\n }\n+\n+fn write_file(path: &Path, data: &[u8]) {\n+    let mut vf = t!(fs::File::create(path));\n+    t!(vf.write_all(data));\n+}"}, {"sha": "c5dbb2a0319f2f030663082f90d62f309395d3ff", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -28,7 +28,6 @@ extern crate rustc_serialize;\n extern crate toml;\n extern crate regex;\n \n-use std::cell::RefCell;\n use std::collections::HashMap;\n use std::env;\n use std::fs::{self, File};\n@@ -46,7 +45,7 @@ use util::{exe, mtime, libdir, add_lib_path};\n /// * The error itself\n ///\n /// This is currently used judiciously throughout the build system rather than\n-/// using a `Result` with `try!`, but this may change on day...\n+/// using a `Result` with `try!`, but this may change one day...\n macro_rules! t {\n     ($e:expr) => (match $e {\n         Ok(e) => e,\n@@ -131,7 +130,6 @@ pub struct Build {\n     // Runtime state filled in later on\n     cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n     cxx: HashMap<String, gcc::Tool>,\n-    compiler_rt_built: RefCell<HashMap<String, PathBuf>>,\n }\n \n /// The various \"modes\" of invoking Cargo.\n@@ -198,7 +196,6 @@ impl Build {\n             package_vers: String::new(),\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n-            compiler_rt_built: RefCell::new(HashMap::new()),\n             gdb_version: None,\n             lldb_version: None,\n             lldb_python_dir: None,\n@@ -252,9 +249,6 @@ impl Build {\n                 Llvm { _dummy } => {\n                     native::llvm(self, target.target);\n                 }\n-                CompilerRt { _dummy } => {\n-                    native::compiler_rt(self, target.target);\n-                }\n                 TestHelpers { _dummy } => {\n                     native::test_helpers(self, target.target);\n                 }\n@@ -585,6 +579,8 @@ impl Build {\n         if mtime(&stamp) < mtime(input) {\n             self.verbose(&format!(\"Dirty - {}\", dir.display()));\n             let _ = fs::remove_dir_all(dir);\n+        } else if stamp.exists() {\n+            return\n         }\n         t!(fs::create_dir_all(dir));\n         t!(File::create(stamp));\n@@ -839,11 +835,6 @@ impl Build {\n         }\n     }\n \n-    /// Root output directory for compiler-rt compiled for `target`\n-    fn compiler_rt_out(&self, target: &str) -> PathBuf {\n-        self.out.join(target).join(\"compiler-rt\")\n-    }\n-\n     /// Root output directory for rust_test_helpers library compiled for\n     /// `target`\n     fn test_helpers_out(&self, target: &str) -> PathBuf {\n@@ -977,6 +968,13 @@ impl Build {\n         }\n         return base\n     }\n+\n+    /// Returns the \"musl root\" for this `target`, if defined\n+    fn musl_root(&self, target: &str) -> Option<&Path> {\n+        self.config.target_config[target].musl_root.as_ref()\n+            .or(self.config.musl_root.as_ref())\n+            .map(|p| &**p)\n+    }\n }\n \n impl<'a> Compiler<'a> {"}, {"sha": "df6408e5fe1c8ac2010abcfdd3222a6b61b976d5", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 396, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -27,7 +27,7 @@ use cmake;\n use gcc;\n \n use Build;\n-use util::{staticlib, up_to_date};\n+use util::up_to_date;\n \n /// Compile LLVM for `target`.\n pub fn llvm(build: &Build, target: &str) {\n@@ -131,401 +131,6 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n     panic!(\"\\n\\nbad LLVM version: {}, need >=3.5\\n\\n\", version)\n }\n \n-/// Compiles the `compiler-rt` library, or at least the builtins part of it.\n-///\n-/// Note that while compiler-rt has a build system associated with it, we\n-/// specifically don't use it here. The compiler-rt build system, written in\n-/// CMake, is actually *very* difficult to work with in terms of getting it to\n-/// compile on all the relevant platforms we want it to compile on. In the end\n-/// it became so much pain to work with local patches, work around the oddities\n-/// of the build system, etc, that we're just building everything by hand now.\n-///\n-/// In general compiler-rt is just a bunch of intrinsics that are in practice\n-/// *very* stable. We just need to make sure that all the relevant functions and\n-/// such are compiled somewhere and placed in an object file somewhere.\n-/// Eventually, these should all be written in Rust!\n-///\n-/// So below you'll find a listing of every single file in the compiler-rt repo\n-/// that we're compiling. We just reach in and compile with the `gcc` crate\n-/// which should have all the relevant flags and such already configured.\n-///\n-/// The risk here is that if we update compiler-rt we may need to compile some\n-/// new intrinsics, but to be honest we surely don't use all of the intrinsics\n-/// listed below today so the likelihood of us actually needing a new intrinsic\n-/// is quite low. The failure case is also just that someone reports a link\n-/// error (if any) and then we just add it to the list. Overall, that cost is\n-/// far far less than working with compiler-rt's build system over time.\n-pub fn compiler_rt(build: &Build, target: &str) {\n-    let build_dir = build.compiler_rt_out(target);\n-    let output = build_dir.join(staticlib(\"compiler-rt\", target));\n-    build.compiler_rt_built.borrow_mut().insert(target.to_string(),\n-                                                output.clone());\n-    t!(fs::create_dir_all(&build_dir));\n-\n-    let mut cfg = gcc::Config::new();\n-    cfg.cargo_metadata(false)\n-       .out_dir(&build_dir)\n-       .target(target)\n-       .host(&build.config.build)\n-       .opt_level(2)\n-       .debug(false);\n-\n-    if target.contains(\"msvc\") {\n-        // Don't pull in extra libraries on MSVC\n-        cfg.flag(\"/Zl\");\n-\n-        // Emulate C99 and C++11's __func__ for MSVC prior to 2013 CTP\n-        cfg.define(\"__func__\", Some(\"__FUNCTION__\"));\n-    } else {\n-        // Turn off various features of gcc and such, mostly copying\n-        // compiler-rt's build system already\n-        cfg.flag(\"-fno-builtin\");\n-        cfg.flag(\"-fvisibility=hidden\");\n-        cfg.flag(\"-fomit-frame-pointer\");\n-        cfg.flag(\"-ffreestanding\");\n-    }\n-\n-    let mut sources = vec![\n-        \"absvdi2.c\",\n-        \"absvsi2.c\",\n-        \"adddf3.c\",\n-        \"addsf3.c\",\n-        \"addvdi3.c\",\n-        \"addvsi3.c\",\n-        \"apple_versioning.c\",\n-        \"ashldi3.c\",\n-        \"ashrdi3.c\",\n-        \"clear_cache.c\",\n-        \"clzdi2.c\",\n-        \"clzsi2.c\",\n-        \"cmpdi2.c\",\n-        \"comparedf2.c\",\n-        \"comparesf2.c\",\n-        \"ctzdi2.c\",\n-        \"ctzsi2.c\",\n-        \"divdc3.c\",\n-        \"divdf3.c\",\n-        \"divdi3.c\",\n-        \"divmoddi4.c\",\n-        \"divmodsi4.c\",\n-        \"divsc3.c\",\n-        \"divsf3.c\",\n-        \"divsi3.c\",\n-        \"divxc3.c\",\n-        \"extendsfdf2.c\",\n-        \"extendhfsf2.c\",\n-        \"ffsdi2.c\",\n-        \"fixdfdi.c\",\n-        \"fixdfsi.c\",\n-        \"fixsfdi.c\",\n-        \"fixsfsi.c\",\n-        \"fixunsdfdi.c\",\n-        \"fixunsdfsi.c\",\n-        \"fixunssfdi.c\",\n-        \"fixunssfsi.c\",\n-        \"fixunsxfdi.c\",\n-        \"fixunsxfsi.c\",\n-        \"fixxfdi.c\",\n-        \"floatdidf.c\",\n-        \"floatdisf.c\",\n-        \"floatdixf.c\",\n-        \"floatsidf.c\",\n-        \"floatsisf.c\",\n-        \"floatundidf.c\",\n-        \"floatundisf.c\",\n-        \"floatundixf.c\",\n-        \"floatunsidf.c\",\n-        \"floatunsisf.c\",\n-        \"int_util.c\",\n-        \"lshrdi3.c\",\n-        \"moddi3.c\",\n-        \"modsi3.c\",\n-        \"muldc3.c\",\n-        \"muldf3.c\",\n-        \"muldi3.c\",\n-        \"mulodi4.c\",\n-        \"mulosi4.c\",\n-        \"muloti4.c\",\n-        \"mulsc3.c\",\n-        \"mulsf3.c\",\n-        \"mulvdi3.c\",\n-        \"mulvsi3.c\",\n-        \"mulxc3.c\",\n-        \"negdf2.c\",\n-        \"negdi2.c\",\n-        \"negsf2.c\",\n-        \"negvdi2.c\",\n-        \"negvsi2.c\",\n-        \"paritydi2.c\",\n-        \"paritysi2.c\",\n-        \"popcountdi2.c\",\n-        \"popcountsi2.c\",\n-        \"powidf2.c\",\n-        \"powisf2.c\",\n-        \"powixf2.c\",\n-        \"subdf3.c\",\n-        \"subsf3.c\",\n-        \"subvdi3.c\",\n-        \"subvsi3.c\",\n-        \"truncdfhf2.c\",\n-        \"truncdfsf2.c\",\n-        \"truncsfhf2.c\",\n-        \"ucmpdi2.c\",\n-        \"udivdi3.c\",\n-        \"udivmoddi4.c\",\n-        \"udivmodsi4.c\",\n-        \"udivsi3.c\",\n-        \"umoddi3.c\",\n-        \"umodsi3.c\",\n-    ];\n-\n-    if !target.contains(\"ios\") {\n-        sources.extend(vec![\n-            \"absvti2.c\",\n-            \"addtf3.c\",\n-            \"addvti3.c\",\n-            \"ashlti3.c\",\n-            \"ashrti3.c\",\n-            \"clzti2.c\",\n-            \"cmpti2.c\",\n-            \"ctzti2.c\",\n-            \"divtf3.c\",\n-            \"divti3.c\",\n-            \"ffsti2.c\",\n-            \"fixdfti.c\",\n-            \"fixsfti.c\",\n-            \"fixunsdfti.c\",\n-            \"fixunssfti.c\",\n-            \"fixunsxfti.c\",\n-            \"fixxfti.c\",\n-            \"floattidf.c\",\n-            \"floattisf.c\",\n-            \"floattixf.c\",\n-            \"floatuntidf.c\",\n-            \"floatuntisf.c\",\n-            \"floatuntixf.c\",\n-            \"lshrti3.c\",\n-            \"modti3.c\",\n-            \"multf3.c\",\n-            \"multi3.c\",\n-            \"mulvti3.c\",\n-            \"negti2.c\",\n-            \"negvti2.c\",\n-            \"parityti2.c\",\n-            \"popcountti2.c\",\n-            \"powitf2.c\",\n-            \"subtf3.c\",\n-            \"subvti3.c\",\n-            \"trampoline_setup.c\",\n-            \"ucmpti2.c\",\n-            \"udivmodti4.c\",\n-            \"udivti3.c\",\n-            \"umodti3.c\",\n-        ]);\n-    }\n-\n-    if target.contains(\"apple\") {\n-        sources.extend(vec![\n-            \"atomic_flag_clear.c\",\n-            \"atomic_flag_clear_explicit.c\",\n-            \"atomic_flag_test_and_set.c\",\n-            \"atomic_flag_test_and_set_explicit.c\",\n-            \"atomic_signal_fence.c\",\n-            \"atomic_thread_fence.c\",\n-        ]);\n-    }\n-\n-    if !target.contains(\"windows\") {\n-        sources.push(\"emutls.c\");\n-    }\n-\n-    if target.contains(\"msvc\") {\n-        if target.contains(\"x86_64\") {\n-            sources.extend(vec![\n-                \"x86_64/floatdidf.c\",\n-                \"x86_64/floatdisf.c\",\n-                \"x86_64/floatdixf.c\",\n-            ]);\n-        }\n-    } else {\n-        if !target.contains(\"freebsd\") {\n-            sources.push(\"gcc_personality_v0.c\");\n-        }\n-\n-        if target.contains(\"x86_64\") {\n-            sources.extend(vec![\n-                \"x86_64/chkstk.S\",\n-                \"x86_64/chkstk2.S\",\n-                \"x86_64/floatdidf.c\",\n-                \"x86_64/floatdisf.c\",\n-                \"x86_64/floatdixf.c\",\n-                \"x86_64/floatundidf.S\",\n-                \"x86_64/floatundisf.S\",\n-                \"x86_64/floatundixf.S\",\n-            ]);\n-        }\n-\n-        if target.contains(\"i386\") ||\n-           target.contains(\"i586\") ||\n-           target.contains(\"i686\") {\n-            sources.extend(vec![\n-                \"i386/ashldi3.S\",\n-                \"i386/ashrdi3.S\",\n-                \"i386/chkstk.S\",\n-                \"i386/chkstk2.S\",\n-                \"i386/divdi3.S\",\n-                \"i386/floatdidf.S\",\n-                \"i386/floatdisf.S\",\n-                \"i386/floatdixf.S\",\n-                \"i386/floatundidf.S\",\n-                \"i386/floatundisf.S\",\n-                \"i386/floatundixf.S\",\n-                \"i386/lshrdi3.S\",\n-                \"i386/moddi3.S\",\n-                \"i386/muldi3.S\",\n-                \"i386/udivdi3.S\",\n-                \"i386/umoddi3.S\",\n-            ]);\n-        }\n-    }\n-\n-    if target.contains(\"arm\") && !target.contains(\"ios\") {\n-        sources.extend(vec![\n-            \"arm/aeabi_cdcmp.S\",\n-            \"arm/aeabi_cdcmpeq_check_nan.c\",\n-            \"arm/aeabi_cfcmp.S\",\n-            \"arm/aeabi_cfcmpeq_check_nan.c\",\n-            \"arm/aeabi_dcmp.S\",\n-            \"arm/aeabi_div0.c\",\n-            \"arm/aeabi_drsub.c\",\n-            \"arm/aeabi_fcmp.S\",\n-            \"arm/aeabi_frsub.c\",\n-            \"arm/aeabi_idivmod.S\",\n-            \"arm/aeabi_ldivmod.S\",\n-            \"arm/aeabi_memcmp.S\",\n-            \"arm/aeabi_memcpy.S\",\n-            \"arm/aeabi_memmove.S\",\n-            \"arm/aeabi_memset.S\",\n-            \"arm/aeabi_uidivmod.S\",\n-            \"arm/aeabi_uldivmod.S\",\n-            \"arm/bswapdi2.S\",\n-            \"arm/bswapsi2.S\",\n-            \"arm/clzdi2.S\",\n-            \"arm/clzsi2.S\",\n-            \"arm/comparesf2.S\",\n-            \"arm/divmodsi4.S\",\n-            \"arm/divsi3.S\",\n-            \"arm/modsi3.S\",\n-            \"arm/switch16.S\",\n-            \"arm/switch32.S\",\n-            \"arm/switch8.S\",\n-            \"arm/switchu8.S\",\n-            \"arm/sync_synchronize.S\",\n-            \"arm/udivmodsi4.S\",\n-            \"arm/udivsi3.S\",\n-            \"arm/umodsi3.S\",\n-        ]);\n-    }\n-\n-    if target.contains(\"armv7\") {\n-        sources.extend(vec![\n-            \"arm/sync_fetch_and_add_4.S\",\n-            \"arm/sync_fetch_and_add_8.S\",\n-            \"arm/sync_fetch_and_and_4.S\",\n-            \"arm/sync_fetch_and_and_8.S\",\n-            \"arm/sync_fetch_and_max_4.S\",\n-            \"arm/sync_fetch_and_max_8.S\",\n-            \"arm/sync_fetch_and_min_4.S\",\n-            \"arm/sync_fetch_and_min_8.S\",\n-            \"arm/sync_fetch_and_nand_4.S\",\n-            \"arm/sync_fetch_and_nand_8.S\",\n-            \"arm/sync_fetch_and_or_4.S\",\n-            \"arm/sync_fetch_and_or_8.S\",\n-            \"arm/sync_fetch_and_sub_4.S\",\n-            \"arm/sync_fetch_and_sub_8.S\",\n-            \"arm/sync_fetch_and_umax_4.S\",\n-            \"arm/sync_fetch_and_umax_8.S\",\n-            \"arm/sync_fetch_and_umin_4.S\",\n-            \"arm/sync_fetch_and_umin_8.S\",\n-            \"arm/sync_fetch_and_xor_4.S\",\n-            \"arm/sync_fetch_and_xor_8.S\",\n-        ]);\n-    }\n-\n-    if target.contains(\"eabihf\") {\n-        sources.extend(vec![\n-            \"arm/adddf3vfp.S\",\n-            \"arm/addsf3vfp.S\",\n-            \"arm/divdf3vfp.S\",\n-            \"arm/divsf3vfp.S\",\n-            \"arm/eqdf2vfp.S\",\n-            \"arm/eqsf2vfp.S\",\n-            \"arm/extendsfdf2vfp.S\",\n-            \"arm/fixdfsivfp.S\",\n-            \"arm/fixsfsivfp.S\",\n-            \"arm/fixunsdfsivfp.S\",\n-            \"arm/fixunssfsivfp.S\",\n-            \"arm/floatsidfvfp.S\",\n-            \"arm/floatsisfvfp.S\",\n-            \"arm/floatunssidfvfp.S\",\n-            \"arm/floatunssisfvfp.S\",\n-            \"arm/gedf2vfp.S\",\n-            \"arm/gesf2vfp.S\",\n-            \"arm/gtdf2vfp.S\",\n-            \"arm/gtsf2vfp.S\",\n-            \"arm/ledf2vfp.S\",\n-            \"arm/lesf2vfp.S\",\n-            \"arm/ltdf2vfp.S\",\n-            \"arm/ltsf2vfp.S\",\n-            \"arm/muldf3vfp.S\",\n-            \"arm/mulsf3vfp.S\",\n-            \"arm/negdf2vfp.S\",\n-            \"arm/negsf2vfp.S\",\n-            \"arm/nedf2vfp.S\",\n-            \"arm/nesf2vfp.S\",\n-            \"arm/restore_vfp_d8_d15_regs.S\",\n-            \"arm/save_vfp_d8_d15_regs.S\",\n-            \"arm/subdf3vfp.S\",\n-            \"arm/subsf3vfp.S\",\n-            \"arm/truncdfsf2vfp.S\",\n-            \"arm/unorddf2vfp.S\",\n-            \"arm/unordsf2vfp.S\",\n-        ]);\n-    }\n-\n-    if target.contains(\"aarch64\") {\n-        sources.extend(vec![\n-            \"comparetf2.c\",\n-            \"extenddftf2.c\",\n-            \"extendsftf2.c\",\n-            \"fixtfdi.c\",\n-            \"fixtfsi.c\",\n-            \"fixtfti.c\",\n-            \"fixunstfdi.c\",\n-            \"fixunstfsi.c\",\n-            \"fixunstfti.c\",\n-            \"floatditf.c\",\n-            \"floatsitf.c\",\n-            \"floatunditf.c\",\n-            \"floatunsitf.c\",\n-            \"multc3.c\",\n-            \"trunctfdf2.c\",\n-            \"trunctfsf2.c\",\n-        ]);\n-    }\n-\n-    let mut out_of_date = false;\n-    for src in sources {\n-        let src = build.src.join(\"src/compiler-rt/lib/builtins\").join(src);\n-        out_of_date = out_of_date || !up_to_date(&src, &output);\n-        cfg.file(src);\n-    }\n-    if !out_of_date {\n-        return\n-    }\n-    cfg.compile(\"libcompiler-rt.a\");\n-}\n-\n /// Compiles the `rust_test_helpers.c` library which we used in various\n /// `run-pass` test suites for ABI testing.\n pub fn test_helpers(build: &Build, target: &str) {"}, {"sha": "05c35543e3e5b0584407531eb546b20a14c325b7", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -75,6 +75,12 @@ pub fn check(build: &mut Build) {\n \n     need_cmd(\"python\".as_ref());\n \n+    // If a manual nodejs was added to the config,\n+    // of if a nodejs install is detected through config, use it.\n+    if let Some(ref s) = build.config.nodejs {\n+        need_cmd(s.as_ref());\n+    }\n+\n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n     for target in build.config.target.iter() {\n@@ -111,8 +117,8 @@ pub fn check(build: &mut Build) {\n \n         // Make sure musl-root is valid if specified\n         if target.contains(\"musl\") && !target.contains(\"mips\") {\n-            match build.config.musl_root {\n-                Some(ref root) => {\n+            match build.musl_root(target) {\n+                Some(root) => {\n                     if fs::metadata(root.join(\"lib/libc.a\")).is_err() {\n                         panic!(\"couldn't find libc.a in musl dir: {}\",\n                                root.join(\"lib\").display());\n@@ -123,8 +129,9 @@ pub fn check(build: &mut Build) {\n                     }\n                 }\n                 None => {\n-                    panic!(\"when targeting MUSL the build.musl-root option \\\n-                            must be specified in config.toml\")\n+                    panic!(\"when targeting MUSL either the build.musl-root \\\n+                            option or the target.$TARGET.musl-root one must \\\n+                            be specified in config.toml\")\n                 }\n             }\n         }"}, {"sha": "5f391b70fbe88b76ef958360ad0487785ef50e91", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -82,7 +82,6 @@ macro_rules! targets {\n             // There aren't really any parameters to this, but empty structs\n             // with braces are unstable so we just pick something that works.\n             (llvm, Llvm { _dummy: () }),\n-            (compiler_rt, CompilerRt { _dummy: () }),\n             (test_helpers, TestHelpers { _dummy: () }),\n             (debugger_scripts, DebuggerScripts { stage: u32 }),\n \n@@ -334,8 +333,7 @@ impl<'a> Step<'a> {\n                 vec![self.libstd(compiler)]\n             }\n             Source::Libstd { compiler } => {\n-                vec![self.compiler_rt(()),\n-                     self.rustc(compiler.stage).target(compiler.host)]\n+                vec![self.rustc(compiler.stage).target(compiler.host)]\n             }\n             Source::LibrustcLink { compiler, host } => {\n                 vec![self.librustc(compiler),\n@@ -348,7 +346,6 @@ impl<'a> Step<'a> {\n                 vec![self.libstd(compiler),\n                      self.target(host).rustc(compiler.stage)]\n             }\n-            Source::CompilerRt { _dummy } => Vec::new(),\n             Source::Llvm { _dummy } => Vec::new(),\n             Source::TestHelpers { _dummy } => Vec::new(),\n             Source::DebuggerScripts { stage: _ } => Vec::new(),"}, {"sha": "6c0a32a54d919bf1a001d4c609e030426b0462b8", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -23,7 +23,7 @@ use filetime::FileTime;\n \n /// Returns the `name` as the filename of a static library for `target`.\n pub fn staticlib(name: &str, target: &str) -> String {\n-    if target.contains(\"windows-msvc\") {\n+    if target.contains(\"windows\") {\n         format!(\"{}.lib\", name)\n     } else {\n         format!(\"lib{}.a\", name)"}, {"sha": "8709c3f4b7b10d10bf67df1d65133250ccb589fb", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -471,7 +471,7 @@ extern {\n \n fn main() {\n     println!(\"You have readline version {} installed.\",\n-             rl_readline_version as i32);\n+             unsafe { rl_readline_version as i32 });\n }\n ```\n \n@@ -539,6 +539,7 @@ This is currently hidden behind the `abi_vectorcall` gate and is subject to chan\n * `system`\n * `C`\n * `win64`\n+* `sysv64`\n \n Most of the abis in this list are self-explanatory, but the `system` abi may\n seem a little odd. This constraint selects whatever the appropriate ABI is for"}, {"sha": "25570cb5503c94f6f3c8ccebaee24baaaa3a86a6", "filename": "src/doc/book/nightly-rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fbook%2Fnightly-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fbook%2Fnightly-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fnightly-rust.md?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -54,7 +54,7 @@ binary downloads][install-page].\n \n Oh, we should also mention the officially supported platforms:\n \n-* Windows (7, 8, Server 2008 R2)\n+* Windows (7+)\n * Linux (2.6.18 or later, various distributions), x86 and x86-64\n * OSX 10.7 (Lion) or greater, x86 and x86-64\n "}, {"sha": "2ec3a00c0df516ab73db23926639712697c0cd50", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -152,7 +152,7 @@ the thing `y` points at. You\u2019ll notice that `x` had to be marked `mut` as well\n If it wasn\u2019t, we couldn\u2019t take a mutable borrow to an immutable value.\n \n You'll also notice we added an asterisk (`*`) in front of `y`, making it `*y`,\n-this is because `y` is a `&mut` reference. You'll need to use astrisks to\n+this is because `y` is a `&mut` reference. You'll need to use asterisks to\n access the contents of a reference as well.\n \n Otherwise, `&mut` references are like references. There _is_ a large"}, {"sha": "b0d954adf6771c9bacd8d3877d5dd57ef4abcd34", "filename": "src/doc/book/traits.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fbook%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fbook%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftraits.md?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -275,7 +275,7 @@ won\u2019t have its methods:\n [write]: ../std/io/trait.Write.html\n \n ```rust,ignore\n-let mut f = std::fs::File::open(\"foo.txt\").expect(\"Couldn\u2019t open foo.txt\");\n+let mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn\u2019t create foo.txt\");\n let buf = b\"whatever\"; // byte string literal. buf: &[u8; 8]\n let result = f.write(buf);\n # result.unwrap(); // ignore the error\n@@ -291,10 +291,10 @@ let result = f.write(buf);\n \n We need to `use` the `Write` trait first:\n \n-```rust,ignore\n+```rust,no_run\n use std::io::Write;\n \n-let mut f = std::fs::File::open(\"foo.txt\").expect(\"Couldn\u2019t open foo.txt\");\n+let mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn\u2019t create foo.txt\");\n let buf = b\"whatever\";\n let result = f.write(buf);\n # result.unwrap(); // ignore the error"}, {"sha": "a6ecf6ab91b4f96c7745af6fa7deab9d146888ff", "filename": "src/doc/nomicon/ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fnomicon%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fnomicon%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fownership.md?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -52,7 +52,7 @@ let mut data = vec![1, 2, 3];\n let x = &data[0];\n \n // OH NO! `push` causes the backing storage of `data` to be reallocated.\n-// Dangling pointer! User after free! Alas!\n+// Dangling pointer! Use after free! Alas!\n // (this does not compile in Rust)\n data.push(4);\n "}, {"sha": "adede0ec911171be9fa22081c08fdfdadf398599", "filename": "src/doc/nomicon/safe-unsafe-meaning.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -26,10 +26,6 @@ can therefore be trusted. You can use `unsafe` on a trait implementation\n to declare that the implementation of that trait has adhered to whatever\n contracts the trait's documentation requires.\n \n-There is also the `#[unsafe_no_drop_flag]` attribute, which exists for\n-historic reasons and is being phased out. See the section on [drop flags]\n-for details.\n-\n The standard library has a number of unsafe functions, including:\n \n * `slice::get_unchecked`, which performs unchecked indexing, allowing"}, {"sha": "b72c3743a69ce1f34d447d7976f94b83ba62a66e", "filename": "src/doc/reference.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -1677,6 +1677,7 @@ There are also some platform-specific ABI strings:\n * `extern \"cdecl\"` -- The default for x86\\_32 C code.\n * `extern \"stdcall\"` -- The default for the Win32 API on x86\\_32.\n * `extern \"win64\"` -- The default for C code on x86\\_64 Windows.\n+* `extern \"sysv64\"` -- The default for C code on non-Windows x86\\_64.\n * `extern \"aapcs\"` -- The default for ARM.\n * `extern \"fastcall\"` -- The `fastcall` ABI -- corresponds to MSVC's\n   `__fastcall` and GCC and clang's `__attribute__((fastcall))`\n@@ -2058,10 +2059,6 @@ macro scope.\n   outside of its dynamic extent), and thus this attribute has the word\n   \"unsafe\" in its name. To use this, the\n   `unsafe_destructor_blind_to_params` feature gate must be enabled.\n-- `unsafe_no_drop_flag` - on structs, remove the flag that prevents\n-  destructors from being run twice. Destructors might be run multiple times on\n-  the same object with this attribute. To use this, the `unsafe_no_drop_flag` feature\n-  gate must be enabled.\n - `doc` - Doc comments such as `/// foo` are equivalent to `#[doc = \"foo\"]`.\n - `rustc_on_unimplemented` - Write a custom note to be shown along with the error\n    when the trait is found to be unimplemented on a type.\n@@ -2070,6 +2067,9 @@ macro scope.\n    trait of the same name. `{Self}` will be replaced with the type that is supposed\n    to implement the trait but doesn't. To use this, the `on_unimplemented` feature gate\n    must be enabled.\n+- `must_use` - on structs and enums, will warn if a value of this type isn't used or\n+   assigned to a variable. You may also include an optional message by using\n+   `#[must_use = \"message\"]` which will be given alongside the warning.\n \n ### Conditional compilation\n \n@@ -2441,6 +2441,9 @@ The currently implemented features of the reference compiler are:\n             into a Rust program. This capability, especially the signature for the\n             annotated function, is subject to change.\n \n+* `static_in_const` - Enables lifetime elision with a `'static` default for\n+                      `const` and `static` item declarations.\n+\n * `thread_local` - The usage of the `#[thread_local]` attribute is experimental\n                    and should be seen as unstable. This attribute is used to\n                    declare a `static` as being unique per-thread leveraging\n@@ -2454,12 +2457,6 @@ The currently implemented features of the reference compiler are:\n * `unboxed_closures` - Rust's new closure design, which is currently a work in\n                        progress feature with many known bugs.\n \n-* `unsafe_no_drop_flag` - Allows use of the `#[unsafe_no_drop_flag]` attribute,\n-                          which removes hidden flag added to a type that\n-                          implements the `Drop` trait. The design for the\n-                          `Drop` flag is subject to change, and this feature\n-                          may be removed in the future.\n-\n * `unmarked_api` - Allows use of items within a `#![staged_api]` crate\n                    which have not been marked with a stability marker.\n                    Such items should not be allowed by the compiler to exist,\n@@ -2485,6 +2482,9 @@ The currently implemented features of the reference compiler are:\n \n * - `dotdot_in_tuple_patterns` - Allows `..` in tuple (struct) patterns.\n \n+* - `abi_sysv64` - Allows the usage of the system V AMD64 calling convention\n+                             (e.g. `extern \"sysv64\" func fn_();`)\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled\n the new feature (because the directive is no longer necessary). However, if a"}, {"sha": "5f9ccd1820ca6181dcf1011b684e873026f15de9", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -331,6 +331,33 @@ impl<T: ?Sized> Arc<T> {\n             deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n         }\n     }\n+\n+    #[inline]\n+    #[unstable(feature = \"ptr_eq\",\n+               reason = \"newly added\",\n+               issue = \"36497\")]\n+    /// Return whether two `Arc` references point to the same value\n+    /// (not just values that compare equal).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ptr_eq)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    /// let same_five = five.clone();\n+    /// let other_five = Arc::new(5);\n+    ///\n+    /// assert!(Arc::ptr_eq(&five, &same_five));\n+    /// assert!(!Arc::ptr_eq(&five, &other_five));\n+    /// ```\n+    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n+        let this_ptr: *const ArcInner<T> = *this.ptr;\n+        let other_ptr: *const ArcInner<T> = *other.ptr;\n+        this_ptr == other_ptr\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -718,6 +745,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n \n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n+    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n     fn default() -> Weak<T> {\n         Weak::new()\n     }\n@@ -923,6 +951,7 @@ impl<T: ?Sized> fmt::Pointer for Arc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Arc<T> {\n+    /// Creates a new `Arc<T>`, with the `Default` value for T.\n     fn default() -> Arc<T> {\n         Arc::new(Default::default())\n     }\n@@ -1198,6 +1227,16 @@ mod tests {\n         let foo: Weak<usize> = Weak::new();\n         assert!(foo.upgrade().is_none());\n     }\n+\n+    #[test]\n+    fn test_ptr_eq() {\n+        let five = Arc::new(5);\n+        let same_five = five.clone();\n+        let other_five = Arc::new(5);\n+\n+        assert!(Arc::ptr_eq(&five, &same_five));\n+        assert!(!Arc::ptr_eq(&five, &other_five));\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "bc9b6e805efc91ee5107229de22de8d01ec78148", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -290,6 +290,7 @@ impl<T: ?Sized> Box<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n+    /// Creates a `Box<T>`, with the `Default` value for T.\n     fn default() -> Box<T> {\n         box Default::default()\n     }"}, {"sha": "32e5587ff41282af0fc034eab987692727488ef8", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -376,6 +376,33 @@ impl<T: ?Sized> Rc<T> {\n             None\n         }\n     }\n+\n+    #[inline]\n+    #[unstable(feature = \"ptr_eq\",\n+               reason = \"newly added\",\n+               issue = \"36497\")]\n+    /// Return whether two `Rc` references point to the same value\n+    /// (not just values that compare equal).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ptr_eq)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    /// let same_five = five.clone();\n+    /// let other_five = Rc::new(5);\n+    ///\n+    /// assert!(Rc::ptr_eq(&five, &same_five));\n+    /// assert!(!Rc::ptr_eq(&five, &other_five));\n+    /// ```\n+    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n+        let this_ptr: *const RcBox<T> = *this.ptr;\n+        let other_ptr: *const RcBox<T> = *other.ptr;\n+        this_ptr == other_ptr\n+    }\n }\n \n impl<T: Clone> Rc<T> {\n@@ -870,6 +897,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n \n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n+    /// Creates a new `Weak<T>`.\n     fn default() -> Weak<T> {\n         Weak::new()\n     }\n@@ -1173,6 +1201,16 @@ mod tests {\n         let foo: Weak<usize> = Weak::new();\n         assert!(foo.upgrade().is_none());\n     }\n+\n+    #[test]\n+    fn test_ptr_eq() {\n+        let five = Rc::new(5);\n+        let same_five = five.clone();\n+        let other_five = Rc::new(5);\n+\n+        assert!(Rc::ptr_eq(&five, &same_five));\n+        assert!(!Rc::ptr_eq(&five, &other_five));\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5bbf1c35e0dd41f0b60e6f46d0ec3f0003b050df", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -77,7 +77,9 @@ const MIN_ALIGN: usize = 8;\n #[cfg(all(any(target_arch = \"x86\",\n               target_arch = \"x86_64\",\n               target_arch = \"aarch64\",\n-              target_arch = \"powerpc64\")))]\n+              target_arch = \"powerpc64\",\n+              target_arch = \"mips64\",\n+              target_arch = \"s390x\")))]\n const MIN_ALIGN: usize = 16;\n \n // MALLOCX_ALIGN(a) macro"}, {"sha": "01407d1acd2ecda82db51af61f7f50925cc91a22", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -32,7 +32,9 @@\n               target_arch = \"asmjs\")))]\n const MIN_ALIGN: usize = 8;\n #[cfg(all(any(target_arch = \"x86_64\",\n-              target_arch = \"aarch64\")))]\n+              target_arch = \"aarch64\",\n+              target_arch = \"mips64\",\n+              target_arch = \"s390x\")))]\n const MIN_ALIGN: usize = 16;\n \n #[no_mangle]"}, {"sha": "556757ec84daf47df19ff444e523f34ba2534cf3", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 55, "deletions": 38, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -15,9 +15,8 @@\n //! of individual objects while the arena itself is still alive. The benefit\n //! of an arena is very fast allocation; just a pointer bump.\n //!\n-//! This crate has two arenas implemented: `TypedArena`, which is a simpler\n-//! arena but can only hold objects of a single type, and `Arena`, which is a\n-//! more complex, slower arena which can hold objects of any type.\n+//! This crate implements `TypedArena`, a simple arena that can only hold\n+//! objects of a single type.\n \n #![crate_name = \"arena\"]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n@@ -51,16 +50,19 @@ use std::ptr;\n use alloc::heap;\n use alloc::raw_vec::RawVec;\n \n-/// A faster arena that can hold objects of only one type.\n+/// An arena that can hold objects of only one type.\n pub struct TypedArena<T> {\n+    /// The capacity of the first chunk (once it is allocated).\n+    first_chunk_capacity: usize,\n+\n     /// A pointer to the next object to be allocated.\n     ptr: Cell<*mut T>,\n \n     /// A pointer to the end of the allocated area. When this pointer is\n     /// reached, a new chunk is allocated.\n     end: Cell<*mut T>,\n \n-    /// A vector arena segments.\n+    /// A vector of arena chunks.\n     chunks: RefCell<Vec<TypedArenaChunk<T>>>,\n \n     /// Marker indicating that dropping the arena causes its owned\n@@ -69,7 +71,7 @@ pub struct TypedArena<T> {\n }\n \n struct TypedArenaChunk<T> {\n-    /// Pointer to the next arena segment.\n+    /// The raw storage for the arena chunk.\n     storage: RawVec<T>,\n }\n \n@@ -117,26 +119,26 @@ impl<T> TypedArenaChunk<T> {\n const PAGE: usize = 4096;\n \n impl<T> TypedArena<T> {\n-    /// Creates a new `TypedArena` with preallocated space for many objects.\n+    /// Creates a new `TypedArena`.\n     #[inline]\n     pub fn new() -> TypedArena<T> {\n         // Reserve at least one page.\n         let elem_size = cmp::max(1, mem::size_of::<T>());\n         TypedArena::with_capacity(PAGE / elem_size)\n     }\n \n-    /// Creates a new `TypedArena` with preallocated space for the given number of\n-    /// objects.\n+    /// Creates a new `TypedArena`. Each chunk used within the arena will have\n+    /// space for at least the given number of objects.\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> TypedArena<T> {\n-        unsafe {\n-            let chunk = TypedArenaChunk::<T>::new(cmp::max(1, capacity));\n-            TypedArena {\n-                ptr: Cell::new(chunk.start()),\n-                end: Cell::new(chunk.end()),\n-                chunks: RefCell::new(vec![chunk]),\n-                _own: PhantomData,\n-            }\n+        TypedArena {\n+            first_chunk_capacity: cmp::max(1, capacity),\n+            // We set both `ptr` and `end` to 0 so that the first call to\n+            // alloc() will trigger a grow().\n+            ptr: Cell::new(0 as *mut T),\n+            end: Cell::new(0 as *mut T),\n+            chunks: RefCell::new(vec![]),\n+            _own: PhantomData,\n         }\n     }\n \n@@ -171,29 +173,37 @@ impl<T> TypedArena<T> {\n     fn grow(&self) {\n         unsafe {\n             let mut chunks = self.chunks.borrow_mut();\n-            let prev_capacity = chunks.last().unwrap().storage.cap();\n-            let new_capacity = prev_capacity.checked_mul(2).unwrap();\n-            if chunks.last_mut().unwrap().storage.double_in_place() {\n-                self.end.set(chunks.last().unwrap().end());\n+            let (chunk, new_capacity);\n+            if let Some(last_chunk) = chunks.last_mut() {\n+                if last_chunk.storage.double_in_place() {\n+                    self.end.set(last_chunk.end());\n+                    return;\n+                } else {\n+                    let prev_capacity = last_chunk.storage.cap();\n+                    new_capacity = prev_capacity.checked_mul(2).unwrap();\n+                }\n             } else {\n-                let chunk = TypedArenaChunk::<T>::new(new_capacity);\n-                self.ptr.set(chunk.start());\n-                self.end.set(chunk.end());\n-                chunks.push(chunk);\n+                new_capacity = self.first_chunk_capacity;\n             }\n+            chunk = TypedArenaChunk::<T>::new(new_capacity);\n+            self.ptr.set(chunk.start());\n+            self.end.set(chunk.end());\n+            chunks.push(chunk);\n         }\n     }\n     /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n     pub fn clear(&mut self) {\n         unsafe {\n             // Clear the last chunk, which is partially filled.\n             let mut chunks_borrow = self.chunks.borrow_mut();\n-            let last_idx = chunks_borrow.len() - 1;\n-            self.clear_last_chunk(&mut chunks_borrow[last_idx]);\n-            // If `T` is ZST, code below has no effect.\n-            for mut chunk in chunks_borrow.drain(..last_idx) {\n-                let cap = chunk.storage.cap();\n-                chunk.destroy(cap);\n+            if let Some(mut last_chunk) = chunks_borrow.pop() {\n+                self.clear_last_chunk(&mut last_chunk);\n+                // If `T` is ZST, code below has no effect.\n+                for mut chunk in chunks_borrow.drain(..) {\n+                    let cap = chunk.storage.cap();\n+                    chunk.destroy(cap);\n+                }\n+                chunks_borrow.push(last_chunk);\n             }\n         }\n     }\n@@ -230,13 +240,14 @@ impl<T> Drop for TypedArena<T> {\n         unsafe {\n             // Determine how much was filled.\n             let mut chunks_borrow = self.chunks.borrow_mut();\n-            let mut last_chunk = chunks_borrow.pop().unwrap();\n-            // Drop the contents of the last chunk.\n-            self.clear_last_chunk(&mut last_chunk);\n-            // The last chunk will be dropped. Destroy all other chunks.\n-            for chunk in chunks_borrow.iter_mut() {\n-                let cap = chunk.storage.cap();\n-                chunk.destroy(cap);\n+            if let Some(mut last_chunk) = chunks_borrow.pop() {\n+                // Drop the contents of the last chunk.\n+                self.clear_last_chunk(&mut last_chunk);\n+                // The last chunk will be dropped. Destroy all other chunks.\n+                for chunk in chunks_borrow.iter_mut() {\n+                    let cap = chunk.storage.cap();\n+                    chunk.destroy(cap);\n+                }\n             }\n             // RawVec handles deallocation of `last_chunk` and `self.chunks`.\n         }\n@@ -260,6 +271,12 @@ mod tests {\n         z: i32,\n     }\n \n+    #[test]\n+    pub fn test_unused() {\n+        let arena: TypedArena<Point> = TypedArena::new();\n+        assert!(arena.chunks.borrow().is_empty());\n+    }\n+\n     #[test]\n     fn test_arena_alloc_nested() {\n         struct Inner {"}, {"sha": "1fe921543bd4ed681f0ff359afd4f24c1e0273ca", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -263,6 +263,7 @@ impl<T: Clone> Clone for BinaryHeap<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Default for BinaryHeap<T> {\n+    /// Creates an empty `BinaryHeap<T>`.\n     #[inline]\n     fn default() -> BinaryHeap<T> {\n         BinaryHeap::new()\n@@ -884,58 +885,61 @@ struct Hole<'a, T: 'a> {\n \n impl<'a, T> Hole<'a, T> {\n     /// Create a new Hole at index `pos`.\n-    fn new(data: &'a mut [T], pos: usize) -> Self {\n-        unsafe {\n-            let elt = ptr::read(&data[pos]);\n-            Hole {\n-                data: data,\n-                elt: Some(elt),\n-                pos: pos,\n-            }\n+    ///\n+    /// Unsafe because pos must be within the data slice.\n+    #[inline]\n+    unsafe fn new(data: &'a mut [T], pos: usize) -> Self {\n+        debug_assert!(pos < data.len());\n+        let elt = ptr::read(&data[pos]);\n+        Hole {\n+            data: data,\n+            elt: Some(elt),\n+            pos: pos,\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn pos(&self) -> usize {\n         self.pos\n     }\n \n     /// Return a reference to the element removed\n-    #[inline(always)]\n+    #[inline]\n     fn element(&self) -> &T {\n         self.elt.as_ref().unwrap()\n     }\n \n     /// Return a reference to the element at `index`.\n     ///\n-    /// Panics if the index is out of bounds.\n-    ///\n-    /// Unsafe because index must not equal pos.\n-    #[inline(always)]\n+    /// Unsafe because index must be within the data slice and not equal to pos.\n+    #[inline]\n     unsafe fn get(&self, index: usize) -> &T {\n         debug_assert!(index != self.pos);\n-        &self.data[index]\n+        debug_assert!(index < self.data.len());\n+        self.data.get_unchecked(index)\n     }\n \n     /// Move hole to new location\n     ///\n-    /// Unsafe because index must not equal pos.\n-    #[inline(always)]\n+    /// Unsafe because index must be within the data slice and not equal to pos.\n+    #[inline]\n     unsafe fn move_to(&mut self, index: usize) {\n         debug_assert!(index != self.pos);\n-        let index_ptr: *const _ = &self.data[index];\n-        let hole_ptr = &mut self.data[self.pos];\n+        debug_assert!(index < self.data.len());\n+        let index_ptr: *const _ = self.data.get_unchecked(index);\n+        let hole_ptr = self.data.get_unchecked_mut(self.pos);\n         ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n         self.pos = index;\n     }\n }\n \n impl<'a, T> Drop for Hole<'a, T> {\n+    #[inline]\n     fn drop(&mut self) {\n         // fill the hole again\n         unsafe {\n             let pos = self.pos;\n-            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n+            ptr::write(self.data.get_unchecked_mut(pos), self.elt.take().unwrap());\n         }\n     }\n }"}, {"sha": "700f88dc0f267688bb91e057616256fc84c00e1c", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -249,6 +249,7 @@ impl<'a, B: ?Sized> Default for Cow<'a, B>\n     where B: ToOwned,\n           <B as ToOwned>::Owned: Default\n {\n+    /// Creates an owned Cow<'a, B> with the default value for the contained owned value.\n     fn default() -> Cow<'a, B> {\n         Owned(<B as ToOwned>::Owned::default())\n     }"}, {"sha": "36cb5a1fd9f6d6150a6e6d262d60e933205b3cf1", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -56,8 +56,12 @@ use self::Entry::*;\n /// however, performance is excellent.\n ///\n /// It is a logic error for a key to be modified in such a way that the key's ordering relative to\n-/// any other key, as determined by the `Ord` trait, changes while it is in the map. This is\n-/// normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n+/// any other key, as determined by the [`Ord`] trait, changes while it is in the map. This is\n+/// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n+///\n+/// [`Ord`]: ../../std/cmp/trait.Ord.html\n+/// [`Cell`]: ../../std/cell/struct.Cell.html\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n ///\n /// # Examples\n ///\n@@ -1663,6 +1667,7 @@ impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n }\n \n impl<K: Ord, V> Default for BTreeMap<K, V> {\n+    /// Creates an empty `BTreeMap<K, V>`.\n     fn default() -> BTreeMap<K, V> {\n         BTreeMap::new()\n     }\n@@ -2020,7 +2025,7 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n         self.key\n     }\n \n-    /// Sets the value of the entry with the VacantEntry's key,\n+    /// Sets the value of the entry with the `VacantEntry`'s key,\n     /// and returns a mutable reference to it.\n     ///\n     /// # Examples\n@@ -2192,7 +2197,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         self.handle.into_kv_mut().1\n     }\n \n-    /// Sets the value of the entry with the OccupiedEntry's key,\n+    /// Sets the value of the entry with the `OccupiedEntry`'s key,\n     /// and returns the entry's old value.\n     ///\n     /// # Examples"}, {"sha": "fc2a7f825474d607deaaab737ccb86aced888812", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -674,6 +674,7 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BTreeSet<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Default for BTreeSet<T> {\n+    /// Makes an empty `BTreeSet<T>` with a reasonable choice of B.\n     fn default() -> BTreeSet<T> {\n         BTreeSet::new()\n     }"}, {"sha": "690c4f4af35896df5b24cb5be112bfbf279b34e4", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -164,6 +164,7 @@ impl<T> LinkedList<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for LinkedList<T> {\n+    /// Creates an empty `LinkedList<T>`.\n     #[inline]\n     fn default() -> Self {\n         Self::new()"}, {"sha": "6a6b450e518632ff0b0666e594290d239bf077f7", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -1594,6 +1594,49 @@ impl str {\n         result\n     }\n \n+    /// Replaces first N matches of a pattern with another string.\n+    ///\n+    /// `replacen` creates a new [`String`], and copies the data from this string slice into it.\n+    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n+    /// replaces them with the replacement string slice at most `N` times.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// # #![feature(str_replacen)]\n+    /// let s = \"foo foo 123 foo\";\n+    /// assert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\n+    /// assert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\n+    /// assert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n+    /// ```\n+    ///\n+    /// When the pattern doesn't match:\n+    ///\n+    /// ```\n+    /// # #![feature(str_replacen)]\n+    /// let s = \"this is old\";\n+    /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n+    /// ```\n+    #[unstable(feature = \"str_replacen\",\n+               issue = \"36436\",\n+               reason = \"only need to replace first N matches\")]\n+    pub fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String {\n+        // Hope to reduce the times of re-allocation\n+        let mut result = String::with_capacity(32);\n+        let mut last_end = 0;\n+        for (start, part) in self.match_indices(pat).take(count) {\n+            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n+            result.push_str(to);\n+            last_end = start + part.len();\n+        }\n+        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n+        result\n+    }\n+\n     /// Returns the lowercase equivalent of this string slice, as a new [`String`].\n     ///\n     /// 'Lowercase' is defined according to the terms of the Unicode Derived Core Property"}, {"sha": "773e94f1b414e140fac6a735ff157ef0e00e88b9", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -1567,6 +1567,7 @@ impl_eq! { Cow<'a, str>, String }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for String {\n+    /// Creates an empty `String`.\n     #[inline]\n     fn default() -> String {\n         String::new()"}, {"sha": "f8b4a92df2c5dca5dc25317e7fc6ac23d8a9fb8e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -1046,21 +1046,27 @@ impl<T: Clone> Vec<T> {\n         self.reserve(n);\n \n         unsafe {\n-            let len = self.len();\n-            let mut ptr = self.as_mut_ptr().offset(len as isize);\n+            let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n+            // Use SetLenOnDrop to work around bug where compiler\n+            // may not realize the store through `ptr` trough self.set_len()\n+            // don't alias.\n+            let mut local_len = SetLenOnDrop::new(&mut self.len);\n+\n             // Write all elements except the last one\n-            for i in 1..n {\n+            for _ in 1..n {\n                 ptr::write(ptr, value.clone());\n                 ptr = ptr.offset(1);\n                 // Increment the length in every step in case clone() panics\n-                self.set_len(len + i);\n+                local_len.increment_len(1);\n             }\n \n             if n > 0 {\n                 // We can write the last element directly without cloning needlessly\n                 ptr::write(ptr, value);\n-                self.set_len(len + n);\n+                local_len.increment_len(1);\n             }\n+\n+            // len set by scope guard\n         }\n     }\n \n@@ -1085,20 +1091,56 @@ impl<T: Clone> Vec<T> {\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n         self.reserve(other.len());\n \n-        for i in 0..other.len() {\n+        // Unsafe code so this can be optimised to a memcpy (or something\n+        // similarly fast) when T is Copy. LLVM is easily confused, so any\n+        // extra operations during the loop can prevent this optimisation.\n+        unsafe {\n             let len = self.len();\n-\n-            // Unsafe code so this can be optimised to a memcpy (or something\n-            // similarly fast) when T is Copy. LLVM is easily confused, so any\n-            // extra operations during the loop can prevent this optimisation.\n-            unsafe {\n-                ptr::write(self.get_unchecked_mut(len), other.get_unchecked(i).clone());\n-                self.set_len(len + 1);\n+            let ptr = self.get_unchecked_mut(len) as *mut T;\n+            // Use SetLenOnDrop to work around bug where compiler\n+            // may not realize the store through `ptr` trough self.set_len()\n+            // don't alias.\n+            let mut local_len = SetLenOnDrop::new(&mut self.len);\n+\n+            for i in 0..other.len() {\n+                ptr::write(ptr.offset(i as isize), other.get_unchecked(i).clone());\n+                local_len.increment_len(1);\n             }\n+\n+            // len set by scope guard\n         }\n     }\n }\n \n+// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n+//\n+// The idea is: The length field in SetLenOnDrop is a local variable\n+// that the optimizer will see does not alias with any stores through the Vec's data\n+// pointer. This is a workaround for alias analysis issue #32155\n+struct SetLenOnDrop<'a> {\n+    len: &'a mut usize,\n+    local_len: usize,\n+}\n+\n+impl<'a> SetLenOnDrop<'a> {\n+    #[inline]\n+    fn new(len: &'a mut usize) -> Self {\n+        SetLenOnDrop { local_len: *len, len: len }\n+    }\n+\n+    #[inline]\n+    fn increment_len(&mut self, increment: usize) {\n+        self.local_len += increment;\n+    }\n+}\n+\n+impl<'a> Drop for SetLenOnDrop<'a> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        *self.len = self.local_len;\n+    }\n+}\n+\n impl<T: PartialEq> Vec<T> {\n     /// Removes consecutive repeated elements in the vector.\n     ///\n@@ -1610,6 +1652,7 @@ impl<T> Drop for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Vec<T> {\n+    /// Creates an empty `Vec<T>`.\n     fn default() -> Vec<T> {\n         Vec::new()\n     }"}, {"sha": "2e561dabb479451bef0aae4621d8f8243180e219", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -84,6 +84,7 @@ impl<T> Drop for VecDeque<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for VecDeque<T> {\n+    /// Creates an empty `VecDeque<T>`.\n     #[inline]\n     fn default() -> VecDeque<T> {\n         VecDeque::new()"}, {"sha": "a32e3f1a76aeacace834dc1158fd666e98ebde58", "filename": "src/libcollectionstest/btree/set.rs", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fset.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -39,30 +39,8 @@ fn test_hash() {\n   assert!(::hash(&x) == ::hash(&y));\n }\n \n-struct Counter<'a, 'b> {\n-    i: &'a mut usize,\n-    expected: &'b [i32],\n-}\n-\n-impl<'a, 'b, 'c> FnMut<(&'c i32,)> for Counter<'a, 'b> {\n-    extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c i32,)) -> bool {\n-        assert_eq!(x, self.expected[*self.i]);\n-        *self.i += 1;\n-        true\n-    }\n-}\n-\n-impl<'a, 'b, 'c> FnOnce<(&'c i32,)> for Counter<'a, 'b> {\n-    type Output = bool;\n-\n-    extern \"rust-call\" fn call_once(mut self, args: (&'c i32,)) -> bool {\n-        self.call_mut(args)\n-    }\n-}\n-\n fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F) where\n-    // FIXME Replace Counter with `Box<FnMut(_) -> _>`\n-    F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, Counter) -> bool,\n+    F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, &mut FnMut(&i32) -> bool) -> bool,\n {\n     let mut set_a = BTreeSet::new();\n     let mut set_b = BTreeSet::new();\n@@ -71,7 +49,11 @@ fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F) where\n     for y in b { assert!(set_b.insert(*y)) }\n \n     let mut i = 0;\n-    f(&set_a, &set_b, Counter { i: &mut i, expected: expected });\n+    f(&set_a, &set_b, &mut |&x| {\n+        assert_eq!(x, expected[i]);\n+        i += 1;\n+        true\n+    });\n     assert_eq!(i, expected.len());\n }\n "}, {"sha": "878581a4f296ea304277860973c041b6c2076811", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -16,12 +16,12 @@\n #![feature(collections)]\n #![feature(collections_bound)]\n #![feature(const_fn)]\n-#![feature(fn_traits)]\n #![feature(enumset)]\n #![feature(pattern)]\n #![feature(rand)]\n #![feature(step_by)]\n #![feature(str_escape)]\n+#![feature(str_replacen)]\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]"}, {"sha": "62e164a569aa642005e5daa53b38e78eeb006cda", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -218,6 +218,20 @@ fn test_is_empty() {\n     assert!(!\"a\".is_empty());\n }\n \n+#[test]\n+fn test_replacen() {\n+    assert_eq!(\"\".replacen('a', \"b\", 5), \"\");\n+    assert_eq!(\"acaaa\".replacen(\"a\", \"b\", 3), \"bcbba\");\n+    assert_eq!(\"aaaa\".replacen(\"a\", \"b\", 0), \"aaaa\");\n+\n+    let test = \"test\";\n+    assert_eq!(\" test test \".replacen(test, \"toast\", 3), \" toast toast \");\n+    assert_eq!(\" test test \".replacen(test, \"toast\", 0), \" test test \");\n+    assert_eq!(\" test test \".replacen(test, \"\", 5), \"   \");\n+\n+    assert_eq!(\"qwer123zxc789\".replacen(char::is_numeric, \"\", 3), \"qwerzxc789\");\n+}\n+\n #[test]\n fn test_replace() {\n     let a = \"a\";"}, {"sha": "a52873fc326b8af9ddfba69d7ccbf6a713b1d857", "filename": "src/libcompiler_builtins/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcompiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcompiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2FCargo.toml?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -0,0 +1,15 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+build = \"build.rs\"\n+name = \"compiler_builtins\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"compiler_builtins\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+core = { path = \"../libcore\" }\n+\n+[build-dependencies]\n+gcc = \"0.3.27\""}, {"sha": "09c400b52bc8325c627d11ea1547953145d83f99", "filename": "src/libcompiler_builtins/build.rs", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcompiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcompiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Fbuild.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -0,0 +1,404 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Compiles the `compiler-rt` library, or at least the builtins part of it.\n+//!\n+//! Note that while compiler-rt has a build system associated with it, we\n+//! specifically don't use it here. The compiler-rt build system, written in\n+//! CMake, is actually *very* difficult to work with in terms of getting it to\n+//! compile on all the relevant platforms we want it to compile on. In the end\n+//! it became so much pain to work with local patches, work around the oddities\n+//! of the build system, etc, that we're just building everything by hand now.\n+//!\n+//! In general compiler-rt is just a bunch of intrinsics that are in practice\n+//! *very* stable. We just need to make sure that all the relevant functions and\n+//! such are compiled somewhere and placed in an object file somewhere.\n+//! Eventually, these should all be written in Rust!\n+//!\n+//! So below you'll find a listing of every single file in the compiler-rt repo\n+//! that we're compiling. We just reach in and compile with the `gcc` crate\n+//! which should have all the relevant flags and such already configured.\n+//!\n+//! The risk here is that if we update compiler-rt we may need to compile some\n+//! new intrinsics, but to be honest we surely don't use all of the intrinsics\n+//! listed below today so the likelihood of us actually needing a new intrinsic\n+//! is quite low. The failure case is also just that someone reports a link\n+//! error (if any) and then we just add it to the list. Overall, that cost is\n+//! far far less than working with compiler-rt's build system over time.\n+\n+extern crate gcc;\n+\n+use std::collections::BTreeMap;\n+use std::env;\n+use std::path::Path;\n+\n+struct Sources {\n+    // SYMBOL -> PATH TO SOURCE\n+    map: BTreeMap<&'static str, &'static str>,\n+}\n+\n+impl Sources {\n+    fn new() -> Sources {\n+        Sources { map: BTreeMap::new() }\n+    }\n+\n+    fn extend(&mut self, sources: &[&'static str]) {\n+        // NOTE Some intrinsics have both a generic implementation (e.g.\n+        // `floatdidf.c`) and an arch optimized implementation\n+        // (`x86_64/floatdidf.c`). In those cases, we keep the arch optimized\n+        // implementation and discard the generic implementation. If we don't\n+        // and keep both implementations, the linker will yell at us about\n+        // duplicate symbols!\n+        for &src in sources {\n+            let symbol = Path::new(src).file_stem().unwrap().to_str().unwrap();\n+            if src.contains(\"/\") {\n+                // Arch-optimized implementation (preferred)\n+                self.map.insert(symbol, src);\n+            } else {\n+                // Generic implementation\n+                if !self.map.contains_key(symbol) {\n+                    self.map.insert(symbol, src);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let target = env::var(\"TARGET\").unwrap();\n+    let cfg = &mut gcc::Config::new();\n+\n+    if target.contains(\"msvc\") {\n+        // Don't pull in extra libraries on MSVC\n+        cfg.flag(\"/Zl\");\n+\n+        // Emulate C99 and C++11's __func__ for MSVC prior to 2013 CTP\n+        cfg.define(\"__func__\", Some(\"__FUNCTION__\"));\n+    } else {\n+        // Turn off various features of gcc and such, mostly copying\n+        // compiler-rt's build system already\n+        cfg.flag(\"-fno-builtin\");\n+        cfg.flag(\"-fvisibility=hidden\");\n+        cfg.flag(\"-fomit-frame-pointer\");\n+        cfg.flag(\"-ffreestanding\");\n+    }\n+\n+    let mut sources = Sources::new();\n+    sources.extend(&[\"absvdi2.c\",\n+                     \"absvsi2.c\",\n+                     \"adddf3.c\",\n+                     \"addsf3.c\",\n+                     \"addvdi3.c\",\n+                     \"addvsi3.c\",\n+                     \"apple_versioning.c\",\n+                     \"ashldi3.c\",\n+                     \"ashrdi3.c\",\n+                     \"clear_cache.c\",\n+                     \"clzdi2.c\",\n+                     \"clzsi2.c\",\n+                     \"cmpdi2.c\",\n+                     \"comparedf2.c\",\n+                     \"comparesf2.c\",\n+                     \"ctzdi2.c\",\n+                     \"ctzsi2.c\",\n+                     \"divdc3.c\",\n+                     \"divdf3.c\",\n+                     \"divdi3.c\",\n+                     \"divmoddi4.c\",\n+                     \"divmodsi4.c\",\n+                     \"divsc3.c\",\n+                     \"divsf3.c\",\n+                     \"divsi3.c\",\n+                     \"divxc3.c\",\n+                     \"extendsfdf2.c\",\n+                     \"extendhfsf2.c\",\n+                     \"ffsdi2.c\",\n+                     \"fixdfdi.c\",\n+                     \"fixdfsi.c\",\n+                     \"fixsfdi.c\",\n+                     \"fixsfsi.c\",\n+                     \"fixunsdfdi.c\",\n+                     \"fixunsdfsi.c\",\n+                     \"fixunssfdi.c\",\n+                     \"fixunssfsi.c\",\n+                     \"fixunsxfdi.c\",\n+                     \"fixunsxfsi.c\",\n+                     \"fixxfdi.c\",\n+                     \"floatdidf.c\",\n+                     \"floatdisf.c\",\n+                     \"floatdixf.c\",\n+                     \"floatsidf.c\",\n+                     \"floatsisf.c\",\n+                     \"floatundidf.c\",\n+                     \"floatundisf.c\",\n+                     \"floatundixf.c\",\n+                     \"floatunsidf.c\",\n+                     \"floatunsisf.c\",\n+                     \"int_util.c\",\n+                     \"lshrdi3.c\",\n+                     \"moddi3.c\",\n+                     \"modsi3.c\",\n+                     \"muldc3.c\",\n+                     \"muldf3.c\",\n+                     \"muldi3.c\",\n+                     \"mulodi4.c\",\n+                     \"mulosi4.c\",\n+                     \"muloti4.c\",\n+                     \"mulsc3.c\",\n+                     \"mulsf3.c\",\n+                     \"mulvdi3.c\",\n+                     \"mulvsi3.c\",\n+                     \"mulxc3.c\",\n+                     \"negdf2.c\",\n+                     \"negdi2.c\",\n+                     \"negsf2.c\",\n+                     \"negvdi2.c\",\n+                     \"negvsi2.c\",\n+                     \"paritydi2.c\",\n+                     \"paritysi2.c\",\n+                     \"popcountdi2.c\",\n+                     \"popcountsi2.c\",\n+                     \"powidf2.c\",\n+                     \"powisf2.c\",\n+                     \"powixf2.c\",\n+                     \"subdf3.c\",\n+                     \"subsf3.c\",\n+                     \"subvdi3.c\",\n+                     \"subvsi3.c\",\n+                     \"truncdfhf2.c\",\n+                     \"truncdfsf2.c\",\n+                     \"truncsfhf2.c\",\n+                     \"ucmpdi2.c\",\n+                     \"udivdi3.c\",\n+                     \"udivmoddi4.c\",\n+                     \"udivmodsi4.c\",\n+                     \"udivsi3.c\",\n+                     \"umoddi3.c\",\n+                     \"umodsi3.c\"]);\n+\n+    if !target.contains(\"ios\") {\n+        sources.extend(&[\"absvti2.c\",\n+                         \"addtf3.c\",\n+                         \"addvti3.c\",\n+                         \"ashlti3.c\",\n+                         \"ashrti3.c\",\n+                         \"clzti2.c\",\n+                         \"cmpti2.c\",\n+                         \"ctzti2.c\",\n+                         \"divtf3.c\",\n+                         \"divti3.c\",\n+                         \"ffsti2.c\",\n+                         \"fixdfti.c\",\n+                         \"fixsfti.c\",\n+                         \"fixunsdfti.c\",\n+                         \"fixunssfti.c\",\n+                         \"fixunsxfti.c\",\n+                         \"fixxfti.c\",\n+                         \"floattidf.c\",\n+                         \"floattisf.c\",\n+                         \"floattixf.c\",\n+                         \"floatuntidf.c\",\n+                         \"floatuntisf.c\",\n+                         \"floatuntixf.c\",\n+                         \"lshrti3.c\",\n+                         \"modti3.c\",\n+                         \"multf3.c\",\n+                         \"multi3.c\",\n+                         \"mulvti3.c\",\n+                         \"negti2.c\",\n+                         \"negvti2.c\",\n+                         \"parityti2.c\",\n+                         \"popcountti2.c\",\n+                         \"powitf2.c\",\n+                         \"subtf3.c\",\n+                         \"subvti3.c\",\n+                         \"trampoline_setup.c\",\n+                         \"ucmpti2.c\",\n+                         \"udivmodti4.c\",\n+                         \"udivti3.c\",\n+                         \"umodti3.c\"]);\n+    }\n+\n+    if target.contains(\"apple\") {\n+        sources.extend(&[\"atomic_flag_clear.c\",\n+                         \"atomic_flag_clear_explicit.c\",\n+                         \"atomic_flag_test_and_set.c\",\n+                         \"atomic_flag_test_and_set_explicit.c\",\n+                         \"atomic_signal_fence.c\",\n+                         \"atomic_thread_fence.c\"]);\n+    }\n+\n+    if !target.contains(\"windows\") {\n+        sources.extend(&[\"emutls.c\"]);\n+    }\n+\n+    if target.contains(\"msvc\") {\n+        if target.contains(\"x86_64\") {\n+            sources.extend(&[\"x86_64/floatdidf.c\", \"x86_64/floatdisf.c\", \"x86_64/floatdixf.c\"]);\n+        }\n+    } else {\n+        if !target.contains(\"freebsd\") {\n+            sources.extend(&[\"gcc_personality_v0.c\"]);\n+        }\n+\n+        if target.contains(\"x86_64\") {\n+            sources.extend(&[\"x86_64/chkstk.S\",\n+                             \"x86_64/chkstk2.S\",\n+                             \"x86_64/floatdidf.c\",\n+                             \"x86_64/floatdisf.c\",\n+                             \"x86_64/floatdixf.c\",\n+                             \"x86_64/floatundidf.S\",\n+                             \"x86_64/floatundisf.S\",\n+                             \"x86_64/floatundixf.S\"]);\n+        }\n+\n+        if target.contains(\"i386\") || target.contains(\"i586\") || target.contains(\"i686\") {\n+            sources.extend(&[\"i386/ashldi3.S\",\n+                             \"i386/ashrdi3.S\",\n+                             \"i386/chkstk.S\",\n+                             \"i386/chkstk2.S\",\n+                             \"i386/divdi3.S\",\n+                             \"i386/floatdidf.S\",\n+                             \"i386/floatdisf.S\",\n+                             \"i386/floatdixf.S\",\n+                             \"i386/floatundidf.S\",\n+                             \"i386/floatundisf.S\",\n+                             \"i386/floatundixf.S\",\n+                             \"i386/lshrdi3.S\",\n+                             \"i386/moddi3.S\",\n+                             \"i386/muldi3.S\",\n+                             \"i386/udivdi3.S\",\n+                             \"i386/umoddi3.S\"]);\n+        }\n+    }\n+\n+    if target.contains(\"arm\") && !target.contains(\"ios\") {\n+        sources.extend(&[\"arm/aeabi_cdcmp.S\",\n+                         \"arm/aeabi_cdcmpeq_check_nan.c\",\n+                         \"arm/aeabi_cfcmp.S\",\n+                         \"arm/aeabi_cfcmpeq_check_nan.c\",\n+                         \"arm/aeabi_dcmp.S\",\n+                         \"arm/aeabi_div0.c\",\n+                         \"arm/aeabi_drsub.c\",\n+                         \"arm/aeabi_fcmp.S\",\n+                         \"arm/aeabi_frsub.c\",\n+                         \"arm/aeabi_idivmod.S\",\n+                         \"arm/aeabi_ldivmod.S\",\n+                         \"arm/aeabi_memcmp.S\",\n+                         \"arm/aeabi_memcpy.S\",\n+                         \"arm/aeabi_memmove.S\",\n+                         \"arm/aeabi_memset.S\",\n+                         \"arm/aeabi_uidivmod.S\",\n+                         \"arm/aeabi_uldivmod.S\",\n+                         \"arm/bswapdi2.S\",\n+                         \"arm/bswapsi2.S\",\n+                         \"arm/clzdi2.S\",\n+                         \"arm/clzsi2.S\",\n+                         \"arm/comparesf2.S\",\n+                         \"arm/divmodsi4.S\",\n+                         \"arm/divsi3.S\",\n+                         \"arm/modsi3.S\",\n+                         \"arm/switch16.S\",\n+                         \"arm/switch32.S\",\n+                         \"arm/switch8.S\",\n+                         \"arm/switchu8.S\",\n+                         \"arm/sync_synchronize.S\",\n+                         \"arm/udivmodsi4.S\",\n+                         \"arm/udivsi3.S\",\n+                         \"arm/umodsi3.S\"]);\n+    }\n+\n+    if target.contains(\"armv7\") {\n+        sources.extend(&[\"arm/sync_fetch_and_add_4.S\",\n+                         \"arm/sync_fetch_and_add_8.S\",\n+                         \"arm/sync_fetch_and_and_4.S\",\n+                         \"arm/sync_fetch_and_and_8.S\",\n+                         \"arm/sync_fetch_and_max_4.S\",\n+                         \"arm/sync_fetch_and_max_8.S\",\n+                         \"arm/sync_fetch_and_min_4.S\",\n+                         \"arm/sync_fetch_and_min_8.S\",\n+                         \"arm/sync_fetch_and_nand_4.S\",\n+                         \"arm/sync_fetch_and_nand_8.S\",\n+                         \"arm/sync_fetch_and_or_4.S\",\n+                         \"arm/sync_fetch_and_or_8.S\",\n+                         \"arm/sync_fetch_and_sub_4.S\",\n+                         \"arm/sync_fetch_and_sub_8.S\",\n+                         \"arm/sync_fetch_and_umax_4.S\",\n+                         \"arm/sync_fetch_and_umax_8.S\",\n+                         \"arm/sync_fetch_and_umin_4.S\",\n+                         \"arm/sync_fetch_and_umin_8.S\",\n+                         \"arm/sync_fetch_and_xor_4.S\",\n+                         \"arm/sync_fetch_and_xor_8.S\"]);\n+    }\n+\n+    if target.contains(\"eabihf\") {\n+        sources.extend(&[\"arm/adddf3vfp.S\",\n+                         \"arm/addsf3vfp.S\",\n+                         \"arm/divdf3vfp.S\",\n+                         \"arm/divsf3vfp.S\",\n+                         \"arm/eqdf2vfp.S\",\n+                         \"arm/eqsf2vfp.S\",\n+                         \"arm/extendsfdf2vfp.S\",\n+                         \"arm/fixdfsivfp.S\",\n+                         \"arm/fixsfsivfp.S\",\n+                         \"arm/fixunsdfsivfp.S\",\n+                         \"arm/fixunssfsivfp.S\",\n+                         \"arm/floatsidfvfp.S\",\n+                         \"arm/floatsisfvfp.S\",\n+                         \"arm/floatunssidfvfp.S\",\n+                         \"arm/floatunssisfvfp.S\",\n+                         \"arm/gedf2vfp.S\",\n+                         \"arm/gesf2vfp.S\",\n+                         \"arm/gtdf2vfp.S\",\n+                         \"arm/gtsf2vfp.S\",\n+                         \"arm/ledf2vfp.S\",\n+                         \"arm/lesf2vfp.S\",\n+                         \"arm/ltdf2vfp.S\",\n+                         \"arm/ltsf2vfp.S\",\n+                         \"arm/muldf3vfp.S\",\n+                         \"arm/mulsf3vfp.S\",\n+                         \"arm/negdf2vfp.S\",\n+                         \"arm/negsf2vfp.S\",\n+                         \"arm/nedf2vfp.S\",\n+                         \"arm/nesf2vfp.S\",\n+                         \"arm/restore_vfp_d8_d15_regs.S\",\n+                         \"arm/save_vfp_d8_d15_regs.S\",\n+                         \"arm/subdf3vfp.S\",\n+                         \"arm/subsf3vfp.S\",\n+                         \"arm/truncdfsf2vfp.S\",\n+                         \"arm/unorddf2vfp.S\",\n+                         \"arm/unordsf2vfp.S\"]);\n+    }\n+\n+    if target.contains(\"aarch64\") {\n+        sources.extend(&[\"comparetf2.c\",\n+                         \"extenddftf2.c\",\n+                         \"extendsftf2.c\",\n+                         \"fixtfdi.c\",\n+                         \"fixtfsi.c\",\n+                         \"fixtfti.c\",\n+                         \"fixunstfdi.c\",\n+                         \"fixunstfsi.c\",\n+                         \"fixunstfti.c\",\n+                         \"floatditf.c\",\n+                         \"floatsitf.c\",\n+                         \"floatunditf.c\",\n+                         \"floatunsitf.c\",\n+                         \"multc3.c\",\n+                         \"trunctfdf2.c\",\n+                         \"trunctfsf2.c\"]);\n+    }\n+\n+    for src in sources.map.values() {\n+        cfg.file(Path::new(\"../compiler-rt/lib/builtins\").join(src));\n+    }\n+\n+    cfg.compile(\"libcompiler-rt.a\");\n+}"}, {"sha": "fbcf5204d2537df68196083b55dd94bc5ec83241", "filename": "src/libcompiler_builtins/lib.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg_attr(not(stage0), feature(compiler_builtins))]\n+#![no_std]\n+#![cfg_attr(not(stage0), compiler_builtins)]\n+#![unstable(feature = \"compiler_builtins_lib\",\n+            reason = \"internal implementation detail of rustc right now\",\n+            issue = \"0\")]\n+#![crate_name = \"compiler_builtins\"]\n+#![crate_type = \"rlib\"]\n+#![feature(staged_api)]"}, {"sha": "51221f1b9b9e94a009b599e6d1d4399cf5b3e192", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -317,6 +317,7 @@ impl<T:Copy> Clone for Cell<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Default + Copy> Default for Cell<T> {\n+    /// Creates a `Cell<T>`, with the `Default` value for T.\n     #[inline]\n     fn default() -> Cell<T> {\n         Cell::new(Default::default())\n@@ -758,6 +759,7 @@ impl<T: Clone> Clone for RefCell<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Default> Default for RefCell<T> {\n+    /// Creates a `RefCell<T>`, with the `Default` value for T.\n     #[inline]\n     fn default() -> RefCell<T> {\n         RefCell::new(Default::default())\n@@ -1139,6 +1141,7 @@ impl<T: ?Sized> UnsafeCell<T> {\n \n #[stable(feature = \"unsafe_cell_default\", since = \"1.9.0\")]\n impl<T: Default> Default for UnsafeCell<T> {\n+    /// Creates an `UnsafeCell`, with the `Default` value for T.\n     fn default() -> UnsafeCell<T> {\n         UnsafeCell::new(Default::default())\n     }"}, {"sha": "0b800cacfc19adbd41909051c8c233b1ef5f83f1", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -14,10 +14,14 @@\n //! assign them or pass them as arguments, the receiver will get a copy,\n //! leaving the original value in place. These types do not require\n //! allocation to copy and do not have finalizers (i.e. they do not\n-//! contain owned boxes or implement `Drop`), so the compiler considers\n+//! contain owned boxes or implement [`Drop`]), so the compiler considers\n //! them cheap and safe to copy. For other types copies must be made\n-//! explicitly, by convention implementing the `Clone` trait and calling\n-//! the `clone` method.\n+//! explicitly, by convention implementing the [`Clone`] trait and calling\n+//! the [`clone`][clone] method.\n+//!\n+//! [`Clone`]: trait.Clone.html\n+//! [clone]: trait.Clone.html#tymethod.clone\n+//! [`Drop`]: ../../std/ops/trait.Drop.html\n //!\n //! Basic usage example:\n //!\n@@ -46,22 +50,22 @@\n \n /// A common trait for the ability to explicitly duplicate an object.\n ///\n-/// Differs from `Copy` in that `Copy` is implicit and extremely inexpensive, while\n+/// Differs from [`Copy`] in that [`Copy`] is implicit and extremely inexpensive, while\n /// `Clone` is always explicit and may or may not be expensive. In order to enforce\n-/// these characteristics, Rust does not allow you to reimplement `Copy`, but you\n+/// these characteristics, Rust does not allow you to reimplement [`Copy`], but you\n /// may reimplement `Clone` and run arbitrary code.\n ///\n-/// Since `Clone` is more general than `Copy`, you can automatically make anything\n-/// `Copy` be `Clone` as well.\n+/// Since `Clone` is more general than [`Copy`], you can automatically make anything\n+/// [`Copy`] be `Clone` as well.\n ///\n /// ## Derivable\n ///\n /// This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d\n-/// implementation of `clone()` calls `clone()` on each field.\n+/// implementation of [`clone()`] calls [`clone()`] on each field.\n ///\n /// ## How can I implement `Clone`?\n ///\n-/// Types that are `Copy` should have a trivial implementation of `Clone`. More formally:\n+/// Types that are [`Copy`] should have a trivial implementation of `Clone`. More formally:\n /// if `T: Copy`, `x: T`, and `y: &T`, then `let x = y.clone();` is equivalent to `let x = *y;`.\n /// Manual implementations should be careful to uphold this invariant; however, unsafe code\n /// must not rely on it to ensure memory safety.\n@@ -70,6 +74,9 @@\n /// library only implements `Clone` up until arrays of size 32. In this case, the implementation of\n /// `Clone` cannot be `derive`d, but can be implemented as:\n ///\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n+/// [`clone()`]: trait.Clone.html#tymethod.clone\n+///\n /// ```\n /// #[derive(Copy)]\n /// struct Stats {\n@@ -106,10 +113,23 @@ pub trait Clone : Sized {\n     }\n }\n \n-// FIXME(aburka): this method is used solely by #[derive] to\n-// assert that every component of a type implements Clone.\n+// FIXME(aburka): these structs are used solely by #[derive] to\n+// assert that every component of a type implements Clone or Copy.\n //\n-// This should never be called by user code.\n+// These structs should never appear in user code.\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_clone_copy\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData<T> }\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_clone_copy\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n+#[cfg(stage0)]\n #[doc(hidden)]\n #[inline(always)]\n #[unstable(feature = \"derive_clone_copy\","}, {"sha": "f990a27e52b3190b8a00fd6840b7ad75ee546f62", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -129,7 +129,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// This trait can be used with `#[derive]`. When `derive`d, because `Eq` has\n /// no extra methods, it is only informing the compiler that this is an\n /// equivalence relation rather than a partial equivalence relation. Note that\n-/// the `derive` strategy requires all fields are `PartialEq`, which isn't\n+/// the `derive` strategy requires all fields are `Eq`, which isn't\n /// always desired.\n ///\n /// ## How can I implement `Eq`?\n@@ -165,6 +165,17 @@ pub trait Eq: PartialEq<Self> {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n+// FIXME: this struct is used solely by #[derive] to\n+// assert that every component of a type implements Eq.\n+//\n+// This struct should never appear in user code.\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_eq\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsEq<T: Eq + ?Sized> { _field: ::marker::PhantomData<T> }\n+\n /// An `Ordering` is the result of a comparison between two values.\n ///\n /// # Examples"}, {"sha": "5f16a4f2435f8549e49fec9d2016f33262d9ec2f", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -92,6 +92,22 @@ pub trait AsRef<T: ?Sized> {\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n ///\n+/// # Examples\n+///\n+/// [`Box<T>`] implements `AsMut<T>`:\n+///\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+///\n+/// ```\n+/// fn add_one<T: AsMut<u64>>(num: &mut T) {\n+///     *num.as_mut() += 1;\n+/// }\n+///\n+/// let mut boxed_num = Box::new(0);\n+/// add_one(&mut boxed_num);\n+/// assert_eq!(*boxed_num, 1);\n+/// ```\n+///\n /// # Generic Impls\n ///\n /// - `AsMut` auto-dereferences if the inner type is a reference or a mutable"}, {"sha": "8342d663cdc7cf7275df75e4d5affffc54bcb6c0", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -272,10 +272,14 @@ impl<'a> Arguments<'a> {\n /// safely be done so, so no constructors are given and the fields are private\n /// to prevent modification.\n ///\n-/// The `format_args!` macro will safely create an instance of this structure\n+/// The [`format_args!`] macro will safely create an instance of this structure\n /// and pass it to a function or closure, passed as the first argument. The\n-/// macro validates the format string at compile-time so usage of the `write`\n-/// and `format` functions can be safely performed.\n+/// macro validates the format string at compile-time so usage of the [`write`]\n+/// and [`format`] functions can be safely performed.\n+///\n+/// [`format_args!`]: ../../std/macro.format_args.html\n+/// [`format`]: ../../std/fmt/fn.format.html\n+/// [`write`]: ../../std/fmt/fn.write.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone)]\n pub struct Arguments<'a> {"}, {"sha": "dc53683d6337cd9c2dec11676056c4e3da8f002c", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -333,6 +333,7 @@ impl<S: Sip> Clone for Hasher<S> {\n }\n \n impl<S: Sip> Default for Hasher<S> {\n+    /// Creates a `Hasher<S>` with the two initial keys set to 0.\n     #[inline]\n     fn default() -> Hasher<S> {\n         Hasher::new_with_keys(0, 0)"}, {"sha": "22abe7a99b1870890bbfad80068066594147ab02", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -194,6 +194,20 @@ extern \"rust-intrinsic\" {\n     /// own, or if it does not enable any significant optimizations.\n     pub fn assume(b: bool);\n \n+    #[cfg(not(stage0))]\n+    /// Hints to the compiler that branch condition is likely to be true.\n+    /// Returns the value passed to it.\n+    ///\n+    /// Any use other than with `if` statements will probably not have an effect.\n+    pub fn likely(b: bool) -> bool;\n+\n+    #[cfg(not(stage0))]\n+    /// Hints to the compiler that branch condition is likely to be false.\n+    /// Returns the value passed to it.\n+    ///\n+    /// Any use other than with `if` statements will probably not have an effect.\n+    pub fn unlikely(b: bool) -> bool;\n+\n     /// Executes a breakpoint trap, for inspection by a debugger.\n     pub fn breakpoint();\n \n@@ -262,22 +276,25 @@ extern \"rust-intrinsic\" {\n     /// Moves a value out of scope without running drop glue.\n     pub fn forget<T>(_: T) -> ();\n \n-    /// Reinterprets the bits of a value of one type as another type; both types\n-    /// must have the same size. Neither the original, nor the result, may be an\n-    /// [invalid value] (../../nomicon/meet-safe-and-unsafe.html).\n+    /// Reinterprets the bits of a value of one type as another type.\n+    ///\n+    /// Both types must have the same size. Neither the original, nor the result,\n+    /// may be an [invalid value](../../nomicon/meet-safe-and-unsafe.html).\n     ///\n     /// `transmute` is semantically equivalent to a bitwise move of one type\n-    /// into another. It copies the bits from the destination type into the\n-    /// source type, then forgets the original. It's equivalent to C's `memcpy`\n-    /// under the hood, just like `transmute_copy`.\n+    /// into another. It copies the bits from the source value into the\n+    /// destination value, then forgets the original. It's equivalent to C's\n+    /// `memcpy` under the hood, just like `transmute_copy`.\n     ///\n-    /// `transmute` is incredibly unsafe. There are a vast number of ways to\n-    /// cause undefined behavior with this function. `transmute` should be\n+    /// `transmute` is **incredibly** unsafe. There are a vast number of ways to\n+    /// cause [undefined behavior][ub] with this function. `transmute` should be\n     /// the absolute last resort.\n     ///\n     /// The [nomicon](../../nomicon/transmutes.html) has additional\n     /// documentation.\n     ///\n+    /// [ub]: ../../reference.html#behavior-considered-undefined\n+    ///\n     /// # Examples\n     ///\n     /// There are a few things that `transmute` is really useful for.\n@@ -292,7 +309,8 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(bitpattern, 0x3F800000);\n     /// ```\n     ///\n-    /// Turning a pointer into a function pointer:\n+    /// Turning a pointer into a function pointer. This is *not* portable to\n+    /// machines where function pointers and data pointers have different sizes.\n     ///\n     /// ```\n     /// fn foo() -> i32 {\n@@ -305,8 +323,8 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(function(), 0);\n     /// ```\n     ///\n-    /// Extending a lifetime, or shortening an invariant lifetime; this is\n-    /// advanced, very unsafe rust:\n+    /// Extending a lifetime, or shortening an invariant lifetime. This is\n+    /// advanced, very unsafe Rust!\n     ///\n     /// ```\n     /// struct R<'a>(&'a i32);\n@@ -322,11 +340,9 @@ extern \"rust-intrinsic\" {\n     ///\n     /// # Alternatives\n     ///\n-    /// However, many uses of `transmute` can be achieved through other means.\n-    /// `transmute` can transform any type into any other, with just the caveat\n-    /// that they're the same size, and often interesting results occur. Below\n-    /// are common applications of `transmute` which can be replaced with safe\n-    /// applications of `as`:\n+    /// Don't despair: many uses of `transmute` can be achieved through other means.\n+    /// Below are common applications of `transmute` which can be replaced with safer\n+    /// constructs.\n     ///\n     /// Turning a pointer into a `usize`:\n     ///\n@@ -335,6 +351,7 @@ extern \"rust-intrinsic\" {\n     /// let ptr_num_transmute = unsafe {\n     ///     std::mem::transmute::<&i32, usize>(ptr)\n     /// };\n+    ///\n     /// // Use an `as` cast instead\n     /// let ptr_num_cast = ptr as *const i32 as usize;\n     /// ```\n@@ -346,6 +363,7 @@ extern \"rust-intrinsic\" {\n     /// let ref_transmuted = unsafe {\n     ///     std::mem::transmute::<*mut i32, &mut i32>(ptr)\n     /// };\n+    ///\n     /// // Use a reborrow instead\n     /// let ref_casted = unsafe { &mut *ptr };\n     /// ```\n@@ -357,6 +375,7 @@ extern \"rust-intrinsic\" {\n     /// let val_transmuted = unsafe {\n     ///     std::mem::transmute::<&mut i32, &mut u32>(ptr)\n     /// };\n+    ///\n     /// // Now, put together `as` and reborrowing - note the chaining of `as`\n     /// // `as` is not transitive\n     /// let val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\n@@ -368,9 +387,11 @@ extern \"rust-intrinsic\" {\n     /// // this is not a good way to do this.\n     /// let slice = unsafe { std::mem::transmute::<&str, &[u8]>(\"Rust\") };\n     /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    ///\n     /// // You could use `str::as_bytes`\n     /// let slice = \"Rust\".as_bytes();\n     /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    ///\n     /// // Or, just use a byte string, if you have control over the string\n     /// // literal\n     /// assert_eq!(b\"Rust\", &[82, 117, 115, 116]);\n@@ -381,18 +402,21 @@ extern \"rust-intrinsic\" {\n     /// ```\n     /// let store = [0, 1, 2, 3];\n     /// let mut v_orig = store.iter().collect::<Vec<&i32>>();\n+    ///\n     /// // Using transmute: this is Undefined Behavior, and a bad idea.\n     /// // However, it is no-copy.\n     /// let v_transmuted = unsafe {\n     ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(\n     ///         v_orig.clone())\n     /// };\n+    ///\n     /// // This is the suggested, safe way.\n-    /// // It does copy the entire Vector, though, into a new array.\n+    /// // It does copy the entire vector, though, into a new array.\n     /// let v_collected = v_orig.clone()\n     ///                         .into_iter()\n     ///                         .map(|r| Some(r))\n     ///                         .collect::<Vec<Option<&i32>>>();\n+    ///\n     /// // The no-copy, unsafe way, still using transmute, but not UB.\n     /// // This is equivalent to the original, but safer, and reuses the\n     /// // same Vec internals. Therefore the new inner type must have the\n@@ -412,6 +436,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// ```\n     /// use std::{slice, mem};\n+    ///\n     /// // There are multiple ways to do this; and there are multiple problems\n     /// // with the following, transmute, way.\n     /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n@@ -426,6 +451,7 @@ extern \"rust-intrinsic\" {\n     ///         (&mut slice[0..mid], &mut slice2[mid..len])\n     ///     }\n     /// }\n+    ///\n     /// // This gets rid of the typesafety problems; `&mut *` will *only* give\n     /// // you an `&mut T` from an `&mut T` or `*mut T`.\n     /// fn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n@@ -439,6 +465,7 @@ extern \"rust-intrinsic\" {\n     ///         (&mut slice[0..mid], &mut slice2[mid..len])\n     ///     }\n     /// }\n+    ///\n     /// // This is how the standard library does it. This is the best method, if\n     /// // you need to do something like this\n     /// fn split_at_stdlib<T>(slice: &mut [T], mid: usize)"}, {"sha": "0e74bbe9c2600fa5e698f0a1ae32866018834163", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -1657,6 +1657,32 @@ pub trait Iterator {\n             .map(|(_, x)| x)\n     }\n \n+    /// Returns the element that gives the maximum value with respect to the\n+    /// specified comparison function.\n+    ///\n+    /// Returns the rightmost element if the comparison determines two elements\n+    /// to be equally maximum.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(iter_max_by)]\n+    /// let a = [-3_i32, 0, 1, 5, -10];\n+    /// assert_eq!(*a.iter().max_by(|x, y| x.cmp(y)).unwrap(), 5);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_max_by\", issue=\"36105\")]\n+    fn max_by<F>(self, mut compare: F) -> Option<Self::Item>\n+        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n+    {\n+        select_fold1(self,\n+                     |_| (),\n+                     // switch to y even if it is only equal, to preserve\n+                     // stability.\n+                     |_, x, _, y| Ordering::Greater != compare(x, y))\n+            .map(|(_, x)| x)\n+    }\n+\n     /// Returns the element that gives the minimum value from the\n     /// specified function.\n     ///\n@@ -1681,6 +1707,33 @@ pub trait Iterator {\n             .map(|(_, x)| x)\n     }\n \n+    /// Returns the element that gives the minimum value with respect to the\n+    /// specified comparison function.\n+    ///\n+    /// Returns the latest element if the comparison determines two elements\n+    /// to be equally minimum.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(iter_min_by)]\n+    /// let a = [-3_i32, 0, 1, 5, -10];\n+    /// assert_eq!(*a.iter().min_by(|x, y| x.cmp(y)).unwrap(), -10);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_min_by\", issue=\"36105\")]\n+    fn min_by<F>(self, mut compare: F) -> Option<Self::Item>\n+        where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n+    {\n+        select_fold1(self,\n+                     |_| (),\n+                     // switch to y even if it is strictly smaller, to\n+                     // preserve stability.\n+                     |_, x, _, y| Ordering::Greater == compare(x, y))\n+            .map(|(_, x)| x)\n+    }\n+\n+\n     /// Reverses an iterator's direction.\n     ///\n     /// Usually, iterators iterate from left to right. After using `rev()`,\n@@ -1814,7 +1867,8 @@ pub trait Iterator {\n     /// # Panics\n     ///\n     /// When calling `sum` and a primitive integer type is being returned, this\n-    /// method will panic if the computation overflows.\n+    /// method will panic if the computation overflows and debug assertions are\n+    /// enabled.\n     ///\n     /// # Examples\n     ///\n@@ -1841,7 +1895,8 @@ pub trait Iterator {\n     /// # Panics\n     ///\n     /// When calling `product` and a primitive integer type is being returned,\n-    /// this method will panic if the computation overflows.\n+    /// method will panic if the computation overflows and debug assertions are\n+    /// enabled.\n     ///\n     /// # Examples\n     ///"}, {"sha": "dd57fd1b5190fdfb74d7adfa0ca95335671d5403", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 14, "deletions": 38, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -643,7 +643,9 @@ impl<A, B> FusedIterator for Chain<A, B>\n pub struct Zip<A, B> {\n     a: A,\n     b: B,\n-    spec: <(A, B) as ZipImplData>::Data,\n+    // index and len are only used by the specialized version of zip\n+    index: usize,\n+    len: usize,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -685,17 +687,6 @@ trait ZipImpl<A, B> {\n               B: DoubleEndedIterator + ExactSizeIterator;\n }\n \n-// Zip specialization data members\n-#[doc(hidden)]\n-trait ZipImplData {\n-    type Data: 'static + Clone + Default + fmt::Debug;\n-}\n-\n-#[doc(hidden)]\n-impl<T> ZipImplData for T {\n-    default type Data = ();\n-}\n-\n // General Zip impl\n #[doc(hidden)]\n impl<A, B> ZipImpl<A, B> for Zip<A, B>\n@@ -706,7 +697,8 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         Zip {\n             a: a,\n             b: b,\n-            spec: Default::default(), // unused\n+            index: 0, // unused\n+            len: 0, // unused\n         }\n     }\n \n@@ -759,20 +751,6 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n     }\n }\n \n-#[doc(hidden)]\n-#[derive(Default, Debug, Clone)]\n-struct ZipImplFields {\n-    index: usize,\n-    len: usize,\n-}\n-\n-#[doc(hidden)]\n-impl<A, B> ZipImplData for (A, B)\n-    where A: TrustedRandomAccess, B: TrustedRandomAccess\n-{\n-    type Data = ZipImplFields;\n-}\n-\n #[doc(hidden)]\n impl<A, B> ZipImpl<A, B> for Zip<A, B>\n     where A: TrustedRandomAccess, B: TrustedRandomAccess\n@@ -782,18 +760,16 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         Zip {\n             a: a,\n             b: b,\n-            spec: ZipImplFields {\n-                index: 0,\n-                len: len,\n-            }\n+            index: 0,\n+            len: len,\n         }\n     }\n \n     #[inline]\n     fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        if self.spec.index < self.spec.len {\n-            let i = self.spec.index;\n-            self.spec.index += 1;\n+        if self.index < self.len {\n+            let i = self.index;\n+            self.index += 1;\n             unsafe {\n                 Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n             }\n@@ -804,7 +780,7 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.spec.len - self.spec.index;\n+        let len = self.len - self.index;\n         (len, Some(len))\n     }\n \n@@ -813,9 +789,9 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         where A: DoubleEndedIterator + ExactSizeIterator,\n               B: DoubleEndedIterator + ExactSizeIterator\n     {\n-        if self.spec.index < self.spec.len {\n-            self.spec.len -= 1;\n-            let i = self.spec.len;\n+        if self.index < self.len {\n+            self.len -= 1;\n+            let i = self.len;\n             unsafe {\n                 Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n             }"}, {"sha": "b55d6f96af9bfbcbd23d47c6cbb41e8a1d0feb67", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+use ops::{Mul, Add};\n \n /// Conversion from an `Iterator`.\n ///\n@@ -581,41 +582,34 @@ pub trait Product<A = Self>: Sized {\n     fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n }\n \n+// NB: explicitly use Add and Mul here to inherit overflow checks\n macro_rules! integer_sum_product {\n     ($($a:ident)*) => ($(\n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Sum for $a {\n             fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(0, |a, b| {\n-                    a.checked_add(b).expect(\"overflow in sum\")\n-                })\n+                iter.fold(0, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Product for $a {\n             fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(1, |a, b| {\n-                    a.checked_mul(b).expect(\"overflow in product\")\n-                })\n+                iter.fold(1, Mul::mul)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Sum<&'a $a> for $a {\n             fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(0, |a, b| {\n-                    a.checked_add(*b).expect(\"overflow in sum\")\n-                })\n+                iter.cloned().fold(0, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Product<&'a $a> for $a {\n             fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(1, |a, b| {\n-                    a.checked_mul(*b).expect(\"overflow in product\")\n-                })\n+                iter.cloned().fold(1, Mul::mul)\n             }\n         }\n     )*)"}, {"sha": "99c24e4c48d44a51a7a0ce0aa7f76add4845ff5d", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 89, "deletions": 7, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -119,6 +119,44 @@ macro_rules! assert_eq {\n     });\n }\n \n+/// Asserts that two expressions are not equal to each other.\n+///\n+/// On panic, this macro will print the values of the expressions with their\n+/// debug representations.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let a = 3;\n+/// let b = 2;\n+/// assert_ne!(a, b);\n+/// ```\n+#[macro_export]\n+#[stable(feature = \"assert_ne\", since = \"1.12.0\")]\n+macro_rules! assert_ne {\n+    ($left:expr , $right:expr) => ({\n+        match (&$left, &$right) {\n+            (left_val, right_val) => {\n+                if *left_val == *right_val {\n+                    panic!(\"assertion failed: `(left != right)` \\\n+                           (left: `{:?}`, right: `{:?}`)\", left_val, right_val)\n+                }\n+            }\n+        }\n+    });\n+    ($left:expr , $right:expr, $($arg:tt)*) => ({\n+        match (&($left), &($right)) {\n+            (left_val, right_val) => {\n+                if *left_val == *right_val {\n+                    panic!(\"assertion failed: `(left != right)` \\\n+                           (left: `{:?}`, right: `{:?}`): {}\", left_val, right_val,\n+                           format_args!($($arg)*))\n+                }\n+            }\n+        }\n+    });\n+}\n+\n /// Ensure that a boolean expression is `true` at runtime.\n ///\n /// This will invoke the `panic!` macro if the provided expression cannot be\n@@ -189,10 +227,44 @@ macro_rules! debug_assert_eq {\n     ($($arg:tt)*) => (if cfg!(debug_assertions) { assert_eq!($($arg)*); })\n }\n \n-/// Helper macro for unwrapping `Result` values while returning early with an\n-/// error if the value of the expression is `Err`. Can only be used in\n-/// functions that return `Result` because of the early return of `Err` that\n-/// it provides.\n+/// Asserts that two expressions are not equal to each other.\n+///\n+/// On panic, this macro will print the values of the expressions with their\n+/// debug representations.\n+///\n+/// Unlike `assert_ne!`, `debug_assert_ne!` statements are only enabled in non\n+/// optimized builds by default. An optimized build will omit all\n+/// `debug_assert_ne!` statements unless `-C debug-assertions` is passed to the\n+/// compiler. This makes `debug_assert_ne!` useful for checks that are too\n+/// expensive to be present in a release build but may be helpful during\n+/// development.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let a = 3;\n+/// let b = 2;\n+/// debug_assert_ne!(a, b);\n+/// ```\n+#[macro_export]\n+#[stable(feature = \"assert_ne\", since = \"1.12.0\")]\n+macro_rules! debug_assert_ne {\n+    ($($arg:tt)*) => (if cfg!(debug_assertions) { assert_ne!($($arg)*); })\n+}\n+\n+/// Helper macro for reducing boilerplate code for matching `Result` together\n+/// with converting downstream errors.\n+///\n+/// `try!` matches the given `Result`. In case of the `Ok` variant, the\n+/// expression has the value of the wrapped value.\n+///\n+/// In case of the `Err` variant, it retrieves the inner error. `try!` then\n+/// performs conversion using `From`. This provides automatic conversion\n+/// between specialized errors and more general ones. The resulting\n+/// error is then immediately returned.\n+///\n+/// Because of the early return, `try!` can only be used in functions that\n+/// return `Result`.\n ///\n /// # Examples\n ///\n@@ -201,18 +273,28 @@ macro_rules! debug_assert_eq {\n /// use std::fs::File;\n /// use std::io::prelude::*;\n ///\n-/// fn write_to_file_using_try() -> Result<(), io::Error> {\n+/// enum MyError {\n+///     FileWriteError\n+/// }\n+///\n+/// impl From<io::Error> for MyError {\n+///     fn from(e: io::Error) -> MyError {\n+///         MyError::FileWriteError\n+///     }\n+/// }\n+///\n+/// fn write_to_file_using_try() -> Result<(), MyError> {\n ///     let mut file = try!(File::create(\"my_best_friends.txt\"));\n ///     try!(file.write_all(b\"This is a list of my best friends.\"));\n ///     println!(\"I wrote to the file\");\n ///     Ok(())\n /// }\n /// // This is equivalent to:\n-/// fn write_to_file_using_match() -> Result<(), io::Error> {\n+/// fn write_to_file_using_match() -> Result<(), MyError> {\n ///     let mut file = try!(File::create(\"my_best_friends.txt\"));\n ///     match file.write_all(b\"This is a list of my best friends.\") {\n ///         Ok(v) => v,\n-///         Err(e) => return Err(e),\n+///         Err(e) => return Err(From::from(e)),\n ///     }\n ///     println!(\"I wrote to the file\");\n ///     Ok(())"}, {"sha": "5a1a034a36358d9d1098f537517fe2d26c7d8839", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 274, "deletions": 142, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Primitive traits and marker types representing basic 'kinds' of types.\n+//! Primitive traits and types representing basic properties of types.\n //!\n //! Rust types can be classified in various useful ways according to\n-//! intrinsic properties of the type. These classifications, often called\n-//! 'kinds', are represented as traits.\n+//! their intrinsic properties. These classifications are represented\n+//! as traits.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -22,7 +22,21 @@ use hash::Hasher;\n \n /// Types that can be transferred across thread boundaries.\n ///\n-/// This trait is automatically derived when the compiler determines it's appropriate.\n+/// This trait is automatically implemented when the compiler determines it's\n+/// appropriate.\n+///\n+/// An example of a non-`Send` type is the reference-counting pointer\n+/// [`rc::Rc`][rc]. If two threads attempt to clone `Rc`s that point to the same\n+/// reference-counted value, they might try to update the reference count at the\n+/// same time, which is [undefined behavior][ub] because `Rc` doesn't use atomic\n+/// operations. Its cousin [`sync::Arc`][arc] does use atomic operations (incurring\n+/// some overhead) and thus is `Send`.\n+///\n+/// See [the Nomicon](../../nomicon/send-and-sync.html) for more details.\n+///\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [arc]: ../../std/sync/struct.Arc.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n@@ -38,10 +52,10 @@ impl<T: ?Sized> !Send for *const T { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !Send for *mut T { }\n \n-/// Types with a constant size known at compile-time.\n+/// Types with a constant size known at compile time.\n ///\n-/// All type parameters which can be bounded have an implicit bound of `Sized`. The special syntax\n-/// `?Sized` can be used to remove this bound if it is not appropriate.\n+/// All type parameters have an implicit bound of `Sized`. The special syntax\n+/// `?Sized` can be used to remove this bound if it's not appropriate.\n ///\n /// ```\n /// # #![allow(dead_code)]\n@@ -51,6 +65,26 @@ impl<T: ?Sized> !Send for *mut T { }\n /// // struct FooUse(Foo<[i32]>); // error: Sized is not implemented for [i32]\n /// struct BarUse(Bar<[i32]>); // OK\n /// ```\n+///\n+/// The one exception is the implicit `Self` type of a trait, which does not\n+/// get an implicit `Sized` bound. This is because a `Sized` bound prevents\n+/// the trait from being used to form a [trait object]:\n+///\n+/// ```\n+/// # #![allow(unused_variables)]\n+/// trait Foo { }\n+/// trait Bar: Sized { }\n+///\n+/// struct Impl;\n+/// impl Foo for Impl { }\n+/// impl Bar for Impl { }\n+///\n+/// let x: &Foo = &Impl;    // OK\n+/// // let y: &Bar = &Impl; // error: the trait `Bar` cannot\n+///                         // be made into an object\n+/// ```\n+///\n+/// [trait object]: ../../book/trait-objects.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n@@ -59,14 +93,27 @@ pub trait Sized {\n     // Empty.\n }\n \n-/// Types that can be \"unsized\" to a dynamically sized type.\n+/// Types that can be \"unsized\" to a dynamically-sized type.\n+///\n+/// For example, the sized array type `[i8; 2]` implements `Unsize<[i8]>` and\n+/// `Unsize<fmt::Debug>`.\n+///\n+/// All implementations of `Unsize` are provided automatically by the compiler.\n+///\n+/// `Unsize` is used along with [`ops::CoerceUnsized`][coerceunsized] to allow\n+/// \"user-defined\" containers such as [`rc::Rc`][rc] to contain dynamically-sized\n+/// types. See the [DST coercion RFC][RFC982] for more details.\n+///\n+/// [coerceunsized]: ../ops/trait.CoerceUnsized.html\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [RFC982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n #[unstable(feature = \"unsize\", issue = \"27732\")]\n #[lang=\"unsize\"]\n pub trait Unsize<T: ?Sized> {\n     // Empty.\n }\n \n-/// Types that can be copied by simply copying bits (i.e. `memcpy`).\n+/// Types whose values can be duplicated simply by copying bits.\n ///\n /// By default, variable bindings have 'move semantics.' In other\n /// words:\n@@ -87,7 +134,8 @@ pub trait Unsize<T: ?Sized> {\n /// However, if a type implements `Copy`, it instead has 'copy semantics':\n ///\n /// ```\n-/// // we can just derive a `Copy` implementation\n+/// // We can derive a `Copy` implementation. `Clone` is also required, as it's\n+/// // a supertrait of `Copy`.\n /// #[derive(Debug, Copy, Clone)]\n /// struct Foo;\n ///\n@@ -100,13 +148,59 @@ pub trait Unsize<T: ?Sized> {\n /// println!(\"{:?}\", x); // A-OK!\n /// ```\n ///\n-/// It's important to note that in these two examples, the only difference is if you are allowed to\n-/// access `x` after the assignment: a move is also a bitwise copy under the hood.\n+/// It's important to note that in these two examples, the only difference is whether you\n+/// are allowed to access `x` after the assignment. Under the hood, both a copy and a move\n+/// can result in bits being copied in memory, although this is sometimes optimized away.\n+///\n+/// ## How can I implement `Copy`?\n+///\n+/// There are two ways to implement `Copy` on your type. The simplest is to use `derive`:\n+///\n+/// ```\n+/// #[derive(Copy, Clone)]\n+/// struct MyStruct;\n+/// ```\n+///\n+/// You can also implement `Copy` and `Clone` manually:\n+///\n+/// ```\n+/// struct MyStruct;\n+///\n+/// impl Copy for MyStruct { }\n+///\n+/// impl Clone for MyStruct {\n+///     fn clone(&self) -> MyStruct {\n+///         *self\n+///     }\n+/// }\n+/// ```\n+///\n+/// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n+/// bound on type parameters, which isn't always desired.\n+///\n+/// ## What's the difference between `Copy` and `Clone`?\n+///\n+/// Copies happen implicitly, for example as part of an assignment `y = x`. The behavior of\n+/// `Copy` is not overloadable; it is always a simple bit-wise copy.\n+///\n+/// Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`][clone] can\n+/// provide any type-specific behavior necessary to duplicate values safely. For example,\n+/// the implementation of `Clone` for [`String`][string] needs to copy the pointed-to string\n+/// buffer in the heap. A simple bitwise copy of `String` values would merely copy the\n+/// pointer, leading to a double free down the line. For this reason, `String` is `Clone`\n+/// but not `Copy`.\n+///\n+/// `Clone` is a supertrait of `Copy`, so everything which is `Copy` must also implement\n+/// `Clone`. If a type is `Copy` then its `Clone` implementation need only return `*self`\n+/// (see the example above).\n+///\n+/// [clone]: ../clone/trait.Clone.html\n+/// [string]: ../../std/string/struct.String.html\n ///\n /// ## When can my type be `Copy`?\n ///\n /// A type can implement `Copy` if all of its components implement `Copy`. For example, this\n-/// `struct` can be `Copy`:\n+/// struct can be `Copy`:\n ///\n /// ```\n /// # #[allow(dead_code)]\n@@ -116,7 +210,8 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// A `struct` can be `Copy`, and `i32` is `Copy`, so therefore, `Point` is eligible to be `Copy`.\n+/// A struct can be `Copy`, and `i32` is `Copy`, therefore `Point` is eligible to be `Copy`.\n+/// By contrast, consider\n ///\n /// ```\n /// # #![allow(dead_code)]\n@@ -126,107 +221,114 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// The `PointList` `struct` cannot implement `Copy`, because `Vec<T>` is not `Copy`. If we\n+/// The struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\n /// attempt to derive a `Copy` implementation, we'll get an error:\n ///\n /// ```text\n /// the trait `Copy` may not be implemented for this type; field `points` does not implement `Copy`\n /// ```\n ///\n-/// ## When can my type _not_ be `Copy`?\n+/// ## When *can't* my type be `Copy`?\n ///\n /// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n-/// mutable reference, and copying `String` would result in two attempts to free the same buffer.\n-///\n-/// Generalizing the latter case, any type implementing `Drop` can't be `Copy`, because it's\n-/// managing some resource besides its own `size_of::<T>()` bytes.\n-///\n-/// ## What if I derive `Copy` on a type that can't?\n-///\n-/// If you try to derive `Copy` on a struct or enum, you will get a compile-time error.\n-/// Specifically, with structs you'll get [E0204](https://doc.rust-lang.org/error-index.html#E0204)\n-/// and with enums you'll get [E0205](https://doc.rust-lang.org/error-index.html#E0205).\n-///\n-/// ## When should my type be `Copy`?\n-///\n-/// Generally speaking, if your type _can_ implement `Copy`, it should. There's one important thing\n-/// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n-/// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n-/// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n-///\n-/// ## Derivable\n+/// mutable reference. Copying [`String`] would duplicate responsibility for managing the `String`'s\n+/// buffer, leading to a double free.\n ///\n-/// This trait can be used with `#[derive]` if all of its components implement `Copy` and the type\n-/// implements `Clone`. The implementation will copy the bytes of each field using `memcpy`.\n+/// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n+/// managing some resource besides its own [`size_of::<T>()`] bytes.\n ///\n-/// ## How can I implement `Copy`?\n+/// If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get a\n+/// compile-time error. Specifically, with structs you'll get [E0204] and with enums you'll get\n+/// [E0205].\n ///\n-/// There are two ways to implement `Copy` on your type:\n+/// [E0204]: https://doc.rust-lang.org/error-index.html#E0204\n+/// [E0205]: https://doc.rust-lang.org/error-index.html#E0205\n ///\n-/// ```\n-/// #[derive(Copy, Clone)]\n-/// struct MyStruct;\n-/// ```\n+/// ## When *should* my type be `Copy`?\n ///\n-/// and\n-///\n-/// ```\n-/// struct MyStruct;\n-/// impl Copy for MyStruct {}\n-/// impl Clone for MyStruct { fn clone(&self) -> MyStruct { *self } }\n-/// ```\n+/// Generally speaking, if your type _can_ implement `Copy`, it should. Keep in mind, though,\n+/// that implementing `Copy` is part of the public API of your type. If the type might become\n+/// non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to\n+/// avoid a breaking API change.\n ///\n-/// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n-/// bound on type parameters, which isn't always desired.\n+/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`Drop`]: ../../std/ops/trait.Drop.html\n+/// [`size_of::<T>()`]: ../../std/mem/fn.size_of.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n pub trait Copy : Clone {\n     // Empty.\n }\n \n-/// Types that can be safely shared between threads when aliased.\n+/// Types for which it is safe to share references between threads.\n+///\n+/// This trait is automatically implemented when the compiler determines\n+/// it's appropriate.\n ///\n /// The precise definition is: a type `T` is `Sync` if `&T` is\n-/// thread-safe. In other words, there is no possibility of data races\n-/// when passing `&T` references between threads.\n-///\n-/// As one would expect, primitive types like `u8` and `f64` are all\n-/// `Sync`, and so are simple aggregate types containing them (like\n-/// tuples, structs and enums). More instances of basic `Sync` types\n-/// include \"immutable\" types like `&T` and those with simple\n-/// inherited mutability, such as `Box<T>`, `Vec<T>` and most other\n-/// collection types. (Generic parameters need to be `Sync` for their\n-/// container to be `Sync`.)\n-///\n-/// A somewhat surprising consequence of the definition is `&mut T` is\n-/// `Sync` (if `T` is `Sync`) even though it seems that it might\n-/// provide unsynchronized mutation. The trick is a mutable reference\n-/// stored in an aliasable reference (that is, `& &mut T`) becomes\n-/// read-only, as if it were a `& &T`, hence there is no risk of a data\n-/// race.\n+/// [`Send`][send]. In other words, if there is no possibility of\n+/// [undefined behavior][ub] (including data races) when passing\n+/// `&T` references between threads.\n+///\n+/// As one would expect, primitive types like [`u8`][u8] and [`f64`][f64]\n+/// are all `Sync`, and so are simple aggregate types containing them,\n+/// like tuples, structs and enums. More examples of basic `Sync`\n+/// types include \"immutable\" types like `&T`, and those with simple\n+/// inherited mutability, such as [`Box<T>`][box], [`Vec<T>`][vec] and\n+/// most other collection types. (Generic parameters need to be `Sync`\n+/// for their container to be `Sync`.)\n+///\n+/// A somewhat surprising consequence of the definition is that `&mut T`\n+/// is `Sync` (if `T` is `Sync`) even though it seems like that might\n+/// provide unsynchronized mutation. The trick is that a mutable\n+/// reference behind a shared reference (that is, `& &mut T`)\n+/// becomes read-only, as if it were a `& &T`. Hence there is no risk\n+/// of a data race.\n ///\n /// Types that are not `Sync` are those that have \"interior\n-/// mutability\" in a non-thread-safe way, such as `Cell` and `RefCell`\n-/// in `std::cell`. These types allow for mutation of their contents\n-/// even when in an immutable, aliasable slot, e.g. the contents of\n-/// `&Cell<T>` can be `.set`, and do not ensure data races are\n-/// impossible, hence they cannot be `Sync`. A higher level example\n-/// of a non-`Sync` type is the reference counted pointer\n-/// `std::rc::Rc`, because any reference `&Rc<T>` can clone a new\n-/// reference, which modifies the reference counts in a non-atomic\n-/// way.\n-///\n-/// For cases when one does need thread-safe interior mutability,\n-/// types like the atomics in `std::sync` and `Mutex` & `RWLock` in\n-/// the `sync` crate do ensure that any mutation cannot cause data\n-/// races.  Hence these types are `Sync`.\n+/// mutability\" in a non-thread-safe form, such as [`cell::Cell`][cell]\n+/// and [`cell::RefCell`][refcell]. These types allow for mutation of\n+/// their contents even through an immutable, shared reference. For\n+/// example the `set` method on `Cell<T>` takes `&self`, so it requires\n+/// only a shared reference `&Cell<T>`. The method performs no\n+/// synchronization, thus `Cell` cannot be `Sync`.\n ///\n-/// Any types with interior mutability must also use the `std::cell::UnsafeCell`\n-/// wrapper around the value(s) which can be mutated when behind a `&`\n-/// reference; not doing this is undefined behavior (for example,\n-/// `transmute`-ing from `&T` to `&mut T` is invalid).\n+/// Another example of a non-`Sync` type is the reference-counting\n+/// pointer [`rc::Rc`][rc]. Given any reference `&Rc<T>`, you can clone\n+/// a new `Rc<T>`, modifying the reference counts in a non-atomic way.\n ///\n-/// This trait is automatically derived when the compiler determines it's appropriate.\n+/// For cases when one does need thread-safe interior mutability,\n+/// Rust provides [atomic data types], as well as explicit locking via\n+/// [`sync::Mutex`][mutex] and [`sync::RWLock`][rwlock]. These types\n+/// ensure that any mutation cannot cause data races, hence the types\n+/// are `Sync`. Likewise, [`sync::Arc`][arc] provides a thread-safe\n+/// analogue of `Rc`.\n+///\n+/// Any types with interior mutability must also use the\n+/// [`cell::UnsafeCell`][unsafecell] wrapper around the value(s) which\n+/// can be mutated through a shared reference. Failing to doing this is\n+/// [undefined behavior][ub]. For example, [`transmute`][transmute]-ing\n+/// from `&T` to `&mut T` is invalid.\n+///\n+/// See [the Nomicon](../../nomicon/send-and-sync.html) for more\n+/// details about `Sync`.\n+///\n+/// [send]: trait.Send.html\n+/// [u8]: ../../std/primitive.u8.html\n+/// [f64]: ../../std/primitive.f64.html\n+/// [box]: ../../std/boxed/struct.Box.html\n+/// [vec]: ../../std/vec/struct.Vec.html\n+/// [cell]: ../cell/struct.Cell.html\n+/// [refcell]: ../cell/struct.RefCell.html\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [arc]: ../../std/sync/struct.Arc.html\n+/// [atomic data types]: ../sync/atomic/index.html\n+/// [mutex]: ../../std/sync/struct.Mutex.html\n+/// [rwlock]: ../../std/sync/struct.RwLock.html\n+/// [unsafecell]: ../cell/struct.UnsafeCell.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [transmute]: ../../std/mem/fn.transmute.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n@@ -295,29 +397,30 @@ macro_rules! impls{\n         )\n }\n \n-/// `PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`,\n-/// even though it does not. This allows you to inform the compiler about certain safety properties\n-/// of your code.\n+/// Zero-sized type used to mark things that \"act like\" they own a `T`.\n ///\n-/// For a more in-depth explanation of how to use `PhantomData<T>`, please see [the Nomicon].\n+/// Adding a `PhantomData<T>` field to your type tells the compiler that your\n+/// type acts as though it stores a value of type `T`, even though it doesn't\n+/// really. This information is used when computing certain safety properties.\n ///\n-/// [the Nomicon]: ../../nomicon/phantom-data.html\n+/// For a more in-depth explanation of how to use `PhantomData<T>`, please see\n+/// [the Nomicon](../../nomicon/phantom-data.html).\n ///\n /// # A ghastly note \ud83d\udc7b\ud83d\udc7b\ud83d\udc7b\n ///\n-/// Though they both have scary names, `PhantomData<T>` and 'phantom types' are related, but not\n-/// identical. Phantom types are a more general concept that don't require `PhantomData<T>` to\n-/// implement, but `PhantomData<T>` is the most common way to implement them in a correct manner.\n+/// Though they both have scary names, `PhantomData` and 'phantom types' are\n+/// related, but not identical. A phantom type parameter is simply a type\n+/// parameter which is never used. In Rust, this often causes the compiler to\n+/// complain, and the solution is to add a \"dummy\" use by way of `PhantomData`.\n ///\n /// # Examples\n ///\n-/// ## Unused lifetime parameter\n+/// ## Unused lifetime parameters\n ///\n-/// Perhaps the most common time that `PhantomData` is required is\n-/// with a struct that has an unused lifetime parameter, typically as\n-/// part of some unsafe code. For example, here is a struct `Slice`\n-/// that has two pointers of type `*const T`, presumably pointing into\n-/// an array somewhere:\n+/// Perhaps the most common use case for `PhantomData` is a struct that has an\n+/// unused lifetime parameter, typically as part of some unsafe code. For\n+/// example, here is a struct `Slice` that has two pointers of type `*const T`,\n+/// presumably pointing into an array somewhere:\n ///\n /// ```ignore\n /// struct Slice<'a, T> {\n@@ -331,7 +434,7 @@ macro_rules! impls{\n /// intent is not expressed in the code, since there are no uses of\n /// the lifetime `'a` and hence it is not clear what data it applies\n /// to. We can correct this by telling the compiler to act *as if* the\n-/// `Slice` struct contained a borrowed reference `&'a T`:\n+/// `Slice` struct contained a reference `&'a T`:\n ///\n /// ```\n /// use std::marker::PhantomData;\n@@ -340,29 +443,53 @@ macro_rules! impls{\n /// struct Slice<'a, T: 'a> {\n ///     start: *const T,\n ///     end: *const T,\n-///     phantom: PhantomData<&'a T>\n+///     phantom: PhantomData<&'a T>,\n /// }\n /// ```\n ///\n-/// This also in turn requires that we annotate `T:'a`, indicating\n-/// that `T` is a type that can be borrowed for the lifetime `'a`.\n+/// This also in turn requires the annotation `T: 'a`, indicating\n+/// that any references in `T` are valid over the lifetime `'a`.\n+///\n+/// When initializing a `Slice` you simply provide the value\n+/// `PhantomData` for the field `phantom`:\n+///\n+/// ```\n+/// # #![allow(dead_code)]\n+/// # use std::marker::PhantomData;\n+/// # struct Slice<'a, T: 'a> {\n+/// #     start: *const T,\n+/// #     end: *const T,\n+/// #     phantom: PhantomData<&'a T>,\n+/// # }\n+/// fn borrow_vec<'a, T>(vec: &'a Vec<T>) -> Slice<'a, T> {\n+///     let ptr = vec.as_ptr();\n+///     Slice {\n+///         start: ptr,\n+///         end: unsafe { ptr.offset(vec.len() as isize) },\n+///         phantom: PhantomData,\n+///     }\n+/// }\n+/// ```\n ///\n /// ## Unused type parameters\n ///\n-/// It sometimes happens that there are unused type parameters that\n+/// It sometimes happens that you have unused type parameters which\n /// indicate what type of data a struct is \"tied\" to, even though that\n /// data is not actually found in the struct itself. Here is an\n-/// example where this arises when handling external resources over a\n-/// foreign function interface. `PhantomData<T>` can prevent\n-/// mismatches by enforcing types in the method implementations:\n+/// example where this arises with [FFI]. The foreign interface uses\n+/// handles of type `*mut ()` to refer to Rust values of different\n+/// types. We track the Rust type using a phantom type parameter on\n+/// the struct `ExternalResource` which wraps a handle.\n+///\n+/// [FFI]: ../../book/ffi.html\n ///\n /// ```\n /// # #![allow(dead_code)]\n-/// # trait ResType { fn foo(&self); }\n+/// # trait ResType { }\n /// # struct ParamType;\n /// # mod foreign_lib {\n-/// # pub fn new(_: usize) -> *mut () { 42 as *mut () }\n-/// # pub fn do_stuff(_: *mut (), _: usize) {}\n+/// #     pub fn new(_: usize) -> *mut () { 42 as *mut () }\n+/// #     pub fn do_stuff(_: *mut (), _: usize) {}\n /// # }\n /// # fn convert_params(_: ParamType) -> usize { 42 }\n /// use std::marker::PhantomData;\n@@ -389,21 +516,20 @@ macro_rules! impls{\n /// }\n /// ```\n ///\n-/// ## Indicating ownership\n+/// ## Ownership and the drop check\n ///\n-/// Adding a field of type `PhantomData<T>` also indicates that your\n-/// struct owns data of type `T`. This in turn implies that when your\n-/// struct is dropped, it may in turn drop one or more instances of\n-/// the type `T`, though that may not be apparent from the other\n-/// structure of the type itself. This is commonly necessary if the\n-/// structure is using a raw pointer like `*mut T` whose referent\n-/// may be dropped when the type is dropped, as a `*mut T` is\n-/// otherwise not treated as owned.\n+/// Adding a field of type `PhantomData<T>` indicates that your\n+/// type owns data of type `T`. This in turn implies that when your\n+/// type is dropped, it may drop one or more instances of the type\n+/// `T`. This has bearing on the Rust compiler's [drop check]\n+/// analysis.\n ///\n /// If your struct does not in fact *own* the data of type `T`, it is\n /// better to use a reference type, like `PhantomData<&'a T>`\n /// (ideally) or `PhantomData<*const T>` (if no lifetime applies), so\n /// as not to indicate ownership.\n+///\n+/// [drop check]: ../../nomicon/dropck.html\n #[lang = \"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T:?Sized>;\n@@ -419,10 +545,13 @@ mod impls {\n \n /// Types that can be reflected over.\n ///\n-/// This trait is implemented for all types. Its purpose is to ensure\n-/// that when you write a generic function that will employ\n-/// reflection, that must be reflected (no pun intended) in the\n-/// generic bounds of that function. Here is an example:\n+/// By \"reflection\" we mean use of the [`Any`][any] trait, or related\n+/// machinery such as [`TypeId`][typeid].\n+///\n+/// `Reflect` is implemented for all types. Its purpose is to ensure\n+/// that when you write a generic function that will employ reflection,\n+/// that must be reflected (no pun intended) in the generic bounds of\n+/// that function.\n ///\n /// ```\n /// #![feature(reflect_marker)]\n@@ -436,21 +565,24 @@ mod impls {\n /// }\n /// ```\n ///\n-/// Without the declaration `T: Reflect`, `foo` would not type check\n-/// (note: as a matter of style, it would be preferable to write\n-/// `T: Any`, because `T: Any` implies `T: Reflect` and `T: 'static`, but\n-/// we use `Reflect` here to show how it works). The `Reflect` bound\n-/// thus serves to alert `foo`'s caller to the fact that `foo` may\n-/// behave differently depending on whether `T = u32` or not. In\n-/// particular, thanks to the `Reflect` bound, callers know that a\n-/// function declared like `fn bar<T>(...)` will always act in\n-/// precisely the same way no matter what type `T` is supplied,\n-/// because there are no bounds declared on `T`. (The ability for a\n-/// caller to reason about what a function may do based solely on what\n-/// generic bounds are declared is often called the [\"parametricity\n-/// property\"][1].)\n-///\n-/// [1]: http://en.wikipedia.org/wiki/Parametricity\n+/// Without the bound `T: Reflect`, `foo` would not typecheck. (As\n+/// a matter of style, it would be preferable to write `T: Any`,\n+/// because `T: Any` implies `T: Reflect` and `T: 'static`, but we\n+/// use `Reflect` here for illustrative purposes.)\n+///\n+/// The `Reflect` bound serves to alert `foo`'s caller to the\n+/// fact that `foo` may behave differently depending on whether\n+/// `T` is `u32` or not. The ability for a caller to reason about what\n+/// a function may do based solely on what generic bounds are declared\n+/// is often called the \"[parametricity property][param]\". Despite the\n+/// use of `Reflect`, Rust lacks true parametricity because a generic\n+/// function can, at the very least, call [`mem::size_of`][size_of]\n+/// without employing any trait bounds whatsoever.\n+///\n+/// [any]: ../any/trait.Any.html\n+/// [typeid]: ../any/struct.TypeId.html\n+/// [param]: http://en.wikipedia.org/wiki/Parametricity\n+/// [size_of]: ../mem/fn.size_of.html\n #[rustc_reflect_like]\n #[unstable(feature = \"reflect_marker\",\n            reason = \"requires RFC and more experience\","}, {"sha": "d3b8a60b79776c3f00a304e3430f006b1a4abc59", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 201, "deletions": 93, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -21,54 +21,39 @@ use ptr;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n \n-/// Leaks a value into the void, consuming ownership and never running its\n-/// destructor.\n+/// Leaks a value: takes ownership and \"forgets\" about the value **without running\n+/// its destructor**.\n ///\n-/// This function will take ownership of its argument, but is distinct from the\n-/// `mem::drop` function in that it **does not run the destructor**, leaking the\n-/// value and any resources that it owns.\n+/// Any resources the value manages, such as heap memory or a file handle, will linger\n+/// forever in an unreachable state.\n ///\n-/// There's only a few reasons to use this function. They mainly come\n-/// up in unsafe code or FFI code.\n-///\n-/// * You have an uninitialized value, perhaps for performance reasons, and\n-///   need to prevent the destructor from running on it.\n-/// * You have two copies of a value (like when writing something like\n-///   [`mem::swap`][swap]), but need the destructor to only run once to\n-///   prevent a double `free`.\n-/// * Transferring resources across [FFI][ffi] boundaries.\n-///\n-/// [swap]: fn.swap.html\n-/// [ffi]: ../../book/ffi.html\n+/// If you want to dispose of a value properly, running its destructor, see\n+/// [`mem::drop`][drop].\n ///\n /// # Safety\n ///\n-/// This function is not marked as `unsafe` as Rust does not guarantee that the\n-/// `Drop` implementation for a value will always run. Note, however, that\n-/// leaking resources such as memory or I/O objects is likely not desired, so\n-/// this function is only recommended for specialized use cases.\n-///\n-/// The safety of this function implies that when writing `unsafe` code\n-/// yourself care must be taken when leveraging a destructor that is required to\n-/// run to preserve memory safety. There are known situations where the\n-/// destructor may not run (such as if ownership of the object with the\n-/// destructor is returned) which must be taken into account.\n+/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n+/// do not include a guarantee that destructors will always run. For example,\n+/// a program can create a reference cycle using [`Rc`][rc], or call\n+/// [`process:exit`][exit] to exit without running destructors. Thus, allowing\n+/// `mem::forget` from safe code does not fundamentally change Rust's safety\n+/// guarantees.\n ///\n-/// # Other forms of Leakage\n+/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n+/// so `forget` is only recommended for specialized use cases like those shown below.\n ///\n-/// It's important to point out that this function is not the only method by\n-/// which a value can be leaked in safe Rust code. Other known sources of\n-/// leakage are:\n+/// Because forgetting a value is allowed, any `unsafe` code you write must\n+/// allow for this possibility. You cannot return a value and expect that the\n+/// caller will necessarily run the value's destructor.\n ///\n-/// * `Rc` and `Arc` cycles\n-/// * `mpsc::{Sender, Receiver}` cycles (they use `Arc` internally)\n-/// * Panicking destructors are likely to leak local resources\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [exit]: ../../std/process/fn.exit.html\n ///\n-/// # Example\n+/// # Examples\n ///\n /// Leak some heap memory by never deallocating it:\n ///\n-/// ```rust\n+/// ```\n /// use std::mem;\n ///\n /// let heap_memory = Box::new(3);\n@@ -77,17 +62,51 @@ pub use intrinsics::transmute;\n ///\n /// Leak an I/O object, never closing the file:\n ///\n-/// ```rust,no_run\n+/// ```no_run\n /// use std::mem;\n /// use std::fs::File;\n ///\n /// let file = File::open(\"foo.txt\").unwrap();\n /// mem::forget(file);\n /// ```\n ///\n-/// The `mem::swap` function uses `mem::forget` to good effect:\n+/// The practical use cases for `forget` are rather specialized and mainly come\n+/// up in unsafe or FFI code.\n+///\n+/// ## Use case 1\n+///\n+/// You have created an uninitialized value using [`mem::uninitialized`][uninit].\n+/// You must either initialize or `forget` it on every computation path before\n+/// Rust drops it automatically, like at the end of a scope or after a panic.\n+/// Running the destructor on an uninitialized value would be [undefined behavior][ub].\n+///\n+/// ```\n+/// use std::mem;\n+/// use std::ptr;\n+///\n+/// # let some_condition = false;\n+/// unsafe {\n+///     let mut uninit_vec: Vec<u32> = mem::uninitialized();\n+///\n+///     if some_condition {\n+///         // Initialize the variable.\n+///         ptr::write(&mut uninit_vec, Vec::new());\n+///     } else {\n+///         // Forget the uninitialized value so its destructor doesn't run.\n+///         mem::forget(uninit_vec);\n+///     }\n+/// }\n+/// ```\n+///\n+/// ## Use case 2\n+///\n+/// You have duplicated the bytes making up a value, without doing a proper\n+/// [`Clone`][clone]. You need the value's destructor to run only once,\n+/// because a double `free` is undefined behavior.\n ///\n-/// ```rust\n+/// An example is the definition of [`mem::swap`][swap] in this module:\n+///\n+/// ```\n /// use std::mem;\n /// use std::ptr;\n ///\n@@ -109,6 +128,41 @@ pub use intrinsics::transmute;\n ///     }\n /// }\n /// ```\n+///\n+/// ## Use case 3\n+///\n+/// You are transferring ownership across a [FFI] boundary to code written in\n+/// another language. You need to `forget` the value on the Rust side because Rust\n+/// code is no longer responsible for it.\n+///\n+/// ```no_run\n+/// use std::mem;\n+///\n+/// extern \"C\" {\n+///     fn my_c_function(x: *const u32);\n+/// }\n+///\n+/// let x: Box<u32> = Box::new(3);\n+///\n+/// // Transfer ownership into C code.\n+/// unsafe {\n+///     my_c_function(&*x);\n+/// }\n+/// mem::forget(x);\n+/// ```\n+///\n+/// In this case, C code must call back into Rust to free the object. Calling C's `free`\n+/// function on a [`Box`][box] is *not* safe! Also, `Box` provides an [`into_raw`][into_raw]\n+/// method which is the preferred way to do this in practice.\n+///\n+/// [drop]: fn.drop.html\n+/// [uninit]: fn.uninitialized.html\n+/// [clone]: ../clone/trait.Clone.html\n+/// [swap]: fn.swap.html\n+/// [FFI]: ../../book/ffi.html\n+/// [box]: ../../std/boxed/struct.Box.html\n+/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn forget<T>(t: T) {\n@@ -133,25 +187,40 @@ pub fn size_of<T>() -> usize {\n     unsafe { intrinsics::size_of::<T>() }\n }\n \n-/// Returns the size of the given value in bytes.\n+/// Returns the size of the pointed-to value in bytes.\n+///\n+/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n+/// statically known size, e.g. a slice [`[T]`][slice] or a [trait object],\n+/// then `size_of_val` can be used to get the dynamically-known size.\n+///\n+/// [slice]: ../../std/primitive.slice.html\n+/// [trait object]: ../../book/trait-objects.html\n ///\n /// # Examples\n ///\n /// ```\n /// use std::mem;\n ///\n /// assert_eq!(4, mem::size_of_val(&5i32));\n+///\n+/// let x: [u8; 13] = [0; 13];\n+/// let y: &[u8] = &x;\n+/// assert_eq!(13, mem::size_of_val(y));\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::size_of_val(val) }\n }\n \n-/// Returns the ABI-required minimum alignment of a type\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n ///\n /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n ///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n /// # Examples\n ///\n /// ```\n@@ -167,7 +236,11 @@ pub fn min_align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n-/// Returns the ABI-required minimum alignment of the type of the value that `val` points to\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n ///\n /// # Examples\n ///\n@@ -184,10 +257,14 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Returns the alignment in memory for a type.\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n ///\n /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n ///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n /// # Examples\n ///\n /// ```\n@@ -201,7 +278,11 @@ pub fn align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n-/// Returns the ABI-required minimum alignment of the type of the value that `val` points to\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n ///\n /// # Examples\n ///\n@@ -216,23 +297,31 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Creates a value initialized to zero.\n+/// Creates a value whose bytes are all zero.\n+///\n+/// This has the same effect as allocating space with\n+/// [`mem::uninitialized`][uninit] and then zeroing it out. It is useful for\n+/// [FFI] sometimes, but should generally be avoided.\n ///\n-/// This function is similar to allocating space for a local variable and zeroing it out (an unsafe\n-/// operation).\n+/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n+/// some type `T`. If `T` has a destructor and the value is destroyed (due to\n+/// a panic or the end of a scope) before being initialized, then the destructor\n+/// will run on zeroed data, likely leading to [undefined behavior][ub].\n ///\n-/// Care must be taken when using this function, if the type `T` has a destructor and the value\n-/// falls out of scope (due to unwinding or returning) before being initialized, then the\n-/// destructor will run on zeroed data, likely leading to crashes.\n+/// See also the documentation for [`mem::uninitialized`][uninit], which has\n+/// many of the same caveats.\n ///\n-/// This is useful for FFI functions sometimes, but should generally be avoided.\n+/// [uninit]: fn.uninitialized.html\n+/// [FFI]: ../../book/ffi.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n ///\n /// # Examples\n ///\n /// ```\n /// use std::mem;\n ///\n /// let x: i32 = unsafe { mem::zeroed() };\n+/// assert_eq!(0, x);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -241,32 +330,38 @@ pub unsafe fn zeroed<T>() -> T {\n }\n \n /// Bypasses Rust's normal memory-initialization checks by pretending to\n-/// produce a value of type T, while doing nothing at all.\n+/// produce a value of type `T`, while doing nothing at all.\n ///\n /// **This is incredibly dangerous, and should not be done lightly. Deeply\n /// consider initializing your memory with a default value instead.**\n ///\n-/// This is useful for FFI functions and initializing arrays sometimes,\n+/// This is useful for [FFI] functions and initializing arrays sometimes,\n /// but should generally be avoided.\n ///\n-/// # Undefined Behavior\n+/// [FFI]: ../../book/ffi.html\n ///\n-/// It is Undefined Behavior to read uninitialized memory. Even just an\n+/// # Undefined behavior\n+///\n+/// It is [undefined behavior][ub] to read uninitialized memory, even just an\n /// uninitialized boolean. For instance, if you branch on the value of such\n-/// a boolean your program may take one, both, or neither of the branches.\n+/// a boolean, your program may take one, both, or neither of the branches.\n ///\n-/// Note that this often also includes *writing* to the uninitialized value.\n-/// Rust believes the value is initialized, and will therefore try to Drop\n-/// the uninitialized value and its fields if you try to overwrite the memory\n-/// in a normal manner. The only way to safely initialize an arbitrary\n-/// uninitialized value is with one of the `ptr` functions: `write`, `copy`, or\n-/// `copy_nonoverlapping`. This isn't necessary if `T` is a primitive\n-/// or otherwise only contains types that don't implement Drop.\n+/// Writing to the uninitialized value is similarly dangerous. Rust believes the\n+/// value is initialized, and will therefore try to [`Drop`][drop] the uninitialized\n+/// value and its fields if you try to overwrite it in a normal manner. The only way\n+/// to safely initialize an uninitialized value is with [`ptr::write`][write],\n+/// [`ptr::copy`][copy], or [`ptr::copy_nonoverlapping`][copy_no].\n ///\n-/// If this value *does* need some kind of Drop, it must be initialized before\n+/// If the value does implement `Drop`, it must be initialized before\n /// it goes out of scope (and therefore would be dropped). Note that this\n /// includes a `panic` occurring and unwinding the stack suddenly.\n ///\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [write]: ../ptr/fn.write.html\n+/// [copy]: ../intrinsics/fn.copy.html\n+/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n+/// [drop]: ../ops/trait.Drop.html\n+///\n /// # Examples\n ///\n /// Here's how to safely initialize an array of `Vec`s.\n@@ -309,8 +404,8 @@ pub unsafe fn zeroed<T>() -> T {\n /// println!(\"{:?}\", &data[0]);\n /// ```\n ///\n-/// This example emphasizes exactly how delicate and dangerous doing this is.\n-/// Note that the `vec!` macro *does* let you initialize every element with a\n+/// This example emphasizes exactly how delicate and dangerous using `mem::uninitialized`\n+/// can be. Note that the `vec!` macro *does* let you initialize every element with a\n /// value that is only `Clone`, so the following is semantically equivalent and\n /// vastly less dangerous, as long as you can live with an extra heap\n /// allocation:\n@@ -325,21 +420,20 @@ pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n \n-/// Swap the values at two mutable locations of the same type, without deinitializing or copying\n-/// either one.\n+/// Swaps the values at two mutable locations, without deinitializing either one.\n ///\n /// # Examples\n ///\n /// ```\n /// use std::mem;\n ///\n-/// let x = &mut 5;\n-/// let y = &mut 42;\n+/// let mut x = 5;\n+/// let mut y = 42;\n ///\n-/// mem::swap(x, y);\n+/// mem::swap(&mut x, &mut y);\n ///\n-/// assert_eq!(42, *x);\n-/// assert_eq!(5, *y);\n+/// assert_eq!(42, x);\n+/// assert_eq!(5, y);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -361,10 +455,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n }\n \n /// Replaces the value at a mutable location with a new one, returning the old value, without\n-/// deinitializing or copying either one.\n-///\n-/// This is primarily used for transferring and swapping ownership of a value in a mutable\n-/// location.\n+/// deinitializing either one.\n ///\n /// # Examples\n ///\n@@ -373,15 +464,17 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// ```\n /// use std::mem;\n ///\n-/// let mut v: Vec<i32> = Vec::new();\n+/// let mut v: Vec<i32> = vec![1, 2];\n ///\n-/// mem::replace(&mut v, Vec::new());\n+/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n+/// assert_eq!(2, old_v.len());\n+/// assert_eq!(3, v.len());\n /// ```\n ///\n-/// This function allows consumption of one field of a struct by replacing it with another value.\n-/// The normal approach doesn't always work:\n+/// `replace` allows consumption of a struct field by replacing it with another value.\n+/// Without `replace` you can run into issues like these:\n ///\n-/// ```rust,ignore\n+/// ```ignore\n /// struct Buffer<T> { buf: Vec<T> }\n ///\n /// impl<T> Buffer<T> {\n@@ -401,6 +494,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// ```\n /// # #![allow(dead_code)]\n /// use std::mem;\n+///\n /// # struct Buffer<T> { buf: Vec<T> }\n /// impl<T> Buffer<T> {\n ///     fn get_and_reset(&mut self) -> Vec<T> {\n@@ -417,14 +511,25 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n \n /// Disposes of a value.\n ///\n-/// While this does call the argument's implementation of `Drop`, it will not\n-/// release any borrows, as borrows are based on lexical scope.\n+/// While this does call the argument's implementation of [`Drop`][drop],\n+/// it will not release any borrows, as borrows are based on lexical scope.\n ///\n /// This effectively does nothing for\n /// [types which implement `Copy`](../../book/ownership.html#copy-types),\n /// e.g. integers. Such values are copied and _then_ moved into the function,\n /// so the value persists after this function call.\n ///\n+/// This function is not magic; it is literally defined as\n+///\n+/// ```\n+/// pub fn drop<T>(_x: T) { }\n+/// ```\n+///\n+/// Because `_x` is moved into the function, it is automatically dropped before\n+/// the function returns.\n+///\n+/// [drop]: ../ops/trait.Drop.html\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -461,8 +566,8 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// v.push(4); // no problems\n /// ```\n ///\n-/// Since `RefCell` enforces the borrow rules at runtime, `drop()` can\n-/// seemingly release a borrow of one:\n+/// Since `RefCell` enforces the borrow rules at runtime, `drop` can\n+/// release a `RefCell` borrow:\n ///\n /// ```\n /// use std::cell::RefCell;\n@@ -478,7 +583,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"{}\", *borrow);\n /// ```\n ///\n-/// Integers and other types implementing `Copy` are unaffected by `drop()`\n+/// Integers and other types implementing `Copy` are unaffected by `drop`.\n ///\n /// ```\n /// #[derive(Copy, Clone)]\n@@ -496,19 +601,22 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n-/// Interprets `src` as `&U`, and then reads `src` without moving the contained\n-/// value.\n+/// Interprets `src` as having type `&U`, and then reads `src` without moving\n+/// the contained value.\n ///\n /// This function will unsafely assume the pointer `src` is valid for\n-/// `sizeof(U)` bytes by transmuting `&T` to `&U` and then reading the `&U`. It\n-/// will also unsafely create a copy of the contained value instead of moving\n-/// out of `src`.\n+/// [`size_of::<U>()`][size_of] bytes by transmuting `&T` to `&U` and then reading\n+/// the `&U`. It will also unsafely create a copy of the contained value instead of\n+/// moving out of `src`.\n ///\n /// It is not a compile-time error if `T` and `U` have different sizes, but it\n /// is highly encouraged to only invoke this function where `T` and `U` have the\n-/// same size. This function triggers undefined behavior if `U` is larger than\n+/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n /// `T`.\n ///\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [size_of]: fn.size_of.html\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "1ca550c67463c3606c8db65c78577235ca283feb", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -474,9 +474,9 @@ macro_rules! define_bignum {\n                 let sz = if self.size < 1 {1} else {self.size};\n                 let digitlen = mem::size_of::<$ty>() * 2;\n \n-                try!(write!(f, \"{:#x}\", self.base[sz-1]));\n+                write!(f, \"{:#x}\", self.base[sz-1])?;\n                 for &v in self.base[..sz-1].iter().rev() {\n-                    try!(write!(f, \"_{:01$x}\", v, digitlen));\n+                    write!(f, \"_{:01$x}\", v, digitlen)?;\n                 }\n                 ::result::Result::Ok(())\n             }"}, {"sha": "5c2cc671969e480f6a218b0d61e8f385404a2e96", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -2211,25 +2211,21 @@ macro_rules! uint_impl {\n             let mut base = self;\n             let mut acc = 1;\n \n-            let mut prev_base = self;\n-            let mut base_oflo = false;\n-            while exp > 0 {\n+            while exp > 1 {\n                 if (exp & 1) == 1 {\n-                    if base_oflo {\n-                        // ensure overflow occurs in the same manner it\n-                        // would have otherwise (i.e. signal any exception\n-                        // it would have otherwise).\n-                        acc = acc * (prev_base * prev_base);\n-                    } else {\n-                        acc = acc * base;\n-                    }\n+                    acc = acc * base;\n                 }\n-                prev_base = base;\n-                let (new_base, new_base_oflo) = base.overflowing_mul(base);\n-                base = new_base;\n-                base_oflo = new_base_oflo;\n                 exp /= 2;\n+                base = base * base;\n             }\n+\n+            // Deal with the final bit of the exponent separately, since\n+            // squaring the base afterwards is not necessary and may cause a\n+            // needless overflow.\n+            if exp == 1 {\n+                acc = acc * base;\n+            }\n+\n             acc\n         }\n "}, {"sha": "85a52da332db53a8842a803ee14b83dd70fbf2d8", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -282,6 +282,12 @@ macro_rules! forward_ref_binop {\n ///                Point { x: 3, y: 3 });\n /// }\n /// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n+/// [std::time::SystemTime] implements `Add<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime + Duration`.\n+///\n+/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n #[lang = \"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Add<RHS=Self> {\n@@ -349,6 +355,12 @@ add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n ///                Point { x: 1, y: 0 });\n /// }\n /// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n+/// [std::time::SystemTime] implements `Sub<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime - Duration`.\n+///\n+/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n #[lang = \"sub\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Sub<RHS=Self> {"}, {"sha": "b9fb2dc90c728054c0deb7f786abfc8b69ca5bd9", "filename": "src/libcore/option.rs", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -10,9 +10,9 @@\n \n //! Optional values.\n //!\n-//! Type `Option` represents an optional value: every `Option`\n-//! is either `Some` and contains a value, or `None`, and\n-//! does not. `Option` types are very common in Rust code, as\n+//! Type [`Option`] represents an optional value: every [`Option`]\n+//! is either [`Some`] and contains a value, or [`None`], and\n+//! does not. [`Option`] types are very common in Rust code, as\n //! they have a number of uses:\n //!\n //! * Initial values\n@@ -26,8 +26,8 @@\n //! * Nullable pointers\n //! * Swapping things out of difficult situations\n //!\n-//! Options are commonly paired with pattern matching to query the presence\n-//! of a value and take action, always accounting for the `None` case.\n+//! [`Option`]s are commonly paired with pattern matching to query the presence\n+//! of a value and take action, always accounting for the [`None`] case.\n //!\n //! ```\n //! fn divide(numerator: f64, denominator: f64) -> Option<f64> {\n@@ -57,13 +57,13 @@\n //!\n //! Rust's pointer types must always point to a valid location; there are\n //! no \"null\" pointers. Instead, Rust has *optional* pointers, like\n-//! the optional owned box, `Option<Box<T>>`.\n+//! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n //!\n-//! The following example uses `Option` to create an optional box of\n-//! `i32`. Notice that in order to use the inner `i32` value first the\n+//! The following example uses [`Option`] to create an optional box of\n+//! [`i32`]. Notice that in order to use the inner [`i32`] value first the\n //! `check_optional` function needs to use pattern matching to\n-//! determine whether the box has a value (i.e. it is `Some(...)`) or\n-//! not (`None`).\n+//! determine whether the box has a value (i.e. it is [`Some(...)`][`Some`]) or\n+//! not ([`None`]).\n //!\n //! ```\n //! let optional: Option<Box<i32>> = None;\n@@ -80,14 +80,14 @@\n //! }\n //! ```\n //!\n-//! This usage of `Option` to create safe nullable pointers is so\n+//! This usage of [`Option`] to create safe nullable pointers is so\n //! common that Rust does special optimizations to make the\n-//! representation of `Option<Box<T>>` a single pointer. Optional pointers\n+//! representation of [`Option`]`<`[`Box<T>`]`>` a single pointer. Optional pointers\n //! in Rust are stored as efficiently as any other pointer type.\n //!\n //! # Examples\n //!\n-//! Basic pattern matching on `Option`:\n+//! Basic pattern matching on [`Option`]:\n //!\n //! ```\n //! let msg = Some(\"howdy\");\n@@ -101,7 +101,7 @@\n //! let unwrapped_msg = msg.unwrap_or(\"default message\");\n //! ```\n //!\n-//! Initialize a result to `None` before a loop:\n+//! Initialize a result to [`None`] before a loop:\n //!\n //! ```\n //! enum Kingdom { Plant(u32, &'static str), Animal(u32, &'static str) }\n@@ -136,6 +136,12 @@\n //!     None => println!(\"there are no animals :(\"),\n //! }\n //! ```\n+//!\n+//! [`Option`]: enum.Option.html\n+//! [`Some`]: enum.Option.html#variant.Some\n+//! [`None`]: enum.Option.html#variant.None\n+//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//! [`i32`]: ../../std/primitive.i32.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -156,7 +162,7 @@ pub enum Option<T> {\n     None,\n     /// Some value `T`\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T)\n+    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n }\n \n /////////////////////////////////////////////////////////////////////////////\n@@ -168,7 +174,7 @@ impl<T> Option<T> {\n     // Querying the contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns `true` if the option is a `Some` value\n+    /// Returns `true` if the option is a `Some` value.\n     ///\n     /// # Examples\n     ///\n@@ -188,7 +194,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns `true` if the option is a `None` value\n+    /// Returns `true` if the option is a `None` value.\n     ///\n     /// # Examples\n     ///\n@@ -209,15 +215,17 @@ impl<T> Option<T> {\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Converts from `Option<T>` to `Option<&T>`\n+    /// Converts from `Option<T>` to `Option<&T>`.\n     ///\n     /// # Examples\n     ///\n     /// Convert an `Option<String>` into an `Option<usize>`, preserving the original.\n-    /// The `map` method takes the `self` argument by value, consuming the original,\n+    /// The [`map`] method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n     ///\n+    /// [`map`]: enum.Option.html#method.map\n+    ///\n     /// ```\n     /// let num_as_str: Option<String> = Some(\"10\".to_string());\n     /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n@@ -234,7 +242,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Converts from `Option<T>` to `Option<&mut T>`\n+    /// Converts from `Option<T>` to `Option<&mut T>`.\n     ///\n     /// # Examples\n     ///\n@@ -357,7 +365,7 @@ impl<T> Option<T> {\n     // Transforming contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value\n+    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n     ///\n     /// # Examples\n     ///\n@@ -423,8 +431,12 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to\n-    /// `Ok(v)` and `None` to `Err(err)`.\n+    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping `Some(v)` to\n+    /// [`Ok(v)`] and `None` to [`Err(err)`][Err].\n+    ///\n+    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [Err]: ../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -444,8 +456,12 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to\n-    /// `Ok(v)` and `None` to `Err(err())`.\n+    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping `Some(v)` to\n+    /// [`Ok(v)`] and `None` to [`Err(err())`][Err].\n+    ///\n+    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [Err]: ../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -698,6 +714,7 @@ fn expect_failed(msg: &str) -> ! {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Option<T> {\n+    /// Returns None.\n     #[inline]\n     fn default() -> Option<T> { None }\n }\n@@ -789,7 +806,9 @@ impl<A> DoubleEndedIterator for Item<A> {\n impl<A> ExactSizeIterator for Item<A> {}\n impl<A> FusedIterator for Item<A> {}\n \n-/// An iterator over a reference of the contained item in an Option.\n+/// An iterator over a reference of the contained item in an [`Option`].\n+///\n+/// [`Option`]: enum.Option.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n@@ -823,7 +842,9 @@ impl<'a, A> Clone for Iter<'a, A> {\n     }\n }\n \n-/// An iterator over a mutable reference of the contained item in an Option.\n+/// An iterator over a mutable reference of the contained item in an [`Option`].\n+///\n+/// [`Option`]: enum.Option.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n@@ -850,7 +871,9 @@ impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, A> FusedIterator for IterMut<'a, A> {}\n \n-/// An iterator over the item contained inside an Option.\n+/// An iterator over the item contained inside an [`Option`].\n+///\n+/// [`Option`]: enum.Option.html\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<A> { inner: Item<A> }"}, {"sha": "69682652a6a512a312999aceb57e9222f9ec35ac", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -479,6 +479,40 @@ impl<T: ?Sized> PartialEq for *mut T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Eq for *mut T {}\n \n+/// Compare raw pointers for equality.\n+///\n+/// This is the same as using the `==` operator, but less generic:\n+/// the arguments have to be `*const T` raw pointers,\n+/// not anything that implements `PartialEq`.\n+///\n+/// This can be used to compare `&T` references (which coerce to `*const T` implicitly)\n+/// by their address rather than comparing the values they point to\n+/// (which is what the `PartialEq for &T` implementation does).\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(ptr_eq)]\n+/// use std::ptr;\n+///\n+/// let five = 5;\n+/// let other_five = 5;\n+/// let five_ref = &five;\n+/// let same_five_ref = &five;\n+/// let other_five_ref = &other_five;\n+///\n+/// assert!(five_ref == same_five_ref);\n+/// assert!(five_ref == other_five_ref);\n+///\n+/// assert!(ptr::eq(five_ref, same_five_ref));\n+/// assert!(!ptr::eq(five_ref, other_five_ref));\n+/// ```\n+#[unstable(feature = \"ptr_eq\", reason = \"newly added\", issue = \"36497\")]\n+#[inline]\n+pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n+    a == b\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for *const T {\n     #[inline]"}, {"sha": "96845259299be29b52f4c597e6c780eed0e48375", "filename": "src/libcore/result.rs", "status": "modified", "additions": 65, "deletions": 36, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -10,9 +10,9 @@\n \n //! Error handling with the `Result` type.\n //!\n-//! `Result<T, E>` is the type used for returning and propagating\n-//! errors. It is an enum with the variants, `Ok(T)`, representing\n-//! success and containing a value, and `Err(E)`, representing error\n+//! [`Result<T, E>`][`Result`] is the type used for returning and propagating\n+//! errors. It is an enum with the variants, [`Ok(T)`], representing\n+//! success and containing a value, and [`Err(E)`], representing error\n //! and containing an error value.\n //!\n //! ```\n@@ -23,11 +23,11 @@\n //! }\n //! ```\n //!\n-//! Functions return `Result` whenever errors are expected and\n-//! recoverable. In the `std` crate `Result` is most prominently used\n+//! Functions return [`Result`] whenever errors are expected and\n+//! recoverable. In the `std` crate, [`Result`] is most prominently used\n //! for [I/O](../../std/io/index.html).\n //!\n-//! A simple function returning `Result` might be\n+//! A simple function returning [`Result`] might be\n //! defined and used like so:\n //!\n //! ```\n@@ -50,8 +50,8 @@\n //! }\n //! ```\n //!\n-//! Pattern matching on `Result`s is clear and straightforward for\n-//! simple cases, but `Result` comes with some convenience methods\n+//! Pattern matching on [`Result`]s is clear and straightforward for\n+//! simple cases, but [`Result`] comes with some convenience methods\n //! that make working with it more succinct.\n //!\n //! ```\n@@ -80,14 +80,14 @@\n //!\n //! A common problem with using return values to indicate errors is\n //! that it is easy to ignore the return value, thus failing to handle\n-//! the error. Result is annotated with the #[must_use] attribute,\n+//! the error. [`Result`] is annotated with the `#[must_use]` attribute,\n //! which will cause the compiler to issue a warning when a Result\n-//! value is ignored. This makes `Result` especially useful with\n+//! value is ignored. This makes [`Result`] especially useful with\n //! functions that may encounter errors but don't otherwise return a\n //! useful value.\n //!\n-//! Consider the `write_all` method defined for I/O types\n-//! by the [`Write`](../../std/io/trait.Write.html) trait:\n+//! Consider the [`write_all`] method defined for I/O types\n+//! by the [`Write`] trait:\n //!\n //! ```\n //! use std::io;\n@@ -97,8 +97,8 @@\n //! }\n //! ```\n //!\n-//! *Note: The actual definition of `Write` uses `io::Result`, which\n-//! is just a synonym for `Result<T, io::Error>`.*\n+//! *Note: The actual definition of [`Write`] uses [`io::Result`], which\n+//! is just a synonym for [`Result`]`<T, `[`io::Error`]`>`.*\n //!\n //! This method doesn't produce a value, but the write may\n //! fail. It's crucial to handle the error case, and *not* write\n@@ -119,7 +119,7 @@\n //! warning (by default, controlled by the `unused_must_use` lint).\n //!\n //! You might instead, if you don't want to handle the error, simply\n-//! assert success with `expect`. This will panic if the\n+//! assert success with [`expect`]. This will panic if the\n //! write fails, providing a marginally useful message indicating why:\n //!\n //! ```{.no_run}\n@@ -139,7 +139,7 @@\n //! assert!(file.write_all(b\"important message\").is_ok());\n //! ```\n //!\n-//! Or propagate the error up the call stack with `try!`:\n+//! Or propagate the error up the call stack with [`try!`]:\n //!\n //! ```\n //! # use std::fs::File;\n@@ -156,7 +156,7 @@\n //! # The `try!` macro\n //!\n //! When writing code that calls many functions that return the\n-//! `Result` type, the error handling can be tedious.  The `try!`\n+//! [`Result`] type, the error handling can be tedious. The [`try!`]\n //! macro hides some of the boilerplate of propagating errors up the\n //! call stack.\n //!\n@@ -219,9 +219,9 @@\n //!\n //! *It's much nicer!*\n //!\n-//! Wrapping an expression in `try!` will result in the unwrapped\n-//! success (`Ok`) value, unless the result is `Err`, in which case\n-//! `Err` is returned early from the enclosing function. Its simple definition\n+//! Wrapping an expression in [`try!`] will result in the unwrapped\n+//! success ([`Ok`]) value, unless the result is [`Err`], in which case\n+//! [`Err`] is returned early from the enclosing function. Its simple definition\n //! makes it clear:\n //!\n //! ```\n@@ -230,9 +230,21 @@\n //! }\n //! ```\n //!\n-//! `try!` is imported by the prelude and is available everywhere, but it can only\n-//! be used in functions that return `Result` because of the early return of\n-//! `Err` that it provides.\n+//! [`try!`] is imported by the prelude and is available everywhere, but it can only\n+//! be used in functions that return [`Result`] because of the early return of\n+//! [`Err`] that it provides.\n+//!\n+//! [`expect`]: enum.Result.html#method.expect\n+//! [`Write`]: ../../std/io/trait.Write.html\n+//! [`write_all`]: ../../std/io/trait.Write.html#method.write_all\n+//! [`io::Result`]: ../../std/io/type.Result.html\n+//! [`try!`]: ../../std/macro.try.html\n+//! [`Result`]: enum.Result.html\n+//! [`Ok(T)`]: enum.Result.html#variant.Ok\n+//! [`Err(E)`]: enum.Result.html#variant.Err\n+//! [`io::Error`]: ../../std/io/struct.Error.html\n+//! [`Ok`]: enum.Result.html#variant.Ok\n+//! [`Err`]: enum.Result.html#variant.Err\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -264,7 +276,7 @@ impl<T, E> Result<T, E> {\n     // Querying the contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns true if the result is `Ok`\n+    /// Returns true if the result is `Ok`.\n     ///\n     /// # Examples\n     ///\n@@ -286,7 +298,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Returns true if the result is `Err`\n+    /// Returns true if the result is `Err`.\n     ///\n     /// # Examples\n     ///\n@@ -309,11 +321,13 @@ impl<T, E> Result<T, E> {\n     // Adapter for each variant\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Converts from `Result<T, E>` to `Option<T>`\n+    /// Converts from `Result<T, E>` to [`Option<T>`].\n     ///\n-    /// Converts `self` into an `Option<T>`, consuming `self`,\n+    /// Converts `self` into an [`Option<T>`], consuming `self`,\n     /// and discarding the error, if any.\n     ///\n+    /// [`Option<T>`]: ../../std/option/enum.Option.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -334,11 +348,13 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Converts from `Result<T, E>` to `Option<E>`\n+    /// Converts from `Result<T, E>` to [`Option<E>`].\n     ///\n-    /// Converts `self` into an `Option<E>`, consuming `self`,\n+    /// Converts `self` into an [`Option<E>`], consuming `self`,\n     /// and discarding the success value, if any.\n     ///\n+    /// [`Option<E>`]: ../../std/option/enum.Option.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -363,7 +379,7 @@ impl<T, E> Result<T, E> {\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Converts from `Result<T, E>` to `Result<&T, &E>`\n+    /// Converts from `Result<T, E>` to `Result<&T, &E>`.\n     ///\n     /// Produces a new `Result`, containing a reference\n     /// into the original, leaving the original in place.\n@@ -388,7 +404,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Converts from `Result<T, E>` to `Result<&mut T, &mut E>`\n+    /// Converts from `Result<T, E>` to `Result<&mut T, &mut E>`.\n     ///\n     /// # Examples\n     ///\n@@ -563,7 +579,7 @@ impl<T, E> Result<T, E> {\n \n     /// Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n     ///\n-    /// This function can be used for control flow based on result values.\n+    /// This function can be used for control flow based on `Result` values.\n     ///\n     /// # Examples\n     ///\n@@ -646,7 +662,7 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Unwraps a result, yielding the content of an `Ok`.\n-    /// Else it returns `optb`.\n+    /// Else, it returns `optb`.\n     ///\n     /// # Examples\n     ///\n@@ -837,7 +853,10 @@ impl<'a, T, E> IntoIterator for &'a mut Result<T, E> {\n // The Result Iterators\n /////////////////////////////////////////////////////////////////////////////\n \n-/// An iterator over a reference to the `Ok` variant of a `Result`.\n+/// An iterator over a reference to the [`Ok`] variant of a [`Result`].\n+///\n+/// [`Ok`]: enum.Result.html#variant.Ok\n+/// [`Result`]: enum.Result.html\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n@@ -872,7 +891,10 @@ impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n }\n \n-/// An iterator over a mutable reference to the `Ok` variant of a `Result`.\n+/// An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].\n+///\n+/// [`Ok`]: enum.Result.html#variant.Ok\n+/// [`Result`]: enum.Result.html\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n@@ -902,7 +924,14 @@ impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n-/// An iterator over the value in a `Ok` variant of a `Result`.\n+/// An iterator over the value in a [`Ok`] variant of a [`Result`]. This struct is\n+/// created by the [`into_iter`] method on [`Result`][`Result`] (provided by\n+/// the [`IntoIterator`] trait).\n+///\n+/// [`Ok`]: enum.Result.html#variant.Ok\n+/// [`Result`]: enum.Result.html\n+/// [`into_iter`]: ../iter/trait.IntoIterator.html#tymethod.into_iter\n+/// [`IntoIterator`]: ../iter/trait.IntoIterator.html\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> { inner: Option<T> }"}, {"sha": "d1df56905df2401cdb3d6d48923dc404f1fb59d4", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -520,8 +520,8 @@ impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n     fn index(&self, index: usize) -> &T {\n-        assert!(index < self.len());\n-        unsafe { self.get_unchecked(index) }\n+        // NB built-in indexing\n+        &(*self)[index]\n     }\n }\n \n@@ -530,8 +530,8 @@ impl<T> ops::Index<usize> for [T] {\n impl<T> ops::IndexMut<usize> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n-        assert!(index < self.len());\n-        unsafe { self.get_unchecked_mut(index) }\n+        // NB built-in indexing\n+        &mut (*self)[index]\n     }\n }\n \n@@ -755,11 +755,13 @@ impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for [T] {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Default for &'a [T] {\n+    /// Creates an empty slice.\n     fn default() -> &'a [T] { &[] }\n }\n \n #[stable(feature = \"mut_slice_default\", since = \"1.5.0\")]\n impl<'a, T> Default for &'a mut [T] {\n+    /// Creates a mutable empty slice.\n     fn default() -> &'a mut [T] { &mut [] }\n }\n \n@@ -1821,7 +1823,8 @@ impl<T: PartialOrd> PartialOrd for [T] {\n // intermediate trait for specialization of slice's PartialEq\n trait SlicePartialEq<B> {\n     fn equal(&self, other: &[B]) -> bool;\n-    fn not_equal(&self, other: &[B]) -> bool;\n+\n+    fn not_equal(&self, other: &[B]) -> bool { !self.equal(other) }\n }\n \n // Generic slice equality\n@@ -1841,20 +1844,6 @@ impl<A, B> SlicePartialEq<B> for [A]\n \n         true\n     }\n-\n-    default fn not_equal(&self, other: &[B]) -> bool {\n-        if self.len() != other.len() {\n-            return true;\n-        }\n-\n-        for i in 0..self.len() {\n-            if self[i].ne(&other[i]) {\n-                return true;\n-            }\n-        }\n-\n-        false\n-    }\n }\n \n // Use memcmp for bytewise equality when the types allow\n@@ -1874,10 +1863,6 @@ impl<A> SlicePartialEq<A> for [A]\n                    other.as_ptr() as *const u8, size) == 0\n         }\n     }\n-\n-    fn not_equal(&self, other: &[A]) -> bool {\n-        !self.equal(other)\n-    }\n }\n \n #[doc(hidden)]"}, {"sha": "1f1ae6f12ab457e1d38342fa46854c9184db572d", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -1987,5 +1987,6 @@ impl AsRef<[u8]> for str {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Default for &'a str {\n+    /// Creates an empty str\n     fn default() -> &'a str { \"\" }\n }"}, {"sha": "f5f37be52de6ec7ea82258933d38cbf62a545507", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -95,6 +95,7 @@ pub struct AtomicBool {\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for AtomicBool {\n+    /// Creates an `AtomicBool` initialised as false.\n     fn default() -> Self {\n         Self::new(false)\n     }\n@@ -117,6 +118,7 @@ pub struct AtomicPtr<T> {\n #[cfg(target_has_atomic = \"ptr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for AtomicPtr<T> {\n+    /// Creates a null `AtomicPtr<T>`.\n     fn default() -> AtomicPtr<T> {\n         AtomicPtr::new(::ptr::null_mut())\n     }"}, {"sha": "27eb25537f31bde549db5cc266b55b4bacc2027c", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -664,12 +664,24 @@ fn test_max_by_key() {\n     assert_eq!(*xs.iter().max_by_key(|x| x.abs()).unwrap(), -10);\n }\n \n+#[test]\n+fn test_max_by() {\n+    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n+    assert_eq!(*xs.iter().max_by(|x, y| x.abs().cmp(&y.abs())).unwrap(), -10);\n+}\n+\n #[test]\n fn test_min_by_key() {\n     let xs: &[isize] = &[-3, 0, 1, 5, -10];\n     assert_eq!(*xs.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n }\n \n+#[test]\n+fn test_min_by() {\n+    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n+    assert_eq!(*xs.iter().min_by(|x, y| x.abs().cmp(&y.abs())).unwrap(), 0);\n+}\n+\n #[test]\n fn test_by_ref() {\n     let mut xs = 0..10;"}, {"sha": "590bf478aa723a2ffe92ebf3820f19f291ab6dbe", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -32,6 +32,8 @@\n #![feature(try_from)]\n #![feature(unicode)]\n #![feature(unique)]\n+#![feature(iter_max_by)]\n+#![feature(iter_min_by)]\n \n extern crate core;\n extern crate test;"}, {"sha": "42200795bb3a53c9e38721845d2ff5ee40858008", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -279,7 +279,7 @@ impl OptGroup {\n                                   }],\n                 }\n             }\n-            (_, _) => panic!(\"something is wrong with the long-form opt\"),\n+            _ => panic!(\"something is wrong with the long-form opt\"),\n         }\n     }\n }"}, {"sha": "d4f6a19c55a03e3f9f6fb7377911b37ed807eb6c", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -1 +1 @@\n-Subproject commit 5066b7dcab7e700844b0e2ba71b8af9dc627a59b\n+Subproject commit d4f6a19c55a03e3f9f6fb7377911b37ed807eb6c"}, {"sha": "33b24fbaa26594d5326c66981110c00aa9966208", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -124,12 +124,15 @@ const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX\n #[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1 / X0, X1\n \n-#[cfg(any(target_arch = \"mips\", target_arch = \"mipsel\"))]\n+#[cfg(any(target_arch = \"mips\", target_arch = \"mipsel\", target_arch = \"mips64\"))]\n const UNWIND_DATA_REG: (i32, i32) = (4, 5); // A0, A1\n \n #[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\n const UNWIND_DATA_REG: (i32, i32) = (3, 4); // R3, R4 / X3, X4\n \n+#[cfg(target_arch = \"s390x\")]\n+const UNWIND_DATA_REG: (i32, i32) = (6, 7); // R6, R7\n+\n // The following code is based on GCC's C and C++ personality routines.  For reference, see:\n // https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n // https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c"}, {"sha": "5896421493008cefb36ca632a37a94d33391a22f", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -232,13 +232,13 @@ extern \"C\" {\n // Again, I'm not entirely sure what this is describing, it just seems to work.\n #[cfg_attr(not(test), lang = \"msvc_try_filter\")]\n static mut TYPE_DESCRIPTOR1: _TypeDescriptor = _TypeDescriptor {\n-    pVFTable: &TYPE_INFO_VTABLE as *const _ as *const _,\n+    pVFTable: unsafe { &TYPE_INFO_VTABLE } as *const _ as *const _,\n     spare: 0 as *mut _,\n     name: imp::NAME1,\n };\n \n static mut TYPE_DESCRIPTOR2: _TypeDescriptor = _TypeDescriptor {\n-    pVFTable: &TYPE_INFO_VTABLE as *const _ as *const _,\n+    pVFTable: unsafe { &TYPE_INFO_VTABLE } as *const _ as *const _,\n     spare: 0 as *mut _,\n     name: imp::NAME2,\n };"}, {"sha": "48395c12fafebde6d55cfc315edd9939ce390070", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -113,6 +113,7 @@ impl<R: Rng + Default> Reseeder<R> for ReseedWithDefault {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for ReseedWithDefault {\n+    /// Creates an instance of `ReseedWithDefault`.\n     fn default() -> ReseedWithDefault {\n         ReseedWithDefault\n     }\n@@ -137,6 +138,7 @@ mod tests {\n         }\n     }\n     impl Default for Counter {\n+    /// Constructs a `Counter` with initial value zero.\n         fn default() -> Counter {\n             Counter { i: 0 }\n         }"}, {"sha": "5a8a52f7dfc6e15d9b5bc215395f620ae75e1747", "filename": "src/librbml/lib.rs", "status": "removed", "additions": 0, "deletions": 1609, "changes": 1609, "blob_url": "https://github.com/rust-lang/rust/blob/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=da3c6b7646fb94a747583f34cfa5c63ee4ea094a", "patch": "@@ -1,1609 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Really Bad Markup Language (rbml) is an internal serialization format of rustc.\n-//! This is not intended to be used by users.\n-//!\n-//! Originally based on the Extensible Binary Markup Language\n-//! (ebml; http://www.matroska.org/technical/specs/rfc/index.html),\n-//! it is now a separate format tuned for the rust object metadata.\n-//!\n-//! # Encoding\n-//!\n-//! RBML document consists of the tag, length and data.\n-//! The encoded data can contain multiple RBML documents concatenated.\n-//!\n-//! **Tags** are a hint for the following data.\n-//! Tags are a number from 0x000 to 0xfff, where 0xf0 through 0xff is reserved.\n-//! Tags less than 0xf0 are encoded in one literal byte.\n-//! Tags greater than 0xff are encoded in two big-endian bytes,\n-//! where the tag number is ORed with 0xf000. (E.g. tag 0x123 = `f1 23`)\n-//!\n-//! **Lengths** encode the length of the following data.\n-//! It is a variable-length unsigned isize, and one of the following forms:\n-//!\n-//! - `80` through `fe` for lengths up to 0x7e;\n-//! - `40 ff` through `7f ff` for lengths up to 0x3fff;\n-//! - `20 40 00` through `3f ff ff` for lengths up to 0x1fffff;\n-//! - `10 20 00 00` through `1f ff ff ff` for lengths up to 0xfffffff.\n-//!\n-//! The \"overlong\" form is allowed so that the length can be encoded\n-//! without the prior knowledge of the encoded data.\n-//! For example, the length 0 can be represented either by `80`, `40 00`,\n-//! `20 00 00` or `10 00 00 00`.\n-//! The encoder tries to minimize the length if possible.\n-//! Also, some predefined tags listed below are so commonly used that\n-//! their lengths are omitted (\"implicit length\").\n-//!\n-//! **Data** can be either binary bytes or zero or more nested RBML documents.\n-//! Nested documents cannot overflow, and should be entirely contained\n-//! within a parent document.\n-//!\n-//! # Predefined Tags\n-//!\n-//! Most RBML tags are defined by the application.\n-//! (For the rust object metadata, see also `rustc::metadata::common`.)\n-//! RBML itself does define a set of predefined tags however,\n-//! intended for the auto-serialization implementation.\n-//!\n-//! Predefined tags with an implicit length:\n-//!\n-//! - `U8`  (`00`): 1-byte unsigned integer.\n-//! - `U16` (`01`): 2-byte big endian unsigned integer.\n-//! - `U32` (`02`): 4-byte big endian unsigned integer.\n-//! - `U64` (`03`): 8-byte big endian unsigned integer.\n-//!   Any of `U*` tags can be used to encode primitive unsigned integer types,\n-//!   as long as it is no greater than the actual size.\n-//!   For example, `u8` can only be represented via the `U8` tag.\n-//!\n-//! - `I8`  (`04`): 1-byte signed integer.\n-//! - `I16` (`05`): 2-byte big endian signed integer.\n-//! - `I32` (`06`): 4-byte big endian signed integer.\n-//! - `I64` (`07`): 8-byte big endian signed integer.\n-//!   Similar to `U*` tags. Always uses two's complement encoding.\n-//!\n-//! - `Bool` (`08`): 1-byte boolean value, `00` for false and `01` for true.\n-//!\n-//! - `Char` (`09`): 4-byte big endian Unicode scalar value.\n-//!   Surrogate pairs or out-of-bound values are invalid.\n-//!\n-//! - `F32` (`0a`): 4-byte big endian unsigned integer representing\n-//!   IEEE 754 binary32 floating-point format.\n-//! - `F64` (`0b`): 8-byte big endian unsigned integer representing\n-//!   IEEE 754 binary64 floating-point format.\n-//!\n-//! - `Sub8`  (`0c`): 1-byte unsigned integer for supplementary information.\n-//! - `Sub32` (`0d`): 4-byte unsigned integer for supplementary information.\n-//!   Those two tags normally occur as the first subdocument of certain tags,\n-//!   namely `Enum`, `Vec` and `Map`, to provide a variant or size information.\n-//!   They can be used interchangeably.\n-//!\n-//! Predefined tags with an explicit length:\n-//!\n-//! - `Str` (`10`): A UTF-8-encoded string.\n-//!\n-//! - `Enum` (`11`): An enum.\n-//!   The first subdocument should be `Sub*` tags with a variant ID.\n-//!   Subsequent subdocuments, if any, encode variant arguments.\n-//!\n-//! - `Vec` (`12`): A vector (sequence).\n-//! - `VecElt` (`13`): A vector element.\n-//!   The first subdocument should be `Sub*` tags with the number of elements.\n-//!   Subsequent subdocuments should be `VecElt` tag per each element.\n-//!\n-//! - `Map` (`14`): A map (associated array).\n-//! - `MapKey` (`15`): A key part of the map entry.\n-//! - `MapVal` (`16`): A value part of the map entry.\n-//!   The first subdocument should be `Sub*` tags with the number of entries.\n-//!   Subsequent subdocuments should be an alternating sequence of\n-//!   `MapKey` and `MapVal` tags per each entry.\n-//!\n-//! - `Opaque` (`17`): An opaque, custom-format tag.\n-//!   Used to wrap ordinary custom tags or data in the auto-serialized context.\n-//!   Rustc typically uses this to encode type information.\n-//!\n-//! First 0x20 tags are reserved by RBML; custom tags start at 0x20.\n-\n-#![crate_name = \"rbml\"]\n-#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       test(attr(deny(warnings))))]\n-#![cfg_attr(not(stage0), deny(warnings))]\n-\n-#![feature(rustc_private)]\n-#![feature(staged_api)]\n-#![feature(question_mark)]\n-\n-#![cfg_attr(test, feature(test))]\n-\n-extern crate serialize;\n-\n-#[cfg(test)]\n-extern crate serialize as rustc_serialize; // Used by RustcEncodable\n-\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(test)]\n-extern crate test;\n-\n-pub mod opaque;\n-pub mod leb128;\n-\n-pub use self::EbmlEncoderTag::*;\n-pub use self::Error::*;\n-\n-use std::str;\n-use std::fmt;\n-\n-/// Common data structures\n-#[derive(Clone, Copy)]\n-pub struct Doc<'a> {\n-    pub data: &'a [u8],\n-    pub start: usize,\n-    pub end: usize,\n-}\n-\n-impl<'doc> Doc<'doc> {\n-    pub fn new(data: &'doc [u8]) -> Doc<'doc> {\n-        Doc {\n-            data: data,\n-            start: 0,\n-            end: data.len(),\n-        }\n-    }\n-\n-    pub fn get(&self, tag: usize) -> Doc<'doc> {\n-        reader::get_doc(*self, tag)\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.start == self.end\n-    }\n-\n-    pub fn as_str(&self) -> &'doc str {\n-        str::from_utf8(&self.data[self.start..self.end]).unwrap()\n-    }\n-\n-    pub fn to_string(&self) -> String {\n-        self.as_str().to_string()\n-    }\n-}\n-\n-pub struct TaggedDoc<'a> {\n-    tag: usize,\n-    pub doc: Doc<'a>,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum EbmlEncoderTag {\n-    // tags 00..1f are reserved for auto-serialization.\n-    // first NUM_IMPLICIT_TAGS tags are implicitly sized and lengths are not encoded.\n-    EsU8 = 0x00, // + 1 byte\n-    EsU16 = 0x01, // + 2 bytes\n-    EsU32 = 0x02, // + 4 bytes\n-    EsU64 = 0x03, // + 8 bytes\n-    EsI8 = 0x04, // + 1 byte\n-    EsI16 = 0x05, // + 2 bytes\n-    EsI32 = 0x06, // + 4 bytes\n-    EsI64 = 0x07, // + 8 bytes\n-    EsBool = 0x08, // + 1 byte\n-    EsChar = 0x09, // + 4 bytes\n-    EsF32 = 0x0a, // + 4 bytes\n-    EsF64 = 0x0b, // + 8 bytes\n-    EsSub8 = 0x0c, // + 1 byte\n-    EsSub32 = 0x0d, // + 4 bytes\n-    // 0x0e and 0x0f are reserved\n-    EsStr = 0x10,\n-    EsEnum = 0x11, // encodes the variant id as the first EsSub*\n-    EsVec = 0x12, // encodes the # of elements as the first EsSub*\n-    EsVecElt = 0x13,\n-    EsMap = 0x14, // encodes the # of pairs as the first EsSub*\n-    EsMapKey = 0x15,\n-    EsMapVal = 0x16,\n-    EsOpaque = 0x17,\n-}\n-\n-const NUM_TAGS: usize = 0x1000;\n-const NUM_IMPLICIT_TAGS: usize = 0x0e;\n-\n-#[cfg_attr(rustfmt, rustfmt_skip)]\n-static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n-    1, 2, 4, 8, // EsU*\n-    1, 2, 4, 8, // ESI*\n-    1, // EsBool\n-    4, // EsChar\n-    4, 8, // EsF*\n-    1, 4, // EsSub*\n-];\n-\n-#[derive(Debug)]\n-pub enum Error {\n-    IntTooBig(usize),\n-    InvalidTag(usize),\n-    Expected(String),\n-    IoError(std::io::Error),\n-    ApplicationError(String),\n-}\n-\n-impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // FIXME: this should be a more useful display form\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n-// --------------------------------------\n-\n-pub mod reader {\n-    use std::char;\n-\n-    use std::isize;\n-    use std::mem::transmute;\n-\n-    use serialize;\n-\n-    use super::opaque;\n-    use super::{ApplicationError, EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n-                EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8, EsBool, EsF64, EsF32,\n-                EsChar, EsStr, EsMapVal, EsOpaque, EbmlEncoderTag, Doc, TaggedDoc, Error,\n-                IntTooBig, InvalidTag, Expected, NUM_IMPLICIT_TAGS, TAG_IMPLICIT_LEN};\n-\n-    pub type DecodeResult<T> = Result<T, Error>;\n-    // rbml reading\n-\n-    macro_rules! try_or {\n-        ($e:expr, $r:expr) => (\n-            match $e {\n-                Ok(e) => e,\n-                Err(e) => {\n-                    debug!(\"ignored error: {:?}\", e);\n-                    return $r\n-                }\n-            }\n-        )\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct Res {\n-        pub val: usize,\n-        pub next: usize,\n-    }\n-\n-    pub fn tag_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        let v = data[start] as usize;\n-        if v < 0xf0 {\n-            Ok(Res {\n-                val: v,\n-                next: start + 1,\n-            })\n-        } else if v > 0xf0 {\n-            Ok(Res {\n-                val: ((v & 0xf) << 8) | data[start + 1] as usize,\n-                next: start + 2,\n-            })\n-        } else {\n-            // every tag starting with byte 0xf0 is an overlong form, which is prohibited.\n-            Err(InvalidTag(v))\n-        }\n-    }\n-\n-    #[inline(never)]\n-    fn vuint_at_slow(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        let a = data[start];\n-        if a & 0x80 != 0 {\n-            return Ok(Res {\n-                val: (a & 0x7f) as usize,\n-                next: start + 1,\n-            });\n-        }\n-        if a & 0x40 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x3f) as usize) << 8 | (data[start + 1] as usize),\n-                next: start + 2,\n-            });\n-        }\n-        if a & 0x20 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x1f) as usize) << 16 | (data[start + 1] as usize) << 8 |\n-                     (data[start + 2] as usize),\n-                next: start + 3,\n-            });\n-        }\n-        if a & 0x10 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x0f) as usize) << 24 | (data[start + 1] as usize) << 16 |\n-                     (data[start + 2] as usize) << 8 |\n-                     (data[start + 3] as usize),\n-                next: start + 4,\n-            });\n-        }\n-        Err(IntTooBig(a as usize))\n-    }\n-\n-    pub fn vuint_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        if data.len() - start < 4 {\n-            return vuint_at_slow(data, start);\n-        }\n-\n-        // Lookup table for parsing EBML Element IDs as per\n-        // http://ebml.sourceforge.net/specs/ The Element IDs are parsed by\n-        // reading a big endian u32 positioned at data[start].  Using the four\n-        // most significant bits of the u32 we lookup in the table below how\n-        // the element ID should be derived from it.\n-        //\n-        // The table stores tuples (shift, mask) where shift is the number the\n-        // u32 should be right shifted with and mask is the value the right\n-        // shifted value should be masked with.  If for example the most\n-        // significant bit is set this means it's a class A ID and the u32\n-        // should be right shifted with 24 and masked with 0x7f. Therefore we\n-        // store (24, 0x7f) at index 0x8 - 0xF (four bit numbers where the most\n-        // significant bit is set).\n-        //\n-        // By storing the number of shifts and masks in a table instead of\n-        // checking in order if the most significant bit is set, the second\n-        // most significant bit is set etc. we can replace up to three\n-        // \"and+branch\" with a single table lookup which gives us a measured\n-        // speedup of around 2x on x86_64.\n-        static SHIFT_MASK_TABLE: [(usize, u32); 16] = [(0, 0x0),\n-                                                       (0, 0x0fffffff),\n-                                                       (8, 0x1fffff),\n-                                                       (8, 0x1fffff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f)];\n-\n-        unsafe {\n-            let ptr = data.as_ptr().offset(start as isize) as *const u32;\n-            let val = u32::from_be(*ptr);\n-\n-            let i = (val >> 28) as usize;\n-            let (shift, mask) = SHIFT_MASK_TABLE[i];\n-            Ok(Res {\n-                val: ((val >> shift) & mask) as usize,\n-                next: start + ((32 - shift) >> 3),\n-            })\n-        }\n-    }\n-\n-    pub fn tag_len_at(data: &[u8], tag: Res) -> DecodeResult<Res> {\n-        if tag.val < NUM_IMPLICIT_TAGS && TAG_IMPLICIT_LEN[tag.val] >= 0 {\n-            Ok(Res {\n-                val: TAG_IMPLICIT_LEN[tag.val] as usize,\n-                next: tag.next,\n-            })\n-        } else {\n-            vuint_at(data, tag.next)\n-        }\n-    }\n-\n-    pub fn doc_at<'a>(data: &'a [u8], start: usize) -> DecodeResult<TaggedDoc<'a>> {\n-        let elt_tag = tag_at(data, start)?;\n-        let elt_size = tag_len_at(data, elt_tag)?;\n-        let end = elt_size.next + elt_size.val;\n-        Ok(TaggedDoc {\n-            tag: elt_tag.val,\n-            doc: Doc {\n-                data: data,\n-                start: elt_size.next,\n-                end: end,\n-            },\n-        })\n-    }\n-\n-    pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: usize) -> Option<Doc<'a>> {\n-        let mut pos = d.start;\n-        while pos < d.end {\n-            let elt_tag = try_or!(tag_at(d.data, pos), None);\n-            let elt_size = try_or!(tag_len_at(d.data, elt_tag), None);\n-            pos = elt_size.next + elt_size.val;\n-            if elt_tag.val == tg {\n-                return Some(Doc {\n-                    data: d.data,\n-                    start: elt_size.next,\n-                    end: pos,\n-                });\n-            }\n-        }\n-        None\n-    }\n-\n-    pub fn get_doc<'a>(d: Doc<'a>, tg: usize) -> Doc<'a> {\n-        match maybe_get_doc(d, tg) {\n-            Some(d) => d,\n-            None => {\n-                error!(\"failed to find block with tag {:?}\", tg);\n-                panic!();\n-            }\n-        }\n-    }\n-\n-    pub fn docs<'a>(d: Doc<'a>) -> DocsIterator<'a> {\n-        DocsIterator { d: d }\n-    }\n-\n-    pub struct DocsIterator<'a> {\n-        d: Doc<'a>,\n-    }\n-\n-    impl<'a> Iterator for DocsIterator<'a> {\n-        type Item = (usize, Doc<'a>);\n-\n-        fn next(&mut self) -> Option<(usize, Doc<'a>)> {\n-            if self.d.start >= self.d.end {\n-                return None;\n-            }\n-\n-            let elt_tag = try_or!(tag_at(self.d.data, self.d.start), {\n-                self.d.start = self.d.end;\n-                None\n-            });\n-            let elt_size = try_or!(tag_len_at(self.d.data, elt_tag), {\n-                self.d.start = self.d.end;\n-                None\n-            });\n-\n-            let end = elt_size.next + elt_size.val;\n-            let doc = Doc {\n-                data: self.d.data,\n-                start: elt_size.next,\n-                end: end,\n-            };\n-\n-            self.d.start = end;\n-            return Some((elt_tag.val, doc));\n-        }\n-    }\n-\n-    pub fn tagged_docs<'a>(d: Doc<'a>, tag: usize) -> TaggedDocsIterator<'a> {\n-        TaggedDocsIterator {\n-            iter: docs(d),\n-            tag: tag,\n-        }\n-    }\n-\n-    pub struct TaggedDocsIterator<'a> {\n-        iter: DocsIterator<'a>,\n-        tag: usize,\n-    }\n-\n-    impl<'a> Iterator for TaggedDocsIterator<'a> {\n-        type Item = Doc<'a>;\n-\n-        fn next(&mut self) -> Option<Doc<'a>> {\n-            while let Some((tag, doc)) = self.iter.next() {\n-                if tag == self.tag {\n-                    return Some(doc);\n-                }\n-            }\n-            None\n-        }\n-    }\n-\n-    pub fn with_doc_data<T, F>(d: Doc, f: F) -> T\n-        where F: FnOnce(&[u8]) -> T\n-    {\n-        f(&d.data[d.start..d.end])\n-    }\n-\n-    pub fn doc_as_u8(d: Doc) -> u8 {\n-        assert_eq!(d.end, d.start + 1);\n-        d.data[d.start]\n-    }\n-\n-    pub fn doc_as_u64(d: Doc) -> u64 {\n-        if d.end >= 8 {\n-            // For performance, we read 8 big-endian bytes,\n-            // and mask off the junk if there is any. This\n-            // obviously won't work on the first 8 bytes\n-            // of a file - we will fall of the start\n-            // of the page and segfault.\n-\n-            let mut b = [0; 8];\n-            b.copy_from_slice(&d.data[d.end - 8..d.end]);\n-            let data = unsafe { (*(b.as_ptr() as *const u64)).to_be() };\n-            let len = d.end - d.start;\n-            if len < 8 {\n-                data & ((1 << (len * 8)) - 1)\n-            } else {\n-                data\n-            }\n-        } else {\n-            let mut result = 0;\n-            for b in &d.data[d.start..d.end] {\n-                result = (result << 8) + (*b as u64);\n-            }\n-            result\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn doc_as_u16(d: Doc) -> u16 {\n-        doc_as_u64(d) as u16\n-    }\n-    #[inline]\n-    pub fn doc_as_u32(d: Doc) -> u32 {\n-        doc_as_u64(d) as u32\n-    }\n-\n-    #[inline]\n-    pub fn doc_as_i8(d: Doc) -> i8 {\n-        doc_as_u8(d) as i8\n-    }\n-    #[inline]\n-    pub fn doc_as_i16(d: Doc) -> i16 {\n-        doc_as_u16(d) as i16\n-    }\n-    #[inline]\n-    pub fn doc_as_i32(d: Doc) -> i32 {\n-        doc_as_u32(d) as i32\n-    }\n-    #[inline]\n-    pub fn doc_as_i64(d: Doc) -> i64 {\n-        doc_as_u64(d) as i64\n-    }\n-\n-    pub struct Decoder<'a> {\n-        parent: Doc<'a>,\n-        pos: usize,\n-    }\n-\n-    impl<'doc> Decoder<'doc> {\n-        pub fn new(d: Doc<'doc>) -> Decoder<'doc> {\n-            Decoder {\n-                parent: d,\n-                pos: d.start,\n-            }\n-        }\n-\n-        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n-            debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n-            if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in current node!\")));\n-            }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n-                   self.parent.start,\n-                   self.parent.end,\n-                   self.pos,\n-                   r_tag,\n-                   r_doc.start,\n-                   r_doc.end);\n-            if r_tag != (exp_tag as usize) {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n-                                            exp_tag,\n-                                            r_tag)));\n-            }\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            Ok(r_doc)\n-        }\n-\n-        fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            let d = self.next_doc(exp_tag)?;\n-            let old_parent = self.parent;\n-            let old_pos = self.pos;\n-            self.parent = d;\n-            self.pos = d.start;\n-            let r = f(self)?;\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(r)\n-        }\n-\n-        fn _next_sub(&mut self) -> DecodeResult<usize> {\n-            // empty vector/map optimization\n-            if self.parent.is_empty() {\n-                return Ok(0);\n-            }\n-\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            let r = if r_tag == (EsSub8 as usize) {\n-                doc_as_u8(r_doc) as usize\n-            } else if r_tag == (EsSub32 as usize) {\n-                doc_as_u32(r_doc) as usize\n-            } else {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but found \\\n-                                             tag {:?}\",\n-                                            EsSub8,\n-                                            EsSub32,\n-                                            r_tag)));\n-            };\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            debug!(\"_next_sub result={:?}\", r);\n-            Ok(r)\n-        }\n-\n-        // variable-length unsigned integer with different tags.\n-        // `first_tag` should be a tag for u8 or i8.\n-        // `last_tag` should be the largest allowed integer tag with the matching signedness.\n-        // all tags between them should be valid, in the order of u8, u16, u32 and u64.\n-        fn _next_int(&mut self,\n-                     first_tag: EbmlEncoderTag,\n-                     last_tag: EbmlEncoderTag)\n-                     -> DecodeResult<u64> {\n-            if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in current node!\")));\n-            }\n-\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            let r = if first_tag as usize <= r_tag && r_tag <= last_tag as usize {\n-                match r_tag - first_tag as usize {\n-                    0 => doc_as_u8(r_doc) as u64,\n-                    1 => doc_as_u16(r_doc) as u64,\n-                    2 => doc_as_u32(r_doc) as u64,\n-                    3 => doc_as_u64(r_doc),\n-                    _ => unreachable!(),\n-                }\n-            } else {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} through {:?} but \\\n-                                             found tag {:?}\",\n-                                            first_tag,\n-                                            last_tag,\n-                                            r_tag)));\n-            };\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            debug!(\"_next_int({:?}, {:?}) result={:?}\", first_tag, last_tag, r);\n-            Ok(r)\n-        }\n-\n-        pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R>\n-            where F: FnOnce(&mut opaque::Decoder, Doc) -> DecodeResult<R>\n-        {\n-            let doc = self.next_doc(EsOpaque)?;\n-\n-            let result = {\n-                let mut opaque_decoder = opaque::Decoder::new(doc.data, doc.start);\n-                op(&mut opaque_decoder, doc)?\n-            };\n-\n-            Ok(result)\n-        }\n-\n-        pub fn position(&self) -> usize {\n-            self.pos\n-        }\n-\n-        pub fn advance(&mut self, bytes: usize) {\n-            self.pos += bytes;\n-        }\n-    }\n-\n-    impl<'doc> serialize::Decoder for Decoder<'doc> {\n-        type Error = Error;\n-        fn read_nil(&mut self) -> DecodeResult<()> {\n-            Ok(())\n-        }\n-\n-        fn read_u64(&mut self) -> DecodeResult<u64> {\n-            self._next_int(EsU8, EsU64)\n-        }\n-        fn read_u32(&mut self) -> DecodeResult<u32> {\n-            Ok(self._next_int(EsU8, EsU32)? as u32)\n-        }\n-        fn read_u16(&mut self) -> DecodeResult<u16> {\n-            Ok(self._next_int(EsU8, EsU16)? as u16)\n-        }\n-        fn read_u8(&mut self) -> DecodeResult<u8> {\n-            Ok(doc_as_u8(self.next_doc(EsU8)?))\n-        }\n-        fn read_usize(&mut self) -> DecodeResult<usize> {\n-            let v = self._next_int(EsU8, EsU64)?;\n-            if v > (::std::usize::MAX as u64) {\n-                Err(IntTooBig(v as usize))\n-            } else {\n-                Ok(v as usize)\n-            }\n-        }\n-\n-        fn read_i64(&mut self) -> DecodeResult<i64> {\n-            Ok(self._next_int(EsI8, EsI64)? as i64)\n-        }\n-        fn read_i32(&mut self) -> DecodeResult<i32> {\n-            Ok(self._next_int(EsI8, EsI32)? as i32)\n-        }\n-        fn read_i16(&mut self) -> DecodeResult<i16> {\n-            Ok(self._next_int(EsI8, EsI16)? as i16)\n-        }\n-        fn read_i8(&mut self) -> DecodeResult<i8> {\n-            Ok(doc_as_u8(self.next_doc(EsI8)?) as i8)\n-        }\n-        fn read_isize(&mut self) -> DecodeResult<isize> {\n-            let v = self._next_int(EsI8, EsI64)? as i64;\n-            if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n-                debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-                Err(IntTooBig(v as usize))\n-            } else {\n-                Ok(v as isize)\n-            }\n-        }\n-\n-        fn read_bool(&mut self) -> DecodeResult<bool> {\n-            Ok(doc_as_u8(self.next_doc(EsBool)?) != 0)\n-        }\n-\n-        fn read_f64(&mut self) -> DecodeResult<f64> {\n-            let bits = doc_as_u64(self.next_doc(EsF64)?);\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_f32(&mut self) -> DecodeResult<f32> {\n-            let bits = doc_as_u32(self.next_doc(EsF32)?);\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_char(&mut self) -> DecodeResult<char> {\n-            Ok(char::from_u32(doc_as_u32(self.next_doc(EsChar)?)).unwrap())\n-        }\n-        fn read_str(&mut self) -> DecodeResult<String> {\n-            Ok(self.next_doc(EsStr)?.to_string())\n-        }\n-\n-        // Compound types:\n-        fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum({})\", name);\n-\n-            let doc = self.next_doc(EsEnum)?;\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = f(self)?;\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n-        }\n-\n-        fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_variant()\");\n-            let idx = self._next_sub()?;\n-            debug!(\"  idx={}\", idx);\n-\n-            f(self, idx)\n-        }\n-\n-        fn read_enum_variant_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_variant_arg(idx={})\", idx);\n-            f(self)\n-        }\n-\n-        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_struct_variant()\");\n-            let idx = self._next_sub()?;\n-            debug!(\"  idx={}\", idx);\n-\n-            f(self, idx)\n-        }\n-\n-        fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                                name: &str,\n-                                                idx: usize,\n-                                                f: F)\n-                                                -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n-            f(self)\n-        }\n-\n-        fn read_struct<T, F>(&mut self, name: &str, _: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_struct(name={})\", name);\n-            f(self)\n-        }\n-\n-        fn read_struct_field<T, F>(&mut self, name: &str, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-            f(self)\n-        }\n-\n-        fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple()\");\n-            self.read_seq(move |d, len| {\n-                if len == tuple_len {\n-                    f(d)\n-                } else {\n-                    Err(Expected(format!(\"Expected tuple of length `{}`, found tuple of length \\\n-                                          `{}`\",\n-                                         tuple_len,\n-                                         len)))\n-                }\n-            })\n-        }\n-\n-        fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_arg(idx={})\", idx);\n-            self.read_seq_elt(idx, f)\n-        }\n-\n-        fn read_tuple_struct<T, F>(&mut self, name: &str, len: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_struct(name={})\", name);\n-            self.read_tuple(len, f)\n-        }\n-\n-        fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_struct_arg(idx={})\", idx);\n-            self.read_tuple_arg(idx, f)\n-        }\n-\n-        fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>\n-        {\n-            debug!(\"read_option()\");\n-            self.read_enum(\"Option\", move |this| {\n-                this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n-                    match idx {\n-                        0 => f(this, false),\n-                        1 => f(this, true),\n-                        _ => Err(Expected(format!(\"Expected None or Some\"))),\n-                    }\n-                })\n-            })\n-        }\n-\n-        fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_seq()\");\n-            self.push_doc(EsVec, move |d| {\n-                let len = d._next_sub()?;\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_seq_elt(idx={})\", idx);\n-            self.push_doc(EsVecElt, f)\n-        }\n-\n-        fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map()\");\n-            self.push_doc(EsMap, move |d| {\n-                let len = d._next_sub()?;\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map_elt_key(idx={})\", idx);\n-            self.push_doc(EsMapKey, f)\n-        }\n-\n-        fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map_elt_val(idx={})\", idx);\n-            self.push_doc(EsMapVal, f)\n-        }\n-\n-        fn error(&mut self, err: &str) -> Error {\n-            ApplicationError(err.to_string())\n-        }\n-    }\n-}\n-\n-pub mod writer {\n-    use std::mem;\n-    use std::io::prelude::*;\n-    use std::io::{self, SeekFrom, Cursor};\n-\n-    use super::opaque;\n-    use super::{EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey, EsU64, EsU32, EsU16,\n-                EsU8, EsI64, EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n-                EsOpaque, NUM_IMPLICIT_TAGS, NUM_TAGS};\n-\n-    use serialize;\n-\n-\n-    pub type EncodeResult = io::Result<()>;\n-\n-    // rbml writing\n-    pub struct Encoder<'a> {\n-        pub writer: &'a mut Cursor<Vec<u8>>,\n-        size_positions: Vec<u64>,\n-        relax_limit: u64, // do not move encoded bytes before this position\n-    }\n-\n-    fn write_tag<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n-        if n < 0xf0 {\n-            w.write_all(&[n as u8])\n-        } else if 0x100 <= n && n < NUM_TAGS {\n-            w.write_all(&[0xf0 | (n >> 8) as u8, n as u8])\n-        } else {\n-            Err(io::Error::new(io::ErrorKind::Other, &format!(\"invalid tag: {}\", n)[..]))\n-        }\n-    }\n-\n-    fn write_sized_vuint<W: Write>(w: &mut W, n: usize, size: usize) -> EncodeResult {\n-        match size {\n-            1 => w.write_all(&[0x80 | (n as u8)]),\n-            2 => w.write_all(&[0x40 | ((n >> 8) as u8), n as u8]),\n-            3 => w.write_all(&[0x20 | ((n >> 16) as u8), (n >> 8) as u8, n as u8]),\n-            4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8, (n >> 8) as u8, n as u8]),\n-            _ => Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..])),\n-        }\n-    }\n-\n-    pub fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n-        if n < 0x7f {\n-            return write_sized_vuint(w, n, 1);\n-        }\n-        if n < 0x4000 {\n-            return write_sized_vuint(w, n, 2);\n-        }\n-        if n < 0x200000 {\n-            return write_sized_vuint(w, n, 3);\n-        }\n-        if n < 0x10000000 {\n-            return write_sized_vuint(w, n, 4);\n-        }\n-        Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..]))\n-    }\n-\n-    impl<'a> Encoder<'a> {\n-        pub fn new(w: &'a mut Cursor<Vec<u8>>) -> Encoder<'a> {\n-            Encoder {\n-                writer: w,\n-                size_positions: vec![],\n-                relax_limit: 0,\n-            }\n-        }\n-\n-        pub fn start_tag(&mut self, tag_id: usize) -> EncodeResult {\n-            debug!(\"Start tag {:?}\", tag_id);\n-            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n-\n-            // Write the enum ID:\n-            write_tag(self.writer, tag_id)?;\n-\n-            // Write a placeholder four-byte size.\n-            let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n-            self.size_positions.push(cur_pos);\n-            let zeroes: &[u8] = &[0, 0, 0, 0];\n-            self.writer.write_all(zeroes)\n-        }\n-\n-        pub fn end_tag(&mut self) -> EncodeResult {\n-            let last_size_pos = self.size_positions.pop().unwrap();\n-            let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n-            self.writer.seek(SeekFrom::Start(last_size_pos))?;\n-            let size = (cur_pos - last_size_pos - 4) as usize;\n-\n-            // relax the size encoding for small tags (bigger tags are costly to move).\n-            // we should never try to move the stable positions, however.\n-            const RELAX_MAX_SIZE: usize = 0x100;\n-            if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit {\n-                // we can't alter the buffer in place, so have a temporary buffer\n-                let mut buf = [0u8; RELAX_MAX_SIZE];\n-                {\n-                    let last_size_pos = last_size_pos as usize;\n-                    let data = &self.writer.get_ref()[last_size_pos + 4..cur_pos as usize];\n-                    buf[..size].copy_from_slice(data);\n-                }\n-\n-                // overwrite the size and data and continue\n-                write_vuint(self.writer, size)?;\n-                self.writer.write_all(&buf[..size])?;\n-            } else {\n-                // overwrite the size with an overlong encoding and skip past the data\n-                write_sized_vuint(self.writer, size, 4)?;\n-                self.writer.seek(SeekFrom::Start(cur_pos))?;\n-            }\n-\n-            debug!(\"End tag (size = {:?})\", size);\n-            Ok(())\n-        }\n-\n-        pub fn wr_tag<F>(&mut self, tag_id: usize, blk: F) -> EncodeResult\n-            where F: FnOnce() -> EncodeResult\n-        {\n-            self.start_tag(tag_id)?;\n-            blk()?;\n-            self.end_tag()\n-        }\n-\n-        pub fn wr_tagged_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n-            write_tag(self.writer, tag_id)?;\n-            write_vuint(self.writer, b.len())?;\n-            self.writer.write_all(b)\n-        }\n-\n-        pub fn wr_tagged_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n-            let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-            // tagged integers are emitted in big-endian, with no\n-            // leading zeros.\n-            let leading_zero_bytes = v.leading_zeros() / 8;\n-            self.wr_tagged_bytes(tag_id, &bytes[leading_zero_bytes as usize..])\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, &[v])\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n-            self.wr_tagged_u32(tag_id, v as u32)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n-            self.wr_tagged_u16(tag_id, v as u16)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, &[v as u8])\n-        }\n-\n-        pub fn wr_tagged_str(&mut self, tag_id: usize, v: &str) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, v.as_bytes())\n-        }\n-\n-        // for auto-serialization\n-        fn wr_tagged_raw_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-            write_tag(self.writer, tag_id)?;\n-            self.writer.write_all(b)\n-        }\n-\n-        fn wr_tagged_raw_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n-            let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n-            let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-            let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n-            self.wr_tagged_raw_bytes(tag_id, &[v])\n-        }\n-\n-        fn wr_tagged_raw_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n-            self.wr_tagged_raw_u64(tag_id, v as u64)\n-        }\n-\n-        fn wr_tagged_raw_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n-            self.wr_tagged_raw_u32(tag_id, v as u32)\n-        }\n-\n-        fn wr_tagged_raw_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n-            self.wr_tagged_raw_u16(tag_id, v as u16)\n-        }\n-\n-        fn wr_tagged_raw_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n-            self.wr_tagged_raw_bytes(tag_id, &[v as u8])\n-        }\n-\n-        pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n-            debug!(\"Write {:?} bytes\", b.len());\n-            self.writer.write_all(b)\n-        }\n-\n-        pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n-            debug!(\"Write str: {:?}\", s);\n-            self.writer.write_all(s.as_bytes())\n-        }\n-\n-        /// Returns the current position while marking it stable, i.e.\n-        /// generated bytes so far wouldn't be affected by relaxation.\n-        pub fn mark_stable_position(&mut self) -> u64 {\n-            let pos = self.writer.seek(SeekFrom::Current(0)).unwrap();\n-            if self.relax_limit < pos {\n-                self.relax_limit = pos;\n-            }\n-            pos\n-        }\n-    }\n-\n-    impl<'a> Encoder<'a> {\n-        // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n-            if v as u8 as usize == v {\n-                self.wr_tagged_raw_u8(EsSub8 as usize, v as u8)\n-            } else if v as u32 as usize == v {\n-                self.wr_tagged_raw_u32(EsSub32 as usize, v as u32)\n-            } else {\n-                Err(io::Error::new(io::ErrorKind::Other,\n-                                   &format!(\"length or variant id too big: {}\", v)[..]))\n-            }\n-        }\n-\n-        pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut opaque::Encoder) -> EncodeResult\n-        {\n-            self.start_tag(EsOpaque as usize)?;\n-\n-            {\n-                let mut opaque_encoder = opaque::Encoder::new(self.writer);\n-                f(&mut opaque_encoder)?;\n-            }\n-\n-            self.mark_stable_position();\n-            self.end_tag()\n-        }\n-    }\n-\n-    impl<'a> serialize::Encoder for Encoder<'a> {\n-        type Error = io::Error;\n-\n-        fn emit_nil(&mut self) -> EncodeResult {\n-            Ok(())\n-        }\n-\n-        fn emit_usize(&mut self, v: usize) -> EncodeResult {\n-            self.emit_u64(v as u64)\n-        }\n-        fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            if v as u32 as u64 == v {\n-                self.emit_u32(v as u32)\n-            } else {\n-                self.wr_tagged_raw_u64(EsU64 as usize, v)\n-            }\n-        }\n-        fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            if v as u16 as u32 == v {\n-                self.emit_u16(v as u16)\n-            } else {\n-                self.wr_tagged_raw_u32(EsU32 as usize, v)\n-            }\n-        }\n-        fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            if v as u8 as u16 == v {\n-                self.emit_u8(v as u8)\n-            } else {\n-                self.wr_tagged_raw_u16(EsU16 as usize, v)\n-            }\n-        }\n-        fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsU8 as usize, v)\n-        }\n-\n-        fn emit_isize(&mut self, v: isize) -> EncodeResult {\n-            self.emit_i64(v as i64)\n-        }\n-        fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            if v as i32 as i64 == v {\n-                self.emit_i32(v as i32)\n-            } else {\n-                self.wr_tagged_raw_i64(EsI64 as usize, v)\n-            }\n-        }\n-        fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            if v as i16 as i32 == v {\n-                self.emit_i16(v as i16)\n-            } else {\n-                self.wr_tagged_raw_i32(EsI32 as usize, v)\n-            }\n-        }\n-        fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            if v as i8 as i16 == v {\n-                self.emit_i8(v as i8)\n-            } else {\n-                self.wr_tagged_raw_i16(EsI16 as usize, v)\n-            }\n-        }\n-        fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-            self.wr_tagged_raw_i8(EsI8 as usize, v)\n-        }\n-\n-        fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsBool as usize, v as u8)\n-        }\n-\n-        fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u64(EsF64 as usize, bits)\n-        }\n-        fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u32(EsF32 as usize, bits)\n-        }\n-        fn emit_char(&mut self, v: char) -> EncodeResult {\n-            self.wr_tagged_raw_u32(EsChar as usize, v as u32)\n-        }\n-\n-        fn emit_str(&mut self, v: &str) -> EncodeResult {\n-            self.wr_tagged_str(EsStr as usize, v)\n-        }\n-\n-        fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.start_tag(EsEnum as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_enum_variant<F>(&mut self, _: &str, v_id: usize, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self._emit_tagged_sub(v_id)?;\n-            f(self)\n-        }\n-\n-        fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_enum_struct_variant<F>(&mut self,\n-                                       v_name: &str,\n-                                       v_id: usize,\n-                                       cnt: usize,\n-                                       f: F)\n-                                       -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum_variant(v_name, v_id, cnt, f)\n-        }\n-\n-        fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum_variant_arg(idx, f)\n-        }\n-\n-        fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum(\"Option\", f)\n-        }\n-        fn emit_option_none(&mut self) -> EncodeResult {\n-            self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n-        }\n-        fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.emit_enum_variant(\"Some\", 1, 1, f)\n-        }\n-\n-        fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            if len == 0 {\n-                // empty vector optimization\n-                return self.wr_tagged_bytes(EsVec as usize, &[]);\n-            }\n-\n-            self.start_tag(EsVec as usize)?;\n-            self._emit_tagged_sub(len)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.start_tag(EsVecElt as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            if len == 0 {\n-                // empty map optimization\n-                return self.wr_tagged_bytes(EsMap as usize, &[]);\n-            }\n-\n-            self.start_tag(EsMap as usize)?;\n-            self._emit_tagged_sub(len)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.start_tag(EsMapKey as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.start_tag(EsMapVal as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Testing\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{Doc, reader, writer};\n-\n-    use serialize::{Encodable, Decodable};\n-\n-    use std::io::Cursor;\n-\n-    #[test]\n-    fn test_vuint_at() {\n-        let data = &[\n-            0x80,\n-            0xff,\n-            0x40, 0x00,\n-            0x7f, 0xff,\n-            0x20, 0x00, 0x00,\n-            0x3f, 0xff, 0xff,\n-            0x10, 0x00, 0x00, 0x00,\n-            0x1f, 0xff, 0xff, 0xff\n-        ];\n-\n-        let mut res: reader::Res;\n-\n-        // Class A\n-        res = reader::vuint_at(data, 0).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 1);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 7) - 1);\n-        assert_eq!(res.next, 2);\n-\n-        // Class B\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 4);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 14) - 1);\n-        assert_eq!(res.next, 6);\n-\n-        // Class C\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 9);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 21) - 1);\n-        assert_eq!(res.next, 12);\n-\n-        // Class D\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 16);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 28) - 1);\n-        assert_eq!(res.next, 20);\n-    }\n-\n-    #[test]\n-    fn test_option_int() {\n-        fn test_v(v: Option<isize>) {\n-            debug!(\"v == {:?}\", v);\n-            let mut wr = Cursor::new(Vec::new());\n-            {\n-                let mut rbml_w = writer::Encoder::new(&mut wr);\n-                let _ = v.encode(&mut rbml_w);\n-            }\n-            let rbml_doc = Doc::new(wr.get_ref());\n-            let mut deser = reader::Decoder::new(rbml_doc);\n-            let v1 = Decodable::decode(&mut deser).unwrap();\n-            debug!(\"v1 == {:?}\", v1);\n-            assert_eq!(v, v1);\n-        }\n-\n-        test_v(Some(22));\n-        test_v(None);\n-        test_v(Some(3));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    #![allow(non_snake_case)]\n-    use test::Bencher;\n-    use super::reader;\n-\n-    #[bench]\n-    pub fn vuint_at_A_aligned(b: &mut Bencher) {\n-        let data = (0..4 * 100)\n-                       .map(|i| {\n-                           match i % 2 {\n-                               0 => 0x80,\n-                               _ => i as u8,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 0;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n-        let data = (0..4 * 100 + 1)\n-                       .map(|i| {\n-                           match i % 2 {\n-                               1 => 0x80,\n-                               _ => i as u8,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 1;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_D_aligned(b: &mut Bencher) {\n-        let data = (0..4 * 100)\n-                       .map(|i| {\n-                           match i % 4 {\n-                               0 => 0x10,\n-                               3 => i as u8,\n-                               _ => 0,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 0;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n-        let data = (0..4 * 100 + 1)\n-                       .map(|i| {\n-                           match i % 4 {\n-                               1 => 0x10,\n-                               0 => i as u8,\n-                               _ => 0,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 1;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-}"}, {"sha": "578ef68b00386f3be294d68748acafc59128460f", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -14,7 +14,6 @@ flate = { path = \"../libflate\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n log = { path = \"../liblog\" }\n-rbml = { path = \"../librbml\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }"}, {"sha": "25a73226473b7556e3179a7ca77108cf98db7b15", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n-            PatKind::Binding(_, _, None) |\n+            PatKind::Binding(.., None) |\n             PatKind::Path(..) |\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n@@ -109,7 +109,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             PatKind::Box(ref subpat) |\n             PatKind::Ref(ref subpat, _) |\n-            PatKind::Binding(_, _, Some(ref subpat)) => {\n+            PatKind::Binding(.., Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&subpat, pred);\n                 self.add_ast_node(pat.id, &[subpat_exit])\n             }\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.call(expr, pred, &func, args.iter().map(|e| &**e))\n             }\n \n-            hir::ExprMethodCall(_, _, ref args) => {\n+            hir::ExprMethodCall(.., ref args) => {\n                 self.call(expr, pred, &args[0], args[1..].iter().map(|e| &**e))\n             }\n "}, {"sha": "48f5b7ea2595d70c37eef2066452456661c10d4e", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -341,6 +341,8 @@ path is found (as demonstrated above).\n \n ### Debugging the dependency graph\n \n+#### Dumping the graph\n+\n The compiler is also capable of dumping the dependency graph for your\n debugging pleasure. To do so, pass the `-Z dump-dep-graph` flag. The\n graph will be dumped to `dep_graph.{txt,dot}` in the current\n@@ -392,6 +394,35 @@ This will dump out all the nodes that lead from `Hir(foo)` to\n `TypeckItemBody(bar)`, from which you can (hopefully) see the source\n of the erroneous edge.\n \n+#### Tracking down incorrect edges\n+\n+Sometimes, after you dump the dependency graph, you will find some\n+path that should not exist, but you will not be quite sure how it came\n+to be. **When the compiler is built with debug assertions,** it can\n+help you track that down. Simply set the `RUST_FORBID_DEP_GRAPH_EDGE`\n+environment variable to a filter. Every edge created in the dep-graph\n+will be tested against that filter -- if it matches, a `bug!` is\n+reported, so you can easily see the backtrace (`RUST_BACKTRACE=1`).\n+\n+The syntax for these filters is the same as described in the previous\n+section. However, note that this filter is applied to every **edge**\n+and doesn't handle longer paths in the graph, unlike the previous\n+section.\n+\n+Example:\n+\n+You find that there is a path from the `Hir` of `foo` to the type\n+check of `bar` and you don't think there should be. You dump the\n+dep-graph as described in the previous section and open `dep-graph.txt`\n+to see something like:\n+\n+    Hir(foo) -> Collect(bar)\n+    Collect(bar) -> TypeckItemBody(bar)\n+    \n+That first edge looks suspicious to you. So you set\n+`RUST_FORBID_DEP_GRAPH_EDGE` to `Hir&foo -> Collect&bar`, re-run, and\n+then observe the backtrace. Voila, bug fixed!\n+\n ### Inlining of HIR nodes\n \n For the time being, at least, we still sometimes \"inline\" HIR nodes"}, {"sha": "5b15c5e67174e2d1618495cbc0449b8aaef79591", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -66,4 +66,11 @@ impl EdgeFilter {\n             })\n         }\n     }\n+\n+    pub fn test<D: Clone + Debug>(&self,\n+                                  source: &DepNode<D>,\n+                                  target: &DepNode<D>)\n+                                  -> bool {\n+        self.source.test(source) && self.target.test(target)\n+    }\n }"}, {"sha": "269f0ebb813ca091f6028b60395552790492ab8c", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -103,18 +103,13 @@ pub enum DepNode<D: Clone + Debug> {\n     // table in the tcx (or elsewhere) maps to one of these\n     // nodes. Often we map multiple tables to the same node if there\n     // is no point in distinguishing them (e.g., both the type and\n-    // predicates for an item wind up in `ItemSignature`). Other\n-    // times, such as `ImplItems` vs `TraitItemDefIds`, tables which\n-    // might be mergable are kept distinct because the sets of def-ids\n-    // to which they apply are disjoint, and hence we might as well\n-    // have distinct labels for easier debugging.\n+    // predicates for an item wind up in `ItemSignature`).\n     ImplOrTraitItems(D),\n     ItemSignature(D),\n     FieldTy(D),\n     SizedConstraint(D),\n-    TraitItemDefIds(D),\n+    ImplOrTraitItemDefIds(D),\n     InherentImpls(D),\n-    ImplItems(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -132,7 +127,7 @@ pub enum DepNode<D: Clone + Debug> {\n     // which would yield an overly conservative dep-graph.\n     TraitItems(D),\n     ReprHints(D),\n-    TraitSelect(D, Vec<D>),\n+    TraitSelect(Vec<D>),\n }\n \n impl<D: Clone + Debug> DepNode<D> {\n@@ -162,9 +157,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             ImplOrTraitItems,\n             ItemSignature,\n             FieldTy,\n-            TraitItemDefIds,\n+            ImplOrTraitItemDefIds,\n             InherentImpls,\n-            ImplItems,\n             TraitImpls,\n             ReprHints,\n         }\n@@ -231,16 +225,14 @@ impl<D: Clone + Debug> DepNode<D> {\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n             FieldTy(ref d) => op(d).map(FieldTy),\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n-            TraitItemDefIds(ref d) => op(d).map(TraitItemDefIds),\n+            ImplOrTraitItemDefIds(ref d) => op(d).map(ImplOrTraitItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n-            ImplItems(ref d) => op(d).map(ImplItems),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),\n-            TraitSelect(ref d, ref type_ds) => {\n-                let d = try_opt!(op(d));\n+            TraitSelect(ref type_ds) => {\n                 let type_ds = try_opt!(type_ds.iter().map(|d| op(d)).collect());\n-                Some(TraitSelect(d, type_ds))\n+                Some(TraitSelect(type_ds))\n             }\n         }\n     }"}, {"sha": "51f7890c7a2f4c8e13d31b97e557a26cc0b1c8f3", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -80,6 +80,17 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n     pub fn keys(&self) -> Vec<M::Key> {\n         self.map.keys().cloned().collect()\n     }\n+\n+    /// Append `elem` to the vector stored for `k`, creating a new vector if needed.\n+    /// This is considered a write to `k`.\n+    pub fn push<E: Clone>(&mut self, k: M::Key, elem: E)\n+        where M: DepTrackingMapConfig<Value=Vec<E>>\n+    {\n+        self.write(&k);\n+        self.map.entry(k)\n+                .or_insert(Vec::new())\n+                .push(elem);\n+    }\n }\n \n impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {"}, {"sha": "c42eeead69ec1e9f28224f5cf6f89f78b4bae818", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -46,7 +46,7 @@ impl DepGraph {\n             data: Rc::new(DepGraphData {\n                 thread: DepGraphThreadData::new(enabled),\n                 previous_work_products: RefCell::new(FnvHashMap()),\n-                work_products: RefCell::new(FnvHashMap())\n+                work_products: RefCell::new(FnvHashMap()),\n             })\n         }\n     }"}, {"sha": "9c00e95c17e05f9078405da28e443cc95d026ff1", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -15,6 +15,7 @@ mod edges;\n mod graph;\n mod query;\n mod raii;\n+mod shadow;\n mod thread;\n mod visit;\n "}, {"sha": "e4f572902f9e5dba0c6e3c8d560eedc0466ea119", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -47,3 +47,4 @@ impl<'graph> Drop for IgnoreTask<'graph> {\n         self.data.enqueue(DepMessage::PopIgnore);\n     }\n }\n+"}, {"sha": "72a321425ef063ca826ab410c9e8f9cf26647017", "filename": "src/librustc/dep_graph/shadow.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fshadow.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -0,0 +1,145 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The \"Shadow Graph\" is maintained on the main thread and which\n+//! tracks each message relating to the dep-graph and applies some\n+//! sanity checks as they go by. If an error results, it means you get\n+//! a nice stack-trace telling you precisely what caused the error.\n+//!\n+//! NOTE: This is a debugging facility which can potentially have non-trivial\n+//! runtime impact. Therefore, it is largely compiled out if\n+//! debug-assertions are not enabled.\n+//!\n+//! The basic sanity check, enabled if you have debug assertions\n+//! enabled, is that there is always a task (or ignore) on the stack\n+//! when you do read/write, and that the tasks are pushed/popped\n+//! according to a proper stack discipline.\n+//!\n+//! Optionally, if you specify RUST_FORBID_DEP_GRAPH_EDGE, you can\n+//! specify an edge filter to be applied to each edge as it is\n+//! created.  See `./README.md` for details.\n+\n+use hir::def_id::DefId;\n+use std::cell::{BorrowState, RefCell};\n+use std::env;\n+\n+use super::DepNode;\n+use super::thread::DepMessage;\n+use super::debug::EdgeFilter;\n+\n+pub struct ShadowGraph {\n+    // if you push None onto the stack, that corresponds to an Ignore\n+    stack: RefCell<Vec<Option<DepNode<DefId>>>>,\n+    forbidden_edge: Option<EdgeFilter>,\n+}\n+\n+const ENABLED: bool = cfg!(debug_assertions);\n+\n+impl ShadowGraph {\n+    pub fn new() -> Self {\n+        let forbidden_edge = if !ENABLED {\n+            None\n+        } else {\n+            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n+                Ok(s) => {\n+                    match EdgeFilter::new(&s) {\n+                        Ok(f) => Some(f),\n+                        Err(err) => bug!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n+                    }\n+                }\n+                Err(_) => None,\n+            }\n+        };\n+\n+        ShadowGraph {\n+            stack: RefCell::new(vec![]),\n+            forbidden_edge: forbidden_edge,\n+        }\n+    }\n+\n+    pub fn enqueue(&self, message: &DepMessage) {\n+        if ENABLED {\n+            match self.stack.borrow_state() {\n+                BorrowState::Unused => {}\n+                _ => {\n+                    // When we apply edge filters, that invokes the\n+                    // Debug trait on DefIds, which in turn reads from\n+                    // various bits of state and creates reads! Ignore\n+                    // those recursive reads.\n+                    return;\n+                }\n+            }\n+\n+            let mut stack = self.stack.borrow_mut();\n+            match *message {\n+                DepMessage::Read(ref n) => self.check_edge(Some(Some(n)), top(&stack)),\n+                DepMessage::Write(ref n) => self.check_edge(top(&stack), Some(Some(n))),\n+                DepMessage::PushTask(ref n) => stack.push(Some(n.clone())),\n+                DepMessage::PushIgnore => stack.push(None),\n+                DepMessage::PopTask(ref n) => {\n+                    match stack.pop() {\n+                        Some(Some(m)) => {\n+                            if *n != m {\n+                                bug!(\"stack mismatch: found {:?} expected {:?}\", m, n)\n+                            }\n+                        }\n+                        Some(None) => bug!(\"stack mismatch: found Ignore expected {:?}\", n),\n+                        None => bug!(\"stack mismatch: found empty stack, expected {:?}\", n),\n+                    }\n+                }\n+                DepMessage::PopIgnore => {\n+                    match stack.pop() {\n+                        Some(Some(m)) => bug!(\"stack mismatch: found {:?} expected ignore\", m),\n+                        Some(None) => (),\n+                        None => bug!(\"stack mismatch: found empty stack, expected ignore\"),\n+                    }\n+                }\n+                DepMessage::Query => (),\n+            }\n+        }\n+    }\n+\n+    fn check_edge(&self,\n+                  source: Option<Option<&DepNode<DefId>>>,\n+                  target: Option<Option<&DepNode<DefId>>>) {\n+        assert!(ENABLED);\n+        match (source, target) {\n+            // cannot happen, one side is always Some(Some(_))\n+            (None, None) => unreachable!(),\n+\n+            // nothing on top of the stack\n+            (None, Some(n)) | (Some(n), None) => bug!(\"read/write of {:?} but no current task\", n),\n+\n+            // this corresponds to an Ignore being top of the stack\n+            (Some(None), _) | (_, Some(None)) => (),\n+\n+            // a task is on top of the stack\n+            (Some(Some(source)), Some(Some(target))) => {\n+                if let Some(ref forbidden_edge) = self.forbidden_edge {\n+                    if forbidden_edge.test(source, target) {\n+                        bug!(\"forbidden edge {:?} -> {:?} created\", source, target)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Do a little juggling: we get back a reference to an option at the\n+// top of the stack, convert it to an optional reference.\n+fn top<'s>(stack: &'s Vec<Option<DepNode<DefId>>>) -> Option<Option<&'s DepNode<DefId>>> {\n+    stack.last()\n+        .map(|n: &'s Option<DepNode<DefId>>| -> Option<&'s DepNode<DefId>> {\n+            // (*)\n+            // (*) type annotation just there to clarify what would\n+            // otherwise be some *really* obscure code\n+            n.as_ref()\n+        })\n+}"}, {"sha": "90c42d66b7adfea37a5a24548838683fa2b3f935", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -20,13 +20,13 @@\n \n use hir::def_id::DefId;\n use rustc_data_structures::veccell::VecCell;\n-use std::cell::Cell;\n use std::sync::mpsc::{self, Sender, Receiver};\n use std::thread;\n \n use super::DepGraphQuery;\n use super::DepNode;\n use super::edges::DepGraphEdges;\n+use super::shadow::ShadowGraph;\n \n #[derive(Debug)]\n pub enum DepMessage {\n@@ -42,12 +42,16 @@ pub enum DepMessage {\n pub struct DepGraphThreadData {\n     enabled: bool,\n \n-    // Local counter that just tracks how many tasks are pushed onto the\n-    // stack, so that we still get an error in the case where one is\n-    // missing. If dep-graph construction is enabled, we'd get the same\n-    // error when processing tasks later on, but that's annoying because\n-    // it lacks precision about the source of the error.\n-    tasks_pushed: Cell<usize>,\n+    // The \"shadow graph\" is a debugging aid. We give it each message\n+    // in real time as it arrives and it checks for various errors\n+    // (for example, a read/write when there is no current task; it\n+    // can also apply user-defined filters; see `shadow` module for\n+    // details). This only occurs if debug-assertions are enabled.\n+    //\n+    // Note that in some cases the same errors will occur when the\n+    // data is processed off the main thread, but that's annoying\n+    // because it lacks precision about the source of the error.\n+    shadow_graph: ShadowGraph,\n \n     // current buffer, where we accumulate messages\n     messages: VecCell<DepMessage>,\n@@ -76,7 +80,7 @@ impl DepGraphThreadData {\n \n         DepGraphThreadData {\n             enabled: enabled,\n-            tasks_pushed: Cell::new(0),\n+            shadow_graph: ShadowGraph::new(),\n             messages: VecCell::with_capacity(INITIAL_CAPACITY),\n             swap_in: rx2,\n             swap_out: tx1,\n@@ -118,21 +122,7 @@ impl DepGraphThreadData {\n     /// the buffer is full, this may swap.)\n     #[inline]\n     pub fn enqueue(&self, message: DepMessage) {\n-        // Regardless of whether dep graph construction is enabled, we\n-        // still want to check that we always have a valid task on the\n-        // stack when a read/write/etc event occurs.\n-        match message {\n-            DepMessage::Read(_) | DepMessage::Write(_) =>\n-                if self.tasks_pushed.get() == 0 {\n-                    self.invalid_message(\"read/write but no current task\")\n-                },\n-            DepMessage::PushTask(_) | DepMessage::PushIgnore =>\n-                self.tasks_pushed.set(self.tasks_pushed.get() + 1),\n-            DepMessage::PopTask(_) | DepMessage::PopIgnore =>\n-                self.tasks_pushed.set(self.tasks_pushed.get() - 1),\n-            DepMessage::Query =>\n-                (),\n-        }\n+        self.shadow_graph.enqueue(&message);\n \n         if self.enabled {\n             self.enqueue_enabled(message);\n@@ -147,11 +137,6 @@ impl DepGraphThreadData {\n             self.swap();\n         }\n     }\n-\n-    // Outline this too.\n-    fn invalid_message(&self, string: &str) {\n-        bug!(\"{}; see src/librustc/dep_graph/README.md for more information\", string)\n-    }\n }\n \n /// Definition of the depgraph thread."}, {"sha": "8ba52cdb64f5fd83a6c274f2dfa3720f676fdfdd", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -18,6 +18,7 @@ use syntax::visit::Visitor;\n enum Target {\n     Fn,\n     Struct,\n+    Union,\n     Enum,\n     Other,\n }\n@@ -27,6 +28,7 @@ impl Target {\n         match item.node {\n             ast::ItemKind::Fn(..) => Target::Fn,\n             ast::ItemKind::Struct(..) => Target::Struct,\n+            ast::ItemKind::Union(..) => Target::Union,\n             ast::ItemKind::Enum(..) => Target::Enum,\n             _ => Target::Other,\n         }\n@@ -40,7 +42,9 @@ struct CheckAttrVisitor<'a> {\n impl<'a> CheckAttrVisitor<'a> {\n     fn check_inline(&self, attr: &ast::Attribute, target: Target) {\n         if target != Target::Fn {\n-            span_err!(self.sess, attr.span, E0518, \"attribute should be applied to function\");\n+            struct_span_err!(self.sess, attr.span, E0518, \"attribute should be applied to function\")\n+                .span_label(attr.span, &format!(\"requires a function\"))\n+                .emit();\n         }\n     }\n \n@@ -54,33 +58,40 @@ impl<'a> CheckAttrVisitor<'a> {\n \n         let mut conflicting_reprs = 0;\n         for word in words {\n+\n             let name = match word.name() {\n                 Some(word) => word,\n                 None => continue,\n             };\n \n-            let message = match &*name {\n+            let (message, label) = match &*name {\n                 \"C\" => {\n                     conflicting_reprs += 1;\n-                    if target != Target::Struct && target != Target::Enum {\n-                        \"attribute should be applied to struct or enum\"\n+                    if target != Target::Struct &&\n+                            target != Target::Union &&\n+                            target != Target::Enum {\n+                                (\"attribute should be applied to struct, enum or union\",\n+                                 \"a struct, enum or union\")\n                     } else {\n                         continue\n                     }\n                 }\n                 \"packed\" => {\n                     // Do not increment conflicting_reprs here, because \"packed\"\n                     // can be used to modify another repr hint\n-                    if target != Target::Struct {\n-                        \"attribute should be applied to struct\"\n+                    if target != Target::Struct &&\n+                            target != Target::Union {\n+                                (\"attribute should be applied to struct or union\",\n+                                 \"a struct or union\")\n                     } else {\n                         continue\n                     }\n                 }\n                 \"simd\" => {\n                     conflicting_reprs += 1;\n                     if target != Target::Struct {\n-                        \"attribute should be applied to struct\"\n+                        (\"attribute should be applied to struct\",\n+                         \"a struct\")\n                     } else {\n                         continue\n                     }\n@@ -90,15 +101,17 @@ impl<'a> CheckAttrVisitor<'a> {\n                 \"isize\" | \"usize\" => {\n                     conflicting_reprs += 1;\n                     if target != Target::Enum {\n-                        \"attribute should be applied to enum\"\n+                        (\"attribute should be applied to enum\",\n+                         \"an enum\")\n                     } else {\n                         continue\n                     }\n                 }\n                 _ => continue,\n             };\n-\n-            span_err!(self.sess, attr.span, E0517, \"{}\", message);\n+            struct_span_err!(self.sess, attr.span, E0517, \"{}\", message)\n+                .span_label(attr.span, &format!(\"requires {}\", label))\n+                .emit();\n         }\n         if conflicting_reprs > 1 {\n             span_warn!(self.sess, attr.span, E0566,"}, {"sha": "dec8ea8a29c3918afc091d940d70a57b8106a88e", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -16,23 +16,20 @@ use hir;\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n     Fn(DefId),\n-    SelfTy(Option<DefId> /* trait */, Option<ast::NodeId> /* impl */),\n+    SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n     Mod(DefId),\n-    ForeignMod(DefId),\n     Static(DefId, bool /* is_mutbl */),\n     Const(DefId),\n     AssociatedConst(DefId),\n-    Local(DefId, // def id of variable\n-             ast::NodeId), // node id of variable\n-    Variant(DefId /* enum */, DefId /* variant */),\n+    Local(DefId),\n+    Variant(DefId),\n     Enum(DefId),\n     TyAlias(DefId),\n-    AssociatedTy(DefId /* trait */, DefId),\n+    AssociatedTy(DefId),\n     Trait(DefId),\n     PrimTy(hir::PrimTy),\n     TyParam(DefId),\n     Upvar(DefId,        // def id of closed over local\n-             ast::NodeId,  // node id of closed over local\n              usize,        // index in the freevars list of the closure\n              ast::NodeId), // expr node that creates the closure\n \n@@ -41,6 +38,7 @@ pub enum Def {\n     // If Def::Struct lives in value namespace (e.g. tuple struct, unit struct expressions)\n     // it denotes a constructor and its DefId refers to NodeId of the struct's constructor.\n     Struct(DefId),\n+    Union(DefId),\n     Label(ast::NodeId),\n     Method(DefId),\n     Err,\n@@ -93,37 +91,20 @@ pub type DefMap = NodeMap<PathResolution>;\n // within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct Export {\n     pub name: ast::Name,    // The name of the target.\n     pub def_id: DefId, // The definition of the target.\n }\n \n impl Def {\n-    pub fn var_id(&self) -> ast::NodeId {\n-        match *self {\n-            Def::Local(_, id) |\n-            Def::Upvar(_, id, _, _) => {\n-                id\n-            }\n-\n-            Def::Fn(..) | Def::Mod(..) | Def::ForeignMod(..) | Def::Static(..) |\n-            Def::Variant(..) | Def::Enum(..) | Def::TyAlias(..) | Def::AssociatedTy(..) |\n-            Def::TyParam(..) | Def::Struct(..) | Def::Trait(..) |\n-            Def::Method(..) | Def::Const(..) | Def::AssociatedConst(..) |\n-            Def::PrimTy(..) | Def::Label(..) | Def::SelfTy(..) | Def::Err => {\n-                bug!(\"attempted .var_id() on invalid {:?}\", self)\n-            }\n-        }\n-    }\n-\n     pub fn def_id(&self) -> DefId {\n         match *self {\n-            Def::Fn(id) | Def::Mod(id) | Def::ForeignMod(id) | Def::Static(id, _) |\n-            Def::Variant(_, id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(_, id) |\n-            Def::TyParam(id) | Def::Struct(id) | Def::Trait(id) |\n+            Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n+            Def::Variant(id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(id) |\n+            Def::TyParam(id) | Def::Struct(id) | Def::Union(id) | Def::Trait(id) |\n             Def::Method(id) | Def::Const(id) | Def::AssociatedConst(id) |\n-            Def::Local(id, _) | Def::Upvar(id, _, _, _) => {\n+            Def::Local(id) | Def::Upvar(id, ..) => {\n                 id\n             }\n \n@@ -140,13 +121,13 @@ impl Def {\n         match *self {\n             Def::Fn(..) => \"function\",\n             Def::Mod(..) => \"module\",\n-            Def::ForeignMod(..) => \"foreign module\",\n             Def::Static(..) => \"static\",\n             Def::Variant(..) => \"variant\",\n             Def::Enum(..) => \"enum\",\n             Def::TyAlias(..) => \"type\",\n             Def::AssociatedTy(..) => \"associated type\",\n             Def::Struct(..) => \"struct\",\n+            Def::Union(..) => \"union\",\n             Def::Trait(..) => \"trait\",\n             Def::Method(..) => \"method\",\n             Def::Const(..) => \"constant\","}, {"sha": "399243551d6518b14f7af6807e8d0b3edbf54e94", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 67, "deletions": 16, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -8,12 +8,69 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::cstore::LOCAL_CRATE;\n use ty;\n-use syntax::ast::CrateNum;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+use serialize::{self, Encoder, Decoder};\n+\n use std::fmt;\n use std::u32;\n \n+#[derive(Clone, Copy, Eq, Ord, PartialOrd, PartialEq, Hash, Debug)]\n+pub struct CrateNum(u32);\n+\n+impl Idx for CrateNum {\n+    fn new(value: usize) -> Self {\n+        assert!(value < (u32::MAX) as usize);\n+        CrateNum(value as u32)\n+    }\n+\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+/// Item definitions in the currently-compiled crate would have the CrateNum\n+/// LOCAL_CRATE in their DefId.\n+pub const LOCAL_CRATE: CrateNum = CrateNum(0);\n+\n+impl CrateNum {\n+    pub fn new(x: usize) -> CrateNum {\n+        assert!(x < (u32::MAX as usize));\n+        CrateNum(x as u32)\n+    }\n+\n+    pub fn from_u32(x: u32) -> CrateNum {\n+        CrateNum(x)\n+    }\n+\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+impl fmt::Display for CrateNum {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+impl serialize::UseSpecializedEncodable for CrateNum {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_u32(self.0)\n+    }\n+}\n+\n+impl serialize::UseSpecializedDecodable for CrateNum {\n+    fn default_decode<D: Decoder>(d: &mut D) -> Result<CrateNum, D::Error> {\n+        d.read_u32().map(CrateNum)\n+    }\n+}\n+\n /// A DefIndex is an index into the hir-map for a crate, identifying a\n /// particular definition. It should really be considered an interned\n /// shorthand for a particular DefPath.\n@@ -46,8 +103,7 @@ pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n \n /// A DefId identifies a particular *definition*, by combining a crate\n /// index and a def index.\n-#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n-           RustcDecodable, Hash, Copy)]\n+#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,\n     pub index: DefIndex,\n@@ -58,19 +114,14 @@ impl fmt::Debug for DefId {\n         write!(f, \"DefId {{ krate: {:?}, node: {:?}\",\n                self.krate, self.index)?;\n \n-        // Unfortunately, there seems to be no way to attempt to print\n-        // a path for a def-id, so I'll just make a best effort for now\n-        // and otherwise fallback to just printing the crate/node pair\n-        if self.is_local() { // (1)\n-            // (1) side-step fact that not all external things have paths at\n-            // the moment, such as type parameters\n-            ty::tls::with_opt(|opt_tcx| {\n-                if let Some(tcx) = opt_tcx {\n-                    write!(f, \" => {}\", tcx.item_path_str(*self))?;\n+        ty::tls::with_opt(|opt_tcx| {\n+            if let Some(tcx) = opt_tcx {\n+                if let Some(def_path) = tcx.opt_def_path(*self) {\n+                    write!(f, \" => {}\", def_path.to_string(tcx))?;\n                 }\n-                Ok(())\n-            })?;\n-        }\n+            }\n+            Ok(())\n+        })?;\n \n         write!(f, \" }}\")\n     }"}, {"sha": "12bc49c10dabc77bd5b57f38204ffbd037844e98", "filename": "src/librustc/hir/fold.rs", "status": "removed", "additions": 0, "deletions": 1127, "changes": 1127, "blob_url": "https://github.com/rust-lang/rust/blob/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=da3c6b7646fb94a747583f34cfa5c63ee4ea094a", "patch": "@@ -1,1127 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A Folder represents an HIR->HIR fold; it accepts a HIR piece,\n-//! and returns a piece of the same type.\n-\n-use hir::*;\n-use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_};\n-use syntax::ast::{NestedMetaItem, NestedMetaItemKind, MetaItem, MetaItemKind};\n-use hir;\n-use syntax_pos::Span;\n-use syntax::codemap::{respan, Spanned};\n-use syntax::ptr::P;\n-use syntax::parse::token::keywords;\n-use syntax::util::move_map::MoveMap;\n-\n-pub trait Folder : Sized {\n-    // Any additions to this trait should happen in form\n-    // of a call to a public `noop_*` function that only calls\n-    // out to the folder again, not other `noop_*` functions.\n-    //\n-    // This is a necessary API workaround to the problem of not\n-    // being able to call out to the super default method\n-    // in an overridden default method.\n-\n-    fn fold_crate(&mut self, c: Crate) -> Crate {\n-        noop_fold_crate(c, self)\n-    }\n-\n-    fn fold_meta_items(&mut self, meta_items: HirVec<P<MetaItem>>) -> HirVec<P<MetaItem>> {\n-        noop_fold_meta_items(meta_items, self)\n-    }\n-\n-    fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem {\n-        noop_fold_meta_list_item(list_item, self)\n-    }\n-\n-    fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n-        noop_fold_meta_item(meta_item, self)\n-    }\n-\n-    fn fold_view_path(&mut self, view_path: P<ViewPath>) -> P<ViewPath> {\n-        noop_fold_view_path(view_path, self)\n-    }\n-\n-    fn fold_foreign_item(&mut self, ni: ForeignItem) -> ForeignItem {\n-        noop_fold_foreign_item(ni, self)\n-    }\n-\n-    fn fold_item(&mut self, i: Item) -> Item {\n-        noop_fold_item(i, self)\n-    }\n-\n-    fn fold_item_id(&mut self, i: ItemId) -> ItemId {\n-        noop_fold_item_id(i, self)\n-    }\n-\n-    fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n-        noop_fold_struct_field(sf, self)\n-    }\n-\n-    fn fold_item_underscore(&mut self, i: Item_) -> Item_ {\n-        noop_fold_item_underscore(i, self)\n-    }\n-\n-    fn fold_trait_item(&mut self, i: TraitItem) -> TraitItem {\n-        noop_fold_trait_item(i, self)\n-    }\n-\n-    fn fold_impl_item(&mut self, i: ImplItem) -> ImplItem {\n-        noop_fold_impl_item(i, self)\n-    }\n-\n-    fn fold_fn_decl(&mut self, d: P<FnDecl>) -> P<FnDecl> {\n-        noop_fold_fn_decl(d, self)\n-    }\n-\n-    fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n-        noop_fold_block(b, self)\n-    }\n-\n-    fn fold_stmt(&mut self, s: Stmt) -> Stmt {\n-        noop_fold_stmt(s, self)\n-    }\n-\n-    fn fold_arm(&mut self, a: Arm) -> Arm {\n-        noop_fold_arm(a, self)\n-    }\n-\n-    fn fold_pat(&mut self, p: P<Pat>) -> P<Pat> {\n-        noop_fold_pat(p, self)\n-    }\n-\n-    fn fold_decl(&mut self, d: P<Decl>) -> P<Decl> {\n-        noop_fold_decl(d, self)\n-    }\n-\n-    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n-        e.map(|e| noop_fold_expr(e, self))\n-    }\n-\n-    fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n-        noop_fold_ty(t, self)\n-    }\n-\n-    fn fold_ty_binding(&mut self, t: TypeBinding) -> TypeBinding {\n-        noop_fold_ty_binding(t, self)\n-    }\n-\n-    fn fold_mod(&mut self, m: Mod) -> Mod {\n-        noop_fold_mod(m, self)\n-    }\n-\n-    fn fold_foreign_mod(&mut self, nm: ForeignMod) -> ForeignMod {\n-        noop_fold_foreign_mod(nm, self)\n-    }\n-\n-    fn fold_variant(&mut self, v: Variant) -> Variant {\n-        noop_fold_variant(v, self)\n-    }\n-\n-    fn fold_name(&mut self, n: Name) -> Name {\n-        noop_fold_name(n, self)\n-    }\n-\n-    fn fold_usize(&mut self, i: usize) -> usize {\n-        noop_fold_usize(i, self)\n-    }\n-\n-    fn fold_path(&mut self, p: Path) -> Path {\n-        noop_fold_path(p, self)\n-    }\n-\n-    fn fold_path_parameters(&mut self, p: PathParameters) -> PathParameters {\n-        noop_fold_path_parameters(p, self)\n-    }\n-\n-    fn fold_angle_bracketed_parameter_data(&mut self,\n-                                           p: AngleBracketedParameterData)\n-                                           -> AngleBracketedParameterData {\n-        noop_fold_angle_bracketed_parameter_data(p, self)\n-    }\n-\n-    fn fold_parenthesized_parameter_data(&mut self,\n-                                         p: ParenthesizedParameterData)\n-                                         -> ParenthesizedParameterData {\n-        noop_fold_parenthesized_parameter_data(p, self)\n-    }\n-\n-    fn fold_local(&mut self, l: P<Local>) -> P<Local> {\n-        noop_fold_local(l, self)\n-    }\n-\n-    fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n-        noop_fold_lifetime(l, self)\n-    }\n-\n-    fn fold_lifetime_def(&mut self, l: LifetimeDef) -> LifetimeDef {\n-        noop_fold_lifetime_def(l, self)\n-    }\n-\n-    fn fold_attribute(&mut self, at: Attribute) -> Option<Attribute> {\n-        noop_fold_attribute(at, self)\n-    }\n-\n-    fn fold_arg(&mut self, a: Arg) -> Arg {\n-        noop_fold_arg(a, self)\n-    }\n-\n-    fn fold_generics(&mut self, generics: Generics) -> Generics {\n-        noop_fold_generics(generics, self)\n-    }\n-\n-    fn fold_trait_ref(&mut self, p: TraitRef) -> TraitRef {\n-        noop_fold_trait_ref(p, self)\n-    }\n-\n-    fn fold_poly_trait_ref(&mut self, p: PolyTraitRef) -> PolyTraitRef {\n-        noop_fold_poly_trait_ref(p, self)\n-    }\n-\n-    fn fold_variant_data(&mut self, vdata: VariantData) -> VariantData {\n-        noop_fold_variant_data(vdata, self)\n-    }\n-\n-    fn fold_lifetimes(&mut self, lts: HirVec<Lifetime>) -> HirVec<Lifetime> {\n-        noop_fold_lifetimes(lts, self)\n-    }\n-\n-    fn fold_lifetime_defs(&mut self, lts: HirVec<LifetimeDef>) -> HirVec<LifetimeDef> {\n-        noop_fold_lifetime_defs(lts, self)\n-    }\n-\n-    fn fold_ty_param(&mut self, tp: TyParam) -> TyParam {\n-        noop_fold_ty_param(tp, self)\n-    }\n-\n-    fn fold_ty_params(&mut self, tps: HirVec<TyParam>) -> HirVec<TyParam> {\n-        noop_fold_ty_params(tps, self)\n-    }\n-\n-    fn fold_opt_lifetime(&mut self, o_lt: Option<Lifetime>) -> Option<Lifetime> {\n-        noop_fold_opt_lifetime(o_lt, self)\n-    }\n-\n-    fn fold_opt_bounds(&mut self,\n-                       b: Option<TyParamBounds>)\n-                       -> Option<TyParamBounds> {\n-        noop_fold_opt_bounds(b, self)\n-    }\n-\n-    fn fold_bounds(&mut self, b: TyParamBounds) -> TyParamBounds {\n-        noop_fold_bounds(b, self)\n-    }\n-\n-    fn fold_ty_param_bound(&mut self, tpb: TyParamBound) -> TyParamBound {\n-        noop_fold_ty_param_bound(tpb, self)\n-    }\n-\n-    fn fold_mt(&mut self, mt: MutTy) -> MutTy {\n-        noop_fold_mt(mt, self)\n-    }\n-\n-    fn fold_field(&mut self, field: Field) -> Field {\n-        noop_fold_field(field, self)\n-    }\n-\n-    fn fold_where_clause(&mut self, where_clause: WhereClause) -> WhereClause {\n-        noop_fold_where_clause(where_clause, self)\n-    }\n-\n-    fn fold_where_predicate(&mut self, where_predicate: WherePredicate) -> WherePredicate {\n-        noop_fold_where_predicate(where_predicate, self)\n-    }\n-\n-    /// called for the `id` on each declaration\n-    fn new_id(&mut self, i: NodeId) -> NodeId {\n-        i\n-    }\n-\n-    /// called for ids that are references (e.g., ItemDef)\n-    fn map_id(&mut self, i: NodeId) -> NodeId {\n-        i\n-    }\n-\n-    fn new_span(&mut self, sp: Span) -> Span {\n-        sp\n-    }\n-}\n-\n-pub fn noop_fold_meta_items<T: Folder>(meta_items: HirVec<P<MetaItem>>,\n-                                       fld: &mut T)\n-                                       -> HirVec<P<MetaItem>> {\n-    meta_items.move_map(|x| fld.fold_meta_item(x))\n-}\n-\n-pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n-    view_path.map(|Spanned { node, span }| {\n-        Spanned {\n-            node: match node {\n-                ViewPathSimple(name, path) => {\n-                    ViewPathSimple(name, fld.fold_path(path))\n-                }\n-                ViewPathGlob(path) => {\n-                    ViewPathGlob(fld.fold_path(path))\n-                }\n-                ViewPathList(path, path_list_idents) => {\n-                    ViewPathList(fld.fold_path(path),\n-                                 path_list_idents.move_map(|path_list_ident| {\n-                                     Spanned {\n-                                         node: PathListItem_ {\n-                                             id: fld.new_id(path_list_ident.node.id),\n-                                             name: path_list_ident.node.name,\n-                                             rename: path_list_ident.node.rename,\n-                                         },\n-                                         span: fld.new_span(path_list_ident.span),\n-                                     }\n-                                 }))\n-                }\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn fold_attrs<T, F>(attrs: T, fld: &mut F) -> T\n-    where T: Into<Vec<Attribute>> + From<Vec<Attribute>>,\n-          F: Folder,\n-{\n-    attrs.into().move_flat_map(|x| fld.fold_attribute(x)).into()\n-}\n-\n-pub fn noop_fold_arm<T: Folder>(Arm { attrs, pats, guard, body }: Arm, fld: &mut T) -> Arm {\n-    Arm {\n-        attrs: fold_attrs(attrs, fld),\n-        pats: pats.move_map(|x| fld.fold_pat(x)),\n-        guard: guard.map(|x| fld.fold_expr(x)),\n-        body: fld.fold_expr(body),\n-    }\n-}\n-\n-pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> P<Decl> {\n-    d.map(|Spanned { node, span }| {\n-        match node {\n-            DeclLocal(l) => Spanned {\n-                node: DeclLocal(fld.fold_local(l)),\n-                span: fld.new_span(span),\n-            },\n-            DeclItem(it) => Spanned {\n-                node: DeclItem(fld.fold_item_id(it)),\n-                span: fld.new_span(span),\n-            },\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_ty_binding<T: Folder>(b: TypeBinding, fld: &mut T) -> TypeBinding {\n-    TypeBinding {\n-        id: fld.new_id(b.id),\n-        name: b.name,\n-        ty: fld.fold_ty(b.ty),\n-        span: fld.new_span(b.span),\n-    }\n-}\n-\n-pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n-    t.map(|Ty { id, node, span }| {\n-        Ty {\n-            id: fld.new_id(id),\n-            node: match node {\n-                TyInfer => node,\n-                TyVec(ty) => TyVec(fld.fold_ty(ty)),\n-                TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n-                TyRptr(region, mt) => {\n-                    TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n-                }\n-                TyBareFn(f) => {\n-                    TyBareFn(f.map(|BareFnTy { lifetimes, unsafety, abi, decl }| {\n-                        BareFnTy {\n-                            lifetimes: fld.fold_lifetime_defs(lifetimes),\n-                            unsafety: unsafety,\n-                            abi: abi,\n-                            decl: fld.fold_fn_decl(decl),\n-                        }\n-                    }))\n-                }\n-                TyNever => node,\n-                TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n-                TyPath(qself, path) => {\n-                    let qself = qself.map(|QSelf { ty, position }| {\n-                        QSelf {\n-                            ty: fld.fold_ty(ty),\n-                            position: position,\n-                        }\n-                    });\n-                    TyPath(qself, fld.fold_path(path))\n-                }\n-                TyObjectSum(ty, bounds) => {\n-                    TyObjectSum(fld.fold_ty(ty), fld.fold_bounds(bounds))\n-                }\n-                TyFixedLengthVec(ty, e) => {\n-                    TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n-                }\n-                TyTypeof(expr) => {\n-                    TyTypeof(fld.fold_expr(expr))\n-                }\n-                TyPolyTraitRef(bounds) => {\n-                    TyPolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n-                }\n-                TyImplTrait(bounds) => {\n-                    TyImplTrait(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n-                }\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod { abi, items }: ForeignMod,\n-                                        fld: &mut T)\n-                                        -> ForeignMod {\n-    ForeignMod {\n-        abi: abi,\n-        items: items.move_map(|x| fld.fold_foreign_item(x)),\n-    }\n-}\n-\n-pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n-    Spanned {\n-        node: Variant_ {\n-            name: v.node.name,\n-            attrs: fold_attrs(v.node.attrs, fld),\n-            data: fld.fold_variant_data(v.node.data),\n-            disr_expr: v.node.disr_expr.map(|e| fld.fold_expr(e)),\n-        },\n-        span: fld.new_span(v.span),\n-    }\n-}\n-\n-pub fn noop_fold_name<T: Folder>(n: Name, _: &mut T) -> Name {\n-    n\n-}\n-\n-pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n-    i\n-}\n-\n-pub fn noop_fold_path<T: Folder>(Path { global, segments, span }: Path, fld: &mut T) -> Path {\n-    Path {\n-        global: global,\n-        segments: segments.move_map(|PathSegment { name, parameters }| {\n-            PathSegment {\n-                name: fld.fold_name(name),\n-                parameters: fld.fold_path_parameters(parameters),\n-            }\n-        }),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters,\n-                                            fld: &mut T)\n-                                            -> PathParameters {\n-    match path_parameters {\n-        AngleBracketedParameters(data) =>\n-            AngleBracketedParameters(fld.fold_angle_bracketed_parameter_data(data)),\n-        ParenthesizedParameters(data) =>\n-            ParenthesizedParameters(fld.fold_parenthesized_parameter_data(data)),\n-    }\n-}\n-\n-pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,\n-                                                           fld: &mut T)\n-                                                           -> AngleBracketedParameterData {\n-    let AngleBracketedParameterData { lifetimes, types, bindings } = data;\n-    AngleBracketedParameterData {\n-        lifetimes: fld.fold_lifetimes(lifetimes),\n-        types: types.move_map(|ty| fld.fold_ty(ty)),\n-        bindings: bindings.move_map(|b| fld.fold_ty_binding(b)),\n-    }\n-}\n-\n-pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n-                                                         fld: &mut T)\n-                                                         -> ParenthesizedParameterData {\n-    let ParenthesizedParameterData { inputs, output, span } = data;\n-    ParenthesizedParameterData {\n-        inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n-        output: output.map(|ty| fld.fold_ty(ty)),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n-    l.map(|Local { id, pat, ty, init, span, attrs }| {\n-        Local {\n-            id: fld.new_id(id),\n-            ty: ty.map(|t| fld.fold_ty(t)),\n-            pat: fld.fold_pat(pat),\n-            init: init.map(|e| fld.fold_expr(e)),\n-            span: fld.new_span(span),\n-            attrs: fold_attrs(attrs, fld),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attribute> {\n-    let Spanned {node: Attribute_ {id, style, value, is_sugared_doc}, span} = at;\n-    Some(Spanned {\n-        node: Attribute_ {\n-            id: id,\n-            style: style,\n-            value: fld.fold_meta_item(value),\n-            is_sugared_doc: is_sugared_doc,\n-        },\n-        span: fld.new_span(span),\n-    })\n-}\n-\n-pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n-    -> NestedMetaItem {\n-    Spanned {\n-        node: match li.node {\n-            NestedMetaItemKind::MetaItem(mi) =>  {\n-                NestedMetaItemKind::MetaItem(fld.fold_meta_item(mi))\n-            },\n-            NestedMetaItemKind::Literal(lit) => NestedMetaItemKind::Literal(lit)\n-        },\n-        span: fld.new_span(li.span)\n-    }\n-}\n-\n-pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n-    mi.map(|Spanned { node, span }| {\n-        Spanned {\n-            node: match node {\n-                MetaItemKind::Word(id) => MetaItemKind::Word(id),\n-                MetaItemKind::List(id, mis) => {\n-                    MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_list_item(e)))\n-                }\n-                MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s),\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_arg<T: Folder>(Arg { id, pat, ty }: Arg, fld: &mut T) -> Arg {\n-    Arg {\n-        id: fld.new_id(id),\n-        pat: fld.fold_pat(pat),\n-        ty: fld.fold_ty(ty),\n-    }\n-}\n-\n-pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n-    decl.map(|FnDecl { inputs, output, variadic }| {\n-        FnDecl {\n-            inputs: inputs.move_map(|x| fld.fold_arg(x)),\n-            output: match output {\n-                Return(ty) => Return(fld.fold_ty(ty)),\n-                DefaultReturn(span) => DefaultReturn(span),\n-            },\n-            variadic: variadic,\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T) -> TyParamBound\n-    where T: Folder\n-{\n-    match tpb {\n-        TraitTyParamBound(ty, modifier) => TraitTyParamBound(fld.fold_poly_trait_ref(ty), modifier),\n-        RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n-    }\n-}\n-\n-pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n-    let TyParam {id, name, bounds, default, span} = tp;\n-    TyParam {\n-        id: fld.new_id(id),\n-        name: name,\n-        bounds: fld.fold_bounds(bounds),\n-        default: default.map(|x| fld.fold_ty(x)),\n-        span: span,\n-    }\n-}\n-\n-pub fn noop_fold_ty_params<T: Folder>(tps: HirVec<TyParam>,\n-                                      fld: &mut T)\n-                                      -> HirVec<TyParam> {\n-    tps.move_map(|tp| fld.fold_ty_param(tp))\n-}\n-\n-pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n-    Lifetime {\n-        id: fld.new_id(l.id),\n-        name: l.name,\n-        span: fld.new_span(l.span),\n-    }\n-}\n-\n-pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T) -> LifetimeDef {\n-    LifetimeDef {\n-        lifetime: fld.fold_lifetime(l.lifetime),\n-        bounds: fld.fold_lifetimes(l.bounds),\n-    }\n-}\n-\n-pub fn noop_fold_lifetimes<T: Folder>(lts: HirVec<Lifetime>, fld: &mut T) -> HirVec<Lifetime> {\n-    lts.move_map(|l| fld.fold_lifetime(l))\n-}\n-\n-pub fn noop_fold_lifetime_defs<T: Folder>(lts: HirVec<LifetimeDef>,\n-                                          fld: &mut T)\n-                                          -> HirVec<LifetimeDef> {\n-    lts.move_map(|l| fld.fold_lifetime_def(l))\n-}\n-\n-pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T) -> Option<Lifetime> {\n-    o_lt.map(|lt| fld.fold_lifetime(lt))\n-}\n-\n-pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause, span}: Generics,\n-                                     fld: &mut T)\n-                                     -> Generics {\n-    Generics {\n-        ty_params: fld.fold_ty_params(ty_params),\n-        lifetimes: fld.fold_lifetime_defs(lifetimes),\n-        where_clause: fld.fold_where_clause(where_clause),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_where_clause<T: Folder>(WhereClause { id, predicates }: WhereClause,\n-                                         fld: &mut T)\n-                                         -> WhereClause {\n-    WhereClause {\n-        id: fld.new_id(id),\n-        predicates: predicates.move_map(|predicate| fld.fold_where_predicate(predicate)),\n-    }\n-}\n-\n-pub fn noop_fold_where_predicate<T: Folder>(pred: WherePredicate, fld: &mut T) -> WherePredicate {\n-    match pred {\n-        hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{bound_lifetimes,\n-                                                                     bounded_ty,\n-                                                                     bounds,\n-                                                                     span}) => {\n-            hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                bound_lifetimes: fld.fold_lifetime_defs(bound_lifetimes),\n-                bounded_ty: fld.fold_ty(bounded_ty),\n-                bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n-                span: fld.new_span(span),\n-            })\n-        }\n-        hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{lifetime,\n-                                                                       bounds,\n-                                                                       span}) => {\n-            hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                span: fld.new_span(span),\n-                lifetime: fld.fold_lifetime(lifetime),\n-                bounds: bounds.move_map(|bound| fld.fold_lifetime(bound)),\n-            })\n-        }\n-        hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{id,\n-                                                               path,\n-                                                               ty,\n-                                                               span}) => {\n-            hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                id: fld.new_id(id),\n-                path: fld.fold_path(path),\n-                ty: fld.fold_ty(ty),\n-                span: fld.new_span(span),\n-            })\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_variant_data<T: Folder>(vdata: VariantData, fld: &mut T) -> VariantData {\n-    match vdata {\n-        VariantData::Struct(fields, id) => {\n-            VariantData::Struct(fields.move_map(|f| fld.fold_struct_field(f)),\n-                                fld.new_id(id))\n-        }\n-        VariantData::Tuple(fields, id) => {\n-            VariantData::Tuple(fields.move_map(|f| fld.fold_struct_field(f)),\n-                               fld.new_id(id))\n-        }\n-        VariantData::Unit(id) => VariantData::Unit(fld.new_id(id)),\n-    }\n-}\n-\n-pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n-    let id = fld.new_id(p.ref_id);\n-    let TraitRef {\n-        path,\n-        ref_id: _,\n-    } = p;\n-    hir::TraitRef {\n-        path: fld.fold_path(path),\n-        ref_id: id,\n-    }\n-}\n-\n-pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n-    hir::PolyTraitRef {\n-        bound_lifetimes: fld.fold_lifetime_defs(p.bound_lifetimes),\n-        trait_ref: fld.fold_trait_ref(p.trait_ref),\n-        span: fld.new_span(p.span),\n-    }\n-}\n-\n-pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructField {\n-    StructField {\n-        span: fld.new_span(f.span),\n-        id: fld.new_id(f.id),\n-        name: f.name,\n-        vis: f.vis,\n-        ty: fld.fold_ty(f.ty),\n-        attrs: fold_attrs(f.attrs, fld),\n-    }\n-}\n-\n-pub fn noop_fold_field<T: Folder>(Field { name, expr, span }: Field, folder: &mut T) -> Field {\n-    Field {\n-        name: respan(folder.new_span(name.span), folder.fold_name(name.node)),\n-        expr: folder.fold_expr(expr),\n-        span: folder.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_mt<T: Folder>(MutTy { ty, mutbl }: MutTy, folder: &mut T) -> MutTy {\n-    MutTy {\n-        ty: folder.fold_ty(ty),\n-        mutbl: mutbl,\n-    }\n-}\n-\n-pub fn noop_fold_opt_bounds<T: Folder>(b: Option<TyParamBounds>,\n-                                       folder: &mut T)\n-                                       -> Option<TyParamBounds> {\n-    b.map(|bounds| folder.fold_bounds(bounds))\n-}\n-\n-fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T) -> TyParamBounds {\n-    bounds.move_map(|bound| folder.fold_ty_param_bound(bound))\n-}\n-\n-pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block { id, stmts, expr, rules, span }| {\n-        Block {\n-            id: folder.new_id(id),\n-            stmts: stmts.move_map(|s| folder.fold_stmt(s)),\n-            expr: expr.map(|x| folder.fold_expr(x)),\n-            rules: rules,\n-            span: folder.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n-    match i {\n-        ItemExternCrate(string) => ItemExternCrate(string),\n-        ItemUse(view_path) => {\n-            ItemUse(folder.fold_view_path(view_path))\n-        }\n-        ItemStatic(t, m, e) => {\n-            ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n-        }\n-        ItemConst(t, e) => {\n-            ItemConst(folder.fold_ty(t), folder.fold_expr(e))\n-        }\n-        ItemFn(decl, unsafety, constness, abi, generics, body) => {\n-            ItemFn(folder.fold_fn_decl(decl),\n-                   unsafety,\n-                   constness,\n-                   abi,\n-                   folder.fold_generics(generics),\n-                   folder.fold_block(body))\n-        }\n-        ItemMod(m) => ItemMod(folder.fold_mod(m)),\n-        ItemForeignMod(nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n-        ItemTy(t, generics) => {\n-            ItemTy(folder.fold_ty(t), folder.fold_generics(generics))\n-        }\n-        ItemEnum(enum_definition, generics) => {\n-            ItemEnum(hir::EnumDef {\n-                         variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n-                     },\n-                     folder.fold_generics(generics))\n-        }\n-        ItemStruct(struct_def, generics) => {\n-            let struct_def = folder.fold_variant_data(struct_def);\n-            ItemStruct(struct_def, folder.fold_generics(generics))\n-        }\n-        ItemDefaultImpl(unsafety, ref trait_ref) => {\n-            ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n-        }\n-        ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n-            let new_impl_items = impl_items\n-                .move_map(|item| folder.fold_impl_item(item));\n-            let ifce = match ifce {\n-                None => None,\n-                Some(ref trait_ref) => {\n-                    Some(folder.fold_trait_ref((*trait_ref).clone()))\n-                }\n-            };\n-            ItemImpl(unsafety,\n-                     polarity,\n-                     folder.fold_generics(generics),\n-                     ifce,\n-                     folder.fold_ty(ty),\n-                     new_impl_items)\n-        }\n-        ItemTrait(unsafety, generics, bounds, items) => {\n-            let bounds = folder.fold_bounds(bounds);\n-            let items = items.move_map(|item| folder.fold_trait_item(item));\n-            ItemTrait(unsafety, folder.fold_generics(generics), bounds, items)\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_trait_item<T: Folder>(i: TraitItem,\n-                                       folder: &mut T)\n-                                       -> TraitItem {\n-    TraitItem {\n-        id: folder.new_id(i.id),\n-        name: folder.fold_name(i.name),\n-        attrs: fold_attrs(i.attrs, folder),\n-        node: match i.node {\n-            ConstTraitItem(ty, default) => {\n-                ConstTraitItem(folder.fold_ty(ty), default.map(|x| folder.fold_expr(x)))\n-            }\n-            MethodTraitItem(sig, body) => {\n-                MethodTraitItem(noop_fold_method_sig(sig, folder),\n-                                body.map(|x| folder.fold_block(x)))\n-            }\n-            TypeTraitItem(bounds, default) => {\n-                TypeTraitItem(folder.fold_bounds(bounds),\n-                              default.map(|x| folder.fold_ty(x)))\n-            }\n-        },\n-        span: folder.new_span(i.span),\n-    }\n-}\n-\n-pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T) -> ImplItem {\n-    ImplItem {\n-        id: folder.new_id(i.id),\n-        name: folder.fold_name(i.name),\n-        attrs: fold_attrs(i.attrs, folder),\n-        vis: i.vis,\n-        defaultness: i.defaultness,\n-        node: match i.node {\n-            ImplItemKind::Const(ty, expr) => {\n-                ImplItemKind::Const(folder.fold_ty(ty), folder.fold_expr(expr))\n-            }\n-            ImplItemKind::Method(sig, body) => {\n-                ImplItemKind::Method(noop_fold_method_sig(sig, folder), folder.fold_block(body))\n-            }\n-            ImplItemKind::Type(ty) => ImplItemKind::Type(folder.fold_ty(ty)),\n-        },\n-        span: folder.new_span(i.span),\n-    }\n-}\n-\n-pub fn noop_fold_mod<T: Folder>(Mod { inner, item_ids }: Mod, folder: &mut T) -> Mod {\n-    Mod {\n-        inner: folder.new_span(inner),\n-        item_ids: item_ids.move_map(|x| folder.fold_item_id(x)),\n-    }\n-}\n-\n-pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span,\n-                                          exported_macros, items }: Crate,\n-                                  folder: &mut T)\n-                                  -> Crate {\n-    let config = folder.fold_meta_items(config);\n-\n-    let crate_mod = folder.fold_item(hir::Item {\n-        name: keywords::Invalid.name(),\n-        attrs: attrs,\n-        id: DUMMY_NODE_ID,\n-        vis: hir::Public,\n-        span: span,\n-        node: hir::ItemMod(module),\n-    });\n-\n-    let (module, attrs, span) = match crate_mod {\n-        hir::Item { attrs, span, node, .. } => {\n-            match node {\n-                hir::ItemMod(m) => (m, attrs, span),\n-                _ => panic!(\"fold converted a module to not a module\"),\n-            }\n-        }\n-    };\n-\n-    let items = items.into_iter()\n-                     .map(|(id, item)| (id, folder.fold_item(item)))\n-                     .collect();\n-\n-    Crate {\n-        module: module,\n-        attrs: attrs,\n-        config: config,\n-        span: span,\n-        exported_macros: exported_macros,\n-        items: items,\n-    }\n-}\n-\n-pub fn noop_fold_item_id<T: Folder>(i: ItemId, folder: &mut T) -> ItemId {\n-    let id = folder.map_id(i.id);\n-    ItemId { id: id }\n-}\n-\n-// fold one item into one item\n-pub fn noop_fold_item<T: Folder>(item: Item, folder: &mut T) -> Item {\n-    let Item { id, name, attrs, node, vis, span } = item;\n-    let id = folder.new_id(id);\n-    let node = folder.fold_item_underscore(node);\n-\n-    Item {\n-        id: id,\n-        name: folder.fold_name(name),\n-        attrs: fold_attrs(attrs, folder),\n-        node: node,\n-        vis: vis,\n-        span: folder.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> ForeignItem {\n-    ForeignItem {\n-        id: folder.new_id(ni.id),\n-        name: folder.fold_name(ni.name),\n-        attrs: fold_attrs(ni.attrs, folder),\n-        node: match ni.node {\n-            ForeignItemFn(fdec, generics) => {\n-                ForeignItemFn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n-            }\n-            ForeignItemStatic(t, m) => {\n-                ForeignItemStatic(folder.fold_ty(t), m)\n-            }\n-        },\n-        vis: ni.vis,\n-        span: folder.new_span(ni.span),\n-    }\n-}\n-\n-pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n-    MethodSig {\n-        generics: folder.fold_generics(sig.generics),\n-        abi: sig.abi,\n-        unsafety: sig.unsafety,\n-        constness: sig.constness,\n-        decl: folder.fold_fn_decl(sig.decl),\n-    }\n-}\n-\n-pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n-    p.map(|Pat { id, node, span }| {\n-        Pat {\n-            id: folder.new_id(id),\n-            node: match node {\n-                PatKind::Wild => PatKind::Wild,\n-                PatKind::Binding(binding_mode, pth1, sub) => {\n-                    PatKind::Binding(binding_mode,\n-                             Spanned {\n-                                 span: folder.new_span(pth1.span),\n-                                 node: folder.fold_name(pth1.node),\n-                             },\n-                             sub.map(|x| folder.fold_pat(x)))\n-                }\n-                PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n-                PatKind::TupleStruct(pth, pats, ddpos) => {\n-                    PatKind::TupleStruct(folder.fold_path(pth),\n-                            pats.move_map(|x| folder.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Path(opt_qself, pth) => {\n-                    let opt_qself = opt_qself.map(|qself| {\n-                        QSelf { ty: folder.fold_ty(qself.ty), position: qself.position }\n-                    });\n-                    PatKind::Path(opt_qself, folder.fold_path(pth))\n-                }\n-                PatKind::Struct(pth, fields, etc) => {\n-                    let pth = folder.fold_path(pth);\n-                    let fs = fields.move_map(|f| {\n-                        Spanned {\n-                            span: folder.new_span(f.span),\n-                            node: hir::FieldPat {\n-                                name: f.node.name,\n-                                pat: folder.fold_pat(f.node.pat),\n-                                is_shorthand: f.node.is_shorthand,\n-                            },\n-                        }\n-                    });\n-                    PatKind::Struct(pth, fs, etc)\n-                }\n-                PatKind::Tuple(elts, ddpos) => {\n-                    PatKind::Tuple(elts.move_map(|x| folder.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n-                PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n-                PatKind::Range(e1, e2) => {\n-                    PatKind::Range(folder.fold_expr(e1), folder.fold_expr(e2))\n-                }\n-                PatKind::Vec(before, slice, after) => {\n-                    PatKind::Vec(before.move_map(|x| folder.fold_pat(x)),\n-                           slice.map(|x| folder.fold_pat(x)),\n-                           after.move_map(|x| folder.fold_pat(x)))\n-                }\n-            },\n-            span: folder.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &mut T) -> Expr {\n-    Expr {\n-        id: folder.new_id(id),\n-        node: match node {\n-            ExprBox(e) => {\n-                ExprBox(folder.fold_expr(e))\n-            }\n-            ExprVec(exprs) => {\n-                ExprVec(exprs.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprRepeat(expr, count) => {\n-                ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n-            }\n-            ExprTup(elts) => ExprTup(elts.move_map(|x| folder.fold_expr(x))),\n-            ExprCall(f, args) => {\n-                ExprCall(folder.fold_expr(f), args.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprMethodCall(name, tps, args) => {\n-                ExprMethodCall(respan(folder.new_span(name.span), folder.fold_name(name.node)),\n-                               tps.move_map(|x| folder.fold_ty(x)),\n-                               args.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprBinary(binop, lhs, rhs) => {\n-                ExprBinary(binop, folder.fold_expr(lhs), folder.fold_expr(rhs))\n-            }\n-            ExprUnary(binop, ohs) => {\n-                ExprUnary(binop, folder.fold_expr(ohs))\n-            }\n-            ExprLit(l) => ExprLit(l),\n-            ExprCast(expr, ty) => {\n-                ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n-            }\n-            ExprType(expr, ty) => {\n-                ExprType(folder.fold_expr(expr), folder.fold_ty(ty))\n-            }\n-            ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n-            ExprIf(cond, tr, fl) => {\n-                ExprIf(folder.fold_expr(cond),\n-                       folder.fold_block(tr),\n-                       fl.map(|x| folder.fold_expr(x)))\n-            }\n-            ExprWhile(cond, body, opt_name) => {\n-                ExprWhile(folder.fold_expr(cond),\n-                          folder.fold_block(body),\n-                          opt_name.map(|label| {\n-                              respan(folder.new_span(label.span), folder.fold_name(label.node))\n-                          }))\n-            }\n-            ExprLoop(body, opt_name) => {\n-                ExprLoop(folder.fold_block(body),\n-                         opt_name.map(|label| {\n-                             respan(folder.new_span(label.span), folder.fold_name(label.node))\n-                         }))\n-            }\n-            ExprMatch(expr, arms, source) => {\n-                ExprMatch(folder.fold_expr(expr),\n-                          arms.move_map(|x| folder.fold_arm(x)),\n-                          source)\n-            }\n-            ExprClosure(capture_clause, decl, body, fn_decl_span) => {\n-                ExprClosure(capture_clause,\n-                            folder.fold_fn_decl(decl),\n-                            folder.fold_block(body),\n-                            folder.new_span(fn_decl_span))\n-            }\n-            ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n-            ExprAssign(el, er) => {\n-                ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprAssignOp(op, el, er) => {\n-                ExprAssignOp(op, folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprField(el, name) => {\n-                ExprField(folder.fold_expr(el),\n-                          respan(folder.new_span(name.span), folder.fold_name(name.node)))\n-            }\n-            ExprTupField(el, index) => {\n-                ExprTupField(folder.fold_expr(el),\n-                             respan(folder.new_span(index.span), folder.fold_usize(index.node)))\n-            }\n-            ExprIndex(el, er) => {\n-                ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprPath(qself, path) => {\n-                let qself = qself.map(|QSelf { ty, position }| {\n-                    QSelf {\n-                        ty: folder.fold_ty(ty),\n-                        position: position,\n-                    }\n-                });\n-                ExprPath(qself, folder.fold_path(path))\n-            }\n-            ExprBreak(opt_name) => ExprBreak(opt_name.map(|label| {\n-                respan(folder.new_span(label.span), folder.fold_name(label.node))\n-            })),\n-            ExprAgain(opt_name) => ExprAgain(opt_name.map(|label| {\n-                respan(folder.new_span(label.span), folder.fold_name(label.node))\n-            })),\n-            ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n-            ExprInlineAsm(asm, outputs, inputs) => {\n-                ExprInlineAsm(asm,\n-                              outputs.move_map(|x| folder.fold_expr(x)),\n-                              inputs.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprStruct(path, fields, maybe_expr) => {\n-                ExprStruct(folder.fold_path(path),\n-                           fields.move_map(|x| folder.fold_field(x)),\n-                           maybe_expr.map(|x| folder.fold_expr(x)))\n-            }\n-        },\n-        span: folder.new_span(span),\n-        attrs: fold_attrs(attrs, folder),\n-    }\n-}\n-\n-pub fn noop_fold_stmt<T: Folder>(stmt: Stmt, folder: &mut T) -> Stmt {\n-    let span = folder.new_span(stmt.span);\n-    match stmt.node {\n-        StmtDecl(d, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtDecl(folder.fold_decl(d), id),\n-                span: span\n-            }\n-        }\n-        StmtExpr(e, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtExpr(folder.fold_expr(e), id),\n-                span: span,\n-            }\n-        }\n-        StmtSemi(e, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtSemi(folder.fold_expr(e), id),\n-                span: span,\n-            }\n-        }\n-    }\n-}"}, {"sha": "726e4e53e231c1fc5c592ac4e80b9be80f7c3524", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -49,8 +49,8 @@ pub enum FnKind<'a> {\n impl<'a> FnKind<'a> {\n     pub fn attrs(&self) -> &'a [Attribute] {\n         match *self {\n-            FnKind::ItemFn(_, _, _, _, _, _, attrs) => attrs,\n-            FnKind::Method(_, _, _, attrs) => attrs,\n+            FnKind::ItemFn(.., attrs) => attrs,\n+            FnKind::Method(.., attrs) => attrs,\n             FnKind::Closure(attrs) => attrs,\n         }\n     }\n@@ -341,14 +341,15 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_id(item.id);\n             visitor.visit_trait_ref(trait_ref)\n         }\n-        ItemImpl(_, _, ref type_parameters, ref opt_trait_reference, ref typ, ref impl_items) => {\n+        ItemImpl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_items) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(type_parameters);\n             walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_impl_item, impl_items);\n         }\n-        ItemStruct(ref struct_definition, ref generics) => {\n+        ItemStruct(ref struct_definition, ref generics) |\n+        ItemUnion(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_id(item.id);\n             visitor.visit_variant_data(struct_definition, item.name, generics, item.id, item.span);\n@@ -621,10 +622,10 @@ pub fn walk_fn_decl_nopat<'v, V: Visitor<'v>>(visitor: &mut V, function_declarat\n \n pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'v>) {\n     match function_kind {\n-        FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n+        FnKind::ItemFn(_, generics, ..) => {\n             visitor.visit_generics(generics);\n         }\n-        FnKind::Method(_, sig, _, _) => {\n+        FnKind::Method(_, sig, ..) => {\n             visitor.visit_generics(&sig.generics);\n         }\n         FnKind::Closure(_) => {}\n@@ -880,8 +881,8 @@ pub struct IdRange {\n impl IdRange {\n     pub fn max() -> IdRange {\n         IdRange {\n-            min: u32::MAX,\n-            max: u32::MIN,\n+            min: NodeId::from_u32(u32::MAX),\n+            max: NodeId::from_u32(u32::MIN),\n         }\n     }\n \n@@ -895,7 +896,7 @@ impl IdRange {\n \n     pub fn add(&mut self, id: NodeId) {\n         self.min = cmp::min(self.min, id);\n-        self.max = cmp::max(self.max, id + 1);\n+        self.max = cmp::max(self.max, NodeId::from_u32(id.as_u32() + 1));\n     }\n \n }"}, {"sha": "37b5eac3cceebcec77d9191b99cb08a14b5d01f6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 20, "deletions": 39, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -61,7 +61,7 @@ use syntax_pos::Span;\n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n-    sess: Option<&'a Session>,\n+    sess: &'a Session,\n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n@@ -81,21 +81,7 @@ pub trait Resolver {\n \n     // We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n     // This should only return `None` during testing.\n-    fn definitions(&mut self) -> Option<&mut Definitions>;\n-}\n-\n-pub struct DummyResolver;\n-impl Resolver for DummyResolver {\n-    fn resolve_generated_global_path(&mut self, _path: &hir::Path, _is_value: bool) -> Def {\n-        Def::Err\n-    }\n-    fn get_resolution(&mut self, _id: NodeId) -> Option<PathResolution> {\n-        None\n-    }\n-    fn record_resolution(&mut self, _id: NodeId, _def: Def) {}\n-    fn definitions(&mut self) -> Option<&mut Definitions> {\n-        None\n-    }\n+    fn definitions(&mut self) -> &mut Definitions;\n }\n \n pub fn lower_crate(sess: &Session,\n@@ -115,22 +101,13 @@ pub fn lower_crate(sess: &Session,\n         } else {\n             Some(\"std\")\n         },\n-        sess: Some(sess),\n+        sess: sess,\n         parent_def: None,\n         resolver: resolver,\n     }.lower_crate(krate)\n }\n \n impl<'a> LoweringContext<'a> {\n-    pub fn testing_context(resolver: &'a mut Resolver) -> Self {\n-        LoweringContext {\n-            crate_root: None,\n-            sess: None,\n-            parent_def: None,\n-            resolver: resolver,\n-        }\n-    }\n-\n     fn lower_crate(&mut self, c: &Crate) -> hir::Crate {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n             items: BTreeMap<NodeId, hir::Item>,\n@@ -161,12 +138,11 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn next_id(&self) -> NodeId {\n-        self.sess.map(Session::next_node_id).unwrap_or(0)\n+        self.sess.next_node_id()\n     }\n \n     fn diagnostic(&self) -> &errors::Handler {\n-        self.sess.map(Session::diagnostic)\n-                 .unwrap_or_else(|| panic!(\"this lowerer cannot emit diagnostics\"))\n+        self.sess.diagnostic()\n     }\n \n     fn str_to_ident(&self, s: &'static str) -> Name {\n@@ -177,9 +153,9 @@ impl<'a> LoweringContext<'a> {\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n         let old_def = self.parent_def;\n-        self.parent_def = match self.resolver.definitions() {\n-            Some(defs) => Some(defs.opt_def_index(parent_id).unwrap()),\n-            None => old_def,\n+        self.parent_def = {\n+            let defs = self.resolver.definitions();\n+            Some(defs.opt_def_index(parent_id).unwrap())\n         };\n \n         let result = f(self);\n@@ -638,7 +614,10 @@ impl<'a> LoweringContext<'a> {\n                 let struct_def = self.lower_variant_data(struct_def);\n                 hir::ItemStruct(struct_def, self.lower_generics(generics))\n             }\n-            ItemKind::Union(..) => panic!(\"`union` is not yet implemented\"),\n+            ItemKind::Union(ref vdata, ref generics) => {\n+                let vdata = self.lower_variant_data(vdata);\n+                hir::ItemUnion(vdata, self.lower_generics(generics))\n+            }\n             ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n                 hir::ItemDefaultImpl(self.lower_unsafety(unsafety),\n                                      self.lower_trait_ref(trait_ref))\n@@ -1716,9 +1695,10 @@ impl<'a> LoweringContext<'a> {\n         let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n         let expr = self.expr(span, expr_path, ThinVec::new());\n \n-        let def = self.resolver.definitions().map(|defs| {\n-            Def::Local(defs.local_def_id(binding), binding)\n-        }).unwrap_or(Def::Err);\n+        let def = {\n+            let defs = self.resolver.definitions();\n+            Def::Local(defs.local_def_id(binding))\n+        };\n         self.resolver.record_resolution(expr.id, def);\n \n         expr\n@@ -1866,11 +1846,12 @@ impl<'a> LoweringContext<'a> {\n         let pat = self.pat(span, pat_ident);\n \n         let parent_def = self.parent_def;\n-        let def = self.resolver.definitions().map(|defs| {\n+        let def = {\n+            let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name.as_str());\n             let def_index = defs.create_def_with_parent(parent_def, pat.id, def_path_data);\n-            Def::Local(DefId::local(def_index), pat.id)\n-        }).unwrap_or(Def::Err);\n+            Def::Local(DefId::local(def_index))\n+        };\n         self.resolver.record_resolution(pat.id, def);\n \n         pat"}, {"sha": "3d9031a136e280cdbd0b5b0ac88178655f121825", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -27,6 +27,10 @@ pub struct NodeCollector<'ast> {\n     pub map: Vec<MapEntry<'ast>>,\n     /// The parent of this node\n     pub parent_node: NodeId,\n+    /// If true, completely ignore nested items. We set this when loading\n+    /// HIR from metadata, since in that case we only want the HIR for\n+    /// one specific item (and not the ones nested inside of it).\n+    pub ignore_nested_items: bool\n }\n \n impl<'ast> NodeCollector<'ast> {\n@@ -35,6 +39,7 @@ impl<'ast> NodeCollector<'ast> {\n             krate: krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n+            ignore_nested_items: false\n         };\n         collector.insert_entry(CRATE_NODE_ID, RootCrate);\n \n@@ -52,6 +57,7 @@ impl<'ast> NodeCollector<'ast> {\n             krate: krate,\n             map: map,\n             parent_node: parent_node,\n+            ignore_nested_items: true\n         };\n \n         assert_eq!(parent_def_path.krate, parent_def_id.krate);\n@@ -63,10 +69,10 @@ impl<'ast> NodeCollector<'ast> {\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n         debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n-        if id as usize >= len {\n-            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n+        if id.as_usize() >= len {\n+            self.map.extend(repeat(NotPresent).take(id.as_usize() - len + 1));\n         }\n-        self.map[id as usize] = entry;\n+        self.map[id.as_usize()] = entry;\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n@@ -88,7 +94,9 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     /// their outer items.\n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        self.visit_item(self.krate.item(item.id))\n+        if !self.ignore_nested_items {\n+            self.visit_item(self.krate.item(item.id))\n+        }\n     }\n \n     fn visit_item(&mut self, i: &'ast Item) {\n@@ -109,7 +117,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                         this.insert(struct_def.id(), NodeStructCtor(struct_def));\n                     }\n                 }\n-                ItemTrait(_, _, ref bounds, _) => {\n+                ItemTrait(.., ref bounds, _) => {\n                     for b in bounds.iter() {\n                         if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n                             this.insert(t.trait_ref.ref_id, NodeItem(i));"}, {"sha": "ea1f8aac7a55ab036a3d065529468c118e017188", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -285,15 +285,6 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n \n // We walk the HIR rather than the AST when reading items from metadata.\n impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n-    /// Because we want to track parent items and so forth, enable\n-    /// deep walking so that we walk nested items in the context of\n-    /// their outer items.\n-    fn visit_nested_item(&mut self, item_id: hir::ItemId) {\n-        debug!(\"visit_nested_item: {:?}\", item_id);\n-        let item = self.hir_crate.unwrap().item(item_id.id);\n-        self.visit_item(item)\n-    }\n-\n     fn visit_item(&mut self, i: &'ast hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n@@ -302,9 +293,9 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n         let def_data = match i.node {\n             hir::ItemDefaultImpl(..) | hir::ItemImpl(..) =>\n                 DefPathData::Impl,\n-            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemTrait(..) |\n-            hir::ItemExternCrate(..) | hir::ItemMod(..) | hir::ItemForeignMod(..) |\n-            hir::ItemTy(..) =>\n+            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemUnion(..) |\n+            hir::ItemTrait(..) | hir::ItemExternCrate(..) | hir::ItemMod(..) |\n+            hir::ItemForeignMod(..) | hir::ItemTy(..) =>\n                 DefPathData::TypeNs(i.name.as_str()),\n             hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) =>\n                 DefPathData::ValueNs(i.name.as_str()),\n@@ -331,7 +322,8 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n                         });\n                     }\n                 }\n-                hir::ItemStruct(ref struct_def, _) => {\n+                hir::ItemStruct(ref struct_def, _) |\n+                hir::ItemUnion(ref struct_def, _) => {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n                         this.create_def(struct_def.id(),"}, {"sha": "f404f60cc9cefa766afeb4ec3f814f6ed68bddef", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::{DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map::def_collector::DefCollector;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::fmt::Write;\n use std::hash::{Hash, Hasher, SipHasher};\n use syntax::{ast, visit};\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token::{self, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n@@ -70,15 +69,15 @@ pub struct DefPath {\n     pub data: Vec<DisambiguatedDefPathData>,\n \n     /// what krate root is this path relative to?\n-    pub krate: ast::CrateNum,\n+    pub krate: CrateNum,\n }\n \n impl DefPath {\n     pub fn is_local(&self) -> bool {\n         self.krate == LOCAL_CRATE\n     }\n \n-    pub fn make<FN>(start_krate: ast::CrateNum,\n+    pub fn make<FN>(start_krate: CrateNum,\n                     start_index: DefIndex,\n                     mut get_key: FN) -> DefPath\n         where FN: FnMut(DefIndex) -> DefKey\n@@ -116,11 +115,7 @@ impl DefPath {\n     pub fn to_string(&self, tcx: TyCtxt) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n-        if self.krate == LOCAL_CRATE {\n-            s.push_str(&tcx.crate_name(self.krate));\n-        } else {\n-            s.push_str(&tcx.sess.cstore.original_crate_name(self.krate));\n-        }\n+        s.push_str(&tcx.original_crate_name(self.krate));\n         s.push_str(\"/\");\n         s.push_str(&tcx.crate_disambiguator(self.krate));\n \n@@ -142,7 +137,7 @@ impl DefPath {\n     }\n \n     pub fn deterministic_hash_to<H: Hasher>(&self, tcx: TyCtxt, state: &mut H) {\n-        tcx.crate_name(self.krate).hash(state);\n+        tcx.original_crate_name(self.krate).hash(state);\n         tcx.crate_disambiguator(self.krate).hash(state);\n         self.data.hash(state);\n     }\n@@ -327,6 +322,30 @@ impl Definitions {\n }\n \n impl DefPathData {\n+    pub fn get_opt_name(&self) -> Option<ast::Name> {\n+        use self::DefPathData::*;\n+        match *self {\n+            TypeNs(ref name) |\n+            ValueNs(ref name) |\n+            Module(ref name) |\n+            MacroDef(ref name) |\n+            TypeParam(ref name) |\n+            LifetimeDef(ref name) |\n+            EnumVariant(ref name) |\n+            Binding(ref name) |\n+            Field(ref name) => Some(token::intern(name)),\n+\n+            Impl |\n+            CrateRoot |\n+            InlinedRoot(_) |\n+            Misc |\n+            ClosureExpr |\n+            StructCtor |\n+            Initializer |\n+            ImplTrait => None\n+        }\n+    }\n+\n     pub fn as_interned_str(&self) -> InternedString {\n         use self::DefPathData::*;\n         match *self {"}, {"sha": "b351bd427acbc26de10d8a477d7b10473b09ac9a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 30, "deletions": 99, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -22,17 +22,15 @@ use middle::cstore::InlinedItem as II;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n-use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n+use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n \n use hir::*;\n-use hir::fold::Folder;\n use hir::print as pprust;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n-use std::cmp;\n use std::io;\n use std::mem;\n \n@@ -240,7 +238,7 @@ impl<'ast> Map<'ast> {\n         let mut id = id0;\n         if !self.is_inlined_node_id(id) {\n             loop {\n-                match map[id as usize] {\n+                match map[id.as_usize()] {\n                     EntryItem(_, item) => {\n                         let def_id = self.local_def_id(item.id);\n                         // NB                          ^~~~~~~\n@@ -295,7 +293,7 @@ impl<'ast> Map<'ast> {\n             // reading from an inlined def-id is really a read out of\n             // the metadata from which we loaded the item.\n             loop {\n-                match map[id as usize] {\n+                match map[id.as_usize()] {\n                     EntryItem(p, _) |\n                     EntryForeignItem(p, _) |\n                     EntryTraitItem(p, _) |\n@@ -373,7 +371,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n-        self.map.borrow().get(id as usize).cloned()\n+        self.map.borrow().get(id.as_usize()).cloned()\n     }\n \n     pub fn krate(&self) -> &'ast Crate {\n@@ -456,8 +454,8 @@ impl<'ast> Map<'ast> {\n         let mut id = start_id;\n         loop {\n             let parent_node = self.get_parent_node(id);\n-            if parent_node == 0 {\n-                return Ok(0);\n+            if parent_node == CRATE_NODE_ID {\n+                return Ok(CRATE_NODE_ID);\n             }\n             if parent_node == id {\n                 return Err(id);\n@@ -582,22 +580,24 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_struct(&self, id: NodeId) -> &'ast VariantData {\n+    pub fn expect_variant_data(&self, id: NodeId) -> &'ast VariantData {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n-                    ItemStruct(ref struct_def, _) => struct_def,\n-                    _ => bug!(\"struct ID bound to non-struct\")\n+                    ItemStruct(ref struct_def, _) |\n+                    ItemUnion(ref struct_def, _) => struct_def,\n+                    _ => {\n+                        bug!(\"struct ID bound to non-struct {}\",\n+                             self.node_to_string(id));\n+                    }\n                 }\n             }\n-            Some(NodeVariant(variant)) => {\n-                if variant.node.data.is_struct() {\n-                    &variant.node.data\n-                } else {\n-                    bug!(\"struct ID bound to enum variant that isn't struct-like\")\n-                }\n+            Some(NodeStructCtor(data)) => data,\n+            Some(NodeVariant(variant)) => &variant.node.data,\n+            _ => {\n+                bug!(\"expected struct or variant, found {}\",\n+                     self.node_to_string(id));\n             }\n-            _ => bug!(\"expected struct, found {}\", self.node_to_string(id)),\n         }\n     }\n \n@@ -680,7 +680,7 @@ impl<'ast> Map<'ast> {\n             map: self,\n             item_name: parts.last().unwrap(),\n             in_which: &parts[..parts.len() - 1],\n-            idx: 0,\n+            idx: CRATE_NODE_ID,\n         }\n     }\n \n@@ -801,10 +801,10 @@ impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n     fn next(&mut self) -> Option<NodeId> {\n         loop {\n             let idx = self.idx;\n-            if idx as usize >= self.map.entry_count() {\n+            if idx.as_usize() >= self.map.entry_count() {\n                 return None;\n             }\n-            self.idx += 1;\n+            self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n             let name = match self.map.find_entry(idx) {\n                 Some(EntryItem(_, n))       => n.name(),\n                 Some(EntryForeignItem(_, n))=> n.name(),\n@@ -832,57 +832,6 @@ impl Named for Variant_ { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n-pub trait FoldOps {\n-    fn new_id(&self, id: NodeId) -> NodeId {\n-        id\n-    }\n-    fn new_def_id(&self, def_id: DefId) -> DefId {\n-        def_id\n-    }\n-    fn new_span(&self, span: Span) -> Span {\n-        span\n-    }\n-}\n-\n-/// A Folder that updates IDs and Span's according to fold_ops.\n-pub struct IdAndSpanUpdater<F> {\n-    fold_ops: F,\n-    min_id_assigned: NodeId,\n-    max_id_assigned: NodeId,\n-}\n-\n-impl<F: FoldOps> IdAndSpanUpdater<F> {\n-    pub fn new(fold_ops: F) -> IdAndSpanUpdater<F> {\n-        IdAndSpanUpdater {\n-            fold_ops: fold_ops,\n-            min_id_assigned: ::std::u32::MAX,\n-            max_id_assigned: ::std::u32::MIN,\n-        }\n-    }\n-\n-    pub fn id_range(&self) -> intravisit::IdRange {\n-        intravisit::IdRange {\n-            min: self.min_id_assigned,\n-            max: self.max_id_assigned + 1,\n-        }\n-    }\n-}\n-\n-impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n-    fn new_id(&mut self, id: NodeId) -> NodeId {\n-        let id = self.fold_ops.new_id(id);\n-\n-        self.min_id_assigned = cmp::min(self.min_id_assigned, id);\n-        self.max_id_assigned = cmp::max(self.max_id_assigned, id);\n-\n-        id\n-    }\n-\n-    fn new_span(&mut self, span: Span) -> Span {\n-        self.fold_ops.new_span(span)\n-    }\n-}\n-\n pub fn map_crate<'ast>(forest: &'ast mut Forest,\n                        definitions: Definitions)\n                        -> Map<'ast> {\n@@ -906,7 +855,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    let local_node_id_watermark = map.len() as NodeId;\n+    let local_node_id_watermark = NodeId::new(map.len());\n     let local_def_id_watermark = definitions.len();\n \n     Map {\n@@ -921,34 +870,15 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n \n /// Used for items loaded from external crate that are being inlined into this\n /// crate.\n-pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n-                                          parent_def_path: DefPath,\n-                                          parent_def_id: DefId,\n-                                          ii: InlinedItem,\n-                                          fold_ops: F)\n-                                          -> &'ast InlinedItem {\n-    let mut fld = IdAndSpanUpdater::new(fold_ops);\n-    let ii = match ii {\n-        II::Item(d, i) => II::Item(fld.fold_ops.new_def_id(d),\n-                                   i.map(|i| fld.fold_item(i))),\n-        II::TraitItem(d, ti) => {\n-            II::TraitItem(fld.fold_ops.new_def_id(d),\n-                          ti.map(|ti| fld.fold_trait_item(ti)))\n-        }\n-        II::ImplItem(d, ii) => {\n-            II::ImplItem(fld.fold_ops.new_def_id(d),\n-                         ii.map(|ii| fld.fold_impl_item(ii)))\n-        }\n-    };\n+pub fn map_decoded_item<'ast>(map: &Map<'ast>,\n+                              parent_def_path: DefPath,\n+                              parent_def_id: DefId,\n+                              ii: InlinedItem,\n+                              ii_parent_id: NodeId)\n+                              -> &'ast InlinedItem {\n+    let _ignore = map.forest.dep_graph.in_ignore();\n \n     let ii = map.forest.inlined_items.alloc(ii);\n-    let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n-\n-    // Assert that the ii_parent_id is the last NodeId in our reserved range\n-    assert!(ii_parent_id == fld.max_id_assigned);\n-    // Assert that we did not violate the invariant that all inlined HIR items\n-    // have NodeIds greater than or equal to `local_node_id_watermark`\n-    assert!(fld.min_id_assigned >= map.local_node_id_watermark);\n \n     let defs = &mut *map.definitions.borrow_mut();\n     let mut def_collector = DefCollector::extend(ii_parent_id,\n@@ -1030,6 +960,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 ItemTy(..) => \"ty\",\n                 ItemEnum(..) => \"enum\",\n                 ItemStruct(..) => \"struct\",\n+                ItemUnion(..) => \"union\",\n                 ItemTrait(..) => \"trait\",\n                 ItemImpl(..) => \"impl\",\n                 ItemDefaultImpl(..) => \"default impl\","}, {"sha": "0cfdbae1a50b0a53d7bd1f9e1392620dc45eb391", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -67,7 +67,6 @@ macro_rules! hir_vec {\n pub mod check_attr;\n pub mod def;\n pub mod def_id;\n-pub mod fold;\n pub mod intravisit;\n pub mod lowering;\n pub mod map;\n@@ -469,7 +468,7 @@ impl Pat {\n         }\n \n         match self.node {\n-            PatKind::Binding(_, _, Some(ref p)) => p.walk_(it),\n+            PatKind::Binding(.., Some(ref p)) => p.walk_(it),\n             PatKind::Struct(_, ref fields, _) => {\n                 fields.iter().all(|field| field.node.pat.walk_(it))\n             }\n@@ -486,7 +485,7 @@ impl Pat {\n             }\n             PatKind::Wild |\n             PatKind::Lit(_) |\n-            PatKind::Range(_, _) |\n+            PatKind::Range(..) |\n             PatKind::Binding(..) |\n             PatKind::Path(..) => {\n                 true\n@@ -1483,6 +1482,8 @@ pub enum Item_ {\n     ItemEnum(EnumDef, Generics),\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n     ItemStruct(VariantData, Generics),\n+    /// A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n+    ItemUnion(VariantData, Generics),\n     /// Represents a Trait Declaration\n     ItemTrait(Unsafety, Generics, TyParamBounds, HirVec<TraitItem>),\n \n@@ -1512,6 +1513,7 @@ impl Item_ {\n             ItemTy(..) => \"type alias\",\n             ItemEnum(..) => \"enum\",\n             ItemStruct(..) => \"struct\",\n+            ItemUnion(..) => \"union\",\n             ItemTrait(..) => \"trait\",\n             ItemImpl(..) |\n             ItemDefaultImpl(..) => \"item\","}, {"sha": "dec41fdfc3b50c35a4693339c61948d6488a3407", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -53,7 +53,7 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n \n pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::Path(Some(..), _) => true,\n+        PatKind::Lit(_) | PatKind::Range(..) | PatKind::Path(Some(..), _) => true,\n         PatKind::TupleStruct(..) |\n         PatKind::Path(..) |\n         PatKind::Struct(..) => {\n@@ -62,7 +62,7 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n                 _ => false\n             }\n         }\n-        PatKind::Vec(_, _, _) => true,\n+        PatKind::Vec(..) => true,\n         _ => false\n     }\n }\n@@ -174,7 +174,7 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n             PatKind::Path(..) |\n             PatKind::Struct(..) => {\n                 match dm.get(&p.id) {\n-                    Some(&PathResolution { base_def: Def::Variant(_, id), .. }) => {\n+                    Some(&PathResolution { base_def: Def::Variant(id), .. }) => {\n                         variants.push(id);\n                     }\n                     _ => ()"}, {"sha": "eebc8fa9e5d5dfd6aadc0cd48cca061f0e427418", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -752,7 +752,10 @@ impl<'a> State<'a> {\n                 self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n-\n+            hir::ItemUnion(ref struct_def, ref generics) => {\n+                self.head(&visibility_qualified(&item.vis, \"union\"))?;\n+                self.print_struct(struct_def, generics, item.name, item.span, true)?;\n+            }\n             hir::ItemDefaultImpl(unsafety, ref trait_ref) => {\n                 self.head(\"\")?;\n                 self.print_visibility(&item.vis)?;\n@@ -1753,9 +1756,9 @@ impl<'a> State<'a> {\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n                     }\n                 } else {\n-                    try!(self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p)));\n+                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n                 }\n-                try!(self.pclose());\n+                self.pclose()?;\n             }\n             PatKind::Path(None, ref path) => {\n                 self.print_path(path, true, 0)?;"}, {"sha": "2792968d427aa95d39b99bf2e6e2202bd6800153", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -105,6 +105,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             match item.node {\n                 hir::ItemImpl(..) => \"impl\",\n                 hir::ItemStruct(..) => \"struct\",\n+                hir::ItemUnion(..) => \"union\",\n                 hir::ItemEnum(..) => \"enum\",\n                 hir::ItemTrait(..) => \"trait\",\n                 hir::ItemFn(..) => \"function body\",\n@@ -139,9 +140,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     Some(ast_map::NodeExpr(expr)) => match expr.node {\n                         hir::ExprCall(..) => \"call\",\n                         hir::ExprMethodCall(..) => \"method call\",\n-                        hir::ExprMatch(_, _, hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                        hir::ExprMatch(_, _, hir::MatchSource::WhileLetDesugar) =>  \"while let\",\n-                        hir::ExprMatch(_, _, hir::MatchSource::ForLoopDesugar) =>  \"for\",\n+                        hir::ExprMatch(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+                        hir::ExprMatch(.., hir::MatchSource::WhileLetDesugar) =>  \"while let\",\n+                        hir::ExprMatch(.., hir::MatchSource::ForLoopDesugar) =>  \"for\",\n                         hir::ExprMatch(..) => \"match\",\n                         _ => \"expression\",\n                     },\n@@ -487,10 +488,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // if they are both \"path types\", there's a chance of ambiguity\n                 // due to different versions of the same crate\n                 match (&exp_found.expected.sty, &exp_found.found.sty) {\n-                    (&ty::TyEnum(ref exp_adt, _), &ty::TyEnum(ref found_adt, _)) |\n-                    (&ty::TyStruct(ref exp_adt, _), &ty::TyStruct(ref found_adt, _)) |\n-                    (&ty::TyEnum(ref exp_adt, _), &ty::TyStruct(ref found_adt, _)) |\n-                    (&ty::TyStruct(ref exp_adt, _), &ty::TyEnum(ref found_adt, _)) => {\n+                    (&ty::TyAdt(exp_adt, _), &ty::TyAdt(found_adt, _)) => {\n                         report_path_match(err, exp_adt.did, found_adt.did);\n                     },\n                     _ => ()\n@@ -549,7 +547,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if !is_simple_error {\n-                diag.note_expected_found(&\"type\", &expected, &found);\n+                if expected == found {\n+                    if let &TypeError::Sorts(ref values) = terr {\n+                        diag.note_expected_found_extra(\n+                            &\"type\", &expected, &found,\n+                            &format!(\" ({})\", values.expected.sort_string(self.tcx)),\n+                            &format!(\" ({})\", values.found.sort_string(self.tcx)));\n+                    } else {\n+                        diag.note_expected_found(&\"type\", &expected, &found);\n+                    }\n+                } else {\n+                    diag.note_expected_found(&\"type\", &expected, &found);\n+                }\n             }\n         }\n \n@@ -1370,7 +1379,8 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 }\n                 hir::TyPath(ref maybe_qself, ref path) => {\n                     match self.tcx.expect_def(cur_ty.id) {\n-                        Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n+                        Def::Enum(did) | Def::TyAlias(did) |\n+                        Def::Struct(did) | Def::Union(did) => {\n                             let generics = self.tcx.lookup_generics(did);\n \n                             let expected =\n@@ -1785,7 +1795,7 @@ fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     let method_id_opt = match tcx.map.find(parent) {\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n-                hir::ItemFn(_, _, _, _, ref gen, _) => {\n+                hir::ItemFn(.., ref gen, _) => {\n                     taken.extend_from_slice(&gen.lifetimes);\n                     None\n                 },\n@@ -1809,7 +1819,7 @@ fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         if let Some(node) = tcx.map.find(parent) {\n             match node {\n                 ast_map::NodeItem(item) => match item.node {\n-                    hir::ItemImpl(_, _, ref gen, _, _, _) => {\n+                    hir::ItemImpl(_, _, ref gen, ..) => {\n                         taken.extend_from_slice(&gen.lifetimes);\n                     }\n                     _ => ()"}, {"sha": "eea12b7f19712867b2ddbf3d750737a9f8b459fb", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyInt(..) |\n             ty::TyUint(..) |\n             ty::TyFloat(..) |\n-            ty::TyEnum(..) |\n+            ty::TyAdt(..) |\n             ty::TyBox(..) |\n             ty::TyStr |\n             ty::TyError |\n@@ -167,7 +167,6 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyFnDef(..) |\n             ty::TyFnPtr(_) |\n             ty::TyTrait(..) |\n-            ty::TyStruct(..) |\n             ty::TyClosure(..) |\n             ty::TyNever |\n             ty::TyTuple(..) |"}, {"sha": "7c02de05d26d5bb351ada05a6d02dd8302c37c62", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             debug!(\"higher_ranked_match: skol_map={:?}\", skol_map);\n \n             // Equate types now that bound regions have been replaced.\n-            try!(self.equate(a_is_expected).relate(&a_match, &b_match));\n+            self.equate(a_is_expected).relate(&a_match, &b_match)?;\n \n             // Map each skolemized region to a vector of other regions that it\n             // must be equated with. (Note that this vector may include other\n@@ -684,7 +684,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             warnings.extend(\n                                 match self.region_vars.var_origin(vid) {\n                                     LateBoundRegion(_,\n-                                                    ty::BrNamed(_, _, wc),\n+                                                    ty::BrNamed(.., wc),\n                                                     _) => Some(wc),\n                                     _ => None,\n                                 });"}, {"sha": "39fc50666a8ce73f1a7403131c61397b45317208", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 55, "deletions": 72, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -136,13 +136,6 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // avoid reporting the same error twice.\n     pub reported_trait_errors: RefCell<FnvHashSet<traits::TraitErrorKey<'tcx>>>,\n \n-    // This is a temporary field used for toggling on normalization in the inference context,\n-    // as we move towards the approach described here:\n-    // https://internals.rust-lang.org/t/flattening-the-contexts-for-fun-and-profit/2293\n-    // At a point sometime in the future normalization will be done by the typing context\n-    // directly.\n-    normalize: bool,\n-\n     // Sadly, the behavior of projection varies a bit depending on the\n     // stage of compilation. The specifics are given in the\n     // documentation for `Reveal`.\n@@ -232,7 +225,7 @@ impl TypeOrigin {\n             &TypeOrigin::RelateOutputImplTypes(_) |\n             &TypeOrigin::ExprAssignable(_) => \"mismatched types\",\n             &TypeOrigin::MethodCompatCheck(_) => \"method not compatible with trait\",\n-            &TypeOrigin::MatchExpressionArm(_, _, source) => match source {\n+            &TypeOrigin::MatchExpressionArm(.., source) => match source {\n                 hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n                 _ => \"match arms have incompatible types\",\n             },\n@@ -255,7 +248,7 @@ impl TypeOrigin {\n             &TypeOrigin::RelateOutputImplTypes(_) => {\n                 \"trait type parameters matches those specified on the impl\"\n             }\n-            &TypeOrigin::MatchExpressionArm(_, _, _) => \"match arms have compatible types\",\n+            &TypeOrigin::MatchExpressionArm(..) => \"match arms have compatible types\",\n             &TypeOrigin::IfExpression(_) => \"if and else have compatible types\",\n             &TypeOrigin::IfExpressionWithNoElse(_) => \"if missing an else returns ()\",\n             &TypeOrigin::RangeExpression(_) => \"start and end of range have compatible types\",\n@@ -458,7 +451,6 @@ pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tables: Option<RefCell<ty::Tables<'tcx>>>,\n     param_env: Option<ty::ParameterEnvironment<'gcx>>,\n     projection_mode: Reveal,\n-    normalize: bool\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n@@ -473,19 +465,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             tables: tables.map(RefCell::new),\n             param_env: param_env,\n             projection_mode: projection_mode,\n-            normalize: false\n-        }\n-    }\n-\n-    pub fn normalizing_infer_ctxt(self, projection_mode: Reveal)\n-                                  -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n-        InferCtxtBuilder {\n-            global_tcx: self,\n-            arenas: ty::CtxtArenas::new(),\n-            tables: None,\n-            param_env: None,\n-            projection_mode: projection_mode,\n-            normalize: false\n         }\n     }\n \n@@ -506,7 +485,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             reported_trait_errors: RefCell::new(FnvHashSet()),\n-            normalize: false,\n             projection_mode: Reveal::NotSpecializable,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n@@ -525,7 +503,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             ref tables,\n             ref mut param_env,\n             projection_mode,\n-            normalize\n         } = *self;\n         let tables = if let Some(ref tables) = *tables {\n             InferTables::Local(tables)\n@@ -547,7 +524,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             reported_trait_errors: RefCell::new(FnvHashSet()),\n-            normalize: normalize,\n             projection_mode: projection_mode,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n@@ -683,6 +659,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n     }\n \n+    /// Finishes processes any obligations that remain in the\n+    /// fulfillment context, and then returns the result with all type\n+    /// variables removed and regions erased. Because this is intended\n+    /// for use after type-check has completed, if any errors occur,\n+    /// it will panic. It is used during normalization and other cases\n+    /// where processing the obligations in `fulfill_cx` may cause\n+    /// type inference variables that appear in `result` to be\n+    /// unified, and hence we need to process those obligations to get\n+    /// the complete picture of the type.\n     pub fn drain_fulfillment_cx_or_panic<T>(&self,\n                                             span: Span,\n                                             fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n@@ -692,47 +677,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"drain_fulfillment_cx_or_panic()\");\n \n-        let when = \"resolving bounds after type-checking\";\n-        let v = match self.drain_fulfillment_cx(fulfill_cx, result) {\n-            Ok(v) => v,\n+        // In principle, we only need to do this so long as `result`\n+        // contains unbound type parameters. It could be a slight\n+        // optimization to stop iterating early.\n+        match fulfill_cx.select_all_or_error(self) {\n+            Ok(()) => { }\n             Err(errors) => {\n-                span_bug!(span, \"Encountered errors `{:?}` {}\", errors, when);\n+                span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n+                          errors);\n             }\n-        };\n+        }\n \n-        match self.tcx.lift_to_global(&v) {\n-            Some(v) => v,\n+        let result = self.resolve_type_vars_if_possible(result);\n+        let result = self.tcx.erase_regions(&result);\n+\n+        match self.tcx.lift_to_global(&result) {\n+            Some(result) => result,\n             None => {\n-                span_bug!(span, \"Uninferred types/regions in `{:?}` {}\", v, when);\n+                span_bug!(span, \"Uninferred types/regions in `{:?}`\", result);\n             }\n         }\n     }\n \n-    /// Finishes processes any obligations that remain in the fulfillment\n-    /// context, and then \"freshens\" and returns `result`. This is\n-    /// primarily used during normalization and other cases where\n-    /// processing the obligations in `fulfill_cx` may cause type\n-    /// inference variables that appear in `result` to be unified, and\n-    /// hence we need to process those obligations to get the complete\n-    /// picture of the type.\n-    pub fn drain_fulfillment_cx<T>(&self,\n-                                   fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                   result: &T)\n-                                   -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n-        where T : TypeFoldable<'tcx>\n-    {\n-        debug!(\"drain_fulfillment_cx(result={:?})\",\n-               result);\n-\n-        // In principle, we only need to do this so long as `result`\n-        // contains unbound type parameters. It could be a slight\n-        // optimization to stop iterating early.\n-        fulfill_cx.select_all_or_error(self)?;\n-\n-        let result = self.resolve_type_vars_if_possible(result);\n-        Ok(self.tcx.erase_regions(&result))\n-    }\n-\n     pub fn projection_mode(&self) -> Reveal {\n         self.projection_mode\n     }\n@@ -864,6 +830,33 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n+    // Clear the \"obligations in snapshot\" flag, invoke the closure,\n+    // then restore the flag to its original value. This flag is a\n+    // debugging measure designed to detect cases where we start a\n+    // snapshot, create type variables, register obligations involving\n+    // those type variables in the fulfillment cx, and then have to\n+    // unroll the snapshot, leaving \"dangling type variables\" behind.\n+    // In such cases, the flag will be set by the fulfillment cx, and\n+    // an assertion will fail when rolling the snapshot back.  Very\n+    // useful, much better than grovelling through megabytes of\n+    // RUST_LOG output.\n+    //\n+    // HOWEVER, in some cases the flag is wrong. In particular, we\n+    // sometimes create a \"mini-fulfilment-cx\" in which we enroll\n+    // obligations. As long as this fulfillment cx is fully drained\n+    // before we return, this is not a problem, as there won't be any\n+    // escaping obligations in the main cx. In those cases, you can\n+    // use this function.\n+    pub fn save_and_restore_obligations_in_snapshot_flag<F, R>(&self, func: F) -> R\n+        where F: FnOnce(&Self) -> R\n+    {\n+        let flag = self.obligations_in_snapshot.get();\n+        self.obligations_in_snapshot.set(false);\n+        let result = func(self);\n+        self.obligations_in_snapshot.set(flag);\n+        result\n+    }\n+\n     fn start_snapshot(&self) -> CombinedSnapshot {\n         debug!(\"start_snapshot()\");\n \n@@ -1702,17 +1695,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let closure_ty = self.tcx.closure_type(def_id, substs);\n-        if self.normalize {\n-            let closure_ty = self.tcx.erase_regions(&closure_ty);\n-\n-            if !closure_ty.has_projection_types() {\n-                return closure_ty;\n-            }\n-\n-            self.normalize_projections_in(&closure_ty)\n-        } else {\n-            closure_ty\n-        }\n+        closure_ty\n     }\n }\n \n@@ -1756,7 +1739,7 @@ impl TypeOrigin {\n             TypeOrigin::ExprAssignable(span) => span,\n             TypeOrigin::Misc(span) => span,\n             TypeOrigin::RelateOutputImplTypes(span) => span,\n-            TypeOrigin::MatchExpressionArm(match_span, _, _) => match_span,\n+            TypeOrigin::MatchExpressionArm(match_span, ..) => match_span,\n             TypeOrigin::IfExpression(span) => span,\n             TypeOrigin::IfExpressionWithNoElse(span) => span,\n             TypeOrigin::RangeExpression(span) => span,\n@@ -1809,7 +1792,7 @@ impl RegionVariableOrigin {\n             Autoref(a) => a,\n             Coercion(a) => a,\n             EarlyBoundRegion(a, _) => a,\n-            LateBoundRegion(a, _, _) => a,\n+            LateBoundRegion(a, ..) => a,\n             BoundRegionInCoherence(_) => syntax_pos::DUMMY_SP,\n             UpvarRegion(_, a) => a\n         }"}, {"sha": "289f7d6c7380088ba4a8bb6f25d346a864f4f284", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -63,9 +63,8 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n-    let requested_node: Option<ast::NodeId> = env::var(\"RUST_REGION_GRAPH_NODE\")\n-                                                  .ok()\n-                                                  .and_then(|s| s.parse().ok());\n+    let requested_node = env::var(\"RUST_REGION_GRAPH_NODE\")\n+        .ok().and_then(|s| s.parse().map(ast::NodeId::new).ok());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;"}, {"sha": "ef36ffa83192117e10a2435e79b378e479214e90", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -605,15 +605,15 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                                  undo_entry: &UndoLogEntry<'tcx>)\n                                  -> bool {\n             match undo_entry {\n-                &AddConstraint(ConstrainVarSubVar(_, _)) =>\n+                &AddConstraint(ConstrainVarSubVar(..)) =>\n                     false,\n                 &AddConstraint(ConstrainRegSubVar(a, _)) =>\n                     skols.contains(&a),\n                 &AddConstraint(ConstrainVarSubReg(_, b)) =>\n                     skols.contains(&b),\n                 &AddConstraint(ConstrainRegSubReg(a, b)) =>\n                     skols.contains(&a) || skols.contains(&b),\n-                &AddGiven(_, _) =>\n+                &AddGiven(..) =>\n                     false,\n                 &AddVerify(_) =>\n                     false,\n@@ -1372,7 +1372,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 (&ReFree(..), &ReFree(..)) => Equal,\n                 (&ReFree(..), _) => Less,\n                 (_, &ReFree(..)) => Greater,\n-                (_, _) => Equal,\n+                (..) => Equal,\n             }\n         }\n         lower_bounds.sort_by(|a, b| free_regions_first(a, b));"}, {"sha": "da9fd1cff2b46ea7da15a33bdf675a3c5b538f9c", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -267,7 +267,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                     debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n                 }\n \n-                sv::UndoLog::Other(SpecifyVar(vid, _, _)) => {\n+                sv::UndoLog::Other(SpecifyVar(vid, ..)) => {\n                     if vid.index < new_elem_threshold {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not."}, {"sha": "c34286f0195bfb61005beb5bdc676537932ae928", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -24,12 +24,14 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(associated_consts)]\n+#![feature(borrow_state)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n+#![feature(dotdot_in_tuple_patterns)]\n #![feature(enumset)]\n #![feature(libc)]\n #![feature(nonzero)]\n@@ -48,7 +50,6 @@ extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n-extern crate rbml;\n extern crate rustc_llvm as llvm;\n extern crate rustc_back;\n extern crate rustc_data_structures;"}, {"sha": "d378772e6557029985b0f825d0f0eae5aae17c1e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -114,7 +114,7 @@ declare_lint! {\n \n declare_lint! {\n     pub PRIVATE_IN_PUBLIC,\n-    Deny,\n+    Warn,\n     \"detect private items in public interfaces not caught by the old implementation\"\n }\n \n@@ -187,21 +187,15 @@ declare_lint! {\n }\n \n declare_lint! {\n-    pub UNSIZED_IN_TUPLE,\n-    Warn,\n-    \"unsized types in the interior of a tuple were erroneously allowed\"\n-}\n-\n-declare_lint! {\n-    pub OBJECT_UNSAFE_FRAGMENT,\n+    pub LIFETIME_UNDERSCORE,\n     Warn,\n-    \"object-unsafe non-principal fragments in object types were erroneously allowed\"\n+    \"lifetimes or labels named `'_` were erroneously allowed\"\n }\n \n declare_lint! {\n-    pub LIFETIME_UNDERSCORE,\n+    pub SAFE_EXTERN_STATICS,\n     Warn,\n-    \"lifetimes or labels named `'_` were erroneously allowed\"\n+    \"safe access to extern statics was erroneously allowed\"\n }\n \n /// Does nothing as a lint pass, but registers some `Lint`s\n@@ -239,10 +233,9 @@ impl LintPass for HardwiredLints {\n             OVERLAPPING_INHERENT_IMPLS,\n             RENAMED_AND_REMOVED_LINTS,\n             SUPER_OR_SELF_IN_GLOBAL_PATH,\n-            UNSIZED_IN_TUPLE,\n-            OBJECT_UNSAFE_FRAGMENT,\n             HR_LIFETIME_IN_ASSOC_TYPE,\n-            LIFETIME_UNDERSCORE\n+            LIFETIME_UNDERSCORE,\n+            SAFE_EXTERN_STATICS\n         )\n     }\n }"}, {"sha": "e57e116cea7407e2a48b9fe87cf334e6ed226a7d", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 86, "deletions": 303, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -23,30 +23,29 @@\n // probably get a better home if someone can find one.\n \n use hir::def::{self, Def};\n-use hir::def_id::{DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n use hir::map::definitions::DefKey;\n use hir::svh::Svh;\n use middle::lang_items;\n-use ty::{self, Ty, TyCtxt, VariantKind};\n+use ty::{self, Ty, TyCtxt};\n use mir::repr::Mir;\n use mir::mir_map::MirMap;\n use session::Session;\n use session::config::PanicStrategy;\n use session::search_paths::PathKind;\n-use util::nodemap::{FnvHashMap, NodeSet, DefIdMap};\n-use std::rc::Rc;\n+use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::base::LoadedMacro;\n use syntax::ptr::P;\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n use hir::intravisit::Visitor;\n \n-pub use self::DefLike::{DlDef, DlField, DlImpl};\n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n \n // lonely orphan structs and enums looking for a better home\n@@ -63,30 +62,20 @@ pub struct LinkMeta {\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n-    pub cnum: ast::CrateNum,\n+    pub cnum: CrateNum,\n }\n \n-#[derive(Copy, Debug, PartialEq, Clone)]\n+#[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,\n }\n \n-enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-    pub enum NativeLibraryKind {\n-        NativeStatic,    // native static library (.a archive)\n-        NativeFramework, // OSX-specific\n-        NativeUnknown,   // default way to specify a dynamic library\n-    }\n-}\n-\n-// Something that a name can resolve to.\n-#[derive(Copy, Clone, Debug)]\n-pub enum DefLike {\n-    DlDef(Def),\n-    DlImpl(DefId),\n-    DlField\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub enum NativeLibraryKind {\n+    NativeStatic,    // native static library (.a archive)\n+    NativeFramework, // OSX-specific\n+    NativeUnknown,   // default way to specify a dynamic library\n }\n \n /// The data we save and restore about an inlined item or method.  This is not\n@@ -100,24 +89,13 @@ pub enum InlinedItem {\n }\n \n /// A borrowed version of `hir::InlinedItem`.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n pub enum InlinedItemRef<'a> {\n     Item(DefId, &'a hir::Item),\n     TraitItem(DefId, &'a hir::TraitItem),\n     ImplItem(DefId, &'a hir::ImplItem)\n }\n \n-/// Item definitions in the currently-compiled crate would have the CrateNum\n-/// LOCAL_CRATE in their DefId.\n-pub const LOCAL_CRATE: ast::CrateNum = 0;\n-\n-#[derive(Copy, Clone)]\n-pub struct ChildItem {\n-    pub def: DefLike,\n-    pub name: ast::Name,\n-    pub vis: ty::Visibility,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct ExternCrate {\n     /// def_id of an `extern crate` in the current crate that caused\n@@ -143,47 +121,39 @@ pub struct ExternCrate {\n /// can be accessed.\n pub trait CrateStore<'tcx> {\n     // item info\n+    fn describe_def(&self, def: DefId) -> Option<Def>;\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind;\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>;\n     fn item_variances(&self, def: DefId) -> Vec<ty::Variance>;\n-    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n-    fn item_name(&self, def: DefId) -> ast::Name;\n-    fn opt_item_name(&self, def: DefId) -> Option<ast::Name>;\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>;\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>;\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> &'tcx ty::Generics<'tcx>;\n+                         -> ty::Generics<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n-    fn method_arg_names(&self, did: DefId) -> Vec<String>;\n+    fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n-    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>;\n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                  -> Vec<Rc<ty::Method<'tcx>>>;\n-    fn trait_item_def_ids(&self, def: DefId)\n-                          -> Vec<ty::ImplOrTraitItemId>;\n+    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>;\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>;\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>;\n-    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>;\n+    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>;\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                             -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n@@ -194,52 +164,46 @@ pub trait CrateStore<'tcx> {\n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n-    fn is_impl(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool;\n     fn is_foreign_item(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n-    fn is_typedef(&self, did: DefId) -> bool;\n \n     // crate metadata\n-    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n-                                    -> Vec<(ast::CrateNum, LinkagePreference)>;\n-    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>;\n-    fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>;\n-    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_allocator(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool;\n-    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy;\n-    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate>;\n-    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>;\n+    fn dylib_dependency_formats(&self, cnum: CrateNum)\n+                                    -> Vec<(CrateNum, LinkagePreference)>;\n+    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>;\n+    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>;\n+    fn is_staged_api(&self, cnum: CrateNum) -> bool;\n+    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool;\n+    fn is_allocator(&self, cnum: CrateNum) -> bool;\n+    fn is_panic_runtime(&self, cnum: CrateNum) -> bool;\n+    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool;\n+    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy;\n+    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>;\n     /// The name of the crate as it is referred to in source code of the current\n     /// crate.\n-    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString;\n+    fn crate_name(&self, cnum: CrateNum) -> InternedString;\n     /// The name of the crate as it is stored in the crate's metadata.\n-    fn original_crate_name(&self, cnum: ast::CrateNum) -> InternedString;\n-    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh;\n-    fn crate_disambiguator(&self, cnum: ast::CrateNum) -> InternedString;\n-    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n-                                -> FnvHashMap<DefId, Vec<ast::Attribute>>;\n-    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>;\n-    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>;\n-    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>;\n-    fn is_no_builtins(&self, cnum: ast::CrateNum) -> bool;\n+    fn original_crate_name(&self, cnum: CrateNum) -> InternedString;\n+    fn crate_hash(&self, cnum: CrateNum) -> Svh;\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> InternedString;\n+    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>;\n+    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>;\n+    fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n \n     // resolve\n     fn def_index_for_def_key(&self,\n-                             cnum: ast::CrateNum,\n+                             cnum: CrateNum,\n                              def: DefKey)\n                              -> Option<DefIndex>;\n     fn def_key(&self, def: DefId) -> hir_map::DefKey;\n-    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath;\n-    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind>;\n+    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n+    fn variant_kind(&self, def_id: DefId) -> Option<ty::VariantKind>;\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>;\n-    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n-    fn item_children(&self, did: DefId) -> Vec<ChildItem>;\n-    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>;\n+    fn item_children(&self, did: DefId) -> Vec<def::Export>;\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -253,27 +217,21 @@ pub trait CrateStore<'tcx> {\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n-    fn crates(&self) -> Vec<ast::CrateNum>;\n+    fn crates(&self) -> Vec<CrateNum>;\n     fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)>;\n     fn used_link_args(&self) -> Vec<String>;\n \n     // utility functions\n     fn metadata_filename(&self) -> &str;\n     fn metadata_section_name(&self, target: &Target) -> &str;\n-    fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n-                       -> Vec<u8>;\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>;\n-    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource;\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>;\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>;\n+    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>,\n-                           krate: &hir::Crate) -> Vec<u8>;\n+                           mir_map: &MirMap<'tcx>) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -322,59 +280,51 @@ pub struct DummyCrateStore;\n #[allow(unused_variables)]\n impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n+    fn describe_def(&self, def: DefId) -> Option<Def> { bug!(\"describe_def\") }\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n-    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind  { bug!(\"closure_kind\") }\n+    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind { bug!(\"closure_kind\") }\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n     fn item_variances(&self, def: DefId) -> Vec<ty::Variance> { bug!(\"item_variances\") }\n-    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx> { bug!(\"item_type\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n-    fn item_name(&self, def: DefId) -> ast::Name { bug!(\"item_name\") }\n-    fn opt_item_name(&self, def: DefId) -> Option<ast::Name> { bug!(\"opt_item_name\") }\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> &'tcx ty::Generics<'tcx> { bug!(\"item_generics\") }\n+                         -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n         { bug!(\"trait_def\") }\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n         { bug!(\"adt_def\") }\n-    fn method_arg_names(&self, did: DefId) -> Vec<String> { bug!(\"method_arg_names\") }\n+    fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n-    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                  -> Vec<Rc<ty::Method<'tcx>>> { bug!(\"provided_trait_methods\") }\n-    fn trait_item_def_ids(&self, def: DefId)\n-                          -> Vec<ty::ImplOrTraitItemId> { bug!(\"trait_item_def_ids\") }\n+    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n     fn def_index_for_def_key(&self,\n-                             cnum: ast::CrateNum,\n+                             cnum: CrateNum,\n                              def: DefKey)\n                              -> Option<DefIndex> {\n         None\n     }\n \n     // impl info\n-    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n-        { bug!(\"impl_items\") }\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>\n+        { bug!(\"impl_or_trait_items\") }\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n-    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity> { bug!(\"impl_polarity\") }\n+    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity { bug!(\"impl_polarity\") }\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n         { bug!(\"custom_coerce_unsized_kind\") }\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                             -> Vec<Rc<ty::AssociatedConst<'tcx>>> { bug!(\"associated_consts\") }\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n@@ -385,61 +335,53 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n     fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n-    fn is_impl(&self, did: DefId) -> bool { bug!(\"is_impl\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool\n         { bug!(\"is_extern_item\") }\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n-    fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }\n \n     // crate metadata\n-    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n-                                    -> Vec<(ast::CrateNum, LinkagePreference)>\n+    fn dylib_dependency_formats(&self, cnum: CrateNum)\n+                                    -> Vec<(CrateNum, LinkagePreference)>\n         { bug!(\"dylib_dependency_formats\") }\n-    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>\n+    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n         { bug!(\"lang_items\") }\n-    fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>\n+    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>\n         { bug!(\"missing_lang_items\") }\n-    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_staged_api\") }\n-    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n-    fn is_allocator(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_allocator\") }\n-    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n-    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy {\n+    fn is_staged_api(&self, cnum: CrateNum) -> bool { bug!(\"is_staged_api\") }\n+    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n+    fn is_allocator(&self, cnum: CrateNum) -> bool { bug!(\"is_allocator\") }\n+    fn is_panic_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n+    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n+    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n         bug!(\"panic_strategy\")\n     }\n-    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n-    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n-        { bug!(\"crate_attrs\") }\n-    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString { bug!(\"crate_name\") }\n-    fn original_crate_name(&self, cnum: ast::CrateNum) -> InternedString {\n+    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n+    fn crate_name(&self, cnum: CrateNum) -> InternedString { bug!(\"crate_name\") }\n+    fn original_crate_name(&self, cnum: CrateNum) -> InternedString {\n         bug!(\"original_crate_name\")\n     }\n-    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh { bug!(\"crate_hash\") }\n-    fn crate_disambiguator(&self, cnum: ast::CrateNum)\n+    fn crate_hash(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n+    fn crate_disambiguator(&self, cnum: CrateNum)\n                            -> InternedString { bug!(\"crate_disambiguator\") }\n-    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n-                                -> FnvHashMap<DefId, Vec<ast::Attribute>>\n-        { bug!(\"crate_struct_field_attrs\") }\n-    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n+    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n-    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>\n         { bug!(\"native_libraries\") }\n-    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n-    fn is_no_builtins(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_no_builtins\") }\n+    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n+    fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n \n     // resolve\n     fn def_key(&self, def: DefId) -> hir_map::DefKey { bug!(\"def_key\") }\n-    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath { bug!(\"relative_def_path\") }\n-    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> { bug!(\"variant_kind\") }\n+    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n+        bug!(\"relative_def_path\")\n+    }\n+    fn variant_kind(&self, def_id: DefId) -> Option<ty::VariantKind> { bug!(\"variant_kind\") }\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n         { bug!(\"struct_ctor_def_id\") }\n-    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n-        { bug!(\"tuple_struct_definition_if_ctor\") }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n-    fn item_children(&self, did: DefId) -> Vec<ChildItem> { bug!(\"item_children\") }\n-    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>\n-        { bug!(\"crate_top_level_items\") }\n+    fn item_children(&self, did: DefId) -> Vec<def::Export> { bug!(\"item_children\") }\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -461,184 +403,25 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n-    fn crates(&self) -> Vec<ast::CrateNum> { vec![] }\n+    fn crates(&self) -> Vec<CrateNum> { vec![] }\n     fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)> { vec![] }\n     fn used_link_args(&self) -> Vec<String> { vec![] }\n \n     // utility functions\n     fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n     fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n-    fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n-                       -> Vec<u8> {\n-        bug!(\"encode_type\")\n-    }\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n         { vec![] }\n-    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum> { None }\n+    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>,\n-                           krate: &hir::Crate) -> Vec<u8> { vec![] }\n+                           mir_map: &MirMap<'tcx>) -> Vec<u8> { vec![] }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n-\n-/// Metadata encoding and decoding can make use of thread-local encoding and\n-/// decoding contexts. These allow implementers of serialize::Encodable and\n-/// Decodable to access information and datastructures that would otherwise not\n-/// be available to them. For example, we can automatically translate def-id and\n-/// span information during decoding because the decoding context knows which\n-/// crate the data is decoded from. Or it allows to make ty::Ty decodable\n-/// because the context has access to the TyCtxt that is needed for creating\n-/// ty::Ty instances.\n-///\n-/// Note, however, that this only works for RBML-based encoding and decoding at\n-/// the moment.\n-pub mod tls {\n-    use rbml::opaque::Encoder as OpaqueEncoder;\n-    use rbml::opaque::Decoder as OpaqueDecoder;\n-    use serialize;\n-    use std::cell::Cell;\n-    use std::mem;\n-    use ty::{self, Ty, TyCtxt};\n-    use ty::subst::Substs;\n-    use hir::def_id::DefId;\n-\n-    pub trait EncodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-        fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: Ty<'tcx>);\n-        fn encode_substs(&self, encoder: &mut OpaqueEncoder, substs: &Substs<'tcx>);\n-    }\n-\n-    /// Marker type used for the TLS slot.\n-    /// The type context cannot be used directly because the TLS\n-    /// in libstd doesn't allow types generic over lifetimes.\n-    struct TlsPayload;\n-\n-    thread_local! {\n-        static TLS_ENCODING: Cell<Option<*const TlsPayload>> = Cell::new(None)\n-    }\n-\n-    /// Execute f after pushing the given EncodingContext onto the TLS stack.\n-    pub fn enter_encoding_context<'tcx, F, R>(ecx: &EncodingContext<'tcx>,\n-                                              encoder: &mut OpaqueEncoder,\n-                                              f: F) -> R\n-        where F: FnOnce(&EncodingContext<'tcx>, &mut OpaqueEncoder) -> R\n-    {\n-        let tls_payload = (ecx as *const _, encoder as *mut _);\n-        let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n-        TLS_ENCODING.with(|tls| {\n-            let prev = tls.get();\n-            tls.set(Some(tls_ptr));\n-            let ret = f(ecx, encoder);\n-            tls.set(prev);\n-            return ret\n-        })\n-    }\n-\n-    /// Execute f with access to the thread-local encoding context and\n-    /// rbml encoder. This function will panic if the encoder passed in and the\n-    /// context encoder are not the same.\n-    ///\n-    /// Note that this method is 'practically' safe due to its checking that the\n-    /// encoder passed in is the same as the one in TLS, but it would still be\n-    /// possible to construct cases where the EncodingContext is exchanged\n-    /// while the same encoder is used, thus working with a wrong context.\n-    pub fn with_encoding_context<'tcx, E, F, R>(encoder: &mut E, f: F) -> R\n-        where F: FnOnce(&EncodingContext<'tcx>, &mut OpaqueEncoder) -> R,\n-              E: serialize::Encoder\n-    {\n-        unsafe {\n-            unsafe_with_encoding_context(|ecx, tls_encoder| {\n-                assert!(encoder as *mut _ as usize == tls_encoder as *mut _ as usize);\n-\n-                let ecx: &EncodingContext<'tcx> = mem::transmute(ecx);\n-\n-                f(ecx, tls_encoder)\n-            })\n-        }\n-    }\n-\n-    /// Execute f with access to the thread-local encoding context and\n-    /// rbml encoder.\n-    pub unsafe fn unsafe_with_encoding_context<F, R>(f: F) -> R\n-        where F: FnOnce(&EncodingContext, &mut OpaqueEncoder) -> R\n-    {\n-        TLS_ENCODING.with(|tls| {\n-            let tls = tls.get().unwrap();\n-            let tls_payload = tls as *mut (&EncodingContext, &mut OpaqueEncoder);\n-            f((*tls_payload).0, (*tls_payload).1)\n-        })\n-    }\n-\n-    pub trait DecodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-        fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx>;\n-        fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> &'tcx Substs<'tcx>;\n-        fn translate_def_id(&self, def_id: DefId) -> DefId;\n-    }\n-\n-    thread_local! {\n-        static TLS_DECODING: Cell<Option<*const TlsPayload>> = Cell::new(None)\n-    }\n-\n-    /// Execute f after pushing the given DecodingContext onto the TLS stack.\n-    pub fn enter_decoding_context<'tcx, F, R>(dcx: &DecodingContext<'tcx>,\n-                                              decoder: &mut OpaqueDecoder,\n-                                              f: F) -> R\n-        where F: FnOnce(&DecodingContext<'tcx>, &mut OpaqueDecoder) -> R\n-    {\n-        let tls_payload = (dcx as *const _, decoder as *mut _);\n-        let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n-        TLS_DECODING.with(|tls| {\n-            let prev = tls.get();\n-            tls.set(Some(tls_ptr));\n-            let ret = f(dcx, decoder);\n-            tls.set(prev);\n-            return ret\n-        })\n-    }\n-\n-    /// Execute f with access to the thread-local decoding context and\n-    /// rbml decoder. This function will panic if the decoder passed in and the\n-    /// context decoder are not the same.\n-    ///\n-    /// Note that this method is 'practically' safe due to its checking that the\n-    /// decoder passed in is the same as the one in TLS, but it would still be\n-    /// possible to construct cases where the DecodingContext is exchanged\n-    /// while the same decoder is used, thus working with a wrong context.\n-    pub fn with_decoding_context<'decoder, 'tcx, D, F, R>(d: &'decoder mut D, f: F) -> R\n-        where D: serialize::Decoder,\n-              F: FnOnce(&DecodingContext<'tcx>,\n-                        &mut OpaqueDecoder) -> R,\n-              'tcx: 'decoder\n-    {\n-        unsafe {\n-            unsafe_with_decoding_context(|dcx, decoder| {\n-                assert!((d as *mut _ as usize) == (decoder as *mut _ as usize));\n-\n-                let dcx: &DecodingContext<'tcx> = mem::transmute(dcx);\n-\n-                f(dcx, decoder)\n-            })\n-        }\n-    }\n-\n-    /// Execute f with access to the thread-local decoding context and\n-    /// rbml decoder.\n-    pub unsafe fn unsafe_with_decoding_context<F, R>(f: F) -> R\n-        where F: FnOnce(&DecodingContext, &mut OpaqueDecoder) -> R\n-    {\n-        TLS_DECODING.with(|tls| {\n-            let tls = tls.get().unwrap();\n-            let tls_payload = tls as *mut (&DecodingContext, &mut OpaqueDecoder);\n-            f((*tls_payload).0, (*tls_payload).1)\n-        })\n-    }\n+pub trait MacroLoader {\n+     fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n }"}, {"sha": "7f3a58808c225edbf261871171935d1d2a88fcc7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -112,10 +112,10 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n         let id = match node {\n-            pprust::NodeName(_) => 0,\n+            pprust::NodeName(_) => ast::CRATE_NODE_ID,\n             pprust::NodeExpr(expr) => expr.id,\n             pprust::NodeBlock(blk) => blk.id,\n-            pprust::NodeItem(_) | pprust::NodeSubItem(_) => 0,\n+            pprust::NodeItem(_) | pprust::NodeSubItem(_) => ast::CRATE_NODE_ID,\n             pprust::NodePat(pat) => pat.id\n         };\n "}, {"sha": "30a0c6a9dc93963fd4e2f0473f73038791fb6892", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -86,20 +86,15 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn lookup_and_handle_definition(&mut self, id: ast::NodeId) {\n-        use ty::TypeVariants::{TyEnum, TyStruct};\n-\n         let def = self.tcx.expect_def(id);\n \n         // If `bar` is a trait item, make sure to mark Foo as alive in `Foo::bar`\n         match def {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n             if self.tcx.trait_of_item(def.def_id()).is_some() => {\n                 if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n-                    match substs.substs.type_at(0).sty {\n-                        TyEnum(tyid, _) | TyStruct(tyid, _) => {\n-                            self.check_def_id(tyid.did)\n-                        }\n-                        _ => {}\n+                    if let ty::TyAdt(tyid, _) = substs.substs.type_at(0).sty {\n+                        self.check_def_id(tyid.did);\n                     }\n                 }\n             }\n@@ -113,8 +108,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             _ if self.ignore_non_const_paths => (),\n             Def::PrimTy(_) => (),\n             Def::SelfTy(..) => (),\n-            Def::Variant(enum_id, variant_id) => {\n-                self.check_def_id(enum_id);\n+            Def::Variant(variant_id) => {\n+                if let Some(enum_id) = self.tcx.parent_def_id(variant_id) {\n+                    self.check_def_id(enum_id);\n+                }\n                 if !self.ignore_variant_stack.contains(&variant_id) {\n                     self.check_def_id(variant_id);\n                 }\n@@ -132,23 +129,28 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n-        if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n-            self.insert_def_id(def.struct_variant().field_named(name).did);\n-        } else {\n-            span_bug!(lhs.span, \"named field access on non-struct\")\n+        match self.tcx.expr_ty_adjusted(lhs).sty {\n+            ty::TyAdt(def, _) => {\n+                self.insert_def_id(def.struct_variant().field_named(name).did);\n+            }\n+            _ => span_bug!(lhs.span, \"named field access on non-ADT\"),\n         }\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n-        if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n-            self.insert_def_id(def.struct_variant().fields[idx].did);\n+        match self.tcx.expr_ty_adjusted(lhs).sty {\n+            ty::TyAdt(def, _) => {\n+                self.insert_def_id(def.struct_variant().fields[idx].did);\n+            }\n+            ty::TyTuple(..) => {}\n+            _ => span_bug!(lhs.span, \"numeric field access on non-ADT\"),\n         }\n     }\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n         let variant = match self.tcx.node_id_to_type(lhs.id).sty {\n-            ty::TyStruct(adt, _) | ty::TyEnum(adt, _) => {\n+            ty::TyAdt(adt, _) => {\n                 adt.variant_of_def(self.tcx.expect_def(lhs.id))\n             }\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n@@ -185,7 +187,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemStruct(..) => {\n+                    hir::ItemStruct(..) | hir::ItemUnion(..) => {\n                         self.struct_has_extern_repr = item.attrs.iter().any(|attr| {\n                             attr::find_repr_attrs(self.tcx.sess.diagnostic(), attr)\n                                 .contains(&attr::ReprExtern)\n@@ -343,7 +345,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n                 self.worklist.extend(enum_def.variants.iter()\n                                                       .map(|variant| variant.node.data.id()));\n             }\n-            hir::ItemTrait(_, _, _, ref trait_items) => {\n+            hir::ItemTrait(.., ref trait_items) => {\n                 for trait_item in trait_items {\n                     match trait_item.node {\n                         hir::ConstTraitItem(_, Some(_)) |\n@@ -356,7 +358,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n                     }\n                 }\n             }\n-            hir::ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n+            hir::ItemImpl(.., ref opt_trait, _, ref impl_items) => {\n                 for impl_item in impl_items {\n                     if opt_trait.is_some() ||\n                             has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n@@ -423,7 +425,8 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             | hir::ItemConst(..)\n             | hir::ItemFn(..)\n             | hir::ItemEnum(..)\n-            | hir::ItemStruct(..) => true,\n+            | hir::ItemStruct(..)\n+            | hir::ItemUnion(..) => true,\n             _ => false\n         };\n         let ctor_id = get_struct_ctor_id(item);\n@@ -469,13 +472,12 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let impl_items = self.tcx.impl_items.borrow();\n+        let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n         if let Some(impl_list) =\n                 self.tcx.inherent_impls.borrow().get(&self.tcx.map.local_def_id(id)) {\n             for impl_did in impl_list.iter() {\n-                for item_did in impl_items.get(impl_did).unwrap().iter() {\n-                    if let Some(item_node_id) =\n-                            self.tcx.map.as_local_node_id(item_did.def_id()) {\n+                for &item_did in &impl_items[impl_did][..] {\n+                    if let Some(item_node_id) = self.tcx.map.as_local_node_id(item_did) {\n                         if self.live_symbols.contains(&item_node_id) {\n                             return true;\n                         }\n@@ -546,7 +548,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     fn visit_struct_field(&mut self, field: &hir::StructField) {\n         if self.should_warn_about_field(&field) {\n             self.warn_dead_code(field.id, field.span,\n-                                field.name, \"struct field\");\n+                                field.name, \"field\");\n         }\n \n         intravisit::walk_struct_field(self, field);"}, {"sha": "c6908e11ed20950902468383b5437c203ff89769", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -61,7 +61,7 @@\n //! Additionally, the algorithm is geared towards finding *any* solution rather\n //! than finding a number of solutions (there are normally quite a few).\n \n-use syntax::ast;\n+use hir::def_id::CrateNum;\n \n use session;\n use session::config::{self, PanicStrategy};\n@@ -139,8 +139,13 @@ fn calculate_type(sess: &session::Session,\n             }\n         }\n \n-        // Everything else falls through below\n-        config::CrateTypeExecutable | config::CrateTypeDylib => {},\n+        // Everything else falls through below. This will happen either with the\n+        // `-C prefer-dynamic` or because we're a rustc-macro crate. Note that\n+        // rustc-macro crates are required to be dylibs, and they're currently\n+        // required to link to libsyntax as well.\n+        config::CrateTypeExecutable |\n+        config::CrateTypeDylib |\n+        config::CrateTypeRustcMacro => {},\n     }\n \n     let mut formats = FnvHashMap();\n@@ -164,9 +169,9 @@ fn calculate_type(sess: &session::Session,\n     }\n \n     // Collect what we've got so far in the return vector.\n-    let last_crate = sess.cstore.crates().len() as ast::CrateNum;\n+    let last_crate = sess.cstore.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        match formats.get(&cnum) {\n+        match formats.get(&CrateNum::new(cnum)) {\n             Some(&RequireDynamic) => Linkage::Dynamic,\n             Some(&RequireStatic) => Linkage::IncludedFromDylib,\n             None => Linkage::NotLinked,\n@@ -186,7 +191,7 @@ fn calculate_type(sess: &session::Session,\n             assert!(src.rlib.is_some());\n             info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n             add_library(sess, cnum, RequireStatic, &mut formats);\n-            ret[cnum as usize - 1] = Linkage::Static;\n+            ret[cnum.as_usize() - 1] = Linkage::Static;\n         }\n     }\n \n@@ -208,7 +213,7 @@ fn calculate_type(sess: &session::Session,\n     // For situations like this, we perform one last pass over the dependencies,\n     // making sure that everything is available in the requested format.\n     for (cnum, kind) in ret.iter().enumerate() {\n-        let cnum = (cnum + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(cnum + 1);\n         let src = sess.cstore.used_crate_source(cnum);\n         match *kind {\n             Linkage::NotLinked |\n@@ -232,9 +237,9 @@ fn calculate_type(sess: &session::Session,\n }\n \n fn add_library(sess: &session::Session,\n-               cnum: ast::CrateNum,\n+               cnum: CrateNum,\n                link: LinkagePreference,\n-               m: &mut FnvHashMap<ast::CrateNum, LinkagePreference>) {\n+               m: &mut FnvHashMap<CrateNum, LinkagePreference>) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library\n@@ -264,9 +269,9 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n \n     // All crates are available in an rlib format, so we're just going to link\n     // everything in explicitly so long as it's actually required.\n-    let last_crate = sess.cstore.crates().len() as ast::CrateNum;\n+    let last_crate = sess.cstore.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        if sess.cstore.is_explicitly_linked(cnum) {\n+        if sess.cstore.is_explicitly_linked(CrateNum::new(cnum)) {\n             Linkage::Static\n         } else {\n             Linkage::NotLinked\n@@ -293,11 +298,11 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n // a required dependency) in one of the session's field. If this field is not\n // set then this compilation doesn't actually need the dependency and we can\n // also skip this step entirely.\n-fn activate_injected_dep(injected: Option<ast::CrateNum>,\n+fn activate_injected_dep(injected: Option<CrateNum>,\n                          list: &mut DependencyList,\n-                         replaces_injected: &Fn(ast::CrateNum) -> bool) {\n+                         replaces_injected: &Fn(CrateNum) -> bool) {\n     for (i, slot) in list.iter().enumerate() {\n-        let cnum = (i + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(i + 1);\n         if !replaces_injected(cnum) {\n             continue\n         }\n@@ -306,7 +311,7 @@ fn activate_injected_dep(injected: Option<ast::CrateNum>,\n         }\n     }\n     if let Some(injected) = injected {\n-        let idx = injected as usize - 1;\n+        let idx = injected.as_usize() - 1;\n         assert_eq!(list[idx], Linkage::NotLinked);\n         list[idx] = Linkage::Static;\n     }\n@@ -324,7 +329,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n         if let Linkage::NotLinked = *linkage {\n             continue\n         }\n-        let cnum = (i + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(i + 1);\n         if sess.cstore.is_allocator(cnum) {\n             if let Some(prev) = allocator {\n                 let prev_name = sess.cstore.crate_name(prev);\n@@ -375,7 +380,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n             if desired_strategy == PanicStrategy::Abort {\n                 continue\n             }\n-            let cnum = (i + 1) as ast::CrateNum;\n+            let cnum = CrateNum::new(i + 1);\n             let found_strategy = sess.cstore.panic_strategy(cnum);\n             if desired_strategy == found_strategy {\n                 continue"}, {"sha": "2a75b6620fd618ff40579a8e2a5237958f686df0", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 59, "deletions": 17, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -13,15 +13,15 @@\n use self::RootUnsafeContext::*;\n \n use dep_graph::DepNode;\n-use hir::def::Def;\n use ty::{self, Ty, TyCtxt};\n use ty::MethodCall;\n+use lint;\n \n use syntax::ast;\n use syntax_pos::Span;\n-use hir;\n-use hir::intravisit;\n-use hir::intravisit::{FnKind, Visitor};\n+use hir::{self, PatKind};\n+use hir::def::Def;\n+use hir::intravisit::{self, FnKind, Visitor};\n \n #[derive(Copy, Clone)]\n struct UnsafeContext {\n@@ -44,7 +44,7 @@ enum RootUnsafeContext {\n \n fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty.sty {\n-        ty::TyFnDef(_, _, ref f) |\n+        ty::TyFnDef(.., ref f) |\n         ty::TyFnPtr(ref f) => f.unsafety == hir::Unsafety::Unsafe,\n         _ => false,\n     }\n@@ -58,16 +58,25 @@ struct EffectCheckVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n-    fn require_unsafe(&mut self, span: Span, description: &str) {\n+    fn require_unsafe_ext(&mut self, node_id: ast::NodeId, span: Span,\n+                          description: &str, is_lint: bool) {\n         if self.unsafe_context.push_unsafe_count > 0 { return; }\n         match self.unsafe_context.root {\n             SafeContext => {\n-                // Report an error.\n-                struct_span_err!(\n-                    self.tcx.sess, span, E0133,\n-                    \"{} requires unsafe function or block\", description)\n-                    .span_label(span, &description)\n-                    .emit();\n+                if is_lint {\n+                    self.tcx.sess.add_lint(lint::builtin::SAFE_EXTERN_STATICS,\n+                                           node_id,\n+                                           span,\n+                                           format!(\"{} requires unsafe function or \\\n+                                                    block (error E0133)\", description));\n+                } else {\n+                    // Report an error.\n+                    struct_span_err!(\n+                        self.tcx.sess, span, E0133,\n+                        \"{} requires unsafe function or block\", description)\n+                        .span_label(span, &description)\n+                        .emit();\n+                }\n             }\n             UnsafeBlock(block_id) => {\n                 // OK, but record this.\n@@ -77,16 +86,20 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n             UnsafeFn => {}\n         }\n     }\n+\n+    fn require_unsafe(&mut self, span: Span, description: &str) {\n+        self.require_unsafe_ext(ast::DUMMY_NODE_ID, span, description, false)\n+    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self, fn_kind: FnKind<'v>, fn_decl: &'v hir::FnDecl,\n                 block: &'v hir::Block, span: Span, id: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n-            FnKind::ItemFn(_, _, unsafety, _, _, _, _) =>\n+            FnKind::ItemFn(_, _, unsafety, ..) =>\n                 (true, unsafety == hir::Unsafety::Unsafe),\n-            FnKind::Method(_, sig, _, _) =>\n+            FnKind::Method(_, sig, ..) =>\n                 (true, sig.unsafety == hir::Unsafety::Unsafe),\n             _ => (false, false),\n         };\n@@ -144,7 +157,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            hir::ExprMethodCall(_, _, _) => {\n+            hir::ExprMethodCall(..) => {\n                 let method_call = MethodCall::expr(expr.id);\n                 let base_type = self.tcx.tables.borrow().method_map[&method_call].ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n@@ -174,15 +187,44 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n             hir::ExprPath(..) => {\n-                if let Def::Static(_, true) = self.tcx.expect_def(expr.id) {\n-                    self.require_unsafe(expr.span, \"use of mutable static\");\n+                if let Def::Static(def_id, mutbl) = self.tcx.expect_def(expr.id) {\n+                    if mutbl {\n+                        self.require_unsafe(expr.span, \"use of mutable static\");\n+                    } else if match self.tcx.map.get_if_local(def_id) {\n+                        Some(hir::map::NodeForeignItem(..)) => true,\n+                        Some(..) => false,\n+                        None => self.tcx.sess.cstore.is_foreign_item(def_id),\n+                    } {\n+                        self.require_unsafe_ext(expr.id, expr.span, \"use of extern static\", true);\n+                    }\n+                }\n+            }\n+            hir::ExprField(ref base_expr, field) => {\n+                if let ty::TyAdt(adt, ..) = self.tcx.expr_ty_adjusted(base_expr).sty {\n+                    if adt.is_union() {\n+                        self.require_unsafe(field.span, \"access to union field\");\n+                    }\n                 }\n             }\n             _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);\n     }\n+\n+    fn visit_pat(&mut self, pat: &hir::Pat) {\n+        if let PatKind::Struct(_, ref fields, _) = pat.node {\n+            if let ty::TyAdt(adt, ..) = self.tcx.pat_ty(pat).sty {\n+                if adt.is_union() {\n+                    for field in fields {\n+                        self.require_unsafe(field.span, \"matching on union field\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        intravisit::walk_pat(self, pat);\n+    }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {"}, {"sha": "5b5c3da8f05b2eae0334c60879f5a8d7e0f2933d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -409,12 +409,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_exprs(args);\n             }\n \n-            hir::ExprMethodCall(_, _, ref args) => { // callee.m(args)\n+            hir::ExprMethodCall(.., ref args) => { // callee.m(args)\n                 self.consume_exprs(args);\n             }\n \n             hir::ExprStruct(_, ref fields, ref opt_with) => {\n-                self.walk_struct_expr(expr, fields, opt_with);\n+                self.walk_struct_expr(fields, opt_with);\n             }\n \n             hir::ExprTup(ref exprs) => {\n@@ -544,7 +544,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_expr(&count);\n             }\n \n-            hir::ExprClosure(_, _, _, fn_decl_span) => {\n+            hir::ExprClosure(.., fn_decl_span) => {\n                 self.walk_captures(expr, fn_decl_span)\n             }\n \n@@ -655,7 +655,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn walk_struct_expr(&mut self,\n-                        _expr: &hir::Expr,\n                         fields: &[hir::Field],\n                         opt_with: &Option<P<hir::Expr>>) {\n         // Consume the expressions supplying values for each field.\n@@ -672,30 +671,33 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n-        if let ty::TyStruct(def, substs) = with_cmt.ty.sty {\n-            // Consume those fields of the with expression that are needed.\n-            for with_field in &def.struct_variant().fields {\n-                if !contains_field_named(with_field, fields) {\n-                    let cmt_field = self.mc.cat_field(\n-                        &*with_expr,\n-                        with_cmt.clone(),\n-                        with_field.name,\n-                        with_field.ty(self.tcx(), substs)\n-                    );\n-                    self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n+        match with_cmt.ty.sty {\n+            ty::TyAdt(adt, substs) if adt.is_struct() => {\n+                // Consume those fields of the with expression that are needed.\n+                for with_field in &adt.struct_variant().fields {\n+                    if !contains_field_named(with_field, fields) {\n+                        let cmt_field = self.mc.cat_field(\n+                            &*with_expr,\n+                            with_cmt.clone(),\n+                            with_field.name,\n+                            with_field.ty(self.tcx(), substs)\n+                        );\n+                        self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n+                    }\n                 }\n             }\n-        } else {\n-            // the base expression should always evaluate to a\n-            // struct; however, when EUV is run during typeck, it\n-            // may not. This will generate an error earlier in typeck,\n-            // so we can just ignore it.\n-            if !self.tcx().sess.has_errors() {\n-                span_bug!(\n-                    with_expr.span,\n-                    \"with expression doesn't evaluate to a struct\");\n+            _ => {\n+                // the base expression should always evaluate to a\n+                // struct; however, when EUV is run during typeck, it\n+                // may not. This will generate an error earlier in typeck,\n+                // so we can just ignore it.\n+                if !self.tcx().sess.has_errors() {\n+                    span_bug!(\n+                        with_expr.span,\n+                        \"with expression doesn't evaluate to a struct\");\n+                }\n             }\n-        };\n+        }\n \n         // walk the with expression so that complex expressions\n         // are properly handled.\n@@ -941,9 +943,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                pat);\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n             match pat.node {\n-                PatKind::Binding(hir::BindByRef(..), _, _) =>\n+                PatKind::Binding(hir::BindByRef(..), ..) =>\n                     mode.lub(BorrowingMatch),\n-                PatKind::Binding(hir::BindByValue(..), _, _) => {\n+                PatKind::Binding(hir::BindByValue(..), ..) => {\n                     match copy_or_move(self.mc.infcx, &cmt_pat, PatBindingMove) {\n                         Copy => mode.lub(CopyingMatch),\n                         Move(..) => mode.lub(MovingMatch),\n@@ -965,7 +967,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         let infcx = self.mc.infcx;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n-            if let PatKind::Binding(bmode, _, _) = pat.node {\n+            if let PatKind::Binding(bmode, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n@@ -1001,7 +1003,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             match tcx.expect_def_or_none(pat.id) {\n-                Some(Def::Variant(enum_did, variant_did)) => {\n+                Some(Def::Variant(variant_did)) => {\n+                    let enum_did = tcx.parent_def_id(variant_did).unwrap();\n                     let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n                         cmt_pat\n                     } else {\n@@ -1012,7 +1015,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n-                Some(Def::Struct(..)) | Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => {\n+                Some(Def::Struct(..)) | Some(Def::Union(..)) |\n+                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }\n@@ -1026,7 +1030,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n-                let id_var = freevar.def.var_id();\n+                let def_id = freevar.def.def_id();\n+                let id_var = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };\n                 let upvar_capture = self.mc.infcx.upvar_capture(upvar_id).unwrap();\n@@ -1058,7 +1063,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = upvar_def.var_id();\n+        let var_id = self.tcx().map.as_local_node_id(upvar_def.def_id()).unwrap();\n         let var_ty = self.mc.infcx.node_ty(var_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }"}, {"sha": "bd35bfc9829a5c08541a83d35585a706f7f873ce", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -55,7 +55,6 @@ impl FreeRegionMap {\n             match *predicate {\n                 ty::Predicate::Projection(..) |\n                 ty::Predicate::Trait(..) |\n-                ty::Predicate::Rfc1592(..) |\n                 ty::Predicate::Equate(..) |\n                 ty::Predicate::WellFormed(..) |\n                 ty::Predicate::ObjectSafe(..) |"}, {"sha": "61bcc05bbb4f4d25c6549cb285f17b42c26edc3f", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -52,7 +52,7 @@ struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match self.infcx.tcx.lookup_item_type(def_id).ty.sty {\n-            ty::TyFnDef(_, _, ref bfty) => bfty.abi == RustIntrinsic,\n+            ty::TyFnDef(.., ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n         intrinsic && self.infcx.tcx.item_name(def_id).as_str() == \"transmute\"\n@@ -160,7 +160,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n                 Def::Fn(did) if self.def_id_is_transmute(did) => {\n                     let typ = self.infcx.tcx.node_id_to_type(expr.id);\n                     match typ.sty {\n-                        ty::TyFnDef(_, _, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n+                        ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             let from = bare_fn_ty.sig.0.inputs[0];\n                             let to = bare_fn_ty.sig.0.output;\n                             self.check_transmute(expr.span, from, to, expr.id);"}, {"sha": "078cce9c49ff4410121b4893e48f31f0eb308fa3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -43,7 +43,7 @@ macro_rules! language_item_table {\n \n \n enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+    #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n     pub enum LangItem {\n         $($variant,)*\n     }"}, {"sha": "db9dd82d492d3193650fd464a0248bd63991511a", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -465,7 +465,8 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         let mut call_caps = Vec::new();\n         ir.tcx.with_freevars(expr.id, |freevars| {\n             for fv in freevars {\n-                if let Def::Local(_, rv) = fv.def {\n+                if let Def::Local(def_id) = fv.def {\n+                    let rv = ir.tcx.map.as_local_node_id(def_id).unwrap();\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                     call_caps.push(CaptureInfo {ln: fv_ln,\n                                                 var_nid: rv});\n@@ -482,7 +483,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n       }\n-      hir::ExprBinary(op, _, _) if op.node.is_lazy() => {\n+      hir::ExprBinary(op, ..) if op.node.is_lazy() => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n       }\n@@ -943,7 +944,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprClosure(_, _, ref blk, _) => {\n+          hir::ExprClosure(.., ref blk, _) => {\n               debug!(\"{} is an ExprClosure\",\n                      expr_to_string(expr));\n \n@@ -1123,7 +1124,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&f, succ)\n           }\n \n-          hir::ExprMethodCall(_, _, ref args) => {\n+          hir::ExprMethodCall(.., ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.tables.borrow().method_map[&method_call].ty;\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n@@ -1270,7 +1271,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n         match self.ir.tcx.expect_def(expr.id) {\n-          Def::Local(_, nid) => {\n+          Def::Local(def_id) => {\n+            let nid = self.ir.tcx.map.as_local_node_id(def_id).unwrap();\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n                 self.init_from_succ(ln, succ);\n@@ -1529,11 +1531,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n             hir::ExprPath(..) => {\n-                if let Def::Local(_, nid) = self.ir.tcx.expect_def(expr.id) {\n+                if let Def::Local(def_id) = self.ir.tcx.expect_def(expr.id) {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability\n                     // as being used.\n+                    let nid = self.ir.tcx.map.as_local_node_id(def_id).unwrap();\n                     let ln = self.live_node(expr.id, expr.span);\n                     let var = self.variable(nid, expr.span);\n                     self.warn_about_dead_assign(expr.span, expr.id, ln, var);"}, {"sha": "340a5ac8f87b73a03f6a06adb8360006ece44cfd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 47, "deletions": 103, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -67,7 +67,6 @@ pub use self::ElementKind::*;\n pub use self::MutabilityCategory::*;\n pub use self::AliasableReason::*;\n pub use self::Note::*;\n-pub use self::deref_kind::*;\n \n use self::Aliasability::*;\n \n@@ -195,52 +194,6 @@ pub struct cmt_<'tcx> {\n \n pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n-// We pun on *T to mean both actual deref of a ptr as well\n-// as accessing of components:\n-#[derive(Copy, Clone)]\n-pub enum deref_kind<'tcx> {\n-    deref_ptr(PointerKind<'tcx>),\n-    deref_interior(InteriorKind),\n-}\n-\n-type DerefKindContext = Option<InteriorOffsetKind>;\n-\n-// Categorizes a derefable type.  Note that we include vectors and strings as\n-// derefable (we model an index as the combination of a deref and then a\n-// pointer adjustment).\n-fn deref_kind(t: Ty, context: DerefKindContext) -> McResult<deref_kind> {\n-    match t.sty {\n-        ty::TyBox(_) => {\n-            Ok(deref_ptr(Unique))\n-        }\n-\n-        ty::TyRef(r, mt) => {\n-            let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n-            Ok(deref_ptr(BorrowedPtr(kind, r)))\n-        }\n-\n-        ty::TyRawPtr(ref mt) => {\n-            Ok(deref_ptr(UnsafePtr(mt.mutbl)))\n-        }\n-\n-        ty::TyEnum(..) |\n-        ty::TyStruct(..) => { // newtype\n-            Ok(deref_interior(InteriorField(PositionalField(0))))\n-        }\n-\n-        ty::TyArray(_, _) | ty::TySlice(_) => {\n-            // no deref of indexed content without supplying InteriorOffsetKind\n-            if let Some(context) = context {\n-                Ok(deref_interior(InteriorElement(context, ElementKind::VecElement)))\n-            } else {\n-                Err(())\n-            }\n-        }\n-\n-        _ => Err(()),\n-    }\n-}\n-\n pub trait ast_node {\n     fn id(&self) -> ast::NodeId;\n     fn span(&self) -> Span;\n@@ -318,7 +271,7 @@ impl MutabilityCategory {\n     fn from_local(tcx: TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) => match p.node {\n-                PatKind::Binding(bind_mode, _, _) => {\n+                PatKind::Binding(bind_mode, ..) => {\n                     if bind_mode == hir::BindByValue(hir::MutMutable) {\n                         McDeclared\n                     } else {\n@@ -419,7 +372,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // *being borrowed* is.  But ideally we would put in a more\n         // fundamental fix to this conflated use of the node id.\n         let ret_ty = match pat.node {\n-            PatKind::Binding(hir::BindByRef(_), _, _) => {\n+            PatKind::Binding(hir::BindByRef(_), ..) => {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n@@ -477,7 +430,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                autoderefs,\n                cmt);\n         for deref in 1..autoderefs + 1 {\n-            cmt = self.cat_deref(expr, cmt, deref, None)?;\n+            cmt = self.cat_deref(expr, cmt, deref)?;\n         }\n         return Ok(cmt);\n     }\n@@ -489,7 +442,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n             let base_cmt = self.cat_expr(&e_base)?;\n-            self.cat_deref(expr, base_cmt, 0, None)\n+            self.cat_deref(expr, base_cmt, 0)\n           }\n \n           hir::ExprField(ref base, f_name) => {\n@@ -508,7 +461,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n           hir::ExprIndex(ref base, _) => {\n             let method_call = ty::MethodCall::expr(expr.id());\n-            let context = InteriorOffsetKind::Index;\n             match self.infcx.node_method_ty(method_call) {\n                 Some(method_ty) => {\n                     // If this is an index implemented by a method call, then it\n@@ -530,10 +482,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     // is an rvalue. That is what we will be\n                     // dereferencing.\n                     let base_cmt = self.cat_rvalue_node(expr.id(), expr.span(), ret_ty);\n-                    self.cat_deref_common(expr, base_cmt, 1, elem_ty, Some(context), true)\n+                    Ok(self.cat_deref_common(expr, base_cmt, 1, elem_ty, true))\n                 }\n                 None => {\n-                    self.cat_index(expr, self.cat_expr(&base)?, context)\n+                    self.cat_index(expr, self.cat_expr(&base)?, InteriorOffsetKind::Index)\n                 }\n             }\n           }\n@@ -572,12 +524,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                id, expr_ty, def);\n \n         match def {\n-          Def::Struct(..) | Def::Variant(..) | Def::Const(..) |\n+          Def::Struct(..) | Def::Union(..) | Def::Variant(..) | Def::Const(..) |\n           Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n \n-          Def::Mod(_) | Def::ForeignMod(_) |\n+          Def::Mod(_) |\n           Def::Trait(_) | Def::Enum(..) | Def::TyAlias(..) | Def::PrimTy(_) |\n           Def::TyParam(..) |\n           Def::Label(_) | Def::SelfTy(..) |\n@@ -597,7 +549,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n               }))\n           }\n \n-          Def::Upvar(_, var_id, _, fn_node_id) => {\n+          Def::Upvar(def_id, _, fn_node_id) => {\n+              let var_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n               let ty = self.node_ty(fn_node_id)?;\n               match ty.sty {\n                   ty::TyClosure(closure_id, _) => {\n@@ -633,7 +586,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n               }\n           }\n \n-          Def::Local(_, vid) => {\n+          Def::Local(def_id) => {\n+            let vid = self.tcx().map.as_local_node_id(def_id).unwrap();\n             Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n@@ -761,7 +715,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n \n             match fn_expr.node {\n-                hir::ExprClosure(_, _, ref body, _) => body.id,\n+                hir::ExprClosure(.., ref body, _) => body.id,\n                 _ => bug!()\n             }\n         };\n@@ -908,8 +862,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt<'tcx>,\n-                             deref_cnt: usize,\n-                             deref_context: DerefKindContext)\n+                             deref_cnt: usize)\n                              -> McResult<cmt<'tcx>> {\n         let method_call = ty::MethodCall {\n             expr_id: node.id(),\n@@ -931,12 +884,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let base_cmt_ty = base_cmt.ty;\n         match base_cmt_ty.builtin_deref(true, ty::NoPreference) {\n             Some(mt) => {\n-                let ret = self.cat_deref_common(node, base_cmt, deref_cnt,\n-                                              mt.ty,\n-                                              deref_context,\n-                                                /* implicit: */ false);\n+                let ret = self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty, false);\n                 debug!(\"cat_deref ret {:?}\", ret);\n-                ret\n+                Ok(ret)\n             }\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {:?}\",\n@@ -951,40 +901,29 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                     base_cmt: cmt<'tcx>,\n                                     deref_cnt: usize,\n                                     deref_ty: Ty<'tcx>,\n-                                    deref_context: DerefKindContext,\n                                     implicit: bool)\n-                                    -> McResult<cmt<'tcx>>\n+                                    -> cmt<'tcx>\n     {\n-        let (m, cat) = match deref_kind(base_cmt.ty, deref_context)? {\n-            deref_ptr(ptr) => {\n-                let ptr = if implicit {\n-                    match ptr {\n-                        BorrowedPtr(bk, r) => Implicit(bk, r),\n-                        _ => span_bug!(node.span(),\n-                            \"Implicit deref of non-borrowed pointer\")\n-                    }\n-                } else {\n-                    ptr\n-                };\n-                // for unique ptrs, we inherit mutability from the\n-                // owning reference.\n-                (MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n-                 Categorization::Deref(base_cmt, deref_cnt, ptr))\n-            }\n-            deref_interior(interior) => {\n-                (base_cmt.mutbl.inherit(), Categorization::Interior(base_cmt, interior))\n+        let ptr = match base_cmt.ty.sty {\n+            ty::TyBox(..) => Unique,\n+            ty::TyRawPtr(ref mt) => UnsafePtr(mt.mutbl),\n+            ty::TyRef(r, mt) => {\n+                let bk = ty::BorrowKind::from_mutbl(mt.mutbl);\n+                if implicit { Implicit(bk, r) } else { BorrowedPtr(bk, r) }\n             }\n+            ref ty => bug!(\"unexpected type in cat_deref_common: {:?}\", ty)\n         };\n         let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat,\n-            mutbl: m,\n+            // For unique ptrs, we inherit mutability from the owning reference.\n+            mutbl: MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n+            cat: Categorization::Deref(base_cmt, deref_cnt, ptr),\n             ty: deref_ty,\n             note: NoteNone\n         });\n         debug!(\"cat_deref_common ret {:?}\", ret);\n-        Ok(ret)\n+        ret\n     }\n \n     pub fn cat_index<N:ast_node>(&self,\n@@ -1138,23 +1077,28 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // alone) because PatKind::Struct can also refer to variants.\n         let cmt = match self.tcx().expect_def_or_none(pat.id) {\n             Some(Def::Err) => return Err(()),\n-            Some(Def::Variant(enum_did, variant_did))\n+            Some(Def::Variant(variant_did)) => {\n                 // univariant enums do not need downcasts\n-                if !self.tcx().lookup_adt_def(enum_did).is_univariant() => {\n+                let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n+                if !self.tcx().lookup_adt_def(enum_did).is_univariant() {\n                     self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n+                } else {\n+                    cmt\n                 }\n+            }\n             _ => cmt\n         };\n \n         match pat.node {\n           PatKind::TupleStruct(_, ref subpats, ddpos) => {\n             let expected_len = match self.tcx().expect_def(pat.id) {\n-                Def::Variant(enum_def, def_id) => {\n+                Def::Variant(def_id) => {\n+                    let enum_def = self.tcx().parent_def_id(def_id).unwrap();\n                     self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()\n                 }\n                 Def::Struct(..) => {\n                     match self.pat_ty(&pat)?.sty {\n-                        ty::TyStruct(adt_def, _) => {\n+                        ty::TyAdt(adt_def, _) => {\n                             adt_def.struct_variant().fields.len()\n                         }\n                         ref ty => {\n@@ -1185,7 +1129,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          PatKind::Binding(_, _, Some(ref subpat)) => {\n+          PatKind::Binding(.., Some(ref subpat)) => {\n               self.cat_pattern_(cmt, &subpat, op)?;\n           }\n \n@@ -1207,7 +1151,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatKind::Ref since that information is already contained\n             // in the type.\n-            let subcmt = self.cat_deref(pat, cmt, 0, None)?;\n+            let subcmt = self.cat_deref(pat, cmt, 0)?;\n             self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n \n@@ -1225,7 +1169,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          PatKind::Path(..) | PatKind::Binding(_, _, None) |\n+          PatKind::Path(..) | PatKind::Binding(.., None) |\n           PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild => {\n             // always ok\n           }\n@@ -1275,9 +1219,9 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Rvalue(..) |\n             Categorization::StaticItem |\n             Categorization::Local(..) |\n-            Categorization::Deref(_, _, UnsafePtr(..)) |\n-            Categorization::Deref(_, _, BorrowedPtr(..)) |\n-            Categorization::Deref(_, _, Implicit(..)) |\n+            Categorization::Deref(.., UnsafePtr(..)) |\n+            Categorization::Deref(.., BorrowedPtr(..)) |\n+            Categorization::Deref(.., Implicit(..)) |\n             Categorization::Upvar(..) => {\n                 Rc::new((*self).clone())\n             }\n@@ -1320,7 +1264,7 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Rvalue(..) |\n             Categorization::Local(..) |\n             Categorization::Upvar(..) |\n-            Categorization::Deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n+            Categorization::Deref(.., UnsafePtr(..)) => { // yes, it's aliasable, but...\n                 NonAliasable\n             }\n \n@@ -1349,9 +1293,9 @@ impl<'tcx> cmt_<'tcx> {\n         match self.note {\n             NoteClosureEnv(..) | NoteUpvarRef(..) => {\n                 Some(match self.cat {\n-                    Categorization::Deref(ref inner, _, _) => {\n+                    Categorization::Deref(ref inner, ..) => {\n                         match inner.cat {\n-                            Categorization::Deref(ref inner, _, _) => inner.clone(),\n+                            Categorization::Deref(ref inner, ..) => inner.clone(),\n                             Categorization::Upvar(..) => inner.clone(),\n                             _ => bug!()\n                         }\n@@ -1379,7 +1323,7 @@ impl<'tcx> cmt_<'tcx> {\n                     \"local variable\".to_string()\n                 }\n             }\n-            Categorization::Deref(_, _, pk) => {\n+            Categorization::Deref(.., pk) => {\n                 let upvar = self.upvar();\n                 match upvar.as_ref().map(|i| &i.cat) {\n                     Some(&Categorization::Upvar(ref var)) => {"}, {"sha": "beffaff1e5b8a491f254593c2b080c28a070cb26", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -46,8 +46,8 @@ fn item_might_be_inlined(item: &hir::Item) -> bool {\n     }\n \n     match item.node {\n-        hir::ItemImpl(_, _, ref generics, _, _, _) |\n-        hir::ItemFn(_, _, _, _, ref generics, _) => {\n+        hir::ItemImpl(_, _, ref generics, ..) |\n+        hir::ItemFn(.., ref generics, _) => {\n             generics_require_inlining(generics)\n         }\n         _ => false,\n@@ -138,7 +138,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Creates a new reachability computation context.\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ReachableContext<'a, 'tcx> {\n         let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n-            *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib\n+            *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib ||\n+            *ty == config::CrateTypeRustcMacro\n         });\n         ReachableContext {\n             tcx: tcx,\n@@ -186,7 +187,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // does too.\n                             let impl_node_id = self.tcx.map.as_local_node_id(impl_did).unwrap();\n                             match self.tcx.map.expect_item(impl_node_id).node {\n-                                hir::ItemImpl(_, _, ref generics, _, _, _) => {\n+                                hir::ItemImpl(_, _, ref generics, ..) => {\n                                     generics_require_inlining(generics)\n                                 }\n                                 _ => false\n@@ -225,7 +226,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n             if let ast_map::NodeItem(item) = *node {\n-                let reachable = if let hir::ItemFn(_, _, _, abi, _, _) = item.node {\n+                let reachable = if let hir::ItemFn(.., abi, _, _) = item.node {\n                     abi != Abi::Rust\n                 } else {\n                     false\n@@ -247,7 +248,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemFn(_, _, _, _, _, ref search_block) => {\n+                    hir::ItemFn(.., ref search_block) => {\n                         if item_might_be_inlined(&item) {\n                             intravisit::walk_block(self, &search_block)\n                         }\n@@ -264,11 +265,11 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n                     hir::ItemExternCrate(_) | hir::ItemUse(_) |\n-                    hir::ItemTy(..) | hir::ItemStatic(_, _, _) |\n+                    hir::ItemTy(..) | hir::ItemStatic(..) |\n                     hir::ItemMod(..) | hir::ItemForeignMod(..) |\n                     hir::ItemImpl(..) | hir::ItemTrait(..) |\n                     hir::ItemStruct(..) | hir::ItemEnum(..) |\n-                    hir::ItemDefaultImpl(..) => {}\n+                    hir::ItemUnion(..) | hir::ItemDefaultImpl(..) => {}\n                 }\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n@@ -328,7 +329,7 @@ struct CollectPrivateImplItemsVisitor<'a> {\n impl<'a, 'v> Visitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemImpl(_, _, _, Some(_), _, ref impl_items) = item.node {\n+        if let hir::ItemImpl(.., Some(_), _, ref impl_items) = item.node {\n             if !self.access_levels.is_reachable(item.id) {\n                 for impl_item in impl_items {\n                     self.worklist.push(impl_item.id);"}, {"sha": "33110c61e8f8b1f0cf95c30f319c600f599a545d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -20,7 +20,6 @@ use dep_graph::DepNode;\n use hir::map as ast_map;\n use session::Session;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n-use middle::cstore::InlinedItem;\n use ty;\n \n use std::cell::RefCell;\n@@ -956,7 +955,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n     ///        | box P&\n     fn is_binding_pat(pat: &hir::Pat) -> bool {\n         match pat.node {\n-            PatKind::Binding(hir::BindByRef(_), _, _) => true,\n+            PatKind::Binding(hir::BindByRef(_), ..) => true,\n \n             PatKind::Struct(_, ref field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.node.pat))\n@@ -1256,19 +1255,3 @@ pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n     }\n     return maps;\n }\n-\n-pub fn resolve_inlined_item(sess: &Session,\n-                            region_maps: &RegionMaps,\n-                            item: &InlinedItem) {\n-    let mut visitor = RegionResolutionVisitor {\n-        sess: sess,\n-        region_maps: region_maps,\n-        cx: Context {\n-            root_id: None,\n-            parent: ROOT_CODE_EXTENT,\n-            var_parent: ROOT_CODE_EXTENT\n-        },\n-        terminating_scopes: NodeSet()\n-    };\n-    item.visit(&mut visitor);\n-}"}, {"sha": "2d93c33afb4095e743978841418b33b9ce65dc2b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -156,8 +156,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n                 hir::ItemTy(_, ref generics) |\n                 hir::ItemEnum(_, ref generics) |\n                 hir::ItemStruct(_, ref generics) |\n-                hir::ItemTrait(_, ref generics, _, _) |\n-                hir::ItemImpl(_, _, ref generics, _, _, _) => {\n+                hir::ItemUnion(_, ref generics) |\n+                hir::ItemTrait(_, ref generics, ..) |\n+                hir::ItemImpl(_, _, ref generics, ..) => {\n                     // These kinds of items have only early bound lifetime parameters.\n                     let lifetimes = &generics.lifetimes;\n                     let start = if let hir::ItemTrait(..) = item.node {\n@@ -203,12 +204,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n                 b: &'v hir::Block, s: Span, fn_id: ast::NodeId) {\n         match fk {\n-            FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n+            FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n                     this.add_scope_and_walk_fn(fk, decl, b, s, fn_id)\n                 })\n             }\n-            FnKind::Method(_, sig, _, _) => {\n+            FnKind::Method(_, sig, ..) => {\n                 self.visit_early_late(\n                     fn_id,\n                     decl,\n@@ -336,7 +337,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n \n         if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n             if self.trait_ref_hack {\n-                println!(\"{:?}\", trait_ref.span);\n                 span_err!(self.sess, trait_ref.span, E0316,\n                           \"nested quantification of lifetimes\");\n             }\n@@ -395,9 +395,9 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n                                         {} name that is already in scope\",\n                                        shadower.kind.desc(), name, orig.kind.desc()))\n     };\n-    err.span_note(orig.span,\n-                  &format!(\"shadowed {} `{}` declared here\",\n-                           orig.kind.desc(), name));\n+    err.span_label(orig.span, &\"first declared here\");\n+    err.span_label(shadower.span,\n+                   &format!(\"lifetime {} already in scope\", name));\n     err.emit();\n }\n \n@@ -454,7 +454,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n \n     fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n         match ex.node {\n-            hir::ExprWhile(_, _, Some(label)) |\n+            hir::ExprWhile(.., Some(label)) |\n             hir::ExprLoop(_, Some(label)) => Some((label.node, label.span)),\n             _ => None,\n         }\n@@ -498,11 +498,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                  fn_id: ast::NodeId) {\n \n         match fk {\n-            FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n+            FnKind::ItemFn(_, generics, ..) => {\n                 intravisit::walk_fn_decl(self, fd);\n                 self.visit_generics(generics);\n             }\n-            FnKind::Method(_, sig, _, _) => {\n+            FnKind::Method(_, sig, ..) => {\n                 intravisit::walk_fn_decl(self, fd);\n                 self.visit_generics(&sig.generics);\n             }\n@@ -582,8 +582,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 start += 1; // Self comes first.\n             }\n             match parent.node {\n-                hir::ItemTrait(_, ref generics, _, _) |\n-                hir::ItemImpl(_, _, ref generics, _, _, _) => {\n+                hir::ItemTrait(_, ref generics, ..) |\n+                hir::ItemImpl(_, _, ref generics, ..) => {\n                     start += generics.lifetimes.len() + generics.ty_params.len();\n                 }\n                 _ => {}"}, {"sha": "2c768db47f11a94661c000b9c99ae6167443fc3b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -17,10 +17,9 @@ use dep_graph::DepNode;\n use hir::map as hir_map;\n use session::Session;\n use lint;\n-use middle::cstore::LOCAL_CRATE;\n use hir::def::Def;\n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n-use ty::{self, TyCtxt};\n+use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n+use ty::{self, TyCtxt, AdtKind};\n use middle::privacy::AccessLevels;\n use syntax::parse::token::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -103,7 +102,7 @@ pub struct Index<'tcx> {\n     depr_map: DefIdMap<Option<DeprecationEntry>>,\n \n     /// Maps for each crate whether it is part of the staged API.\n-    staged_api: FnvHashMap<ast::CrateNum, bool>\n+    staged_api: FnvHashMap<CrateNum, bool>\n }\n \n // A private tree-walker for producing an Index.\n@@ -252,11 +251,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n-            hir::ItemImpl(_, _, _, None, _, _) | hir::ItemForeignMod(..) => {\n+            hir::ItemImpl(.., None, _, _) | hir::ItemForeignMod(..) => {\n                 self.in_trait_impl = false;\n                 kind = AnnotationKind::Container;\n             }\n-            hir::ItemImpl(_, _, _, Some(_), _, _) => {\n+            hir::ItemImpl(.., Some(_), _, _) => {\n                 self.in_trait_impl = true;\n             }\n             hir::ItemStruct(ref sd, _) => {\n@@ -528,7 +527,7 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // For implementations of traits, check the stability of each item\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n-        hir::ItemImpl(_, _, _, Some(ref t), _, ref impl_items) => {\n+        hir::ItemImpl(.., Some(ref t), _, ref impl_items) => {\n             let trait_did = tcx.expect_def(t.ref_id).def_id();\n             let trait_items = tcx.trait_items(trait_did);\n \n@@ -553,55 +552,56 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n                                            &Option<DeprecationEntry>)) {\n     let span;\n     let id = match e.node {\n-        hir::ExprMethodCall(i, _, _) => {\n+        hir::ExprMethodCall(i, ..) => {\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n             tcx.tables.borrow().method_map[&method_call].def_id\n         }\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(def, _) => def.struct_variant().field_named(field.node).did,\n+                ty::TyAdt(def, _) => {\n+                    def.struct_variant().field_named(field.node).did\n+                }\n                 _ => span_bug!(e.span,\n-                               \"stability::check_expr: named field access on non-struct\")\n+                               \"stability::check_expr: named field access on non-ADT\")\n             }\n         }\n         hir::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(def, _) => def.struct_variant().fields[field.node].did,\n+                ty::TyAdt(def, _) => {\n+                    def.struct_variant().fields[field.node].did\n+                }\n                 ty::TyTuple(..) => return,\n                 _ => span_bug!(e.span,\n                                \"stability::check_expr: unnamed field access on \\\n                                 something other than a tuple or struct\")\n             }\n         }\n         hir::ExprStruct(_, ref expr_fields, _) => {\n-            let type_ = tcx.expr_ty(e);\n-            match type_.sty {\n-                ty::TyStruct(def, _) => {\n-                    // check the stability of each field that appears\n-                    // in the construction expression.\n-                    for field in expr_fields {\n-                        let did = def.struct_variant()\n-                            .field_named(field.name.node)\n-                            .did;\n-                        maybe_do_stability_check(tcx, did, field.span, cb);\n-                    }\n+            match tcx.expr_ty(e).sty {\n+                ty::TyAdt(adt, ..) => match adt.adt_kind() {\n+                    AdtKind::Struct | AdtKind::Union => {\n+                        // check the stability of each field that appears\n+                        // in the construction expression.\n+                        for field in expr_fields {\n+                            let did = adt.struct_variant().field_named(field.name.node).did;\n+                            maybe_do_stability_check(tcx, did, field.span, cb);\n+                        }\n \n-                    // we're done.\n-                    return\n-                }\n-                // we don't look at stability attributes on\n-                // struct-like enums (yet...), but it's definitely not\n-                // a bug to have construct one.\n-                ty::TyEnum(..) => return,\n-                _ => {\n-                    span_bug!(e.span,\n-                              \"stability::check_expr: struct construction \\\n-                               of non-struct, type {:?}\",\n-                              type_);\n-                }\n+                        // we're done.\n+                        return\n+                    }\n+                    AdtKind::Enum => {\n+                        // we don't look at stability attributes on\n+                        // struct-like enums (yet...), but it's definitely not\n+                        // a bug to have construct one.\n+                        return\n+                    }\n+                },\n+                ref ty => span_bug!(e.span, \"stability::check_expr: struct \\\n+                                         construction of non-ADT type: {:?}\", ty)\n             }\n         }\n         _ => return\n@@ -646,9 +646,9 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    let v = match tcx.pat_ty_opt(pat) {\n-        Some(&ty::TyS { sty: ty::TyStruct(def, _), .. }) => def.struct_variant(),\n-        Some(_) | None => return,\n+    let v = match tcx.pat_ty_opt(pat).map(|ty| &ty.sty) {\n+        Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => adt.struct_variant(),\n+        _ => return,\n     };\n     match pat.node {\n         // Foo(a, b, c)\n@@ -695,10 +695,9 @@ fn is_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) -> bool {\n \n fn is_staged_api<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> bool {\n     match tcx.trait_item_of_item(id) {\n-        Some(ty::MethodTraitItemId(trait_method_id))\n-            if trait_method_id != id => {\n-                is_staged_api(tcx, trait_method_id)\n-            }\n+        Some(trait_method_id) if trait_method_id != id => {\n+            is_staged_api(tcx, trait_method_id)\n+        }\n         _ => {\n             *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n                 || tcx.sess.cstore.is_staged_api(id.krate))"}, {"sha": "c2f275e6deaf82671a27c49f4aad8e88b1bf43ad", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -70,6 +70,7 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n     let needs_check = sess.crate_types.borrow().iter().any(|kind| {\n         match *kind {\n             config::CrateTypeDylib |\n+            config::CrateTypeRustcMacro |\n             config::CrateTypeCdylib |\n             config::CrateTypeExecutable |\n             config::CrateTypeStaticlib => true,"}, {"sha": "6ad6251d584a9739e8309325600aeaa030c9649c", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 80, "deletions": 4, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -187,6 +187,32 @@ impl<'tcx> Mir<'tcx> {\n         self.var_decls.len() +\n         self.temp_decls.len() + 1\n     }\n+\n+    pub fn format_local(&self, local: Local) -> String {\n+        let mut index = local.index();\n+        index = match index.checked_sub(self.arg_decls.len()) {\n+            None => return format!(\"{:?}\", Arg::new(index)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(self.var_decls.len()) {\n+            None => return format!(\"{:?}\", Var::new(index)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(self.temp_decls.len()) {\n+            None => return format!(\"{:?}\", Temp::new(index)),\n+            Some(index) => index,\n+        };\n+        debug_assert!(index == 0);\n+        return \"ReturnPointer\".to_string()\n+    }\n+\n+    /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n+    /// invalidating statement indices in `Location`s.\n+    pub fn make_statement_nop(&mut self, location: Location) {\n+        let block = &mut self[location.block];\n+        debug_assert!(location.statement_index < block.statements.len());\n+        block.statements[location.statement_index].make_nop()\n+    }\n }\n \n impl<'tcx> Index<BasicBlock> for Mir<'tcx> {\n@@ -686,6 +712,14 @@ pub struct Statement<'tcx> {\n     pub kind: StatementKind<'tcx>,\n }\n \n+impl<'tcx> Statement<'tcx> {\n+    /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n+    /// invalidating statement indices in `Location`s.\n+    pub fn make_nop(&mut self) {\n+        self.kind = StatementKind::Nop\n+    }\n+}\n+\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Lvalue.\n@@ -699,6 +733,9 @@ pub enum StatementKind<'tcx> {\n \n     /// End the current live range for the storage of the local.\n     StorageDead(Lvalue<'tcx>),\n+\n+    /// No-op. Useful for deleting instructions without affecting statement indices.\n+    Nop,\n }\n \n impl<'tcx> Debug for Statement<'tcx> {\n@@ -711,6 +748,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n             SetDiscriminant{lvalue: ref lv, variant_index: index} => {\n                 write!(fmt, \"discriminant({:?}) = {:?}\", lv, index)\n             }\n+            Nop => write!(fmt, \"nop\"),\n         }\n     }\n }\n@@ -824,6 +862,24 @@ impl<'tcx> Lvalue<'tcx> {\n             elem: elem,\n         }))\n     }\n+\n+    pub fn from_local(mir: &Mir<'tcx>, local: Local) -> Lvalue<'tcx> {\n+        let mut index = local.index();\n+        index = match index.checked_sub(mir.arg_decls.len()) {\n+            None => return Lvalue::Arg(Arg(index as u32)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(mir.var_decls.len()) {\n+            None => return Lvalue::Var(Var(index as u32)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(mir.temp_decls.len()) {\n+            None => return Lvalue::Temp(Temp(index as u32)),\n+            Some(index) => index,\n+        };\n+        debug_assert!(index == 0);\n+        Lvalue::ReturnPointer\n+    }\n }\n \n impl<'tcx> Debug for Lvalue<'tcx> {\n@@ -962,7 +1018,10 @@ pub enum CastKind {\n pub enum AggregateKind<'tcx> {\n     Vec,\n     Tuple,\n-    Adt(AdtDef<'tcx>, usize, &'tcx Substs<'tcx>),\n+    /// The second field is variant number (discriminant), it's equal to 0\n+    /// for struct and union expressions. The fourth field is active field\n+    /// number and is present only for union expressions.\n+    Adt(AdtDef<'tcx>, usize, &'tcx Substs<'tcx>, Option<usize>),\n     Closure(DefId, ClosureSubsts<'tcx>),\n }\n \n@@ -1069,7 +1128,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         }\n                     }\n \n-                    Adt(adt_def, variant, substs) => {\n+                    Adt(adt_def, variant, substs, _) => {\n                         let variant_def = &adt_def.variants[variant];\n \n                         ppaux::parameterized(fmt, substs, variant_def.did,\n@@ -1095,7 +1154,9 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                             tcx.with_freevars(node_id, |freevars| {\n                                 for (freevar, lv) in freevars.iter().zip(lvs) {\n-                                    let var_name = tcx.local_var_name_str(freevar.def.var_id());\n+                                    let def_id = freevar.def.def_id();\n+                                    let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n+                                    let var_name = tcx.local_var_name_str(var_id);\n                                     struct_fmt.field(&var_name, lv);\n                                 }\n                             });\n@@ -1240,7 +1301,7 @@ impl<'a, 'b>  GraphSuccessors<'b> for Mir<'a> {\n     type Iter = IntoIter<BasicBlock>;\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, Ord, PartialOrd)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n pub struct Location {\n     /// the location is within this block\n     pub block: BasicBlock,\n@@ -1250,3 +1311,18 @@ pub struct Location {\n     pub statement_index: usize,\n }\n \n+impl fmt::Debug for Location {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}[{}]\", self.block, self.statement_index)\n+    }\n+}\n+\n+impl Location {\n+    pub fn dominates(&self, other: &Location, dominators: &Dominators<BasicBlock>) -> bool {\n+        if self.block == other.block {\n+            self.statement_index <= other.statement_index\n+        } else {\n+            dominators.is_dominated_by(other.block, self.block)\n+        }\n+    }\n+}"}, {"sha": "74ad6c602f6cdf47f3bd59bb96d07d29dab6a579", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n             LvalueTy::Ty { ty } =>\n                 ty,\n             LvalueTy::Downcast { adt_def, substs, variant_index: _ } =>\n-                tcx.mk_enum(adt_def, substs),\n+                tcx.mk_adt(adt_def, substs),\n         }\n     }\n \n@@ -75,15 +75,16 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n             }\n             ProjectionElem::Downcast(adt_def1, index) =>\n                 match self.to_ty(tcx).sty {\n-                    ty::TyEnum(adt_def, substs) => {\n+                    ty::TyAdt(adt_def, substs) => {\n+                        assert!(adt_def.is_enum());\n                         assert!(index < adt_def.variants.len());\n                         assert_eq!(adt_def, adt_def1);\n                         LvalueTy::Downcast { adt_def: adt_def,\n                                              substs: substs,\n                                              variant_index: index }\n                     }\n                     _ => {\n-                        bug!(\"cannot downcast non-enum type: `{:?}`\", self)\n+                        bug!(\"cannot downcast non-ADT type: `{:?}`\", self)\n                     }\n                 },\n             ProjectionElem::Field(_, fty) => LvalueTy::Ty { ty: fty }\n@@ -153,7 +154,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 ))\n             }\n             &Rvalue::Len(..) => Some(tcx.types.usize),\n-            &Rvalue::Cast(_, _, ty) => Some(ty),\n+            &Rvalue::Cast(.., ty) => Some(ty),\n             &Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs_ty = lhs.ty(mir, tcx);\n                 let rhs_ty = rhs.ty(mir, tcx);\n@@ -187,7 +188,7 @@ impl<'tcx> Rvalue<'tcx> {\n                             ops.iter().map(|op| op.ty(mir, tcx)).collect()\n                         ))\n                     }\n-                    AggregateKind::Adt(def, _, substs) => {\n+                    AggregateKind::Adt(def, _, substs, _) => {\n                         Some(tcx.lookup_item_type(def.did).ty.subst(tcx, substs))\n                     }\n                     AggregateKind::Closure(did, substs) => {"}, {"sha": "8cd5f5844d21c02e8f2b8a1fdd29165e46d6a8c9", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -15,7 +15,9 @@ use mir::mir_map::MirMap;\n use mir::repr::{Mir, Promoted};\n use ty::TyCtxt;\n use syntax::ast::NodeId;\n+use util::common::time;\n \n+use std::borrow::Cow;\n use std::fmt;\n \n /// Where a specific Mir comes from.\n@@ -72,12 +74,12 @@ impl<'a, 'tcx> MirSource {\n /// Various information about pass.\n pub trait Pass {\n     // fn should_run(Session) to check if pass should run?\n-    fn name(&self) -> &str {\n+    fn name<'a>(&self) -> Cow<'static, str> {\n         let name = unsafe { ::std::intrinsics::type_name::<Self>() };\n         if let Some(tail) = name.rfind(\":\") {\n-            &name[tail+1..]\n+            Cow::from(&name[tail+1..])\n         } else {\n-            name\n+            Cow::from(name)\n         }\n     }\n     fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> { None }\n@@ -162,11 +164,10 @@ impl<'a, 'tcx> Passes {\n     }\n \n     pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n-        for pass in &mut self.plugin_passes {\n-            pass.run_pass(tcx, map, &mut self.pass_hooks);\n-        }\n-        for pass in &mut self.passes {\n-            pass.run_pass(tcx, map, &mut self.pass_hooks);\n+        let Passes { ref mut passes, ref mut plugin_passes, ref mut pass_hooks } = *self;\n+        for pass in plugin_passes.iter_mut().chain(passes.iter_mut()) {\n+            time(tcx.sess.time_passes(), &*pass.name(),\n+                 || pass.run_pass(tcx, map, pass_hooks));\n         }\n     }\n "}, {"sha": "2c58d35973e73a2c6b7880875cf0824e10016ff4", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 106, "deletions": 9, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -150,7 +150,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_lvalue(&mut self,\n                             lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            context: LvalueContext,\n+                            context: LvalueContext<'tcx>,\n                             location: Location) {\n                 self.super_lvalue(lvalue, context, location);\n             }\n@@ -346,6 +346,7 @@ macro_rules! make_mir_visitor {\n                     StatementKind::StorageDead(ref $($mutability)* lvalue) => {\n                         self.visit_lvalue(lvalue, LvalueContext::StorageDead, location);\n                     }\n+                    StatementKind::Nop => {}\n                 }\n             }\n \n@@ -536,7 +537,8 @@ macro_rules! make_mir_visitor {\n                             }\n                             AggregateKind::Adt(_adt_def,\n                                                _variant_index,\n-                                               ref $($mutability)* substs) => {\n+                                               ref $($mutability)* substs,\n+                                               _active_field_index) => {\n                                 self.visit_substs(substs);\n                             }\n                             AggregateKind::Closure(ref $($mutability)* def_id,\n@@ -579,7 +581,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_lvalue(&mut self,\n                             lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            context: LvalueContext,\n+                            context: LvalueContext<'tcx>,\n                             location: Location) {\n                 match *lvalue {\n                     Lvalue::Var(_) |\n@@ -604,7 +606,12 @@ macro_rules! make_mir_visitor {\n                     ref $($mutability)* base,\n                     ref $($mutability)* elem,\n                 } = *proj;\n-                self.visit_lvalue(base, LvalueContext::Projection, location);\n+                let context = if context.is_mutating_use() {\n+                    LvalueContext::Projection(Mutability::Mut)\n+                } else {\n+                    LvalueContext::Projection(Mutability::Not)\n+                };\n+                self.visit_lvalue(base, context, location);\n                 self.visit_projection_elem(elem, context, location);\n             }\n \n@@ -749,6 +756,21 @@ macro_rules! make_mir_visitor {\n \n             fn super_const_usize(&mut self, _substs: & $($mutability)* ConstUsize) {\n             }\n+\n+            // Convenience methods\n+\n+            fn visit_location(&mut self, mir: & $($mutability)* Mir<'tcx>, location: Location) {\n+                let basic_block = & $($mutability)* mir[location.block];\n+                if basic_block.statements.len() == location.statement_index {\n+                    if let Some(ref $($mutability)* terminator) = basic_block.terminator {\n+                        self.visit_terminator(location.block, terminator, location)\n+                    }\n+                } else {\n+                    let statement = & $($mutability)*\n+                        basic_block.statements[location.statement_index];\n+                    self.visit_statement(location.block, statement, location)\n+                }\n+            }\n         }\n     }\n }\n@@ -773,11 +795,20 @@ pub enum LvalueContext<'tcx> {\n     // Being borrowed\n     Borrow { region: &'tcx Region, kind: BorrowKind },\n \n-    // Being sliced -- this should be same as being borrowed, probably\n-    Slice { from_start: usize, from_end: usize },\n-\n-    // Used as base for another lvalue, e.g. `x` in `x.y`\n-    Projection,\n+    // Used as base for another lvalue, e.g. `x` in `x.y`.\n+    //\n+    // The `Mutability` argument specifies whether the projection is being performed in order to\n+    // (potentially) mutate the lvalue. For example, the projection `x.y` is marked as a mutation\n+    // in these cases:\n+    //\n+    //     x.y = ...;\n+    //     f(&mut x.y);\n+    //\n+    // But not in these cases:\n+    //\n+    //     z = x.y;\n+    //     f(&x.y);\n+    Projection(Mutability),\n \n     // Consumed as part of an operand\n     Consume,\n@@ -786,3 +817,69 @@ pub enum LvalueContext<'tcx> {\n     StorageLive,\n     StorageDead,\n }\n+\n+impl<'tcx> LvalueContext<'tcx> {\n+    /// Returns true if this lvalue context represents a drop.\n+    pub fn is_drop(&self) -> bool {\n+        match *self {\n+            LvalueContext::Drop => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a storage live or storage dead marker.\n+    pub fn is_storage_marker(&self) -> bool {\n+        match *self {\n+            LvalueContext::StorageLive | LvalueContext::StorageDead => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a storage live marker.\n+    pub fn is_storage_live_marker(&self) -> bool {\n+        match *self {\n+            LvalueContext::StorageLive => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a storage dead marker.\n+    pub fn is_storage_dead_marker(&self) -> bool {\n+        match *self {\n+            LvalueContext::StorageDead => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a use that potentially changes the value.\n+    pub fn is_mutating_use(&self) -> bool {\n+        match *self {\n+            LvalueContext::Store | LvalueContext::Call |\n+            LvalueContext::Borrow { kind: BorrowKind::Mut, .. } |\n+            LvalueContext::Projection(Mutability::Mut) |\n+            LvalueContext::Drop => true,\n+            LvalueContext::Inspect |\n+            LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n+            LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n+            LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume |\n+            LvalueContext::StorageLive | LvalueContext::StorageDead => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a use that does not change the value.\n+    pub fn is_nonmutating_use(&self) -> bool {\n+        match *self {\n+            LvalueContext::Inspect | LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n+            LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n+            LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume => true,\n+            LvalueContext::Borrow { kind: BorrowKind::Mut, .. } | LvalueContext::Store |\n+            LvalueContext::Call | LvalueContext::Projection(Mutability::Mut) |\n+            LvalueContext::Drop | LvalueContext::StorageLive | LvalueContext::StorageDead => false,\n+        }\n+    }\n+\n+    pub fn is_use(&self) -> bool {\n+        self.is_mutating_use() || self.is_nonmutating_use()\n+    }\n+}\n+"}, {"sha": "8dd5d4d45f7a40e263319849fdd5f9c80de235f4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -475,6 +475,7 @@ pub enum CrateType {\n     CrateTypeRlib,\n     CrateTypeStaticlib,\n     CrateTypeCdylib,\n+    CrateTypeRustcMacro,\n }\n \n #[derive(Clone, Hash)]\n@@ -492,7 +493,7 @@ impl Passes {\n     }\n }\n \n-#[derive(Clone, PartialEq, Hash)]\n+#[derive(Clone, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub enum PanicStrategy {\n     Unwind,\n     Abort,\n@@ -848,9 +849,13 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     ls: bool = (false, parse_bool, [UNTRACKED],\n         \"list the symbols defined by a library crate\"),\n     save_analysis: bool = (false, parse_bool, [UNTRACKED],\n-        \"write syntax and type analysis (in JSON format) information in addition to normal output\"),\n+        \"write syntax and type analysis (in JSON format) information, in \\\n+         addition to normal output\"),\n     save_analysis_csv: bool = (false, parse_bool, [UNTRACKED],\n-        \"write syntax and type analysis (in CSV format) information in addition to normal output\"),\n+        \"write syntax and type analysis (in CSV format) information, in addition to normal output\"),\n+    save_analysis_api: bool = (false, parse_bool, [UNTRACKED],\n+        \"write syntax and type analysis information for opaque libraries (in JSON format), \\\n+         in addition to normal output\"),\n     print_move_fragments: bool = (false, parse_bool, [UNTRACKED],\n         \"print out move-fragment data for every fn\"),\n     flowgraph_print_loans: bool = (false, parse_bool, [UNTRACKED],\n@@ -908,6 +913,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"dump MIR state at various points in translation\"),\n     dump_mir_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"the directory the MIR is dumped into\"),\n+    perf_stats: bool = (false, parse_bool, [UNTRACKED],\n+          \"print some performance-related statistics\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -962,6 +969,9 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     if sess.opts.debug_assertions {\n         ret.push(attr::mk_word_item(InternedString::new(\"debug_assertions\")));\n     }\n+    if sess.opts.crate_types.contains(&CrateTypeRustcMacro) {\n+        ret.push(attr::mk_word_item(InternedString::new(\"rustc_macro\")));\n+    }\n     return ret;\n }\n \n@@ -1531,8 +1541,8 @@ pub fn get_unstable_features_setting() -> UnstableFeatures {\n     let bootstrap_provided_key = env::var(\"RUSTC_BOOTSTRAP_KEY\").ok();\n     match (disable_unstable_features, bootstrap_secret_key, bootstrap_provided_key) {\n         (_, Some(ref s), Some(ref p)) if s == p => UnstableFeatures::Cheat,\n-        (true, _, _) => UnstableFeatures::Disallow,\n-        (false, _, _) => UnstableFeatures::Allow\n+        (true, ..) => UnstableFeatures::Disallow,\n+        (false, ..) => UnstableFeatures::Allow\n     }\n }\n \n@@ -1547,6 +1557,7 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateTy\n                 \"dylib\"     => CrateTypeDylib,\n                 \"cdylib\"    => CrateTypeCdylib,\n                 \"bin\"       => CrateTypeExecutable,\n+                \"rustc-macro\" => CrateTypeRustcMacro,\n                 _ => {\n                     return Err(format!(\"unknown crate type: `{}`\",\n                                        part));\n@@ -1635,6 +1646,7 @@ impl fmt::Display for CrateType {\n             CrateTypeRlib => \"rlib\".fmt(f),\n             CrateTypeStaticlib => \"staticlib\".fmt(f),\n             CrateTypeCdylib => \"cdylib\".fmt(f),\n+            CrateTypeRustcMacro => \"rustc-macro\".fmt(f),\n         }\n     }\n }\n@@ -2359,6 +2371,8 @@ mod tests {\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.save_analysis_csv = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.save_analysis_api = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.print_move_fragments = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.flowgraph_print_loans = true;"}, {"sha": "268dbd70bb5bb2f8cd1bdde4a9c4e8bbd4efbbd2", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::DepGraph;\n-use hir::def_id::DefIndex;\n+use hir::def_id::{CrateNum, DefIndex};\n use hir::svh::Svh;\n use lint;\n use middle::cstore::CrateStore;\n@@ -18,9 +18,10 @@ use session::search_paths::PathKind;\n use session::config::{DebugInfoLevel, PanicStrategy};\n use ty::tls;\n use util::nodemap::{NodeMap, FnvHashMap};\n+use util::common::duration_to_secs_str;\n use mir::transform as mir_pass;\n \n-use syntax::ast::{NodeId, Name};\n+use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder};\n use errors::emitter::{Emitter, EmitterWriter};\n use syntax::json::JsonEmitter;\n@@ -38,11 +39,12 @@ use llvm;\n \n use std::path::{Path, PathBuf};\n use std::cell::{self, Cell, RefCell};\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::env;\n use std::ffi::CString;\n use std::rc::Rc;\n use std::fmt;\n+use std::time::Duration;\n use libc::c_int;\n \n pub mod config;\n@@ -62,6 +64,7 @@ pub struct Session {\n     pub entry_fn: RefCell<Option<(NodeId, Span)>>,\n     pub entry_type: Cell<Option<config::EntryFnType>>,\n     pub plugin_registrar_fn: Cell<Option<ast::NodeId>>,\n+    pub derive_registrar_fn: Cell<Option<ast::NodeId>>,\n     pub default_sysroot: Option<PathBuf>,\n     // The name of the root source file of the crate, in the local file system.\n     // The path is always expected to be absolute. `None` means that there is no\n@@ -90,12 +93,8 @@ pub struct Session {\n     /// The metadata::creader module may inject an allocator/panic_runtime\n     /// dependency if it didn't already find one, and this tracks what was\n     /// injected.\n-    pub injected_allocator: Cell<Option<ast::CrateNum>>,\n-    pub injected_panic_runtime: Cell<Option<ast::CrateNum>>,\n-\n-    /// Names of all bang-style macros and syntax extensions\n-    /// available in this crate\n-    pub available_macros: RefCell<HashSet<Name>>,\n+    pub injected_allocator: Cell<Option<CrateNum>>,\n+    pub injected_panic_runtime: Cell<Option<CrateNum>>,\n \n     /// Map from imported macro spans (which consist of\n     /// the localized span for the macro body) to the\n@@ -104,9 +103,23 @@ pub struct Session {\n \n     incr_comp_session: RefCell<IncrCompSession>,\n \n+    /// Some measurements that are being gathered during compilation.\n+    pub perf_stats: PerfStats,\n+\n     next_node_id: Cell<ast::NodeId>,\n }\n \n+pub struct PerfStats {\n+    // The accumulated time needed for computing the SVH of the crate\n+    pub svh_time: Cell<Duration>,\n+    // The accumulated time spent on computing incr. comp. hashes\n+    pub incr_comp_hashes_time: Cell<Duration>,\n+    // The number of incr. comp. hash computations performed\n+    pub incr_comp_hashes_count: Cell<u64>,\n+    // The accumulated time spent on computing symbol hashes\n+    pub symbol_hash_time: Cell<Duration>,\n+}\n+\n impl Session {\n     pub fn local_crate_disambiguator(&self) -> token::InternedString {\n         self.crate_disambiguator.borrow().clone()\n@@ -253,11 +266,13 @@ impl Session {\n         }\n         lints.insert(id, vec!((lint_id, sp, msg)));\n     }\n-    pub fn reserve_node_ids(&self, count: ast::NodeId) -> ast::NodeId {\n+    pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n         let id = self.next_node_id.get();\n \n-        match id.checked_add(count) {\n-            Some(next) => self.next_node_id.set(next),\n+        match id.as_usize().checked_add(count) {\n+            Some(next) => {\n+                self.next_node_id.set(ast::NodeId::new(next));\n+            }\n             None => bug!(\"Input too large, ran out of node ids!\")\n         }\n \n@@ -314,6 +329,12 @@ impl Session {\n         format!(\"__rustc_plugin_registrar__{}_{}\", svh, index.as_usize())\n     }\n \n+    pub fn generate_derive_registrar_symbol(&self,\n+                                            svh: &Svh,\n+                                            index: DefIndex) -> String {\n+        format!(\"__rustc_derive_registrar__{}_{}\", svh, index.as_usize())\n+    }\n+\n     pub fn sysroot<'a>(&'a self) -> &'a Path {\n         match self.opts.maybe_sysroot {\n             Some (ref sysroot) => sysroot,\n@@ -404,6 +425,17 @@ impl Session {\n             None\n         }\n     }\n+\n+    pub fn print_perf_stats(&self) {\n+        println!(\"Total time spent computing SVHs:               {}\",\n+                 duration_to_secs_str(self.perf_stats.svh_time.get()));\n+        println!(\"Total time spent computing incr. comp. hashes: {}\",\n+                 duration_to_secs_str(self.perf_stats.incr_comp_hashes_time.get()));\n+        println!(\"Total number of incr. comp. hashes computed:   {}\",\n+                 self.perf_stats.incr_comp_hashes_count.get());\n+        println!(\"Total time spent computing symbol hashes:      {}\",\n+                 duration_to_secs_str(self.perf_stats.symbol_hash_time.get()));\n+    }\n }\n \n pub fn build_session(sopts: config::Options,\n@@ -501,6 +533,7 @@ pub fn build_session_(sopts: config::Options,\n         entry_fn: RefCell::new(None),\n         entry_type: Cell::new(None),\n         plugin_registrar_fn: Cell::new(None),\n+        derive_registrar_fn: Cell::new(None),\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n         working_dir: env::current_dir().unwrap(),\n@@ -514,12 +547,17 @@ pub fn build_session_(sopts: config::Options,\n         crate_disambiguator: RefCell::new(token::intern(\"\").as_str()),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n-        next_node_id: Cell::new(1),\n+        next_node_id: Cell::new(NodeId::new(1)),\n         injected_allocator: Cell::new(None),\n         injected_panic_runtime: Cell::new(None),\n-        available_macros: RefCell::new(HashSet::new()),\n         imported_macro_spans: RefCell::new(HashMap::new()),\n         incr_comp_session: RefCell::new(IncrCompSession::NotInitialized),\n+        perf_stats: PerfStats {\n+            svh_time: Cell::new(Duration::from_secs(0)),\n+            incr_comp_hashes_time: Cell::new(Duration::from_secs(0)),\n+            incr_comp_hashes_count: Cell::new(0),\n+            symbol_hash_time: Cell::new(Duration::from_secs(0)),\n+        }\n     };\n \n     init_llvm(&sess);"}, {"sha": "68c88249ec0c36b29c3d061069f116dd438b6a53", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -12,8 +12,7 @@\n \n use super::{SelectionContext, Obligation, ObligationCause};\n \n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use infer::{InferCtxt, TypeOrigin};\n use syntax_pos::DUMMY_SP;\n@@ -224,7 +223,7 @@ fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     match ty.sty {\n         ty::TyBox(..) | ty::TyRef(..) =>\n             true,\n-        ty::TyEnum(def, _) | ty::TyStruct(def, _) =>\n+        ty::TyAdt(def, _) =>\n             def.is_fundamental(),\n         ty::TyTrait(ref data) =>\n             tcx.has_attr(data.principal.def_id(), \"fundamental\"),\n@@ -260,8 +259,7 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n             infer_is_local.0\n         }\n \n-        ty::TyEnum(def, _) |\n-        ty::TyStruct(def, _) => {\n+        ty::TyAdt(def, _) => {\n             def.did.is_local()\n         }\n "}, {"sha": "52ddd8ab5dac01f7dad1a7efd1ff6cab1191ed6e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 43, "deletions": 115, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -27,7 +27,7 @@ use super::{\n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n use infer::{self, InferCtxt, TypeOrigin};\n-use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n@@ -36,50 +36,37 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n use std::fmt;\n-use syntax::ast;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n pub struct TraitErrorKey<'tcx> {\n     span: Span,\n-    warning_node_id: Option<ast::NodeId>,\n     predicate: ty::Predicate<'tcx>\n }\n \n impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n     fn from_error(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                  e: &FulfillmentError<'tcx>,\n-                  warning_node_id: Option<ast::NodeId>) -> Self {\n+                  e: &FulfillmentError<'tcx>) -> Self {\n         let predicate =\n             infcx.resolve_type_vars_if_possible(&e.obligation.predicate);\n         TraitErrorKey {\n             span: e.obligation.cause.span,\n-            predicate: infcx.tcx.erase_regions(&predicate),\n-            warning_node_id: warning_node_id\n+            predicate: infcx.tcx.erase_regions(&predicate)\n         }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n         for error in errors {\n-            self.report_fulfillment_error(error, None);\n-        }\n-    }\n-\n-    pub fn report_fulfillment_errors_as_warnings(&self,\n-                                                 errors: &Vec<FulfillmentError<'tcx>>,\n-                                                 node_id: ast::NodeId) {\n-        for error in errors {\n-            self.report_fulfillment_error(error, Some(node_id));\n+            self.report_fulfillment_error(error);\n         }\n     }\n \n     fn report_fulfillment_error(&self,\n-                                error: &FulfillmentError<'tcx>,\n-                                warning_node_id: Option<ast::NodeId>) {\n-        let error_key = TraitErrorKey::from_error(self, error, warning_node_id);\n+                                error: &FulfillmentError<'tcx>) {\n+        let error_key = TraitErrorKey::from_error(self, error);\n         debug!(\"report_fulfillment_errors({:?}) - key={:?}\",\n                error, error_key);\n         if !self.reported_trait_errors.borrow_mut().insert(error_key) {\n@@ -88,10 +75,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n         match error.code {\n             FulfillmentErrorCode::CodeSelectionError(ref e) => {\n-                self.report_selection_error(&error.obligation, e, warning_node_id);\n+                self.report_selection_error(&error.obligation, e);\n             }\n             FulfillmentErrorCode::CodeProjectionError(ref e) => {\n-                self.report_projection_error(&error.obligation, e, warning_node_id);\n+                self.report_projection_error(&error.obligation, e);\n             }\n             FulfillmentErrorCode::CodeAmbiguity => {\n                 self.maybe_report_ambiguity(&error.obligation);\n@@ -101,25 +88,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn report_projection_error(&self,\n                                obligation: &PredicateObligation<'tcx>,\n-                               error: &MismatchedProjectionTypes<'tcx>,\n-                               warning_node_id: Option<ast::NodeId>)\n+                               error: &MismatchedProjectionTypes<'tcx>)\n     {\n         let predicate =\n             self.resolve_type_vars_if_possible(&obligation.predicate);\n \n         if predicate.references_error() {\n             return\n         }\n-        if let Some(warning_node_id) = warning_node_id {\n-            self.tcx.sess.add_lint(\n-                ::lint::builtin::UNSIZED_IN_TUPLE,\n-                warning_node_id,\n-                obligation.cause.span,\n-                format!(\"type mismatch resolving `{}`: {}\",\n-                        predicate,\n-                        error.err));\n-            return\n-        }\n+\n         self.probe(|_| {\n             let origin = TypeOrigin::Misc(obligation.cause.span);\n             let err_buf;\n@@ -174,30 +151,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyBool => Some(0),\n                 ty::TyChar => Some(1),\n                 ty::TyStr => Some(2),\n-                ty::TyInt(..) | ty::TyUint(..) |\n-                ty::TyInfer(ty::IntVar(..)) => Some(3),\n+                ty::TyInt(..) | ty::TyUint(..) | ty::TyInfer(ty::IntVar(..)) => Some(3),\n                 ty::TyFloat(..) | ty::TyInfer(ty::FloatVar(..)) => Some(4),\n-                ty::TyEnum(..) => Some(5),\n-                ty::TyStruct(..) => Some(6),\n-                ty::TyBox(..) | ty::TyRef(..) | ty::TyRawPtr(..) => Some(7),\n-                ty::TyArray(..) | ty::TySlice(..) => Some(8),\n-                ty::TyFnDef(..) | ty::TyFnPtr(..) => Some(9),\n-                ty::TyTrait(..) => Some(10),\n-                ty::TyClosure(..) => Some(11),\n-                ty::TyTuple(..) => Some(12),\n-                ty::TyProjection(..) => Some(13),\n-                ty::TyParam(..) => Some(14),\n-                ty::TyAnon(..) => Some(15),\n-                ty::TyNever => Some(16),\n+                ty::TyBox(..) | ty::TyRef(..) | ty::TyRawPtr(..) => Some(5),\n+                ty::TyArray(..) | ty::TySlice(..) => Some(6),\n+                ty::TyFnDef(..) | ty::TyFnPtr(..) => Some(7),\n+                ty::TyTrait(..) => Some(8),\n+                ty::TyClosure(..) => Some(9),\n+                ty::TyTuple(..) => Some(10),\n+                ty::TyProjection(..) => Some(11),\n+                ty::TyParam(..) => Some(12),\n+                ty::TyAnon(..) => Some(13),\n+                ty::TyNever => Some(14),\n+                ty::TyAdt(adt, ..) => match adt.adt_kind() {\n+                    AdtKind::Struct => Some(15),\n+                    AdtKind::Union => Some(16),\n+                    AdtKind::Enum => Some(17),\n+                },\n                 ty::TyInfer(..) | ty::TyError => None\n             }\n         }\n \n         match (type_category(a), type_category(b)) {\n             (Some(cat_a), Some(cat_b)) => match (&a.sty, &b.sty) {\n-                (&ty::TyStruct(def_a, _), &ty::TyStruct(def_b, _)) |\n-                (&ty::TyEnum(def_a, _), &ty::TyEnum(def_b, _)) =>\n-                    def_a == def_b,\n+                (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => def_a == def_b,\n                 _ => cat_a == cat_b\n             },\n             // infer and error can be equated to all types\n@@ -442,8 +419,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn report_selection_error(&self,\n                                   obligation: &PredicateObligation<'tcx>,\n-                                  error: &SelectionError<'tcx>,\n-                                  warning_node_id: Option<ast::NodeId>)\n+                                  error: &SelectionError<'tcx>)\n     {\n         let span = obligation.cause.span;\n         let mut err = match *error {\n@@ -466,16 +442,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             } else {\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n \n-                                if let Some(warning_node_id) = warning_node_id {\n-                                    self.tcx.sess.add_lint(\n-                                        ::lint::builtin::UNSIZED_IN_TUPLE,\n-                                        warning_node_id,\n-                                        obligation.cause.span,\n-                                        format!(\"the trait bound `{}` is not satisfied\",\n-                                                trait_ref.to_predicate()));\n-                                    return;\n-                                }\n-\n                                 let mut err = struct_span_err!(self.tcx.sess, span, E0277,\n                                     \"the trait bound `{}` is not satisfied\",\n                                     trait_ref.to_predicate());\n@@ -541,15 +507,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         ty::Predicate::ObjectSafe(trait_def_id) => {\n                             let violations = self.tcx.object_safety_violations(trait_def_id);\n-                            let err = self.tcx.report_object_safety_error(span,\n-                                                                          trait_def_id,\n-                                                                          warning_node_id,\n-                                                                          violations);\n-                            if let Some(err) = err {\n-                                err\n-                            } else {\n-                                return;\n-                            }\n+                            self.tcx.report_object_safety_error(span,\n+                                                                trait_def_id,\n+                                                                violations)\n                         }\n \n                         ty::Predicate::ClosureKind(closure_def_id, kind) => {\n@@ -577,13 +537,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // (which may fail).\n                             span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n                         }\n-\n-                        ty::Predicate::Rfc1592(ref data) => {\n-                            span_bug!(\n-                                obligation.cause.span,\n-                                \"RFC1592 predicate not satisfied for {:?}\",\n-                                data);\n-                        }\n                     }\n                 }\n             }\n@@ -605,14 +558,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             TraitNotObjectSafe(did) => {\n                 let violations = self.tcx.object_safety_violations(did);\n-                let err = self.tcx.report_object_safety_error(span, did,\n-                                                              warning_node_id,\n-                                                              violations);\n-                if let Some(err) = err {\n-                    err\n-                } else {\n-                    return;\n-                }\n+                self.tcx.report_object_safety_error(span, did,\n+                                                    violations)\n             }\n         };\n         self.note_obligation_cause(&mut err, obligation);\n@@ -640,24 +587,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_object_safety_error(self,\n                                       span: Span,\n                                       trait_def_id: DefId,\n-                                      warning_node_id: Option<ast::NodeId>,\n                                       violations: Vec<ObjectSafetyViolation>)\n-                                      -> Option<DiagnosticBuilder<'tcx>>\n+                                      -> DiagnosticBuilder<'tcx>\n     {\n-        let mut err = match warning_node_id {\n-            Some(_) => None,\n-            None => {\n-                let trait_str = self.item_path_str(trait_def_id);\n-                let mut db = struct_span_err!(\n-                            self.sess, span, E0038,\n-                            \"the trait `{}` cannot be made into an object\",\n-                            trait_str);\n-                db.span_label(span,\n-                              &format!(\"the trait `{}` cannot be made \\\n-                              into an object\", trait_str));\n-                Some(db)\n-            }\n-        };\n+        let trait_str = self.item_path_str(trait_def_id);\n+        let mut err = struct_span_err!(\n+            self.sess, span, E0038,\n+            \"the trait `{}` cannot be made into an object\",\n+            trait_str);\n+        err.span_label(span, &format!(\n+            \"the trait `{}` cannot be made into an object\", trait_str\n+        ));\n \n         let mut reported_violations = FnvHashSet();\n         for violation in violations {\n@@ -697,19 +637,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     &buf\n                 }\n             };\n-            match (warning_node_id, &mut err) {\n-                (Some(node_id), &mut None) => {\n-                    self.sess.add_lint(\n-                        ::lint::builtin::OBJECT_UNSAFE_FRAGMENT,\n-                        node_id,\n-                        span,\n-                        note.to_string());\n-                }\n-                (None, &mut Some(ref mut err)) => {\n-                    err.note(note);\n-                }\n-                _ => unreachable!()\n-            }\n+            err.note(note);\n         }\n         err\n     }"}, {"sha": "65860671c4c636c331fd87d56525a9489966b60a", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -57,9 +57,6 @@ pub struct FulfillmentContext<'tcx> {\n     // fulfillment context.\n     predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n \n-    // A list of new obligations due to RFC1592.\n-    rfc1592_obligations: Vec<PredicateObligation<'tcx>>,\n-\n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n     // outlive the lifetime 'a\". These constraints derive from\n@@ -192,7 +189,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n-            rfc1592_obligations: Vec::new(),\n             region_obligations: NodeMap(),\n             deferred_obligations: vec![],\n         }\n@@ -275,13 +271,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_rfc1592_obligation(&mut self,\n-                                       _infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                       obligation: PredicateObligation<'tcx>)\n-    {\n-        self.rfc1592_obligations.push(obligation);\n-    }\n-\n     pub fn region_obligations(&self,\n                               body_id: ast::NodeId)\n                               -> &[RegionObligation<'tcx>]\n@@ -292,21 +281,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn select_rfc1592_obligations(&mut self,\n-                                      infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n-    {\n-        while !self.rfc1592_obligations.is_empty() {\n-            for obligation in mem::replace(&mut self.rfc1592_obligations, Vec::new()) {\n-                self.register_predicate_obligation(infcx, obligation);\n-            }\n-\n-            self.select_all_or_error(infcx)?;\n-        }\n-\n-        Ok(())\n-    }\n-\n     pub fn select_all_or_error(&mut self,\n                                infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n                                -> Result<(),Vec<FulfillmentError<'tcx>>>\n@@ -362,7 +336,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n                 selcx: selcx,\n                 region_obligations: &mut self.region_obligations,\n-                rfc1592_obligations: &mut self.rfc1592_obligations,\n                 deferred_obligations: &mut self.deferred_obligations\n             });\n             debug!(\"select: outcome={:?}\", outcome);\n@@ -398,7 +371,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     region_obligations: &'a mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    rfc1592_obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n     deferred_obligations: &'a mut Vec<DeferredObligation<'tcx>>\n }\n \n@@ -413,7 +385,6 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n         process_predicate(self.selcx,\n                           obligation,\n                           self.region_obligations,\n-                          self.rfc1592_obligations,\n                           self.deferred_obligations)\n             .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n                 obligation: o,\n@@ -455,7 +426,6 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n     pending_obligation: &mut PendingPredicateObligation<'tcx>,\n     region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>,\n     deferred_obligations: &mut Vec<DeferredObligation<'tcx>>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n               FulfillmentErrorCode<'tcx>>\n@@ -644,14 +614,6 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                 s => Ok(s)\n             }\n         }\n-\n-        ty::Predicate::Rfc1592(ref inner) => {\n-            rfc1592_obligations.push(PredicateObligation {\n-                predicate: ty::Predicate::clone(inner),\n-                ..obligation.clone()\n-            });\n-            Ok(Some(vec![]))\n-        }\n     }\n }\n "}, {"sha": "7ba10d9c0a58e1140d35de18d2148993014a5191", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -40,7 +40,7 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::specialize::{OverlapError, specialization_graph, specializes, translate_substs};\n-pub use self::specialize::{SpecializesCache};\n+pub use self::specialize::{SpecializesCache, find_method};\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n@@ -527,6 +527,88 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     Ok(resolved_value)\n }\n \n+/// Normalizes the predicates and checks whether they hold.  If this\n+/// returns false, then either normalize encountered an error or one\n+/// of the predicates did not hold. Used when creating vtables to\n+/// check for unsatisfiable methods.\n+pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               predicates: Vec<ty::Predicate<'tcx>>)\n+                                               -> bool\n+{\n+    debug!(\"normalize_and_test_predicates(predicates={:?})\",\n+           predicates);\n+\n+    tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+        let mut selcx = SelectionContext::new(&infcx);\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let cause = ObligationCause::dummy();\n+        let Normalized { value: predicates, obligations } =\n+            normalize(&mut selcx, cause.clone(), &predicates);\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n+        for predicate in predicates {\n+            let obligation = Obligation::new(cause.clone(), predicate);\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n+\n+        fulfill_cx.select_all_or_error(&infcx).is_ok()\n+    })\n+}\n+\n+/// Given a trait `trait_ref`, iterates the vtable entries\n+/// that come from `trait_ref`, including its supertraits.\n+#[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+pub fn get_vtable_methods<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>)\n+    -> impl Iterator<Item=Option<(DefId, &'tcx Substs<'tcx>)>> + 'a\n+{\n+    debug!(\"get_vtable_methods({:?})\", trait_ref);\n+\n+    supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n+        tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n+\n+        let trait_item_def_ids = tcx.impl_or_trait_items(trait_ref.def_id());\n+        let trait_methods = (0..trait_item_def_ids.len()).filter_map(move |i| {\n+            match tcx.impl_or_trait_item(trait_item_def_ids[i]) {\n+                ty::MethodTraitItem(m) => Some(m),\n+                _ => None\n+            }\n+        });\n+\n+        // Now list each method's DefId and Substs (for within its trait).\n+        // If the method can never be called from this object, produce None.\n+        trait_methods.map(move |trait_method| {\n+            debug!(\"get_vtable_methods: trait_method={:?}\", trait_method);\n+\n+            // Some methods cannot be called on an object; skip those.\n+            if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n+                debug!(\"get_vtable_methods: not vtable safe\");\n+                return None;\n+            }\n+\n+            // the method may have some early-bound lifetimes, add\n+            // regions for those\n+            let substs = Substs::for_item(tcx, trait_method.def_id,\n+                                            |_, _| tcx.mk_region(ty::ReErased),\n+                                            |def, _| trait_ref.substs().type_for_def(def));\n+\n+            // It's possible that the method relies on where clauses that\n+            // do not hold for this particular set of type parameters.\n+            // Note that this method could then never be called, so we\n+            // do not want to try and trans it, in that case (see #23435).\n+            let predicates = trait_method.predicates.instantiate_own(tcx, substs);\n+            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n+                debug!(\"get_vtable_methods: predicates do not hold\");\n+                return None;\n+            }\n+\n+            Some((trait_method.def_id, substs))\n+        })\n+    })\n+}\n+\n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                trait_ref: O)\n@@ -571,7 +653,7 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n \n     pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, body_id: 0, code: MiscObligation }\n+        ObligationCause { span: DUMMY_SP, body_id: ast::CRATE_NODE_ID, code: MiscObligation }\n     }\n }\n "}, {"sha": "5f7b71518291a1f932729f690d1975ea9c4c5a37", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -153,7 +153,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::TypeOutlives(..) |\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::Rfc1592(..) |\n                     ty::Predicate::Equate(..) => {\n                         false\n                     }\n@@ -184,7 +183,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::Trait(..) |\n-                    ty::Predicate::Rfc1592(..) |\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::WellFormed(..) |"}, {"sha": "9d7131dc96cc5c31bedf67f55e5e4548288b4b01", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -513,8 +513,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         match obligation.predicate {\n-            ty::Predicate::Rfc1592(..) => EvaluatedToOk,\n-\n             ty::Predicate::Trait(ref t) => {\n                 assert!(!t.has_escaping_regions());\n                 let obligation = obligation.with(t.clone());\n@@ -816,7 +814,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn filter_negative_impls(&self, candidate: SelectionCandidate<'tcx>)\n                              -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n         if let ImplCandidate(def_id) = candidate {\n-            if self.tcx().trait_impl_polarity(def_id) == Some(hir::ImplPolarity::Negative) {\n+            if self.tcx().trait_impl_polarity(def_id) == hir::ImplPolarity::Negative {\n                 return Err(Unimplemented)\n             }\n         }\n@@ -1381,7 +1379,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::TyFnDef(_, _, &ty::BareFnTy {\n+            ty::TyFnDef(.., &ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -1637,10 +1635,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // [T; n] -> [T].\n-            (&ty::TyArray(_, _), &ty::TySlice(_)) => true,\n+            (&ty::TyArray(..), &ty::TySlice(_)) => true,\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::TyStruct(def_id_a, _), &ty::TyStruct(def_id_b, _)) => {\n+            (&ty::TyAdt(def_id_a, _), &ty::TyAdt(def_id_b, _)) if def_id_a.is_struct() => {\n                 def_id_a == def_id_b\n             }\n \n@@ -1779,11 +1777,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyStr | ty::TySlice(_) | ty::TyTrait(..) => Never,\n \n             ty::TyTuple(tys) => {\n-                // FIXME(#33242) we only need to constrain the last field\n-                Where(ty::Binder(tys.to_vec()))\n+                Where(ty::Binder(tys.last().into_iter().cloned().collect()))\n             }\n \n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n                 Where(ty::Binder(match sized_crit.sty {\n@@ -1839,8 +1836,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(tys.to_vec()))\n             }\n \n-            ty::TyStruct(..) | ty::TyEnum(..) |\n-            ty::TyProjection(..) | ty::TyParam(..) | ty::TyAnon(..) => {\n+            ty::TyAdt(..) | ty::TyProjection(..) | ty::TyParam(..) | ty::TyAnon(..) => {\n                 // Fallback to whatever user-defined impls exist in this case.\n                 None\n             }\n@@ -1932,11 +1928,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n-            ty::TyStruct(def, substs) if def.is_phantom_data() => {\n+            ty::TyAdt(def, substs) if def.is_phantom_data() => {\n                 substs.types().collect()\n             }\n \n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 def.all_fields()\n                     .map(|f| f.ty(self.tcx(), substs))\n                     .collect()\n@@ -2508,12 +2504,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             // T -> Trait.\n             (_, &ty::TyTrait(ref data)) => {\n-                let mut object_dids = Some(data.principal.def_id()).into_iter();\n-                // FIXME(#33243)\n-//                    data.builtin_bounds.iter().flat_map(|bound| {\n-//                        tcx.lang_items.from_builtin_kind(bound).ok()\n-//                    })\n-//                    .chain(Some(data.principal.def_id()));\n+                let mut object_dids =\n+                    data.builtin_bounds.iter().flat_map(|bound| {\n+                        tcx.lang_items.from_builtin_kind(bound).ok()\n+                    })\n+                    .chain(Some(data.principal.def_id()));\n                 if let Some(did) = object_dids.find(|did| {\n                     !tcx.is_object_safe(*did)\n                 }) {\n@@ -2569,7 +2564,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::TyStruct(def, substs_a), &ty::TyStruct(_, substs_b)) => {\n+            (&ty::TyAdt(def, substs_a), &ty::TyAdt(_, substs_b)) => {\n                 let fields = def\n                     .all_fields()\n                     .map(|f| f.unsubst_ty())\n@@ -2624,7 +2619,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         k\n                     }\n                 });\n-                let new_struct = tcx.mk_struct(def, Substs::new(tcx, params));\n+                let new_struct = tcx.mk_adt(def, Substs::new(tcx, params));\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_struct, target)"}, {"sha": "e37425901c8c8f2dd74ae0d89cc9ce127692f9e3", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 65, "deletions": 23, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -26,9 +26,11 @@ use infer::{InferCtxt, TypeOrigin};\n use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause, Normalized};\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n \n+use syntax::ast;\n+\n pub mod specialization_graph;\n \n /// Information pertinent to an overlapping impl error.\n@@ -103,6 +105,41 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     source_substs.rebase_onto(infcx.tcx, source_impl, target_substs)\n }\n \n+/// Given a selected impl described by `impl_data`, returns the\n+/// definition and substitions for the method with the name `name`,\n+/// and trait method substitutions `substs`, in that impl, a less\n+/// specialized impl, or the trait default, whichever applies.\n+pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             name: ast::Name,\n+                             substs: &'tcx Substs<'tcx>,\n+                             impl_data: &super::VtableImplData<'tcx, ()>)\n+                             -> (DefId, &'tcx Substs<'tcx>)\n+{\n+    assert!(!substs.needs_infer());\n+\n+    let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+\n+    match trait_def.ancestors(impl_data.impl_def_id).fn_defs(tcx, name).next() {\n+        Some(node_item) => {\n+            let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+                let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n+                let substs = translate_substs(&infcx, impl_data.impl_def_id,\n+                                              substs, node_item.node);\n+                tcx.lift(&substs).unwrap_or_else(|| {\n+                    bug!(\"find_method: translate_substs \\\n+                          returned {:?} which contains inference types/regions\",\n+                         substs);\n+                })\n+            });\n+            (node_item.item.def_id, substs)\n+        }\n+        None => {\n+            bug!(\"method {:?} not found in {:?}\", name, impl_data.impl_def_id)\n+        }\n+    }\n+}\n+\n /// Is impl1 a specialization of impl2?\n ///\n /// Specialization is determined by the sets of types to which the impls apply;\n@@ -147,7 +184,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              .unwrap()\n                              .subst(tcx, &penv.free_substs);\n \n-    let result = tcx.normalizing_infer_ctxt(Reveal::ExactMatch).enter(|mut infcx| {\n+    let result = tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|mut infcx| {\n         // Normalize the trait reference, adding any obligations\n         // that arise into the impl1 assumptions.\n         let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {\n@@ -203,29 +240,34 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n \n-    let mut fulfill_cx = FulfillmentContext::new();\n-    for oblig in obligations.into_iter() {\n-        fulfill_cx.register_predicate_obligation(&infcx, oblig);\n-    }\n+    infcx.save_and_restore_obligations_in_snapshot_flag(|infcx| {\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        for oblig in obligations.into_iter() {\n+            fulfill_cx.register_predicate_obligation(&infcx, oblig);\n+        }\n+        match fulfill_cx.select_all_or_error(infcx) {\n+            Err(errors) => {\n+                // no dice!\n+                debug!(\"fulfill_implication: for impls on {:?} and {:?}, \\\n+                        could not fulfill: {:?} given {:?}\",\n+                       source_trait_ref,\n+                       target_trait_ref,\n+                       errors,\n+                       infcx.parameter_environment.caller_bounds);\n+                Err(())\n+            }\n \n-    if let Err(errors) = infcx.drain_fulfillment_cx(&mut fulfill_cx, &()) {\n-        // no dice!\n-        debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n-                {:?}\",\n-               source_trait_ref,\n-               target_trait_ref,\n-               errors,\n-               infcx.parameter_environment.caller_bounds);\n-        Err(())\n-    } else {\n-        debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n-               source_trait_ref,\n-               target_trait_ref);\n+            Ok(()) => {\n+                debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n+                       source_trait_ref,\n+                       target_trait_ref);\n \n-        // Now resolve the *substitution* we built for the target earlier, replacing\n-        // the inference variables inside with whatever we got from fulfillment.\n-        Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n-    }\n+                // Now resolve the *substitution* we built for the target earlier, replacing\n+                // the inference variables inside with whatever we got from fulfillment.\n+                Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+            }\n+        }\n+    })\n }\n \n pub struct SpecializesCache {"}, {"sha": "1374719ef49c4875bd7eafe97a4fdd348a414a35", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 16, "deletions": 47, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell;\n use std::rc::Rc;\n \n use super::{OverlapError, specializes};\n@@ -287,21 +286,10 @@ impl<'a, 'gcx, 'tcx> Node {\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n     pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeItems<'a, 'gcx> {\n-        match *self {\n-            Node::Impl(impl_def_id) => {\n-                NodeItems::Impl {\n-                    tcx: tcx.global_tcx(),\n-                    items: cell::Ref::map(tcx.impl_items.borrow(),\n-                                          |impl_items| &impl_items[&impl_def_id]),\n-                    idx: 0,\n-                }\n-            }\n-            Node::Trait(trait_def_id) => {\n-                NodeItems::Trait {\n-                    items: tcx.trait_items(trait_def_id).clone(),\n-                    idx: 0,\n-                }\n-            }\n+        NodeItems {\n+            tcx: tcx.global_tcx(),\n+            items: tcx.impl_or_trait_items(self.def_id()),\n+            idx: 0,\n         }\n     }\n \n@@ -314,42 +302,23 @@ impl<'a, 'gcx, 'tcx> Node {\n }\n \n /// An iterator over the items defined within a trait or impl.\n-pub enum NodeItems<'a, 'tcx: 'a> {\n-    Impl {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        items: cell::Ref<'a, Vec<ty::ImplOrTraitItemId>>,\n-        idx: usize,\n-    },\n-    Trait {\n-        items: Rc<Vec<ImplOrTraitItem<'tcx>>>,\n-        idx: usize,\n-    },\n+pub struct NodeItems<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    items: Rc<Vec<DefId>>,\n+    idx: usize\n }\n \n impl<'a, 'tcx> Iterator for NodeItems<'a, 'tcx> {\n     type Item = ImplOrTraitItem<'tcx>;\n     fn next(&mut self) -> Option<ImplOrTraitItem<'tcx>> {\n-        match *self {\n-            NodeItems::Impl { tcx, ref items, ref mut idx } => {\n-                let items_table = tcx.impl_or_trait_items.borrow();\n-                if *idx < items.len() {\n-                    let item_def_id = items[*idx].def_id();\n-                    let item = items_table[&item_def_id].clone();\n-                    *idx += 1;\n-                    Some(item)\n-                } else {\n-                    None\n-                }\n-            }\n-            NodeItems::Trait { ref items, ref mut idx } => {\n-                if *idx < items.len() {\n-                    let item = items[*idx].clone();\n-                    *idx += 1;\n-                    Some(item)\n-                } else {\n-                    None\n-                }\n-            }\n+        if self.idx < self.items.len() {\n+            let item_def_id = self.items[self.idx];\n+            let items_table = self.tcx.impl_or_trait_items.borrow();\n+            let item = items_table[&item_def_id].clone();\n+            self.idx += 1;\n+            Some(item)\n+        } else {\n+            None\n         }\n     }\n }"}, {"sha": "2cefc2ad79646730cc9b9e07e3cc7be784fc6680", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -23,9 +23,6 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::Predicate::Trait(ref data) =>\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data)),\n \n-        ty::Predicate::Rfc1592(ref data) =>\n-            ty::Predicate::Rfc1592(Box::new(anonymize_predicate(tcx, data))),\n-\n         ty::Predicate::Equate(ref data) =>\n             ty::Predicate::Equate(tcx.anonymize_late_bound_regions(data)),\n \n@@ -150,9 +147,6 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n \n                 self.stack.extend(predicates);\n             }\n-            ty::Predicate::Rfc1592(..) => {\n-                // Nothing to elaborate.\n-            }\n             ty::Predicate::WellFormed(..) => {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could."}, {"sha": "cfe370343ae490093682f58b15a0cc3469972184", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -19,7 +19,7 @@ use syntax_pos::Span;\n \n use hir;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum AutoAdjustment<'tcx> {\n     AdjustNeverToAny(Ty<'tcx>), // go from ! to any type\n     AdjustReifyFnPointer,       // go from a fn-item type to a fn-pointer type\n@@ -90,7 +90,7 @@ pub enum AutoAdjustment<'tcx> {\n ///     unsize: Some(Box<[i32]>),\n /// }\n /// ```\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct AutoDerefRef<'tcx> {\n     /// Step 1. Apply a number of dereferences, producing an lvalue.\n     pub autoderefs: usize,\n@@ -122,7 +122,7 @@ impl<'tcx> AutoDerefRef<'tcx> {\n }\n \n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoRef<'tcx> {\n     /// Convert from T to &T.\n     AutoPtr(&'tcx ty::Region, hir::Mutability),\n@@ -160,7 +160,7 @@ impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n \n                     AdjustReifyFnPointer => {\n                         match self.sty {\n-                            ty::TyFnDef(_, _, f) => tcx.mk_fn_ptr(f),\n+                            ty::TyFnDef(.., f) => tcx.mk_fn_ptr(f),\n                             _ => {\n                                 bug!(\"AdjustReifyFnPointer adjustment on non-fn-item: {:?}\",\n                                      self);"}, {"sha": "0badb85e9e0956bcdd1ee9561c4d7221f82ba135", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -65,7 +65,7 @@ impl<'tcx> CastTy<'tcx> {\n             ty::TyInt(_) => Some(CastTy::Int(IntTy::I)),\n             ty::TyUint(u) => Some(CastTy::Int(IntTy::U(u))),\n             ty::TyFloat(_) => Some(CastTy::Float),\n-            ty::TyEnum(d,_) if d.is_payloadfree() =>\n+            ty::TyAdt(d,_) if d.is_enum() && d.is_payloadfree() =>\n                 Some(CastTy::Int(IntTy::CEnum)),\n             ty::TyRawPtr(ref mt) => Some(CastTy::Ptr(mt)),\n             ty::TyRef(_, ref mt) => Some(CastTy::RPtr(mt)),"}, {"sha": "b499e1346e73c12afbffa50ac82be68cbce50b85", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                     TC::None\n                 }\n \n-                ty::TyRef(_, _) => {\n+                ty::TyRef(..) => {\n                     TC::None\n                 }\n \n@@ -224,7 +224,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                                         |ty| tc_ty(tcx, *ty, cache))\n                 }\n \n-                ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                ty::TyAdt(def, substs) => {\n                     let mut res =\n                         TypeContents::union(&def.variants, |v| {\n                             TypeContents::union(&v.fields, |f| {"}, {"sha": "5976bd374d2a7dbb0971bc39544c7bbbe15eba02", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 103, "deletions": 75, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -13,10 +13,9 @@\n use dep_graph::{DepGraph, DepTrackingMap};\n use session::Session;\n use middle;\n-use middle::cstore::LOCAL_CRATE;\n use hir::TraitMap;\n use hir::def::DefMap;\n-use hir::def_id::{DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as ast_map;\n use hir::map::{DefKey, DefPathData, DisambiguatedDefPathData};\n use middle::free_region::FreeRegionMap;\n@@ -26,8 +25,8 @@ use middle::stability;\n use ty::subst::Substs;\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n-use ty::{TyS, TypeVariants};\n-use ty::{AdtDef, ClosureSubsts, Region};\n+use ty::{TyS, TypeVariants, Slice};\n+use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n@@ -93,7 +92,7 @@ pub struct CtxtInterners<'tcx> {\n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n     type_: RefCell<FnvHashSet<Interned<'tcx, TyS<'tcx>>>>,\n-    type_list: RefCell<FnvHashSet<Interned<'tcx, [Ty<'tcx>]>>>,\n+    type_list: RefCell<FnvHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n     substs: RefCell<FnvHashSet<Interned<'tcx, Substs<'tcx>>>>,\n     bare_fn: RefCell<FnvHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n     region: RefCell<FnvHashSet<Interned<'tcx, Region>>>,\n@@ -331,8 +330,8 @@ pub struct GlobalCtxt<'tcx> {\n     /// Maps from a trait item to the trait item \"descriptor\"\n     pub impl_or_trait_items: RefCell<DepTrackingMap<maps::ImplOrTraitItems<'tcx>>>,\n \n-    /// Maps from a trait def-id to a list of the def-ids of its trait items\n-    pub trait_item_def_ids: RefCell<DepTrackingMap<maps::TraitItemDefIds<'tcx>>>,\n+    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n+    pub impl_or_trait_item_def_ids: RefCell<DepTrackingMap<maps::ImplOrTraitItemDefIds<'tcx>>>,\n \n     /// A cache for the trait_items() routine; note that the routine\n     /// itself pushes the `TraitItems` dependency node.\n@@ -393,12 +392,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Methods in these implementations don't need to be exported.\n     pub inherent_impls: RefCell<DepTrackingMap<maps::InherentImpls<'tcx>>>,\n \n-    /// Maps a DefId of an impl to a list of its items.\n-    /// Note that this contains all of the impls that we know about,\n-    /// including ones in other crates. It's not clear that this is the best\n-    /// way to do it.\n-    pub impl_items: RefCell<DepTrackingMap<maps::ImplItems<'tcx>>>,\n-\n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n     pub used_unsafe: RefCell<NodeSet>,\n@@ -495,6 +488,10 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Cache for layouts computed from types.\n     pub layout_cache: RefCell<FnvHashMap<Ty<'tcx>, &'tcx Layout>>,\n+\n+    /// Map from function to the `#[derive]` mode that it's defining. Only used\n+    /// by `rustc-macro` crates.\n+    pub derive_macros: RefCell<NodeMap<token::InternedString>>,\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -508,15 +505,23 @@ impl<'tcx> GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn crate_name(self, cnum: ast::CrateNum) -> token::InternedString {\n+    pub fn crate_name(self, cnum: CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n         } else {\n             self.sess.cstore.crate_name(cnum)\n         }\n     }\n \n-    pub fn crate_disambiguator(self, cnum: ast::CrateNum) -> token::InternedString {\n+    pub fn original_crate_name(self, cnum: CrateNum) -> token::InternedString {\n+        if cnum == LOCAL_CRATE {\n+            self.crate_name.clone()\n+        } else {\n+            self.sess.cstore.original_crate_name(cnum)\n+        }\n+    }\n+\n+    pub fn crate_disambiguator(self, cnum: CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.sess.local_crate_disambiguator()\n         } else {\n@@ -529,7 +534,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// relative to `krate`.\n     ///\n     /// Returns `None` if there is no `DefIndex` with that key.\n-    pub fn def_index_for_def_key(self, krate: ast::CrateNum, key: DefKey)\n+    pub fn def_index_for_def_key(self, krate: CrateNum, key: DefKey)\n                                  -> Option<DefIndex> {\n         if krate == LOCAL_CRATE {\n             self.map.def_index_for_def_key(key)\n@@ -539,7 +544,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn retrace_path(self,\n-                        krate: ast::CrateNum,\n+                        krate: CrateNum,\n                         path_data: &[DisambiguatedDefPathData])\n                         -> Option<DefId> {\n         debug!(\"retrace_path(path={:?}, krate={:?})\", path_data, self.crate_name(krate));\n@@ -619,7 +624,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn intern_adt_def(self,\n                           did: DefId,\n-                          kind: ty::AdtKind,\n+                          kind: AdtKind,\n                           variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n                           -> ty::AdtDefMaster<'gcx> {\n         let def = ty::AdtDefData::new(self, did, kind, variants);\n@@ -734,13 +739,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             rcache: RefCell::new(FnvHashMap()),\n             tc_cache: RefCell::new(FnvHashMap()),\n             impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            impl_or_trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_items_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FnvHashMap()),\n             lang_items: lang_items,\n             inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            impl_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n             used_mut_nodes: RefCell::new(NodeSet()),\n             used_trait_imports: RefCell::new(NodeSet()),\n@@ -759,6 +763,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             crate_name: token::intern_and_get_ident(crate_name),\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FnvHashMap()),\n+            derive_macros: RefCell::new(NodeMap()),\n        }, f)\n     }\n }\n@@ -846,10 +851,11 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Region {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a [Ty<'a>] {\n-    type Lifted = &'tcx [Ty<'tcx>];\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx [Ty<'tcx>]> {\n-        if let Some(&Interned(list)) = tcx.interners.type_list.borrow().get(*self) {\n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n+    type Lifted = &'tcx Slice<Ty<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<&'tcx Slice<Ty<'tcx>>> {\n+        if let Some(&Interned(list)) = tcx.interners.type_list.borrow().get(&self[..]) {\n             if *self as *const _ == list as *const _ {\n                 return Some(list);\n             }\n@@ -1030,8 +1036,8 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n-            TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n-            TyTrait, TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n+            TyAdt, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n+            TyTrait, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n@@ -1066,9 +1072,24 @@ impl<'tcx: 'lcx, 'lcx> Borrow<TypeVariants<'lcx>> for Interned<'tcx, TyS<'tcx>>\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, [Ty<'tcx>]> {\n+// NB: An Interned<Slice<T>> compares and hashes as its elements.\n+impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, Slice<T>> {\n+    fn eq(&self, other: &Interned<'tcx, Slice<T>>) -> bool {\n+        self.0[..] == other.0[..]\n+    }\n+}\n+\n+impl<'tcx, T: Eq> Eq for Interned<'tcx, Slice<T>> {}\n+\n+impl<'tcx, T: Hash> Hash for Interned<'tcx, Slice<T>> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.0[..].hash(s)\n+    }\n+}\n+\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, Slice<Ty<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Ty<'lcx>] {\n-        self.0\n+        &self.0[..]\n     }\n }\n \n@@ -1090,32 +1111,23 @@ impl<'tcx> Borrow<Region> for Interned<'tcx, Region> {\n     }\n }\n \n-macro_rules! items { ($($item:item)+) => ($($item)+) }\n-macro_rules! impl_interners {\n-    ($lt_tcx:tt, $($name:ident: $method:ident($alloc:ty, $needs_infer:expr)-> $ty:ty),+) => {\n-        items!($(impl<$lt_tcx> PartialEq for Interned<$lt_tcx, $ty> {\n-            fn eq(&self, other: &Self) -> bool {\n-                self.0 == other.0\n-            }\n-        }\n-\n-        impl<$lt_tcx> Eq for Interned<$lt_tcx, $ty> {}\n-\n-        impl<$lt_tcx> Hash for Interned<$lt_tcx, $ty> {\n-            fn hash<H: Hasher>(&self, s: &mut H) {\n-                self.0.hash(s)\n-            }\n-        }\n-\n+macro_rules! intern_method {\n+    ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n+                                            $alloc_to_key:expr,\n+                                            $alloc_to_ret:expr,\n+                                            $needs_infer:expr) -> $ty:ty) => {\n         impl<'a, 'gcx, $lt_tcx> TyCtxt<'a, 'gcx, $lt_tcx> {\n             pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n-                if let Some(i) = self.interners.$name.borrow().get::<$ty>(&v) {\n-                    return i.0;\n-                }\n-                if !self.is_global() {\n-                    if let Some(i) = self.global_interners.$name.borrow().get::<$ty>(&v) {\n+                {\n+                    let key = ($alloc_to_key)(&v);\n+                    if let Some(i) = self.interners.$name.borrow().get(key) {\n                         return i.0;\n                     }\n+                    if !self.is_global() {\n+                        if let Some(i) = self.global_interners.$name.borrow().get(key) {\n+                            return i.0;\n+                        }\n+                    }\n                 }\n \n                 // HACK(eddyb) Depend on flags being accurate to\n@@ -1126,7 +1138,7 @@ macro_rules! impl_interners {\n                         let v = unsafe {\n                             mem::transmute(v)\n                         };\n-                        let i = self.global_interners.arenas.$name.alloc(v);\n+                        let i = ($alloc_to_ret)(self.global_interners.arenas.$name.alloc(v));\n                         self.global_interners.$name.borrow_mut().insert(Interned(i));\n                         return i;\n                     }\n@@ -1140,34 +1152,59 @@ macro_rules! impl_interners {\n                     }\n                 }\n \n-                let i = self.interners.arenas.$name.alloc(v);\n+                let i = ($alloc_to_ret)(self.interners.arenas.$name.alloc(v));\n                 self.interners.$name.borrow_mut().insert(Interned(i));\n                 i\n             }\n-        })+);\n+        }\n+    }\n+}\n+\n+macro_rules! direct_interners {\n+    ($lt_tcx:tt, $($name:ident: $method:ident($needs_infer:expr) -> $ty:ty),+) => {\n+        $(impl<$lt_tcx> PartialEq for Interned<$lt_tcx, $ty> {\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n+        }\n+\n+        impl<$lt_tcx> Eq for Interned<$lt_tcx, $ty> {}\n+\n+        impl<$lt_tcx> Hash for Interned<$lt_tcx, $ty> {\n+            fn hash<H: Hasher>(&self, s: &mut H) {\n+                self.0.hash(s)\n+            }\n+        }\n+\n+        intern_method!($lt_tcx, $name: $method($ty, |x| x, |x| x, $needs_infer) -> $ty);)+\n     }\n }\n \n fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n     x.has_type_flags(ty::TypeFlags::KEEP_IN_LOCAL_TCX)\n }\n \n-impl_interners!('tcx,\n-    type_list: mk_type_list(Vec<Ty<'tcx>>, keep_local) -> [Ty<'tcx>],\n-    substs: mk_substs(Substs<'tcx>, |substs: &Substs| {\n+direct_interners!('tcx,\n+    substs: mk_substs(|substs: &Substs| {\n         substs.params().iter().any(keep_local)\n     }) -> Substs<'tcx>,\n-    bare_fn: mk_bare_fn(BareFnTy<'tcx>, |fty: &BareFnTy| {\n+    bare_fn: mk_bare_fn(|fty: &BareFnTy| {\n         keep_local(&fty.sig)\n     }) -> BareFnTy<'tcx>,\n-    region: mk_region(Region, |r| {\n+    region: mk_region(|r| {\n         match r {\n             &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n             _ => false\n         }\n     }) -> Region\n );\n \n+intern_method!('tcx,\n+    type_list: mk_type_list(Vec<Ty<'tcx>>, Deref::deref, |xs: &[Ty]| -> &Slice<Ty> {\n+        unsafe { mem::transmute(xs) }\n+    }, keep_local) -> Slice<Ty<'tcx>>\n+);\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Create an unsafe fn ty based on a safe fn ty.\n     pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n@@ -1225,9 +1262,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n     }\n \n-    pub fn mk_enum(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_adt(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n-        self.mk_ty(TyEnum(def, substs))\n+        self.mk_ty(TyAdt(def, substs))\n     }\n \n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -1301,7 +1338,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_trait(self, mut obj: TraitObject<'tcx>) -> Ty<'tcx> {\n-        obj.projection_bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()));\n+        obj.projection_bounds.sort_by_key(|b| b.sort_key(self));\n         self.mk_ty(TyTrait(box obj))\n     }\n \n@@ -1314,11 +1351,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyProjection(inner))\n     }\n \n-    pub fn mk_struct(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-        // take a copy of substs so that we own the vectors inside\n-        self.mk_ty(TyStruct(def, substs))\n-    }\n-\n     pub fn mk_closure(self,\n                       closure_id: DefId,\n                       substs: &'tcx Substs<'tcx>,\n@@ -1373,23 +1405,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'gcx>>> {\n         self.trait_items_cache.memoize(trait_did, || {\n-            let def_ids = self.trait_item_def_ids(trait_did);\n+            let def_ids = self.impl_or_trait_items(trait_did);\n             Rc::new(def_ids.iter()\n-                           .map(|d| self.impl_or_trait_item(d.def_id()))\n+                           .map(|&def_id| self.impl_or_trait_item(def_id))\n                            .collect())\n         })\n     }\n \n     /// Obtain the representation annotation for a struct definition.\n     pub fn lookup_repr_hints(self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n         self.repr_hint_cache.memoize(did, || {\n-            Rc::new(if did.is_local() {\n-                self.get_attrs(did).iter().flat_map(|meta| {\n-                    attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n-                }).collect()\n-            } else {\n-                self.sess.cstore.repr_attrs(did)\n-            })\n+            Rc::new(self.get_attrs(did).iter().flat_map(|meta| {\n+                attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n+            }).collect())\n         })\n     }\n }"}, {"sha": "001f47af68c3bf67b0727f6425a2040eb5c0ef32", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -210,13 +210,13 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n }\n \n impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n-    fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> String {\n+    pub fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> String {\n         match self.sty {\n             ty::TyBool | ty::TyChar | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr | ty::TyNever => self.to_string(),\n             ty::TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n \n-            ty::TyEnum(def, _) => format!(\"enum `{}`\", tcx.item_path_str(def.did)),\n+            ty::TyAdt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n             ty::TyBox(_) => \"box\".to_string(),\n             ty::TyArray(_, n) => format!(\"array of {} elements\", n),\n             ty::TySlice(_) => \"slice\".to_string(),\n@@ -244,9 +244,6 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyTrait(ref inner) => {\n                 format!(\"trait {}\", tcx.item_path_str(inner.principal.def_id()))\n             }\n-            ty::TyStruct(def, _) => {\n-                format!(\"struct `{}`\", tcx.item_path_str(def.did))\n-            }\n             ty::TyClosure(..) => \"closure\".to_string(),\n             ty::TyTuple(_) => \"tuple\".to_string(),\n             ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),"}, {"sha": "ee1544d2d996d3df5905d29c6838ec2b4439e6e5", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -22,14 +22,13 @@ pub enum SimplifiedType {\n     IntSimplifiedType(ast::IntTy),\n     UintSimplifiedType(ast::UintTy),\n     FloatSimplifiedType(ast::FloatTy),\n-    EnumSimplifiedType(DefId),\n+    AdtSimplifiedType(DefId),\n     StrSimplifiedType,\n     VecSimplifiedType,\n     PtrSimplifiedType,\n     NeverSimplifiedType,\n     TupleSimplifiedType(usize),\n     TraitSimplifiedType(DefId),\n-    StructSimplifiedType(DefId),\n     ClosureSimplifiedType(DefId),\n     AnonSimplifiedType(DefId),\n     FunctionSimplifiedType(usize),\n@@ -56,16 +55,13 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyInt(int_type) => Some(IntSimplifiedType(int_type)),\n         ty::TyUint(uint_type) => Some(UintSimplifiedType(uint_type)),\n         ty::TyFloat(float_type) => Some(FloatSimplifiedType(float_type)),\n-        ty::TyEnum(def, _) => Some(EnumSimplifiedType(def.did)),\n+        ty::TyAdt(def, _) => Some(AdtSimplifiedType(def.did)),\n         ty::TyStr => Some(StrSimplifiedType),\n         ty::TyArray(..) | ty::TySlice(_) => Some(VecSimplifiedType),\n         ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n         ty::TyTrait(ref trait_info) => {\n             Some(TraitSimplifiedType(trait_info.principal.def_id()))\n         }\n-        ty::TyStruct(def, _) => {\n-            Some(StructSimplifiedType(def.did))\n-        }\n         ty::TyRef(_, mt) => {\n             // since we introduce auto-refs during method lookup, we\n             // just treat &T and T as equivalent from the point of\n@@ -75,7 +71,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyBox(_) => {\n             // treat like we would treat `Box`\n             match tcx.lang_items.require_owned_box() {\n-                Ok(def_id) => Some(StructSimplifiedType(def_id)),\n+                Ok(def_id) => Some(AdtSimplifiedType(def_id)),\n                 Err(msg) => tcx.sess.fatal(&msg),\n             }\n         }\n@@ -86,7 +82,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyTuple(ref tys) => {\n             Some(TupleSimplifiedType(tys.len()))\n         }\n-        ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n+        ty::TyFnDef(.., ref f) | ty::TyFnPtr(ref f) => {\n             Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n         ty::TyProjection(_) | ty::TyParam(_) => {"}, {"sha": "cddd59fa83c1b80ec76aa68fe88f614657d2b3f2", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -102,7 +102,7 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty::TyEnum(_, substs) | &ty::TyStruct(_, substs) => {\n+            &ty::TyAdt(_, substs) => {\n                 self.add_substs(substs);\n             }\n "}, {"sha": "fdf5185eb69e2f205e3aa3d0aabe5daaa5d7e422", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use hir::map::DefPathData;\n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::parse::token;\n@@ -67,7 +66,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the \"path\" to a particular crate. This can proceed in\n     /// various ways, depending on the `root_mode` of the `buffer`.\n     /// (See `RootMode` enum for more details.)\n-    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: ast::CrateNum)\n+    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum)\n         where T: ItemPathBuffer\n     {\n         match *buffer.root_mode() {\n@@ -102,11 +101,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             RootMode::Absolute => {\n                 // In absolute mode, just write the crate name\n                 // unconditionally.\n-                if cnum == LOCAL_CRATE {\n-                    buffer.push(&self.crate_name(cnum));\n-                } else {\n-                    buffer.push(&self.sess.cstore.original_crate_name(cnum));\n-                }\n+                buffer.push(&self.original_crate_name(cnum));\n             }\n         }\n     }\n@@ -139,7 +134,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            cur_path.push(self.sess.cstore.opt_item_name(cur_def).unwrap_or_else(||\n+            cur_path.push(self.sess.cstore.def_key(cur_def)\n+                              .disambiguated_data.data.get_opt_name().unwrap_or_else(||\n                 token::intern(\"<unnamed>\")));\n             match visible_parent_map.get(&cur_def) {\n                 Some(&def) => cur_def = def,\n@@ -262,8 +258,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n         // anything other than a simple path.\n         match self_ty.sty {\n-            ty::TyStruct(adt_def, substs) |\n-            ty::TyEnum(adt_def, substs) => {\n+            ty::TyAdt(adt_def, substs) => {\n                 if substs.types().next().is_none() { // ignore regions\n                     self.push_item_path(buffer, adt_def.did);\n                 } else {\n@@ -305,7 +300,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the def-id of `def_id`'s parent in the def tree. If\n     /// this returns `None`, then `def_id` represents a crate root or\n     /// inlined root.\n-    fn parent_def_id(&self, def_id: DefId) -> Option<DefId> {\n+    pub fn parent_def_id(self, def_id: DefId) -> Option<DefId> {\n         let key = self.def_key(def_id);\n         key.parent.map(|index| DefId { krate: def_id.krate, index: index })\n     }\n@@ -319,8 +314,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n /// decisions and we may want to adjust it later.\n pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n     match ty.sty {\n-        ty::TyStruct(adt_def, _) |\n-        ty::TyEnum(adt_def, _) => Some(adt_def.did),\n+        ty::TyAdt(adt_def, _) => Some(adt_def.did),\n \n         ty::TyTrait(ref data) => Some(data.principal.def_id()),\n \n@@ -335,7 +329,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n                                    .filter_map(|ty| characteristic_def_id_of_type(ty))\n                                    .next(),\n \n-        ty::TyFnDef(def_id, _, _) |\n+        ty::TyFnDef(def_id, ..) |\n         ty::TyClosure(def_id, _) => Some(def_id),\n \n         ty::TyBool |"}, {"sha": "5e7a2bc0266cfa06672b54e04e3a0ec74f38d6c4", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 115, "deletions": 61, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -45,6 +45,7 @@ pub struct TargetDataLayout {\n }\n \n impl Default for TargetDataLayout {\n+    /// Creates an instance of `TargetDataLayout`.\n     fn default() -> TargetDataLayout {\n         TargetDataLayout {\n             endian: Endian::Big,\n@@ -366,7 +367,7 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    pub fn repr_discr(tcx: TyCtxt, hint: attr::ReprAttr, min: i64, max: i64)\n+    pub fn repr_discr(tcx: TyCtxt, ty: Ty, hint: attr::ReprAttr, min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n@@ -376,11 +377,12 @@ impl Integer {\n         let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n \n         let at_least = match hint {\n-            attr::ReprInt(span, ity) => {\n+            attr::ReprInt(ity) => {\n                 let discr = Integer::from_attr(&tcx.data_layout, ity);\n                 let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n                 if discr < fit {\n-                    span_bug!(span, \"representation hint insufficient for discriminant range\")\n+                    bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n+                          discriminant range of enum `{}\", ty)\n                 }\n                 return (discr, ity.is_signed());\n             }\n@@ -396,10 +398,10 @@ impl Integer {\n             }\n             attr::ReprAny => I8,\n             attr::ReprPacked => {\n-                bug!(\"Integer::repr_discr: found #[repr(packed)] on an enum\");\n+                bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n             }\n             attr::ReprSimd => {\n-                bug!(\"Integer::repr_discr: found #[repr(simd)] on an enum\");\n+                bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n             }\n         };\n \n@@ -488,7 +490,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n         for field in fields {\n             if !self.sized {\n-                bug!(\"Struct::compute: field #{} of `{}` comes after unsized field\",\n+                bug!(\"Struct::extend: field #{} of `{}` comes after unsized field\",\n                      self.offset_after_field.len(), scapegoat);\n             }\n \n@@ -555,7 +557,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             }\n \n             // Is this the NonZero lang item wrapping a pointer or integer type?\n-            (&Univariant { non_zero: true, .. }, &ty::TyStruct(def, substs)) => {\n+            (&Univariant { non_zero: true, .. }, &ty::TyAdt(def, substs)) => {\n                 let fields = &def.struct_variant().fields;\n                 assert_eq!(fields.len(), 1);\n                 match *fields[0].ty(tcx, substs).layout(infcx)? {\n@@ -573,7 +575,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n             // Perhaps one of the fields of this struct is non-zero\n             // let's recurse and find out\n-            (_, &ty::TyStruct(def, substs)) => {\n+            (_, &ty::TyAdt(def, substs)) if def.is_struct() => {\n                 Struct::non_zero_field_path(infcx, def.struct_variant().fields\n                                                       .iter().map(|field| {\n                     field.ty(tcx, substs)\n@@ -623,6 +625,54 @@ impl<'a, 'gcx, 'tcx> Struct {\n     }\n }\n \n+/// An untagged union.\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub struct Union {\n+    pub align: Align,\n+\n+    pub min_size: Size,\n+\n+    /// If true, no alignment padding is used.\n+    pub packed: bool,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Union {\n+    pub fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n+        Union {\n+            align: if packed { dl.i8_align } else { dl.aggregate_align },\n+            min_size: Size::from_bytes(0),\n+            packed: packed,\n+        }\n+    }\n+\n+    /// Extend the Struct with more fields.\n+    pub fn extend<I>(&mut self, dl: &TargetDataLayout,\n+                     fields: I,\n+                     scapegoat: Ty<'gcx>)\n+                     -> Result<(), LayoutError<'gcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n+        for (index, field) in fields.enumerate() {\n+            let field = field?;\n+            if field.is_unsized() {\n+                bug!(\"Union::extend: field #{} of `{}` is unsized\",\n+                     index, scapegoat);\n+            }\n+\n+            if !self.packed {\n+                self.align = self.align.max(field.align(dl));\n+            }\n+            self.min_size = cmp::max(self.min_size, field.size(dl));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Get the size with trailing aligment padding.\n+    pub fn stride(&self) -> Size {\n+        self.min_size.abi_align(self.align)\n+    }\n+}\n+\n /// The first half of a fat pointer.\n /// - For a trait object, this is the address of the box.\n /// - For a slice, this is the base address.\n@@ -646,7 +696,7 @@ pub enum Layout {\n         non_zero: bool\n     },\n \n-    /// SIMD vectors, from TyStruct marked with #[repr(simd)].\n+    /// SIMD vectors, from structs marked with #[repr(simd)].\n     Vector {\n         element: Primitive,\n         count: u64\n@@ -667,7 +717,7 @@ pub enum Layout {\n         non_zero: bool\n     },\n \n-    // Remaining variants are all ADTs such as TyStruct, TyEnum or TyTuple.\n+    // Remaining variants are all ADTs such as structs, enums or tuples.\n \n     /// C-like enums; basically an integer.\n     CEnum {\n@@ -690,6 +740,11 @@ pub enum Layout {\n         non_zero: bool\n     },\n \n+    /// Untagged unions.\n+    UntaggedUnion {\n+        variants: Union,\n+    },\n+\n     /// General-case enums: for each case there is a struct, and they\n     /// all start with a field for the discriminant.\n     General {\n@@ -803,10 +858,10 @@ impl<'a, 'gcx, 'tcx> Layout {\n             ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let non_zero = !ty.is_unsafe_ptr();\n+                let pointee = normalize_associated_type(infcx, pointee);\n                 if pointee.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n                     Scalar { value: Pointer, non_zero: non_zero }\n                 } else {\n-                    let pointee = normalize_associated_type(infcx, pointee);\n                     let unsized_part = tcx.struct_tail(pointee);\n                     let meta = match unsized_part.sty {\n                         ty::TySlice(_) | ty::TyStr => {\n@@ -865,38 +920,26 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Univariant { variant: st, non_zero: false }\n             }\n \n-            // ADTs.\n-            ty::TyStruct(def, substs) => {\n-                if ty.is_simd() {\n-                    // SIMD vector types.\n-                    let element = ty.simd_type(tcx);\n-                    match *element.layout(infcx)? {\n-                        Scalar { value, .. } => {\n-                            return success(Vector {\n-                                element: value,\n-                                count: ty.simd_size(tcx) as u64\n-                            });\n-                        }\n-                        _ => {\n-                            tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` with \\\n-                                                     a non-machine element type `{}`\",\n-                                                    ty, element));\n-                        }\n+            // SIMD vector types.\n+            ty::TyAdt(def, ..) if def.is_simd() => {\n+                let element = ty.simd_type(tcx);\n+                match *element.layout(infcx)? {\n+                    Scalar { value, .. } => {\n+                        return success(Vector {\n+                            element: value,\n+                            count: ty.simd_size(tcx) as u64\n+                        });\n+                    }\n+                    _ => {\n+                        tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` with \\\n+                                                a non-machine element type `{}`\",\n+                                                ty, element));\n                     }\n-                }\n-                let fields = def.struct_variant().fields.iter().map(|field| {\n-                    field.ty(tcx, substs).layout(infcx)\n-                });\n-                let packed = tcx.lookup_packed(def.did);\n-                let mut st = Struct::new(dl, packed);\n-                st.extend(dl, fields, ty)?;\n-\n-                Univariant {\n-                    variant: st,\n-                    non_zero: Some(def.did) == tcx.lang_items.non_zero()\n                 }\n             }\n-            ty::TyEnum(def, substs) => {\n+\n+            // ADTs.\n+            ty::TyAdt(def, substs) => {\n                 let hint = *tcx.lookup_repr_hints(def.did).get(0)\n                     .unwrap_or(&attr::ReprAny);\n \n@@ -911,7 +954,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     });\n                 }\n \n-                if def.variants.iter().all(|v| v.fields.is_empty()) {\n+                if def.is_enum() && def.variants.iter().all(|v| v.fields.is_empty()) {\n                     // All bodies empty -> intlike\n                     let (mut min, mut max) = (i64::MAX, i64::MIN);\n                     for v in &def.variants {\n@@ -920,7 +963,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         if x > max { max = x; }\n                     }\n \n-                    let (discr, signed) = Integer::repr_discr(tcx, hint, min, max);\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, hint, min, max);\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n@@ -929,28 +972,37 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     });\n                 }\n \n+                if def.variants.len() == 1 {\n+                    // Struct, or union, or univariant enum equivalent to a struct.\n+                    // (Typechecking will reject discriminant-sizing attrs.)\n+                    assert!(!def.is_enum() || hint == attr::ReprAny);\n+                    let fields = def.variants[0].fields.iter().map(|field| {\n+                        field.ty(tcx, substs).layout(infcx)\n+                    });\n+                    let packed = tcx.lookup_packed(def.did);\n+                    let layout = if def.is_union() {\n+                        let mut un = Union::new(dl, packed);\n+                        un.extend(dl, fields, ty)?;\n+                        UntaggedUnion { variants: un }\n+                    } else {\n+                        let mut st = Struct::new(dl, packed);\n+                        st.extend(dl, fields, ty)?;\n+                        let non_zero = Some(def.did) == tcx.lang_items.non_zero();\n+                        Univariant { variant: st, non_zero: non_zero }\n+                    };\n+                    return success(layout);\n+                }\n+\n                 // Since there's at least one\n                 // non-empty body, explicit discriminants should have\n                 // been rejected by a checker before this point.\n                 for (i, v) in def.variants.iter().enumerate() {\n                     if i as u64 != v.disr_val.to_u64_unchecked() {\n                         bug!(\"non-C-like enum {} with specified discriminants\",\n-                             tcx.item_path_str(def.did));\n+                            tcx.item_path_str(def.did));\n                     }\n                 }\n \n-                if def.variants.len() == 1 {\n-                    // Equivalent to a struct/tuple/newtype.\n-                    // (Typechecking will reject discriminant-sizing attrs.)\n-                    assert_eq!(hint, attr::ReprAny);\n-                    let fields = def.variants[0].fields.iter().map(|field| {\n-                        field.ty(tcx, substs).layout(infcx)\n-                    });\n-                    let mut st = Struct::new(dl, false);\n-                    st.extend(dl, fields, ty)?;\n-                    return success(Univariant { variant: st, non_zero: false });\n-                }\n-\n                 // Cache the substituted and normalized variant field types.\n                 let variants = def.variants.iter().map(|v| {\n                     v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n@@ -980,8 +1032,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                                 }\n                                 _ => {\n                                     bug!(\"Layout::compute: `{}`'s non-zero \\\n-                                          `{}` field not scalar?!\",\n-                                         ty, variants[discr][0])\n+                                        `{}` field not scalar?!\",\n+                                        ty, variants[discr][0])\n                                 }\n                             }\n                         }\n@@ -1001,7 +1053,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // The general case.\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, hint, 0, discr_max);\n+                let (min_ity, _) = Integer::repr_discr(tcx, ty, hint, 0, discr_max);\n \n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n@@ -1115,7 +1167,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n     pub fn is_unsized(&self) -> bool {\n         match *self {\n             Scalar {..} | Vector {..} | FatPointer {..} |\n-            CEnum {..} | General {..} |\n+            CEnum {..} | UntaggedUnion {..} | General {..} |\n             RawNullablePointer {..} |\n             StructWrappedNullablePointer {..} => false,\n \n@@ -1149,6 +1201,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             CEnum { discr, .. } => Int(discr).size(dl),\n             Array { size, .. } | General { size, .. } => size,\n+            UntaggedUnion { ref variants } => variants.stride(),\n \n             Univariant { ref variant, .. } |\n             StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n@@ -1188,6 +1241,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             CEnum { discr, .. } => Int(discr).align(dl),\n             Array { align, .. } | General { align, .. } => align,\n+            UntaggedUnion { ref variants } => variants.align,\n \n             Univariant { ref variant, .. } |\n             StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n@@ -1253,9 +1307,9 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                 }\n             }\n \n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 // Only newtypes and enums w/ nullable pointer optimization.\n-                if def.variants.is_empty() || def.variants.len() > 2 {\n+                if def.is_union() || def.variants.is_empty() || def.variants.len() > 2 {\n                     return Err(err);\n                 }\n "}, {"sha": "3a552a8b437d3aba15ba54929a17f4a48e95c05d", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -34,13 +34,12 @@ dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n-dep_map_ty! { TraitItemDefIds: TraitItemDefIds(DefId) -> Rc<Vec<ty::ImplOrTraitItemId>> }\n+dep_map_ty! { ImplOrTraitItemDefIds: ImplOrTraitItemDefIds(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n-dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Rc<Vec<DefId>> }\n-dep_map_ty! { ImplItems: ImplItems(DefId) -> Vec<ty::ImplOrTraitItemId> }\n+dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n dep_map_ty! { InlinedClosures: Hir(DefId) -> ast::NodeId }"}, {"sha": "9eb87fa2ed43c93b6714433eeab7eea030de18b0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 203, "deletions": 249, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::ImplOrTraitItemId::*;\n pub use self::Variance::*;\n pub use self::DtorKind::*;\n pub use self::ImplOrTraitItemContainer::*;\n@@ -21,9 +20,8 @@ pub use self::fold::TypeFoldable;\n use dep_graph::{self, DepNode};\n use hir::map as ast_map;\n use middle;\n-use middle::cstore::{self, LOCAL_CRATE};\n use hir::def::{Def, PathResolution, ExportMap};\n-use hir::def_id::DefId;\n+use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n use traits;\n@@ -34,23 +32,23 @@ use util::common::MemoizationMap;\n use util::nodemap::NodeSet;\n use util::nodemap::FnvHashMap;\n \n-use serialize::{Encodable, Encoder, Decodable, Decoder};\n+use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::hash::{Hash, Hasher};\n use std::iter;\n+use std::ops::Deref;\n use std::rc::Rc;\n use std::slice;\n use std::vec::IntoIter;\n-use syntax::ast::{self, CrateNum, Name, NodeId};\n+use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token::{self, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n use rustc_const_math::ConstInt;\n \n use hir;\n-use hir::{ItemImpl, ItemTrait, PatKind};\n use hir::intravisit::Visitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n@@ -191,23 +189,11 @@ pub enum ImplOrTraitItem<'tcx> {\n }\n \n impl<'tcx> ImplOrTraitItem<'tcx> {\n-    fn id(&self) -> ImplOrTraitItemId {\n-        match *self {\n-            ConstTraitItem(ref associated_const) => {\n-                ConstTraitItemId(associated_const.def_id)\n-            }\n-            MethodTraitItem(ref method) => MethodTraitItemId(method.def_id),\n-            TypeTraitItem(ref associated_type) => {\n-                TypeTraitItemId(associated_type.def_id)\n-            }\n-        }\n-    }\n-\n     pub fn def(&self) -> Def {\n         match *self {\n             ConstTraitItem(ref associated_const) => Def::AssociatedConst(associated_const.def_id),\n             MethodTraitItem(ref method) => Def::Method(method.def_id),\n-            TypeTraitItem(ref ty) => Def::AssociatedTy(ty.container.id(), ty.def_id),\n+            TypeTraitItem(ref ty) => Def::AssociatedTy(ty.def_id),\n         }\n     }\n \n@@ -251,24 +237,7 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Debug)]\n-pub enum ImplOrTraitItemId {\n-    ConstTraitItemId(DefId),\n-    MethodTraitItemId(DefId),\n-    TypeTraitItemId(DefId),\n-}\n-\n-impl ImplOrTraitItemId {\n-    pub fn def_id(&self) -> DefId {\n-        match *self {\n-            ConstTraitItemId(def_id) => def_id,\n-            MethodTraitItemId(def_id) => def_id,\n-            TypeTraitItemId(def_id) => def_id,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Copy)]\n+#[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n     Public,\n@@ -346,34 +315,12 @@ pub struct Method<'tcx> {\n     pub explicit_self: ExplicitSelfCategory<'tcx>,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n+    pub has_body: bool,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n }\n \n impl<'tcx> Method<'tcx> {\n-    pub fn new(name: Name,\n-               generics: &'tcx ty::Generics<'tcx>,\n-               predicates: GenericPredicates<'tcx>,\n-               fty: &'tcx BareFnTy<'tcx>,\n-               explicit_self: ExplicitSelfCategory<'tcx>,\n-               vis: Visibility,\n-               defaultness: hir::Defaultness,\n-               def_id: DefId,\n-               container: ImplOrTraitItemContainer)\n-               -> Method<'tcx> {\n-        Method {\n-            name: name,\n-            generics: generics,\n-            predicates: predicates,\n-            fty: fty,\n-            explicit_self: explicit_self,\n-            vis: vis,\n-            defaultness: defaultness,\n-            def_id: def_id,\n-            container: container,\n-        }\n-    }\n-\n     pub fn container_id(&self) -> DefId {\n         match self.container {\n             TraitContainer(id) => id,\n@@ -425,7 +372,7 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, RustcDecodable, RustcEncodable)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n     pub def_id: DefId,\n@@ -567,23 +514,47 @@ impl<'tcx> Hash for TyS<'tcx> {\n \n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-impl<'tcx> Encodable for Ty<'tcx> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n-            ecx.encode_ty(rbml_w, *self);\n-            Ok(())\n-        })\n+impl<'tcx> serialize::UseSpecializedEncodable for Ty<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for Ty<'tcx> {}\n+\n+/// A wrapper for slices with the additioanl invariant\n+/// that the slice is interned and no other slice with\n+/// the same contents can exist in the same context.\n+/// This means we can use pointer + length for both\n+/// equality comparisons and hashing.\n+#[derive(Debug, RustcEncodable)]\n+pub struct Slice<T>([T]);\n+\n+impl<T> PartialEq for Slice<T> {\n+    #[inline]\n+    fn eq(&self, other: &Slice<T>) -> bool {\n+        (&self.0 as *const [T]) == (&other.0 as *const [T])\n     }\n }\n+impl<T> Eq for Slice<T> {}\n \n-impl<'tcx> Decodable for Ty<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Ty<'tcx>, D::Error> {\n-        cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n-            Ok(dcx.decode_ty(rbml_r))\n-        })\n+impl<T> Hash for Slice<T> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self.as_ptr(), self.len()).hash(s)\n     }\n }\n \n+impl<T> Deref for Slice<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        &self.0\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a Slice<T> {\n+    type Item = &'a T;\n+    type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self[..].iter()\n+    }\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<Ty<'tcx>> {}\n \n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n@@ -642,7 +613,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy)]\n+#[derive(PartialEq, Clone, Debug, Copy, RustcEncodable, RustcDecodable)]\n pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -653,7 +624,7 @@ pub enum UpvarCapture<'tcx> {\n     ByRef(UpvarBorrow<'tcx>),\n }\n \n-#[derive(PartialEq, Clone, Copy)]\n+#[derive(PartialEq, Clone, Copy, RustcEncodable, RustcDecodable)]\n pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -684,7 +655,7 @@ pub enum IntVarValue {\n /// from `T:'a` annotations appearing in the type definition.  If\n /// this is `None`, then the default is inherited from the\n /// surrounding context. See RFC #599 for details.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum ObjectLifetimeDefault<'tcx> {\n     /// Require an explicit annotation. Occurs when multiple\n     /// `T:'a` constraints are found.\n@@ -697,7 +668,7 @@ pub enum ObjectLifetimeDefault<'tcx> {\n     Specific(&'tcx Region),\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct TypeParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n@@ -707,7 +678,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub object_lifetime_default: ObjectLifetimeDefault<'tcx>,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct RegionParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n@@ -717,11 +688,16 @@ pub struct RegionParameterDef<'tcx> {\n \n impl<'tcx> RegionParameterDef<'tcx> {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n-        ty::ReEarlyBound(ty::EarlyBoundRegion {\n+        ty::ReEarlyBound(self.to_early_bound_region_data())\n+    }\n+\n+    pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n+        ty::EarlyBoundRegion {\n             index: self.index,\n             name: self.name,\n-        })\n+        }\n     }\n+\n     pub fn to_bound_region(&self) -> ty::BoundRegion {\n         // this is an early bound region, so unaffected by #32330\n         ty::BoundRegion::BrNamed(self.def_id, self.name, Issue32330::WontChange)\n@@ -730,7 +706,7 @@ impl<'tcx> RegionParameterDef<'tcx> {\n \n /// Information about the formal type/lifetime parameters associated\n /// with an item or method. Analogous to hir::Generics.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Generics<'tcx> {\n     pub parent: Option<DefId>,\n     pub parent_regions: u32,\n@@ -761,6 +737,9 @@ pub struct GenericPredicates<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n+impl<'tcx> serialize::UseSpecializedEncodable for GenericPredicates<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for GenericPredicates<'tcx> {}\n+\n impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     pub fn instantiate(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                        -> InstantiatedPredicates<'tcx> {\n@@ -797,16 +776,13 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n     Trait(PolyTraitPredicate<'tcx>),\n \n-    /// A predicate created by RFC1592\n-    Rfc1592(Box<Predicate<'tcx>>),\n-\n     /// where `T1 == T2`.\n     Equate(PolyEquatePredicate<'tcx>),\n \n@@ -906,8 +882,6 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n         match *self {\n             Predicate::Trait(ty::Binder(ref data)) =>\n                 Predicate::Trait(ty::Binder(data.subst(tcx, substs))),\n-            Predicate::Rfc1592(ref pi) =>\n-                Predicate::Rfc1592(Box::new(pi.subst_supertrait(tcx, trait_ref))),\n             Predicate::Equate(ty::Binder(ref data)) =>\n                 Predicate::Equate(ty::Binder(data.subst(tcx, substs))),\n             Predicate::RegionOutlives(ty::Binder(ref data)) =>\n@@ -926,7 +900,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>\n }\n@@ -952,14 +926,14 @@ impl<'tcx> TraitPredicate<'tcx> {\n             self.input_types()\n                 .flat_map(|t| t.walk())\n                 .filter_map(|t| match t.sty {\n-                    ty::TyStruct(adt_def, _) |\n-                    ty::TyEnum(adt_def, _) =>\n+                    ty::TyAdt(adt_def, _) =>\n                         Some(adt_def.did),\n                     _ =>\n                         None\n                 })\n+                .chain(iter::once(self.def_id()))\n                 .collect();\n-        DepNode::TraitSelect(self.def_id(), def_ids)\n+        DepNode::TraitSelect(def_ids)\n     }\n \n     pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n@@ -983,11 +957,11 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct EquatePredicate<'tcx>(pub Ty<'tcx>, pub Ty<'tcx>); // `0 == 1`\n pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<&'tcx ty::Region,\n@@ -1006,7 +980,7 @@ pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, &'tcx\n /// equality between arbitrary types. Processing an instance of Form\n /// #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,\n@@ -1018,10 +992,6 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     pub fn item_name(&self) -> Name {\n         self.0.projection_ty.item_name // safe to skip the binder to access a name\n     }\n-\n-    pub fn sort_key(&self) -> (DefId, Name) {\n-        self.0.projection_ty.sort_key()\n-    }\n }\n \n pub trait ToPolyTraitRef<'tcx> {\n@@ -1108,9 +1078,6 @@ impl<'tcx> Predicate<'tcx> {\n             ty::Predicate::Trait(ref data) => {\n                 data.skip_binder().input_types().collect()\n             }\n-            ty::Predicate::Rfc1592(ref data) => {\n-                return data.walk_tys()\n-            }\n             ty::Predicate::Equate(ty::Binder(ref data)) => {\n                 vec![data.0, data.1]\n             }\n@@ -1148,7 +1115,6 @@ impl<'tcx> Predicate<'tcx> {\n             Predicate::Trait(ref t) => {\n                 Some(t.to_poly_trait_ref())\n             }\n-            Predicate::Rfc1592(..) |\n             Predicate::Projection(..) |\n             Predicate::Equate(..) |\n             Predicate::RegionOutlives(..) |\n@@ -1271,7 +1237,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n         match tcx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n-                    hir::ImplItemKind::Type(_) | hir::ImplItemKind::Const(_, _) => {\n+                    hir::ImplItemKind::Type(_) | hir::ImplItemKind::Const(..) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the impl\n                         let impl_id = tcx.map.get_parent(id);\n@@ -1338,7 +1304,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(_, _, _, _, _, ref body) => {\n+                    hir::ItemFn(.., ref body) => {\n                         // We assume this is a function.\n                         let fn_def_id = tcx.map.local_def_id(id);\n \n@@ -1349,6 +1315,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n+                    hir::ItemUnion(..) |\n                     hir::ItemTy(..) |\n                     hir::ItemImpl(..) |\n                     hir::ItemConst(..) |\n@@ -1429,6 +1396,7 @@ bitflags! {\n         const IS_PHANTOM_DATA     = 1 << 3,\n         const IS_SIMD             = 1 << 4,\n         const IS_FUNDAMENTAL      = 1 << 5,\n+        const IS_UNION            = 1 << 6,\n     }\n }\n \n@@ -1502,26 +1470,16 @@ impl<'tcx, 'container> Hash for AdtDefData<'tcx, 'container> {\n     }\n }\n \n-impl<'tcx> Encodable for AdtDef<'tcx> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<'tcx> serialize::UseSpecializedEncodable for AdtDef<'tcx> {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.did.encode(s)\n     }\n }\n \n-impl<'tcx> Decodable for AdtDef<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<AdtDef<'tcx>, D::Error> {\n-        let def_id: DefId = Decodable::decode(d)?;\n-\n-        cstore::tls::with_decoding_context(d, |dcx, _| {\n-            let def_id = dcx.translate_def_id(def_id);\n-            Ok(dcx.tcx().lookup_adt_def(def_id))\n-        })\n-    }\n-}\n-\n+impl<'tcx> serialize::UseSpecializedDecodable for AdtDef<'tcx> {}\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub enum AdtKind { Struct, Enum }\n+pub enum AdtKind { Struct, Union, Enum }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum VariantKind { Struct, Tuple, Unit }\n@@ -1552,8 +1510,10 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         if Some(did) == tcx.lang_items.phantom_data() {\n             flags = flags | AdtFlags::IS_PHANTOM_DATA;\n         }\n-        if let AdtKind::Enum = kind {\n-            flags = flags | AdtFlags::IS_ENUM;\n+        match kind {\n+            AdtKind::Enum => flags = flags | AdtFlags::IS_ENUM,\n+            AdtKind::Union => flags = flags | AdtFlags::IS_UNION,\n+            AdtKind::Struct => {}\n         }\n         AdtDefData {\n             did: did,\n@@ -1571,16 +1531,49 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK_VALID)\n     }\n \n+    #[inline]\n+    pub fn is_struct(&self) -> bool {\n+        !self.is_union() && !self.is_enum()\n+    }\n+\n+    #[inline]\n+    pub fn is_union(&self) -> bool {\n+        self.flags.get().intersects(AdtFlags::IS_UNION)\n+    }\n+\n+    #[inline]\n+    pub fn is_enum(&self) -> bool {\n+        self.flags.get().intersects(AdtFlags::IS_ENUM)\n+    }\n+\n     /// Returns the kind of the ADT - Struct or Enum.\n     #[inline]\n     pub fn adt_kind(&self) -> AdtKind {\n-        if self.flags.get().intersects(AdtFlags::IS_ENUM) {\n+        if self.is_enum() {\n             AdtKind::Enum\n+        } else if self.is_union() {\n+            AdtKind::Union\n         } else {\n             AdtKind::Struct\n         }\n     }\n \n+    pub fn descr(&self) -> &'static str {\n+        match self.adt_kind() {\n+            AdtKind::Struct => \"struct\",\n+            AdtKind::Union => \"union\",\n+            AdtKind::Enum => \"enum\",\n+        }\n+    }\n+\n+    pub fn variant_descr(&self) -> &'static str {\n+        match self.adt_kind() {\n+            AdtKind::Struct => \"struct\",\n+            AdtKind::Union => \"union\",\n+            AdtKind::Enum => \"variant\",\n+        }\n+    }\n+\n     /// Returns whether this is a dtorck type. If this returns\n     /// true, this type being safe for destruction requires it to be\n     /// alive; Otherwise, only the contents are required to be.\n@@ -1618,7 +1611,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     /// Asserts this is a struct and returns the struct's unique\n     /// variant.\n     pub fn struct_variant(&self) -> &VariantDefData<'gcx, 'container> {\n-        assert_eq!(self.adt_kind(), AdtKind::Struct);\n+        assert!(!self.is_enum());\n         &self.variants[0]\n     }\n \n@@ -1676,8 +1669,9 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n \n     pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n         match def {\n-            Def::Variant(_, vid) => self.variant_with_id(vid),\n-            Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => self.struct_variant(),\n+            Def::Variant(vid) => self.variant_with_id(vid),\n+            Def::Struct(..) | Def::Union(..) |\n+            Def::TyAlias(..) | Def::AssociatedTy(..) => self.struct_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n         }\n     }\n@@ -1820,13 +1814,13 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n             }\n \n             TyTuple(ref tys) => {\n-                // FIXME(#33242) we only need to constrain the last field\n-                tys.iter().flat_map(|ty| {\n-                    self.sized_constraint_for_ty(tcx, stack, ty)\n-                }).collect()\n+                match tys.last() {\n+                    None => vec![],\n+                    Some(ty) => self.sized_constraint_for_ty(tcx, stack, ty)\n+                }\n             }\n \n-            TyEnum(adt, substs) | TyStruct(adt, substs) => {\n+            TyAdt(adt, substs) => {\n                 // recursive case\n                 let adt = tcx.lookup_adt_def_master(adt.did);\n                 adt.calculate_sized_constraint_inner(tcx, stack);\n@@ -1935,7 +1929,7 @@ impl<'a, 'gcx, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n \n /// Records the substitutions used to translate the polytype for an\n /// item into the monotype of an item reference.\n-#[derive(Clone)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct ItemSubsts<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }\n@@ -2192,7 +2186,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    PatKind::Binding(_, ref path1, _) => path1.node.as_str(),\n+                    hir::PatKind::Binding(_, ref path1, _) => path1.node.as_str(),\n                     _ => {\n                         bug!(\"Variable id {} maps to {:?}, not local\", id, pat);\n                     },\n@@ -2255,84 +2249,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn provided_trait_methods(self, id: DefId) -> Vec<Rc<Method<'gcx>>> {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id).node {\n-                ms.iter().filter_map(|ti| {\n-                    if let hir::MethodTraitItem(_, Some(_)) = ti.node {\n-                        match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n-                            MethodTraitItem(m) => Some(m),\n-                            _ => {\n-                                bug!(\"provided_trait_methods(): \\\n-                                      non-method item found from \\\n-                                      looking up provided method?!\")\n-                            }\n-                        }\n-                    } else {\n-                        None\n-                    }\n-                }).collect()\n-            } else {\n-                bug!(\"provided_trait_methods: `{:?}` is not a trait\", id)\n+        self.impl_or_trait_items(id).iter().filter_map(|&def_id| {\n+            match self.impl_or_trait_item(def_id) {\n+                MethodTraitItem(ref m) if m.has_body => Some(m.clone()),\n+                _ => None\n             }\n-        } else {\n-            self.sess.cstore.provided_trait_methods(self.global_tcx(), id)\n-        }\n+        }).collect()\n     }\n \n-    pub fn associated_consts(self, id: DefId) -> Vec<Rc<AssociatedConst<'gcx>>> {\n+    pub fn trait_impl_polarity(self, id: DefId) -> hir::ImplPolarity {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             match self.map.expect_item(id).node {\n-                ItemTrait(_, _, _, ref tis) => {\n-                    tis.iter().filter_map(|ti| {\n-                        if let hir::ConstTraitItem(_, _) = ti.node {\n-                            match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n-                                ConstTraitItem(ac) => Some(ac),\n-                                _ => {\n-                                    bug!(\"associated_consts(): \\\n-                                          non-const item found from \\\n-                                          looking up a constant?!\")\n-                                }\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    }).collect()\n-                }\n-                ItemImpl(_, _, _, _, _, ref iis) => {\n-                    iis.iter().filter_map(|ii| {\n-                        if let hir::ImplItemKind::Const(_, _) = ii.node {\n-                            match self.impl_or_trait_item(self.map.local_def_id(ii.id)) {\n-                                ConstTraitItem(ac) => Some(ac),\n-                                _ => {\n-                                    bug!(\"associated_consts(): \\\n-                                          non-const item found from \\\n-                                          looking up a constant?!\")\n-                                }\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    }).collect()\n-                }\n-                _ => {\n-                    bug!(\"associated_consts: `{:?}` is not a trait or impl\", id)\n-                }\n-            }\n-        } else {\n-            self.sess.cstore.associated_consts(self.global_tcx(), id)\n-        }\n-    }\n-\n-    pub fn trait_impl_polarity(self, id: DefId) -> Option<hir::ImplPolarity> {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            match self.map.find(id) {\n-                Some(ast_map::NodeItem(item)) => {\n-                    match item.node {\n-                        hir::ItemImpl(_, polarity, _, _, _, _) => Some(polarity),\n-                        _ => None\n-                    }\n-                }\n-                _ => None\n+                hir::ItemImpl(_, polarity, ..) => polarity,\n+                ref item => bug!(\"trait_impl_polarity: {:?} not an impl\", item)\n             }\n         } else {\n             self.sess.cstore.impl_polarity(id)\n@@ -2365,10 +2294,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                    .expect(\"missing ImplOrTraitItem in metadata\"))\n     }\n \n-    pub fn trait_item_def_ids(self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n+    pub fn impl_or_trait_items(self, id: DefId) -> Rc<Vec<DefId>> {\n         lookup_locally_or_in_crate_store(\n-            \"trait_item_def_ids\", id, &self.trait_item_def_ids,\n-            || Rc::new(self.sess.cstore.trait_item_def_ids(id)))\n+            \"impl_or_trait_items\", id, &self.impl_or_trait_item_def_ids,\n+            || Rc::new(self.sess.cstore.impl_or_trait_items(id)))\n     }\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n@@ -2379,20 +2308,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             || self.sess.cstore.impl_trait_ref(self.global_tcx(), id))\n     }\n \n-    /// Returns whether this DefId refers to an impl\n-    pub fn is_impl(self, id: DefId) -> bool {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            if let Some(ast_map::NodeItem(\n-                &hir::Item { node: hir::ItemImpl(..), .. })) = self.map.find(id) {\n-                true\n-            } else {\n-                false\n-            }\n-        } else {\n-            self.sess.cstore.is_impl(id)\n-        }\n-    }\n-\n     /// Returns a path resolution for node id if it exists, panics otherwise.\n     pub fn expect_resolution(self, id: NodeId) -> PathResolution {\n         *self.def_map.borrow().get(&id).expect(\"no def-map entry for node id\")\n@@ -2413,10 +2328,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // or variant or their constructors, panics otherwise.\n     pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {\n         match def {\n-            Def::Variant(enum_did, did) => {\n+            Def::Variant(did) => {\n+                let enum_did = self.parent_def_id(did).unwrap();\n                 self.lookup_adt_def(enum_did).variant_with_id(did)\n             }\n-            Def::Struct(did) => {\n+            Def::Struct(did) | Def::Union(did) => {\n                 self.lookup_adt_def(did).struct_variant()\n             }\n             _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)\n@@ -2431,12 +2347,41 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns the `DefPath` of an item. Note that if `id` is not\n-    /// local to this crate -- or is inlined into this crate -- the\n-    /// result will be a non-local `DefPath`.\n+    /// Convert a `DefId` into its fully expanded `DefPath` (every\n+    /// `DefId` is really just an interned def-path).\n+    ///\n+    /// Note that if `id` is not local to this crate -- or is\n+    /// inlined into this crate -- the result will be a non-local\n+    /// `DefPath`.\n+    ///\n+    /// This function is only safe to use when you are sure that the\n+    /// full def-path is accessible. Examples that are known to be\n+    /// safe are local def-ids or items; see `opt_def_path` for more\n+    /// details.\n     pub fn def_path(self, id: DefId) -> ast_map::DefPath {\n+        self.opt_def_path(id).unwrap_or_else(|| {\n+            bug!(\"could not load def-path for {:?}\", id)\n+        })\n+    }\n+\n+    /// Convert a `DefId` into its fully expanded `DefPath` (every\n+    /// `DefId` is really just an interned def-path).\n+    ///\n+    /// When going across crates, we do not save the full info for\n+    /// every cross-crate def-id, and hence we may not always be able\n+    /// to create a def-path. Therefore, this returns\n+    /// `Option<DefPath>` to cover that possibility. It will always\n+    /// return `Some` for local def-ids, however, as well as for\n+    /// items. The problems arise with \"minor\" def-ids like those\n+    /// associated with a pattern, `impl Trait`, or other internal\n+    /// detail to a fn.\n+    ///\n+    /// Note that if `id` is not local to this crate -- or is\n+    /// inlined into this crate -- the result will be a non-local\n+    /// `DefPath`.\n+    pub fn opt_def_path(self, id: DefId) -> Option<ast_map::DefPath> {\n         if id.is_local() {\n-            self.map.def_path(id)\n+            Some(self.map.def_path(id))\n         } else {\n             self.sess.cstore.relative_def_path(id)\n         }\n@@ -2445,8 +2390,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn item_name(self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)\n+        } else if id.index == CRATE_DEF_INDEX {\n+            token::intern(&self.sess.cstore.original_crate_name(id.krate))\n         } else {\n-            self.sess.cstore.item_name(id)\n+            let def_key = self.sess.cstore.def_key(id);\n+            // The name of a StructCtor is that of its struct parent.\n+            if let ast_map::DefPathData::StructCtor = def_key.disambiguated_data.data {\n+                self.item_name(DefId {\n+                    krate: id.krate,\n+                    index: def_key.parent.unwrap()\n+                })\n+            } else {\n+                def_key.disambiguated_data.data.get_opt_name().unwrap_or_else(|| {\n+                    bug!(\"item_name: no name for {:?}\", self.def_path(id));\n+                })\n+            }\n         }\n     }\n \n@@ -2513,7 +2471,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn lookup_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"generics\", did, &self.generics,\n-            || self.sess.cstore.item_generics(self.global_tcx(), did))\n+            || self.alloc_generics(self.sess.cstore.item_generics(self.global_tcx(), did)))\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n@@ -2626,10 +2584,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\",\n                primitive_def_id);\n \n-        let impl_items = self.sess.cstore.impl_items(primitive_def_id);\n+        let impl_items = self.sess.cstore.impl_or_trait_items(primitive_def_id);\n \n         // Store the implementation info.\n-        self.impl_items.borrow_mut().insert(primitive_def_id, impl_items);\n+        self.impl_or_trait_item_def_ids.borrow_mut().insert(primitive_def_id, Rc::new(impl_items));\n         self.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n     }\n \n@@ -2655,11 +2613,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n         for &impl_def_id in &inherent_impls {\n             // Store the implementation info.\n-            let impl_items = self.sess.cstore.impl_items(impl_def_id);\n-            self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n+            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n+            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n         }\n \n-        self.inherent_impls.borrow_mut().insert(type_id, Rc::new(inherent_impls));\n+        self.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n         self.populated_external_types.borrow_mut().insert(type_id);\n     }\n \n@@ -2685,28 +2643,24 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.record_trait_has_default_impl(trait_id);\n         }\n \n-        for impl_def_id in self.sess.cstore.implementations_of_trait(trait_id) {\n-            let impl_items = self.sess.cstore.impl_items(impl_def_id);\n+        for impl_def_id in self.sess.cstore.implementations_of_trait(Some(trait_id)) {\n+            let impl_items = self.sess.cstore.impl_or_trait_items(impl_def_id);\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n \n             // Record the trait->implementation mapping.\n-            if let Some(parent) = self.sess.cstore.impl_parent(impl_def_id) {\n-                def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n-            } else {\n-                def.record_remote_impl(self, impl_def_id, trait_ref, trait_id);\n-            }\n+            let parent = self.sess.cstore.impl_parent(impl_def_id).unwrap_or(trait_id);\n+            def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n \n             // For any methods that use a default implementation, add them to\n             // the map. This is a bit unfortunate.\n-            for impl_item_def_id in &impl_items {\n-                let method_def_id = impl_item_def_id.def_id();\n+            for &impl_item_def_id in &impl_items {\n                 // load impl items eagerly for convenience\n                 // FIXME: we may want to load these lazily\n-                self.impl_or_trait_item(method_def_id);\n+                self.impl_or_trait_item(impl_item_def_id);\n             }\n \n             // Store the implementation info.\n-            self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n+            self.impl_or_trait_item_def_ids.borrow_mut().insert(impl_def_id, Rc::new(impl_items));\n         }\n \n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n@@ -2795,19 +2749,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// is already that of the original trait method, then the return value is\n     /// the same).\n     /// Otherwise, return `None`.\n-    pub fn trait_item_of_item(self, def_id: DefId) -> Option<ImplOrTraitItemId> {\n+    pub fn trait_item_of_item(self, def_id: DefId) -> Option<DefId> {\n         let impl_or_trait_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n             Some(m) => m.clone(),\n             None => return None,\n         };\n         match impl_or_trait_item.container() {\n-            TraitContainer(_) => Some(impl_or_trait_item.id()),\n+            TraitContainer(_) => Some(impl_or_trait_item.def_id()),\n             ImplContainer(def_id) => {\n                 self.trait_id_of_impl(def_id).and_then(|trait_did| {\n                     let name = impl_or_trait_item.name();\n                     self.trait_items(trait_did).iter()\n                         .find(|item| item.name() == name)\n-                        .map(|item| item.id())\n+                        .map(|item| item.def_id())\n                 })\n             }\n         }\n@@ -2939,7 +2893,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n /// The category of explicit self.\n-#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n+#[derive(Clone, Copy, Eq, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum ExplicitSelfCategory<'tcx> {\n     Static,\n     ByValue,"}, {"sha": "a4edd3b93c949535a38a55465093635225a7af3e", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -172,8 +172,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ty::TyUint(..) |        // OutlivesScalar\n             ty::TyFloat(..) |       // OutlivesScalar\n             ty::TyNever |           // ...\n-            ty::TyEnum(..) |        // OutlivesNominalType\n-            ty::TyStruct(..) |      // OutlivesNominalType\n+            ty::TyAdt(..) |         // OutlivesNominalType\n             ty::TyBox(..) |         // OutlivesNominalType (ish)\n             ty::TyAnon(..) |        // OutlivesNominalType (ish)\n             ty::TyStr |             // OutlivesScalar (ish)"}, {"sha": "b10c731fe27d00881faff1757c7cef9299eb2333", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -414,11 +414,11 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(a)\n         }\n \n-        (&ty::TyEnum(a_def, a_substs), &ty::TyEnum(b_def, b_substs))\n+        (&ty::TyAdt(a_def, a_substs), &ty::TyAdt(b_def, b_substs))\n             if a_def == b_def =>\n         {\n             let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n-            Ok(tcx.mk_enum(a_def, substs))\n+            Ok(tcx.mk_adt(a_def, substs))\n         }\n \n         (&ty::TyTrait(ref a_obj), &ty::TyTrait(ref b_obj)) =>\n@@ -440,13 +440,6 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             }))\n         }\n \n-        (&ty::TyStruct(a_def, a_substs), &ty::TyStruct(b_def, b_substs))\n-            if a_def == b_def =>\n-        {\n-            let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n-            Ok(tcx.mk_struct(a_def, substs))\n-        }\n-\n         (&ty::TyClosure(a_id, a_substs),\n          &ty::TyClosure(b_id, b_substs))\n             if a_id == b_id =>"}, {"sha": "5a87ea1473d982fbda294e9dc4f5e13566aa2faf", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -14,7 +14,6 @@ use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::rc::Rc;\n use syntax::abi;\n-use syntax::ptr::P;\n \n use hir;\n \n@@ -178,9 +177,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n             ty::Predicate::WellFormed(ty) => {\n                 tcx.lift(&ty).map(ty::Predicate::WellFormed)\n             }\n-            ty::Predicate::Rfc1592(box ref a) => {\n-                tcx.lift(a).map(|a| ty::Predicate::Rfc1592(Box::new(a)))\n-            }\n             ty::Predicate::ClosureKind(closure_def_id, kind) => {\n                 Some(ty::Predicate::ClosureKind(closure_def_id, kind))\n             }\n@@ -440,16 +436,6 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        self.iter().map(|t| t.fold_with(folder)).collect()\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TraitObject {\n@@ -467,7 +453,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx [Ty<'tcx>] {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<Ty<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let tys = self.iter().map(|t| t.fold_with(folder)).collect();\n         folder.tcx().mk_type_list(tys)\n@@ -485,7 +471,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyRawPtr(tm) => ty::TyRawPtr(tm.fold_with(folder)),\n             ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz),\n             ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n-            ty::TyEnum(tid, substs) => ty::TyEnum(tid, substs.fold_with(folder)),\n+            ty::TyAdt(tid, substs) => ty::TyAdt(tid, substs.fold_with(folder)),\n             ty::TyTrait(ref trait_ty) => ty::TyTrait(trait_ty.fold_with(folder)),\n             ty::TyTuple(ts) => ty::TyTuple(ts.fold_with(folder)),\n             ty::TyFnDef(def_id, substs, f) => {\n@@ -497,7 +483,6 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyRef(ref r, tm) => {\n                 ty::TyRef(r.fold_with(folder), tm.fold_with(folder))\n             }\n-            ty::TyStruct(did, substs) => ty::TyStruct(did, substs.fold_with(folder)),\n             ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n             ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n             ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n@@ -518,15 +503,14 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyRawPtr(ref tm) => tm.visit_with(visitor),\n             ty::TyArray(typ, _sz) => typ.visit_with(visitor),\n             ty::TySlice(typ) => typ.visit_with(visitor),\n-            ty::TyEnum(_tid, ref substs) => substs.visit_with(visitor),\n+            ty::TyAdt(_, substs) => substs.visit_with(visitor),\n             ty::TyTrait(ref trait_ty) => trait_ty.visit_with(visitor),\n             ty::TyTuple(ts) => ts.visit_with(visitor),\n             ty::TyFnDef(_, substs, ref f) => {\n                 substs.visit_with(visitor) || f.visit_with(visitor)\n             }\n             ty::TyFnPtr(ref f) => f.visit_with(visitor),\n             ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n-            ty::TyStruct(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyProjection(ref data) => data.visit_with(visitor),\n             ty::TyAnon(_, ref substs) => substs.visit_with(visitor),\n@@ -790,8 +774,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n         match *self {\n             ty::Predicate::Trait(ref a) =>\n                 ty::Predicate::Trait(a.fold_with(folder)),\n-            ty::Predicate::Rfc1592(ref a) =>\n-                ty::Predicate::Rfc1592(a.fold_with(folder)),\n             ty::Predicate::Equate(ref binder) =>\n                 ty::Predicate::Equate(binder.fold_with(folder)),\n             ty::Predicate::RegionOutlives(ref binder) =>\n@@ -812,7 +794,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n             ty::Predicate::Trait(ref a) => a.visit_with(visitor),\n-            ty::Predicate::Rfc1592(ref a) => a.visit_with(visitor),\n             ty::Predicate::Equate(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::RegionOutlives(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::TypeOutlives(ref binder) => binder.visit_with(visitor),"}, {"sha": "302cab0446cd3178e6048f342d1b02e9ab83e14f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 65, "deletions": 91, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -10,29 +10,28 @@\n \n //! This module contains TypeVariants and its major components\n \n-use middle::cstore;\n use hir::def_id::DefId;\n use middle::region;\n use ty::subst::Substs;\n-use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TyS, TypeFoldable};\n+use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TypeFoldable};\n+use ty::{Slice, TyS};\n use util::common::ErrorReported;\n \n use collections::enum_set::{self, EnumSet, CLike};\n use std::fmt;\n-use std::mem;\n use std::ops;\n use syntax::abi;\n use syntax::ast::{self, Name};\n-use syntax::parse::token::keywords;\n+use syntax::parse::token::{keywords, InternedString};\n \n-use serialize::{Decodable, Decoder, Encodable, Encoder};\n+use serialize;\n \n use hir;\n \n use self::InferTy::*;\n use self::TypeVariants::*;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct TypeAndMut<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub mutbl: hir::Mutability,\n@@ -88,7 +87,7 @@ pub enum Issue32330 {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum TypeVariants<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n     TyBool,\n@@ -106,19 +105,13 @@ pub enum TypeVariants<'tcx> {\n     /// A primitive floating-point type. For example, `f64`.\n     TyFloat(ast::FloatTy),\n \n-    /// An enumerated type, defined with `enum`.\n+    /// Structures, enumerations and unions.\n     ///\n     /// Substs here, possibly against intuition, *may* contain `TyParam`s.\n     /// That is, even after substitution it is possible that there are type\n-    /// variables. This happens when the `TyEnum` corresponds to an enum\n-    /// definition and not a concrete use of it. This is true for `TyStruct`\n-    /// as well.\n-    TyEnum(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n-\n-    /// A structure type, defined with `struct`.\n-    ///\n-    /// See warning about substitutions for enumerated types.\n-    TyStruct(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n+    /// variables. This happens when the `TyAdt` corresponds to an ADT\n+    /// definition and not a concrete use of it.\n+    TyAdt(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n \n     /// `Box<T>`; this is nominally a struct in the documentation, but is\n     /// special-cased internally. For example, it is possible to implicitly\n@@ -162,7 +155,7 @@ pub enum TypeVariants<'tcx> {\n     TyNever,\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    TyTuple(&'tcx [Ty<'tcx>]),\n+    TyTuple(&'tcx Slice<Ty<'tcx>>),\n \n     /// The projection of an associated type.  For example,\n     /// `<T as Trait<..>>::N`.\n@@ -259,7 +252,7 @@ pub enum TypeVariants<'tcx> {\n /// closure C wind up influencing the decisions we ought to make for\n /// closure C (which would then require fixed point iteration to\n /// handle). Plus it fixes an ICE. :P\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function.\n     /// These are separated out because trans wants to pass them around\n@@ -269,28 +262,10 @@ pub struct ClosureSubsts<'tcx> {\n     /// The types of the upvars. The list parallels the freevars and\n     /// `upvar_borrows` lists. These are kept distinct so that we can\n     /// easily index into them.\n-    pub upvar_tys: &'tcx [Ty<'tcx>]\n-}\n-\n-impl<'tcx> Encodable for ClosureSubsts<'tcx> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (self.func_substs, self.upvar_tys).encode(s)\n-    }\n-}\n-\n-impl<'tcx> Decodable for ClosureSubsts<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<ClosureSubsts<'tcx>, D::Error> {\n-        let (func_substs, upvar_tys) = Decodable::decode(d)?;\n-        cstore::tls::with_decoding_context(d, |dcx, _| {\n-            Ok(ClosureSubsts {\n-                func_substs: func_substs,\n-                upvar_tys: dcx.tcx().mk_type_list(upvar_tys)\n-            })\n-        })\n-    }\n+    pub upvar_tys: &'tcx Slice<Ty<'tcx>>\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitObject<'tcx> {\n     pub principal: PolyExistentialTraitRef<'tcx>,\n     pub region_bound: &'tcx ty::Region,\n@@ -313,7 +288,7 @@ pub struct TraitObject<'tcx> {\n /// Note that a `TraitRef` introduces a level of region binding, to\n /// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n /// U>` or higher-ranked object types.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n@@ -353,7 +328,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n ///\n /// The substitutions don't include the erased `Self`, only trait\n /// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ExistentialTraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n@@ -389,7 +364,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// erase, or otherwise \"discharge\" these bound regions, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Binder<T>(pub T);\n \n impl<T> Binder<T> {\n@@ -437,7 +412,7 @@ impl fmt::Debug for TypeFlags {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ProjectionTy<'tcx> {\n     /// The trait reference `T as Trait<..>`.\n     pub trait_ref: ty::TraitRef<'tcx>,\n@@ -446,20 +421,16 @@ pub struct ProjectionTy<'tcx> {\n     pub item_name: Name,\n }\n \n-impl<'tcx> ProjectionTy<'tcx> {\n-    pub fn sort_key(&self) -> (DefId, Name) {\n-        (self.trait_ref.def_id, self.item_name)\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct BareFnTy<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n     pub sig: PolyFnSig<'tcx>,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx BareFnTy<'tcx> {}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ClosureTy<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n@@ -472,7 +443,7 @@ pub struct ClosureTy<'tcx> {\n /// - `inputs` is the list of arguments and their modes.\n /// - `output` is the return type.\n /// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct FnSig<'tcx> {\n     pub inputs: Vec<Ty<'tcx>>,\n     pub output: Ty<'tcx>,\n@@ -496,7 +467,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ParamTy {\n     pub idx: u32,\n     pub name: Name,\n@@ -675,32 +646,25 @@ pub enum Region {\n     ReErased,\n }\n \n-impl<'tcx> Decodable for &'tcx Region {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Region, D::Error> {\n-        let r = Decodable::decode(d)?;\n-        cstore::tls::with_decoding_context(d, |dcx, _| {\n-            Ok(dcx.tcx().mk_region(r))\n-        })\n-    }\n-}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Region {}\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n     pub index: u32,\n     pub name: Name,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TyVid {\n     pub index: u32,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct IntVid {\n     pub index: u32\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct FloatVid {\n     pub index: u32\n }\n@@ -715,7 +679,7 @@ pub struct SkolemizedRegionVid {\n     pub index: u32\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n@@ -730,7 +694,7 @@ pub enum InferTy {\n }\n \n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExistentialProjection<'tcx> {\n     pub trait_ref: ExistentialTraitRef<'tcx>,\n     pub item_name: Name,\n@@ -744,8 +708,17 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n         self.0.item_name // safe to skip the binder to access a name\n     }\n \n-    pub fn sort_key(&self) -> (DefId, Name) {\n-        (self.0.trait_ref.def_id, self.0.item_name)\n+    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (u64, InternedString) {\n+        // We want something here that is stable across crate boundaries.\n+        // The DefId isn't but the `deterministic_hash` of the corresponding\n+        // DefPath is.\n+        let trait_def = tcx.lookup_trait_def(self.0.trait_ref.def_id);\n+        let def_path_hash = trait_def.def_path_hash;\n+\n+        // An `ast::Name` is also not stable (it's just an index into an\n+        // interning table), so map to the corresponding `InternedString`.\n+        let item_name = self.0.item_name.as_str();\n+        (def_path_hash, item_name)\n     }\n \n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -766,7 +739,7 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n \n impl<'a, 'gcx, 'tcx> BuiltinBounds {\n@@ -809,20 +782,25 @@ impl<'a> IntoIterator for &'a BuiltinBounds {\n \n #[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n            Debug, Copy)]\n-#[repr(usize)]\n pub enum BuiltinBound {\n-    Send,\n-    Sized,\n-    Copy,\n-    Sync,\n+    Send = 0,\n+    Sized = 1,\n+    Copy = 2,\n+    Sync = 3,\n }\n \n impl CLike for BuiltinBound {\n     fn to_usize(&self) -> usize {\n         *self as usize\n     }\n     fn from_usize(v: usize) -> BuiltinBound {\n-        unsafe { mem::transmute(v) }\n+        match v {\n+            0 => BuiltinBound::Send,\n+            1 => BuiltinBound::Sized,\n+            2 => BuiltinBound::Copy,\n+            3 => BuiltinBound::Sync,\n+            _ => bug!(\"{} is not a valid BuiltinBound\", v)\n+        }\n     }\n }\n \n@@ -917,7 +895,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         // FIXME(#24885): be smarter here, the AdtDefData::is_empty method could easily be made\n         // more complete.\n         match self.sty {\n-            TyEnum(def, _) | TyStruct(def, _) => def.is_empty(),\n+            TyAdt(def, _) => def.is_empty(),\n \n             // FIXME(canndrew): There's no reason why these can't be uncommented, they're tested\n             // and they don't break anything. But I'm keeping my changes small for now.\n@@ -945,7 +923,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n \n     pub fn is_phantom_data(&self) -> bool {\n-        if let TyStruct(def, _) = self.sty {\n+        if let TyAdt(def, _) = self.sty {\n             def.is_phantom_data()\n         } else {\n             false\n@@ -980,16 +958,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_structural(&self) -> bool {\n         match self.sty {\n-            TyStruct(..) | TyTuple(_) | TyEnum(..) |\n-            TyArray(..) | TyClosure(..) => true,\n+            TyAdt(..) | TyTuple(..) | TyArray(..) | TyClosure(..) => true,\n             _ => self.is_slice() | self.is_trait()\n         }\n     }\n \n     #[inline]\n     pub fn is_simd(&self) -> bool {\n         match self.sty {\n-            TyStruct(def, _) => def.is_simd(),\n+            TyAdt(def, _) => def.is_simd(),\n             _ => false\n         }\n     }\n@@ -1004,7 +981,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn simd_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n-            TyStruct(def, substs) => {\n+            TyAdt(def, substs) => {\n                 def.struct_variant().fields[0].ty(tcx, substs)\n             }\n             _ => bug!(\"simd_type called on invalid type\")\n@@ -1013,7 +990,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn simd_size(&self, _cx: TyCtxt) -> usize {\n         match self.sty {\n-            TyStruct(def, _) => def.struct_variant().fields.len(),\n+            TyAdt(def, _) => def.struct_variant().fields.len(),\n             _ => bug!(\"simd_size called on invalid type\")\n         }\n     }\n@@ -1166,15 +1143,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn fn_sig(&self) -> &'tcx PolyFnSig<'tcx> {\n         match self.sty {\n-            TyFnDef(_, _, ref f) | TyFnPtr(ref f) => &f.sig,\n+            TyFnDef(.., ref f) | TyFnPtr(ref f) => &f.sig,\n             _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }\n \n     /// Returns the ABI of the given function.\n     pub fn fn_abi(&self) -> abi::Abi {\n         match self.sty {\n-            TyFnDef(_, _, ref f) | TyFnPtr(ref f) => f.abi,\n+            TyFnDef(.., ref f) | TyFnPtr(ref f) => f.abi,\n             _ => bug!(\"Ty::fn_abi() called on non-fn type\"),\n         }\n     }\n@@ -1198,16 +1175,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     pub fn ty_to_def_id(&self) -> Option<DefId> {\n         match self.sty {\n             TyTrait(ref tt) => Some(tt.principal.def_id()),\n-            TyStruct(def, _) |\n-            TyEnum(def, _) => Some(def.did),\n+            TyAdt(def, _) => Some(def.did),\n             TyClosure(id, _) => Some(id),\n             _ => None\n         }\n     }\n \n     pub fn ty_adt_def(&self) -> Option<AdtDef<'tcx>> {\n         match self.sty {\n-            TyStruct(adt, _) | TyEnum(adt, _) => Some(adt),\n+            TyAdt(adt, _) => Some(adt),\n             _ => None\n         }\n     }\n@@ -1225,9 +1201,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 v.extend(obj.principal.skip_binder().substs.regions());\n                 v\n             }\n-            TyEnum(_, substs) |\n-            TyStruct(_, substs) |\n-            TyAnon(_, substs) => {\n+            TyAdt(_, substs) | TyAnon(_, substs) => {\n                 substs.regions().collect()\n             }\n             TyClosure(_, ref substs) => {\n@@ -1245,7 +1219,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             TyFloat(_) |\n             TyBox(_) |\n             TyStr |\n-            TyArray(_, _) |\n+            TyArray(..) |\n             TySlice(_) |\n             TyRawPtr(_) |\n             TyNever |"}, {"sha": "6911d2174260db022fdf256a407e0ecd2412fcbb", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -10,12 +10,11 @@\n \n // Type substitutions.\n \n-use middle::cstore;\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n-use serialize::{Encodable, Encoder, Decodable, Decoder};\n+use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n \n use core::nonzero::NonZero;\n@@ -129,8 +128,40 @@ impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n     }\n }\n \n+impl<'tcx> Encodable for Kind<'tcx> {\n+    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+        e.emit_enum(\"Kind\", |e| {\n+            if let Some(ty) = self.as_type() {\n+                e.emit_enum_variant(\"Ty\", TYPE_TAG, 1, |e| {\n+                    e.emit_enum_variant_arg(0, |e| ty.encode(e))\n+                })\n+            } else if let Some(r) = self.as_region() {\n+                e.emit_enum_variant(\"Region\", REGION_TAG, 1, |e| {\n+                    e.emit_enum_variant_arg(0, |e| r.encode(e))\n+                })\n+            } else {\n+                bug!()\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx> Decodable for Kind<'tcx> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Kind<'tcx>, D::Error> {\n+        d.read_enum(\"Kind\", |d| {\n+            d.read_enum_variant(&[\"Ty\", \"Region\"], |d, tag| {\n+                match tag {\n+                    TYPE_TAG => Ty::decode(d).map(Kind::from),\n+                    REGION_TAG => <&ty::Region>::decode(d).map(Kind::from),\n+                    _ => Err(d.error(\"invalid Kind tag\"))\n+                }\n+            })\n+        })\n+    }\n+}\n+\n /// A substitution mapping type/region parameters to new values.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct Substs<'tcx> {\n     params: Vec<Kind<'tcx>>\n }\n@@ -298,25 +329,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n-impl<'tcx> Encodable for &'tcx Substs<'tcx> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n-            ecx.encode_substs(rbml_w, self);\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<'tcx> Decodable for &'tcx Substs<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Substs<'tcx>, D::Error> {\n-        let substs = cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n-            dcx.decode_substs(rbml_r)\n-        });\n-\n-        Ok(substs)\n-    }\n-}\n-\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`"}, {"sha": "3ff2ed76e571e3a8b308657186d9a069331e57cf", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -15,7 +15,6 @@ use ty;\n use ty::fast_reject;\n use ty::{Ty, TyCtxt, TraitRef};\n use std::cell::{Cell, RefCell};\n-use syntax::ast::Name;\n use hir;\n use util::nodemap::FnvHashMap;\n \n@@ -38,10 +37,6 @@ pub struct TraitDef<'tcx> {\n \n     pub trait_ref: ty::TraitRef<'tcx>,\n \n-    /// A list of the associated types defined in this trait. Useful\n-    /// for resolving `X::Foo` type markers.\n-    pub associated_type_names: Vec<Name>,\n-\n     // Impls of a trait. To allow for quicker lookup, the impls are indexed by a\n     // simplified version of their `Self` type: impls with a simplifiable `Self`\n     // are stored in `nonblanket_impls` keyed by it, while all other impls are\n@@ -70,26 +65,30 @@ pub struct TraitDef<'tcx> {\n     pub specialization_graph: RefCell<traits::specialization_graph::Graph>,\n \n     /// Various flags\n-    pub flags: Cell<TraitFlags>\n+    pub flags: Cell<TraitFlags>,\n+\n+    /// The ICH of this trait's DefPath, cached here so it doesn't have to be\n+    /// recomputed all the time.\n+    pub def_path_hash: u64,\n }\n \n impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     pub fn new(unsafety: hir::Unsafety,\n                paren_sugar: bool,\n                generics: &'tcx ty::Generics<'tcx>,\n                trait_ref: ty::TraitRef<'tcx>,\n-               associated_type_names: Vec<Name>)\n+               def_path_hash: u64)\n                -> TraitDef<'tcx> {\n         TraitDef {\n             paren_sugar: paren_sugar,\n             unsafety: unsafety,\n             generics: generics,\n             trait_ref: trait_ref,\n-            associated_type_names: associated_type_names,\n             nonblanket_impls: RefCell::new(FnvHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n             specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),\n+            def_path_hash: def_path_hash,\n         }\n     }\n "}, {"sha": "d834a7d485a389fb5ad7b44d52f0ee3512aa22fe", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 84, "deletions": 102, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::DefId;\n use infer::InferCtxt;\n use hir::pat_util;\n use traits::{self, Reveal};\n-use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n+use ty::{self, Ty, AdtKind, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n@@ -138,28 +138,30 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n         // FIXME: (@jroesch) float this code up\n         tcx.infer_ctxt(None, Some(self.clone()), Reveal::ExactMatch).enter(|infcx| {\n             let adt = match self_type.sty {\n-                ty::TyStruct(struct_def, substs) => {\n-                    for field in struct_def.all_fields() {\n-                        let field_ty = field.ty(tcx, substs);\n-                        if infcx.type_moves_by_default(field_ty, span) {\n-                            return Err(CopyImplementationError::InfrigingField(\n-                                field.name))\n-                        }\n-                    }\n-                    struct_def\n-                }\n-                ty::TyEnum(enum_def, substs) => {\n-                    for variant in &enum_def.variants {\n-                        for field in &variant.fields {\n+                ty::TyAdt(adt, substs) => match adt.adt_kind() {\n+                    AdtKind::Struct | AdtKind::Union => {\n+                        for field in adt.all_fields() {\n                             let field_ty = field.ty(tcx, substs);\n                             if infcx.type_moves_by_default(field_ty, span) {\n-                                return Err(CopyImplementationError::InfrigingVariant(\n-                                    variant.name))\n+                                return Err(CopyImplementationError::InfrigingField(\n+                                    field.name))\n                             }\n                         }\n+                        adt\n                     }\n-                    enum_def\n-                }\n+                    AdtKind::Enum => {\n+                        for variant in &adt.variants {\n+                            for field in &variant.fields {\n+                                let field_ty = field.ty(tcx, substs);\n+                                if infcx.type_moves_by_default(field_ty, span) {\n+                                    return Err(CopyImplementationError::InfrigingVariant(\n+                                        variant.name))\n+                                }\n+                            }\n+                        }\n+                        adt\n+                    }\n+                },\n                 _ => return Err(CopyImplementationError::NotAnAdt)\n             };\n \n@@ -183,7 +185,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 for field in def.all_fields() {\n                     let field_ty = field.ty(self, substs);\n                     if let TyError = field_ty.sty {\n@@ -203,15 +205,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  i: usize,\n                                  variant: Option<DefId>) -> Option<Ty<'tcx>> {\n         match (&ty.sty, variant) {\n-            (&TyStruct(def, substs), None) => {\n-                def.struct_variant().fields.get(i).map(|f| f.ty(self, substs))\n-            }\n-            (&TyEnum(def, substs), Some(vid)) => {\n-                def.variant_with_id(vid).fields.get(i).map(|f| f.ty(self, substs))\n+            (&TyAdt(adt, substs), Some(vid)) => {\n+                adt.variant_with_id(vid).fields.get(i).map(|f| f.ty(self, substs))\n             }\n-            (&TyEnum(def, substs), None) => {\n-                assert!(def.is_univariant());\n-                def.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n+            (&TyAdt(adt, substs), None) => {\n+                // Don't use `struct_variant`, this may be a univariant enum.\n+                adt.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n             }\n             (&TyTuple(ref v), None) => v.get(i).cloned(),\n             _ => None\n@@ -225,11 +224,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                             n: Name,\n                             variant: Option<DefId>) -> Option<Ty<'tcx>> {\n         match (&ty.sty, variant) {\n-            (&TyStruct(def, substs), None) => {\n-                def.struct_variant().find_field_named(n).map(|f| f.ty(self, substs))\n+            (&TyAdt(adt, substs), Some(vid)) => {\n+                adt.variant_with_id(vid).find_field_named(n).map(|f| f.ty(self, substs))\n             }\n-            (&TyEnum(def, substs), Some(vid)) => {\n-                def.variant_with_id(vid).find_field_named(n).map(|f| f.ty(self, substs))\n+            (&TyAdt(adt, substs), None) => {\n+                adt.struct_variant().find_field_named(n).map(|f| f.ty(self, substs))\n             }\n             _ => return None\n         }\n@@ -241,7 +240,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn enum_repr_type(self, opt_hint: Option<&attr::ReprAttr>) -> attr::IntType {\n         match opt_hint {\n             // Feed in the given type\n-            Some(&attr::ReprInt(_, int_t)) => int_t,\n+            Some(&attr::ReprInt(int_t)) => int_t,\n             // ... but provide sensible default if none provided\n             //\n             // NB. Historically `fn enum_variants` generate i64 here, while\n@@ -254,7 +253,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy.\n     pub fn struct_tail(self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        while let TyStruct(def, substs) = ty.sty {\n+        while let TyAdt(def, substs) = ty.sty {\n+            if !def.is_struct() {\n+                break\n+            }\n             match def.struct_variant().fields.last() {\n                 Some(f) => ty = f.ty(self, substs),\n                 None => break\n@@ -273,15 +275,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  target: Ty<'tcx>)\n                                  -> (Ty<'tcx>, Ty<'tcx>) {\n         let (mut a, mut b) = (source, target);\n-        while let (&TyStruct(a_def, a_substs), &TyStruct(b_def, b_substs)) = (&a.sty, &b.sty) {\n-            if a_def != b_def {\n-                break;\n+        while let (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs)) = (&a.sty, &b.sty) {\n+            if a_def != b_def || !a_def.is_struct() {\n+                break\n             }\n-            if let Some(f) = a_def.struct_variant().fields.last() {\n-                a = f.ty(self, a_substs);\n-                b = f.ty(self, b_substs);\n-            } else {\n-                break;\n+            match a_def.struct_variant().fields.last() {\n+                Some(f) => {\n+                    a = f.ty(self, a_substs);\n+                    b = f.ty(self, b_substs);\n+                }\n+                _ => break\n             }\n         }\n         (a, b)\n@@ -318,7 +321,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 match predicate {\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::Trait(..) |\n-                    ty::Predicate::Rfc1592(..) |\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n@@ -350,12 +352,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n-        let mut hasher = TypeIdHasher {\n-            tcx: self,\n-            state: SipHasher::new()\n-        };\n+        let mut hasher = TypeIdHasher::new(self, SipHasher::new());\n         hasher.visit_ty(ty);\n-        hasher.state.finish()\n+        hasher.finish()\n     }\n \n     /// Returns true if this ADT is a dtorck type.\n@@ -389,16 +388,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, H> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: SipHasher\n+    state: H\n }\n \n-impl<'a, 'gcx, 'tcx> TypeIdHasher<'a, 'gcx, 'tcx> {\n-    fn hash<T: Hash>(&mut self, x: T) {\n+impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, state: H) -> Self {\n+        TypeIdHasher {\n+            tcx: tcx,\n+            state: state\n+        }\n+    }\n+\n+    pub fn hash<T: Hash>(&mut self, x: T) {\n         x.hash(&mut self.state);\n     }\n \n+    pub fn finish(self) -> u64 {\n+        self.state.finish()\n+    }\n+\n     fn hash_discriminant_u8<T>(&mut self, x: &T) {\n         let v = unsafe {\n             intrinsics::discriminant_value(x)\n@@ -409,19 +419,15 @@ impl<'a, 'gcx, 'tcx> TypeIdHasher<'a, 'gcx, 'tcx> {\n     }\n \n     fn def_id(&mut self, did: DefId) {\n-        // Hash the crate identification information.\n-        let name = self.tcx.crate_name(did.krate);\n-        let disambiguator = self.tcx.crate_disambiguator(did.krate);\n-        self.hash((name, disambiguator));\n-\n-        // Hash the item path within that crate.\n-        // FIXME(#35379) This should use a deterministic\n-        // DefPath hashing mechanism, not the DefIndex.\n-        self.hash(did.index);\n+        // Hash the DefPath corresponding to the DefId, which is independent\n+        // of compiler internal state.\n+        let tcx = self.tcx;\n+        let def_path = tcx.def_path(did);\n+        def_path.deterministic_hash_to(tcx, &mut self.state);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         // Distinguish between the Ty variants uniformly.\n         self.hash_discriminant_u8(&ty.sty);\n@@ -430,47 +436,22 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n             TyInt(i) => self.hash(i),\n             TyUint(u) => self.hash(u),\n             TyFloat(f) => self.hash(f),\n-            TyStruct(d, _) |\n-            TyEnum(d, _) => self.def_id(d.did),\n             TyArray(_, n) => self.hash(n),\n             TyRawPtr(m) |\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |\n             TyAnon(def_id, _) |\n-            TyFnDef(def_id, _, _) => self.def_id(def_id),\n+            TyFnDef(def_id, ..) => self.def_id(def_id),\n+            TyAdt(d, _) => self.def_id(d.did),\n             TyFnPtr(f) => {\n                 self.hash(f.unsafety);\n                 self.hash(f.abi);\n                 self.hash(f.sig.variadic());\n+                self.hash(f.sig.inputs().skip_binder().len());\n             }\n             TyTrait(ref data) => {\n-                // Trait objects have a list of projection bounds\n-                // that are not guaranteed to be sorted in an order\n-                // that gets preserved across crates, so we need\n-                // to sort them again by the name, in string form.\n-\n-                // Hash the whole principal trait ref.\n                 self.def_id(data.principal.def_id());\n-                data.principal.visit_with(self);\n-\n-                // Hash region and builtin bounds.\n-                data.region_bound.visit_with(self);\n                 self.hash(data.builtin_bounds);\n-\n-                // Only projection bounds are left, sort and hash them.\n-                let mut projection_bounds: Vec<_> = data.projection_bounds\n-                                                        .iter()\n-                                                        .map(|b| (b.item_name().as_str(), b))\n-                                                        .collect();\n-                projection_bounds.sort_by_key(|&(ref name, _)| name.clone());\n-                for (name, bound) in projection_bounds {\n-                    self.def_id(bound.0.trait_ref.def_id);\n-                    self.hash(name);\n-                    bound.visit_with(self);\n-                }\n-\n-                // Bypass super_visit_with, we've visited everything.\n-                return false;\n             }\n             TyTuple(tys) => {\n                 self.hash(tys.len());\n@@ -488,32 +469,34 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n             TyChar |\n             TyStr |\n             TyBox(_) |\n-            TySlice(_) |\n-            TyError => {}\n-            TyInfer(_) => bug!()\n+            TySlice(_) => {}\n+\n+            TyError |\n+            TyInfer(_) => bug!(\"TypeIdHasher: unexpected type {}\", ty)\n         }\n \n         ty.super_visit_with(self)\n     }\n \n     fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n         match *r {\n-            ty::ReStatic | ty::ReErased => {\n+            ty::ReErased => {\n                 self.hash::<u32>(0);\n             }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 assert!(db.depth > 0);\n                 self.hash::<u32>(db.depth);\n                 self.hash(i);\n             }\n+            ty::ReStatic |\n             ty::ReEmpty |\n             ty::ReEarlyBound(..) |\n             ty::ReLateBound(..) |\n             ty::ReFree(..) |\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n             ty::ReSkolemized(..) => {\n-                bug!(\"unexpected region found when hashing a type\")\n+                bug!(\"TypeIdHasher: unexpected region {:?}\", r)\n             }\n         }\n         false\n@@ -558,8 +541,8 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 mutbl: hir::MutMutable, ..\n             }) => Some(true),\n \n-            TyArray(..) | TySlice(_) | TyTrait(..) | TyTuple(..) |\n-            TyClosure(..) | TyEnum(..) | TyStruct(..) | TyAnon(..) |\n+            TyArray(..) | TySlice(..) | TyTrait(..) | TyTuple(..) |\n+            TyClosure(..) | TyAdt(..) | TyAnon(..) |\n             TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n         }.unwrap_or_else(|| !self.impls_bound(tcx, param_env, ty::BoundCopy, span));\n \n@@ -599,7 +582,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n             TyStr | TyTrait(..) | TySlice(_) => Some(false),\n \n-            TyEnum(..) | TyStruct(..) | TyProjection(..) | TyParam(..) |\n+            TyAdt(..) | TyProjection(..) | TyParam(..) |\n             TyInfer(..) | TyAnon(..) | TyError => None\n         }.unwrap_or_else(|| self.impls_bound(tcx, param_env, ty::BoundSized, span));\n \n@@ -661,7 +644,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 TyArray(ty, _) => {\n                     is_type_structurally_recursive(tcx, sp, seen, ty)\n                 }\n-                TyStruct(def, substs) | TyEnum(def, substs) => {\n+                TyAdt(def, substs) => {\n                     find_nonrepresentable(tcx,\n                                           sp,\n                                           seen,\n@@ -678,7 +661,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n             match ty.sty {\n-                TyStruct(ty_def, _) | TyEnum(ty_def, _) => {\n+                TyAdt(ty_def, _) => {\n                      ty_def == def\n                 }\n                 _ => false\n@@ -687,8 +670,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         fn same_type<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n             match (&a.sty, &b.sty) {\n-                (&TyStruct(did_a, ref substs_a), &TyStruct(did_b, ref substs_b)) |\n-                (&TyEnum(did_a, ref substs_a), &TyEnum(did_b, ref substs_b)) => {\n+                (&TyAdt(did_a, substs_a), &TyAdt(did_b, substs_b)) => {\n                     if did_a != did_b {\n                         return false;\n                     }\n@@ -710,7 +692,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             debug!(\"is_type_structurally_recursive: {:?}\", ty);\n \n             match ty.sty {\n-                TyStruct(def, _) | TyEnum(def, _) => {\n+                TyAdt(def, _) => {\n                     {\n                         // Iterate through stack of previously seen types.\n                         let mut iter = seen.iter();"}, {"sha": "dd3a62f7cd2dd0d5ee4071520c037cb259a68710", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -93,9 +93,7 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n                 pred.0.ty\n             }).rev());\n         }\n-        ty::TyEnum(_, ref substs) |\n-        ty::TyStruct(_, ref substs) |\n-        ty::TyAnon(_, ref substs) => {\n+        ty::TyAdt(_, substs) | ty::TyAnon(_, substs) => {\n             stack.extend(substs.types().rev());\n         }\n         ty::TyClosure(_, ref substs) => {"}, {"sha": "0557660e98c2f7d0a7890f6617598492c3302529", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -94,9 +94,6 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n         }\n         ty::Predicate::ClosureKind(..) => {\n         }\n-        ty::Predicate::Rfc1592(ref data) => {\n-            bug!(\"RFC1592 predicate `{:?}` in predicate_obligations\", data);\n-        }\n     }\n \n     wf.normalize()\n@@ -158,7 +155,6 @@ pub fn implied_bounds<'a, 'gcx, 'tcx>(\n                 assert!(!obligation.has_escaping_regions());\n                 match obligation.predicate {\n                     ty::Predicate::Trait(..) |\n-                    ty::Predicate::Rfc1592(..) |\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::ClosureKind(..) |\n@@ -282,21 +278,14 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>,\n-                     rfc1592: bool) {\n+    fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>) {\n         if !subty.has_escaping_regions() {\n             let cause = self.cause(cause);\n             match self.infcx.tcx.trait_ref_for_builtin_bound(ty::BoundSized, subty) {\n                 Ok(trait_ref) => {\n-                    let predicate = trait_ref.to_predicate();\n-                    let predicate = if rfc1592 {\n-                        ty::Predicate::Rfc1592(box predicate)\n-                    } else {\n-                        predicate\n-                    };\n                     self.out.push(\n                         traits::Obligation::new(cause,\n-                                                predicate));\n+                                                trait_ref.to_predicate()));\n                 }\n                 Err(ErrorReported) => { }\n             }\n@@ -326,13 +315,13 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n                 ty::TySlice(subty) |\n                 ty::TyArray(subty, _) => {\n-                    self.require_sized(subty, traits::SliceOrArrayElem, false);\n+                    self.require_sized(subty, traits::SliceOrArrayElem);\n                 }\n \n                 ty::TyTuple(ref tys) => {\n                     if let Some((_last, rest)) = tys.split_last() {\n                         for elem in rest {\n-                            self.require_sized(elem, traits::TupleElem, true);\n+                            self.require_sized(elem, traits::TupleElem);\n                         }\n                     }\n                 }\n@@ -347,8 +336,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     self.compute_projection(data);\n                 }\n \n-                ty::TyEnum(def, substs) |\n-                ty::TyStruct(def, substs) => {\n+                ty::TyAdt(def, substs) => {\n                     // WfNominalType\n                     let obligations = self.nominal_obligations(def.did, substs);\n                     self.out.extend(obligations);\n@@ -401,22 +389,15 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n                     let cause = self.cause(traits::MiscObligation);\n \n-                    // FIXME(#33243): remove RFC1592\n-                    self.out.push(traits::Obligation::new(\n-                        cause.clone(),\n-                        ty::Predicate::ObjectSafe(data.principal.def_id())\n-                    ));\n                     let component_traits =\n                         data.builtin_bounds.iter().flat_map(|bound| {\n                             tcx.lang_items.from_builtin_kind(bound).ok()\n-                        });\n-//                        .chain(Some(data.principal.def_id()));\n+                        })\n+                        .chain(Some(data.principal.def_id()));\n                     self.out.extend(\n                         component_traits.map(|did| { traits::Obligation::new(\n                             cause.clone(),\n-                            ty::Predicate::Rfc1592(\n-                                box ty::Predicate::ObjectSafe(did)\n-                            )\n+                            ty::Predicate::ObjectSafe(did)\n                         )})\n                     );\n                 }"}, {"sha": "78f20b77f3185b478690a390e59d95b9c4e95ec3", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -17,7 +17,7 @@ use std::fmt::Debug;\n use std::hash::{Hash, BuildHasher};\n use std::iter::repeat;\n use std::path::Path;\n-use std::time::Instant;\n+use std::time::{Duration, Instant};\n \n use hir;\n use hir::intravisit;\n@@ -47,27 +47,44 @@ pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n     let rv = f();\n     let dur = start.elapsed();\n \n-    // Hack up our own formatting for the duration to make it easier for scripts\n-    // to parse (always use the same number of decimal places and the same unit).\n-    const NANOS_PER_SEC: f64 = 1_000_000_000.0;\n-    let secs = dur.as_secs() as f64;\n-    let secs = secs + dur.subsec_nanos() as f64 / NANOS_PER_SEC;\n-\n     let mem_string = match get_resident() {\n         Some(n) => {\n             let mb = n as f64 / 1_000_000.0;\n             format!(\"; rss: {}MB\", mb.round() as usize)\n         }\n         None => \"\".to_owned(),\n     };\n-    println!(\"{}time: {:.3}{}\\t{}\", repeat(\"  \").take(old).collect::<String>(),\n-             secs, mem_string, what);\n+    println!(\"{}time: {}{}\\t{}\",\n+             repeat(\"  \").take(old).collect::<String>(),\n+             duration_to_secs_str(dur),\n+             mem_string,\n+             what);\n \n     DEPTH.with(|slot| slot.set(old));\n \n     rv\n }\n \n+// Hack up our own formatting for the duration to make it easier for scripts\n+// to parse (always use the same number of decimal places and the same unit).\n+pub fn duration_to_secs_str(dur: Duration) -> String {\n+    const NANOS_PER_SEC: f64 = 1_000_000_000.0;\n+    let secs = dur.as_secs() as f64 +\n+               dur.subsec_nanos() as f64 / NANOS_PER_SEC;\n+\n+    format!(\"{:.3}\", secs)\n+}\n+\n+pub fn record_time<T, F>(accu: &Cell<Duration>, f: F) -> T where\n+    F: FnOnce() -> T,\n+{\n+    let start = Instant::now();\n+    let rv = f();\n+    let duration = start.elapsed();\n+    accu.set(duration + accu.get());\n+    rv\n+}\n+\n // Like std::macros::try!, but for Option<>.\n macro_rules! option_try(\n     ($e:expr) => (match $e { Some(e) => e, None => return None })"}, {"sha": "c290d8f893e9ed8e9c077e7fb53045f1c56bc845", "filename": "src/librustc/util/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Futil%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Futil%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Ffs.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -68,7 +68,7 @@ pub fn link_or_copy<P: AsRef<Path>, Q: AsRef<Path>>(p: P, q: Q) -> io::Result<Li\n     let p = p.as_ref();\n     let q = q.as_ref();\n     if q.exists() {\n-        try!(fs::remove_file(&q));\n+        fs::remove_file(&q)?;\n     }\n \n     match fs::hard_link(p, q) {"}, {"sha": "1df0cf2d5cdf6b299f5af6c6506644747d432aaa", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use hir::def_id::DefId;\n use ty::subst::{self, Subst, Substs};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n-use ty::{TyBool, TyChar, TyStruct, TyEnum};\n+use ty::{TyBool, TyChar, TyAdt};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::TyClosure;\n@@ -487,9 +486,6 @@ impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::Predicate::Trait(ref a) => write!(f, \"{:?}\", a),\n-            ty::Predicate::Rfc1592(ref a) => {\n-                write!(f, \"RFC1592({:?})\", a)\n-            }\n             ty::Predicate::Equate(ref pair) => write!(f, \"{:?}\", pair),\n             ty::Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n             ty::Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n@@ -872,7 +868,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n             TyError => write!(f, \"[type error]\"),\n             TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-            TyEnum(def, substs) | TyStruct(def, substs) => {\n+            TyAdt(def, substs) => {\n                 ty::tls::with(|tcx| {\n                     if def.did.is_local() &&\n                           !tcx.tcache.borrow().contains_key(&def.did) {\n@@ -924,7 +920,8 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     let mut sep = \" \";\n                     tcx.with_freevars(node_id, |freevars| {\n                         for (freevar, upvar_ty) in freevars.iter().zip(substs.upvar_tys) {\n-                            let node_id = freevar.def.var_id();\n+                            let def_id = freevar.def.def_id();\n+                            let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n                             write!(f,\n                                         \"{}{}:{}\",\n                                         sep,\n@@ -1083,7 +1080,6 @@ impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::Predicate::Trait(ref data) => write!(f, \"{}\", data),\n-            ty::Predicate::Rfc1592(ref data) => write!(f, \"{}\", data),\n             ty::Predicate::Equate(ref predicate) => write!(f, \"{}\", predicate),\n             ty::Predicate::RegionOutlives(ref predicate) => write!(f, \"{}\", predicate),\n             ty::Predicate::TypeOutlives(ref predicate) => write!(f, \"{}\", predicate),"}, {"sha": "f7ae47d2e5e56efac5e5707f4cc1c47ef43b2d2e", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -46,7 +46,6 @@ extern crate serialize;\n #[macro_use] extern crate log;\n \n pub mod tempdir;\n-pub mod rpath;\n pub mod sha2;\n pub mod target;\n pub mod slice;"}, {"sha": "660ed0ac7b8439f97bf1deaa625931056217f045", "filename": "src/librustc_back/target/aarch64_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -12,7 +12,7 @@ use target::{Target, TargetOptions, TargetResult};\n use super::apple_ios_base::{opts, Arch};\n \n pub fn target() -> TargetResult {\n-    let base = try!(opts(Arch::Arm64));\n+    let base = opts(Arch::Arm64)?;\n     Ok(Target {\n         llvm_target: \"arm64-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "17492b8bdcb64bf6537b9e71964872d8639ca41a", "filename": "src/librustc_back/target/apple_ios_base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -68,7 +68,7 @@ fn build_pre_link_args(arch: Arch) -> Result<Vec<String>, String> {\n \n     let arch_name = arch.to_string();\n \n-    let sdk_root = try!(get_sdk_root(sdk_name));\n+    let sdk_root = get_sdk_root(sdk_name)?;\n \n     Ok(vec![\"-arch\".to_string(), arch_name.to_string(),\n          \"-Wl,-syslibroot\".to_string(), sdk_root])\n@@ -85,7 +85,7 @@ fn target_cpu(arch: Arch) -> String {\n }\n \n pub fn opts(arch: Arch) -> Result<TargetOptions, String> {\n-    let pre_link_args = try!(build_pre_link_args(arch));\n+    let pre_link_args = build_pre_link_args(arch)?;\n     Ok(TargetOptions {\n         cpu: target_cpu(arch),\n         dynamic_linking: false,"}, {"sha": "71533a09b16724cbd839801c64987eb39303c5df", "filename": "src/librustc_back/target/armv7_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -12,7 +12,7 @@ use target::{Target, TargetOptions, TargetResult};\n use super::apple_ios_base::{opts, Arch};\n \n pub fn target() -> TargetResult {\n-    let base = try!(opts(Arch::Armv7));\n+    let base = opts(Arch::Armv7)?;\n     Ok(Target {\n         llvm_target: \"armv7-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "f24b9969910ef0e3f4f864c054fa2ae99c09930c", "filename": "src/librustc_back/target/armv7s_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -12,7 +12,7 @@ use target::{Target, TargetOptions, TargetResult};\n use super::apple_ios_base::{opts, Arch};\n \n pub fn target() -> TargetResult {\n-    let base = try!(opts(Arch::Armv7s));\n+    let base = opts(Arch::Armv7s)?;\n     Ok(Target {\n         llvm_target: \"armv7s-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "9ccfdbb129c7352bceab72900939f340660c7512", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -18,7 +18,6 @@ pub fn target() -> Result<Target, String> {\n         dynamic_linking: false,\n         executables: true,\n         exe_suffix: \".js\".to_string(),\n-        no_compiler_rt: true,\n         linker_is_gnu: true,\n         allow_asm: false,\n         obj_is_bitcode: true,"}, {"sha": "94146fe9d9885266e15a000dc356f2f9aeb6ece7", "filename": "src/librustc_back/target/i386_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -12,7 +12,7 @@ use target::{Target, TargetOptions, TargetResult};\n use super::apple_ios_base::{opts, Arch};\n \n pub fn target() -> TargetResult {\n-    let base = try!(opts(Arch::I386));\n+    let base = opts(Arch::I386)?;\n     Ok(Target {\n         llvm_target: \"i386-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "9b88cde5989370da54e65423f397cd295831ac2c", "filename": "src/librustc_back/target/i586_pc_windows_msvc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fi586_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fi586_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi586_pc_windows_msvc.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -11,7 +11,7 @@\n use target::TargetResult;\n \n pub fn target() -> TargetResult {\n-    let mut base = try!(super::i686_pc_windows_msvc::target());\n+    let mut base = super::i686_pc_windows_msvc::target()?;\n     base.options.cpu = \"pentium\".to_string();\n     base.llvm_target = \"i586-pc-windows-msvc\".to_string();\n     Ok(base)"}, {"sha": "40fb4a67acdf13506ca33077385b6a03432cf67e", "filename": "src/librustc_back/target/i586_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fi586_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fi586_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi586_unknown_linux_gnu.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -11,7 +11,7 @@\n use target::TargetResult;\n \n pub fn target() -> TargetResult {\n-    let mut base = try!(super::i686_unknown_linux_gnu::target());\n+    let mut base = super::i686_unknown_linux_gnu::target()?;\n     base.options.cpu = \"pentium\".to_string();\n     base.llvm_target = \"i586-unknown-linux-gnu\".to_string();\n     Ok(base)"}, {"sha": "9ba6591f587c4d91d9f1c211665863c57367ab99", "filename": "src/librustc_back/target/le32_unknown_nacl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -22,7 +22,6 @@ pub fn target() -> TargetResult {\n         dynamic_linking: false,\n         executables: true,\n         exe_suffix: \".pexe\".to_string(),\n-        no_compiler_rt: false,\n         linker_is_gnu: true,\n         allow_asm: false,\n         max_atomic_width: 32,"}, {"sha": "837856344280f89c9fffb86a2b92eef2fdf8ed73", "filename": "src/librustc_back/target/mips64_unknown_linux_gnuabi64.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"mips64-unknown-linux-gnuabi64\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        data_layout: \"E-m:m-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        arch: \"mips64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: TargetOptions {\n+            // NOTE(mips64r2) matches C toolchain\n+            cpu: \"mips64r2\".to_string(),\n+            features: \"+mips64r2\".to_string(),\n+            max_atomic_width: 64,\n+            ..super::linux_base::opts()\n+        },\n+    })\n+}"}, {"sha": "e1340e8e127b229ddb9baf69c14994843ef9242e", "filename": "src/librustc_back/target/mips64el_unknown_linux_gnuabi64.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"mips64el-unknown-linux-gnuabi64\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:m-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        arch: \"mips64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: TargetOptions {\n+            // NOTE(mips64r2) matches C toolchain\n+            cpu: \"mips64r2\".to_string(),\n+            features: \"+mips64r2\".to_string(),\n+            max_atomic_width: 64,\n+            ..super::linux_base::opts()\n+        },\n+    })\n+}"}, {"sha": "756586602b45a6d7f9bcbd6cec0809b72067e13e", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -77,12 +77,12 @@ macro_rules! supported_targets {\n             match target {\n                 $(\n                     $triple => {\n-                        let mut t = try!($module::target());\n+                        let mut t = $module::target()?;\n                         t.options.is_builtin = true;\n \n                         // round-trip through the JSON parser to ensure at\n                         // run-time that the parser works correctly\n-                        t = try!(Target::from_json(t.to_json()));\n+                        t = Target::from_json(t.to_json())?;\n                         debug!(\"Got builtin target: {:?}\", t);\n                         Ok(t)\n                     },\n@@ -128,6 +128,8 @@ supported_targets! {\n     (\"i686-unknown-linux-gnu\", i686_unknown_linux_gnu),\n     (\"i586-unknown-linux-gnu\", i586_unknown_linux_gnu),\n     (\"mips-unknown-linux-gnu\", mips_unknown_linux_gnu),\n+    (\"mips64-unknown-linux-gnuabi64\", mips64_unknown_linux_gnuabi64),\n+    (\"mips64el-unknown-linux-gnuabi64\", mips64el_unknown_linux_gnuabi64),\n     (\"mipsel-unknown-linux-gnu\", mipsel_unknown_linux_gnu),\n     (\"powerpc-unknown-linux-gnu\", powerpc_unknown_linux_gnu),\n     (\"powerpc64-unknown-linux-gnu\", powerpc64_unknown_linux_gnu),\n@@ -304,9 +306,6 @@ pub struct TargetOptions {\n     pub allows_weak_linkage: bool,\n     /// Whether the linker support rpaths or not. Defaults to false.\n     pub has_rpath: bool,\n-    /// Whether to disable linking to compiler-rt. Defaults to false, as LLVM\n-    /// will emit references to the functions that compiler-rt provides.\n-    pub no_compiler_rt: bool,\n     /// Whether to disable linking to the default libraries, typically corresponds\n     /// to `-nodefaultlibs`. Defaults to true.\n     pub no_default_libraries: bool,\n@@ -379,7 +378,6 @@ impl Default for TargetOptions {\n             linker_is_gnu: false,\n             allows_weak_linkage: true,\n             has_rpath: false,\n-            no_compiler_rt: false,\n             no_default_libraries: true,\n             position_independent_executables: false,\n             pre_link_objects_exe: Vec::new(),\n@@ -440,12 +438,12 @@ impl Target {\n         };\n \n         let mut base = Target {\n-            llvm_target: try!(get_req_field(\"llvm-target\")),\n-            target_endian: try!(get_req_field(\"target-endian\")),\n-            target_pointer_width: try!(get_req_field(\"target-pointer-width\")),\n-            data_layout: try!(get_req_field(\"data-layout\")),\n-            arch: try!(get_req_field(\"arch\")),\n-            target_os: try!(get_req_field(\"os\")),\n+            llvm_target: get_req_field(\"llvm-target\")?,\n+            target_endian: get_req_field(\"target-endian\")?,\n+            target_pointer_width: get_req_field(\"target-pointer-width\")?,\n+            data_layout: get_req_field(\"data-layout\")?,\n+            arch: get_req_field(\"arch\")?,\n+            target_os: get_req_field(\"os\")?,\n             target_env: get_opt_field(\"env\", \"\"),\n             target_vendor: get_opt_field(\"vendor\", \"unknown\"),\n             options: Default::default(),\n@@ -522,7 +520,6 @@ impl Target {\n         key!(linker_is_gnu, bool);\n         key!(allows_weak_linkage, bool);\n         key!(has_rpath, bool);\n-        key!(no_compiler_rt, bool);\n         key!(no_default_libraries, bool);\n         key!(position_independent_executables, bool);\n         key!(archive_format);\n@@ -665,7 +662,6 @@ impl ToJson for Target {\n         target_option_val!(linker_is_gnu);\n         target_option_val!(allows_weak_linkage);\n         target_option_val!(has_rpath);\n-        target_option_val!(no_compiler_rt);\n         target_option_val!(no_default_libraries);\n         target_option_val!(position_independent_executables);\n         target_option_val!(archive_format);"}, {"sha": "79f2d290e3760431396e1946015825a2d860e08b", "filename": "src/librustc_back/target/s390x_unknown_linux_gnu.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -12,8 +12,12 @@ use target::{Target, TargetResult};\n \n pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n-    // NOTE(zEC12) matches C toolchain\n-    base.cpu = \"zEC12\".to_string();\n+    // z10 is the oldest CPU supported by LLVM\n+    base.cpu = \"z10\".to_string();\n+    // FIXME: The data_layout string below and the ABI implementation in\n+    // cabi_s390x.rs are for now hard-coded to assume the no-vector ABI.\n+    // Pass the -vector feature string to LLVM to respect this assumption.\n+    base.features = \"-vector\".to_string();\n     base.max_atomic_width = 64;\n \n     Ok(Target {"}, {"sha": "3b8b636b6dc66ef1e0c88de4617d4df3227f28d6", "filename": "src/librustc_back/target/x86_64_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -12,7 +12,7 @@ use target::{Target, TargetOptions, TargetResult};\n use super::apple_ios_base::{opts, Arch};\n \n pub fn target() -> TargetResult {\n-    let base = try!(opts(Arch::X86_64));\n+    let base = opts(Arch::X86_64)?;\n     Ok(Target {\n         llvm_target: \"x86_64-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "7e96adfc4bdbc006d45a27c2af582fd553f7704a", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -201,7 +201,7 @@ macro_rules! bitflags {\n                 !(*self & other).is_empty()\n             }\n \n-            /// Returns `true` all of the flags in `other` are contained within `self`.\n+            /// Returns `true` if all of the flags in `other` are contained within `self`.\n             #[inline]\n             pub fn contains(&self, other: $BitFlags) -> bool {\n                 (*self & other) == other"}, {"sha": "089733da536d8d4c602727971784e21d22546dc4", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -56,7 +56,7 @@ fn owned_ptr_base_path<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> &'a LoanPath<\n                 }\n             }\n             LpDowncast(ref lp_base, _) |\n-            LpExtend(ref lp_base, _, _) => helper(&lp_base)\n+            LpExtend(ref lp_base, ..) => helper(&lp_base)\n         }\n     }\n }\n@@ -80,7 +80,7 @@ fn owned_ptr_base_path_rc<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Rc<LoanPath<'\n                 }\n             }\n             LpDowncast(ref lp_base, _) |\n-            LpExtend(ref lp_base, _, _) => helper(lp_base)\n+            LpExtend(ref lp_base, ..) => helper(lp_base)\n         }\n     }\n }\n@@ -312,7 +312,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     break;\n                 }\n                 LpDowncast(ref lp_base, _) |\n-                LpExtend(ref lp_base, _, _) => {\n+                LpExtend(ref lp_base, ..) => {\n                     loan_path = &lp_base;\n                 }\n             }\n@@ -542,7 +542,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     err\n                 }\n \n-                (_, _) => {\n+                (..) => {\n                     let mut err = struct_span_err!(self.bccx, new_loan.span, E0502,\n                                                    \"cannot borrow `{}`{} as {} because \\\n                                                    {} is also borrowed as {}{}\",\n@@ -796,7 +796,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n-                    ty::TyStruct(def, _) | ty::TyEnum(def, _) if def.has_dtor() => {\n+                    ty::TyAdt(def, _) if def.has_dtor() => {\n                         // In the case where the owner implements drop, then\n                         // the path must be initialized to prevent a case of\n                         // partial reinitialization"}, {"sha": "515868c460d071571639eb9395014fc1a4f5370b", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 53, "deletions": 50, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -21,7 +21,7 @@ use borrowck::LoanPathElem::{LpDeref, LpInterior};\n use borrowck::move_data::InvalidMovePathIndex;\n use borrowck::move_data::{MoveData, MovePathIndex};\n use rustc::hir::def_id::{DefId};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, AdtKind, TyCtxt};\n use rustc::middle::mem_categorization as mc;\n \n use std::mem;\n@@ -365,9 +365,9 @@ fn add_fragment_siblings<'a, 'tcx>(this: &MoveData<'tcx>,\n         }\n \n         // *LV for unsafe and borrowed pointers do not consume their loan path, so stop here.\n-        LpExtend(_, _, LpDeref(mc::UnsafePtr(..)))   |\n-        LpExtend(_, _, LpDeref(mc::Implicit(..)))    |\n-        LpExtend(_, _, LpDeref(mc::BorrowedPtr(..))) => {}\n+        LpExtend(.., LpDeref(mc::UnsafePtr(..)))   |\n+        LpExtend(.., LpDeref(mc::Implicit(..)))    |\n+        LpExtend(.., LpDeref(mc::BorrowedPtr(..))) => {}\n \n         // FIXME (pnkfelix): LV[j] should be tracked, at least in the\n         // sense of we will track the remaining drop obligation of the\n@@ -378,7 +378,7 @@ fn add_fragment_siblings<'a, 'tcx>(this: &MoveData<'tcx>,\n         // bind.\n         //\n         // Anyway, for now: LV[j] is not tracked precisely\n-        LpExtend(_, _, LpInterior(_, InteriorElement(..))) => {\n+        LpExtend(.., LpInterior(_, InteriorElement(..))) => {\n             let mp = this.move_path(tcx, lp.clone());\n             gathered_fragments.push(AllButOneFrom(mp));\n         }\n@@ -422,8 +422,8 @@ fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n             variant_did);\n     };\n \n-    match (&parent_ty.sty, enum_variant_info) {\n-        (&ty::TyTuple(ref v), None) => {\n+    match parent_ty.sty {\n+        ty::TyTuple(ref v) => {\n             let tuple_idx = match *origin_field_name {\n                 mc::PositionalField(tuple_idx) => tuple_idx,\n                 mc::NamedField(_) =>\n@@ -438,65 +438,68 @@ fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n-        (&ty::TyStruct(def, _), None) => {\n-            match *origin_field_name {\n-                mc::NamedField(ast_name) => {\n-                    for f in &def.struct_variant().fields {\n-                        if f.name == ast_name {\n-                            continue;\n+        ty::TyAdt(def, ..) => match def.adt_kind() {\n+            AdtKind::Struct => {\n+                match *origin_field_name {\n+                    mc::NamedField(ast_name) => {\n+                        for f in &def.struct_variant().fields {\n+                            if f.name == ast_name {\n+                                continue;\n+                            }\n+                            let field_name = mc::NamedField(f.name);\n+                            add_fragment_sibling_local(field_name, None);\n                         }\n-                        let field_name = mc::NamedField(f.name);\n-                        add_fragment_sibling_local(field_name, None);\n                     }\n-                }\n-                mc::PositionalField(tuple_idx) => {\n-                    for (i, _f) in def.struct_variant().fields.iter().enumerate() {\n-                        if i == tuple_idx {\n-                            continue\n+                    mc::PositionalField(tuple_idx) => {\n+                        for (i, _f) in def.struct_variant().fields.iter().enumerate() {\n+                            if i == tuple_idx {\n+                                continue\n+                            }\n+                            let field_name = mc::PositionalField(i);\n+                            add_fragment_sibling_local(field_name, None);\n                         }\n-                        let field_name = mc::PositionalField(i);\n-                        add_fragment_sibling_local(field_name, None);\n                     }\n                 }\n             }\n-        }\n-\n-        (&ty::TyEnum(def, _), ref enum_variant_info) => {\n-            let variant = match *enum_variant_info {\n-                Some((vid, ref _lp2)) => def.variant_with_id(vid),\n-                None => {\n-                    assert!(def.is_univariant());\n-                    &def.variants[0]\n-                }\n-            };\n-            match *origin_field_name {\n-                mc::NamedField(ast_name) => {\n-                    for field in &variant.fields {\n-                        if field.name == ast_name {\n-                            continue;\n+            AdtKind::Union => {\n+                // Do nothing, all union fields are moved/assigned together.\n+            }\n+            AdtKind::Enum => {\n+                let variant = match enum_variant_info {\n+                    Some((vid, ref _lp2)) => def.variant_with_id(vid),\n+                    None => {\n+                        assert!(def.is_univariant());\n+                        &def.variants[0]\n+                    }\n+                };\n+                match *origin_field_name {\n+                    mc::NamedField(ast_name) => {\n+                        for field in &variant.fields {\n+                            if field.name == ast_name {\n+                                continue;\n+                            }\n+                            let field_name = mc::NamedField(field.name);\n+                            add_fragment_sibling_local(field_name, Some(variant.did));\n                         }\n-                        let field_name = mc::NamedField(field.name);\n-                        add_fragment_sibling_local(field_name, Some(variant.did));\n                     }\n-                }\n-                mc::PositionalField(tuple_idx) => {\n-                    for (i, _f) in variant.fields.iter().enumerate() {\n-                        if tuple_idx == i {\n-                            continue;\n+                    mc::PositionalField(tuple_idx) => {\n+                        for (i, _f) in variant.fields.iter().enumerate() {\n+                            if tuple_idx == i {\n+                                continue;\n+                            }\n+                            let field_name = mc::PositionalField(i);\n+                            add_fragment_sibling_local(field_name, None);\n                         }\n-                        let field_name = mc::PositionalField(i);\n-                        add_fragment_sibling_local(field_name, None);\n                     }\n                 }\n             }\n-        }\n+        },\n \n-        ref sty_and_variant_info => {\n+        ref ty => {\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n             span_bug!(opt_span.unwrap_or(DUMMY_SP),\n                       \"type {:?} ({:?}) is not fragmentable\",\n-                      parent_ty,\n-                      sty_and_variant_info);\n+                      parent_ty, ty);\n         }\n     }\n }"}, {"sha": "9bdc6887f6d03e74680a3a74fbb9a31d480f1926", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -161,9 +161,9 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                                cmt: &mc::cmt<'tcx>)\n                                                -> Option<mc::cmt<'tcx>> {\n     match cmt.cat {\n-        Categorization::Deref(_, _, mc::BorrowedPtr(..)) |\n-        Categorization::Deref(_, _, mc::Implicit(..)) |\n-        Categorization::Deref(_, _, mc::UnsafePtr(..)) |\n+        Categorization::Deref(.., mc::BorrowedPtr(..)) |\n+        Categorization::Deref(.., mc::Implicit(..)) |\n+        Categorization::Deref(.., mc::UnsafePtr(..)) |\n         Categorization::StaticItem => {\n             Some(cmt.clone())\n         }\n@@ -178,13 +178,14 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Interior(ref b, mc::InteriorField(_)) |\n         Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n-                ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n+                ty::TyAdt(def, _) => {\n                     if def.has_dtor() {\n                         Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)\n                     }\n                 }\n+                ty::TySlice(..) => Some(cmt.clone()),\n                 _ => {\n                     check_and_get_illegal_move_origin(bccx, b)\n                 }"}, {"sha": "5970d6e4f2f657217012a1729c90d1880e68a14e", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -74,9 +74,9 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             Categorization::Rvalue(..) |\n             Categorization::Local(..) |                         // L-Local\n             Categorization::Upvar(..) |\n-            Categorization::Deref(_, _, mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n-            Categorization::Deref(_, _, mc::Implicit(..)) |\n-            Categorization::Deref(_, _, mc::UnsafePtr(..)) => {\n+            Categorization::Deref(.., mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n+            Categorization::Deref(.., mc::Implicit(..)) |\n+            Categorization::Deref(.., mc::UnsafePtr(..)) => {\n                 self.check_scope(self.scope(cmt))\n             }\n \n@@ -119,11 +119,11 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                     self.bccx.tcx.region_maps.var_scope(local_id)))\n             }\n             Categorization::StaticItem |\n-            Categorization::Deref(_, _, mc::UnsafePtr(..)) => {\n+            Categorization::Deref(.., mc::UnsafePtr(..)) => {\n                 self.bccx.tcx.mk_region(ty::ReStatic)\n             }\n-            Categorization::Deref(_, _, mc::BorrowedPtr(_, r)) |\n-            Categorization::Deref(_, _, mc::Implicit(_, r)) => {\n+            Categorization::Deref(.., mc::BorrowedPtr(_, r)) |\n+            Categorization::Deref(.., mc::Implicit(_, r)) => {\n                 r\n             }\n             Categorization::Downcast(ref cmt, _) |"}, {"sha": "763c012a8f8abb313ab7932ec1bcad227d44bd08", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -205,7 +205,7 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                         alias_cause);\n             Err(())\n         }\n-        (_, _) => {\n+        (..) => {\n             Ok(())\n         }\n     }"}, {"sha": "9fbf1492f5d2884b869390e0192a68b5407c5956", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -16,7 +16,6 @@ use rustc::ty;\n use syntax::ast;\n use syntax_pos;\n use errors::DiagnosticBuilder;\n-use rustc::hir;\n \n pub struct MoveErrorCollector<'tcx> {\n     errors: Vec<MoveError<'tcx>>\n@@ -117,9 +116,9 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                        move_from: mc::cmt<'tcx>)\n                                        -> DiagnosticBuilder<'a> {\n     match move_from.cat {\n-        Categorization::Deref(_, _, mc::BorrowedPtr(..)) |\n-        Categorization::Deref(_, _, mc::Implicit(..)) |\n-        Categorization::Deref(_, _, mc::UnsafePtr(..)) |\n+        Categorization::Deref(.., mc::BorrowedPtr(..)) |\n+        Categorization::Deref(.., mc::Implicit(..)) |\n+        Categorization::Deref(.., mc::UnsafePtr(..)) |\n         Categorization::StaticItem => {\n             let mut err = struct_span_err!(bccx, move_from.span, E0507,\n                              \"cannot move out of {}\",\n@@ -131,25 +130,27 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             err\n         }\n \n-        Categorization::Interior(ref b, mc::InteriorElement(Kind::Index, _)) => {\n-            let expr = bccx.tcx.map.expect_expr(move_from.id);\n-            if let hir::ExprIndex(..) = expr.node {\n-                let mut err = struct_span_err!(bccx, move_from.span, E0508,\n-                                               \"cannot move out of type `{}`, \\\n-                                               a non-copy fixed-size array\",\n-                                               b.ty);\n-                err.span_label(move_from.span, &format!(\"cannot move out of here\"));\n-                err\n-            } else {\n-                span_bug!(move_from.span, \"this path should not cause illegal move\");\n+        Categorization::Interior(ref b, mc::InteriorElement(ik, _)) => {\n+            match (&b.ty.sty, ik) {\n+                (&ty::TySlice(..), _) |\n+                (_, Kind::Index) => {\n+                    let mut err = struct_span_err!(bccx, move_from.span, E0508,\n+                                                   \"cannot move out of type `{}`, \\\n+                                                    a non-copy array\",\n+                                                   b.ty);\n+                    err.span_label(move_from.span, &format!(\"cannot move out of here\"));\n+                    err\n+                }\n+                (_, Kind::Pattern) => {\n+                    span_bug!(move_from.span, \"this path should not cause illegal move\");\n+                }\n             }\n         }\n \n         Categorization::Downcast(ref b, _) |\n         Categorization::Interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n-                ty::TyStruct(def, _) |\n-                ty::TyEnum(def, _) if def.has_dtor() => {\n+                ty::TyAdt(def, _) if def.has_dtor() => {\n                     let mut err = struct_span_err!(bccx, move_from.span, E0509,\n                                                    \"cannot move out of type `{}`, \\\n                                                    which implements the `Drop` trait\","}, {"sha": "fdcefdc0d43073f4d91f0b56dff5756f0adc2116", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 self.restrict(cmt_base)\n             }\n \n-            Categorization::Interior(cmt_base, i) => {\n+            Categorization::Interior(cmt_base, interior) => {\n                 // R-Field\n                 //\n                 // Overwriting the base would not change the type of\n@@ -99,8 +99,34 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                     Categorization::Downcast(_, variant_id) => Some(variant_id),\n                     _ => None\n                 };\n+                let interior = interior.cleaned();\n+                let base_ty = cmt_base.ty;\n                 let result = self.restrict(cmt_base);\n-                self.extend(result, &cmt, LpInterior(opt_variant_id, i.cleaned()))\n+                // Borrowing one union field automatically borrows all its fields.\n+                match base_ty.sty {\n+                    ty::TyAdt(adt_def, _) if adt_def.is_union() => match result {\n+                        RestrictionResult::Safe => RestrictionResult::Safe,\n+                        RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n+                            for field in &adt_def.struct_variant().fields {\n+                                let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                                let field_ty = if field == interior {\n+                                    cmt.ty\n+                                } else {\n+                                    self.bccx.tcx.types.err // Doesn't matter\n+                                };\n+                                let sibling_lp_kind = LpExtend(base_lp.clone(), cmt.mutbl,\n+                                                               LpInterior(opt_variant_id, field));\n+                                let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n+                                base_vec.push(sibling_lp);\n+                            }\n+\n+                            let lp = new_lp(LpExtend(base_lp, cmt.mutbl,\n+                                                     LpInterior(opt_variant_id, interior)));\n+                            RestrictionResult::SafeIf(lp, base_vec)\n+                        }\n+                    },\n+                    _ => self.extend(result, &cmt, LpInterior(opt_variant_id, interior))\n+                }\n             }\n \n             Categorization::StaticItem => {"}, {"sha": "55dda8eda3a4a552e52c9dd33da78d36cdbaadf8", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -17,7 +17,7 @@ use super::super::MoveDataParamEnv;\n use super::super::DropFlagState;\n use super::super::drop_flag_effects_for_function_entry;\n use super::super::drop_flag_effects_for_location;\n-use super::super::on_all_children_bits;\n+use super::super::on_lookup_result_bits;\n \n use super::{BitDenotation, BlockSets, DataflowOperator};\n \n@@ -277,10 +277,9 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n                              dest_lval: &repr::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n-        let move_path_index = ctxt.move_data.rev_lookup.find(dest_lval);\n-        on_all_children_bits(self.tcx, self.mir, &ctxt.move_data,\n-                             move_path_index,\n-                             |mpi| { in_out.add(&mpi); });\n+        on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n+                              ctxt.move_data.rev_lookup.find(dest_lval),\n+                              |mpi| { in_out.add(&mpi); });\n     }\n }\n \n@@ -338,11 +337,10 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n                              _dest_bb: repr::BasicBlock,\n                              dest_lval: &repr::Lvalue) {\n         // when a call returns successfully, that means we need to set\n-        // the bits for that dest_lval to 1 (initialized).\n-        let move_path_index = ctxt.move_data.rev_lookup.find(dest_lval);\n-        on_all_children_bits(self.tcx, self.mir, &ctxt.move_data,\n-                             move_path_index,\n-                             |mpi| { in_out.remove(&mpi); });\n+        // the bits for that dest_lval to 0 (initialized).\n+        on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n+                              ctxt.move_data.rev_lookup.find(dest_lval),\n+                              |mpi| { in_out.remove(&mpi); });\n     }\n }\n \n@@ -400,10 +398,9 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n                              dest_lval: &repr::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n-        let move_path_index = ctxt.move_data.rev_lookup.find(dest_lval);\n-        on_all_children_bits(self.tcx, self.mir, &ctxt.move_data,\n-                             move_path_index,\n-                             |mpi| { in_out.add(&mpi); });\n+        on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n+                              ctxt.move_data.rev_lookup.find(dest_lval),\n+                              |mpi| { in_out.add(&mpi); });\n     }\n }\n \n@@ -448,18 +445,18 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                 // assigning into this `lvalue` kills all\n                 // MoveOuts from it, and *also* all MoveOuts\n                 // for children and associated fragment sets.\n-                let move_path_index = rev_lookup.find(lvalue);\n-                on_all_children_bits(tcx,\n+                on_lookup_result_bits(tcx,\n                                      mir,\n                                      move_data,\n-                                     move_path_index,\n+                                     rev_lookup.find(lvalue),\n                                      |mpi| for moi in &path_map[mpi] {\n                                          assert!(moi.index() < bits_per_block);\n                                          sets.kill_set.add(&moi);\n                                      });\n             }\n             repr::StatementKind::StorageLive(_) |\n-            repr::StatementKind::StorageDead(_) => {}\n+            repr::StatementKind::StorageDead(_) |\n+            repr::StatementKind::Nop => {}\n         }\n     }\n \n@@ -489,18 +486,17 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                              _dest_bb: repr::BasicBlock,\n                              dest_lval: &repr::Lvalue) {\n         let move_data = &ctxt.move_data;\n-        let move_path_index = move_data.rev_lookup.find(dest_lval);\n         let bits_per_block = self.bits_per_block(ctxt);\n \n         let path_map = &move_data.path_map;\n-        on_all_children_bits(self.tcx,\n-                             self.mir,\n-                             move_data,\n-                             move_path_index,\n-                             |mpi| for moi in &path_map[mpi] {\n-                                 assert!(moi.index() < bits_per_block);\n-                                 in_out.remove(&moi);\n-                             });\n+        on_lookup_result_bits(self.tcx,\n+                              self.mir,\n+                              move_data,\n+                              move_data.rev_lookup.find(dest_lval),\n+                              |mpi| for moi in &path_map[mpi] {\n+                                  assert!(moi.index() < bits_per_block);\n+                                  in_out.remove(&moi);\n+                              });\n     }\n }\n "}, {"sha": "aeb91f06a9aa455947d200861ac94c294adbbee4", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::mir::repr::{self, Mir};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::super::gather_moves::{MovePathIndex};\n+use super::super::gather_moves::{MovePathIndex, LookupResult};\n use super::super::MoveDataParamEnv;\n use super::BitDenotation;\n use super::DataflowResults;\n@@ -105,7 +105,8 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 (lvalue, rvalue)\n             }\n             repr::StatementKind::StorageLive(_) |\n-            repr::StatementKind::StorageDead(_) => continue,\n+            repr::StatementKind::StorageDead(_) |\n+            repr::StatementKind::Nop => continue,\n             repr::StatementKind::SetDiscriminant{ .. } =>\n                 span_bug!(stmt.source_info.span,\n                           \"sanity_check should run before Deaggregator inserts SetDiscriminant\"),\n@@ -116,20 +117,26 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      repr::BorrowKind::Shared,\n                                      ref peeking_at_lval) = *rvalue {\n                 // Okay, our search is over.\n-                let peek_mpi = move_data.rev_lookup.find(peeking_at_lval);\n-                let bit_state = sets.on_entry.contains(&peek_mpi);\n-                debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n-                       lvalue, peeking_at_lval, bit_state);\n-                if !bit_state {\n-                    tcx.sess.span_err(span, &format!(\"rustc_peek: bit not set\"));\n+                match move_data.rev_lookup.find(peeking_at_lval) {\n+                    LookupResult::Exact(peek_mpi) => {\n+                        let bit_state = sets.on_entry.contains(&peek_mpi);\n+                        debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n+                               lvalue, peeking_at_lval, bit_state);\n+                        if !bit_state {\n+                            tcx.sess.span_err(span, \"rustc_peek: bit not set\");\n+                        }\n+                    }\n+                    LookupResult::Parent(..) => {\n+                        tcx.sess.span_err(span, \"rustc_peek: argument untracked\");\n+                    }\n                 }\n                 return;\n             } else {\n                 // Our search should have been over, but the input\n                 // does not match expectations of `rustc_peek` for\n                 // this sanity_check.\n-                let msg = &format!(\"rustc_peek: argument expression \\\n-                                    must be immediate borrow of form `&expr`\");\n+                let msg = \"rustc_peek: argument expression \\\n+                           must be immediate borrow of form `&expr`\";\n                 tcx.sess.span_err(span, msg);\n             }\n         }"}, {"sha": "96702b209a1f5d0b271b8a5e0c7e6f2b5b6e9e1b", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 81, "deletions": 84, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -9,10 +9,11 @@\n // except according to those terms.\n \n use indexed_set::IdxSetBuf;\n-use super::gather_moves::{MoveData, MovePathIndex, MovePathContent};\n+use super::gather_moves::{MoveData, MovePathIndex, LookupResult};\n use super::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use super::dataflow::{DataflowResults};\n use super::{drop_flag_effects_for_location, on_all_children_bits};\n+use super::on_lookup_result_bits;\n use super::{DropFlagState, MoveDataParamEnv};\n use super::patch::MirPatch;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -42,7 +43,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n         }\n         let id = src.item_id();\n         let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n-        let move_data = MoveData::gather_moves(mir, tcx);\n+        let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n         let elaborate_patch = {\n             let mir = &*mir;\n             let env = MoveDataParamEnv {\n@@ -184,31 +185,11 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn path_needs_drop(&self, path: MovePathIndex) -> bool\n     {\n-        match self.move_data().move_paths[path].content {\n-            MovePathContent::Lvalue(ref lvalue) => {\n-                let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                debug!(\"path_needs_drop({:?}, {:?} : {:?})\", path, lvalue, ty);\n+        let lvalue = &self.move_data().move_paths[path].lvalue;\n+        let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        debug!(\"path_needs_drop({:?}, {:?} : {:?})\", path, lvalue, ty);\n \n-                self.tcx.type_needs_drop_given_env(ty, self.param_env())\n-            }\n-            _ => false\n-        }\n-    }\n-\n-    /// Returns whether this lvalue is tracked by drop elaboration. This\n-    /// includes all lvalues, except these (1.) behind references or arrays,\n-    ///  or (2.) behind ADT's with a Drop impl.\n-    fn lvalue_is_tracked(&self, lv: &Lvalue<'tcx>) -> bool\n-    {\n-        // `lvalue_contents_drop_state_cannot_differ` only compares\n-        // the `lv` to its immediate contents, while this recursively\n-        // follows parent chain formed by `base` of each projection.\n-        if let &Lvalue::Projection(ref data) = lv {\n-            !super::lvalue_contents_drop_state_cannot_differ(self.tcx, self.mir, &data.base) &&\n-                self.lvalue_is_tracked(&data.base)\n-        } else {\n-            true\n-        }\n+        self.tcx.type_needs_drop_given_env(ty, self.param_env())\n     }\n \n     fn collect_drop_flags(&mut self)\n@@ -221,19 +202,29 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 _ => continue\n             };\n \n-            if !self.lvalue_is_tracked(location) {\n-                continue\n-            }\n-\n             let init_data = self.initialization_data_at(Location {\n                 block: bb,\n                 statement_index: data.statements.len()\n             });\n \n             let path = self.move_data().rev_lookup.find(location);\n-            debug!(\"collect_drop_flags: {:?}, lv {:?} (index {:?})\",\n+            debug!(\"collect_drop_flags: {:?}, lv {:?} ({:?})\",\n                    bb, location, path);\n \n+            let path = match path {\n+                LookupResult::Exact(e) => e,\n+                LookupResult::Parent(None) => continue,\n+                LookupResult::Parent(Some(parent)) => {\n+                    let (_maybe_live, maybe_dead) = init_data.state(parent);\n+                    if maybe_dead {\n+                        span_bug!(terminator.source_info.span,\n+                                  \"drop of untracked, uninitialized value {:?}, lv {:?} ({:?})\",\n+                                  bb, location, path);\n+                    }\n+                    continue\n+                }\n+            };\n+\n             on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n                 if self.path_needs_drop(child) {\n                     let (maybe_live, maybe_dead) = init_data.state(child);\n@@ -257,20 +248,27 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             match terminator.kind {\n                 TerminatorKind::Drop { ref location, target, unwind } => {\n                     let init_data = self.initialization_data_at(loc);\n-                    let path = self.move_data().rev_lookup.find(location);\n-                    self.elaborate_drop(&DropCtxt {\n-                        source_info: terminator.source_info,\n-                        is_cleanup: data.is_cleanup,\n-                        init_data: &init_data,\n-                        lvalue: location,\n-                        path: path,\n-                        succ: target,\n-                        unwind: if data.is_cleanup {\n-                            None\n-                        } else {\n-                            Some(Option::unwrap_or(unwind, resume_block))\n+                    match self.move_data().rev_lookup.find(location) {\n+                        LookupResult::Exact(path) => {\n+                            self.elaborate_drop(&DropCtxt {\n+                                source_info: terminator.source_info,\n+                                is_cleanup: data.is_cleanup,\n+                                init_data: &init_data,\n+                                lvalue: location,\n+                                path: path,\n+                                succ: target,\n+                                unwind: if data.is_cleanup {\n+                                    None\n+                                } else {\n+                                    Some(Option::unwrap_or(unwind, resume_block))\n+                                }\n+                            }, bb);\n                         }\n-                    }, bb);\n+                        LookupResult::Parent(..) => {\n+                            span_bug!(terminator.source_info.span,\n+                                      \"drop of untracked value {:?}\", bb);\n+                        }\n+                    }\n                 }\n                 TerminatorKind::DropAndReplace { ref location, ref value,\n                                                  target, unwind } =>\n@@ -336,35 +334,37 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             is_cleanup: data.is_cleanup,\n         });\n \n-        if !self.lvalue_is_tracked(location) {\n-            // drop and replace behind a pointer/array/whatever. The location\n-            // must be initialized.\n-            debug!(\"elaborate_drop_and_replace({:?}) - untracked\", terminator);\n-            self.patch.patch_terminator(bb, TerminatorKind::Drop {\n-                location: location.clone(),\n-                target: target,\n-                unwind: Some(unwind)\n-            });\n-        } else {\n-            debug!(\"elaborate_drop_and_replace({:?}) - tracked\", terminator);\n-            let init_data = self.initialization_data_at(loc);\n-            let path = self.move_data().rev_lookup.find(location);\n-\n-            self.elaborate_drop(&DropCtxt {\n-                source_info: terminator.source_info,\n-                is_cleanup: data.is_cleanup,\n-                init_data: &init_data,\n-                lvalue: location,\n-                path: path,\n-                succ: target,\n-                unwind: Some(unwind)\n-            }, bb);\n-            on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n-                self.set_drop_flag(Location { block: target, statement_index: 0 },\n-                                   child, DropFlagState::Present);\n-                self.set_drop_flag(Location { block: unwind, statement_index: 0 },\n-                                   child, DropFlagState::Present);\n-            });\n+        match self.move_data().rev_lookup.find(location) {\n+            LookupResult::Exact(path) => {\n+                debug!(\"elaborate_drop_and_replace({:?}) - tracked {:?}\", terminator, path);\n+                let init_data = self.initialization_data_at(loc);\n+\n+                self.elaborate_drop(&DropCtxt {\n+                    source_info: terminator.source_info,\n+                    is_cleanup: data.is_cleanup,\n+                    init_data: &init_data,\n+                    lvalue: location,\n+                    path: path,\n+                    succ: target,\n+                    unwind: Some(unwind)\n+                }, bb);\n+                on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n+                    self.set_drop_flag(Location { block: target, statement_index: 0 },\n+                                       child, DropFlagState::Present);\n+                    self.set_drop_flag(Location { block: unwind, statement_index: 0 },\n+                                       child, DropFlagState::Present);\n+                });\n+            }\n+            LookupResult::Parent(parent) => {\n+                // drop and replace behind a pointer/array/whatever. The location\n+                // must be initialized.\n+                debug!(\"elaborate_drop_and_replace({:?}) - untracked {:?}\", terminator, parent);\n+                self.patch.patch_terminator(bb, TerminatorKind::Drop {\n+                    location: location.clone(),\n+                    target: target,\n+                    unwind: Some(unwind)\n+                });\n+            }\n         }\n     }\n \n@@ -446,10 +446,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                              substs: &'tcx Substs<'tcx>)\n                              -> Vec<(Lvalue<'tcx>, Option<MovePathIndex>)>\n     {\n-        let move_paths = &self.move_data().move_paths;\n         variant.fields.iter().enumerate().map(|(i, f)| {\n             let subpath =\n-                super::move_path_children_matching(move_paths, variant_path, |p| {\n+                super::move_path_children_matching(self.move_data(), variant_path, |p| {\n                     match p {\n                         &Projection {\n                             elem: ProjectionElem::Field(idx, _), ..\n@@ -580,7 +579,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let fields = tys.iter().enumerate().map(|(i, &ty)| {\n             (c.lvalue.clone().field(Field::new(i), ty),\n              super::move_path_children_matching(\n-                 &self.move_data().move_paths, c.path, |proj| match proj {\n+                 self.move_data(), c.path, |proj| match proj {\n                      &Projection {\n                          elem: ProjectionElem::Field(f, _), ..\n                      } => f.index() == i,\n@@ -598,7 +597,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         debug!(\"open_drop_for_box({:?}, {:?})\", c, ty);\n \n         let interior_path = super::move_path_children_matching(\n-            &self.move_data().move_paths, c.path, |proj| match proj {\n+            self.move_data(), c.path, |proj| match proj {\n                 &Projection { elem: ProjectionElem::Deref, .. } => true,\n                 _ => false\n             }).unwrap();\n@@ -625,10 +624,8 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                                  variant_index: usize)\n                                  -> BasicBlock\n     {\n-        let move_paths = &self.move_data().move_paths;\n-\n         let subpath = super::move_path_children_matching(\n-            move_paths, c.path, |proj| match proj {\n+            self.move_data(), c.path, |proj| match proj {\n                 &Projection {\n                     elem: ProjectionElem::Downcast(_, idx), ..\n                 } => idx == variant_index,\n@@ -709,7 +706,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn open_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n         let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n         match ty.sty {\n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 self.open_drop_for_adt(c, def, substs)\n             }\n             ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n@@ -893,7 +890,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n \n         match ty.sty {\n-            ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n+            ty::TyAdt(def, _) => {\n                 if def.has_dtor() {\n                     self.tcx.sess.span_warn(\n                         c.source_info.span,\n@@ -942,7 +939,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n                 let loc = Location { block: tgt, statement_index: 0 };\n                 let path = self.move_data().rev_lookup.find(lv);\n-                on_all_children_bits(\n+                on_lookup_result_bits(\n                     self.tcx, self.mir, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n                 );\n@@ -1011,7 +1008,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n                 let loc = Location { block: bb, statement_index: data.statements.len() };\n                 let path = self.move_data().rev_lookup.find(lv);\n-                on_all_children_bits(\n+                on_lookup_result_bits(\n                     self.tcx, self.mir, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n                 );"}, {"sha": "6346c1e58897e12e62d32e05abc82e3c38c80fc3", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 331, "deletions": 555, "changes": 886, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -9,16 +9,17 @@\n // except according to those terms.\n \n \n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n use rustc::mir::repr::*;\n use rustc::util::nodemap::FnvHashMap;\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::indexed_vec::{IndexVec};\n+\n+use syntax::codemap::DUMMY_SP;\n \n-use std::cell::{Cell};\n use std::collections::hash_map::Entry;\n use std::fmt;\n-use std::iter;\n-use std::ops::Index;\n+use std::mem;\n+use std::ops::{Index, IndexMut};\n \n use super::abs_domain::{AbstractElem, Lift};\n \n@@ -28,17 +29,15 @@ use super::abs_domain::{AbstractElem, Lift};\n // ensure that other code does not accidentally access `index.0`\n // (which is likely to yield a subtle off-by-one error).\n mod indexes {\n+    use std::fmt;\n     use core::nonzero::NonZero;\n     use rustc_data_structures::indexed_vec::Idx;\n \n     macro_rules! new_index {\n-        ($Index:ident) => {\n-            #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+        ($Index:ident, $debug_name:expr) => {\n+            #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n             pub struct $Index(NonZero<usize>);\n \n-            impl $Index {\n-            }\n-\n             impl Idx for $Index {\n                 fn new(idx: usize) -> Self {\n                     unsafe { $Index(NonZero::new(idx + 1)) }\n@@ -47,22 +46,28 @@ mod indexes {\n                     *self.0 - 1\n                 }\n             }\n+\n+            impl fmt::Debug for $Index {\n+                fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                    write!(fmt, \"{}{}\", $debug_name, self.index())\n+                }\n+            }\n         }\n     }\n \n     /// Index into MovePathData.move_paths\n-    new_index!(MovePathIndex);\n+    new_index!(MovePathIndex, \"mp\");\n \n     /// Index into MoveData.moves.\n-    new_index!(MoveOutIndex);\n+    new_index!(MoveOutIndex, \"mo\");\n }\n \n pub use self::indexes::MovePathIndex;\n pub use self::indexes::MoveOutIndex;\n \n impl self::indexes::MoveOutIndex {\n     pub fn move_path_index(&self, move_data: &MoveData) -> MovePathIndex {\n-        move_data.moves[self.index()].path\n+        move_data.moves[*self].path\n     }\n }\n \n@@ -83,40 +88,7 @@ pub struct MovePath<'tcx> {\n     pub next_sibling: Option<MovePathIndex>,\n     pub first_child: Option<MovePathIndex>,\n     pub parent: Option<MovePathIndex>,\n-    pub content: MovePathContent<'tcx>,\n-}\n-\n-/// MovePaths usually represent a single l-value. The exceptions are\n-/// forms that arise due to erroneous input code: static data holds\n-/// l-values that we cannot actually move out of. Therefore we map\n-/// statics to a special marker value (`MovePathContent::Static`)\n-/// representing an invalid origin.\n-#[derive(Clone, Debug)]\n-pub enum MovePathContent<'tcx> {\n-    Lvalue(Lvalue<'tcx>),\n-    Static,\n-}\n-\n-/// During construction of the MovePath's, we use PreMovePath to\n-/// represent accumulated state while we are gathering up all the\n-/// children of each path.\n-#[derive(Clone)]\n-struct PreMovePath<'tcx> {\n-    pub next_sibling: Option<MovePathIndex>,\n-    pub first_child: Cell<Option<MovePathIndex>>,\n-    pub parent: Option<MovePathIndex>,\n-    pub content: MovePathContent<'tcx>,\n-}\n-\n-impl<'tcx> PreMovePath<'tcx> {\n-    fn into_move_path(self) -> MovePath<'tcx> {\n-        MovePath {\n-            next_sibling: self.next_sibling,\n-            parent: self.parent,\n-            content: self.content,\n-            first_child: self.first_child.get(),\n-        }\n-    }\n+    pub lvalue: Lvalue<'tcx>,\n }\n \n impl<'tcx> fmt::Debug for MovePath<'tcx> {\n@@ -131,52 +103,50 @@ impl<'tcx> fmt::Debug for MovePath<'tcx> {\n         if let Some(next_sibling) = self.next_sibling {\n             write!(w, \" next_sibling: {:?}\", next_sibling)?;\n         }\n-        write!(w, \" content: {:?} }}\", self.content)\n+        write!(w, \" lvalue: {:?} }}\", self.lvalue)\n     }\n }\n \n #[derive(Debug)]\n pub struct MoveData<'tcx> {\n-    pub move_paths: MovePathData<'tcx>,\n-    pub moves: Vec<MoveOut>,\n-    pub loc_map: LocMap,\n-    pub path_map: PathMap,\n+    pub move_paths: IndexVec<MovePathIndex, MovePath<'tcx>>,\n+    pub moves: IndexVec<MoveOutIndex, MoveOut>,\n+    /// Each Location `l` is mapped to the MoveOut's that are effects\n+    /// of executing the code at `l`. (There can be multiple MoveOut's\n+    /// for a given `l` because each MoveOut is associated with one\n+    /// particular path being moved.)\n+    pub loc_map: LocationMap<Vec<MoveOutIndex>>,\n+    pub path_map: IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n     pub rev_lookup: MovePathLookup<'tcx>,\n }\n \n #[derive(Debug)]\n-pub struct LocMap {\n+pub struct LocationMap<T> {\n     /// Location-indexed (BasicBlock for outer index, index within BB\n-    /// for inner index) map to list of MoveOutIndex's.\n-    ///\n-    /// Each Location `l` is mapped to the MoveOut's that are effects\n-    /// of executing the code at `l`. (There can be multiple MoveOut's\n-    /// for a given `l` because each MoveOut is associated with one\n-    /// particular path being moved.)\n-    map: Vec<Vec<Vec<MoveOutIndex>>>,\n+    /// for inner index) map.\n+    map: IndexVec<BasicBlock, Vec<T>>,\n }\n \n-impl Index<Location> for LocMap {\n-    type Output = [MoveOutIndex];\n+impl<T> Index<Location> for LocationMap<T> {\n+    type Output = T;\n     fn index(&self, index: Location) -> &Self::Output {\n-        assert!(index.block.index() < self.map.len());\n-        assert!(index.statement_index < self.map[index.block.index()].len());\n-        &self.map[index.block.index()][index.statement_index]\n+        &self.map[index.block][index.statement_index]\n     }\n }\n \n-#[derive(Debug)]\n-pub struct PathMap {\n-    /// Path-indexed map to list of MoveOutIndex's.\n-    ///\n-    /// Each Path `p` is mapped to the MoveOut's that move out of `p`.\n-    map: Vec<Vec<MoveOutIndex>>,\n+impl<T> IndexMut<Location> for LocationMap<T> {\n+    fn index_mut(&mut self, index: Location) -> &mut Self::Output {\n+        &mut self.map[index.block][index.statement_index]\n+    }\n }\n \n-impl Index<MovePathIndex> for PathMap {\n-    type Output = [MoveOutIndex];\n-    fn index(&self, index: MovePathIndex) -> &Self::Output {\n-        &self.map[index.index()]\n+impl<T> LocationMap<T> where T: Default + Clone {\n+    fn new(mir: &Mir) -> Self {\n+        LocationMap {\n+            map: mir.basic_blocks().iter().map(|block| {\n+                vec![T::default(); block.statements.len()+1]\n+            }).collect()\n+        }\n     }\n }\n \n@@ -196,583 +166,389 @@ pub struct MoveOut {\n \n impl fmt::Debug for MoveOut {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"p{}@{:?}\", self.path.index(), self.source)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct MovePathData<'tcx> {\n-    move_paths: Vec<MovePath<'tcx>>,\n-}\n-\n-impl<'tcx> MovePathData<'tcx> {\n-    pub fn len(&self) -> usize { self.move_paths.len() }\n-}\n-\n-impl<'tcx> Index<MovePathIndex> for MovePathData<'tcx> {\n-    type Output = MovePath<'tcx>;\n-    fn index(&self, i: MovePathIndex) -> &MovePath<'tcx> {\n-        &self.move_paths[i.index()]\n+        write!(fmt, \"{:?}@{:?}\", self.path, self.source)\n     }\n }\n \n-struct MovePathDataBuilder<'tcx> {\n-    pre_move_paths: Vec<PreMovePath<'tcx>>,\n-    rev_lookup: MovePathLookup<'tcx>,\n-}\n-\n /// Tables mapping from an l-value to its MovePathIndex.\n #[derive(Debug)]\n pub struct MovePathLookup<'tcx> {\n-    vars: IndexVec<Var, Option<MovePathIndex>>,\n-    temps: IndexVec<Temp, Option<MovePathIndex>>,\n-    args: IndexVec<Arg, Option<MovePathIndex>>,\n+    vars: IndexVec<Var, MovePathIndex>,\n+    temps: IndexVec<Temp, MovePathIndex>,\n+    args: IndexVec<Arg, MovePathIndex>,\n \n     /// The move path representing the return value is constructed\n     /// lazily when we first encounter it in the input MIR.\n     return_ptr: Option<MovePathIndex>,\n \n-    /// A single move path (representing any static data referenced)\n-    /// is constructed lazily when we first encounter statics in the\n-    /// input MIR.\n-    statics: Option<MovePathIndex>,\n-\n     /// projections are made from a base-lvalue and a projection\n     /// elem. The base-lvalue will have a unique MovePathIndex; we use\n     /// the latter as the index into the outer vector (narrowing\n     /// subsequent search so that it is solely relative to that\n     /// base-lvalue). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n-    projections: Vec<FnvHashMap<AbstractElem<'tcx>, MovePathIndex>>,\n-\n-    /// Tracks the next index to allocate during construction of the\n-    /// MovePathData. Unused after MovePathData is fully constructed.\n-    next_index: MovePathIndex,\n+    projections: FnvHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n }\n \n-trait FillTo {\n-    type T;\n-    fn fill_to_with(&mut self, idx: usize, x: Self::T);\n-    fn fill_to(&mut self, idx: usize) where Self::T: Default {\n-        self.fill_to_with(idx, Default::default())\n-    }\n-}\n-impl<T:Clone> FillTo for Vec<T> {\n-    type T = T;\n-    fn fill_to_with(&mut self, idx: usize, x: T) {\n-        if idx >= self.len() {\n-            let delta = idx + 1 - self.len();\n-            assert_eq!(idx + 1, self.len() + delta);\n-            self.extend(iter::repeat(x).take(delta))\n-        }\n-        debug_assert!(idx < self.len());\n-    }\n+struct MoveDataBuilder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: &'a ParameterEnvironment<'tcx>,\n+    data: MoveData<'tcx>,\n }\n \n-#[derive(Clone, Debug)]\n-enum LookupKind { Generate, Reuse }\n-#[derive(Clone, Debug)]\n-struct Lookup<T>(LookupKind, T);\n-\n-impl Lookup<MovePathIndex> {\n-    fn index(&self) -> usize { (self.1).index() }\n+pub enum MovePathError {\n+    IllegalMove,\n+    UnionMove { path: MovePathIndex },\n }\n \n-impl<'tcx> MovePathLookup<'tcx> {\n-    fn new(mir: &Mir) -> Self {\n-        MovePathLookup {\n-            vars: IndexVec::from_elem(None, &mir.var_decls),\n-            temps: IndexVec::from_elem(None, &mir.temp_decls),\n-            args: IndexVec::from_elem(None, &mir.arg_decls),\n-            statics: None,\n-            return_ptr: None,\n-            projections: vec![],\n-            next_index: MovePathIndex::new(0),\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+    fn new(mir: &'a Mir<'tcx>,\n+           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+           param_env: &'a ParameterEnvironment<'tcx>)\n+           -> Self {\n+        let mut move_paths = IndexVec::new();\n+        let mut path_map = IndexVec::new();\n+\n+        MoveDataBuilder {\n+            mir: mir,\n+            tcx: tcx,\n+            param_env: param_env,\n+            data: MoveData {\n+                moves: IndexVec::new(),\n+                loc_map: LocationMap::new(mir),\n+                rev_lookup: MovePathLookup {\n+                    vars: mir.var_decls.indices().map(Lvalue::Var).map(|v| {\n+                        Self::new_move_path(&mut move_paths, &mut path_map, None, v)\n+                    }).collect(),\n+                    temps: mir.temp_decls.indices().map(Lvalue::Temp).map(|t| {\n+                        Self::new_move_path(&mut move_paths, &mut path_map, None, t)\n+                    }).collect(),\n+                    args: mir.arg_decls.indices().map(Lvalue::Arg).map(|a| {\n+                        Self::new_move_path(&mut move_paths, &mut path_map, None, a)\n+                    }).collect(),\n+                    return_ptr: None,\n+                    projections: FnvHashMap(),\n+                },\n+                move_paths: move_paths,\n+                path_map: path_map,\n+            }\n         }\n     }\n \n-    fn next_index(next: &mut MovePathIndex) -> MovePathIndex {\n-        let i = *next;\n-        *next = MovePathIndex::new(i.index() + 1);\n-        i\n-    }\n-\n-    fn lookup_or_generate<I: Idx>(vec: &mut IndexVec<I, Option<MovePathIndex>>,\n-                                  idx: I,\n-                                  next_index: &mut MovePathIndex)\n-                                  -> Lookup<MovePathIndex> {\n-        let entry = &mut vec[idx];\n-        match *entry {\n-            None => {\n-                let i = Self::next_index(next_index);\n-                *entry = Some(i);\n-                Lookup(LookupKind::Generate, i)\n-            }\n-            Some(entry_idx) => {\n-                Lookup(LookupKind::Reuse, entry_idx)\n-            }\n+    fn new_move_path(move_paths: &mut IndexVec<MovePathIndex, MovePath<'tcx>>,\n+                     path_map: &mut IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n+                     parent: Option<MovePathIndex>,\n+                     lvalue: Lvalue<'tcx>)\n+                     -> MovePathIndex\n+    {\n+        let move_path = move_paths.push(MovePath {\n+            next_sibling: None,\n+            first_child: None,\n+            parent: parent,\n+            lvalue: lvalue\n+        });\n+\n+        if let Some(parent) = parent {\n+            let next_sibling =\n+                mem::replace(&mut move_paths[parent].first_child, Some(move_path));\n+            move_paths[move_path].next_sibling = next_sibling;\n         }\n-    }\n \n-    fn lookup_var(&mut self, var_idx: Var) -> Lookup<MovePathIndex> {\n-        Self::lookup_or_generate(&mut self.vars,\n-                                 var_idx,\n-                                 &mut self.next_index)\n+        let path_map_ent = path_map.push(vec![]);\n+        assert_eq!(path_map_ent, move_path);\n+        move_path\n     }\n \n-    fn lookup_temp(&mut self, temp_idx: Temp) -> Lookup<MovePathIndex> {\n-        Self::lookup_or_generate(&mut self.temps,\n-                                 temp_idx,\n-                                 &mut self.next_index)\n+    /// This creates a MovePath for a given lvalue, returning an `MovePathError`\n+    /// if that lvalue can't be moved from.\n+    ///\n+    /// NOTE: lvalues behind references *do not* get a move path, which is\n+    /// problematic for borrowck.\n+    ///\n+    /// Maybe we should have seperate \"borrowck\" and \"moveck\" modes.\n+    fn move_path_for(&mut self, lval: &Lvalue<'tcx>)\n+                     -> Result<MovePathIndex, MovePathError>\n+    {\n+        debug!(\"lookup({:?})\", lval);\n+        match *lval {\n+            Lvalue::Var(var) => Ok(self.data.rev_lookup.vars[var]),\n+            Lvalue::Arg(arg) => Ok(self.data.rev_lookup.args[arg]),\n+            Lvalue::Temp(temp) => Ok(self.data.rev_lookup.temps[temp]),\n+            // error: can't move out of a static\n+            Lvalue::Static(..) => Err(MovePathError::IllegalMove),\n+            Lvalue::ReturnPointer => match self.data.rev_lookup.return_ptr {\n+                Some(ptr) => Ok(ptr),\n+                ref mut ptr @ None => {\n+                    let path = Self::new_move_path(\n+                        &mut self.data.move_paths,\n+                        &mut self.data.path_map,\n+                        None,\n+                        lval.clone());\n+                    *ptr = Some(path);\n+                    Ok(path)\n+                }\n+            },\n+            Lvalue::Projection(ref proj) => {\n+                self.move_path_for_projection(lval, proj)\n+            }\n+        }\n     }\n \n-    fn lookup_arg(&mut self, arg_idx: Arg) -> Lookup<MovePathIndex> {\n-        Self::lookup_or_generate(&mut self.args,\n-                                 arg_idx,\n-                                 &mut self.next_index)\n+    fn create_move_path(&mut self, lval: &Lvalue<'tcx>) {\n+        // This is an assignment, not a move, so this not being a valid\n+        // move path is OK.\n+        let _ = self.move_path_for(lval);\n     }\n \n-    fn lookup_static(&mut self) -> Lookup<MovePathIndex> {\n-        match self.statics {\n-            Some(mpi) => {\n-                Lookup(LookupKind::Reuse, mpi)\n-            }\n-            ref mut ret @ None => {\n-                let mpi = Self::next_index(&mut self.next_index);\n-                *ret = Some(mpi);\n-                Lookup(LookupKind::Generate, mpi)\n+    fn move_path_for_projection(&mut self,\n+                                lval: &Lvalue<'tcx>,\n+                                proj: &LvalueProjection<'tcx>)\n+                                -> Result<MovePathIndex, MovePathError>\n+    {\n+        let base = try!(self.move_path_for(&proj.base));\n+        let lv_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        match lv_ty.sty {\n+            // error: can't move out of borrowed content\n+            ty::TyRef(..) | ty::TyRawPtr(..) => return Err(MovePathError::IllegalMove),\n+            // error: can't move out of struct with destructor\n+            ty::TyAdt(adt, _) if adt.has_dtor() =>\n+                return Err(MovePathError::IllegalMove),\n+            // move out of union - always move the entire union\n+            ty::TyAdt(adt, _) if adt.is_union() =>\n+                return Err(MovePathError::UnionMove { path: base }),\n+            // error: can't move out of a slice\n+            ty::TySlice(..) =>\n+                return Err(MovePathError::IllegalMove),\n+            ty::TyArray(..) => match proj.elem {\n+                // error: can't move out of an array\n+                ProjectionElem::Index(..) => return Err(MovePathError::IllegalMove),\n+                _ => {\n+                    // FIXME: still badly broken\n+                }\n+            },\n+            _ => {}\n+        };\n+        match self.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n+            Entry::Occupied(ent) => Ok(*ent.get()),\n+            Entry::Vacant(ent) => {\n+                let path = Self::new_move_path(\n+                    &mut self.data.move_paths,\n+                    &mut self.data.path_map,\n+                    Some(base),\n+                    lval.clone()\n+                );\n+                ent.insert(path);\n+                Ok(path)\n             }\n         }\n     }\n \n-    fn lookup_return_pointer(&mut self) -> Lookup<MovePathIndex> {\n-        match self.return_ptr {\n-            Some(mpi) => {\n-                Lookup(LookupKind::Reuse, mpi)\n+    fn finalize(self) -> MoveData<'tcx> {\n+        debug!(\"{}\", {\n+            debug!(\"moves for {:?}:\", self.mir.span);\n+            for (j, mo) in self.data.moves.iter_enumerated() {\n+                debug!(\"    {:?} = {:?}\", j, mo);\n             }\n-            ref mut ret @ None => {\n-                let mpi = Self::next_index(&mut self.next_index);\n-                *ret = Some(mpi);\n-                Lookup(LookupKind::Generate, mpi)\n+            debug!(\"move paths for {:?}:\", self.mir.span);\n+            for (j, path) in self.data.move_paths.iter_enumerated() {\n+                debug!(\"    {:?} = {:?}\", j, path);\n             }\n-        }\n+            \"done dumping moves\"\n+        });\n+        self.data\n     }\n+}\n \n-    fn lookup_proj(&mut self,\n-                   proj: &LvalueProjection<'tcx>,\n-                   base: MovePathIndex) -> Lookup<MovePathIndex> {\n-        let MovePathLookup { ref mut projections,\n-                             ref mut next_index, .. } = *self;\n-        projections.fill_to(base.index());\n-        match projections[base.index()].entry(proj.elem.lift()) {\n-            Entry::Occupied(ent) => {\n-                Lookup(LookupKind::Reuse, *ent.get())\n-            }\n-            Entry::Vacant(ent) => {\n-                let mpi = Self::next_index(next_index);\n-                ent.insert(mpi);\n-                Lookup(LookupKind::Generate, mpi)\n-            }\n-        }\n-    }\n+#[derive(Copy, Clone, Debug)]\n+pub enum LookupResult {\n+    Exact(MovePathIndex),\n+    Parent(Option<MovePathIndex>)\n }\n \n impl<'tcx> MovePathLookup<'tcx> {\n     // Unlike the builder `fn move_path_for` below, this lookup\n     // alternative will *not* create a MovePath on the fly for an\n-    // unknown l-value; it will simply panic.\n-    pub fn find(&self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n+    // unknown l-value, but will rather return the nearest available\n+    // parent.\n+    pub fn find(&self, lval: &Lvalue<'tcx>) -> LookupResult {\n         match *lval {\n-            Lvalue::Var(var) => self.vars[var].unwrap(),\n-            Lvalue::Temp(temp) => self.temps[temp].unwrap(),\n-            Lvalue::Arg(arg) => self.args[arg].unwrap(),\n-            Lvalue::Static(ref _def_id) => self.statics.unwrap(),\n-            Lvalue::ReturnPointer => self.return_ptr.unwrap(),\n+            Lvalue::Var(var) => LookupResult::Exact(self.vars[var]),\n+            Lvalue::Temp(temp) => LookupResult::Exact(self.temps[temp]),\n+            Lvalue::Arg(arg) => LookupResult::Exact(self.args[arg]),\n+            Lvalue::Static(..) => LookupResult::Parent(None),\n+            Lvalue::ReturnPointer => LookupResult::Exact(self.return_ptr.unwrap()),\n             Lvalue::Projection(ref proj) => {\n-                let base_index = self.find(&proj.base);\n-                self.projections[base_index.index()][&proj.elem.lift()]\n+                match self.find(&proj.base) {\n+                    LookupResult::Exact(base_path) => {\n+                        match self.projections.get(&(base_path, proj.elem.lift())) {\n+                            Some(&subpath) => LookupResult::Exact(subpath),\n+                            None => LookupResult::Parent(Some(base_path))\n+                        }\n+                    }\n+                    inexact => inexact\n+                }\n             }\n         }\n     }\n }\n \n-impl<'tcx> MovePathDataBuilder<'tcx> {\n-    fn lookup(&mut self, lval: &Lvalue<'tcx>) -> Lookup<MovePathIndex> {\n-        let proj = match *lval {\n-            Lvalue::Var(var_idx) =>\n-                return self.rev_lookup.lookup_var(var_idx),\n-            Lvalue::Temp(temp_idx) =>\n-                return self.rev_lookup.lookup_temp(temp_idx),\n-            Lvalue::Arg(arg_idx) =>\n-                return self.rev_lookup.lookup_arg(arg_idx),\n-            Lvalue::Static(_def_id) =>\n-                return self.rev_lookup.lookup_static(),\n-            Lvalue::ReturnPointer =>\n-                return self.rev_lookup.lookup_return_pointer(),\n-            Lvalue::Projection(ref proj) => {\n-                proj\n-            }\n-        };\n-\n-        let base_index = self.move_path_for(&proj.base);\n-        self.rev_lookup.lookup_proj(proj, base_index)\n-    }\n-\n-    fn create_move_path(&mut self, lval: &Lvalue<'tcx>) {\n-        // Create MovePath for `lval`, discarding returned index.\n-        self.move_path_for(lval);\n+impl<'a, 'tcx> MoveData<'tcx> {\n+    pub fn gather_moves(mir: &Mir<'tcx>,\n+                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        param_env: &ParameterEnvironment<'tcx>)\n+                        -> Self {\n+        gather_moves(mir, tcx, param_env)\n     }\n+}\n \n-    fn move_path_for(&mut self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n-        debug!(\"move_path_for({:?})\", lval);\n-\n-        let lookup: Lookup<MovePathIndex> = self.lookup(lval);\n-\n-        // `lookup` is either the previously assigned index or a\n-        // newly-allocated one.\n-        debug_assert!(lookup.index() <= self.pre_move_paths.len());\n-\n-        if let Lookup(LookupKind::Generate, mpi) = lookup {\n-            let parent;\n-            let sibling;\n-            // tracks whether content is Some non-static; statics map to None.\n-            let content: Option<&Lvalue<'tcx>>;\n-\n-            match *lval {\n-                Lvalue::Static(_) => {\n-                    content = None;\n-                    sibling = None;\n-                    parent = None;\n-                }\n-\n-                Lvalue::Var(_) | Lvalue::Temp(_) | Lvalue::Arg(_) |\n-                Lvalue::ReturnPointer => {\n-                    content = Some(lval);\n-                    sibling = None;\n-                    parent = None;\n-                }\n-                Lvalue::Projection(ref proj) => {\n-                    content = Some(lval);\n-\n-                    // Here, install new MovePath as new first_child.\n-\n-                    // Note: `parent` previously allocated (Projection\n-                    // case of match above established this).\n-                    let idx = self.move_path_for(&proj.base);\n-                    parent = Some(idx);\n-\n-                    let parent_move_path = &mut self.pre_move_paths[idx.index()];\n-\n-                    // At last: Swap in the new first_child.\n-                    sibling = parent_move_path.first_child.get();\n-                    parent_move_path.first_child.set(Some(mpi));\n-                }\n-            };\n-\n-            let content = match content {\n-                Some(lval) => MovePathContent::Lvalue(lval.clone()),\n-                None => MovePathContent::Static,\n-            };\n-\n-            let move_path = PreMovePath {\n-                next_sibling: sibling,\n-                parent: parent,\n-                content: content,\n-                first_child: Cell::new(None),\n-            };\n+fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          param_env: &ParameterEnvironment<'tcx>)\n+                          -> MoveData<'tcx> {\n+    let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n \n-            self.pre_move_paths.push(move_path);\n+    for (bb, block) in mir.basic_blocks().iter_enumerated() {\n+        for (i, stmt) in block.statements.iter().enumerate() {\n+            let source = Location { block: bb, statement_index: i };\n+            builder.gather_statement(source, stmt);\n         }\n \n-        return lookup.1;\n+        let terminator_loc = Location {\n+            block: bb,\n+            statement_index: block.statements.len()\n+        };\n+        builder.gather_terminator(terminator_loc, block.terminator());\n     }\n-}\n \n-impl<'a, 'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        gather_moves(mir, tcx)\n-    }\n+    builder.finalize()\n }\n \n-#[derive(Debug)]\n-enum StmtKind {\n-    Use, Repeat, Cast, BinaryOp, UnaryOp, Box,\n-    Aggregate, Drop, CallFn, CallArg, Return, If,\n-}\n-\n-fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveData<'tcx> {\n-    use self::StmtKind as SK;\n-\n-    let bb_count = mir.basic_blocks().len();\n-    let mut moves = vec![];\n-    let mut loc_map: Vec<_> = iter::repeat(Vec::new()).take(bb_count).collect();\n-    let mut path_map = Vec::new();\n-\n-    // this is mutable only because we will move it to and fro' the\n-    // BlockContexts constructed on each iteration. (Moving is more\n-    // straight-forward than mutable borrows in this instance.)\n-    let mut builder = MovePathDataBuilder {\n-        pre_move_paths: Vec::new(),\n-        rev_lookup: MovePathLookup::new(mir),\n-    };\n-\n-    // Before we analyze the program text, we create the MovePath's\n-    // for all of the vars, args, and temps. (This enforces a basic\n-    // property that even if the MIR body doesn't contain any\n-    // references to a var/arg/temp, it will still be a valid\n-    // operation to lookup the MovePath associated with it.)\n-    assert!(mir.var_decls.len() <= ::std::u32::MAX as usize);\n-    assert!(mir.arg_decls.len() <= ::std::u32::MAX as usize);\n-    assert!(mir.temp_decls.len() <= ::std::u32::MAX as usize);\n-    for var in mir.var_decls.indices() {\n-        let path_idx = builder.move_path_for(&Lvalue::Var(var));\n-        path_map.fill_to(path_idx.index());\n-    }\n-    for arg in mir.arg_decls.indices() {\n-        let path_idx = builder.move_path_for(&Lvalue::Arg(arg));\n-        path_map.fill_to(path_idx.index());\n-    }\n-    for temp in mir.temp_decls.indices() {\n-        let path_idx = builder.move_path_for(&Lvalue::Temp(temp));\n-        path_map.fill_to(path_idx.index());\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+    fn gather_statement(&mut self, loc: Location, stmt: &Statement<'tcx>) {\n+        debug!(\"gather_statement({:?}, {:?})\", loc, stmt);\n+        match stmt.kind {\n+            StatementKind::Assign(ref lval, ref rval) => {\n+                self.create_move_path(lval);\n+                self.gather_rvalue(loc, rval);\n+            }\n+            StatementKind::StorageLive(_) |\n+            StatementKind::StorageDead(_) => {}\n+            StatementKind::SetDiscriminant{ .. } => {\n+                span_bug!(stmt.source_info.span,\n+                          \"SetDiscriminant should not exist during borrowck\");\n+            }\n+            StatementKind::Nop => {}\n+        }\n     }\n \n-    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n-        let loc_map_bb = &mut loc_map[bb.index()];\n-\n-        debug_assert!(loc_map_bb.len() == 0);\n-        let len = bb_data.statements.len();\n-        loc_map_bb.fill_to(len);\n-        debug_assert!(loc_map_bb.len() == len + 1);\n-\n-        let mut bb_ctxt = BlockContext {\n-            _tcx: tcx,\n-            moves: &mut moves,\n-            builder: builder,\n-            path_map: &mut path_map,\n-            loc_map_bb: loc_map_bb,\n-        };\n-\n-        for (i, stmt) in bb_data.statements.iter().enumerate() {\n-            let source = Location { block: bb, statement_index: i };\n-            match stmt.kind {\n-                StatementKind::Assign(ref lval, ref rval) => {\n-                    bb_ctxt.builder.create_move_path(lval);\n-\n-                    // Ensure that the path_map contains entries even\n-                    // if the lvalue is assigned and never read.\n-                    let assigned_path = bb_ctxt.builder.move_path_for(lval);\n-                    bb_ctxt.path_map.fill_to(assigned_path.index());\n-\n-                    match *rval {\n-                        Rvalue::Use(ref operand) => {\n-                            bb_ctxt.on_operand(SK::Use, operand, source)\n-                        }\n-                        Rvalue::Repeat(ref operand, ref _const) =>\n-                            bb_ctxt.on_operand(SK::Repeat, operand, source),\n-                        Rvalue::Cast(ref _kind, ref operand, ref _ty) =>\n-                            bb_ctxt.on_operand(SK::Cast, operand, source),\n-                        Rvalue::BinaryOp(ref _binop, ref operand1, ref operand2) |\n-                        Rvalue::CheckedBinaryOp(ref _binop, ref operand1, ref operand2) => {\n-                            bb_ctxt.on_operand(SK::BinaryOp, operand1, source);\n-                            bb_ctxt.on_operand(SK::BinaryOp, operand2, source);\n-                        }\n-                        Rvalue::UnaryOp(ref _unop, ref operand) => {\n-                            bb_ctxt.on_operand(SK::UnaryOp, operand, source);\n-                        }\n-                        Rvalue::Box(ref _ty) => {\n-                            // this is creating uninitialized\n-                            // memory that needs to be initialized.\n-                            let deref_lval = Lvalue::Projection(Box::new(Projection {\n-                                base: lval.clone(),\n-                                elem: ProjectionElem::Deref,\n-                            }));\n-                            bb_ctxt.on_move_out_lval(SK::Box, &deref_lval, source);\n-                        }\n-                        Rvalue::Aggregate(ref _kind, ref operands) => {\n-                            for operand in operands {\n-                                bb_ctxt.on_operand(SK::Aggregate, operand, source);\n-                            }\n-                        }\n-                        Rvalue::Ref(..) |\n-                        Rvalue::Len(..) |\n-                        Rvalue::InlineAsm { .. } => {}\n-                    }\n-                }\n-                StatementKind::StorageLive(_) |\n-                StatementKind::StorageDead(_) => {}\n-                StatementKind::SetDiscriminant{ .. } => {\n-                    span_bug!(stmt.source_info.span,\n-                              \"SetDiscriminant should not exist during borrowck\");\n+    fn gather_rvalue(&mut self, loc: Location, rvalue: &Rvalue<'tcx>) {\n+        match *rvalue {\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::Cast(_, ref operand, _) |\n+            Rvalue::UnaryOp(_, ref operand) => {\n+                self.gather_operand(loc, operand)\n+            }\n+            Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs) |\n+            Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n+                self.gather_operand(loc, lhs);\n+                self.gather_operand(loc, rhs);\n+            }\n+            Rvalue::Aggregate(ref _kind, ref operands) => {\n+                for operand in operands {\n+                    self.gather_operand(loc, operand);\n                 }\n             }\n+            Rvalue::Ref(..) |\n+            Rvalue::Len(..) |\n+            Rvalue::InlineAsm { .. } => {}\n+            Rvalue::Box(..) => {\n+                // This returns an rvalue with uninitialized contents. We can't\n+                // move out of it here because it is an rvalue - assignments always\n+                // completely initialize their lvalue.\n+                //\n+                // However, this does not matter - MIR building is careful to\n+                // only emit a shallow free for the partially-initialized\n+                // temporary.\n+                //\n+                // In any case, if we want to fix this, we have to register a\n+                // special move and change the `statement_effect` functions.\n+            }\n         }\n+    }\n \n-        debug!(\"gather_moves({:?})\", bb_data.terminator());\n-        match bb_data.terminator().kind {\n+    fn gather_terminator(&mut self, loc: Location, term: &Terminator<'tcx>) {\n+        debug!(\"gather_terminator({:?}, {:?})\", loc, term);\n+        match term.kind {\n             TerminatorKind::Goto { target: _ } |\n             TerminatorKind::Resume |\n             TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n-                let source = Location { block: bb,\n-                                        statement_index: bb_data.statements.len() };\n-                debug!(\"gather_moves Return on_move_out_lval return {:?}\", source);\n-                bb_ctxt.on_move_out_lval(SK::Return, &Lvalue::ReturnPointer, source);\n-            }\n-\n-            TerminatorKind::If { ref cond, targets: _ } => {\n-                let source = Location { block: bb,\n-                                        statement_index: bb_data.statements.len() };\n-                bb_ctxt.on_operand(SK::If, cond, source);\n-            }\n-\n-            TerminatorKind::Assert {\n-                ref cond, expected: _,\n-                ref msg, target: _, cleanup: _\n-            } => {\n-                // The `cond` is always of (copyable) type `bool`,\n-                // so there will never be anything to move.\n-                let _ = cond;\n-                match *msg {\n-                    AssertMessage:: BoundsCheck { ref len, ref index } => {\n-                        // Same for the usize length and index in bounds-checking.\n-                        let _ = (len, index);\n-                    }\n-                    AssertMessage::Math(_) => {}\n-                }\n+                self.gather_move(loc, &Lvalue::ReturnPointer);\n             }\n \n-            TerminatorKind::SwitchInt { switch_ty: _, values: _, targets: _, ref discr } |\n-            TerminatorKind::Switch { adt_def: _, targets: _, ref discr } => {\n-                // The `discr` is not consumed; that is instead\n-                // encoded on specific match arms (and for\n-                // SwitchInt`, it is always a copyable integer\n-                // type anyway).\n-                let _ = discr;\n+            TerminatorKind::If { .. } |\n+            TerminatorKind::Assert { .. } |\n+            TerminatorKind::SwitchInt { .. } |\n+            TerminatorKind::Switch { .. } => {\n+                // branching terminators - these don't move anything\n             }\n \n             TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n-                let source = Location { block: bb,\n-                                        statement_index: bb_data.statements.len() };\n-                bb_ctxt.on_move_out_lval(SK::Drop, location, source);\n+                self.gather_move(loc, location);\n             }\n             TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n-                let assigned_path = bb_ctxt.builder.move_path_for(location);\n-                bb_ctxt.path_map.fill_to(assigned_path.index());\n-\n-                let source = Location { block: bb,\n-                                        statement_index: bb_data.statements.len() };\n-                bb_ctxt.on_operand(SK::Use, value, source);\n+                self.create_move_path(location);\n+                self.gather_operand(loc, value);\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n-                let source = Location { block: bb,\n-                                        statement_index: bb_data.statements.len() };\n-                bb_ctxt.on_operand(SK::CallFn, func, source);\n+                self.gather_operand(loc, func);\n                 for arg in args {\n-                    debug!(\"gather_moves Call on_operand {:?} {:?}\", arg, source);\n-                    bb_ctxt.on_operand(SK::CallArg, arg, source);\n+                    self.gather_operand(loc, arg);\n                 }\n                 if let Some((ref destination, _bb)) = *destination {\n-                    debug!(\"gather_moves Call create_move_path {:?} {:?}\", destination, source);\n-\n-                    // Ensure that the path_map contains entries even\n-                    // if the lvalue is assigned and never read.\n-                    let assigned_path = bb_ctxt.builder.move_path_for(destination);\n-                    bb_ctxt.path_map.fill_to(assigned_path.index());\n-\n-                    bb_ctxt.builder.create_move_path(destination);\n+                    self.create_move_path(destination);\n                 }\n             }\n         }\n-\n-        builder = bb_ctxt.builder;\n     }\n \n-    // At this point, we may have created some MovePaths that do not\n-    // have corresponding entries in the path map.\n-    //\n-    // (For example, creating the path `a.b.c` may, as a side-effect,\n-    // create a path for the parent path `a.b`.)\n-    //\n-    // All such paths were not referenced ...\n-    //\n-    // well you know, lets actually try just asserting that the path map *is* complete.\n-    assert_eq!(path_map.len(), builder.pre_move_paths.len());\n-\n-    let pre_move_paths = builder.pre_move_paths;\n-    let move_paths: Vec<_> = pre_move_paths.into_iter()\n-        .map(|p| p.into_move_path())\n-        .collect();\n-\n-    debug!(\"{}\", {\n-        let mut seen: Vec<_> = move_paths.iter().map(|_| false).collect();\n-        for (j, &MoveOut { ref path, ref source }) in moves.iter().enumerate() {\n-            debug!(\"MovePathData moves[{}]: MoveOut {{ path: {:?} = {:?}, source: {:?} }}\",\n-                   j, path, move_paths[path.index()], source);\n-            seen[path.index()] = true;\n-        }\n-        for (j, path) in move_paths.iter().enumerate() {\n-            if !seen[j] {\n-                debug!(\"MovePathData move_paths[{}]: {:?}\", j, path);\n+    fn gather_operand(&mut self, loc: Location, operand: &Operand<'tcx>) {\n+        match *operand {\n+            Operand::Constant(..) => {} // not-a-move\n+            Operand::Consume(ref lval) => { // a move\n+                self.gather_move(loc, lval);\n             }\n         }\n-        \"done dumping MovePathData\"\n-    });\n-\n-    MoveData {\n-        move_paths: MovePathData { move_paths: move_paths, },\n-        moves: moves,\n-        loc_map: LocMap { map: loc_map },\n-        path_map: PathMap { map: path_map },\n-        rev_lookup: builder.rev_lookup,\n     }\n-}\n \n-struct BlockContext<'b, 'tcx: 'b> {\n-    _tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-    moves: &'b mut Vec<MoveOut>,\n-    builder: MovePathDataBuilder<'tcx>,\n-    path_map: &'b mut Vec<Vec<MoveOutIndex>>,\n-    loc_map_bb: &'b mut Vec<Vec<MoveOutIndex>>,\n-}\n+    fn gather_move(&mut self, loc: Location, lval: &Lvalue<'tcx>) {\n+        debug!(\"gather_move({:?}, {:?})\", loc, lval);\n \n-impl<'b, 'tcx: 'b> BlockContext<'b, 'tcx> {\n-    fn on_move_out_lval(&mut self,\n-                        stmt_kind: StmtKind,\n-                        lval: &Lvalue<'tcx>,\n-                        source: Location) {\n-        let i = source.statement_index;\n-        let index = MoveOutIndex::new(self.moves.len());\n-\n-        let path = self.builder.move_path_for(lval);\n-        self.moves.push(MoveOut { path: path, source: source.clone() });\n-        self.path_map.fill_to(path.index());\n-\n-        debug!(\"ctxt: {:?} add consume of lval: {:?} \\\n-                at index: {:?} \\\n-                to path_map for path: {:?} and \\\n-                to loc_map for loc: {:?}\",\n-               stmt_kind, lval, index, path, source);\n-\n-        debug_assert!(path.index() < self.path_map.len());\n-        // this is actually a questionable assert; at the very\n-        // least, incorrect input code can probably cause it to\n-        // fire.\n-        assert!(self.path_map[path.index()].iter().find(|idx| **idx == index).is_none());\n-        self.path_map[path.index()].push(index);\n-\n-        debug_assert!(i < self.loc_map_bb.len());\n-        debug_assert!(self.loc_map_bb[i].iter().find(|idx| **idx == index).is_none());\n-        self.loc_map_bb[i].push(index);\n-    }\n+        let lv_ty = lval.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        if !lv_ty.moves_by_default(self.tcx, self.param_env, DUMMY_SP) {\n+            debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", loc, lval, lv_ty);\n+            return\n+        }\n \n-    fn on_operand(&mut self, stmt_kind: StmtKind, operand: &Operand<'tcx>, source: Location) {\n-        match *operand {\n-            Operand::Constant(..) => {} // not-a-move\n-            Operand::Consume(ref lval) => { // a move\n-                self.on_move_out_lval(stmt_kind, lval, source);\n+        let path = match self.move_path_for(lval) {\n+            Ok(path) | Err(MovePathError::UnionMove { path }) => path,\n+            Err(MovePathError::IllegalMove) => {\n+                // Moving out of a bad path. Eventually, this should be a MIR\n+                // borrowck error instead of a bug.\n+                span_bug!(self.mir.span,\n+                          \"Broken MIR: moving out of lvalue {:?}: {:?} at {:?}\",\n+                          lval, lv_ty, loc);\n             }\n-        }\n+        };\n+        let move_out = self.data.moves.push(MoveOut { path: path, source: loc });\n+\n+        debug!(\"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n+               loc, lval, move_out, path);\n+\n+        self.data.path_map[path].push(move_out);\n+        self.data.loc_map[loc].push(move_out);\n     }\n }"}, {"sha": "f26afdc2b857280ae51891af7712098027323db4", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -34,8 +34,7 @@ use self::dataflow::{DataflowOperator};\n use self::dataflow::{Dataflow, DataflowAnalysis, DataflowResults};\n use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use self::dataflow::{DefinitelyInitializedLvals};\n-use self::gather_moves::{MoveData, MovePathIndex};\n-use self::gather_moves::{MovePathContent, MovePathData};\n+use self::gather_moves::{MoveData, MovePathIndex, LookupResult};\n \n fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<P<MetaItem>> {\n     for attr in attrs {\n@@ -67,8 +66,8 @@ pub fn borrowck_mir<'a, 'tcx: 'a>(\n     id: ast::NodeId,\n     attributes: &[ast::Attribute]) {\n     match fk {\n-        FnKind::ItemFn(name, _, _, _, _, _, _) |\n-        FnKind::Method(name, _, _, _) => {\n+        FnKind::ItemFn(name, ..) |\n+        FnKind::Method(name, ..) => {\n             debug!(\"borrowck_mir({}) UNIMPLEMENTED\", name);\n         }\n         FnKind::Closure(_) => {\n@@ -78,8 +77,8 @@ pub fn borrowck_mir<'a, 'tcx: 'a>(\n \n     let tcx = bcx.tcx;\n \n-    let move_data = MoveData::gather_moves(mir, tcx);\n     let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+    let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n     let flow_inits =\n         do_dataflow(tcx, mir, id, attributes, &mdpe, MaybeInitializedLvals::new(tcx, mir));\n@@ -211,23 +210,23 @@ impl DropFlagState {\n     }\n }\n \n-fn move_path_children_matching<'tcx, F>(move_paths: &MovePathData<'tcx>,\n+fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n                                         path: MovePathIndex,\n                                         mut cond: F)\n                                         -> Option<MovePathIndex>\n     where F: FnMut(&repr::LvalueProjection<'tcx>) -> bool\n {\n-    let mut next_child = move_paths[path].first_child;\n+    let mut next_child = move_data.move_paths[path].first_child;\n     while let Some(child_index) = next_child {\n-        match move_paths[child_index].content {\n-            MovePathContent::Lvalue(repr::Lvalue::Projection(ref proj)) => {\n+        match move_data.move_paths[child_index].lvalue {\n+            repr::Lvalue::Projection(ref proj) => {\n                 if cond(proj) {\n                     return Some(child_index)\n                 }\n             }\n             _ => {}\n         }\n-        next_child = move_paths[child_index].next_sibling;\n+        next_child = move_data.move_paths[child_index].next_sibling;\n     }\n \n     None\n@@ -257,12 +256,12 @@ fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n     let ty = lv.ty(mir, tcx).to_ty(tcx);\n     match ty.sty {\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n-            debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} refd => false\",\n+            debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} refd => true\",\n                    lv, ty);\n             true\n         }\n-        ty::TyStruct(def, _) | ty::TyEnum(def, _) if def.has_dtor() => {\n-            debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} Drop => false\",\n+        ty::TyAdt(def, _) if def.has_dtor() || def.is_union() => {\n+            debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} Drop => true\",\n                    lv, ty);\n             true\n         }\n@@ -272,6 +271,24 @@ fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n     }\n }\n \n+fn on_lookup_result_bits<'a, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    move_data: &MoveData<'tcx>,\n+    lookup_result: LookupResult,\n+    each_child: F)\n+    where F: FnMut(MovePathIndex)\n+{\n+    match lookup_result {\n+        LookupResult::Parent(..) => {\n+            // access to untracked value - do not touch children\n+        }\n+        LookupResult::Exact(e) => {\n+            on_all_children_bits(tcx, mir, move_data, e, each_child)\n+        }\n+    }\n+}\n+\n fn on_all_children_bits<'a, 'tcx, F>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n@@ -286,12 +303,8 @@ fn on_all_children_bits<'a, 'tcx, F>(\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex) -> bool\n     {\n-        match move_data.move_paths[path].content {\n-            MovePathContent::Lvalue(ref lvalue) => {\n-                lvalue_contents_drop_state_cannot_differ(tcx, mir, lvalue)\n-            }\n-            _ => true\n-        }\n+        lvalue_contents_drop_state_cannot_differ(\n+            tcx, mir, &move_data.move_paths[path].lvalue)\n     }\n \n     fn on_all_children_bits<'a, 'tcx, F>(\n@@ -327,10 +340,10 @@ fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n     let move_data = &ctxt.move_data;\n     for (arg, _) in mir.arg_decls.iter_enumerated() {\n         let lvalue = repr::Lvalue::Arg(arg);\n-        let move_path_index = move_data.rev_lookup.find(&lvalue);\n-        on_all_children_bits(tcx, mir, move_data,\n-                             move_path_index,\n-                             |moi| callback(moi, DropFlagState::Present));\n+        let lookup_result = move_data.rev_lookup.find(&lvalue);\n+        on_lookup_result_bits(tcx, mir, move_data,\n+                              lookup_result,\n+                              |moi| callback(moi, DropFlagState::Present));\n     }\n }\n \n@@ -352,11 +365,10 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n         debug!(\"moving out of path {:?}\", move_data.move_paths[path]);\n \n         // don't move out of non-Copy things\n-        if let MovePathContent::Lvalue(ref lvalue) = move_data.move_paths[path].content {\n-            let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n-            if !ty.moves_by_default(tcx, param_env, DUMMY_SP) {\n-                continue;\n-            }\n+        let lvalue = &move_data.move_paths[path].lvalue;\n+        let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n+        if !ty.moves_by_default(tcx, param_env, DUMMY_SP) {\n+            continue;\n         }\n \n         on_all_children_bits(tcx, mir, move_data,\n@@ -372,20 +384,21 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n             }\n             repr::StatementKind::Assign(ref lvalue, _) => {\n                 debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n-                 on_all_children_bits(tcx, mir, move_data,\n-                                     move_data.rev_lookup.find(lvalue),\n-                                     |moi| callback(moi, DropFlagState::Present))\n+                 on_lookup_result_bits(tcx, mir, move_data,\n+                                       move_data.rev_lookup.find(lvalue),\n+                                       |moi| callback(moi, DropFlagState::Present))\n             }\n             repr::StatementKind::StorageLive(_) |\n-            repr::StatementKind::StorageDead(_) => {}\n+            repr::StatementKind::StorageDead(_) |\n+            repr::StatementKind::Nop => {}\n         },\n         None => {\n             debug!(\"drop_flag_effects: replace {:?}\", block.terminator());\n             match block.terminator().kind {\n                 repr::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                    on_all_children_bits(tcx, mir, move_data,\n-                                         move_data.rev_lookup.find(location),\n-                                         |moi| callback(moi, DropFlagState::Present))\n+                    on_lookup_result_bits(tcx, mir, move_data,\n+                                          move_data.rev_lookup.find(location),\n+                                          |moi| callback(moi, DropFlagState::Present))\n                 }\n                 _ => {\n                     // other terminators do not contain move-ins"}, {"sha": "5d62629b648109d638d92c93a90a112f982453a3", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -142,7 +142,7 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &hir::Item) {\n     // loan step is intended for things that have a data\n     // flow dependent conditions.\n     match item.node {\n-        hir::ItemStatic(_, _, ref ex) |\n+        hir::ItemStatic(.., ref ex) |\n         hir::ItemConst(_, ref ex) => {\n             gather_loans::gather_loans_in_static_initializer(this, item.id, &ex);\n         }\n@@ -422,7 +422,7 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n                         tcx: TyCtxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n-            hir::ExprClosure(_, _, ref block, _) => {\n+            hir::ExprClosure(.., ref block, _) => {\n                 block.id\n             }\n             _ => {\n@@ -442,7 +442,7 @@ impl<'a, 'tcx> LoanPath<'tcx> {\n                 tcx.region_maps.node_extent(block_id)\n             }\n             LpDowncast(ref base, _) |\n-            LpExtend(ref base, _, _) => base.kill_scope(tcx),\n+            LpExtend(ref base, ..) => base.kill_scope(tcx),\n         }\n     }\n \n@@ -464,7 +464,7 @@ impl<'a, 'tcx> LoanPath<'tcx> {\n     fn depth(&self) -> usize {\n         match self.kind {\n             LpExtend(ref base, _, LpDeref(_)) => base.depth(),\n-            LpExtend(ref base, _, LpInterior(_, _)) => base.depth() + 1,\n+            LpExtend(ref base, _, LpInterior(..)) => base.depth() + 1,\n             _ => 0,\n         }\n     }\n@@ -477,8 +477,6 @@ impl<'a, 'tcx> LoanPath<'tcx> {\n                     base.common(&base2).map(|x| {\n                         let xd = x.depth();\n                         if base.depth() == xd && base2.depth() == xd {\n-                            assert_eq!(base.ty, base2.ty);\n-                            assert_eq!(self.ty, other.ty);\n                             LoanPath {\n                                 kind: LpExtend(Rc::new(x), a, LpInterior(opt_variant_id, id)),\n                                 ty: self.ty,\n@@ -495,15 +493,13 @@ impl<'a, 'tcx> LoanPath<'tcx> {\n             (_, &LpExtend(ref other, _, LpDeref(_))) => self.common(&other),\n             (&LpVar(id), &LpVar(id2)) => {\n                 if id == id2 {\n-                    assert_eq!(self.ty, other.ty);\n                     Some(LoanPath { kind: LpVar(id), ty: self.ty })\n                 } else {\n                     None\n                 }\n             }\n             (&LpUpvar(id), &LpUpvar(id2)) => {\n                 if id == id2 {\n-                    assert_eq!(self.ty, other.ty);\n                     Some(LoanPath { kind: LpUpvar(id), ty: self.ty })\n                 } else {\n                     None\n@@ -715,7 +711,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n             move_data::Captured =>\n                 (match self.tcx.map.expect_expr(the_move.id).node {\n-                    hir::ExprClosure(_, _, _, fn_decl_span) => fn_decl_span,\n+                    hir::ExprClosure(.., fn_decl_span) => fn_decl_span,\n                     ref r => bug!(\"Captured({}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n                 }, \" (into closure)\"),\n@@ -1028,6 +1024,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n             err_out_of_scope(super_scope, sub_scope, cause) => {\n+                let (value_kind, value_msg) = match err.cmt.cat {\n+                    mc::Categorization::Rvalue(_) =>\n+                        (\"temporary value\", \"temporary value created here\"),\n+                    _ =>\n+                        (\"borrowed value\", \"does not live long enough\")\n+                };\n                 match cause {\n                     euv::ClosureCapture(s) => {\n                         // The primary span starts out as the closure creation point.\n@@ -1038,13 +1040,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             Some(primary) => {\n                                 db.span = MultiSpan::from_span(s);\n                                 db.span_label(primary, &format!(\"capture occurs here\"));\n-                                db.span_label(s, &format!(\"does not live long enough\"));\n+                                db.span_label(s, &value_msg);\n                             }\n                             None => ()\n                         }\n                     }\n                     _ => {\n-                        db.span_label(error_span, &format!(\"does not live long enough\"));\n+                        db.span_label(error_span, &value_msg);\n                     }\n                 }\n \n@@ -1053,14 +1055,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 match (sub_span, super_span) {\n                     (Some(s1), Some(s2)) if s1 == s2 => {\n-                        db.span_label(s1, &\"borrowed value dropped before borrower\");\n+                        db.span_label(s1, &format!(\"{} dropped before borrower\", value_kind));\n                         db.note(\"values in a scope are dropped in the opposite order \\\n                                 they are created\");\n                     }\n                     _ => {\n                         match sub_span {\n                             Some(s) => {\n-                                db.span_label(s, &\"borrowed value must be valid until here\");\n+                                db.span_label(s, &format!(\"{} needs to live until here\",\n+                                                          value_kind));\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n@@ -1072,7 +1075,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         }\n                         match super_span {\n                             Some(s) => {\n-                                db.span_label(s, &\"borrowed value only valid until here\");\n+                                db.span_label(s, &format!(\"{} only lives until here\", value_kind));\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n@@ -1085,9 +1088,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                if let Some(span) = statement_scope_span(self.tcx, super_scope) {\n-                    db.span_help(span,\n-                                 \"consider using a `let` binding to increase its lifetime\");\n+                if let Some(_) = statement_scope_span(self.tcx, super_scope) {\n+                    db.note(\"consider using a `let` binding to increase its lifetime\");\n                 }\n             }\n \n@@ -1130,7 +1132,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push(')');\n             }\n \n-\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(fname))) => {\n                 self.append_autoderefd_loan_path_to_string(&lp_base, out);\n                 match fname {\n@@ -1176,7 +1177,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push(')');\n             }\n \n-            LpVar(..) | LpUpvar(..) | LpExtend(_, _, LpInterior(..)) => {\n+            LpVar(..) | LpUpvar(..) | LpExtend(.., LpInterior(..)) => {\n                 self.append_loan_path_to_string(loan_path, out)\n             }\n         }"}, {"sha": "e9ba406389f88ae022b5512aa16518a1403a1963", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -21,7 +21,8 @@ use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n-use rustc::ty::TyCtxt;\n+use rustc::middle::mem_categorization as mc;\n+use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n use std::cell::RefCell;\n@@ -196,7 +197,7 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n         LpVar(_) | LpUpvar(_) => {\n             true\n         }\n-        LpExtend(_, _, LpInterior(_, InteriorKind::InteriorElement(..))) => {\n+        LpExtend(.., LpInterior(_, InteriorKind::InteriorElement(..))) => {\n             // Paths involving element accesses a[i] do not refer to a unique\n             // location, as there is no accurate tracking of the indices.\n             //\n@@ -206,7 +207,7 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n             false\n         }\n         LpDowncast(ref lp_base, _) |\n-        LpExtend(ref lp_base, _, _) => {\n+        LpExtend(ref lp_base, ..) => {\n             loan_path_is_precise(&lp_base)\n         }\n     }\n@@ -294,7 +295,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             }\n \n             LpDowncast(ref base, _) |\n-            LpExtend(ref base, _, _) => {\n+            LpExtend(ref base, ..) => {\n                 let parent_index = self.move_path(tcx, base.clone());\n \n                 let index = MovePathIndex(self.paths.borrow().len());\n@@ -350,7 +351,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                 match lp.kind {\n                     LpVar(..) | LpUpvar(..) => { }\n                     LpDowncast(ref b, _) |\n-                    LpExtend(ref b, _, _) => {\n+                    LpExtend(ref b, ..) => {\n                         self.add_existing_base_paths(b, result);\n                     }\n                 }\n@@ -364,6 +365,34 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                     lp: Rc<LoanPath<'tcx>>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n+        // Moving one union field automatically moves all its fields.\n+        if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n+            if let ty::TyAdt(adt_def, _) = base_lp.ty.sty {\n+                if adt_def.is_union() {\n+                    for field in &adt_def.struct_variant().fields {\n+                        let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                        let field_ty = if field == interior {\n+                            lp.ty\n+                        } else {\n+                            tcx.types.err // Doesn't matter\n+                        };\n+                        let sibling_lp_kind = LpExtend(base_lp.clone(), mutbl,\n+                                                    LpInterior(opt_variant_id, field));\n+                        let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n+                        self.add_move_helper(tcx, sibling_lp, id, kind);\n+                    }\n+                    return;\n+                }\n+            }\n+        }\n+\n+        self.add_move_helper(tcx, lp.clone(), id, kind);\n+    }\n+\n+    fn add_move_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       lp: Rc<LoanPath<'tcx>>,\n+                       id: ast::NodeId,\n+                       kind: MoveKind) {\n         debug!(\"add_move(lp={:?}, id={}, kind={:?})\",\n                lp,\n                id,\n@@ -393,6 +422,37 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                           span: Span,\n                           assignee_id: ast::NodeId,\n                           mode: euv::MutateMode) {\n+        // Assigning to one union field automatically assigns to all its fields.\n+        if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n+            if let ty::TyAdt(adt_def, _) = base_lp.ty.sty {\n+                if adt_def.is_union() {\n+                    for field in &adt_def.struct_variant().fields {\n+                        let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                        let field_ty = if field == interior {\n+                            lp.ty\n+                        } else {\n+                            tcx.types.err // Doesn't matter\n+                        };\n+                        let sibling_lp_kind = LpExtend(base_lp.clone(), mutbl,\n+                                                    LpInterior(opt_variant_id, field));\n+                        let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n+                        self.add_assignment_helper(tcx, sibling_lp, assign_id,\n+                                                   span, assignee_id, mode);\n+                    }\n+                    return;\n+                }\n+            }\n+        }\n+\n+        self.add_assignment_helper(tcx, lp.clone(), assign_id, span, assignee_id, mode);\n+    }\n+\n+    fn add_assignment_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             lp: Rc<LoanPath<'tcx>>,\n+                             assign_id: ast::NodeId,\n+                             span: Span,\n+                             assignee_id: ast::NodeId,\n+                             mode: euv::MutateMode) {\n         debug!(\"add_assignment(lp={:?}, assign_id={}, assignee_id={}\",\n                lp, assign_id, assignee_id);\n "}, {"sha": "22b590592fe168d3277d3f7a4e31b28b4706debc", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -19,6 +19,7 @@\n \n #![allow(non_camel_case_types)]\n \n+#![feature(dotdot_in_tuple_patterns)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "eb74936d8c905380625a63e630a06f6a24934631", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 106, "deletions": 95, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "patch": "@@ -26,8 +26,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n use rustc::hir::pat_util::*;\n use rustc::traits::Reveal;\n-use rustc::ty::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty, TyCtxt};\n use std::cmp::Ordering;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator, repeat};\n@@ -40,11 +39,10 @@ use rustc_back::slice;\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n use syntax::codemap::Spanned;\n use syntax_pos::{Span, DUMMY_SP};\n-use rustc::hir::fold::{Folder, noop_fold_pat};\n use rustc::hir::print::pat_to_string;\n use syntax::ptr::P;\n+use syntax::util::move_map::MoveMap;\n use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n@@ -111,7 +109,7 @@ impl<'a, 'tcx> FromIterator<Vec<(&'a Pat, Option<Ty<'tcx>>)>> for Matrix<'a, 'tc\n //NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub param_env: ParameterEnvironment<'tcx>,\n+    pub param_env: ty::ParameterEnvironment<'tcx>,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -182,7 +180,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 }\n             }\n \n-            let mut static_inliner = StaticInliner::new(cx.tcx, None);\n+            let mut static_inliner = StaticInliner::new(cx.tcx);\n             let inlined_arms = arms.iter().map(|arm| {\n                 (arm.pats.iter().map(|pat| {\n                     static_inliner.fold_pat((*pat).clone())\n@@ -245,21 +243,23 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n     pat.walk(|p| {\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n             let pat_ty = cx.tcx.pat_ty(p);\n-            if let ty::TyEnum(edef, _) = pat_ty.sty {\n-                if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n-                    if edef.variants.iter().any(|variant| {\n-                        variant.name == name.node && variant.kind == VariantKind::Unit\n-                    }) {\n-                        let ty_path = cx.tcx.item_path_str(edef.did);\n-                        let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n-                            \"pattern binding `{}` is named the same as one \\\n-                             of the variants of the type `{}`\",\n-                            name.node, ty_path);\n-                        help!(err,\n-                            \"if you meant to match on a variant, \\\n-                             consider making the path in the pattern qualified: `{}::{}`\",\n-                            ty_path, name.node);\n-                        err.emit();\n+            if let ty::TyAdt(edef, _) = pat_ty.sty {\n+                if edef.is_enum() {\n+                    if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n+                        if edef.variants.iter().any(|variant| {\n+                            variant.name == name.node && variant.kind == ty::VariantKind::Unit\n+                        }) {\n+                            let ty_path = cx.tcx.item_path_str(edef.did);\n+                            let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n+                                \"pattern binding `{}` is named the same as one \\\n+                                of the variants of the type `{}`\",\n+                                name.node, ty_path);\n+                            help!(err,\n+                                \"if you meant to match on a variant, \\\n+                                consider making the path in the pattern qualified: `{}::{}`\",\n+                                ty_path, name.node);\n+                            err.emit();\n+                        }\n                     }\n                 }\n             }\n@@ -372,8 +372,8 @@ fn check_arms(cx: &MatchCheckCtxt,\n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n fn pat_is_catchall(dm: &DefMap, p: &Pat) -> bool {\n     match p.node {\n-        PatKind::Binding(_, _, None) => true,\n-        PatKind::Binding(_, _, Some(ref s)) => pat_is_catchall(dm, &s),\n+        PatKind::Binding(.., None) => true,\n+        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(dm, &s),\n         PatKind::Ref(ref s, _) => pat_is_catchall(dm, &s),\n         PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(dm, &p)),\n         _ => false\n@@ -382,7 +382,7 @@ fn pat_is_catchall(dm: &DefMap, p: &Pat) -> bool {\n \n fn raw_pat(p: &Pat) -> &Pat {\n     match p.node {\n-        PatKind::Binding(_, _, Some(ref s)) => raw_pat(&s),\n+        PatKind::Binding(.., Some(ref s)) => raw_pat(&s),\n         _ => p\n     }\n }\n@@ -408,10 +408,13 @@ fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                         },\n                         _ => bug!(),\n                     };\n-                    span_err!(cx.tcx.sess, sp, E0297,\n+                    let pattern_string = pat_to_string(witness);\n+                    struct_span_err!(cx.tcx.sess, sp, E0297,\n                         \"refutable pattern in `for` loop binding: \\\n                                 `{}` not covered\",\n-                                pat_to_string(witness));\n+                                pattern_string)\n+                        .span_label(sp, &format!(\"pattern `{}` not covered\", pattern_string))\n+                        .emit();\n                 },\n                 _ => {\n                     let pattern_strings: Vec<_> = witnesses.iter().map(|w| {\n@@ -455,94 +458,100 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n         _ => bug!()\n     };\n     P(hir::Expr {\n-        id: 0,\n+        id: DUMMY_NODE_ID,\n         node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n         span: DUMMY_SP,\n         attrs: ast::ThinVec::new(),\n     })\n }\n \n-pub struct StaticInliner<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub failed: bool,\n-    pub renaming_map: Option<&'a mut FnvHashMap<(NodeId, Span), NodeId>>,\n+struct StaticInliner<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    failed: bool\n }\n \n impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                   renaming_map: Option<&'b mut FnvHashMap<(NodeId, Span), NodeId>>)\n-                   -> StaticInliner<'b, 'tcx> {\n+    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx, 'tcx>) -> StaticInliner<'b, 'tcx> {\n         StaticInliner {\n             tcx: tcx,\n-            failed: false,\n-            renaming_map: renaming_map\n+            failed: false\n         }\n     }\n }\n \n-struct RenamingRecorder<'map> {\n-    substituted_node_id: NodeId,\n-    origin_span: Span,\n-    renaming_map: &'map mut FnvHashMap<(NodeId, Span), NodeId>\n-}\n-\n-impl<'v, 'map> Visitor<'v> for RenamingRecorder<'map> {\n-    fn visit_id(&mut self, node_id: NodeId) {\n-        let key = (node_id, self.origin_span);\n-        self.renaming_map.insert(key, self.substituted_node_id);\n-    }\n-}\n-\n-impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n+impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n-        return match pat.node {\n+        match pat.node {\n             PatKind::Path(..) => {\n                 match self.tcx.expect_def(pat.id) {\n                     Def::AssociatedConst(did) | Def::Const(did) => {\n                         let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n                         if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n                             match const_expr_to_pat(self.tcx, const_expr, pat.id, pat.span) {\n-                                Ok(new_pat) => {\n-                                    if let Some(ref mut map) = self.renaming_map {\n-                                        // Record any renamings we do here\n-                                        record_renamings(const_expr, &pat, map);\n-                                    }\n-                                    new_pat\n-                                }\n+                                Ok(new_pat) => return new_pat,\n                                 Err(def_id) => {\n                                     self.failed = true;\n                                     self.tcx.sess.span_err(\n                                         pat.span,\n                                         &format!(\"constants of the type `{}` \\\n                                                   cannot be used in patterns\",\n                                                  self.tcx.item_path_str(def_id)));\n-                                    pat\n                                 }\n                             }\n                         } else {\n                             self.failed = true;\n                             span_err!(self.tcx.sess, pat.span, E0158,\n                                 \"statics cannot be referenced in patterns\");\n-                            pat\n                         }\n                     }\n-                    _ => noop_fold_pat(pat, self)\n+                    _ => {}\n                 }\n             }\n-            _ => noop_fold_pat(pat, self)\n-        };\n+            _ => {}\n+        }\n \n-        fn record_renamings(const_expr: &hir::Expr,\n-                            substituted_pat: &hir::Pat,\n-                            renaming_map: &mut FnvHashMap<(NodeId, Span), NodeId>) {\n-            let mut renaming_recorder = RenamingRecorder {\n-                substituted_node_id: substituted_pat.id,\n-                origin_span: substituted_pat.span,\n-                renaming_map: renaming_map,\n+        pat.map(|Pat { id, node, span }| {\n+            let node = match node {\n+                PatKind::Binding(binding_mode, pth1, sub) => {\n+                    PatKind::Binding(binding_mode, pth1, sub.map(|x| self.fold_pat(x)))\n+                }\n+                PatKind::TupleStruct(pth, pats, ddpos) => {\n+                    PatKind::TupleStruct(pth, pats.move_map(|x| self.fold_pat(x)), ddpos)\n+                }\n+                PatKind::Struct(pth, fields, etc) => {\n+                    let fs = fields.move_map(|f| {\n+                        Spanned {\n+                            span: f.span,\n+                            node: hir::FieldPat {\n+                                name: f.node.name,\n+                                pat: self.fold_pat(f.node.pat),\n+                                is_shorthand: f.node.is_shorthand,\n+                            },\n+                        }\n+                    });\n+                    PatKind::Struct(pth, fs, etc)\n+                }\n+                PatKind::Tuple(elts, ddpos) => {\n+                    PatKind::Tuple(elts.move_map(|x| self.fold_pat(x)), ddpos)\n+                }\n+                PatKind::Box(inner) => PatKind::Box(self.fold_pat(inner)),\n+                PatKind::Ref(inner, mutbl) => PatKind::Ref(self.fold_pat(inner), mutbl),\n+                PatKind::Vec(before, slice, after) => {\n+                    PatKind::Vec(before.move_map(|x| self.fold_pat(x)),\n+                                 slice.map(|x| self.fold_pat(x)),\n+                                 after.move_map(|x| self.fold_pat(x)))\n+                }\n+                PatKind::Wild |\n+                PatKind::Lit(_) |\n+                PatKind::Range(..) |\n+                PatKind::Path(..) => node\n             };\n-\n-            renaming_recorder.visit_expr(const_expr);\n-        }\n+            Pat {\n+                id: id,\n+                node: node,\n+                span: span\n+            }\n+        })\n     }\n }\n \n@@ -566,10 +575,10 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     let pat = match left_ty.sty {\n         ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n \n-        ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n+        ty::TyAdt(adt, _) => {\n             let v = ctor.variant_for_adt(adt);\n             match v.kind {\n-                VariantKind::Struct => {\n+                ty::VariantKind::Struct => {\n                     let field_pats: hir::HirVec<_> = v.fields.iter()\n                         .zip(pats)\n                         .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n@@ -584,10 +593,10 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                     let has_more_fields = field_pats.len() < pats_len;\n                     PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n                 }\n-                VariantKind::Tuple => {\n+                ty::VariantKind::Tuple => {\n                     PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n                 }\n-                VariantKind::Unit => {\n+                ty::VariantKind::Unit => {\n                     PatKind::Path(None, def_to_path(cx.tcx, v.did))\n                 }\n             }\n@@ -620,7 +629,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     };\n \n     P(hir::Pat {\n-        id: 0,\n+        id: DUMMY_NODE_ID,\n         node: pat,\n         span: DUMMY_SP\n     })\n@@ -629,7 +638,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n impl Constructor {\n     fn variant_for_adt<'tcx, 'container, 'a>(&self,\n                                              adt: &'a ty::AdtDefData<'tcx, 'container>)\n-                                             -> &'a VariantDefData<'tcx, 'container> {\n+                                             -> &'a ty::VariantDefData<'tcx, 'container> {\n         match self {\n             &Variant(vid) => adt.variant_with_id(vid),\n             _ => adt.struct_variant()\n@@ -659,7 +668,8 @@ fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(_) =>\n             (0..max_slice_length+1).map(|length| Slice(length)).collect(),\n-        ty::TyEnum(def, _) => def.variants.iter().map(|v| Variant(v.did)).collect(),\n+        ty::TyAdt(def, _) if def.is_enum() =>\n+            def.variants.iter().map(|v| Variant(v.did)).collect(),\n         _ => vec![Single]\n     }\n }\n@@ -791,8 +801,9 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n             match cx.tcx.expect_def(pat.id) {\n-                Def::Variant(_, id) => vec![Variant(id)],\n-                Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n+                Def::Variant(id) => vec![Variant(id)],\n+                Def::Struct(..) | Def::Union(..) |\n+                Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat.span, \"const pattern should've been rewritten\"),\n                 def => span_bug!(pat.span, \"pat_constructors: unexpected definition {:?}\", def),\n@@ -803,7 +814,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n             vec![ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))],\n         PatKind::Vec(ref before, ref slice, ref after) =>\n             match left_ty.sty {\n-                ty::TyArray(_, _) => vec![Single],\n+                ty::TyArray(..) => vec![Single],\n                 ty::TySlice(_) if slice.is_some() => {\n                     (before.len() + after.len()..max_slice_length+1)\n                         .map(|length| Slice(length))\n@@ -836,7 +847,7 @@ pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> us\n             _ => bug!()\n         },\n         ty::TyRef(..) => 1,\n-        ty::TyEnum(adt, _) | ty::TyStruct(adt, _) => {\n+        ty::TyAdt(adt, _) => {\n             ctor.variant_for_adt(adt).fields.len()\n         }\n         ty::TyArray(_, n) => n,\n@@ -865,8 +876,8 @@ fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n {\n     let pat_ty = cx.tcx.pat_ty(pat);\n     (pat, Some(match pat.node {\n-        PatKind::Binding(hir::BindByRef(..), _, _) => {\n-            pat_ty.builtin_deref(false, NoPreference).unwrap().ty\n+        PatKind::Binding(hir::BindByRef(..), ..) => {\n+            pat_ty.builtin_deref(false, ty::NoPreference).unwrap().ty\n         }\n         _ => pat_ty\n     }))\n@@ -902,7 +913,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n-                Def::Variant(_, id) if *constructor != Variant(id) => None,\n+                Def::Variant(id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n                 def => span_bug!(pat_span, \"specialize: unexpected \\\n                                           definition {:?}\", def),\n@@ -914,7 +925,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n-                Def::Variant(_, id) if *constructor != Variant(id) => None,\n+                Def::Variant(id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => {\n                     match ddpos {\n                         Some(ddpos) => {\n@@ -1040,7 +1051,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n fn check_local(cx: &mut MatchCheckCtxt, loc: &hir::Local) {\n     intravisit::walk_local(cx, loc);\n \n-    let pat = StaticInliner::new(cx.tcx, None).fold_pat(loc.pat.clone());\n+    let pat = StaticInliner::new(cx.tcx).fold_pat(loc.pat.clone());\n     check_irrefutable(cx, &pat, false);\n \n     // Check legality of move bindings and `@` patterns.\n@@ -1056,7 +1067,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             fn_id: NodeId) {\n     match kind {\n         FnKind::Closure(_) => {}\n-        _ => cx.param_env = ParameterEnvironment::for_item(cx.tcx, fn_id),\n+        _ => cx.param_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_id),\n     }\n \n     intravisit::walk_fn(cx, kind, decl, body, sp, fn_id);\n@@ -1175,17 +1186,17 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n               _: NodeId,\n               span: Span,\n               _: cmt,\n-              _: &'tcx Region,\n-              kind: BorrowKind,\n+              _: &'tcx ty::Region,\n+              kind:ty:: BorrowKind,\n               _: LoanCause) {\n         match kind {\n-            MutBorrow => {\n+            ty::MutBorrow => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0301,\n                           \"cannot mutably borrow in a pattern guard\")\n                     .span_label(span, &format!(\"borrowed mutably in pattern guard\"))\n                     .emit();\n             }\n-            ImmBorrow | UniqueImmBorrow => {}\n+            ty::ImmBorrow | ty::UniqueImmBorrow => {}\n         }\n     }\n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n@@ -1216,7 +1227,7 @@ struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     fn visit_pat(&mut self, pat: &Pat) {\n         match pat.node {\n-            PatKind::Binding(_, _, ref subpat) => {\n+            PatKind::Binding(.., ref subpat) => {\n                 if !self.bindings_allowed {\n                     span_err!(self.cx.tcx.sess, pat.span, E0303,\n                               \"pattern bindings are not allowed after an `@`\");"}, {"sha": "dce3882004c6740ebbbe5d9ee0f9967f4c5a4439", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "f926fef065ea6c228fed4cc17a473a5ac0e7930f", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "ae90c2fac83218c21c27574ec88959d82f4596fd", "filename": "src/librustc_data_structures/fnv.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_data_structures%2Ffnv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_data_structures%2Ffnv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffnv.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "ea7621e16e7b7de192c4054bc4862f0064d9c044", "filename": "src/librustc_driver/derive_registrar.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_driver%2Fderive_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_driver%2Fderive_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fderive_registrar.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "55892801247b5459a5420c43fadd2155c7b4510b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 52, "deletions": 36, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "681a7ec5b5ac99d1f89670c7fb89b9ef8b3060ed", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "215287f84399c1d9e079c8ac09bc6326e5d99ed1", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "f6772b8771844526844b125f35a575bc00d17633", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "1bdc9ef30881fe44390e2c7ca615b11864419203", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "bc599a8207656aadff7a97317ce884f9c7bbd3bb", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "e3ee7527545042211481ecf9d36f6e228c23f0bc", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "b28454cddb247feedf5868d4ddc69b3cd0662abf", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 71, "deletions": 87, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "ad9c48420e217d04b5a82ba23808b7a1064464c3", "filename": "src/librustc_incremental/calculate_svh/caching_codemap_view.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fcaching_codemap_view.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "c54fe2114517e17d234ba9044a6c5acc886f5605", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "9950f470a82c486fe78cf642af52d74db257509d", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 340, "deletions": 85, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "42b5657e212b02be11d3c9938372368c286e5f97", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "7e2d5b8c8ef6365c60787654d1e2d72aef5c2027", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "c9cfaf4f6613fd6a59490b8d571477bbbe05e7ec", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "5a4716e45f6e1f9ae6af39fe04ac38394bae6cc0", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "b051e6c5ab73a1f759d061c1b6049b43f2216895", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "5b45874840f5676fec5c559e4dd5b86badc00def", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "84d65308f952ffbbdd613ec43cff0bbeb5158b5a", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "b610a924a339666e264c515538af7a7a32ffc0f8", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "bc2979c806f65abb619ddc63cfcb4100ddf8d3d1", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "1209ced8dd3d75ffd0d4fc45c67363267194ebd3", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 103, "deletions": 73, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "d31f16df693569ed1a5270d3508901e86d859337", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "50c68d5e75eef18602b86d622119474339ade5a8", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "6b3ee21d9acebf074b48643b5227a0377a708b38", "filename": "src/librustc_macro/Cargo.toml", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macro%2FCargo.toml?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "previous_filename": "src/librbml/Cargo.toml"}, {"sha": "c2a2cc2ecd64d9c7414aafea261843b3858db034", "filename": "src/librustc_macro/lib.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macro%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "680d55955bb96a928beb606c0986ea0a91155767", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "c9dbedacbc1a5a3a85cb40e72960aa4422d8ee93", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 101, "deletions": 1318, "changes": 1419, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "85cf41e42a2737194e583093c55dd389970e0561", "filename": "src/librustc_metadata/common.rs", "status": "removed", "additions": 0, "deletions": 239, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=da3c6b7646fb94a747583f34cfa5c63ee4ea094a"}, {"sha": "95be77c24f46eb952e4c6732fd99dda696f554e0", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 216, "deletions": 270, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "1f25136ffe1acc679c7870dc66be5362b2f3ff5c", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 132, "deletions": 301, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "0a1ff70a0497e518992afb0b8507f63aab173d32", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 62, "deletions": 91, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "3e4a2542b270bc9f7b7bd3c22e56142b2f2dac21", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 903, "deletions": 1399, "changes": 2302, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "285ca2e4d4d4de2367259410dd9f09a3e291e73c", "filename": "src/librustc_metadata/def_key.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Fdef_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Fdef_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdef_key.rs?ref=da3c6b7646fb94a747583f34cfa5c63ee4ea094a"}, {"sha": "f52e1437acc9534a9b1a5c98c313d617c38aaf67", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 183, "deletions": 9, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "0f067270b80f5cb84c67bac8fc0ae956736ea6fd", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1074, "deletions": 1625, "changes": 2699, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "ef83251f51e8d18ed725b411528bc3b5f0516493", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 48, "deletions": 91, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "aeb6f63252c6efde1076d36680c82b6f0564d455", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 39, "deletions": 68, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "4fc5a46762d1215136d9e4291537c2a30c250e12", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "fc94cec916aad146be7f830c77cc64040aa7912b", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "e41f076d64a80bea5abc8e227509d937d3fe05b1", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 92, "deletions": 13, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "ed764ebd9f95dd4e27b579342fc0f4c66e77a486", "filename": "src/librustc_metadata/macros.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacros.rs?ref=da3c6b7646fb94a747583f34cfa5c63ee4ea094a"}, {"sha": "f4d1e8e17f842066e39ec459dd6d39da5ee2de29", "filename": "src/librustc_metadata/schema.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "6e78cbcd28e731e663b698a6fc16d2068b041113", "filename": "src/librustc_metadata/tls_context.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Ftls_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Ftls_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftls_context.rs?ref=da3c6b7646fb94a747583f34cfa5c63ee4ea094a"}, {"sha": "f51299226fe7da904ff2f689e194d4eb8ad36cd6", "filename": "src/librustc_metadata/tydecode.rs", "status": "removed", "additions": 0, "deletions": 758, "changes": 758, "blob_url": "https://github.com/rust-lang/rust/blob/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=da3c6b7646fb94a747583f34cfa5c63ee4ea094a"}, {"sha": "7255eae61d4533cd75b205caae28b6f7f256e121", "filename": "src/librustc_metadata/tyencode.rs", "status": "removed", "additions": 0, "deletions": 534, "changes": 534, "blob_url": "https://github.com/rust-lang/rust/blob/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=da3c6b7646fb94a747583f34cfa5c63ee4ea094a"}, {"sha": "a40571c5d859784125c247ea19cf785b6e8d1622", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "23591f05b8774f27d6a61815335a8ca58559f332", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "7329a20c497082d431b688aa306f0b3ec50c685f", "filename": "src/librustc_mir/def_use.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdef_use.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "6283ff2187ab8bbed00b8ff395d367627f26a409", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 54, "deletions": 55, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "8dd33ad2f9c7a1e2b371254cc3ff5911ab0ca8ce", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "7b8446b184fb3725f4fd8fc2170c25a23a9cbe62", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "12f1eb8535a3eb7bd27a48a060988b326d3ed06d", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "01e2c6308ba01b9ef9d00a81e6da5519fb08a64f", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "33f3d6d8842eae5ccb623f5699a5c063857ea323", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "77af02c18c60ed3cb37f94e3a85b7f19e07c3c9d", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "694b017bbd70687a9f9c0334d731200baa989f18", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "a0331f03b019742e9d1b2f51486deee00187b756", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "7bcb89b5895e78698dc13eac93643c74ce64fc1b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "57de68fce1d1a4543e435b08bf4cc0b847fa00ba", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "c3a22853f84373b7aa484b86a465201ce4159b38", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "407e21616102cafc7d9ea67f9571c217329e974c", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "8e1b7b44976f33c0c2baf8875d646afff8e0ae6d", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "7b6a2f5580819c98ddce4ee4265185aeb3ada921", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "6275639a9adfff9649c41192389deb2e76f5ae2c", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "f919e42b6bd7d38d6de6f483f002192ee80ae70f", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "a4657251c9ce2f16a9497b5a2ec5f2ef4fcf6ee1", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "e942707acd56b94e9cb7409887b71b25a48a135f", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "0ab8e2d7fcd2812b50e8740fcf687c18629670b0", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "8f0cc2c3d750f96e35e87943371531c6e9b60d3c", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "66afe5835bf6fc6f3549dfc788e7feaab720f948", "filename": "src/librustc_privacy/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_privacy%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_privacy%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Fdiagnostics.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "1b119fd008509c61ed7f8c2bf8f982b12c94f16e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 54, "deletions": 39, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "a9e3c6ffe9ed887d028208dab5d64fa7e49d70e3", "filename": "src/librustc_resolve/assign_ids.rs", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3c6b7646fb94a747583f34cfa5c63ee4ea094a/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=da3c6b7646fb94a747583f34cfa5c63ee4ea094a"}, {"sha": "c9591c31831a850fe0ec7b30051ead1eac0ba45e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 72, "deletions": 57, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "93abe07128fa1d5bb0dfa19cf2b3e5c2256a6e08", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "016b621eabd4c598c79421e17240667754a4a777", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 217, "deletions": 180, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "e452a44cea5878b7fafaacd258dcbb04efcbf35a", "filename": "src/librustc_resolve/macros.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "29add1f9b9d4972b2329426593b0909c43d49002", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 143, "deletions": 61, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "fc235aaf9276b7450fa4cfec91e900776573fb80", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 63, "deletions": 7, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "79fcff7d8a166471e43dfe956b88e9bb4b891daf", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 192, "deletions": 110, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "5847575742342680efc3ed8742c77c1f44c8f436", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 66, "deletions": 9, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "d56aae18a7cd1f65e49a64d55bacc1acbf47082b", "filename": "src/librustc_save_analysis/json_api_dumper.rs", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "0378d75cc6eb1d4d57e5ce3302748095f902ae8c", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "aa68a873120ec8670db7ed78c17699c0ad84e02f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 77, "deletions": 36, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "1a6c34b55af650b52426d0bd0a6ad0362ad26557", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "fdbee50992dd19fbcbd690f9c8738fd3b689cf30", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 276, "deletions": 157, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "201e1e5f2ec4cf05619bbcd239d317fe69a33586", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "dd14f98c9207fc6e97b0c24f0d7ea5b8be2ea591", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "4ed860bd40d86b3f835b98aa94c7efeeca42f13f", "filename": "src/librustc_trans/back/rpath.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c", "previous_filename": "src/librustc_back/rpath.rs"}, {"sha": "0a668db06908090b8a7689380bdf37ffc5da243b", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 55, "deletions": 62, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "04b814e2b9772fd3b162454650a349e8aca7b5ef", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "1e05b31eeadf6b6f70a07f6ca80db664b0ebf67b", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 45, "deletions": 58, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}, {"sha": "e92ef1eaec8ec571ad74a4274afca8122ef2f6a7", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20c10913ffd57ceda12f5ed3980c5170686bd52c/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=20c10913ffd57ceda12f5ed3980c5170686bd52c"}]}