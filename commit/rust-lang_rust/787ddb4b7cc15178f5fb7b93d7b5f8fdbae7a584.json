{"sha": "787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4N2RkYjRiN2NjMTUxNzhmNWZiN2I5M2Q3YjVmOGZkYmFlN2E1ODQ=", "commit": {"author": {"name": "Zack Corr", "email": "zack@z0w0.me", "date": "2013-01-23T06:38:05Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-16T02:04:10Z"}, "message": "rustpkg: Clean up formatting issues", "tree": {"sha": "81c38bafa84910fe63f6836ed5e6573db96cca28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81c38bafa84910fe63f6836ed5e6573db96cca28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584", "html_url": "https://github.com/rust-lang/rust/commit/787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584/comments", "author": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c82183de19ad3c77c16bbf34bebf1f73b297e526", "url": "https://api.github.com/repos/rust-lang/rust/commits/c82183de19ad3c77c16bbf34bebf1f73b297e526", "html_url": "https://github.com/rust-lang/rust/commit/c82183de19ad3c77c16bbf34bebf1f73b297e526"}], "stats": {"total": 469, "additions": 240, "deletions": 229}, "files": [{"sha": "349bbd0f4086f5f34c4a67c49a8ea1b9125d6212", "filename": "src/librustpkg/api.rs", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/c82183de19ad3c77c16bbf34bebf1f73b297e526/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c82183de19ad3c77c16bbf34bebf1f73b297e526/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=c82183de19ad3c77c16bbf34bebf1f73b297e526", "patch": "@@ -1,141 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::*;\n-use util::{compile_crate, note};\n-\n-/// A crate is a unit of Rust code to be compiled into a binary or library\n-pub struct Crate {\n-    file: ~str,\n-    flags: ~[~str],\n-    cfgs: ~[~str]\n-}\n-\n-pub struct Listener {\n-    cmds: ~[~str],\n-    cb: fn~()\n-}\n-\n-pub fn run(listeners: ~[Listener]) {\n-    let rcmd = os::args()[2];\n-    let mut found = false;\n-\n-    for listeners.each |listener| {\n-        for listener.cmds.each |&cmd| {\n-            if cmd == rcmd {\n-                (listener.cb)();\n-\n-                found = true;\n-\n-                break;\n-            }\n-        }\n-    }\n-\n-    if !found {\n-        os::set_exit_status(1);\n-    }\n-}\n-\n-pub impl Crate {\n-   fn flag(flag: ~str) -> Crate {\n-        Crate {\n-            flags: vec::append(copy self.flags, ~[flag]),\n-            .. copy self\n-        }\n-    }\n-\n-    fn flags(flags: ~[~str]) -> Crate {\n-        Crate {\n-            flags: vec::append(copy self.flags, flags),\n-            .. copy self\n-        }\n-    }\n-\n-   fn cfg(cfg: ~str) -> Crate {\n-        Crate {\n-            cfgs: vec::append(copy self.cfgs, ~[cfg]),\n-            .. copy self\n-        }\n-    }\n-\n-    fn cfgs(cfgs: ~[~str]) -> Crate {\n-        Crate {\n-            cfgs: vec::append(copy self.cfgs, cfgs),\n-            .. copy self\n-        }\n-    }\n-}\n-\n-/// Create a crate target from a source file\n-pub fn Crate(file: ~str) -> Crate {\n-    Crate {\n-        file: file,\n-        flags: ~[],\n-        cfgs: ~[]\n-    }\n-}\n-\n-/** \n- * Get the working directory of the package script.\n- * Assumes that the package script has been compiled\n- * in is the working directory.\n- */\n-fn work_dir() -> Path {\n-    os::self_exe_path().get()\n-}\n-\n-/**\n- * Get the source directory of the package (i.e.\n- * where the crates are located). Assumes\n- * that the cwd is changed to it before\n- * running this executable.\n- */\n-fn src_dir() -> Path {\n-    os::getcwd()\n-}\n-\n-pub fn args() -> ~[~str] {\n-    let mut args = os::args();\n-\n-    args.shift();\n-    args.shift();\n-\n-    args\n-}\n-\n-/// Build a set of crates, should be called once\n-pub fn build(crates: ~[Crate]) -> bool {\n-    let dir = src_dir();\n-    let work_dir = work_dir();\n-    let mut success = true;\n-    let sysroot = Path(os::args()[1]);\n-\n-    for crates.each |&crate| {\n-        let path = &dir.push_rel(&Path(crate.file)).normalize();\n-\n-        note(fmt!(\"compiling %s\", path.to_str()));\n-\n-        success = compile_crate(Some(sysroot), path, &work_dir, crate.flags, crate.cfgs,\n-                                false, false);\n-\n-        if !success { break; }\n-    }\n-\n-    if !success {\n-        os::set_exit_status(2);\n-    }\n-\n-    success\n-}\n-\n-pub mod util {\n-    // TODO: utilities for working with things like autotools\n-}"}, {"sha": "329c61f19187b953eeea13ff5db923a0dd8b6b49", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 156, "deletions": 30, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584", "patch": "@@ -35,7 +35,6 @@ use rustc::driver::{driver, session};\n use syntax::{ast, attr, codemap, diagnostic, parse, visit};\n use semver::Version;\n \n-mod api;\n mod usage;\n mod util;\n \n@@ -223,7 +222,8 @@ impl PackageScript {\n     }\n \n     // Build the bootstrap and run a command\n-    // TODO: Use JIT once it works, it should be faster\n+    // FIXME: Use workcache to only compile the script when changed\n+    // FIXME: Use JIT once it works, it should be faster\n     fn run(cmd: ~str) -> int {\n         let work_dir = self.work_dir();\n         let input = self.input;\n@@ -297,7 +297,7 @@ impl Ctx {\n             }\n             ~\"install\" => {\n                 self.install(if args.len() >= 1 { Some(args[0]) }\n-                             else { None }, \n+                             else { None },\n                              if args.len() >= 2 { Some(args[1]) }\n                              else { None }, false);\n             }\n@@ -370,7 +370,7 @@ impl Ctx {\n             result::Err(err) => {\n                 util::error(err);\n \n-                return None; \n+                return None;\n             }\n         };\n         let work_dir = script.work_dir();\n@@ -391,8 +391,9 @@ impl Ctx {\n \n \n             if !success {\n-                util::error(fmt!(\"building %s v%s failed: a dep wasn't installed\",\n-                                 script.name, script.vers.to_str()));\n+                util::error(\n+                    fmt!(\"building %s v%s failed: a dep wasn't installed\",\n+                         script.name, script.vers.to_str()));\n \n                 return None;\n             }\n@@ -404,8 +405,9 @@ impl Ctx {\n         os::change_dir(dir);\n \n         if script.custom && script.run(~\"build\") != 0 {\n-            util::error(fmt!(\"building %s v%s failed: custom build logic failed\",\n-                             script.name, script.vers.to_str()));\n+            util::error(\n+                fmt!(\"building %s v%s failed: custom build logic failed\",\n+                     script.name, script.vers.to_str()));\n \n             return None;\n         }\n@@ -424,14 +426,16 @@ impl Ctx {\n         }\n \n         if !success {\n-            util::error(fmt!(\"building %s v%s failed: a crate failed to compile\",\n-                             script.name, script.vers.to_str()));\n+            util::error(\n+                fmt!(\"building %s v%s failed: a crate failed to compile\",\n+                     script.name, script.vers.to_str()));\n \n             return None;\n         }\n \n         if verbose {\n-            util::note(fmt!(\"built %s v%s\", script.name, script.vers.to_str()));\n+            util::note(fmt!(\"built %s v%s\", script.name,\n+                            script.vers.to_str()));\n         }\n \n         Some(script)\n@@ -453,8 +457,8 @@ impl Ctx {\n         };\n         let dir = script.work_dir();\n \n-        util::note(fmt!(\"cleaning %s v%s (%s)\", script.name, script.vers.to_str(),\n-                                                script.id));\n+        util::note(fmt!(\"cleaning %s v%s (%s)\", script.name,\n+                        script.vers.to_str(), script.id));\n \n         if os::path_exists(&dir) {\n             util::remove_dir_r(&dir);\n@@ -468,7 +472,7 @@ impl Ctx {\n     }\n \n     fn install(url: Option<~str>, target: Option<~str>, cache: bool) -> bool {\n-        let mut success = true;\n+        let mut success;\n         let mut dir;\n \n         if url.is_none() {\n@@ -544,8 +548,10 @@ impl Ctx {\n     }\n \n     fn fetch(dir: &Path, url: ~str, target: Option<~str>) -> bool {\n-        let url = match url::from_str(if str::find_str(url, \"://\").is_none() { ~\"http://\" + url }\n-                                                       else { url }) {\n+        let url = if str::find_str(url, \"://\").is_none() {\n+            ~\"http://\" + url }\n+        else { url };\n+        let url = match url::from_str(url) {\n             result::Ok(url) => url,\n             result::Err(err) => {\n                 util::error(fmt!(\"failed parsing %s\", err.to_lower()));\n@@ -579,14 +585,19 @@ impl Ctx {\n \n         let tar = dir.dir_path().push(&dir.file_path().to_str() + ~\".tar\");\n \n-        if run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", tar.to_str(), url]).status != 0 {\n+        if run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n+                                          ~\"-o\", tar.to_str(),\n+                                          url]).status != 0 {\n             util::error(~\"fetching failed: downloading using curl failed\");\n \n             return false;\n         }\n \n-        if run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\", ~\"-C\", dir.to_str(), ~\"-f\", tar.to_str()]).status != 0 {\n-            util::error(~\"fetching failed: extracting using tar failed (is it a valid tar archive?)\");\n+        if run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n+                                         ~\"-C\", dir.to_str(), ~\"-f\",\n+                                         tar.to_str()]).status != 0 {\n+            util::error(~\"fetching failed: extracting using tar failed\" +\n+                        ~\"(is it a valid tar archive?)\");\n \n             return false;\n         }\n@@ -600,7 +611,8 @@ impl Ctx {\n         // Git can't clone into a non-empty directory\n         util::remove_dir_r(dir);\n \n-        if run::program_output(~\"git\", ~[~\"clone\", url, dir.to_str()]).status != 0 {\n+        if run::program_output(~\"git\", ~[~\"clone\", url,\n+                                         dir.to_str()]).status != 0 {\n             util::error(~\"fetching failed: can't clone repository\");\n \n             return false;\n@@ -610,7 +622,9 @@ impl Ctx {\n             let mut success = true;\n \n             do util::temp_change_dir(dir) {\n-                success = run::program_output(~\"git\", ~[~\"checkout\", target.get()]).status != 0\n+                success = run::program_output(~\"git\",\n+                                              ~[~\"checkout\",\n+                                                target.get()]).status != 0\n             }\n \n             if !success {\n@@ -703,8 +717,8 @@ impl Ctx {\n             }\n         };\n \n-        util::note(fmt!(\"uninstalling %s v%s (%s)\", name, package.vers.to_str(),\n-                                                    package.id));\n+        util::note(fmt!(\"uninstalling %s v%s (%s)\", name,\n+                        package.vers.to_str(), package.id));\n \n         for vec::append(package.bins, package.libs).each |&file| {\n             let path = Path(file);\n@@ -742,8 +756,8 @@ impl Ctx {\n             }\n         };\n \n-        util::note(fmt!(\"unpreferring %s v%s (%s)\", name, package.vers.to_str(),\n-                                                    package.id));\n+        util::note(fmt!(\"unpreferring %s v%s (%s)\", name,\n+                        package.vers.to_str(), package.id));\n \n         let bin_dir = util::root().push(~\"bin\");\n \n@@ -815,8 +829,120 @@ pub fn main() {\n     }.run(cmd, args);\n }\n \n-pub use Crate = api::Crate;\n-pub use build = api::build;\n-pub use util = api::util;\n-pub use Listener = api::Listener;\n-pub use run = api::run;\n+\n+/// A crate is a unit of Rust code to be compiled into a binary or library\n+pub struct Crate {\n+    file: ~str,\n+    flags: ~[~str],\n+    cfgs: ~[~str]\n+}\n+\n+pub struct Listener {\n+    cmds: ~[~str],\n+    cb: fn~()\n+}\n+\n+pub fn run(listeners: ~[Listener]) {\n+    let rcmd = os::args()[2];\n+    let mut found = false;\n+\n+    for listeners.each |listener| {\n+        for listener.cmds.each |&cmd| {\n+            if cmd == rcmd {\n+                (listener.cb)();\n+\n+                found = true;\n+\n+                break;\n+            }\n+        }\n+    }\n+\n+    if !found {\n+        os::set_exit_status(1);\n+    }\n+}\n+\n+pub impl Crate {\n+    pub fn flag(flag: ~str) -> Crate {\n+        Crate {\n+            flags: vec::append(copy self.flags, ~[flag]),\n+            .. copy self\n+        }\n+    }\n+\n+    pub fn flags(flags: ~[~str]) -> Crate {\n+        Crate {\n+            flags: vec::append(copy self.flags, flags),\n+            .. copy self\n+        }\n+    }\n+\n+    pub fn cfg(cfg: ~str) -> Crate {\n+        Crate {\n+            cfgs: vec::append(copy self.cfgs, ~[cfg]),\n+            .. copy self\n+        }\n+    }\n+\n+    pub fn cfgs(cfgs: ~[~str]) -> Crate {\n+        Crate {\n+            cfgs: vec::append(copy self.cfgs, cfgs),\n+            .. copy self\n+        }\n+    }\n+}\n+\n+/// Create a crate target from a source file\n+pub fn Crate(file: ~str) -> Crate {\n+    Crate {\n+        file: file,\n+        flags: ~[],\n+        cfgs: ~[]\n+    }\n+}\n+\n+/**\n+ * Get the working directory of the package script.\n+ * Assumes that the package script has been compiled\n+ * in is the working directory.\n+ */\n+fn work_dir() -> Path {\n+    os::self_exe_path().get()\n+}\n+\n+/**\n+ * Get the source directory of the package (i.e.\n+ * where the crates are located). Assumes\n+ * that the cwd is changed to it before\n+ * running this executable.\n+ */\n+fn src_dir() -> Path {\n+    os::getcwd()\n+}\n+\n+/// Build a set of crates, should be called once\n+pub fn build(crates: ~[Crate]) -> bool {\n+    let dir = src_dir();\n+    let work_dir = work_dir();\n+    let mut success = true;\n+    let sysroot = Path(os::args()[1]);\n+\n+    for crates.each |&crate| {\n+        let path = &dir.push_rel(&Path(crate.file)).normalize();\n+\n+        util::note(fmt!(\"compiling %s\", path.to_str()));\n+\n+        success = util::compile_crate(Some(sysroot), path, &work_dir,\n+                                      crate.flags, crate.cfgs,\n+                                      false, false);\n+\n+        if !success { break; }\n+    }\n+\n+    if !success {\n+        os::set_exit_status(2);\n+    }\n+\n+    success\n+}"}, {"sha": "94fa140e51effea900f1c24cd49a71378420d826", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use core::io;\n- \n+\n pub fn general() {\n     io::println(~\"Usage: rustpkg [options] <cmd> [args..]\n \n@@ -69,17 +69,17 @@ Options:\n pub fn uninstall() {\n     io::println(~\"rustpkg uninstall <id|name>[@version]\n \n-Remove a package by id or name and optionally version. If the package(s) is/are depended\n-on by another package then they cannot be removed.\");\n+Remove a package by id or name and optionally version. If the package(s)\n+is/are depended on by another package then they cannot be removed.\");\n }\n \n pub fn prefer() {\n     io::println(~\"rustpkg [options..] prefer <id|name>[@version]\n \n By default all binaries are given a unique name so that multiple versions can\n coexist. The prefer command will symlink the uniquely named binary to\n-the binary directory under its bare name. If version is not supplied, the latest\n-version of the package will be preferred.\n+the binary directory under its bare name. If version is not supplied, the\n+latest version of the package will be preferred.\n \n Example:\n     export PATH=$PATH:/home/user/.rustpkg/bin"}, {"sha": "f9ac1b59782a931a948afabdd13d9444f12022b2", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 79, "deletions": 53, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=787ddb4b7cc15178f5fb7b93d7b5f8fdbae7a584", "patch": "@@ -18,7 +18,7 @@ use codemap::span;\n use semver::Version;\n use std::{json, term, sort, getopts};\n use getopts::groups::getopts;\n-use api::Listener;\n+use Listener;\n \n pub struct Package {\n     id: ~str,\n@@ -47,9 +47,11 @@ pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n     for parts.each |&part| {\n         for str::chars(part).each |&char| {\n             if char::is_whitespace(char) {\n-                return result::Err(~\"could not parse id: contains whitespace\");\n+                return result::Err(\n+                    ~\"could not parse id: contains whitespace\");\n             } else if char::is_uppercase(char) {\n-                return result::Err(~\"could not parse id: should be all lowercase\");\n+                return result::Err(\n+                    ~\"could not parse id: should be all lowercase\");\n             }\n         }\n     }\n@@ -98,7 +100,7 @@ fn fold_mod(ctx: @ReadyCtx, m: ast::_mod,\n         }\n     }\n \n-    fold::noop_fold_mod({\n+    fold::noop_fold_mod(ast::_mod {\n         view_items: vec::append_one(m.view_items, mk_rustpkg_use(ctx)),\n         items: do vec::map(m.items) |item| {\n             strip_main(*item)\n@@ -116,7 +118,7 @@ fn fold_crate(ctx: @ReadyCtx, crate: ast::crate_,\n     }\n }\n \n-fn fold_item(ctx: @ReadyCtx, &&item: @ast::item,\n+fn fold_item(ctx: @ReadyCtx, item: @ast::item,\n              fold: fold::ast_fold) -> Option<@ast::item> {\n \n     ctx.path.push(item.ident);\n@@ -177,7 +179,7 @@ fn mk_rustpkg_import(ctx: @ReadyCtx) -> @ast::view_item {\n fn add_pkg_module(ctx: @ReadyCtx, m: ast::_mod) -> ast::_mod {\n     let listeners = mk_listeners(ctx);\n     let main = mk_main(ctx);\n-    let pkg_mod = @{\n+    let pkg_mod = @ast::_mod {\n         view_items: ~[mk_rustpkg_import(ctx)],\n         items: ~[main, listeners]\n     };\n@@ -193,7 +195,7 @@ fn add_pkg_module(ctx: @ReadyCtx, m: ast::_mod) -> ast::_mod {\n         span: dummy_sp(),\n     };\n \n-    {\n+    ast::_mod {\n         items: vec::append_one(/*bad*/copy m.items, item),\n         .. m\n     }\n@@ -228,7 +230,7 @@ fn path_node_global(ids: ~[ast::ident]) -> @ast::path {\n \n fn mk_listeners(ctx: @ReadyCtx) -> @ast::item {\n     let ret_ty = mk_listener_vec_ty(ctx);\n-    let decl = {\n+    let decl = ast::fn_decl {\n         inputs: ~[],\n         output: ret_ty,\n         cf: ast::return_val\n@@ -255,7 +257,7 @@ fn mk_path(ctx: @ReadyCtx, path: ~[ast::ident]) -> @ast::path {\n \n fn mk_listener_vec_ty(ctx: @ReadyCtx) -> @ast::Ty {\n     let listener_ty_path = mk_path(ctx, ~[ctx.sess.ident_of(~\"Listener\")]);\n-    let listener_ty = {\n+    let listener_ty = ast::Ty {\n         id: ctx.sess.next_node_id(),\n         node: ast::ty_path(listener_ty_path,\n                            ctx.sess.next_node_id()),\n@@ -265,13 +267,13 @@ fn mk_listener_vec_ty(ctx: @ReadyCtx) -> @ast::Ty {\n         ty: @listener_ty,\n         mutbl: ast::m_imm\n     };\n-    let inner_ty = @{\n+    let inner_ty = @ast::Ty {\n         id: ctx.sess.next_node_id(),\n         node: ast::ty_vec(vec_mt),\n         span: dummy_sp()\n     };\n \n-    @{\n+    @ast::Ty {\n         id: ctx.sess.next_node_id(),\n         node: ast::ty_uniq(ast::mt {\n             ty: inner_ty,\n@@ -287,14 +289,14 @@ fn mk_listener_vec(ctx: @ReadyCtx) -> @ast::expr {\n     let descs = do fns.map |listener| {\n         mk_listener_rec(ctx, *listener)\n     };\n-    let inner_expr = @{\n+    let inner_expr = @ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: ast::expr_vec(descs, ast::m_imm),\n         span: dummy_sp()\n     };\n \n-    @{\n+    @ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: ast::expr_vstore(inner_expr, ast::expr_vstore_uniq),\n@@ -306,27 +308,27 @@ fn mk_listener_rec(ctx: @ReadyCtx, listener: ListenerFn) -> @ast::expr {\n     let span = listener.span;\n     let path = /*bad*/copy listener.path;\n     let descs = do listener.cmds.map |&cmd| {\n-        let inner = @{\n+        let inner = @ast::expr {\n             id: ctx.sess.next_node_id(),\n             callee_id: ctx.sess.next_node_id(),\n             node: ast::expr_lit(@no_span(ast::lit_str(@cmd))),\n             span: span\n         };\n \n-        @{\n+        @ast::expr {\n             id: ctx.sess.next_node_id(),\n             callee_id: ctx.sess.next_node_id(),\n             node: ast::expr_vstore(inner, ast::expr_vstore_uniq),\n             span: dummy_sp()\n         }\n     };\n-    let cmd_expr_inner = @{\n+    let cmd_expr_inner = @ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: ast::expr_vec(descs, ast::m_imm),\n         span: dummy_sp()\n     };\n-    let cmd_expr = {\n+    let cmd_expr = ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: ast::expr_vstore(cmd_expr_inner, ast::expr_vstore_uniq),\n@@ -339,7 +341,7 @@ fn mk_listener_rec(ctx: @ReadyCtx, listener: ListenerFn) -> @ast::expr {\n     });\n \n     let cb_path = path_node_global(path);\n-    let cb_expr = {\n+    let cb_expr = ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: ast::expr_path(cb_path),\n@@ -356,7 +358,7 @@ fn mk_listener_rec(ctx: @ReadyCtx, listener: ListenerFn) -> @ast::expr {\n     let listener_rec_ = ast::expr_struct(listener_path,\n                                          ~[cmd_field, cb_field],\n                                          option::None);\n-    @{\n+    @ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: listener_rec_,\n@@ -366,16 +368,17 @@ fn mk_listener_rec(ctx: @ReadyCtx, listener: ListenerFn) -> @ast::expr {\n \n fn mk_fn_wrapper(ctx: @ReadyCtx, fn_path_expr: ast::expr,\n                  span: span) -> @ast::expr {\n-    let call_expr = {\n+    let call_expr = ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: ast::expr_call(@fn_path_expr, ~[], false),\n         span: span\n     };\n-    let call_stmt = no_span(ast::stmt_semi(@call_expr, ctx.sess.next_node_id()));\n-    let wrapper_decl = {\n+    let call_stmt = no_span(ast::stmt_semi(@call_expr,\n+                                           ctx.sess.next_node_id()));\n+    let wrapper_decl = ast::fn_decl {\n         inputs: ~[],\n-        output: @{\n+        output: @ast::Ty {\n             id: ctx.sess.next_node_id(),\n             node: ast::ty_nil, span: span\n         },\n@@ -389,7 +392,7 @@ fn mk_fn_wrapper(ctx: @ReadyCtx, fn_path_expr: ast::expr,\n         rules: ast::default_blk\n     });\n \n-    @{\n+    @ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: ast::expr_fn(ast::ProtoBare, wrapper_decl,\n@@ -399,12 +402,12 @@ fn mk_fn_wrapper(ctx: @ReadyCtx, fn_path_expr: ast::expr,\n }\n \n fn mk_main(ctx: @ReadyCtx) -> @ast::item {\n-    let ret_ty = {\n+    let ret_ty = ast::Ty {\n         id: ctx.sess.next_node_id(),\n         node: ast::ty_nil,\n         span: dummy_sp()\n     };\n-    let decl = {\n+    let decl = ast::fn_decl {\n         inputs: ~[],\n         output: @ret_ty,\n         cf: ast::return_val\n@@ -431,14 +434,14 @@ fn mk_main(ctx: @ReadyCtx) -> @ast::item {\n fn mk_run_call(ctx: @ReadyCtx) -> @ast::expr {\n     let listener_path = path_node(~[ctx.sess.ident_of(~\"listeners\")]);\n     let listener_path_expr_ = ast::expr_path(listener_path);\n-    let listener_path_expr = {\n+    let listener_path_expr = ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: listener_path_expr_,\n         span: dummy_sp()\n     };\n     let listener_call_expr_ = ast::expr_call(@listener_path_expr, ~[], false);\n-    let listener_call_expr = {\n+    let listener_call_expr = ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: listener_call_expr_,\n@@ -447,7 +450,7 @@ fn mk_run_call(ctx: @ReadyCtx) -> @ast::expr {\n     let rustpkg_run_path = mk_path(ctx, ~[ctx.sess.ident_of(~\"run\")]);\n \n     let rustpkg_run_path_expr_ = ast::expr_path(rustpkg_run_path);\n-    let rustpkg_run_path_expr = {\n+    let rustpkg_run_path_expr = ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: rustpkg_run_path_expr_,\n@@ -456,7 +459,7 @@ fn mk_run_call(ctx: @ReadyCtx) -> @ast::expr {\n     let rustpkg_run_call_expr_ = ast::expr_call(@rustpkg_run_path_expr,\n                                                ~[@listener_call_expr],\n                                                false);\n-    @{\n+    @ast::expr {\n         id: ctx.sess.next_node_id(),\n         callee_id: ctx.sess.next_node_id(),\n         node: rustpkg_run_call_expr_,\n@@ -602,7 +605,7 @@ fn _add_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n \n                 match map.get(&~\"vers\") {\n                     json::String(str) => {\n-                        if pkg.vers.to_str() == str {\n+                        if has_id && pkg.vers.to_str() == str {\n                             return packages;\n                         }\n                     }\n@@ -644,8 +647,8 @@ fn _rm_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n \n                 match map.get(&~\"vers\") {\n                     json::String(str) => {\n-                        if pkg.vers.to_str() == str { None }\n-                        else { Some(package) } \n+                        if has_id && pkg.vers.to_str() == str { None }\n+                        else { Some(package) }\n                     }\n                     _ => { Some(package) }\n                 }\n@@ -673,21 +676,25 @@ pub fn load_pkgs() -> result::Result<~[json::Json], ~str> {\n                             _ => {\n                                 os::remove_file(&db_lock);\n \n-                                return result::Err(~\"package db's json is not a list\");\n+                                return result::Err(\n+                                    ~\"package db's json is not a list\");\n                             }\n                         }\n                     }\n                     result::Err(err) => {\n                         os::remove_file(&db_lock);\n \n-                        return result::Err(fmt!(\"failed to parse package db: %s\", err.to_str()));\n+                        return result::Err(\n+                            fmt!(\"failed to parse package db: %s\",\n+                            err.to_str()));\n                     }\n                 }\n             }\n             result::Err(err) => {\n                 os::remove_file(&db_lock);\n \n-                return result::Err(fmt!(\"failed to read package db: %s\", err));\n+                return result::Err(fmt!(\"failed to read package db: %s\",\n+                                        err));\n             }\n         }\n     } else { ~[] };\n@@ -697,7 +704,8 @@ pub fn load_pkgs() -> result::Result<~[json::Json], ~str> {\n     result::Ok(packages)\n }\n \n-pub fn get_pkg(id: ~str, vers: Option<~str>) -> result::Result<Package, ~str> {\n+pub fn get_pkg(id: ~str,\n+               vers: Option<~str>) -> result::Result<Package, ~str> {\n     let name = match parse_name(id) {\n         result::Ok(name) => name,\n         result::Err(err) => return result::Err(err)\n@@ -812,7 +820,8 @@ pub fn add_pkg(pkg: &Package) -> bool {\n \n     match io::mk_file_writer(&db, ~[io::Create]) {\n         result::Ok(writer) => {\n-            writer.write_line(json::to_pretty_str(&json::List(_add_pkg(packages, pkg))));\n+            writer.write_line(json::to_pretty_str(&json::List(\n+                _add_pkg(packages, pkg))));\n         }\n         result::Err(err) => {\n             error(fmt!(\"failed to dump package db: %s\", err));\n@@ -846,7 +855,8 @@ pub fn remove_pkg(pkg: &Package) -> bool {\n \n     match io::mk_file_writer(&db, ~[io::Create]) {\n         result::Ok(writer) => {\n-            writer.write_line(json::to_pretty_str(&json::List(_rm_pkg(packages, pkg))));\n+            writer.write_line(json::to_pretty_str(&json::List(\n+                _rm_pkg(packages, pkg))));\n         }\n         result::Err(err) => {\n             error(fmt!(\"failed to dump package db: %s\", err));\n@@ -868,14 +878,23 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n     let test_dir = dir.push(~\"test\");\n     let binary = os::args()[0];\n     let matches = getopts(flags, driver::optgroups()).get();\n-    let mut options = driver::build_session_options(binary, matches,\n-                                                    diagnostic::emit);\n+    let options = @{\n+        crate_type: session::unknown_crate,\n+        optimize: if opt { session::Aggressive } else { session::No },\n+        test: test,\n+        maybe_sysroot: sysroot,\n+        .. *driver::build_session_options(binary, &matches, diagnostic::emit)\n+    };\n+    let mut crate_cfg = options.cfg;\n \n-    options.crate_type = session::unknown_crate;\n-    options.optimize = if opt { session::Aggressive } else { session::No };\n-    options.test = test;\n-    options.maybe_sysroot = sysroot;\n+    for cfgs.each |&cfg| {\n+        crate_cfg.push(attr::mk_word_item(cfg));\n+    }\n \n+    let options = @{\n+        cfg: vec::append(options.cfg, crate_cfg),\n+        .. *options\n+    };\n     let sess = driver::build_session(options, diagnostic::emit);\n     let cfg = driver::build_configuration(sess, binary, input);\n     let mut outputs = driver::build_output_filenames(input, &None, &None,\n@@ -979,7 +998,8 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n         let path = bin_dir.push(fmt!(\"%s-%s-%s%s\", name,\n                                                    hash(name + uuid + vers),\n                                                    vers, exe_suffix()));\n-        outputs = driver::build_output_filenames(input, &None, &Some(path), sess);\n+        outputs = driver::build_output_filenames(input, &None, &Some(path),\n+                                                 sess);\n     } else {\n         need_dir(&lib_dir);\n \n@@ -1002,18 +1022,24 @@ pub fn exe_suffix() -> ~str { ~\".exe\" }\n #[cfg(target_os = \"macos\")]\n pub fn exe_suffix() -> ~str { ~\"\" }\n \n-pub fn compile_crate(sysroot: Option<Path>, crate: &Path, dir: &Path, flags: ~[~str],\n-               cfgs: ~[~str], opt: bool, test: bool) -> bool {\n-    compile_input(sysroot, driver::file_input(*crate), dir, flags, cfgs, opt, test)\n+\n+// FIXME: Use workcache to only compile when needed\n+pub fn compile_crate(sysroot: Option<Path>, crate: &Path, dir: &Path,\n+                     flags: ~[~str], cfgs: ~[~str], opt: bool,\n+                     test: bool) -> bool {\n+    compile_input(sysroot, driver::file_input(*crate), dir, flags, cfgs,\n+                  opt, test)\n }\n \n-pub fn compile_str(sysroot: Option<Path>, code: ~str, dir: &Path, flags: ~[~str],\n-                   cfgs: ~[~str], opt: bool, test: bool) -> bool {\n-    compile_input(sysroot, driver::str_input(code), dir, flags, cfgs, opt, test)\n+pub fn compile_str(sysroot: Option<Path>, code: ~str, dir: &Path,\n+                   flags: ~[~str], cfgs: ~[~str], opt: bool,\n+                   test: bool) -> bool {\n+    compile_input(sysroot, driver::str_input(code), dir, flags, cfgs,\n+                  opt, test)\n }\n \n #[cfg(windows)]\n-pub fn link_exe(_src: &Path, _dest: &Path) -> bool{\n+pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n     /* FIXME: Investigate how to do this on win32\n        Node wraps symlinks by having a .bat,\n        but that won't work with minGW. */"}]}