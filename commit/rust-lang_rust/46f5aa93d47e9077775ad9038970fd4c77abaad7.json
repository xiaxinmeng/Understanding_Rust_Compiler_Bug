{"sha": "46f5aa93d47e9077775ad9038970fd4c77abaad7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZjVhYTkzZDQ3ZTkwNzc3NzVhZDkwMzg5NzBmZDRjNzdhYmFhZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-26T01:48:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-26T01:48:27Z"}, "message": "Auto merge of #69474 - Dylan-DPC:rollup-ciotplu, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #67637 (Add primitive module to libcore)\n - #69387 (Deduplicate identifier printing a bit)\n - #69412 (Mark attributes consumed by `check_mod_attrs` as normal)\n - #69423 (syntax: Remove `Nt(Impl,Trait,Foreign)Item`)\n - #69429 (remove redundant clones and import)\n - #69457 (Clean up e0370 e0371)\n - #69468 ([master] Backport release notes of 1.41.1)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d60d68e8f7c959e8b453a7a0357b9b4d70473379", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d60d68e8f7c959e8b453a7a0357b9b4d70473379"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46f5aa93d47e9077775ad9038970fd4c77abaad7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46f5aa93d47e9077775ad9038970fd4c77abaad7", "html_url": "https://github.com/rust-lang/rust/commit/46f5aa93d47e9077775ad9038970fd4c77abaad7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46f5aa93d47e9077775ad9038970fd4c77abaad7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55a777cd92d50e7ba5e8b7c52246f630bcac35b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/55a777cd92d50e7ba5e8b7c52246f630bcac35b4", "html_url": "https://github.com/rust-lang/rust/commit/55a777cd92d50e7ba5e8b7c52246f630bcac35b4"}, {"sha": "83818628b24aac7ddd165882bc6dbae5236e4c0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/83818628b24aac7ddd165882bc6dbae5236e4c0e", "html_url": "https://github.com/rust-lang/rust/commit/83818628b24aac7ddd165882bc6dbae5236e4c0e"}], "stats": {"total": 419, "additions": 300, "deletions": 119}, "files": [{"sha": "427aa71b4b5dc0cbd324cd6441845300ef187a65", "filename": "RELEASES.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -1,3 +1,13 @@\n+Version 1.41.1 (2020-02-27)\n+===========================\n+\n+* [Always check types of static items][69145]\n+* [Always check lifetime bounds of `Copy` impls][69145]\n+* [Fix miscompilation in callers of `Layout::repeat`][69225]\n+\n+[69225]: https://github.com/rust-lang/rust/issues/69225\n+[69145]: https://github.com/rust-lang/rust/pull/69145\n+\n Version 1.41.0 (2020-01-30)\n ===========================\n "}, {"sha": "7bd1d00e84ca1e184339949ecbdea7c120e31b44", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -267,6 +267,9 @@ mod bool;\n mod tuple;\n mod unit;\n \n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub mod primitive;\n+\n // Pull in the `core_arch` crate directly into libcore. The contents of\n // `core_arch` are in a different repository: rust-lang/stdarch.\n //"}, {"sha": "e20b2c5c9382a116b35385d680195eef3b4e17d0", "filename": "src/libcore/primitive.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibcore%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibcore%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprimitive.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -0,0 +1,67 @@\n+//! This module reexports the primitive types to allow usage that is not\n+//! possibly shadowed by other declared types.\n+//!\n+//! This is normally only useful in macro generated code.\n+//!\n+//! An example of this is when generating a new struct and an impl for it:\n+//!\n+//! ```rust,compile_fail\n+//! pub struct bool;\n+//!\n+//! impl QueryId for bool {\n+//!     const SOME_PROPERTY: bool = true;\n+//! }\n+//!\n+//! # trait QueryId { const SOME_PROPERTY: core::primitive::bool; }\n+//! ```\n+//!\n+//! Note that the `SOME_PROPERTY` associated constant would not compile, as its\n+//! type `bool` refers to the struct, rather than to the primitive bool type.\n+//!\n+//! A correct implementation could look like:\n+//!\n+//! ```rust\n+//! # #[allow(non_camel_case_types)]\n+//! pub struct bool;\n+//!\n+//! impl QueryId for bool {\n+//!     const SOME_PROPERTY: core::primitive::bool = true;\n+//! }\n+//!\n+//! # trait QueryId { const SOME_PROPERTY: core::primitive::bool; }\n+//! ```\n+\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use bool;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use char;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use f32;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use f64;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use i128;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use i16;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use i32;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use i64;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use i8;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use isize;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use str;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use u128;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use u16;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use u32;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use u64;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use u8;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use usize;"}, {"sha": "c027d6f61b01f2d32e5520773a04331189b27e39", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -1526,7 +1526,7 @@ impl<'tcx> GlobalCtxt<'tcx> {\n         ty::tls::with_related_context(tcx, |icx| {\n             let new_icx = ty::tls::ImplicitCtxt {\n                 tcx,\n-                query: icx.query.clone(),\n+                query: icx.query,\n                 diagnostics: icx.diagnostics,\n                 layout_depth: icx.layout_depth,\n                 task_deps: icx.task_deps,"}, {"sha": "d17ef3a6c9a8cce5ff7238ee985ac5c5c808e5a1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -1447,7 +1447,7 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&TraitRef<'tcx>> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n         ty::Predicate::Trait(\n-            ty::Binder::dummy(ty::TraitPredicate { trait_ref: self.value.clone() }),\n+            ty::Binder::dummy(ty::TraitPredicate { trait_ref: *self.value }),\n             self.constness,\n         )\n     }"}, {"sha": "3394fed8402224ff98f0d7929c67065d93aedd25", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -173,7 +173,7 @@ impl<'tcx> QueryLatch<'tcx> {\n                 return CycleError { usage, cycle };\n             }\n \n-            current_job = info.job.parent.clone();\n+            current_job = info.job.parent;\n         }\n \n         panic!(\"did not find a cycle\")"}, {"sha": "3431c1b8e9d4201eacc0e9bcf7df27cfe2f03bb5", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 4, "deletions": 49, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -3,7 +3,7 @@ use crate::pp::{self, Breaks};\n \n use rustc_span::edition::Edition;\n use rustc_span::source_map::{SourceMap, Spanned};\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, IdentPrinter};\n use rustc_span::{BytePos, FileName, Span};\n use syntax::ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use syntax::ast::{Attribute, GenericArg, MacArgs};\n@@ -196,40 +196,6 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n     out\n }\n \n-/// Print an ident from AST, `$crate` is converted into its respective crate name.\n-pub fn ast_ident_to_string(ident: ast::Ident, is_raw: bool) -> String {\n-    ident_to_string(ident.name, is_raw, Some(ident.span))\n-}\n-\n-// AST pretty-printer is used as a fallback for turning AST structures into token streams for\n-// proc macros. Additionally, proc macros may stringify their input and expect it survive the\n-// stringification (especially true for proc macro derives written between Rust 1.15 and 1.30).\n-// So we need to somehow pretty-print `$crate` in a way preserving at least some of its\n-// hygiene data, most importantly name of the crate it refers to.\n-// As a result we print `$crate` as `crate` if it refers to the local crate\n-// and as `::other_crate_name` if it refers to some other crate.\n-// Note, that this is only done if the ident token is printed from inside of AST pretty-pringing,\n-// but not otherwise. Pretty-printing is the only way for proc macros to discover token contents,\n-// so we should not perform this lossy conversion if the top level call to the pretty-printer was\n-// done for a token stream or a single token.\n-fn ident_to_string(name: ast::Name, is_raw: bool, convert_dollar_crate: Option<Span>) -> String {\n-    if is_raw {\n-        format!(\"r#{}\", name)\n-    } else {\n-        if name == kw::DollarCrate {\n-            if let Some(span) = convert_dollar_crate {\n-                let converted = span.ctxt().dollar_crate_name();\n-                return if converted.is_path_segment_keyword() {\n-                    converted.to_string()\n-                } else {\n-                    format!(\"::{}\", converted)\n-                };\n-            }\n-        }\n-        name.to_string()\n-    }\n-}\n-\n /// Print the token kind precisely, without converting `$crate` into its respective crate name.\n pub fn token_kind_to_string(tok: &TokenKind) -> String {\n     token_kind_to_string_ext(tok, None)\n@@ -280,7 +246,7 @@ fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>)\n         token::Literal(lit) => literal_to_string(lit),\n \n         /* Name components */\n-        token::Ident(s, is_raw) => ident_to_string(s, is_raw, convert_dollar_crate),\n+        token::Ident(s, is_raw) => IdentPrinter::new(s, is_raw, convert_dollar_crate).to_string(),\n         token::Lifetime(s) => s.to_string(),\n \n         /* Other */\n@@ -315,14 +281,11 @@ pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n         token::NtBlock(ref e) => block_to_string(e),\n         token::NtStmt(ref e) => stmt_to_string(e),\n         token::NtPat(ref e) => pat_to_string(e),\n-        token::NtIdent(e, is_raw) => ast_ident_to_string(e, is_raw),\n+        token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n         token::NtLifetime(e) => e.to_string(),\n         token::NtLiteral(ref e) => expr_to_string(e),\n         token::NtTT(ref tree) => tt_to_string(tree.clone()),\n-        // FIXME(Centril): merge these variants.\n-        token::NtImplItem(ref e) | token::NtTraitItem(ref e) => assoc_item_to_string(e),\n         token::NtVis(ref e) => vis_to_string(e),\n-        token::NtForeignItem(ref e) => foreign_item_to_string(e),\n     }\n }\n \n@@ -358,10 +321,6 @@ pub fn item_to_string(i: &ast::Item) -> String {\n     to_string(|s| s.print_item(i))\n }\n \n-fn assoc_item_to_string(i: &ast::AssocItem) -> String {\n-    to_string(|s| s.print_assoc_item(i))\n-}\n-\n pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n     to_string(|s| s.print_generic_params(generic_params))\n }\n@@ -404,10 +363,6 @@ pub fn param_to_string(arg: &ast::Param) -> String {\n     to_string(|s| s.print_param(arg, false))\n }\n \n-fn foreign_item_to_string(arg: &ast::ForeignItem) -> String {\n-    to_string(|s| s.print_foreign_item(arg))\n-}\n-\n fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n     format!(\"{}{}\", to_string(|s| s.print_visibility(vis)), s)\n }\n@@ -819,7 +774,7 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n \n     fn print_ident(&mut self, ident: ast::Ident) {\n-        self.s.word(ast_ident_to_string(ident, ident.is_raw_guess()));\n+        self.s.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n         self.ann.post(self, AnnNode::Ident(&ident))\n     }\n "}, {"sha": "4248627dccaf23533f896c68a3d96bf55354e03d", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => {\n                 let val = self.eval_mir_constant(constant)?;\n                 let ty = self.monomorphize(&constant.literal.ty);\n-                Ok(OperandRef::from_const(bx, val.clone(), ty))\n+                Ok(OperandRef::from_const(bx, val, ty))\n             }\n         }\n     }"}, {"sha": "6711a49b2b7c1df00a8f6b74c4ebe595d8f8c71a", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -314,7 +314,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             return Ok(());\n         }\n \n-        match self.active_cache.entry(obligation.as_cache_key().clone()) {\n+        match self.active_cache.entry(obligation.as_cache_key()) {\n             Entry::Occupied(o) => {\n                 let node = &mut self.nodes[*o.get()];\n                 if let Some(parent_index) = parent {\n@@ -385,7 +385,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.error_cache\n             .entry(node.obligation_tree_id)\n             .or_default()\n-            .insert(node.obligation.as_cache_key().clone());\n+            .insert(node.obligation.as_cache_key());\n     }\n \n     /// Performs a pass through the obligation list. This must"}, {"sha": "14e954722a2501c34ef182a978eb35f78b8346e8", "filename": "src/librustc_error_codes/error_codes/E0370.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -1,5 +1,7 @@\n The maximum value of an enum was reached, so it cannot be automatically\n-set in the next enum value. Erroneous code example:\n+set in the next enum value.\n+\n+Erroneous code example:\n \n ```compile_fail,E0370\n #[repr(i64)]"}, {"sha": "a44721346e20dc8377bd7a2d612c4e46b3617779", "filename": "src/librustc_error_codes/error_codes/E0371.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -1,9 +1,6 @@\n-When `Trait2` is a subtrait of `Trait1` (for example, when `Trait2` has a\n-definition like `trait Trait2: Trait1 { ... }`), it is not allowed to implement\n-`Trait1` for `Trait2`. This is because `Trait2` already implements `Trait1` by\n-definition, so it is not useful to do this.\n+A trait was implemented on another which already automatically implemented it.\n \n-Example:\n+Erroneous code examples:\n \n ```compile_fail,E0371\n trait Foo { fn foo(&self) { } }\n@@ -15,3 +12,8 @@ impl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`\n impl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`\n impl Baz for Bar { } // Note: This is OK\n ```\n+\n+When `Trait2` is a subtrait of `Trait1` (for example, when `Trait2` has a\n+definition like `trait Trait2: Trait1 { ... }`), it is not allowed to implement\n+`Trait1` for `Trait2`. This is because `Trait2` already implements `Trait1` by\n+definition, so it is not useful to do this."}, {"sha": "8ed7bbf6e1276eb78dc26df6453c4935cbf075e8", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -669,12 +669,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n+                    // `Annotatable` can be converted into tokens directly, but we are packing it\n+                    // into a nonterminal as a piece of AST to make the produced token stream\n+                    // look nicer in pretty-printed form. This may be no longer necessary.\n                     let item_tok = TokenTree::token(\n                         token::Interpolated(Lrc::new(match item {\n                             Annotatable::Item(item) => token::NtItem(item),\n-                            Annotatable::TraitItem(item) => token::NtTraitItem(item),\n-                            Annotatable::ImplItem(item) => token::NtImplItem(item),\n-                            Annotatable::ForeignItem(item) => token::NtForeignItem(item),\n+                            Annotatable::TraitItem(item)\n+                            | Annotatable::ImplItem(item)\n+                            | Annotatable::ForeignItem(item) => {\n+                                token::NtItem(P(item.and_then(ast::AssocItem::into_item)))\n+                            }\n                             Annotatable::Stmt(stmt) => token::NtStmt(stmt.into_inner()),\n                             Annotatable::Expr(expr) => token::NtExpr(expr),\n                             Annotatable::Arm(..)"}, {"sha": "91658db1a7a3d5b49a4804dc0b8c3b1e8a185460", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -234,7 +234,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(export_name, Whitelisted, template!(NameValueStr: \"name\")),\n     ungated!(link_section, Whitelisted, template!(NameValueStr: \"name\")),\n     ungated!(no_mangle, Whitelisted, template!(Word)),\n-    ungated!(used, Whitelisted, template!(Word)),\n+    ungated!(used, Normal, template!(Word)),\n \n     // Limits:\n     ungated!(recursion_limit, CrateLevel, template!(NameValueStr: \"N\")),\n@@ -250,17 +250,17 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(path, Normal, template!(NameValueStr: \"file\")),\n     ungated!(no_std, CrateLevel, template!(Word)),\n     ungated!(no_implicit_prelude, Normal, template!(Word)),\n-    ungated!(non_exhaustive, Whitelisted, template!(Word)),\n+    ungated!(non_exhaustive, Normal, template!(Word)),\n \n     // Runtime\n     ungated!(windows_subsystem, Whitelisted, template!(NameValueStr: \"windows|console\")),\n     ungated!(panic_handler, Normal, template!(Word)), // RFC 2070\n \n     // Code generation:\n-    ungated!(inline, Whitelisted, template!(Word, List: \"always|never\")),\n+    ungated!(inline, Normal, template!(Word, List: \"always|never\")),\n     ungated!(cold, Whitelisted, template!(Word)),\n     ungated!(no_builtins, Whitelisted, template!(Word)),\n-    ungated!(target_feature, Whitelisted, template!(List: r#\"enable = \"name\"\"#)),\n+    ungated!(target_feature, Normal, template!(List: r#\"enable = \"name\"\"#)),\n     gated!(\n         no_sanitize, Whitelisted,\n         template!(List: \"address, memory, thread\"),\n@@ -275,7 +275,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     // Linking:\n-    gated!(naked, Whitelisted, template!(Word), naked_functions, experimental!(naked)),\n+    gated!(naked, Normal, template!(Word), naked_functions, experimental!(naked)),\n     gated!(\n         link_args, Normal, template!(NameValueStr: \"args\"),\n         \"the `link_args` attribute is experimental and not portable across platforms, \\\n@@ -332,7 +332,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n \n     gated!(ffi_returns_twice, Whitelisted, template!(Word), experimental!(ffi_returns_twice)),\n-    gated!(track_caller, Whitelisted, template!(Word), experimental!(track_caller)),\n+    gated!(track_caller, Normal, template!(Word), experimental!(track_caller)),\n     gated!(\n         register_attr, CrateLevel, template!(List: \"attr1, attr2, ...\"),\n         experimental!(register_attr),"}, {"sha": "3fde04c294ef25a681699372d689c43340b43dcc", "filename": "src/librustc_hir/print.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_hir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_hir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fprint.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -1,8 +1,8 @@\n use rustc_ast_pretty::pp::Breaks::{Consistent, Inconsistent};\n use rustc_ast_pretty::pp::{self, Breaks};\n-use rustc_ast_pretty::pprust::{self, Comments, PrintState};\n+use rustc_ast_pretty::pprust::{Comments, PrintState};\n use rustc_span::source_map::{SourceMap, Spanned};\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, IdentPrinter};\n use rustc_span::{self, BytePos, FileName};\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n@@ -126,7 +126,7 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n \n     fn print_ident(&mut self, ident: ast::Ident) {\n-        self.s.word(pprust::ast_ident_to_string(ident, ident.is_raw_guess()));\n+        self.s.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n         self.ann.post(self, AnnNode::Name(&ident.name))\n     }\n "}, {"sha": "fc9f3bb076745a6f076a8783d11e7aa0b7682cf6", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -848,7 +848,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         for upper_bound in &upper_bounds {\n             if let ty::RePlaceholder(p) = upper_bound.region {\n                 if node_universe.cannot_name(p.universe) {\n-                    let origin = self.var_infos[node_idx].origin.clone();\n+                    let origin = self.var_infos[node_idx].origin;\n                     errors.push(RegionResolutionError::UpperBoundUniverseConflict(\n                         node_idx,\n                         origin,"}, {"sha": "dc6ae961e5a6e69e39f28b89ffda65360fd1bdd7", "filename": "src/librustc_macros/src/hash_stable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -1,7 +1,6 @@\n use proc_macro2::{self, Ident};\n use quote::quote;\n use syn::{self, parse_quote, Meta, NestedMeta};\n-use synstructure;\n \n struct Attributes {\n     ignore: bool,"}, {"sha": "4583e244f493d7c904a7aa04aba91fcdac388d9c", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -376,7 +376,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     TerminatorKind::Yield {\n                         value,\n                         resume,\n-                        resume_arg: destination.clone(),\n+                        resume_arg: *destination,\n                         drop: cleanup,\n                     },\n                 );"}, {"sha": "79951255243141cb6c19505538993f9220928ef1", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -649,7 +649,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n             PatKind::Or { ref pats } => {\n-                self.visit_bindings(&pats[0], pattern_user_ty.clone(), f);\n+                self.visit_bindings(&pats[0], pattern_user_ty, f);\n             }\n         }\n     }"}, {"sha": "bd0b189d4fd4d41e7347acb8c0641a445ee3bdc8", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -314,9 +314,6 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n         Nonterminal::NtItem(ref item) => {\n             prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n         }\n-        Nonterminal::NtTraitItem(ref item) | Nonterminal::NtImplItem(ref item) => {\n-            prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n-        }\n         Nonterminal::NtIdent(ident, is_raw) => {\n             Some(tokenstream::TokenTree::token(token::Ident(ident.name, is_raw), ident.span).into())\n         }"}, {"sha": "d7d6fcd05b795eca326f1d9649b2614abd2ced2e", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -632,16 +632,10 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_impl_item(&mut self) -> PResult<'a, Option<Option<P<AssocItem>>>> {\n-        maybe_whole!(self, NtImplItem, |x| Some(Some(x)));\n         self.parse_assoc_item(|_| true)\n     }\n \n     pub fn parse_trait_item(&mut self) -> PResult<'a, Option<Option<P<AssocItem>>>> {\n-        maybe_whole!(self, NtTraitItem, |x| Some(Some(x)));\n-        // This is somewhat dubious; We don't want to allow\n-        // param names to be left off if there is a definition...\n-        //\n-        // We don't allow param names to be left off in edition 2018.\n         self.parse_assoc_item(|t| t.span.rust_2018())\n     }\n \n@@ -834,8 +828,6 @@ impl<'a> Parser<'a> {\n \n     /// Parses a foreign item (one in an `extern { ... }` block).\n     pub fn parse_foreign_item(&mut self) -> PResult<'a, Option<Option<P<ForeignItem>>>> {\n-        maybe_whole!(self, NtForeignItem, |item| Some(Some(item)));\n-\n         Ok(self.parse_item_(|_| true)?.map(|Item { attrs, id, span, vis, ident, kind, tokens }| {\n             let kind = match kind {\n                 ItemKind::Mac(a) => ForeignItemKind::Macro(a),"}, {"sha": "b8e5ea97f4e4792f1d6ae642dc8b9d0e56dfb986", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -893,19 +893,17 @@ impl Hash for Ident {\n \n impl fmt::Debug for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.is_raw_guess() {\n-            write!(f, \"r#\")?;\n-        }\n-        write!(f, \"{}{:?}\", self.name, self.span.ctxt())\n+        fmt::Display::fmt(self, f)?;\n+        fmt::Debug::fmt(&self.span.ctxt(), f)\n     }\n }\n \n+/// This implementation is supposed to be used in error messages, so it's expected to be identical\n+/// to printing the original identifier token written in source code (`token_to_string`),\n+/// except that AST identifiers don't keep the rawness flag, so we have to guess it.\n impl fmt::Display for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.is_raw_guess() {\n-            write!(f, \"r#\")?;\n-        }\n-        fmt::Display::fmt(&self.name, f)\n+        fmt::Display::fmt(&IdentPrinter::new(self.name, self.is_raw_guess(), None), f)\n     }\n }\n \n@@ -929,6 +927,59 @@ impl UseSpecializedDecodable for Ident {\n     }\n }\n \n+/// This is the most general way to print identifiers.\n+/// AST pretty-printer is used as a fallback for turning AST structures into token streams for\n+/// proc macros. Additionally, proc macros may stringify their input and expect it survive the\n+/// stringification (especially true for proc macro derives written between Rust 1.15 and 1.30).\n+/// So we need to somehow pretty-print `$crate` in a way preserving at least some of its\n+/// hygiene data, most importantly name of the crate it refers to.\n+/// As a result we print `$crate` as `crate` if it refers to the local crate\n+/// and as `::other_crate_name` if it refers to some other crate.\n+/// Note, that this is only done if the ident token is printed from inside of AST pretty-pringing,\n+/// but not otherwise. Pretty-printing is the only way for proc macros to discover token contents,\n+/// so we should not perform this lossy conversion if the top level call to the pretty-printer was\n+/// done for a token stream or a single token.\n+pub struct IdentPrinter {\n+    symbol: Symbol,\n+    is_raw: bool,\n+    /// Span used for retrieving the crate name to which `$crate` refers to,\n+    /// if this field is `None` then the `$crate` conversion doesn't happen.\n+    convert_dollar_crate: Option<Span>,\n+}\n+\n+impl IdentPrinter {\n+    /// The most general `IdentPrinter` constructor. Do not use this.\n+    pub fn new(symbol: Symbol, is_raw: bool, convert_dollar_crate: Option<Span>) -> IdentPrinter {\n+        IdentPrinter { symbol, is_raw, convert_dollar_crate }\n+    }\n+\n+    /// This implementation is supposed to be used when printing identifiers\n+    /// as a part of pretty-printing for larger AST pieces.\n+    /// Do not use this either.\n+    pub fn for_ast_ident(ident: Ident, is_raw: bool) -> IdentPrinter {\n+        IdentPrinter::new(ident.name, is_raw, Some(ident.span))\n+    }\n+}\n+\n+impl fmt::Display for IdentPrinter {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.is_raw {\n+            f.write_str(\"r#\")?;\n+        } else {\n+            if self.symbol == kw::DollarCrate {\n+                if let Some(span) = self.convert_dollar_crate {\n+                    let converted = span.ctxt().dollar_crate_name();\n+                    if !converted.is_path_segment_keyword() {\n+                        f.write_str(\"::\")?;\n+                    }\n+                    return fmt::Display::fmt(&converted, f);\n+                }\n+            }\n+        }\n+        fmt::Display::fmt(&self.symbol, f)\n+    }\n+}\n+\n /// An interned string.\n ///\n /// Internally, a `Symbol` is implemented as an index, and all operations"}, {"sha": "7b3c702b929c0b9a3cfa0e355220545b6fc1b103", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -233,12 +233,12 @@\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n-#![feature(atomic_mut_ptr)]\n #![feature(arbitrary_self_types)]\n #![feature(array_error_internals)]\n #![feature(asm)]\n #![feature(assoc_int_consts)]\n #![feature(associated_type_bounds)]\n+#![feature(atomic_mut_ptr)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n #![feature(cfg_target_has_atomic)]\n@@ -551,6 +551,9 @@ pub use core::{\n     trace_macros,\n };\n \n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use core::primitive;\n+\n // Include a number of private modules that exist solely to provide\n // the rustdoc documentation for primitive types. Using `include!`\n // because rustdoc only looks for these modules at the crate level."}, {"sha": "62ff4f5183a70a8ebf12c7328a3077b97d5064a4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -2441,6 +2441,13 @@ impl Item {\n     }\n }\n \n+impl<K: IntoItemKind> Item<K> {\n+    pub fn into_item(self) -> Item {\n+        let Item { attrs, id, span, vis, ident, kind, tokens } = self;\n+        Item { attrs, id, span, vis, ident, kind: kind.into_item_kind(), tokens }\n+    }\n+}\n+\n /// `extern` qualifier on a function item or function type.\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n pub enum Extern {\n@@ -2617,6 +2624,10 @@ impl ItemKind {\n     }\n }\n \n+pub trait IntoItemKind {\n+    fn into_item_kind(self) -> ItemKind;\n+}\n+\n // FIXME(Centril): These definitions should be unmerged;\n // see https://github.com/rust-lang/rust/pull/69194#discussion_r379899975\n pub type ForeignItem = Item<AssocItemKind>;\n@@ -2656,3 +2667,15 @@ impl AssocItemKind {\n         }\n     }\n }\n+\n+impl IntoItemKind for AssocItemKind {\n+    fn into_item_kind(self) -> ItemKind {\n+        match self {\n+            AssocItemKind::Const(a, b, c) => ItemKind::Const(a, b, c),\n+            AssocItemKind::Static(a, b, c) => ItemKind::Static(a, b, c),\n+            AssocItemKind::Fn(a, b, c, d) => ItemKind::Fn(a, b, c, d),\n+            AssocItemKind::TyAlias(a, b, c, d) => ItemKind::TyAlias(a, b, c, d),\n+            AssocItemKind::Macro(a) => ItemKind::Mac(a),\n+        }\n+    }\n+}"}, {"sha": "b3abd4fc755e46b721b1a4d376650008b6079f89", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -711,20 +711,7 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n         }\n         token::NtPath(path) => vis.visit_path(path),\n         token::NtTT(tt) => vis.visit_tt(tt),\n-        token::NtImplItem(item) => visit_clobber(item, |item| {\n-            // See reasoning above.\n-            vis.flat_map_impl_item(item).expect_one(\"expected visitor to produce exactly one item\")\n-        }),\n-        token::NtTraitItem(item) => visit_clobber(item, |item| {\n-            // See reasoning above.\n-            vis.flat_map_trait_item(item).expect_one(\"expected visitor to produce exactly one item\")\n-        }),\n         token::NtVis(visib) => vis.visit_vis(visib),\n-        token::NtForeignItem(item) => visit_clobber(item, |item| {\n-            // See reasoning above.\n-            vis.flat_map_foreign_item(item)\n-                .expect_one(\"expected visitor to produce exactly one item\")\n-        }),\n     }\n }\n "}, {"sha": "52bf50604fb307e3bc8083997b08635a6bf36c58", "filename": "src/libsyntax/token.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibsyntax%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Flibsyntax%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftoken.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -712,12 +712,6 @@ pub enum Nonterminal {\n     NtPath(ast::Path),\n     NtVis(ast::Visibility),\n     NtTT(TokenTree),\n-    // Used only for passing items to proc macro attributes (they are not\n-    // strictly necessary for that, `Annotatable` can be converted into\n-    // tokens directly, but doing that naively regresses pretty-printing).\n-    NtTraitItem(P<ast::AssocItem>),\n-    NtImplItem(P<ast::AssocItem>),\n-    NtForeignItem(P<ast::ForeignItem>),\n }\n \n // `Nonterminal` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -755,9 +749,6 @@ impl fmt::Debug for Nonterminal {\n             NtMeta(..) => f.pad(\"NtMeta(..)\"),\n             NtPath(..) => f.pad(\"NtPath(..)\"),\n             NtTT(..) => f.pad(\"NtTT(..)\"),\n-            NtImplItem(..) => f.pad(\"NtImplItem(..)\"),\n-            NtTraitItem(..) => f.pad(\"NtTraitItem(..)\"),\n-            NtForeignItem(..) => f.pad(\"NtForeignItem(..)\"),\n             NtVis(..) => f.pad(\"NtVis(..)\"),\n             NtLifetime(..) => f.pad(\"NtLifetime(..)\"),\n         }"}, {"sha": "3a448d4b2201d892920e1658382268d5c900d188", "filename": "src/test/ui/proc-macro/trait-fn-args-2015.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Ftest%2Fui%2Fproc-macro%2Ftrait-fn-args-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Ftest%2Fui%2Fproc-macro%2Ftrait-fn-args-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Ftrait-fn-args-2015.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -0,0 +1,14 @@\n+// Unnamed arguments in trait functions can be passed through proc macros on 2015 edition.\n+\n+// check-pass\n+// aux-build:test-macros.rs\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+trait Tr {\n+    #[identity_attr]\n+    fn method(u8);\n+}\n+\n+fn main() {}"}, {"sha": "9d381a8a94e3f488ee7c8ff9147171cb0c930a2b", "filename": "src/test/ui/resolve/resolve-primitive-fallback.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Ftest%2Fui%2Fresolve%2Fresolve-primitive-fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Ftest%2Fui%2Fresolve%2Fresolve-primitive-fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-primitive-fallback.stderr?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -9,6 +9,11 @@ error[E0412]: cannot find type `u8` in the crate root\n    |\n LL |     let _: ::u8;\n    |              ^^ not found in the crate root\n+   |\n+help: possible candidate is found in another module, you can import it into scope\n+   |\n+LL | use std::primitive::u8;\n+   |\n \n error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/resolve-primitive-fallback.rs:3:5"}, {"sha": "f290a329eaac298575d6981faa0ae3adbf694dcf", "filename": "src/test/ui/shadow-bool.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Ftest%2Fui%2Fshadow-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Ftest%2Fui%2Fshadow-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshadow-bool.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+mod bar {\n+    pub trait QueryId {\n+        const SOME_PROPERTY: bool;\n+    }\n+}\n+\n+use bar::QueryId;\n+\n+#[allow(non_camel_case_types)]\n+pub struct bool;\n+\n+impl QueryId for bool {\n+    const SOME_PROPERTY: core::primitive::bool = true;\n+}\n+\n+fn main() {}"}, {"sha": "adb939e9b400ed833ed712e0fd4cf12886183871", "filename": "src/test/ui/unused/unused-attr-crate.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Ftest%2Fui%2Funused%2Funused-attr-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Ftest%2Fui%2Funused%2Funused-attr-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funused%2Funused-attr-crate.rs?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -0,0 +1,13 @@\n+#![deny(unused_attributes)]\n+\n+#![feature(naked_functions)]\n+#![feature(track_caller)]\n+\n+#![used] //~ ERROR unused attribute\n+#![non_exhaustive] //~ ERROR unused attribute\n+#![inline] //~ ERROR unused attribute\n+#![target_feature(enable = \"\")] //~ ERROR unused attribute\n+#![naked] //~ ERROR unused attribute\n+#![track_caller] //~ ERROR unused attribute\n+\n+fn main() {}"}, {"sha": "620a3ea5315cb578e60c4d45929465082d4616ff", "filename": "src/test/ui/unused/unused-attr-crate.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Ftest%2Fui%2Funused%2Funused-attr-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46f5aa93d47e9077775ad9038970fd4c77abaad7/src%2Ftest%2Fui%2Funused%2Funused-attr-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funused%2Funused-attr-crate.stderr?ref=46f5aa93d47e9077775ad9038970fd4c77abaad7", "patch": "@@ -0,0 +1,44 @@\n+error: unused attribute\n+  --> $DIR/unused-attr-crate.rs:6:1\n+   |\n+LL | #![used]\n+   | ^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused-attr-crate.rs:1:9\n+   |\n+LL | #![deny(unused_attributes)]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: unused attribute\n+  --> $DIR/unused-attr-crate.rs:7:1\n+   |\n+LL | #![non_exhaustive]\n+   | ^^^^^^^^^^^^^^^^^^\n+\n+error: unused attribute\n+  --> $DIR/unused-attr-crate.rs:8:1\n+   |\n+LL | #![inline]\n+   | ^^^^^^^^^^\n+\n+error: unused attribute\n+  --> $DIR/unused-attr-crate.rs:9:1\n+   |\n+LL | #![target_feature(enable = \"\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unused attribute\n+  --> $DIR/unused-attr-crate.rs:10:1\n+   |\n+LL | #![naked]\n+   | ^^^^^^^^^\n+\n+error: unused attribute\n+  --> $DIR/unused-attr-crate.rs:11:1\n+   |\n+LL | #![track_caller]\n+   | ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}]}