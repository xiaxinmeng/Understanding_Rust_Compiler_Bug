{"sha": "84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d", "node_id": "C_kwDOAAsO6NoAKDg0YTRhYjdmM2YyMWFlNzhjZDFjMjc0YzQ2NDdmZDM4ZWVmN2Q0M2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-04T12:27:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-04T12:27:50Z"}, "message": "Auto merge of #7928 - xFrednet:rust-90354-deploy-clippy-docs, r=flip1995\n\nReference `clippy_utils` docs on nightly-rustc and some other documentation updates\n\nThe `clippy_utils` crate is now part of the nightly-rustc documentation. See [**very beautiful documentation**](https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/). This PR references them in our documentation and updates some other documentation.\n\nchangelog: none", "tree": {"sha": "7272e81731f7442efb1ed25d48c9113a7cc1b6d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7272e81731f7442efb1ed25d48c9113a7cc1b6d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d", "html_url": "https://github.com/rust-lang/rust/commit/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e18101137866b79045fee0ef996e696e68c920b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e18101137866b79045fee0ef996e696e68c920b4", "html_url": "https://github.com/rust-lang/rust/commit/e18101137866b79045fee0ef996e696e68c920b4"}, {"sha": "540515220d849de13f75df868d0b653e2002e59a", "url": "https://api.github.com/repos/rust-lang/rust/commits/540515220d849de13f75df868d0b653e2002e59a", "html_url": "https://github.com/rust-lang/rust/commit/540515220d849de13f75df868d0b653e2002e59a"}], "stats": {"total": 94, "additions": 80, "deletions": 14}, "files": [{"sha": "7f68cc388eb01f08a8db85220c720c84e612eeaa", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d", "patch": "@@ -155,14 +155,22 @@ fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>,\n         .join(\"\\n\")\n }\n \n-/// Converts a span to a code snippet if available, otherwise use default.\n+/// Converts a span to a code snippet if available, otherwise returns the default.\n ///\n /// This is useful if you want to provide suggestions for your lint or more generally, if you want\n-/// to convert a given `Span` to a `str`.\n+/// to convert a given `Span` to a `str`. To create suggestions consider using\n+/// [`snippet_with_applicability`] to ensure that the applicability stays correct.\n ///\n /// # Example\n /// ```rust,ignore\n-/// snippet(cx, expr.span, \"..\")\n+/// // Given two spans one for `value` and one for the `init` expression.\n+/// let value = Vec::new();\n+/// //  ^^^^^   ^^^^^^^^^^\n+/// //  span1   span2\n+///\n+/// // The snipped call would return the corresponding code snippet\n+/// snippet(cx, span1, \"..\") // -> \"value\"\n+/// snippet(cx, span2, \"..\") // -> \"Vec::new()\"\n /// ```\n pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)"}, {"sha": "697158282709f6fef416b6e4a57433a4ad78ba9d", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d", "patch": "@@ -114,7 +114,12 @@ pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<\n \n /// Checks whether a type implements a trait.\n /// The function returns false in case the type contains an inference variable.\n-/// See also [`get_trait_def_id`](super::get_trait_def_id).\n+///\n+/// See:\n+/// * [`get_trait_def_id`](super::get_trait_def_id) to get a trait [`DefId`].\n+/// * [Common tools for writing lints] for an example how to use this function and other options.\n+///\n+/// [Common tools for writing lints]: https://github.com/rust-lang/rust-clippy/blob/master/doc/common_tools_writing_lints.md#checking-if-a-type-implements-a-specific-trait\n pub fn implements_trait<'tcx>(\n     cx: &LateContext<'tcx>,\n     ty: Ty<'tcx>,\n@@ -254,9 +259,17 @@ pub fn is_type_ref_to_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_ite\n     }\n }\n \n-/// Checks if the type is equal to a diagnostic item\n+/// Checks if the type is equal to a diagnostic item. To check if a type implements a\n+/// trait marked with a diagnostic item use [`implements_trait`].\n+///\n+/// For a further exploitation what diagnostic items are see [diagnostic items] in\n+/// rustc-dev-guide.\n+///\n+/// ---\n ///\n /// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n+///\n+/// [Diagnostic Items]: https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html\n pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),"}, {"sha": "ae2444f0171d992e5775a1debbd60175255efedb", "filename": "doc/adding_lints.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d", "patch": "@@ -634,7 +634,7 @@ in the following steps:\n Here are some pointers to things you are likely going to need for every lint:\n \n * [Clippy utils][utils] - Various helper functions. Maybe the function you need\n-  is already in here (`implements_trait`, `match_def_path`, `snippet`, etc)\n+  is already in here ([`is_type_diagnostic_item`], [`implements_trait`], [`snippet`], etc)\n * [Clippy diagnostics][diagnostics]\n * [The `if_chain` macro][if_chain]\n * [`from_expansion`][from_expansion] and [`in_external_macro`][in_external_macro]\n@@ -660,7 +660,10 @@ documentation currently. This is unfortunate, but in most cases you can probably\n get away with copying things from existing similar lints. If you are stuck,\n don't hesitate to ask on [Zulip] or in the issue/PR.\n \n-[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/lib.rs\n+[utils]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/index.html\n+[`is_type_diagnostic_item`]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/ty/fn.is_type_diagnostic_item.html\n+[`implements_trait`]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/ty/fn.implements_trait.html\n+[`snippet`]: https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/source/fn.snippet.html\n [if_chain]: https://docs.rs/if_chain/*/if_chain/\n [from_expansion]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion\n [in_external_macro]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/lint/fn.in_external_macro.html"}, {"sha": "552b9b2587b8fb1542b7884332ff3c0d0fc200f5", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=84a4ab7f3f21ae78cd1c274c4647fd38eef7d43d", "patch": "@@ -4,7 +4,8 @@ You may need following tooltips to catch up with common operations.\n \n - [Common tools for writing lints](#common-tools-for-writing-lints)\n   - [Retrieving the type of an expression](#retrieving-the-type-of-an-expression)\n-  - [Checking if an expression is calling a specific method](#checking-if-an-expr-is-calling-a-specific-method)\n+  - [Checking if an expr is calling a specific method](#checking-if-an-expr-is-calling-a-specific-method)\n+  - [Checking for a specific type](#checking-for-a-specific-type)\n   - [Checking if a type implements a specific trait](#checking-if-a-type-implements-a-specific-trait)\n   - [Checking if a type defines a specific method](#checking-if-a-type-defines-a-specific-method)\n   - [Dealing with macros](#dealing-with-macros)\n@@ -15,7 +16,7 @@ Useful Rustc dev guide links:\n - [Type checking](https://rustc-dev-guide.rust-lang.org/type-checking.html)\n - [Ty module](https://rustc-dev-guide.rust-lang.org/ty.html)\n \n-# Retrieving the type of an expression\n+## Retrieving the type of an expression\n \n Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for example to answer following questions:\n \n@@ -54,7 +55,7 @@ Two noticeable items here:\n   created by type checking step, it includes useful information such as types\n   of expressions, ways to resolve methods and so on.\n \n-# Checking if an expr is calling a specific method\n+## Checking if an expr is calling a specific method\n \n Starting with an `expr`, you can check whether it is calling a specific method `some_method`:\n \n@@ -63,9 +64,11 @@ impl LateLintPass<'_> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             // Check our expr is calling a method\n-            if let hir::ExprKind::MethodCall(path, _, _args, _) = &expr.kind;\n+            if let hir::ExprKind::MethodCall(path, _, [_self_arg, ..], _) = &expr.kind;\n             // Check the name of this method is `some_method`\n             if path.ident.name == sym!(some_method);\n+            // Optionally, check the type of the self argument.\n+            // - See \"Checking for a specific type\"\n             then {\n                 // ...\n             }\n@@ -74,7 +77,45 @@ impl LateLintPass<'_> for MyStructLint {\n }\n ```\n \n-# Checking if a type implements a specific trait\n+## Checking for a specific type\n+\n+There are three ways to check if an expression type is a specific type we want to check for.\n+All of these methods only check for the base type, generic arguments have to be checked separately.\n+\n+```rust\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n+use clippy_utils::{paths, match_def_path};\n+use rustc_span::symbol::sym;\n+use rustc_hir::LangItem;\n+\n+impl LateLintPass<'_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        // Getting the expression type\n+        let ty = cx.typeck_results().expr_ty(expr);\n+\n+        // 1. Using diagnostic items\n+        // The last argument is the diagnostic item to check for\n+        if is_type_diagnostic_item(cx, ty, sym::Option) {\n+            // The type is an `Option`\n+        }\n+\n+        // 2. Using lang items\n+        if is_type_lang_item(cx, ty, LangItem::RangeFull) {\n+            // The type is a full range like `.drain(..)`\n+        }\n+\n+        // 3. Using the type path\n+        // This method should be avoided if possible\n+        if match_def_path(cx, def_id, &paths::RESULT) {\n+            // The type is a `core::result::Result`\n+        }\n+    }\n+}\n+```\n+\n+Prefer using diagnostic items and lang items where possible.\n+\n+## Checking if a type implements a specific trait\n \n There are three ways to do this, depending on if the target trait has a diagnostic item, lang item or neither.\n \n@@ -102,6 +143,7 @@ impl LateLintPass<'_> for MyStructLint {\n \n         // 3. Using the type path with the expression\n         // we use `match_trait_method` function from Clippy's utils\n+        // (This method should be avoided if possible)\n         if match_trait_method(cx, expr, &paths::INTO) {\n             // `expr` implements `Into` trait\n         }\n@@ -114,7 +156,7 @@ impl LateLintPass<'_> for MyStructLint {\n We access lang items through the type context `tcx`. `tcx` is of type [`TyCtxt`][TyCtxt] and is defined in the `rustc_middle` crate.\n A list of defined paths for Clippy can be found in [paths.rs][paths]\n \n-# Checking if a type defines a specific method\n+## Checking if a type defines a specific method\n \n To check if our type defines a method called `some_method`:\n \n@@ -140,7 +182,7 @@ impl<'tcx> LateLintPass<'tcx> for MyTypeImpl {\n }\n ```\n \n-# Dealing with macros\n+## Dealing with macros\n \n There are several helpers in [`clippy_utils`][utils] to deal with macros:\n "}]}