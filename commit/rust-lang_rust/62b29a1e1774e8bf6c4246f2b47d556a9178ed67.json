{"sha": "62b29a1e1774e8bf6c4246f2b47d556a9178ed67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYjI5YTFlMTc3NGU4YmY2YzQyNDZmMmI0N2Q1NTZhOTE3OGVkNjc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-09T08:36:14Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-28T04:53:38Z"}, "message": "Adjust parsing of Slice, Tuple, TupleStruct patterns.", "tree": {"sha": "75d967c57e7d111260254c452f34b21c7c91d768", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75d967c57e7d111260254c452f34b21c7c91d768"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62b29a1e1774e8bf6c4246f2b47d556a9178ed67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62b29a1e1774e8bf6c4246f2b47d556a9178ed67", "html_url": "https://github.com/rust-lang/rust/commit/62b29a1e1774e8bf6c4246f2b47d556a9178ed67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62b29a1e1774e8bf6c4246f2b47d556a9178ed67/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e1b671f8ac935eeda9cf2c111c7c4eacc31e130", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e1b671f8ac935eeda9cf2c111c7c4eacc31e130", "html_url": "https://github.com/rust-lang/rust/commit/7e1b671f8ac935eeda9cf2c111c7c4eacc31e130"}], "stats": {"total": 153, "additions": 26, "deletions": 127}, "files": [{"sha": "04e4dcfcb1aedbb24a73befd2603d0496faf3c94", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 26, "deletions": 127, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/62b29a1e1774e8bf6c4246f2b47d556a9178ed67/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b29a1e1774e8bf6c4246f2b47d556a9178ed67/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=62b29a1e1774e8bf6c4246f2b47d556a9178ed67", "patch": "@@ -3535,122 +3535,6 @@ impl<'a> Parser<'a> {\n         };\n     }\n \n-    // Parses a parenthesized list of patterns like\n-    // `()`, `(p)`, `(p,)`, `(p, q)`, or `(p, .., q)`. Returns:\n-    // - a vector of the patterns that were parsed\n-    // - an option indicating the index of the `..` element\n-    // - a boolean indicating whether a trailing comma was present.\n-    // Trailing commas are significant because (p) and (p,) are different patterns.\n-    fn parse_parenthesized_pat_list(&mut self) -> PResult<'a, (Vec<P<Pat>>, Option<usize>, bool)> {\n-        self.expect(&token::OpenDelim(token::Paren))?;\n-        let result = match self.parse_pat_list() {\n-            Ok(result) => result,\n-            Err(mut err) => { // recover from parse error in tuple pattern list\n-                err.emit();\n-                self.consume_block(token::Paren);\n-                return Ok((vec![], Some(0), false));\n-            }\n-        };\n-        self.expect(&token::CloseDelim(token::Paren))?;\n-        Ok(result)\n-    }\n-\n-    fn parse_pat_list(&mut self) -> PResult<'a, (Vec<P<Pat>>, Option<usize>, bool)> {\n-        let mut fields = Vec::new();\n-        let mut ddpos = None;\n-        let mut prev_dd_sp = None;\n-        let mut trailing_comma = false;\n-        loop {\n-            if self.eat(&token::DotDot) {\n-                if ddpos.is_none() {\n-                    ddpos = Some(fields.len());\n-                    prev_dd_sp = Some(self.prev_span);\n-                } else {\n-                    // Emit a friendly error, ignore `..` and continue parsing\n-                    let mut err = self.struct_span_err(\n-                        self.prev_span,\n-                        \"`..` can only be used once per tuple or tuple struct pattern\",\n-                    );\n-                    err.span_label(self.prev_span, \"can only be used once per pattern\");\n-                    if let Some(sp) = prev_dd_sp {\n-                        err.span_label(sp, \"previously present here\");\n-                    }\n-                    err.emit();\n-                }\n-            } else if !self.check(&token::CloseDelim(token::Paren)) {\n-                fields.push(self.parse_pat(None)?);\n-            } else {\n-                break\n-            }\n-\n-            trailing_comma = self.eat(&token::Comma);\n-            if !trailing_comma {\n-                break\n-            }\n-        }\n-\n-        if ddpos == Some(fields.len()) && trailing_comma {\n-            // `..` needs to be followed by `)` or `, pat`, `..,)` is disallowed.\n-            let msg = \"trailing comma is not permitted after `..`\";\n-            self.struct_span_err(self.prev_span, msg)\n-                .span_label(self.prev_span, msg)\n-                .emit();\n-        }\n-\n-        Ok((fields, ddpos, trailing_comma))\n-    }\n-\n-    fn parse_pat_vec_elements(\n-        &mut self,\n-    ) -> PResult<'a, (Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>)> {\n-        let mut before = Vec::new();\n-        let mut slice = None;\n-        let mut after = Vec::new();\n-        let mut first = true;\n-        let mut before_slice = true;\n-\n-        while self.token != token::CloseDelim(token::Bracket) {\n-            if first {\n-                first = false;\n-            } else {\n-                self.expect(&token::Comma)?;\n-\n-                if self.token == token::CloseDelim(token::Bracket)\n-                        && (before_slice || !after.is_empty()) {\n-                    break\n-                }\n-            }\n-\n-            if before_slice {\n-                if self.eat(&token::DotDot) {\n-\n-                    if self.check(&token::Comma) ||\n-                            self.check(&token::CloseDelim(token::Bracket)) {\n-                        slice = Some(P(Pat {\n-                            id: ast::DUMMY_NODE_ID,\n-                            node: PatKind::Wild,\n-                            span: self.prev_span,\n-                        }));\n-                        before_slice = false;\n-                    }\n-                    continue\n-                }\n-            }\n-\n-            let subpat = self.parse_pat(None)?;\n-            if before_slice && self.eat(&token::DotDot) {\n-                slice = Some(subpat);\n-                before_slice = false;\n-            } else if before_slice {\n-                before.push(subpat);\n-            } else {\n-                after.push(subpat);\n-            }\n-        }\n-\n-        Ok((before, slice, after))\n-    }\n-\n     fn parse_pat_field(\n         &mut self,\n         lo: Span,\n@@ -3862,6 +3746,17 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n+    /// Parse a parentesized comma separated sequence of patterns until `delim` is reached.\n+    fn parse_recover_pat_list(&mut self) -> PResult<'a, ()> {\n+        while !self.check(&token::CloseDelim(token::Paren)) {\n+            self.parse_pat(None)?;\n+            if !self.eat(&token::Comma) {\n+                return Ok(())\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// A wrapper around `parse_pat` with some special error handling for the\n     /// \"top-level\" patterns in a match arm, `for` loop, `let`, &c. (in contrast\n     /// to subpatterns within such).\n@@ -3875,7 +3770,7 @@ impl<'a> Parser<'a> {\n             // later.\n             let comma_span = self.token.span;\n             self.bump();\n-            if let Err(mut err) = self.parse_pat_list() {\n+            if let Err(mut err) = self.parse_recover_pat_list() {\n                 // We didn't expect this to work anyway; we just wanted\n                 // to advance to the end of the comma-sequence so we know\n                 // the span to suggest parenthesizing\n@@ -3933,20 +3828,24 @@ impl<'a> Parser<'a> {\n                 pat = PatKind::Ref(subpat, mutbl);\n             }\n             token::OpenDelim(token::Paren) => {\n-                // Parse (pat,pat,pat,...) as tuple pattern\n-                let (fields, ddpos, trailing_comma) = self.parse_parenthesized_pat_list()?;\n-                pat = if fields.len() == 1 && ddpos.is_none() && !trailing_comma {\n+                // Parse `(pat, pat, pat, ...)` as tuple pattern.\n+                let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+\n+                pat = if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n                     PatKind::Paren(fields.into_iter().nth(0).unwrap())\n                 } else {\n-                    PatKind::Tuple(fields, ddpos)\n+                    PatKind::Tuple(fields)\n                 };\n             }\n             token::OpenDelim(token::Bracket) => {\n-                // Parse [pat,pat,...] as slice pattern\n+                // Parse `[pat, pat,...]` as a slice pattern.\n+                let (slice, _) = self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?;\n+                pat = PatKind::Slice(slice);\n+            }\n+            token::DotDot => {\n+                // Parse `..`.\n                 self.bump();\n-                let (before, slice, after) = self.parse_pat_vec_elements()?;\n-                self.expect(&token::CloseDelim(token::Bracket))?;\n-                pat = PatKind::Slice(before, slice, after);\n+                pat = PatKind::Rest;\n             }\n             // At this point, token != &, &&, (, [\n             _ => if self.eat_keyword(kw::Underscore) {\n@@ -4044,8 +3943,8 @@ impl<'a> Parser<'a> {\n                             return Err(err);\n                         }\n                         // Parse tuple struct or enum pattern\n-                        let (fields, ddpos, _) = self.parse_parenthesized_pat_list()?;\n-                        pat = PatKind::TupleStruct(path, fields, ddpos)\n+                        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+                        pat = PatKind::TupleStruct(path, fields)\n                     }\n                     _ => pat = PatKind::Path(qself, path),\n                 }"}]}