{"sha": "309421c117fc20e58b9f30fb28a01a89f50b0086", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwOTQyMWMxMTdmYzIwZTU4YjlmMzBmYjI4YTAxYTg5ZjUwYjAwODY=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-02-23T23:20:00Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-08T21:58:48Z"}, "message": "Draft the qualifier import resolution", "tree": {"sha": "77ab1a1a1dd426a5ffa2f817e0df49c4b804782e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77ab1a1a1dd426a5ffa2f817e0df49c4b804782e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/309421c117fc20e58b9f30fb28a01a89f50b0086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/309421c117fc20e58b9f30fb28a01a89f50b0086", "html_url": "https://github.com/rust-lang/rust/commit/309421c117fc20e58b9f30fb28a01a89f50b0086", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/309421c117fc20e58b9f30fb28a01a89f50b0086/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c395c3311dc2ac59251e86eaa6b86b597358d31f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c395c3311dc2ac59251e86eaa6b86b597358d31f", "html_url": "https://github.com/rust-lang/rust/commit/c395c3311dc2ac59251e86eaa6b86b597358d31f"}], "stats": {"total": 267, "additions": 224, "deletions": 43}, "files": [{"sha": "c0463311effb20872d12cfee254c2fa14675528f", "filename": "crates/ide_assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/309421c117fc20e58b9f30fb28a01a89f50b0086/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309421c117fc20e58b9f30fb28a01a89f50b0086/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=309421c117fc20e58b9f30fb28a01a89f50b0086", "patch": "@@ -1,7 +1,10 @@\n use std::iter;\n \n use hir::AsAssocItem;\n-use ide_db::helpers::{import_assets::ImportCandidate, mod_path_to_ast};\n+use ide_db::helpers::{\n+    import_assets::{ImportCandidate, Qualifier},\n+    mod_path_to_ast,\n+};\n use ide_db::RootDatabase;\n use syntax::{\n     ast,\n@@ -45,7 +48,7 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n     let qualify_candidate = match candidate {\n         ImportCandidate::Path(candidate) => {\n-            if candidate.unresolved_qualifier.is_some() {\n+            if !matches!(candidate.qualifier, Qualifier::Absent) {\n                 cov_mark::hit!(qualify_path_qualifier_start);\n                 let path = ast::Path::cast(syntax_under_caret)?;\n                 let (prev_segment, segment) = (path.qualifier()?.segment()?, path.segment()?);\n@@ -192,7 +195,7 @@ fn group_label(candidate: &ImportCandidate) -> GroupLabel {\n fn label(candidate: &ImportCandidate, import: &hir::ModPath) -> String {\n     match candidate {\n         ImportCandidate::Path(candidate) => {\n-            if candidate.unresolved_qualifier.is_some() {\n+            if !matches!(candidate.qualifier, Qualifier::Absent) {\n                 format!(\"Qualify with `{}`\", &import)\n             } else {\n                 format!(\"Qualify as `{}`\", &import)"}, {"sha": "64b60bbdd4076a9ecfbae6ba6d6f1c5e4a5a84e4", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 81, "deletions": 3, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/309421c117fc20e58b9f30fb28a01a89f50b0086/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309421c117fc20e58b9f30fb28a01a89f50b0086/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=309421c117fc20e58b9f30fb28a01a89f50b0086", "patch": "@@ -775,18 +775,92 @@ fn main() {\n     }\n \n     #[test]\n-    fn unresolved_qualifiers() {\n+    fn unresolved_qualifier() {\n+        check_edit(\n+            \"Item\",\n+            r#\"\n+mod foo {\n+    pub mod bar {\n+        pub mod baz {\n+            pub struct Item;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::baz::Ite$0\n+}\n+\"#,\n+            r#\"\n+use foo::bar;\n+\n+mod foo {\n+    pub mod bar {\n+        pub mod baz {\n+            pub struct Item;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::baz::Item\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unresolved_assoc_item_container() {\n+        check_edit(\n+            \"Item\",\n+            r#\"\n+mod foo {\n+    pub struct Item;\n+\n+    impl Item {\n+        pub const TEST_ASSOC: usize = 3;\n+    }\n+}\n+\n+fn main() {\n+    Item::TEST_A$0;\n+}\n+\"#,\n+            r#\"\n+use foo::Item;\n+\n+mod foo {\n+    pub struct Item;\n+\n+    impl Item {\n+        pub const TEST_ASSOC: usize = 3;\n+    }\n+}\n+\n+fn main() {\n+    Item::TEST_ASSOC\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unresolved_assoc_item_container_with_path() {\n         check_edit(\n             \"Item\",\n             r#\"\n mod foo {\n     pub mod bar {\n         pub struct Item;\n+\n+        impl Item {\n+            pub const TEST_ASSOC: usize = 3;\n+        }\n     }\n }\n \n fn main() {\n-    bar::Ite$0\n+    bar::Item::TEST_A$0;\n }\n \"#,\n             r#\"\n@@ -795,11 +869,15 @@ use foo::bar;\n mod foo {\n     pub mod bar {\n         pub struct Item;\n+\n+        impl Item {\n+            pub const TEST_ASSOC: usize = 3;\n+        }\n     }\n }\n \n fn main() {\n-    bar::Item\n+    bar::Item::TEST_ASSOC\n }\n \"#,\n         );"}, {"sha": "dc3b92a643ec1d41db72fdea77a22b44473c65f2", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 136, "deletions": 37, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/309421c117fc20e58b9f30fb28a01a89f50b0086/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309421c117fc20e58b9f30fb28a01a89f50b0086/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=309421c117fc20e58b9f30fb28a01a89f50b0086", "patch": "@@ -1,8 +1,8 @@\n //! Look up accessible paths for items.\n use either::Either;\n use hir::{\n-    AsAssocItem, AssocItem, Crate, ItemInNs, MacroDef, ModPath, Module, ModuleDef, PrefixKind,\n-    Semantics,\n+    AsAssocItem, AssocItem, Crate, ItemInNs, MacroDef, ModPath, Module, ModuleDef, Name,\n+    PrefixKind, Semantics,\n };\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n@@ -34,10 +34,16 @@ pub struct TraitImportCandidate {\n \n #[derive(Debug)]\n pub struct PathImportCandidate {\n-    pub unresolved_qualifier: Option<ast::Path>,\n+    pub qualifier: Qualifier,\n     pub name: NameToImport,\n }\n \n+#[derive(Debug)]\n+pub enum Qualifier {\n+    Absent,\n+    FirstSegmentUnresolved(ast::PathSegment, ast::Path),\n+}\n+\n #[derive(Debug)]\n pub enum NameToImport {\n     Exact(String),\n@@ -162,8 +168,9 @@ impl ImportAssets {\n                 let (assoc_item_search, limit) = if self.import_candidate.is_trait_candidate() {\n                     (AssocItemSearch::AssocItemsOnly, None)\n                 } else {\n-                    (AssocItemSearch::Exclude, Some(DEFAULT_QUERY_SEARCH_LIMIT))\n+                    (AssocItemSearch::Include, Some(DEFAULT_QUERY_SEARCH_LIMIT))\n                 };\n+\n                 imports_locator::find_similar_imports(\n                     sema,\n                     current_crate,\n@@ -192,17 +199,16 @@ impl ImportAssets {\n         let db = sema.db;\n \n         match &self.import_candidate {\n-            ImportCandidate::Path(path_candidate) => Box::new(path_applicable_items(\n-                sema,\n-                path_candidate,\n-                unfiltered_defs\n-                    .into_iter()\n-                    .map(|def| def.either(ItemInNs::from, ItemInNs::from))\n-                    .filter_map(move |item_to_search| {\n-                        get_mod_path(db, item_to_search, &self.module_with_candidate, prefixed)\n-                            .zip(Some(item_to_search))\n-                    }),\n-            )),\n+            ImportCandidate::Path(path_candidate) => Box::new(\n+                path_applicable_items(\n+                    db,\n+                    path_candidate,\n+                    &self.module_with_candidate,\n+                    prefixed,\n+                    unfiltered_defs,\n+                )\n+                .into_iter(),\n+            ),\n             ImportCandidate::TraitAssocItem(trait_candidate) => Box::new(\n                 trait_applicable_defs(db, current_crate, trait_candidate, true, unfiltered_defs)\n                     .into_iter()\n@@ -224,27 +230,110 @@ impl ImportAssets {\n }\n \n fn path_applicable_items<'a>(\n-    sema: &'a Semantics<RootDatabase>,\n-    path_candidate: &PathImportCandidate,\n-    unfiltered_defs: impl Iterator<Item = (ModPath, ItemInNs)> + 'a,\n-) -> Box<dyn Iterator<Item = (ModPath, ItemInNs)> + 'a> {\n-    let unresolved_qualifier = match &path_candidate.unresolved_qualifier {\n-        Some(qualifier) => qualifier,\n-        None => {\n-            return Box::new(unfiltered_defs);\n+    db: &'a RootDatabase,\n+    path_candidate: &'a PathImportCandidate,\n+    module_with_candidate: &hir::Module,\n+    prefixed: Option<hir::PrefixKind>,\n+    unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>> + 'a,\n+) -> FxHashSet<(ModPath, ItemInNs)> {\n+    let applicable_items = unfiltered_defs\n+        .filter_map(|def| {\n+            let (assoc_original, candidate) = match def {\n+                Either::Left(module_def) => match module_def.as_assoc_item(db) {\n+                    Some(assoc_item) => match assoc_item.container(db) {\n+                        hir::AssocItemContainer::Trait(trait_) => {\n+                            (Some(module_def), ItemInNs::from(ModuleDef::from(trait_)))\n+                        }\n+                        hir::AssocItemContainer::Impl(impl_) => (\n+                            Some(module_def),\n+                            ItemInNs::from(ModuleDef::from(impl_.target_ty(db).as_adt()?)),\n+                        ),\n+                    },\n+                    None => (None, ItemInNs::from(module_def)),\n+                },\n+                Either::Right(macro_def) => (None, ItemInNs::from(macro_def)),\n+            };\n+            Some((assoc_original, candidate))\n+        })\n+        .filter_map(|(assoc_original, candidate)| {\n+            get_mod_path(db, candidate, module_with_candidate, prefixed)\n+                .zip(Some((assoc_original, candidate)))\n+        });\n+\n+    let (unresolved_first_segment, unresolved_qualifier) = match &path_candidate.qualifier {\n+        Qualifier::Absent => {\n+            return applicable_items\n+                .map(|(candidate_path, (_, candidate))| (candidate_path, candidate))\n+                .collect();\n         }\n+        Qualifier::FirstSegmentUnresolved(first_segment, qualifier) => (first_segment, qualifier),\n     };\n \n-    let qualifier_string = unresolved_qualifier.to_string();\n-    Box::new(unfiltered_defs.filter(move |(candidate_path, _)| {\n-        let mut candidate_qualifier = candidate_path.clone();\n-        candidate_qualifier.pop_segment();\n+    // TODO kb need to remove turbofish from the qualifier, maybe use the segments instead?\n+    let unresolved_qualifier_string = unresolved_qualifier.to_string();\n+    let unresolved_first_segment_string = unresolved_first_segment.to_string();\n+\n+    applicable_items\n+        .filter(|(candidate_path, _)| {\n+            let candidate_path_string = candidate_path.to_string();\n+            candidate_path_string.contains(&unresolved_qualifier_string)\n+                && candidate_path_string.contains(&unresolved_first_segment_string)\n+        })\n+        // TODO kb need to adjust the return type: I get the results rendered rather badly\n+        .filter_map(|(candidate_path, (assoc_original, candidate))| {\n+            if let Some(assoc_original) = assoc_original {\n+                if item_name(db, candidate)?.to_string() == unresolved_first_segment_string {\n+                    return Some((candidate_path, ItemInNs::from(assoc_original)));\n+                }\n+            }\n+\n+            let matching_module =\n+                module_with_matching_name(db, &unresolved_first_segment_string, candidate)?;\n+            let path = get_mod_path(\n+                db,\n+                ItemInNs::from(ModuleDef::from(matching_module)),\n+                module_with_candidate,\n+                prefixed,\n+            )?;\n+            Some((path, candidate))\n+        })\n+        .collect()\n+}\n+\n+fn item_name(db: &RootDatabase, item: ItemInNs) -> Option<Name> {\n+    match item {\n+        ItemInNs::Types(module_def_id) => ModuleDef::from(module_def_id).name(db),\n+        ItemInNs::Values(module_def_id) => ModuleDef::from(module_def_id).name(db),\n+        ItemInNs::Macros(macro_def_id) => MacroDef::from(macro_def_id).name(db),\n+    }\n+}\n \n-        // TODO kb\n-        // * take 1st segment of `unresolved_qualifier` and return it instead of the original `ItemInNs`\n-        // * Update `ModPath`: pop until 1st segment of `unresolved_qualifier` reached (do not rely on name comparison, nested mod names can repeat)\n-        candidate_qualifier.to_string().ends_with(&qualifier_string)\n-    }))\n+fn item_module(db: &RootDatabase, item: ItemInNs) -> Option<Module> {\n+    match item {\n+        ItemInNs::Types(module_def_id) => ModuleDef::from(module_def_id).module(db),\n+        ItemInNs::Values(module_def_id) => ModuleDef::from(module_def_id).module(db),\n+        ItemInNs::Macros(macro_def_id) => MacroDef::from(macro_def_id).module(db),\n+    }\n+}\n+\n+fn module_with_matching_name(\n+    db: &RootDatabase,\n+    unresolved_first_segment_string: &str,\n+    candidate: ItemInNs,\n+) -> Option<Module> {\n+    let mut current_module = item_module(db, candidate);\n+    while let Some(module) = current_module {\n+        match module.name(db) {\n+            Some(module_name) => {\n+                if module_name.to_string().as_str() == unresolved_first_segment_string {\n+                    return Some(module);\n+                }\n+            }\n+            None => {}\n+        }\n+        current_module = module.parent(db);\n+    }\n+    None\n }\n \n fn trait_applicable_defs<'a>(\n@@ -367,10 +456,20 @@ fn path_import_candidate(\n ) -> Option<ImportCandidate> {\n     Some(match qualifier {\n         Some(qualifier) => match sema.resolve_path(&qualifier) {\n-            None => ImportCandidate::Path(PathImportCandidate {\n-                unresolved_qualifier: Some(qualifier),\n-                name,\n-            }),\n+            None => {\n+                let qualifier_start =\n+                    qualifier.syntax().descendants().find_map(ast::PathSegment::cast)?;\n+                let qualifier_start_path =\n+                    qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n+                if sema.resolve_path(&qualifier_start_path).is_none() {\n+                    ImportCandidate::Path(PathImportCandidate {\n+                        qualifier: Qualifier::FirstSegmentUnresolved(qualifier_start, qualifier),\n+                        name,\n+                    })\n+                } else {\n+                    return None;\n+                }\n+            }\n             Some(hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path))) => {\n                 ImportCandidate::TraitAssocItem(TraitImportCandidate {\n                     receiver_ty: assoc_item_path.ty(sema.db),\n@@ -379,6 +478,6 @@ fn path_import_candidate(\n             }\n             Some(_) => return None,\n         },\n-        None => ImportCandidate::Path(PathImportCandidate { unresolved_qualifier: None, name }),\n+        None => ImportCandidate::Path(PathImportCandidate { qualifier: Qualifier::Absent, name }),\n     })\n }"}, {"sha": "480cbf1ea8918b2b08fa91f7c0f1e28b4a1855de", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/309421c117fc20e58b9f30fb28a01a89f50b0086/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309421c117fc20e58b9f30fb28a01a89f50b0086/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=309421c117fc20e58b9f30fb28a01a89f50b0086", "patch": "@@ -40,6 +40,7 @@ pub fn find_exact_imports<'a>(\n     ))\n }\n \n+#[derive(Debug)]\n pub enum AssocItemSearch {\n     Include,\n     Exclude,"}]}