{"sha": "2c1f676bfe831f488cbd8e07d46b7b9be727ca24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMWY2NzZiZmU4MzFmNDg4Y2JkOGUwN2Q0NmI3YjliZTcyN2NhMjQ=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-09T20:58:10Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:14:20Z"}, "message": "Add detect_same_item_push to its own module", "tree": {"sha": "fce4214e1fcc2d099a736b4e2e07bcfe8e9e0ca1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fce4214e1fcc2d099a736b4e2e07bcfe8e9e0ca1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c1f676bfe831f488cbd8e07d46b7b9be727ca24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1f676bfe831f488cbd8e07d46b7b9be727ca24", "html_url": "https://github.com/rust-lang/rust/commit/2c1f676bfe831f488cbd8e07d46b7b9be727ca24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c1f676bfe831f488cbd8e07d46b7b9be727ca24/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "453e6b97ace822f715b6118a60ec9b33e0ae87ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/453e6b97ace822f715b6118a60ec9b33e0ae87ec", "html_url": "https://github.com/rust-lang/rust/commit/453e6b97ace822f715b6118a60ec9b33e0ae87ec"}], "stats": {"total": 339, "additions": 174, "deletions": 165}, "files": [{"sha": "66b71a7202ea67ee2aeab79e9d017620671e311a", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 6, "deletions": 165, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/2c1f676bfe831f488cbd8e07d46b7b9be727ca24/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1f676bfe831f488cbd8e07d46b7b9be727ca24/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=2c1f676bfe831f488cbd8e07d46b7b9be727ca24", "patch": "@@ -7,25 +7,25 @@ mod for_single_element_loop;\n mod infinite_loop;\n mod manual_flatten;\n mod needless_collect;\n+mod same_item_push;\n mod utils;\n \n use crate::utils::sugg::Sugg;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     get_enclosing_block, get_parent_expr, get_trait_def_id, higher, implements_trait, is_in_panic_handler,\n     is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_trait_method,\n-    path_to_local, path_to_local_id, paths, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n-    span_lint, span_lint_and_help, span_lint_and_sugg, sugg,\n+    path_to_local, path_to_local_id, paths, snippet, snippet_with_applicability, span_lint, span_lint_and_help,\n+    span_lint_and_sugg, sugg,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n-use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, MatchSource,\n-    Mutability, Node, Pat, PatKind, Stmt, StmtKind,\n+    BinOpKind, Block, BorrowKind, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, MatchSource, Mutability, Node,\n+    Pat, PatKind, Stmt, StmtKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n@@ -866,7 +866,7 @@ fn check_for_loop<'tcx>(\n     for_loop_over_map_kv::check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n     for_mut_range_bound::check_for_mut_range_bound(cx, arg, body);\n     for_single_element_loop::check_for_single_element_loop(cx, pat, arg, body, expr);\n-    detect_same_item_push(cx, pat, arg, body, expr);\n+    same_item_push::detect_same_item_push(cx, pat, arg, body, expr);\n     manual_flatten::check_manual_flatten(cx, pat, arg, body, span);\n }\n \n@@ -1307,165 +1307,6 @@ fn detect_manual_memcpy<'tcx>(\n     false\n }\n \n-// Scans the body of the for loop and determines whether lint should be given\n-struct SameItemPushVisitor<'a, 'tcx> {\n-    should_lint: bool,\n-    // this field holds the last vec push operation visited, which should be the only push seen\n-    vec_push: Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        match &expr.kind {\n-            // Non-determinism may occur ... don't give a lint\n-            ExprKind::Loop(..) | ExprKind::Match(..) => self.should_lint = false,\n-            ExprKind::Block(block, _) => self.visit_block(block),\n-            _ => {},\n-        }\n-    }\n-\n-    fn visit_block(&mut self, b: &'tcx Block<'_>) {\n-        for stmt in b.stmts.iter() {\n-            self.visit_stmt(stmt);\n-        }\n-    }\n-\n-    fn visit_stmt(&mut self, s: &'tcx Stmt<'_>) {\n-        let vec_push_option = get_vec_push(self.cx, s);\n-        if vec_push_option.is_none() {\n-            // Current statement is not a push so visit inside\n-            match &s.kind {\n-                StmtKind::Expr(expr) | StmtKind::Semi(expr) => self.visit_expr(&expr),\n-                _ => {},\n-            }\n-        } else {\n-            // Current statement is a push ...check whether another\n-            // push had been previously done\n-            if self.vec_push.is_none() {\n-                self.vec_push = vec_push_option;\n-            } else {\n-                // There are multiple pushes ... don't lint\n-                self.should_lint = false;\n-            }\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-// Given some statement, determine if that statement is a push on a Vec. If it is, return\n-// the Vec being pushed into and the item being pushed\n-fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n-    if_chain! {\n-            // Extract method being called\n-            if let StmtKind::Semi(semi_stmt) = &stmt.kind;\n-            if let ExprKind::MethodCall(path, _, args, _) = &semi_stmt.kind;\n-            // Figure out the parameters for the method call\n-            if let Some(self_expr) = args.get(0);\n-            if let Some(pushed_item) = args.get(1);\n-            // Check that the method being called is push() on a Vec\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym::vec_type);\n-            if path.ident.name.as_str() == \"push\";\n-            then {\n-                return Some((self_expr, pushed_item))\n-            }\n-    }\n-    None\n-}\n-\n-/// Detects for loop pushing the same item into a Vec\n-fn detect_same_item_push<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &'tcx Pat<'_>,\n-    _: &'tcx Expr<'_>,\n-    body: &'tcx Expr<'_>,\n-    _: &'tcx Expr<'_>,\n-) {\n-    fn emit_lint(cx: &LateContext<'_>, vec: &Expr<'_>, pushed_item: &Expr<'_>) {\n-        let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n-        let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n-\n-        span_lint_and_help(\n-            cx,\n-            SAME_ITEM_PUSH,\n-            vec.span,\n-            \"it looks like the same item is being pushed into this Vec\",\n-            None,\n-            &format!(\n-                \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n-                item_str, vec_str, item_str\n-            ),\n-        )\n-    }\n-\n-    if !matches!(pat.kind, PatKind::Wild) {\n-        return;\n-    }\n-\n-    // Determine whether it is safe to lint the body\n-    let mut same_item_push_visitor = SameItemPushVisitor {\n-        should_lint: true,\n-        vec_push: None,\n-        cx,\n-    };\n-    walk_expr(&mut same_item_push_visitor, body);\n-    if same_item_push_visitor.should_lint {\n-        if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n-            let vec_ty = cx.typeck_results().expr_ty(vec);\n-            let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n-            if cx\n-                .tcx\n-                .lang_items()\n-                .clone_trait()\n-                .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n-            {\n-                // Make sure that the push does not involve possibly mutating values\n-                match pushed_item.kind {\n-                    ExprKind::Path(ref qpath) => {\n-                        match cx.qpath_res(qpath, pushed_item.hir_id) {\n-                            // immutable bindings that are initialized with literal or constant\n-                            Res::Local(hir_id) => {\n-                                if_chain! {\n-                                    let node = cx.tcx.hir().get(hir_id);\n-                                    if let Node::Binding(pat) = node;\n-                                    if let PatKind::Binding(bind_ann, ..) = pat.kind;\n-                                    if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n-                                    let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n-                                    if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n-                                    if let Some(init) = parent_let_expr.init;\n-                                    then {\n-                                        match init.kind {\n-                                            // immutable bindings that are initialized with literal\n-                                            ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n-                                            // immutable bindings that are initialized with constant\n-                                            ExprKind::Path(ref path) => {\n-                                                if let Res::Def(DefKind::Const, ..) = cx.qpath_res(path, init.hir_id) {\n-                                                    emit_lint(cx, vec, pushed_item);\n-                                                }\n-                                            }\n-                                            _ => {},\n-                                        }\n-                                    }\n-                                }\n-                            },\n-                            // constant\n-                            Res::Def(DefKind::Const, ..) => emit_lint(cx, vec, pushed_item),\n-                            _ => {},\n-                        }\n-                    },\n-                    ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-}\n-\n fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n     let def_id = match path_to_local(expr) {\n         Some(id) => id,"}, {"sha": "62efb58a38f7de0cca57e2e29e28e998e3097bfa", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/2c1f676bfe831f488cbd8e07d46b7b9be727ca24/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1f676bfe831f488cbd8e07d46b7b9be727ca24/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=2c1f676bfe831f488cbd8e07d46b7b9be727ca24", "patch": "@@ -0,0 +1,168 @@\n+use crate::utils::{implements_trait, is_type_diagnostic_item, snippet_with_macro_callsite, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Node, Pat, PatKind, Stmt, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_span::symbol::sym;\n+use std::iter::Iterator;\n+\n+/// Detects for loop pushing the same item into a Vec\n+pub(super) fn detect_same_item_push<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    _: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    _: &'tcx Expr<'_>,\n+) {\n+    fn emit_lint(cx: &LateContext<'_>, vec: &Expr<'_>, pushed_item: &Expr<'_>) {\n+        let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n+        let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n+\n+        span_lint_and_help(\n+            cx,\n+            super::SAME_ITEM_PUSH,\n+            vec.span,\n+            \"it looks like the same item is being pushed into this Vec\",\n+            None,\n+            &format!(\n+                \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                item_str, vec_str, item_str\n+            ),\n+        )\n+    }\n+\n+    if !matches!(pat.kind, PatKind::Wild) {\n+        return;\n+    }\n+\n+    // Determine whether it is safe to lint the body\n+    let mut same_item_push_visitor = SameItemPushVisitor {\n+        should_lint: true,\n+        vec_push: None,\n+        cx,\n+    };\n+    walk_expr(&mut same_item_push_visitor, body);\n+    if same_item_push_visitor.should_lint {\n+        if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n+            let vec_ty = cx.typeck_results().expr_ty(vec);\n+            let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n+            if cx\n+                .tcx\n+                .lang_items()\n+                .clone_trait()\n+                .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+            {\n+                // Make sure that the push does not involve possibly mutating values\n+                match pushed_item.kind {\n+                    ExprKind::Path(ref qpath) => {\n+                        match cx.qpath_res(qpath, pushed_item.hir_id) {\n+                            // immutable bindings that are initialized with literal or constant\n+                            Res::Local(hir_id) => {\n+                                if_chain! {\n+                                    let node = cx.tcx.hir().get(hir_id);\n+                                    if let Node::Binding(pat) = node;\n+                                    if let PatKind::Binding(bind_ann, ..) = pat.kind;\n+                                    if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n+                                    let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n+                                    if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n+                                    if let Some(init) = parent_let_expr.init;\n+                                    then {\n+                                        match init.kind {\n+                                            // immutable bindings that are initialized with literal\n+                                            ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                                            // immutable bindings that are initialized with constant\n+                                            ExprKind::Path(ref path) => {\n+                                                if let Res::Def(DefKind::Const, ..) = cx.qpath_res(path, init.hir_id) {\n+                                                    emit_lint(cx, vec, pushed_item);\n+                                                }\n+                                            }\n+                                            _ => {},\n+                                        }\n+                                    }\n+                                }\n+                            },\n+                            // constant\n+                            Res::Def(DefKind::Const, ..) => emit_lint(cx, vec, pushed_item),\n+                            _ => {},\n+                        }\n+                    },\n+                    ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Scans the body of the for loop and determines whether lint should be given\n+struct SameItemPushVisitor<'a, 'tcx> {\n+    should_lint: bool,\n+    // this field holds the last vec push operation visited, which should be the only push seen\n+    vec_push: Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        match &expr.kind {\n+            // Non-determinism may occur ... don't give a lint\n+            ExprKind::Loop(..) | ExprKind::Match(..) => self.should_lint = false,\n+            ExprKind::Block(block, _) => self.visit_block(block),\n+            _ => {},\n+        }\n+    }\n+\n+    fn visit_block(&mut self, b: &'tcx Block<'_>) {\n+        for stmt in b.stmts.iter() {\n+            self.visit_stmt(stmt);\n+        }\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'tcx Stmt<'_>) {\n+        let vec_push_option = get_vec_push(self.cx, s);\n+        if vec_push_option.is_none() {\n+            // Current statement is not a push so visit inside\n+            match &s.kind {\n+                StmtKind::Expr(expr) | StmtKind::Semi(expr) => self.visit_expr(&expr),\n+                _ => {},\n+            }\n+        } else {\n+            // Current statement is a push ...check whether another\n+            // push had been previously done\n+            if self.vec_push.is_none() {\n+                self.vec_push = vec_push_option;\n+            } else {\n+                // There are multiple pushes ... don't lint\n+                self.should_lint = false;\n+            }\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+// Given some statement, determine if that statement is a push on a Vec. If it is, return\n+// the Vec being pushed into and the item being pushed\n+fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if_chain! {\n+            // Extract method being called\n+            if let StmtKind::Semi(semi_stmt) = &stmt.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = &semi_stmt.kind;\n+            // Figure out the parameters for the method call\n+            if let Some(self_expr) = args.get(0);\n+            if let Some(pushed_item) = args.get(1);\n+            // Check that the method being called is push() on a Vec\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym::vec_type);\n+            if path.ident.name.as_str() == \"push\";\n+            then {\n+                return Some((self_expr, pushed_item))\n+            }\n+    }\n+    None\n+}"}]}