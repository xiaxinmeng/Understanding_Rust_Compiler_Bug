{"sha": "b8c5e4650598f43a2e362bcf6f4e919440a997bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YzVlNDY1MDU5OGY0M2EyZTM2MmJjZjZmNGU5MTk0NDBhOTk3YmI=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-06-25T22:20:01Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-06-28T04:41:10Z"}, "message": "working on hygiene", "tree": {"sha": "af70d7198561d26bf5091ce068e8f0409aedbb37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af70d7198561d26bf5091ce068e8f0409aedbb37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8c5e4650598f43a2e362bcf6f4e919440a997bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c5e4650598f43a2e362bcf6f4e919440a997bb", "html_url": "https://github.com/rust-lang/rust/commit/b8c5e4650598f43a2e362bcf6f4e919440a997bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8c5e4650598f43a2e362bcf6f4e919440a997bb/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e880c42920592558c5c7d3d7cfdf339bb4ab08d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e880c42920592558c5c7d3d7cfdf339bb4ab08d1", "html_url": "https://github.com/rust-lang/rust/commit/e880c42920592558c5c7d3d7cfdf339bb4ab08d1"}], "stats": {"total": 63, "additions": 51, "deletions": 12}, "files": [{"sha": "529b460adcd34d862bcb951e8ee00a8f27358d40", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8c5e4650598f43a2e362bcf6f4e919440a997bb/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c5e4650598f43a2e362bcf6f4e919440a997bb/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b8c5e4650598f43a2e362bcf6f4e919440a997bb", "patch": "@@ -401,6 +401,7 @@ pub enum Decl_ {\n     DeclItem(Gc<Item>),\n }\n \n+/// represents one arm of a 'match'\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,"}, {"sha": "11f50d685f88e82eac8ca58924f2f4920da28d7e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 50, "deletions": 12, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b8c5e4650598f43a2e362bcf6f4e919440a997bb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c5e4650598f43a2e362bcf6f4e919440a997bb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b8c5e4650598f43a2e362bcf6f4e919440a997bb", "patch": "@@ -31,6 +31,7 @@ use util::small_vector::SmallVector;\n \n use std::gc::{Gc, GC};\n \n+\n pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n     match e.node {\n         // expr_mac should really be expr_ext or something; it's the\n@@ -130,8 +131,6 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n         // From: `['<ident>:] for <src_pat> in <src_expr> <src_loop_block>`\n         // FIXME #6993: change type of opt_ident to Option<Name>\n         ast::ExprForLoop(src_pat, src_expr, src_loop_block, opt_ident) => {\n-            // Expand any interior macros etc.\n-            // NB: we don't fold pats yet. Curious.\n \n             let span = e.span;\n \n@@ -281,7 +280,7 @@ macro_rules! with_exts_frame (\n )\n \n // When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n+fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                    -> SmallVector<Gc<ast::Item>> {\n     let it = expand_item_modifiers(it, fld);\n \n@@ -386,13 +385,13 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n }\n \n // does this attribute list contain \"macro_escape\" ?\n-pub fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n+fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"macro_escape\")\n }\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n+fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n                        -> SmallVector<Gc<ast::Item>> {\n     let (pth, tts) = match it.node {\n         ItemMac(codemap::Spanned {\n@@ -498,7 +497,7 @@ pub fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n }\n \n // expand a stmt\n-pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n+fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n     let (pth, tts, semi) = match s.node {\n@@ -659,6 +658,42 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n     }\n }\n \n+fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n+    if a.pats.len() == 0 {\n+        fail!(\"encountered match arm with 0 patterns\");\n+    }\n+    let first_pat = match a.pats.get(0) {\n+        \n+    }\n+    // code duplicated from 'let', above. Perhaps this can be lifted\n+    // into a separate function:\n+    let expanded_pat = fld.fold_pat(pat);\n+    let mut name_finder = new_name_finder(Vec::new());\n+    name_finder.visit_pat(&*expanded_pat,());\n+    let mut new_pending_renames = Vec::new();\n+    for ident in name_finder.ident_accumulator.iter() {\n+        let new_name = fresh_name(ident);\n+        new_pending_renames.push((*ident,new_name));\n+    }\n+    let rewritten_pat = {\n+        let mut rename_fld =\n+            renames_to_fold(&mut new_pending_renames);\n+        // rewrite the pattern using the new names (the old\n+        // ones have already been applied):\n+        rename_fld.fold_pat(expanded_pat)\n+    };\n+    \n+    let bound_names\n+        ast::Arm {\n+        attrs: a.attrs.iter().map(|x| self.fold_attribute(*x)).collect(),\n+        pats: a.pats.iter().map(|x| self.fold_pat(*x)).collect(),\n+        guard: a.guard.map(|x| self.fold_expr(x)),\n+        body: self.fold_expr(a.body),\n+    }    \n+}\n+\n+\n+\n // a visitor that extracts the pat_ident (binding) paths\n // from a given thingy and puts them in a mutable\n // array (passed in to the traversal).\n@@ -711,14 +746,14 @@ fn new_name_finder(idents: Vec<ast::Ident> ) -> NameFinderContext {\n }\n \n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n-pub fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n+fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n     // see note below about treatment of exts table\n     with_exts_frame!(fld.extsbox,false,\n                      expand_block_elts(blk, fld))\n }\n \n // expand the elements of a block.\n-pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n+fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n     let new_view_items = b.view_items.iter().map(|x| fld.fold_view_item(x)).collect();\n     let new_stmts =\n         b.stmts.iter().flat_map(|x| {\n@@ -747,7 +782,7 @@ pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n     })\n }\n \n-pub fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n+fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n     let (pth, tts) = match p.node {\n         PatMac(ref mac) => {\n             match mac.node {\n@@ -842,13 +877,13 @@ impl<'a> Folder for IdentRenamer<'a> {\n \n // given a mutable list of renames, return a tree-folder that applies those\n // renames.\n-pub fn renames_to_fold<'a>(renames: &'a mut RenameList) -> IdentRenamer<'a> {\n+fn renames_to_fold<'a>(renames: &'a mut RenameList) -> IdentRenamer<'a> {\n     IdentRenamer {\n         renames: renames,\n     }\n }\n \n-pub fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n+fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n     /* this discards information in the case of macro-defining macros */\n     Span {\n         lo: sp.lo,\n@@ -883,6 +918,10 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_block(&*block, self)\n     }\n \n+    fn fold_arm(&mut self, arm: &ast::Arm) -> ast::Arm {\n+        expand_arm(arm, self)\n+    }\n+\n     fn new_span(&mut self, span: Span) -> Span {\n         new_span(self.cx, span)\n     }\n@@ -1248,7 +1287,6 @@ mod test {\n \n     // FIXME #9384, match variable hygiene. Should expand into\n     // fn z() {match 8 {x_1 => {match 9 {x_2 | x_2 => x_2 + x_1}}}}\n-    #[ignore]\n     #[test] fn issue_9384(){\n         run_renaming_test(\n             &(\"macro_rules! bad_macro (($ex:expr) => ({match 9 {x | x => x + $ex}}))"}]}