{"sha": "41af2792333fe739abb899c6815005b08674ff21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxYWYyNzkyMzMzZmU3MzlhYmI4OTljNjgxNTAwNWIwODY3NGZmMjE=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-04-02T23:44:01Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-04-28T16:51:16Z"}, "message": "parser comments", "tree": {"sha": "11747b5e61776b16fff33dcac286612a44b47dc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11747b5e61776b16fff33dcac286612a44b47dc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41af2792333fe739abb899c6815005b08674ff21", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41af2792333fe739abb899c6815005b08674ff21", "html_url": "https://github.com/rust-lang/rust/commit/41af2792333fe739abb899c6815005b08674ff21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41af2792333fe739abb899c6815005b08674ff21/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2985f74ff345638af2391a74b60e8e949691e694", "url": "https://api.github.com/repos/rust-lang/rust/commits/2985f74ff345638af2391a74b60e8e949691e694", "html_url": "https://github.com/rust-lang/rust/commit/2985f74ff345638af2391a74b60e8e949691e694"}], "stats": {"total": 94, "additions": 82, "deletions": 12}, "files": [{"sha": "e04914c0f1e83f4d0aabe94ee2df7109fc133e87", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41af2792333fe739abb899c6815005b08674ff21/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41af2792333fe739abb899c6815005b08674ff21/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=41af2792333fe739abb899c6815005b08674ff21", "patch": "@@ -15,6 +15,13 @@\n use ast;\n use codemap;\n \n+// does this expression require a semicolon to be treated\n+// as a statement? The negation of this: 'can this expression\n+// be used as a statement without a semicolon' -- is used\n+// as an early-bail-out in the parser so that, for instance,\n+// 'if true {...} else {...}\n+//  |x| 5 '\n+// isn't parsed as (if true {...} else {...} | x) | 5\n pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n     match e.node {\n       ast::expr_if(*)\n@@ -40,6 +47,9 @@ pub fn expr_is_simple_block(e: @ast::expr) -> bool {\n     }\n }\n \n+// this statement requires a semicolon after it.\n+// note that in one case (stmt_semi), we've already\n+// seen the semicolon, and thus don't need another.\n pub fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n     return match stmt.node {\n         ast::stmt_decl(d, _) => {"}, {"sha": "4e29c3dcf183b4bd738e5bd74fe132d8211791ad", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41af2792333fe739abb899c6815005b08674ff21/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41af2792333fe739abb899c6815005b08674ff21/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=41af2792333fe739abb899c6815005b08674ff21", "patch": "@@ -309,6 +309,8 @@ pub struct lit {\n     pos: BytePos\n }\n \n+// it appears this function is called only from pprust... that's\n+// probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic:\n                                     @diagnostic::span_handler,\n                                     path: ~str,"}, {"sha": "60d6ce504fd9aa9b554cf422ac1d9a814d4eadfa", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41af2792333fe739abb899c6815005b08674ff21/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41af2792333fe739abb899c6815005b08674ff21/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=41af2792333fe739abb899c6815005b08674ff21", "patch": "@@ -286,6 +286,8 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n         }\n     } else if rdr.curr == '#' {\n         if nextch(rdr) == '!' {\n+            // I guess this is the only way to figure out if\n+            // we're at the beginning of the file...\n             let cmap = @CodeMap::new();\n             (*cmap).files.push(rdr.filemap);\n             let loc = cmap.lookup_char_pos_adj(rdr.last_pos);"}, {"sha": "30275436c065f6560113901118b7a7453ff799e5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 68, "deletions": 12, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/41af2792333fe739abb899c6815005b08674ff21/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41af2792333fe739abb899c6815005b08674ff21/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=41af2792333fe739abb899c6815005b08674ff21", "patch": "@@ -473,6 +473,7 @@ pub impl Parser {\n         (decl, lifetimes)\n     }\n \n+    // parse the methods in a trait declaration\n     fn parse_trait_methods(&self) -> ~[trait_method] {\n         do self.parse_unspanned_seq(\n             &token::LBRACE,\n@@ -558,6 +559,7 @@ pub impl Parser {\n     }\n \n     // parse [mut/const/imm] ID : TY\n+    // now used only by obsolete record syntax parser...\n     fn parse_ty_field(&self) -> ty_field {\n         let lo = self.span.lo;\n         let mutbl = self.parse_mutability();\n@@ -834,6 +836,7 @@ pub impl Parser {\n         either::Left(self.parse_arg_general(true))\n     }\n \n+    // parse an argument in a lambda header e.g. |arg, arg|\n     fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n         let m = self.parse_arg_mode();\n         let is_mutbl = self.eat_keyword(&~\"mut\");\n@@ -1269,6 +1272,7 @@ pub impl Parser {\n             }\n             hi = self.span.hi;\n         } else if self.eat_keyword(&~\"__log\") {\n+            // LOG expression\n             self.expect(&token::LPAREN);\n             let lvl = self.parse_expr();\n             self.expect(&token::COMMA);\n@@ -1277,19 +1281,22 @@ pub impl Parser {\n             hi = self.span.hi;\n             self.expect(&token::RPAREN);\n         } else if self.eat_keyword(&~\"return\") {\n+            // RETURN expression\n             if can_begin_expr(&*self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n                 ex = expr_ret(Some(e));\n             } else { ex = expr_ret(None); }\n         } else if self.eat_keyword(&~\"break\") {\n+            // BREAK expression\n             if is_ident(&*self.token) {\n                 ex = expr_break(Some(self.parse_ident()));\n             } else {\n                 ex = expr_break(None);\n             }\n             hi = self.span.hi;\n         } else if self.eat_keyword(&~\"copy\") {\n+            // COPY expression\n             let e = self.parse_expr();\n             ex = expr_copy(e);\n             hi = e.span.hi;\n@@ -1300,6 +1307,7 @@ pub impl Parser {\n \n             // `!`, as an operator, is prefix, so we know this isn't that\n             if *self.token == token::NOT {\n+                // MACRO INVOCATION expression\n                 self.bump();\n                 match *self.token {\n                     token::LPAREN | token::LBRACE => {}\n@@ -1354,6 +1362,7 @@ pub impl Parser {\n             hi = pth.span.hi;\n             ex = expr_path(pth);\n         } else {\n+            // other literal expression\n             let lit = self.parse_lit();\n             hi = lit.span.hi;\n             ex = expr_lit(@lit);\n@@ -1362,6 +1371,7 @@ pub impl Parser {\n         return self.mk_expr(lo, hi, ex);\n     }\n \n+    // parse a block or unsafe block\n     fn parse_block_expr(\n         &self,\n         lo: BytePos,\n@@ -1372,7 +1382,7 @@ pub impl Parser {\n         return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n     }\n \n-    // parse a.b or a(13) or just a\n+    // parse a.b or a(13) or a[4] or just a\n     fn parse_dot_or_call_expr(&self) -> @expr {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n@@ -1834,6 +1844,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse an 'if' expression ('if' token already eaten)\n     fn parse_if_expr(&self) -> @expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n@@ -1848,7 +1859,7 @@ pub impl Parser {\n         self.mk_expr(lo, hi, expr_if(cond, thn, els))\n     }\n \n-    // `|args| { ... }` like in `do` expressions\n+    // `|args| { ... }` or `{ ...}` like in `do` expressions\n     fn parse_lambda_block_expr(&self) -> @expr {\n         self.parse_lambda_expr_(\n             || {\n@@ -1882,6 +1893,9 @@ pub impl Parser {\n                                 || self.parse_expr())\n     }\n \n+    // parse something of the form |args| expr\n+    // this is used both in parsing a lambda expr\n+    // and in parsing a block expr as e.g. in for...\n     fn parse_lambda_expr_(\n         &self,\n         parse_decl: &fn() -> fn_decl,\n@@ -1912,6 +1926,9 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a 'for' or 'do'.\n+    // the 'for' and 'do' expressions parse as calls, but look like\n+    // function calls followed by a closure expression.\n     fn parse_sugary_call_expr(&self, keyword: ~str,\n                               sugar: CallSugar,\n                               ctor: &fn(v: @expr) -> expr_) -> @expr {\n@@ -2098,6 +2115,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse patterns, separated by '|' s\n     fn parse_pats(&self) -> ~[@pat] {\n         let mut pats = ~[];\n         loop {\n@@ -2152,6 +2170,7 @@ pub impl Parser {\n         (before, slice, after)\n     }\n \n+    // parse the fields of a struct-like pattern\n     fn parse_pat_fields(&self, refutable: bool) -> (~[ast::field_pat], bool) {\n         let mut fields = ~[];\n         let mut etc = false;\n@@ -2195,14 +2214,19 @@ pub impl Parser {\n         return (fields, etc);\n     }\n \n+    // parse a pattern. The 'refutable' argument\n+    // appears to control whether the binding_mode\n+    // 'bind_infer' or 'bind_by_copy' is used.\n     fn parse_pat(&self, refutable: bool) -> @pat {\n         maybe_whole!(self, nt_pat);\n \n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         let pat;\n         match *self.token {\n+            // parse _\n           token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n+            // parse @pat\n           token::AT => {\n             self.bump();\n             let sub = self.parse_pat(refutable);\n@@ -2226,6 +2250,7 @@ pub impl Parser {\n             };\n           }\n           token::TILDE => {\n+            // parse ~pat\n             self.bump();\n             let sub = self.parse_pat(refutable);\n             hi = sub.span.hi;\n@@ -2248,6 +2273,7 @@ pub impl Parser {\n             };\n           }\n           token::BINOP(token::AND) => {\n+              // parse &pat\n               let lo = self.span.lo;\n               self.bump();\n               let sub = self.parse_pat(refutable);\n@@ -2278,6 +2304,7 @@ pub impl Parser {\n             pat = pat_wild;\n           }\n           token::LPAREN => {\n+            // parse (pat,pat,pat,...) as tuple\n             self.bump();\n             if *self.token == token::RPAREN {\n                 hi = self.span.hi;\n@@ -2302,6 +2329,7 @@ pub impl Parser {\n             }\n           }\n           token::LBRACKET => {\n+            // parse [pat,pat,...] as vector pattern\n             self.bump();\n             let (before, slice, after) =\n                 self.parse_pat_vec_elements(refutable);\n@@ -2314,6 +2342,7 @@ pub impl Parser {\n                 || self.is_keyword(&~\"true\")\n                 || self.is_keyword(&~\"false\")\n             {\n+                // parse an expression pattern or exp .. exp\n                 let val = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                 if self.eat(&token::DOTDOT) {\n                     let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n@@ -2322,9 +2351,11 @@ pub impl Parser {\n                     pat = pat_lit(val);\n                 }\n             } else if self.eat_keyword(&~\"ref\") {\n+                // parse ref pat\n                 let mutbl = self.parse_mutability();\n                 pat = self.parse_pat_ident(refutable, bind_by_ref(mutbl));\n             } else if self.eat_keyword(&~\"copy\") {\n+                // parse copy pat\n                 pat = self.parse_pat_ident(refutable, bind_by_copy);\n             } else {\n                 // XXX---refutable match bindings should work same as let\n@@ -2344,12 +2375,15 @@ pub impl Parser {\n                     let name = self.parse_path_without_tps();\n                     let sub;\n                     if self.eat(&token::AT) {\n+                        // parse foo @ pat\n                         sub = Some(self.parse_pat(refutable));\n                     } else {\n+                        // or just foo\n                         sub = None;\n                     };\n                     pat = pat_ident(binding_mode, name, sub);\n                 } else {\n+                    // parse an enum pat\n                     let enum_path = self.parse_path_with_tps(true);\n                     match *self.token {\n                         token::LBRACE => {\n@@ -2404,13 +2438,16 @@ pub impl Parser {\n         @ast::pat { id: self.get_id(), node: pat, span: mk_sp(lo, hi) }\n     }\n \n+    // used by the copy foo and ref foo patterns to give a good\n+    // error message when parsing mistakes like ref foo(a,b)\n     fn parse_pat_ident(&self, refutable: bool,\n                        binding_mode: ast::binding_mode) -> ast::pat_ {\n         if !is_plain_ident(&*self.token) {\n             self.span_fatal(\n                 *self.last_span,\n                 ~\"expected identifier, found path\");\n         }\n+        // why a path here, and not just an identifier?\n         let name = self.parse_path_without_tps();\n         let sub = if self.eat(&token::AT) {\n             Some(self.parse_pat(refutable))\n@@ -2455,6 +2492,7 @@ pub impl Parser {\n         )\n     }\n \n+    // parse a \"let\" stmt\n     fn parse_let(&self) -> @decl {\n         let is_mutbl = self.eat_keyword(&~\"mut\");\n         let lo = self.span.lo;\n@@ -2485,6 +2523,7 @@ pub impl Parser {\n         })\n     }\n \n+    // parse a statement. may include decl\n     fn parse_stmt(&self, first_item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n@@ -2504,6 +2543,11 @@ pub impl Parser {\n         } else if is_ident(&*self.token)\n             && !self.is_any_keyword(&copy *self.token)\n             && self.look_ahead(1) == token::NOT {\n+            // parse a macro invocation. Looks like there's serious\n+            // overlap here; if this clause doesn't catch it (and it\n+            // won't, for brace-delimited macros) it will fall through\n+            // to the macro clause of parse_item_or_view_item. This\n+            // could use some cleanup, it appears to me.\n \n             check_expected_item(self, first_item_attrs);\n \n@@ -2569,6 +2613,7 @@ pub impl Parser {\n         }\n     }\n \n+    // is this expression a successfully-parsed statement?\n     fn expr_is_complete(&self, e: @expr) -> bool {\n         return *self.restriction == RESTRICT_STMT_EXPR &&\n             !classify::expr_requires_semi_to_be_stmt(e);\n@@ -2602,7 +2647,7 @@ pub impl Parser {\n \n         (inner, self.parse_block_tail_(lo, default_blk, next))\n     }\n-    \n+\n     // Precondition: already parsed the '{' or '#{'\n     // I guess that also means \"already parsed the 'impure'\" if\n     // necessary, and this should take a qualifier.\n@@ -3040,6 +3085,7 @@ pub impl Parser {\n         (spanned(lo, hi, self_ty), fn_decl)\n     }\n \n+    // parse the |arg, arg| header on a lambda\n     fn parse_fn_block_decl(&self) -> fn_decl {\n         let inputs_captures = {\n             if self.eat(&token::OROR) {\n@@ -3066,7 +3112,6 @@ pub impl Parser {\n         }\n     }\n \n-    // matches fn_header = IDENT generics\n     // parse the name and optional generic types of a function header.\n     fn parse_fn_header(&self) -> (ident, ast::Generics) {\n         let id = self.parse_ident();\n@@ -3095,6 +3140,7 @@ pub impl Parser {\n          Some(inner_attrs))\n     }\n \n+    // parse a method in a trait impl\n     fn parse_method(&self) -> @method {\n         let attrs = self.parse_outer_attributes();\n         let lo = self.span.lo;\n@@ -3383,6 +3429,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse visiility: PUB, PRIV, or nothing\n     fn parse_visibility(&self) -> visibility {\n         if self.eat_keyword(&~\"pub\") { public }\n         else if self.eat_keyword(&~\"priv\") { private }\n@@ -3414,9 +3461,8 @@ pub impl Parser {\n         let mut items: ~[@item] = starting_items;\n         let attrs_remaining_len = attrs_remaining.len();\n \n-        // looks like this code depends on the invariant that\n-        // outer attributes can't occur on view items (or macro\n-        // invocations?)\n+        // don't think this other loop is even necessary....\n+\n         let mut first = true;\n         while *self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n@@ -3533,6 +3579,7 @@ pub impl Parser {\n         self.mod_path_stack.pop();\n     }\n \n+    // read a module from a source file.\n     fn eval_src_mod(&self, id: ast::ident,\n                     outer_attrs: ~[ast::attribute],\n                     id_sp: span) -> (ast::item_, ~[ast::attribute]) {\n@@ -3590,6 +3637,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&self,  attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n         let vis = self.parse_visibility();\n@@ -3606,6 +3654,7 @@ pub impl Parser {\n                              vis: vis }\n     }\n \n+    // parse a const definition from a foreign module\n     fn parse_item_foreign_const(&self, vis: ast::visibility,\n                                 attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n@@ -3630,6 +3679,7 @@ pub impl Parser {\n                              vis: vis }\n     }\n \n+    // parse safe/unsafe and fn\n     fn parse_fn_purity(&self) -> purity {\n         if self.eat_keyword(&~\"fn\") { impure_fn }\n         else if self.eat_keyword(&~\"pure\") {\n@@ -3644,12 +3694,13 @@ pub impl Parser {\n         else { self.unexpected(); }\n     }\n \n-    // how is this different from parse_foreign_items\n+\n+    // at this point, this is essentially a wrapper for\n+    // parse_foreign_items.\n     fn parse_foreign_mod_items(&self, sort: ast::foreign_mod_sort,\n                                abis: AbiSet,\n                                first_item_attrs: ~[attribute])\n                             -> foreign_mod {\n-        // Shouldn't be any view items since we've already parsed an item attr\n         let ParsedItemsAndViewItems {\n             attrs_remaining: attrs_remaining,\n             view_items: view_items,\n@@ -3666,7 +3717,7 @@ pub impl Parser {\n         }\n     }\n \n-    // parse extern mod foo { ... } or extern { ... }\n+    // parse extern foo; or extern mod foo { ... } or extern { ... }\n     fn parse_item_foreign_mod(&self,\n                               lo: BytePos,\n                               opt_abis: Option<AbiSet>,\n@@ -3755,6 +3806,8 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a structure-like enum variant definition\n+    // this should probably be renamed or refactored...\n     fn parse_struct_def(&self) -> @struct_def {\n         let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n         let mut fields: ~[@struct_field] = ~[];\n@@ -3798,6 +3851,7 @@ pub impl Parser {\n         };\n     }\n \n+    // parse the part of an \"enum\" decl following the '{'\n     fn parse_enum_def(&self, _generics: &ast::Generics) -> enum_def {\n         let mut variants = ~[];\n         let mut all_nullary = true, have_disr = false;\n@@ -3858,6 +3912,7 @@ pub impl Parser {\n         ast::enum_def { variants: variants }\n     }\n \n+    // parse an \"enum\" declaration\n     fn parse_item_enum(&self) -> item_info {\n         let id = self.parse_ident();\n         self.parse_region_param();\n@@ -4204,6 +4259,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse, e.g., \"use a::b::{z,y}\"\n     fn parse_use(&self) -> view_item_ {\n         return view_item_use(self.parse_view_paths());\n     }\n@@ -4429,7 +4485,6 @@ pub impl Parser {\n         }\n     }\n \n-    // splitting parse_items_and_view_items into two functions...\n     // Parses a sequence of foreign items. Stops when it finds program\n     // text that can't be parsed as an item\n     fn parse_foreign_items(&self, first_item_attrs: ~[attribute],\n@@ -4466,7 +4521,8 @@ pub impl Parser {\n         }\n     }\n \n-    // Parses a source module as a crate\n+    // Parses a source module as a crate. This is the main\n+    // entry point for the parser.\n     fn parse_crate_mod(&self) -> @crate {\n         let lo = self.span.lo;\n         // parse the crate's inner attrs, maybe (oops) one"}]}