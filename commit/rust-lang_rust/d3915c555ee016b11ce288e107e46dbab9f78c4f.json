{"sha": "d3915c555ee016b11ce288e107e46dbab9f78c4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzOTE1YzU1NWVlMDE2YjExY2UyODhlMTA3ZTQ2ZGJhYjlmNzhjNGY=", "commit": {"author": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-01-05T16:08:51Z"}, "committer": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-01-05T16:08:51Z"}, "message": "Fix spacing in docs for `core::pin` by combining consequent code blocks using HTML-syntax.", "tree": {"sha": "0e9f4df8f95383eda3a7c41a78c3fa988d0e82e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e9f4df8f95383eda3a7c41a78c3fa988d0e82e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3915c555ee016b11ce288e107e46dbab9f78c4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3915c555ee016b11ce288e107e46dbab9f78c4f", "html_url": "https://github.com/rust-lang/rust/commit/d3915c555ee016b11ce288e107e46dbab9f78c4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3915c555ee016b11ce288e107e46dbab9f78c4f/comments", "author": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68ec33261183ffc21de96d6f825b02373e22e835", "url": "https://api.github.com/repos/rust-lang/rust/commits/68ec33261183ffc21de96d6f825b02373e22e835", "html_url": "https://github.com/rust-lang/rust/commit/68ec33261183ffc21de96d6f825b02373e22e835"}], "stats": {"total": 46, "additions": 23, "deletions": 23}, "files": [{"sha": "8d73bf56dcb0d4170e3ed14aba49bd1744b7e3d5", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d3915c555ee016b11ce288e107e46dbab9f78c4f/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3915c555ee016b11ce288e107e46dbab9f78c4f/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=d3915c555ee016b11ce288e107e46dbab9f78c4f", "patch": "@@ -16,9 +16,9 @@\n //! By default, all types in Rust are movable. Rust allows passing all types by-value,\n //! and common smart-pointer types such as [`Box<T>`] and `&mut T` allow replacing and\n //! moving the values they contain: you can move out of a [`Box<T>`], or you can use [`mem::swap`].\n-//! [`Pin<P>`] wraps a pointer type `P`, so [`Pin`]`<`[`Box`]`<T>>` functions much like a regular\n-//! [`Box<T>`]: when a [`Pin`]`<`[`Box`]`<T>>` gets dropped, so do its contents, and the memory gets\n-//! deallocated. Similarly, [`Pin`]`<&mut T>` is a lot like `&mut T`. However, [`Pin<P>`] does\n+//! [`Pin<P>`] wraps a pointer type `P`, so <code>[Pin]<[Box]\\<T>></code> functions much like a regular\n+//! [`Box<T>`]: when a <code>[Pin]<[Box]\\<T>></code> gets dropped, so do its contents, and the memory gets\n+//! deallocated. Similarly, <code>[Pin]<&mut T></code> is a lot like `&mut T`. However, [`Pin<P>`] does\n //! not let clients actually obtain a [`Box<T>`] or `&mut T` to pinned data, which implies that you\n //! cannot use operations such as [`mem::swap`]:\n //!\n@@ -40,8 +40,8 @@\n //!\n //! [`Pin<P>`] can be used to wrap any pointer type `P`, and as such it interacts with\n //! [`Deref`] and [`DerefMut`]. A [`Pin<P>`] where `P: Deref` should be considered\n-//! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a [`Pin`]`<`[`Box`]`<T>>` is\n-//! an owned pointer to a pinned `T`, and a [`Pin`]`<`[`Rc`]`<T>>` is a reference-counted\n+//! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a <code>[Pin]<[Box]\\<T>></code> is\n+//! an owned pointer to a pinned `T`, and a <code>[Pin]<[Rc]\\<T>></code> is a reference-counted\n //! pointer to a pinned `T`.\n //! For correctness, [`Pin<P>`] relies on the implementations of [`Deref`] and\n //! [`DerefMut`] not to move out of their `self` parameter, and only ever to\n@@ -54,12 +54,12 @@\n //! [`bool`], [`i32`], and references) as well as types consisting solely of these\n //! types. Types that do not care about pinning implement the [`Unpin`]\n //! auto-trait, which cancels the effect of [`Pin<P>`]. For `T: Unpin`,\n-//! [`Pin`]`<`[`Box`]`<T>>` and [`Box<T>`] function identically, as do [`Pin`]`<&mut T>` and\n+//! <code>[Pin]<[Box]\\<T>></code> and [`Box<T>`] function identically, as do <code>[Pin]<&mut T></code> and\n //! `&mut T`.\n //!\n //! Note that pinning and [`Unpin`] only affect the pointed-to type `P::Target`, not the pointer\n //! type `P` itself that got wrapped in [`Pin<P>`]. For example, whether or not [`Box<T>`] is\n-//! [`Unpin`] has no effect on the behavior of [`Pin`]`<`[`Box`]`<T>>` (here, `T` is the\n+//! [`Unpin`] has no effect on the behavior of <code>[Pin]<[Box]\\<T>></code> (here, `T` is the\n //! pointed-to type).\n //!\n //! # Example: self-referential struct\n@@ -158,7 +158,7 @@\n //!\n //! Notice that this guarantee does *not* mean that memory does not leak! It is still\n //! completely okay not ever to call [`drop`] on a pinned element (e.g., you can still\n-//! call [`mem::forget`] on a [`Pin`]`<`[`Box`]`<T>>`). In the example of the doubly-linked\n+//! call [`mem::forget`] on a <code>[Pin]<[Box]\\<T>></code>). In the example of the doubly-linked\n //! list, that element would just stay in the list. However you may not free or reuse the storage\n //! *without calling [`drop`]*.\n //!\n@@ -172,9 +172,9 @@\n //! This can never cause a problem in safe code because implementing a type that\n //! relies on pinning requires unsafe code, but be aware that deciding to make\n //! use of pinning in your type (for example by implementing some operation on\n-//! [`Pin`]`<&Self>` or [`Pin`]`<&mut Self>`) has consequences for your [`Drop`]\n+//! <code>[Pin]<&Self></code> or <code>[Pin]<&mut Self></code>) has consequences for your [`Drop`]\n //! implementation as well: if an element of your type could have been pinned,\n-//! you must treat [`Drop`] as implicitly taking [`Pin`]`<&mut Self>`.\n+//! you must treat [`Drop`] as implicitly taking <code>[Pin]<&mut Self></code>.\n //!\n //! For example, you could implement `Drop` as follows:\n //!\n@@ -204,18 +204,18 @@\n //! # Projections and Structural Pinning\n //!\n //! When working with pinned structs, the question arises how one can access the\n-//! fields of that struct in a method that takes just [`Pin`]`<&mut Struct>`.\n+//! fields of that struct in a method that takes just <code>[Pin]<&mut Struct></code>.\n //! The usual approach is to write helper methods (so called *projections*)\n-//! that turn [`Pin`]`<&mut Struct>` into a reference to the field, but what\n-//! type should that reference have? Is it [`Pin`]`<&mut Field>` or `&mut Field`?\n+//! that turn <code>[Pin]<&mut Struct></code> into a reference to the field, but what\n+//! type should that reference have? Is it <code>[Pin]<&mut Field></code> or `&mut Field`?\n //! The same question arises with the fields of an `enum`, and also when considering\n //! container/wrapper types such as [`Vec<T>`], [`Box<T>`], or [`RefCell<T>`].\n //! (This question applies to both mutable and shared references, we just\n //! use the more common case of mutable references here for illustration.)\n //!\n //! It turns out that it is actually up to the author of the data structure\n //! to decide whether the pinned projection for a particular field turns\n-//! [`Pin`]`<&mut Struct>` into [`Pin`]`<&mut Field>` or `&mut Field`. There are some\n+//! <code>[Pin]<&mut Struct></code> into <code>[Pin]<&mut Field></code> or `&mut Field`. There are some\n //! constraints though, and the most important constraint is *consistency*:\n //! every field can be *either* projected to a pinned reference, *or* have\n //! pinning removed as part of the projection. If both are done for the same field,\n@@ -230,12 +230,12 @@\n //! ## Pinning *is not* structural for `field`\n //!\n //! It may seem counter-intuitive that the field of a pinned struct might not be pinned,\n-//! but that is actually the easiest choice: if a [`Pin`]`<&mut Field>` is never created,\n+//! but that is actually the easiest choice: if a <code>[Pin]<&mut Field></code> is never created,\n //! nothing can go wrong! So, if you decide that some field does not have structural pinning,\n //! all you have to ensure is that you never create a pinned reference to that field.\n //!\n //! Fields without structural pinning may have a projection method that turns\n-//! [`Pin`]`<&mut Struct>` into `&mut Field`:\n+//! <code>[Pin]<&mut Struct></code> into `&mut Field`:\n //!\n //! ```rust,no_run\n //! # use std::pin::Pin;\n@@ -251,14 +251,14 @@\n //!\n //! You may also `impl Unpin for Struct` *even if* the type of `field`\n //! is not [`Unpin`]. What that type thinks about pinning is not relevant\n-//! when no [`Pin`]`<&mut Field>` is ever created.\n+//! when no <code>[Pin]<&mut Field></code> is ever created.\n //!\n //! ## Pinning *is* structural for `field`\n //!\n //! The other option is to decide that pinning is \"structural\" for `field`,\n //! meaning that if the struct is pinned then so is the field.\n //!\n-//! This allows writing a projection that creates a [`Pin`]`<&mut Field>`, thus\n+//! This allows writing a projection that creates a <code>[Pin]<&mut Field></code>, thus\n //! witnessing that the field is pinned:\n //!\n //! ```rust,no_run\n@@ -336,17 +336,17 @@\n //! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n //! It makes sense to do this for pointer types, because moving the `Box<T>`\n //! does not actually move the `T`: the [`Box<T>`] can be freely movable (aka `Unpin`) even if\n-//! the `T` is not. In fact, even [`Pin`]`<`[`Box`]`<T>>` and [`Pin`]`<&mut T>` are always\n+//! the `T` is not. In fact, even <code>[Pin]<[Box]\\<T>></code> and <code>[Pin]<&mut T></code> are always\n //! [`Unpin`] themselves, for the same reason: their contents (the `T`) are pinned, but the\n //! pointers themselves can be moved without moving the pinned data. For both [`Box<T>`] and\n-//! [`Pin`]`<`[`Box`]`<T>>`, whether the content is pinned is entirely independent of whether the\n+//! <code>[Pin]<[Box]\\<T>></code>, whether the content is pinned is entirely independent of whether the\n //! pointer is pinned, meaning pinning is *not* structural.\n //!\n //! When implementing a [`Future`] combinator, you will usually need structural pinning\n //! for the nested futures, as you need to get pinned references to them to call [`poll`].\n //! But if your combinator contains any other data that does not need to be pinned,\n //! you can make those fields not structural and hence freely access them with a\n-//! mutable reference even when you just have [`Pin`]`<&mut Self>` (such as in your own\n+//! mutable reference even when you just have <code>[Pin]<&mut Self></code> (such as in your own\n //! [`poll`] implementation).\n //!\n //! [`Deref`]: crate::ops::Deref\n@@ -356,10 +356,10 @@\n //! [`Box<T>`]: ../../std/boxed/struct.Box.html\n //! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n //! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len\n-//! [`Box`]: ../../std/boxed/struct.Box.html\n+//! [Box]: ../../std/boxed/struct.Box.html\n //! [Vec::pop]: ../../std/vec/struct.Vec.html#method.pop\n //! [Vec::push]: ../../std/vec/struct.Vec.html#method.push\n-//! [`Rc`]: ../../std/rc/struct.Rc.html\n+//! [Rc]: ../../std/rc/struct.Rc.html\n //! [`RefCell<T>`]: crate::cell::RefCell\n //! [`drop`]: Drop::drop\n //! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html"}]}