{"sha": "5a8a30f45bed02a33b2e0e11f0d07cda2f569533", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhOGEzMGY0NWJlZDAyYTMzYjJlMGUxMWYwZDA3Y2RhMmY1Njk1MzM=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-06-30T22:08:22Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-07-04T02:45:38Z"}, "message": "Added functionality to Base64 package\n\nThe Base64 package previously had extremely basic functionality. It only\nsuported the standard encoding character set, didn't support line breaks\nand always padded output. This commit makes it significantly more\npowerful.\n\nThe FromBase64 impl now supports all of the standard variants of Base64.\nIt ignores newlines,interprets '-' and '_' as well as '+' and '/' and\ndoesn't require padding. It isn't incredibly pedantic and will\nsuccessfully parse strings that are not strictly valid, but I don't\nthink the extra complexity required to make it accept _only_ valid\nstrings is worth it.\n\nThe ToBase64 trait has been modified such that to_base64 now takes a\nbase64::Config struct which contains the output format configuration.\nThis currently includes the selection of character set (standard or\nurl safe), whether or not to pad and an optional line break width. The\npackage comes with three static Config structs for the RFC 4648\nstandard, RFC 4648 url safe and RFC 2045 MIME formats.\n\nThe other option for configuring ToBase64 output would be to have one\nmethod with the configuration flags passed and other traits with default\nimpls for the common cases, but I think that's a little messier.", "tree": {"sha": "1a5a9e4cccd0da80b0dc75a050c87b0db275acdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a5a9e4cccd0da80b0dc75a050c87b0db275acdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a8a30f45bed02a33b2e0e11f0d07cda2f569533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a8a30f45bed02a33b2e0e11f0d07cda2f569533", "html_url": "https://github.com/rust-lang/rust/commit/5a8a30f45bed02a33b2e0e11f0d07cda2f569533", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a8a30f45bed02a33b2e0e11f0d07cda2f569533/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c0a1621b550936e862585667d8a58f7a2ab72c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c0a1621b550936e862585667d8a58f7a2ab72c5", "html_url": "https://github.com/rust-lang/rust/commit/3c0a1621b550936e862585667d8a58f7a2ab72c5"}], "stats": {"total": 331, "additions": 210, "deletions": 121}, "files": [{"sha": "8a14ed8cc98d15f90ad25af32bf8bd565a7b41c0", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 210, "deletions": 121, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/5a8a30f45bed02a33b2e0e11f0d07cda2f569533/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8a30f45bed02a33b2e0e11f0d07cda2f569533/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=5a8a30f45bed02a33b2e0e11f0d07cda2f569533", "patch": "@@ -10,81 +10,134 @@\n \n //! Base64 binary-to-text encoding\n \n+/// Contains configuration parameters for to_base64\n+pub struct Config {\n+    /// True to use the url-safe encoding format ('-' and '_'), false to use\n+    /// the standard encoding format ('+' and '/')\n+    pub url_safe: bool,\n+    /// True to pad output with '=' characters\n+    pub pad: bool,\n+    /// Some(len) to wrap lines at len, None to disable line wrapping\n+    pub line_length: Option<uint>\n+}\n \n-use std::vec;\n+/// Configuration for RFC 4648 standard base64 encoding\n+pub static standard: Config =\n+    Config {url_safe: false, pad: true, line_length: None};\n \n-/// A trait for converting a value to base64 encoding.\n-pub trait ToBase64 {\n-    /// Converts the value of `self` to a base64 value, returning the owned\n-    /// string\n-    fn to_base64(&self) -> ~str;\n-}\n+/// Configuration for RFC 4648 base64url encoding\n+pub static url_safe: Config =\n+    Config {url_safe: true, pad: false, line_length: None};\n+\n+/// Configuration for RFC 2045 MIME base64 encoding\n+pub static mime: Config =\n+    Config {url_safe: false, pad: true, line_length: Some(76)};\n \n-static CHARS: [char, ..64] = [\n+static STANDARD_CHARS: [char, ..64] = [\n     'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n     'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n     'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n     'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n     '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n ];\n \n+static URLSAFE_CHARS: [char, ..64] = [\n+    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n+];\n+\n+/// A trait for converting a value to base64 encoding.\n+pub trait ToBase64 {\n+    /// Converts the value of `self` to a base64 value following the specified\n+    /// format configuration, returning the owned string.\n+    fn to_base64(&self, config: Config) -> ~str;\n+}\n+\n impl<'self> ToBase64 for &'self [u8] {\n     /**\n      * Turn a vector of `u8` bytes into a base64 string.\n      *\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::base64::ToBase64;\n+     * use std::base64::{ToBase64, standard};\n      *\n      * fn main () {\n-     *     let str = [52,32].to_base64();\n+     *     let str = [52,32].to_base64(standard);\n      *     println(fmt!(\"%s\", str));\n      * }\n      * ~~~\n      */\n-    fn to_base64(&self) -> ~str {\n+    fn to_base64(&self, config: Config) -> ~str {\n+        let chars = match config.url_safe {\n+            true => URLSAFE_CHARS,\n+            false => STANDARD_CHARS\n+        };\n+\n         let mut s = ~\"\";\n+        let mut i = 0;\n+        let mut cur_length = 0;\n         let len = self.len();\n-        s.reserve(((len + 3u) / 4u) * 3u);\n+        while i < len - (len % 3) {\n+            match config.line_length {\n+                Some(line_length) =>\n+                    if cur_length >= line_length {\n+                        s.push_str(\"\\r\\n\");\n+                        cur_length = 0;\n+                    },\n+                None => ()\n+            }\n \n-        let mut i = 0u;\n-\n-        while i < len - (len % 3u) {\n-            let n = (self[i] as uint) << 16u |\n-                    (self[i + 1u] as uint) << 8u |\n-                    (self[i + 2u] as uint);\n+            let n = (self[i] as u32) << 16 |\n+                    (self[i + 1] as u32) << 8 |\n+                    (self[i + 2] as u32);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n-            s.push_char(CHARS[(n >> 18u) & 63u]);\n-            s.push_char(CHARS[(n >> 12u) & 63u]);\n-            s.push_char(CHARS[(n >> 6u) & 63u]);\n-            s.push_char(CHARS[n & 63u]);\n+            s.push_char(chars[(n >> 18) & 63]);\n+            s.push_char(chars[(n >> 12) & 63]);\n+            s.push_char(chars[(n >> 6 ) & 63]);\n+            s.push_char(chars[n & 63]);\n+\n+            cur_length += 4;\n+            i += 3;\n+        }\n \n-            i += 3u;\n+        if len % 3 != 0 {\n+            match config.line_length {\n+                Some(line_length) =>\n+                    if cur_length >= line_length {\n+                        s.push_str(\"\\r\\n\");\n+                    },\n+                None => ()\n+            }\n         }\n \n         // Heh, would be cool if we knew this was exhaustive\n         // (the dream of bounded integer types)\n         match len % 3 {\n-          0 => (),\n-          1 => {\n-            let n = (self[i] as uint) << 16u;\n-            s.push_char(CHARS[(n >> 18u) & 63u]);\n-            s.push_char(CHARS[(n >> 12u) & 63u]);\n-            s.push_char('=');\n-            s.push_char('=');\n-          }\n-          2 => {\n-            let n = (self[i] as uint) << 16u |\n-                (self[i + 1u] as uint) << 8u;\n-            s.push_char(CHARS[(n >> 18u) & 63u]);\n-            s.push_char(CHARS[(n >> 12u) & 63u]);\n-            s.push_char(CHARS[(n >> 6u) & 63u]);\n-            s.push_char('=');\n-          }\n-          _ => fail!(\"Algebra is broken, please alert the math police\")\n+            0 => (),\n+            1 => {\n+                let n = (self[i] as u32) << 16;\n+                s.push_char(chars[(n >> 18) & 63]);\n+                s.push_char(chars[(n >> 12) & 63]);\n+                if config.pad {\n+                    s.push_str(\"==\");\n+                }\n+            }\n+            2 => {\n+                let n = (self[i] as u32) << 16 |\n+                    (self[i + 1u] as u32) << 8;\n+                s.push_char(chars[(n >> 18) & 63]);\n+                s.push_char(chars[(n >> 12) & 63]);\n+                s.push_char(chars[(n >> 6 ) & 63]);\n+                if config.pad {\n+                    s.push_char('=');\n+                }\n+            }\n+            _ => fail!(\"Algebra is broken, please alert the math police\")\n         }\n         s\n     }\n@@ -98,23 +151,24 @@ impl<'self> ToBase64 for &'self str {\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::base64::ToBase64;\n+     * use std::base64::{ToBase64, standard};\n      *\n      * fn main () {\n-     *     let str = \"Hello, World\".to_base64();\n+     *     let str = \"Hello, World\".to_base64(standard);\n      *     println(fmt!(\"%s\",str));\n      * }\n      * ~~~\n      *\n      */\n-    fn to_base64(&self) -> ~str {\n-        self.as_bytes().to_base64()\n+    fn to_base64(&self, config: Config) -> ~str {\n+        self.as_bytes().to_base64(config)\n     }\n }\n \n-#[allow(missing_doc)]\n+/// A trait for converting from base64 encoded values.\n pub trait FromBase64 {\n+    /// Converts the value of `self`, interpreted as base64 encoded data, into\n+    /// an owned vector of bytes, returning the vector.\n     fn from_base64(&self) -> ~[u8];\n }\n \n@@ -126,69 +180,63 @@ impl<'self> FromBase64 for &'self [u8] {\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::base64::ToBase64;\n-     * use extra::base64::FromBase64;\n+     * use std::base64::{ToBase64, FromBase64, standard};\n      *\n      * fn main () {\n-     *     let str = [52,32].to_base64();\n+     *     let str = [52,32].to_base64(standard);\n      *     println(fmt!(\"%s\", str));\n      *     let bytes = str.from_base64();\n      *     println(fmt!(\"%?\",bytes));\n      * }\n      * ~~~\n      */\n     fn from_base64(&self) -> ~[u8] {\n-        if self.len() % 4u != 0u { fail!(\"invalid base64 length\"); }\n+        let mut r = ~[];\n+        let mut buf: u32 = 0;\n+        let mut modulus = 0;\n \n-        let len = self.len();\n-        let mut padding = 0u;\n+        let mut it = self.iter();\n+        for it.advance |&byte| {\n+            let ch = byte as char;\n+            let val = byte as u32;\n \n-        if len != 0u {\n-            if self[len - 1u] == '=' as u8 { padding += 1u; }\n-            if self[len - 2u] == '=' as u8 { padding += 1u; }\n-        }\n+            match ch {\n+                'A'..'Z'  => buf |= val - 0x41,\n+                'a'..'z'  => buf |= val - 0x47,\n+                '0'..'9'  => buf |= val + 0x04,\n+                '+'|'-'   => buf |= 0x3E,\n+                '/'|'_'   => buf |= 0x3F,\n+                '\\r'|'\\n' => loop,\n+                '='       => break,\n+                _         => fail!(\"Invalid Base64 character\")\n+            }\n \n-        let mut r = vec::with_capacity((len / 4u) * 3u - padding);\n-\n-        let mut i = 0u;\n-        while i < len {\n-            let mut n = 0u;\n-\n-            for 4u.times {\n-                let ch = self[i] as char;\n-                n <<= 6u;\n-\n-                match ch {\n-                    'A'..'Z' => n |= (ch as uint) - 0x41,\n-                    'a'..'z' => n |= (ch as uint) - 0x47,\n-                    '0'..'9' => n |= (ch as uint) + 0x04,\n-                    '+'      => n |= 0x3E,\n-                    '/'      => n |= 0x3F,\n-                    '='      => {\n-                        match len - i {\n-                            1u => {\n-                                r.push(((n >> 16u) & 0xFFu) as u8);\n-                                r.push(((n >> 8u ) & 0xFFu) as u8);\n-                                return copy r;\n-                            }\n-                            2u => {\n-                                r.push(((n >> 10u) & 0xFFu) as u8);\n-                                return copy r;\n-                            }\n-                            _ => fail!(\"invalid base64 padding\")\n-                        }\n-                    }\n-                    _ => fail!(\"invalid base64 character\")\n-                }\n+            buf <<= 6;\n+            modulus += 1;\n+            if modulus == 4 {\n+                modulus = 0;\n+                r.push((buf >> 22) as u8);\n+                r.push((buf >> 14) as u8);\n+                r.push((buf >> 6 ) as u8);\n+            }\n+        }\n \n-                i += 1u;\n-            };\n+        if !it.all(|&byte| {byte as char == '='}) {\n+            fail!(\"Invalid Base64 character\");\n+        }\n \n-            r.push(((n >> 16u) & 0xFFu) as u8);\n-            r.push(((n >> 8u ) & 0xFFu) as u8);\n-            r.push(((n       ) & 0xFFu) as u8);\n+        match modulus {\n+            2 => {\n+                r.push((buf >> 10) as u8);\n+            }\n+            3 => {\n+                r.push((buf >> 16) as u8);\n+                r.push((buf >> 8 ) as u8);\n+            }\n+            0 => (),\n+            _ => fail!(\"Invalid Base64 length\")\n         }\n+\n         r\n     }\n }\n@@ -199,20 +247,19 @@ impl<'self> FromBase64 for &'self str {\n      * to the byte values it encodes.\n      *\n      * You can use the `from_bytes` function in `std::str`\n-     * to turn a `[u8]` into a string with characters corresponding to those values.\n+     * to turn a `[u8]` into a string with characters corresponding to those\n+     * values.\n      *\n      * # Example\n      *\n      * This converts a string literal to base64 and back.\n      *\n      * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::base64::ToBase64;\n-     * use extra::base64::FromBase64;\n+     * use std::base64::{ToBase64, FromBase64, standard};\n      * use std::str;\n      *\n      * fn main () {\n-     *     let hello_str = \"Hello, World\".to_base64();\n+     *     let hello_str = \"Hello, World\".to_base64(standard);\n      *     println(fmt!(\"%s\",hello_str));\n      *     let bytes = hello_str.from_base64();\n      *     println(fmt!(\"%?\",bytes));\n@@ -226,27 +273,69 @@ impl<'self> FromBase64 for &'self str {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    #[test]\n-    fn test_to_base64() {\n-        assert_eq!(\"\".to_base64(), ~\"\");\n-        assert_eq!(\"f\".to_base64(), ~\"Zg==\");\n-        assert_eq!(\"fo\".to_base64(), ~\"Zm8=\");\n-        assert_eq!(\"foo\".to_base64(), ~\"Zm9v\");\n-        assert_eq!(\"foob\".to_base64(), ~\"Zm9vYg==\");\n-        assert_eq!(\"fooba\".to_base64(), ~\"Zm9vYmE=\");\n-        assert_eq!(\"foobar\".to_base64(), ~\"Zm9vYmFy\");\n-    }\n+#[test]\n+fn test_to_base64_basic() {\n+    assert_eq!(\"\".to_base64(standard), ~\"\");\n+    assert_eq!(\"f\".to_base64(standard), ~\"Zg==\");\n+    assert_eq!(\"fo\".to_base64(standard), ~\"Zm8=\");\n+    assert_eq!(\"foo\".to_base64(standard), ~\"Zm9v\");\n+    assert_eq!(\"foob\".to_base64(standard), ~\"Zm9vYg==\");\n+    assert_eq!(\"fooba\".to_base64(standard), ~\"Zm9vYmE=\");\n+    assert_eq!(\"foobar\".to_base64(standard), ~\"Zm9vYmFy\");\n+}\n+\n+#[test]\n+fn test_to_base64_line_break() {\n+    assert!(![0u8, 1000].to_base64(Config {line_length: None, ..standard})\n+        .contains(\"\\r\\n\"));\n+    assert_eq!(\"foobar\".to_base64(Config {line_length: Some(4), ..standard}),\n+        ~\"Zm9v\\r\\nYmFy\");\n+}\n+\n+#[test]\n+fn test_to_base64_padding() {\n+    assert_eq!(\"f\".to_base64(Config {pad: false, ..standard}), ~\"Zg\");\n+    assert_eq!(\"fo\".to_base64(Config {pad: false, ..standard}), ~\"Zm8\");\n+}\n+\n+#[test]\n+fn test_to_base64_url_safe() {\n+    assert_eq!([251, 255].to_base64(url_safe), ~\"-_8\");\n+    assert_eq!([251, 255].to_base64(standard), ~\"+/8=\");\n+}\n+\n+#[test]\n+fn test_from_base64_basic() {\n+    assert_eq!(\"\".from_base64(), \"\".as_bytes().to_owned());\n+    assert_eq!(\"Zg==\".from_base64(), \"f\".as_bytes().to_owned());\n+    assert_eq!(\"Zm8=\".from_base64(), \"fo\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9v\".from_base64(), \"foo\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9vYg==\".from_base64(), \"foob\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9vYmE=\".from_base64(), \"fooba\".as_bytes().to_owned());\n+    assert_eq!(\"Zm9vYmFy\".from_base64(), \"foobar\".as_bytes().to_owned());\n+}\n+\n+#[test]\n+fn test_from_base64_newlines() {\n+    assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64(), \"foobar\".as_bytes().to_owned());\n+}\n+\n+#[test]\n+fn test_from_base64_urlsafe() {\n+    assert_eq!(\"-_8\".from_base64(), \"+/8=\".from_base64());\n+}\n+\n+#[test]\n+fn test_base64_random() {\n+    use std::rand::random;\n+    use std::vec;\n \n-    #[test]\n-    fn test_from_base64() {\n-        assert_eq!(\"\".from_base64(), \"\".as_bytes().to_owned());\n-        assert_eq!(\"Zg==\".from_base64(), \"f\".as_bytes().to_owned());\n-        assert_eq!(\"Zm8=\".from_base64(), \"fo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9v\".from_base64(), \"foo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYg==\".from_base64(), \"foob\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmE=\".from_base64(), \"fooba\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmFy\".from_base64(), \"foobar\".as_bytes().to_owned());\n+    for 1000.times {\n+        let v: ~[u8] = do vec::build |push| {\n+            for 100.times {\n+                push(random());\n+            }\n+        };\n+        assert_eq!(v.to_base64(standard).from_base64(), v);\n     }\n }"}]}