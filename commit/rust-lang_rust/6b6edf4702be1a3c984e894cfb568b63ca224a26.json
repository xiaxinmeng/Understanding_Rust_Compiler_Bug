{"sha": "6b6edf4702be1a3c984e894cfb568b63ca224a26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiNmVkZjQ3MDJiZTFhM2M5ODRlODk0Y2ZiNTY4YjYzY2EyMjRhMjY=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-21T12:56:23Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-07-03T07:17:47Z"}, "message": "Improve code reuse between trans/_match.rs and check_match.rs\n\nThe specialization logic for patterns is really the same in both\nexhaustiveness/reachability checking and codegen.", "tree": {"sha": "56c6065fdf81d3f9ceb49effcf59b383a3c86d6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56c6065fdf81d3f9ceb49effcf59b383a3c86d6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b6edf4702be1a3c984e894cfb568b63ca224a26", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b6edf4702be1a3c984e894cfb568b63ca224a26", "html_url": "https://github.com/rust-lang/rust/commit/6b6edf4702be1a3c984e894cfb568b63ca224a26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b6edf4702be1a3c984e894cfb568b63ca224a26/comments", "author": null, "committer": null, "parents": [{"sha": "e6c54a12c4d209de9f438b4722657ca381f969a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c54a12c4d209de9f438b4722657ca381f969a2", "html_url": "https://github.com/rust-lang/rust/commit/e6c54a12c4d209de9f438b4722657ca381f969a2"}], "stats": {"total": 618, "additions": 111, "deletions": 507}, "files": [{"sha": "11e635a5af69737062021686b9a4234b055dbb9f", "filename": "src/doc/rust.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b6edf4702be1a3c984e894cfb568b63ca224a26/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b6edf4702be1a3c984e894cfb568b63ca224a26/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=6b6edf4702be1a3c984e894cfb568b63ca224a26", "patch": "@@ -2155,8 +2155,6 @@ These are functions:\n \n * `str_eq`\n   : Compare two strings (`&str`) for equality.\n-* `uniq_str_eq`\n-  : Compare two owned strings (`String`) for equality.\n * `strdup_uniq`\n   : Return a new unique string\n     containing a copy of the contents of a unique string."}, {"sha": "cde83693f0b4174bd5da08b17ef876db97359739", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b6edf4702be1a3c984e894cfb568b63ca224a26/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b6edf4702be1a3c984e894cfb568b63ca224a26/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=6b6edf4702be1a3c984e894cfb568b63ca224a26", "patch": "@@ -74,12 +74,12 @@ impl fmt::Show for Matrix {\n     }\n }\n \n-struct MatchCheckCtxt<'a> {\n-    tcx: &'a ty::ctxt\n+pub struct MatchCheckCtxt<'a> {\n+    pub tcx: &'a ty::ctxt\n }\n \n #[deriving(Clone, PartialEq)]\n-enum Constructor {\n+pub enum Constructor {\n     /// The constructor of all patterns that don't vary by constructor,\n     /// e.g. struct patterns and fixed-length arrays.\n     Single,\n@@ -492,9 +492,9 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix, v: &[Gc<P\n                          ctor: Constructor, lty: ty::t, witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, r.as_slice(), &ctor, arity)\n+        specialize(cx, r.as_slice(), &ctor, 0u, arity)\n     }).collect());\n-    match specialize(cx, v, &ctor, arity) {\n+    match specialize(cx, v, &ctor, 0u, arity) {\n         Some(v) => is_useful(cx, &matrix, v.as_slice(), witness),\n         None => NotUseful\n     }\n@@ -580,7 +580,7 @@ fn is_wild(cx: &MatchCheckCtxt, p: Gc<Pat>) -> bool {\n ///\n /// For instance, a tuple pattern (_, 42u, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: ty::t) -> uint {\n+pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: ty::t) -> uint {\n     match ty::get(ty).sty {\n         ty::ty_tup(ref fs) => fs.len(),\n         ty::ty_box(_) | ty::ty_uniq(_) => 1u,\n@@ -628,11 +628,11 @@ fn range_covered_by_constructor(ctor: &Constructor,\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n-              constructor: &Constructor, arity: uint) -> Option<Vec<Gc<Pat>>> {\n+pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n+                  constructor: &Constructor, col: uint, arity: uint) -> Option<Vec<Gc<Pat>>> {\n     let &Pat {\n         id: pat_id, node: ref node, span: pat_span\n-    } = &(*raw_pat(r[0]));\n+    } = &(*raw_pat(r[col]));\n     let head: Option<Vec<Gc<Pat>>> = match node {\n         &PatWild =>\n             Some(Vec::from_elem(arity, wild())),\n@@ -776,7 +776,7 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n             None\n         }\n     };\n-    head.map(|head| head.append(r.tail()))\n+    head.map(|head| head.append(r.slice_to(col)).append(r.slice_from(col + 1)))\n }\n \n fn default(cx: &MatchCheckCtxt, r: &[Gc<Pat>]) -> Option<Vec<Gc<Pat>>> {"}, {"sha": "186a737a56ba34f6cd0833d10d5894a050797f0a", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b6edf4702be1a3c984e894cfb568b63ca224a26/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b6edf4702be1a3c984e894cfb568b63ca224a26/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=6b6edf4702be1a3c984e894cfb568b63ca224a26", "patch": "@@ -248,7 +248,6 @@ lets_do_this! {\n     OrdTraitLangItem,                \"ord\",                     ord_trait;\n \n     StrEqFnLangItem,                 \"str_eq\",                  str_eq_fn;\n-    UniqStrEqFnLangItem,             \"uniq_str_eq\",             uniq_str_eq_fn;\n \n     // A number of failure-related lang items. The `fail_` item corresponds to\n     // divide-by-zero and various failure cases with `match`. The"}, {"sha": "595203fdefb2d26efe2e9b3358213d044ac98997", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 101, "deletions": 494, "changes": 595, "blob_url": "https://github.com/rust-lang/rust/blob/6b6edf4702be1a3c984e894cfb568b63ca224a26/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b6edf4702be1a3c984e894cfb568b63ca224a26/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=6b6edf4702be1a3c984e894cfb568b63ca224a26", "patch": "@@ -199,7 +199,8 @@ use driver::config::FullDebugInfo;\n use lib::llvm::{llvm, ValueRef, BasicBlockRef};\n use middle::const_eval;\n use middle::def;\n-use middle::lang_items::{UniqStrEqFnLangItem, StrEqFnLangItem};\n+use middle::check_match;\n+use middle::lang_items::StrEqFnLangItem;\n use middle::pat_util::*;\n use middle::resolve::DefMap;\n use middle::trans::adt;\n@@ -223,15 +224,16 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, vec_map_to_str};\n \n+use std;\n use std::collections::HashMap;\n use std::cell::Cell;\n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n+use std::gc::{Gc};\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::ast_util::path_to_ident;\n use syntax::ast_util;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n \n // An option identifying a literal: either a unit-like struct or an\n@@ -252,7 +254,7 @@ pub enum VecLenOpt {\n // range)\n enum Opt {\n     lit(Lit),\n-    var(ty::Disr, Rc<adt::Repr>),\n+    var(ty::Disr, Rc<adt::Repr>, ast::DefId),\n     range(Gc<ast::Expr>, Gc<ast::Expr>),\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n@@ -284,7 +286,7 @@ fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                 _ => fail!(\"compare_list_exprs: type mismatch\"),\n             }\n         }\n-        (&var(a, _), &var(b, _)) => a == b,\n+        (&var(a, _, _), &var(b, _, _)) => a == b,\n         (&vec_len(a1, a2, _), &vec_len(b1, b2, _)) =>\n             a1 == b1 && a2 == b2,\n         _ => false\n@@ -320,7 +322,7 @@ fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n             let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n             return single_result(Result::new(bcx, lit_datum.val));\n         }\n-        var(disr_val, ref repr) => {\n+        var(disr_val, ref repr, _) => {\n             return adt::trans_case(bcx, &**repr, disr_val);\n         }\n         range(ref l1, ref l2) => {\n@@ -342,18 +344,11 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n     let def = ccx.tcx.def_map.borrow().get_copy(&pat_id);\n     match def {\n         def::DefVariant(enum_id, var_id, _) => {\n-            let variants = ty::enum_variants(ccx.tcx(), enum_id);\n-            for v in (*variants).iter() {\n-                if var_id == v.id {\n-                    return var(v.disr_val,\n-                               adt::represent_node(bcx, pat_id))\n-                }\n-            }\n-            unreachable!();\n+            let variant = ty::enum_variant_with_id(ccx.tcx(), enum_id, var_id);\n+            var(variant.disr_val, adt::represent_node(bcx, pat_id), var_id)\n         }\n-        def::DefFn(..) |\n-        def::DefStruct(_) => {\n-            return lit(UnitLikeStructLit(pat_id));\n+        def::DefFn(..) | def::DefStruct(_) => {\n+            lit(UnitLikeStructLit(pat_id))\n         }\n         _ => {\n             ccx.sess().bug(\"non-variant or struct in variant_opt()\");\n@@ -462,24 +457,15 @@ fn expand_nested_bindings<'a, 'b>(\n     }).collect()\n }\n \n-fn assert_is_binding_or_wild(bcx: &Block, p: Gc<ast::Pat>) {\n-    if !pat_is_binding_or_wild(&bcx.tcx().def_map, &*p) {\n-        bcx.sess().span_bug(\n-            p.span,\n-            format!(\"expected an identifier pattern but found p: {}\",\n-                    p.repr(bcx.tcx())).as_slice());\n-    }\n-}\n-\n-type enter_pat<'a> = |Gc<ast::Pat>|: 'a -> Option<Vec<Gc<ast::Pat>>>;\n+type enter_pats<'a> = |&[Gc<ast::Pat>]|: 'a -> Option<Vec<Gc<ast::Pat>>>;\n \n fn enter_match<'a, 'b>(\n                bcx: &'b Block<'b>,\n                dm: &DefMap,\n                m: &'a [Match<'a, 'b>],\n                col: uint,\n                val: ValueRef,\n-               e: enter_pat)\n+               e: enter_pats)\n                -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n@@ -489,10 +475,7 @@ fn enter_match<'a, 'b>(\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n-        e(*br.pats.get(col)).map(|sub| {\n-            let pats = sub.append(br.pats.slice(0u, col))\n-                            .append(br.pats.slice(col + 1u, br.pats.len()));\n-\n+        e(br.pats.as_slice()).map(|pats| {\n             let this = *br.pats.get(col);\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n@@ -528,11 +511,11 @@ fn enter_default<'a, 'b>(\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n-    enter_match(bcx, dm, m, col, val, |p| {\n-        match p.node {\n-          ast::PatWild | ast::PatWildMulti => Some(Vec::new()),\n-          ast::PatIdent(_, _, None) if pat_is_binding(dm, &*p) => Some(Vec::new()),\n-          _ => None\n+    enter_match(bcx, dm, m, col, val, |pats| {\n+        if pat_is_binding_or_wild(dm, pats[col]) {\n+            Some(Vec::from_slice(pats.slice_to(col)).append(pats.slice_from(col + 1)))\n+        } else {\n+            None\n         }\n     })\n }\n@@ -561,8 +544,14 @@ fn enter_default<'a, 'b>(\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n+/// The above is now outdated in that enter_match() now takes a function that\n+/// takes the complete row of patterns rather than just the first one.\n+/// Also, most of the enter_() family functions have been unified with\n+/// the check_match specialization step.\n fn enter_opt<'a, 'b>(\n              bcx: &'b Block<'b>,\n+             _: ast::NodeId,\n+             dm: &DefMap,\n              m: &'a [Match<'a, 'b>],\n              opt: &Opt,\n              col: uint,\n@@ -577,88 +566,32 @@ fn enter_opt<'a, 'b>(\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let tcx = bcx.tcx();\n-    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n-    let mut i = 0;\n-    enter_match(bcx, &tcx.def_map, m, col, val, |p| {\n-        let answer = match p.node {\n-            ast::PatEnum(..) |\n-            ast::PatIdent(_, _, None) if pat_is_const(&tcx.def_map, &*p) => {\n-                let const_def = tcx.def_map.borrow().get_copy(&p.id);\n-                let const_def_id = const_def.def_id();\n-                if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n-                    Some(Vec::new())\n-                } else {\n-                    None\n-                }\n-            }\n-            ast::PatEnum(_, ref subpats) => {\n-                if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n-                    // FIXME: Must we clone?\n-                    match *subpats {\n-                        None => Some(Vec::from_elem(variant_size, dummy)),\n-                        Some(ref subpats) => {\n-                            Some((*subpats).iter().map(|x| *x).collect())\n-                        }\n-                    }\n-                } else {\n-                    None\n-                }\n-            }\n-            ast::PatIdent(_, _, None)\n-                    if pat_is_variant_or_struct(&tcx.def_map, &*p) => {\n-                if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n-                    Some(Vec::new())\n-                } else {\n-                    None\n-                }\n-            }\n-            ast::PatLit(l) => {\n-                if opt_eq(tcx, &lit(ExprLit(l)), opt) { Some(Vec::new()) }\n-                else { None }\n-            }\n-            ast::PatRange(l1, l2) => {\n-                if opt_eq(tcx, &range(l1, l2), opt) { Some(Vec::new()) }\n-                else { None }\n-            }\n-            ast::PatStruct(_, ref field_pats, _) => {\n-                if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n-                    // Look up the struct variant ID.\n-                    let struct_id;\n-                    match tcx.def_map.borrow().get_copy(&p.id) {\n-                        def::DefVariant(_, found_struct_id, _) => {\n-                            struct_id = found_struct_id;\n-                        }\n-                        _ => {\n-                            tcx.sess.span_bug(p.span, \"expected enum variant def\");\n-                        }\n-                    }\n+    let ctor = match opt {\n+        &lit(UnitLikeStructLit(_)) => check_match::Single,\n+        &lit(x) => check_match::ConstantValue(const_eval::eval_const_expr(\n+            bcx.tcx(), lit_to_expr(bcx.tcx(), &x))),\n+        &range(ref lo, ref hi) => check_match::ConstantRange(\n+            const_eval::eval_const_expr(bcx.tcx(), &**lo),\n+            const_eval::eval_const_expr(bcx.tcx(), &**hi)\n+        ),\n+        &vec_len(len, _, _) => check_match::Slice(len),\n+        &var(_, _, def_id) => check_match::Variant(def_id)\n+    };\n \n-                    // Reorder the patterns into the same order they were\n-                    // specified in the struct definition. Also fill in\n-                    // unspecified fields with dummy.\n-                    let mut reordered_patterns = Vec::new();\n-                    let r = ty::lookup_struct_fields(tcx, struct_id);\n-                    for field in r.iter() {\n-                            match field_pats.iter().find(|p| p.ident.name\n-                                                         == field.name) {\n-                                None => reordered_patterns.push(dummy),\n-                                Some(fp) => reordered_patterns.push(fp.pat)\n-                            }\n-                    }\n-                    Some(reordered_patterns)\n-                } else {\n-                    None\n-                }\n-            }\n+    let mut i = 0;\n+    let tcx = bcx.tcx();\n+    let mcx = check_match::MatchCheckCtxt { tcx: bcx.tcx() };\n+    enter_match(bcx, dm, m, col, val, |pats| {\n+        let span = pats[col].span;\n+        let specialized = match pats[col].node {\n             ast::PatVec(ref before, slice, ref after) => {\n                 let (lo, hi) = match *opt {\n                     vec_len(_, _, (lo, hi)) => (lo, hi),\n-                    _ => tcx.sess.span_bug(p.span,\n+                    _ => tcx.sess.span_bug(span,\n                                            \"vec pattern but not vec opt\")\n                 };\n \n-                match slice {\n+                let elems = match slice {\n                     Some(slice) if i >= lo && i <= hi => {\n                         let n = before.len() + after.len();\n                         let this_opt = vec_len(n, vec_len_ge(before.len()),\n@@ -690,172 +623,15 @@ fn enter_opt<'a, 'b>(\n                         }\n                     }\n                     _ => None\n-                }\n+                };\n+                elems.map(|head| head.append(pats.slice_to(col)).append(pats.slice_from(col + 1)))\n             }\n             _ => {\n-                assert_is_binding_or_wild(bcx, p);\n-                Some(Vec::from_elem(variant_size, dummy))\n+                check_match::specialize(&mcx, pats.as_slice(), &ctor, col, variant_size)\n             }\n         };\n         i += 1;\n-        answer\n-    })\n-}\n-\n-fn enter_rec_or_struct<'a, 'b>(\n-                       bcx: &'b Block<'b>,\n-                       dm: &DefMap,\n-                       m: &'a [Match<'a, 'b>],\n-                       col: uint,\n-                       fields: &[ast::Ident],\n-                       val: ValueRef)\n-                       -> Vec<Match<'a, 'b>> {\n-    debug!(\"enter_rec_or_struct(bcx={}, m={}, col={}, val={})\",\n-           bcx.to_str(),\n-           m.repr(bcx.tcx()),\n-           col,\n-           bcx.val_to_str(val));\n-    let _indenter = indenter();\n-\n-    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n-    enter_match(bcx, dm, m, col, val, |p| {\n-        match p.node {\n-            ast::PatStruct(_, ref fpats, _) => {\n-                let mut pats = Vec::new();\n-                for fname in fields.iter() {\n-                    match fpats.iter().find(|p| p.ident.name == fname.name) {\n-                        None => pats.push(dummy),\n-                        Some(pat) => pats.push(pat.pat)\n-                    }\n-                }\n-                Some(pats)\n-            }\n-            _ => {\n-                assert_is_binding_or_wild(bcx, p);\n-                Some(Vec::from_elem(fields.len(), dummy))\n-            }\n-        }\n-    })\n-}\n-\n-fn enter_tup<'a, 'b>(\n-             bcx: &'b Block<'b>,\n-             dm: &DefMap,\n-             m: &'a [Match<'a, 'b>],\n-             col: uint,\n-             val: ValueRef,\n-             n_elts: uint)\n-             -> Vec<Match<'a, 'b>> {\n-    debug!(\"enter_tup(bcx={}, m={}, col={}, val={})\",\n-           bcx.to_str(),\n-           m.repr(bcx.tcx()),\n-           col,\n-           bcx.val_to_str(val));\n-    let _indenter = indenter();\n-\n-    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n-    enter_match(bcx, dm, m, col, val, |p| {\n-        match p.node {\n-            ast::PatTup(ref elts) => {\n-                let mut new_elts = Vec::new();\n-                for elt in elts.iter() {\n-                    new_elts.push((*elt).clone())\n-                }\n-                Some(new_elts)\n-            }\n-            _ => {\n-                assert_is_binding_or_wild(bcx, p);\n-                Some(Vec::from_elem(n_elts, dummy))\n-            }\n-        }\n-    })\n-}\n-\n-fn enter_tuple_struct<'a, 'b>(\n-                      bcx: &'b Block<'b>,\n-                      dm: &DefMap,\n-                      m: &'a [Match<'a, 'b>],\n-                      col: uint,\n-                      val: ValueRef,\n-                      n_elts: uint)\n-                      -> Vec<Match<'a, 'b>> {\n-    debug!(\"enter_tuple_struct(bcx={}, m={}, col={}, val={})\",\n-           bcx.to_str(),\n-           m.repr(bcx.tcx()),\n-           col,\n-           bcx.val_to_str(val));\n-    let _indenter = indenter();\n-\n-    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n-    enter_match(bcx, dm, m, col, val, |p| {\n-        match p.node {\n-            ast::PatEnum(_, Some(ref elts)) => {\n-                Some(elts.iter().map(|x| (*x)).collect())\n-            }\n-            ast::PatEnum(_, None) => {\n-                Some(Vec::from_elem(n_elts, dummy))\n-            }\n-            _ => {\n-                assert_is_binding_or_wild(bcx, p);\n-                Some(Vec::from_elem(n_elts, dummy))\n-            }\n-        }\n-    })\n-}\n-\n-fn enter_uniq<'a, 'b>(\n-              bcx: &'b Block<'b>,\n-              dm: &DefMap,\n-              m: &'a [Match<'a, 'b>],\n-              col: uint,\n-              val: ValueRef)\n-              -> Vec<Match<'a, 'b>> {\n-    debug!(\"enter_uniq(bcx={}, m={}, col={}, val={})\",\n-           bcx.to_str(),\n-           m.repr(bcx.tcx()),\n-           col,\n-           bcx.val_to_str(val));\n-    let _indenter = indenter();\n-\n-    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n-    enter_match(bcx, dm, m, col, val, |p| {\n-        match p.node {\n-            ast::PatBox(sub) => {\n-                Some(vec!(sub))\n-            }\n-            _ => {\n-                assert_is_binding_or_wild(bcx, p);\n-                Some(vec!(dummy))\n-            }\n-        }\n-    })\n-}\n-\n-fn enter_region<'a, 'b>(\n-                bcx: &'b Block<'b>,\n-                dm: &DefMap,\n-                m: &'a [Match<'a, 'b>],\n-                col: uint,\n-                val: ValueRef)\n-                -> Vec<Match<'a, 'b>> {\n-    debug!(\"enter_region(bcx={}, m={}, col={}, val={})\",\n-           bcx.to_str(),\n-           m.repr(bcx.tcx()),\n-           col,\n-           bcx.val_to_str(val));\n-    let _indenter = indenter();\n-\n-    let dummy = box(GC) ast::Pat { id: 0, node: ast::PatWild, span: DUMMY_SP };\n-    enter_match(bcx, dm, m, col, val, |p| {\n-        match p.node {\n-            ast::PatRegion(sub) => {\n-                Some(vec!(sub))\n-            }\n-            _ => {\n-                assert_is_binding_or_wild(bcx, p);\n-                Some(vec!(dummy))\n-            }\n-        }\n+        specialized\n     })\n }\n \n@@ -900,14 +676,10 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                 // variable binding.\n                 let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n-                    Some(def::DefVariant(..)) => {\n+                    Some(def::DefVariant(..)) | Some(def::DefStruct(..)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(def::DefStruct(..)) => {\n-                        add_to_set(ccx.tcx(), &mut found,\n-                                   lit(UnitLikeStructLit(cur.id)));\n-                    }\n                     Some(def::DefStatic(const_did, false)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    lit(ConstLit(const_did)));\n@@ -1027,49 +799,6 @@ fn extract_vec_elems<'a>(\n     ExtractedBlock { vals: elems, bcx: bcx }\n }\n \n-/// Checks every pattern in `m` at `col` column.\n-/// If there are a struct pattern among them function\n-/// returns list of all fields that are matched in these patterns.\n-/// Function returns None if there is no struct pattern.\n-/// Function doesn't collect fields from struct-like enum variants.\n-/// Function can return empty list if there is only wildcard struct pattern.\n-fn collect_record_or_struct_fields<'a>(\n-                                   bcx: &'a Block<'a>,\n-                                   m: &[Match],\n-                                   col: uint)\n-                                   -> Option<Vec<ast::Ident> > {\n-    let mut fields: Vec<ast::Ident> = Vec::new();\n-    let mut found = false;\n-    for br in m.iter() {\n-        match br.pats.get(col).node {\n-          ast::PatStruct(_, ref fs, _) => {\n-            match ty::get(node_id_type(bcx, br.pats.get(col).id)).sty {\n-              ty::ty_struct(..) => {\n-                   extend(&mut fields, fs.as_slice());\n-                   found = true;\n-              }\n-              _ => ()\n-            }\n-          }\n-          _ => ()\n-        }\n-    }\n-    if found {\n-        return Some(fields);\n-    } else {\n-        return None;\n-    }\n-\n-    fn extend(idents: &mut Vec<ast::Ident> , field_pats: &[ast::FieldPat]) {\n-        for field_pat in field_pats.iter() {\n-            let field_ident = field_pat.ident;\n-            if !idents.iter().any(|x| x.name == field_ident.name) {\n-                idents.push(field_ident);\n-            }\n-        }\n-    }\n-}\n-\n // Macro for deciding whether any of the remaining matches fit a given kind of\n // pattern.  Note that, because the macro is well-typed, either ALL of the\n // matches should fit that sort of pattern or NONE (however, some of the\n@@ -1093,21 +822,17 @@ fn any_region_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::PatRegion(_))\n }\n \n-fn any_tup_pat(m: &[Match], col: uint) -> bool {\n-    any_pat!(m, ast::PatTup(_))\n-}\n-\n-fn any_tuple_struct_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n+fn any_irrefutable_adt_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n         let pat = *br.pats.get(col);\n         match pat.node {\n-            ast::PatEnum(_, _) => {\n+            ast::PatTup(_) => true,\n+            ast::PatStruct(_, _, _) | ast::PatEnum(_, _) =>\n                 match bcx.tcx().def_map.borrow().find(&pat.id) {\n                     Some(&def::DefFn(..)) |\n                     Some(&def::DefStruct(..)) => true,\n                     _ => false\n-                }\n-            }\n+                },\n             _ => false\n         }\n     })\n@@ -1197,7 +922,7 @@ fn pick_col(m: &[Match]) -> uint {\n }\n \n #[deriving(PartialEq)]\n-pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n+pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len }\n \n // Compiles a comparison between two things.\n fn compare_values<'a>(\n@@ -1226,21 +951,6 @@ fn compare_values<'a>(\n     }\n \n     match ty::get(rhs_t).sty {\n-        ty::ty_uniq(t) => match ty::get(t).sty {\n-            ty::ty_str => {\n-                let scratch_lhs = alloca(cx, val_ty(lhs), \"__lhs\");\n-                Store(cx, lhs, scratch_lhs);\n-                let scratch_rhs = alloca(cx, val_ty(rhs), \"__rhs\");\n-                Store(cx, rhs, scratch_rhs);\n-                let did = langcall(cx,\n-                                   None,\n-                                   format!(\"comparison of `{}`\",\n-                                           cx.ty_to_str(rhs_t)).as_slice(),\n-                                   UniqStrEqFnLangItem);\n-                callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs], None)\n-            }\n-            _ => cx.sess().bug(\"only strings supported in compare_values\"),\n-        },\n         ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n             ty::ty_str => compare_str(cx, lhs, rhs, rhs_t),\n             ty::ty_vec(mt, _) => match ty::get(mt.ty).sty {\n@@ -1254,7 +964,7 @@ fn compare_values<'a>(\n                 },\n                 _ => cx.sess().bug(\"only byte strings supported in compare_values\"),\n             },\n-            _ => cx.sess().bug(\"on string and byte strings supported in compare_values\"),\n+            _ => cx.sess().bug(\"only string and byte strings supported in compare_values\"),\n         },\n         _ => cx.sess().bug(\"only scalars, byte strings, and strings supported in compare_values\"),\n     }\n@@ -1475,103 +1185,41 @@ fn compile_submatch_continue<'a, 'b>(\n \n     let vals_left = Vec::from_slice(vals.slice(0u, col)).append(vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n-    let mut pat_id = 0;\n-    for br in m.iter() {\n-        // Find a real id (we're adding placeholder wildcard patterns, but\n-        // each column is guaranteed to have at least one real pattern)\n-        if pat_id == 0 {\n-            pat_id = br.pats.get(col).id;\n-        }\n-    }\n-\n-    match collect_record_or_struct_fields(bcx, m, col) {\n-        Some(ref rec_fields) => {\n-            let pat_ty = node_id_type(bcx, pat_id);\n-            let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n-            expr::with_field_tys(tcx, pat_ty, Some(pat_id), |discr, field_tys| {\n-                let rec_vals = rec_fields.iter().map(|field_name| {\n-                        let ix = ty::field_idx_strict(tcx, field_name.name, field_tys);\n-                        adt::trans_field_ptr(bcx, &*pat_repr, val, discr, ix)\n-                        }).collect::<Vec<_>>();\n-                compile_submatch(\n-                        bcx,\n-                        enter_rec_or_struct(bcx,\n-                                            dm,\n-                                            m,\n-                                            col,\n-                                            rec_fields.as_slice(),\n-                                            val).as_slice(),\n-                        rec_vals.append(vals_left.as_slice()).as_slice(),\n-                        chk, has_genuine_default);\n-            });\n-            return;\n-        }\n-        None => {}\n-    }\n \n-    if any_tup_pat(m, col) {\n-        let tup_ty = node_id_type(bcx, pat_id);\n-        let tup_repr = adt::represent_type(bcx.ccx(), tup_ty);\n-        let n_tup_elts = match ty::get(tup_ty).sty {\n-          ty::ty_tup(ref elts) => elts.len(),\n-          _ => ccx.sess().bug(\"non-tuple type in tuple pattern\")\n-        };\n-        let tup_vals = Vec::from_fn(n_tup_elts, |i| {\n-            adt::trans_field_ptr(bcx, &*tup_repr, val, 0, i)\n-        });\n-        compile_submatch(bcx,\n-                         enter_tup(bcx,\n-                                   dm,\n-                                   m,\n-                                   col,\n-                                   val,\n-                                   n_tup_elts).as_slice(),\n-                         tup_vals.append(vals_left.as_slice()).as_slice(),\n-                         chk, has_genuine_default);\n-        return;\n-    }\n+    // Find a real id (we're adding placeholder wildcard patterns, but\n+    // each column is guaranteed to have at least one real pattern)\n+    let pat_id = m.iter().map(|br| br.pats.get(col).id).find(|&id| id != 0).unwrap_or(0);\n \n-    if any_tuple_struct_pat(bcx, m, col) {\n-        let struct_ty = node_id_type(bcx, pat_id);\n-        let struct_element_count;\n-        match ty::get(struct_ty).sty {\n-            ty::ty_struct(struct_id, _) => {\n-                struct_element_count =\n-                    ty::lookup_struct_fields(tcx, struct_id).len();\n-            }\n-            _ => {\n-                ccx.sess().bug(\"non-struct type in tuple struct pattern\");\n-            }\n-        }\n-\n-        let struct_repr = adt::represent_type(bcx.ccx(), struct_ty);\n-        let llstructvals = Vec::from_fn(struct_element_count, |i| {\n-            adt::trans_field_ptr(bcx, &*struct_repr, val, 0, i)\n-        });\n-        compile_submatch(bcx,\n-                         enter_tuple_struct(bcx, dm, m, col, val,\n-                                            struct_element_count).as_slice(),\n-                         llstructvals.append(vals_left.as_slice()).as_slice(),\n-                         chk, has_genuine_default);\n-        return;\n-    }\n+    let left_ty = if pat_id == 0 {\n+        ty::mk_nil()\n+    } else {\n+        node_id_type(bcx, pat_id)\n+    };\n \n-    if any_uniq_pat(m, col) {\n-        let llbox = Load(bcx, val);\n-        compile_submatch(bcx,\n-                         enter_uniq(bcx, dm, m, col, val).as_slice(),\n-                         (vec!(llbox)).append(vals_left.as_slice()).as_slice(),\n-                         chk, has_genuine_default);\n-        return;\n-    }\n+    let mcx = check_match::MatchCheckCtxt { tcx: bcx.tcx() };\n+    let adt_vals = if any_irrefutable_adt_pat(bcx, m, col) {\n+        let repr = adt::represent_type(bcx.ccx(), left_ty);\n+        let arg_count = adt::num_args(&*repr, 0);\n+        let field_vals: Vec<ValueRef> = std::iter::range(0, arg_count).map(|ix|\n+            adt::trans_field_ptr(bcx, &*repr, val, 0, ix)\n+        ).collect();\n+        Some(field_vals)\n+    } else if any_uniq_pat(m, col) || any_region_pat(m, col) {\n+        Some(vec!(Load(bcx, val)))\n+    } else {\n+        None\n+    };\n \n-    if any_region_pat(m, col) {\n-        let loaded_val = Load(bcx, val);\n-        compile_submatch(bcx,\n-                         enter_region(bcx, dm, m, col, val).as_slice(),\n-                         (vec!(loaded_val)).append(vals_left.as_slice()).as_slice(),\n-                         chk, has_genuine_default);\n-        return;\n+    match adt_vals {\n+        Some(field_vals) => {\n+            let pats = enter_match(bcx, dm, m, col, val, |pats|\n+                check_match::specialize(&mcx, pats, &check_match::Single, col, field_vals.len())\n+            );\n+            let vals = field_vals.append(vals_left.as_slice());\n+            compile_submatch(bcx, pats.as_slice(), vals.as_slice(), chk, has_genuine_default);\n+            return;\n+        }\n+        _ => ()\n     }\n \n     // Decide what kind of branch we need\n@@ -1582,24 +1230,22 @@ fn compile_submatch_continue<'a, 'b>(\n     debug!(\"test_val={}\", bcx.val_to_str(test_val));\n     if opts.len() > 0u {\n         match *opts.get(0) {\n-            var(_, ref repr) => {\n+            var(_, ref repr, _) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val);\n                 kind = the_kind;\n                 for &tval in val_opt.iter() { test_val = tval; }\n             }\n             lit(_) => {\n-                let pty = node_id_type(bcx, pat_id);\n-                test_val = load_if_immediate(bcx, val, pty);\n-                kind = if ty::type_is_integral(pty) { switch }\n+                test_val = load_if_immediate(bcx, val, left_ty);\n+                kind = if ty::type_is_integral(left_ty) { switch }\n                 else { compare };\n             }\n             range(_, _) => {\n                 test_val = Load(bcx, val);\n                 kind = compare;\n             },\n             vec_len(..) => {\n-                let vec_ty = node_id_type(bcx, pat_id);\n-                let (_, len) = tvec::get_base_and_len(bcx, val, vec_ty);\n+                let (_, len) = tvec::get_base_and_len(bcx, val, left_ty);\n                 test_val = len;\n                 kind = compare_vec_len;\n             }\n@@ -1652,17 +1298,19 @@ fn compile_submatch_continue<'a, 'b>(\n                       }\n                   }\n               }\n-              compare => {\n-                  let t = node_id_type(bcx, pat_id);\n+              compare | compare_vec_len => {\n+                  let t = if kind == compare {\n+                      left_ty\n+                  } else {\n+                      ty::mk_uint() // vector length\n+                  };\n                   let Result {bcx: after_cx, val: matches} = {\n                       match trans_opt(bcx, opt) {\n                           single_result(Result {bcx, val}) => {\n                               compare_values(bcx, test_val, val, t)\n                           }\n                           lower_bound(Result {bcx, val}) => {\n-                              compare_scalar_types(\n-                                  bcx, test_val, val,\n-                                  t, ast::BiGe)\n+                              compare_scalar_types(bcx, test_val, val, t, ast::BiGe)\n                           }\n                           range_result(Result {val: vbegin, ..},\n                                        Result {bcx, val: vend}) => {\n@@ -1686,48 +1334,7 @@ fn compile_submatch_continue<'a, 'b>(\n                   // the default.\n                   let guarded = m[i].data.arm.guard.is_some();\n                   let multi_pats = m[i].pats.len() > 1;\n-                  if i+1 < len && (guarded || multi_pats) {\n-                      branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n-                  }\n-                  CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n-              }\n-              compare_vec_len => {\n-                  let Result {bcx: after_cx, val: matches} = {\n-                      match trans_opt(bcx, opt) {\n-                          single_result(\n-                              Result {bcx, val}) => {\n-                              let value = compare_scalar_values(\n-                                  bcx, test_val, val,\n-                                  signed_int, ast::BiEq);\n-                              Result::new(bcx, value)\n-                          }\n-                          lower_bound(\n-                              Result {bcx, val: val}) => {\n-                              let value = compare_scalar_values(\n-                                  bcx, test_val, val,\n-                                  signed_int, ast::BiGe);\n-                              Result::new(bcx, value)\n-                          }\n-                          range_result(\n-                              Result {val: vbegin, ..},\n-                              Result {bcx, val: vend}) => {\n-                              let llge =\n-                                  compare_scalar_values(\n-                                  bcx, test_val,\n-                                  vbegin, signed_int, ast::BiGe);\n-                              let llle =\n-                                  compare_scalar_values(\n-                                  bcx, test_val, vend,\n-                                  signed_int, ast::BiLe);\n-                              Result::new(bcx, And(bcx, llge, llle))\n-                          }\n-                      }\n-                  };\n-                  bcx = fcx.new_temp_block(\"compare_vec_len_next\");\n-\n-                  // If none of these subcases match, move on to the\n-                  // next condition if there is any.\n-                  if i+1 < len {\n+                  if i + 1 < len && (guarded || multi_pats || kind == compare_vec_len) {\n                       branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n                   }\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n@@ -1741,7 +1348,7 @@ fn compile_submatch_continue<'a, 'b>(\n         let mut size = 0u;\n         let mut unpacked = Vec::new();\n         match *opt {\n-            var(disr_val, ref repr) => {\n+            var(disr_val, ref repr, _) => {\n                 let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n                     extract_variant_args(opt_cx, &**repr, disr_val, val);\n                 size = argvals.len();\n@@ -1761,7 +1368,7 @@ fn compile_submatch_continue<'a, 'b>(\n             }\n             lit(_) | range(_, _) => ()\n         }\n-        let opt_ms = enter_opt(opt_cx, m, opt, col, size, val);\n+        let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let opt_vals = unpacked.append(vals_left.as_slice());\n \n         match branch_chk {"}]}