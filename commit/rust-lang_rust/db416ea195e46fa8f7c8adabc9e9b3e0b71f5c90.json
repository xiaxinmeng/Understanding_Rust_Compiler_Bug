{"sha": "db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "node_id": "C_kwDOAAsO6NoAKGRiNDE2ZWExOTVlNDZmYThmN2M4YWRhYmM5ZTliM2UwYjcxZjVjOTA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-06T15:54:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-06T15:54:52Z"}, "message": "Rollup merge of #104898 - oli-obk:group_all_the_things, r=wesleywiser\n\nPut all cached values into a central struct instead of just the stable hash\n\ncc `@nnethercote`\n\nthis allows re-use of the type for Predicate without duplicating all the logic for the non-hash cached fields", "tree": {"sha": "32d90da339a385c2b25b0387c68fbc80a755ab37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32d90da339a385c2b25b0387c68fbc80a755ab37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjj2XMCRBK7hj4Ov3rIwAA1kcIAB2q9M/lByZ+pB6TL5tX/Zuo\nwUd6VO1nsLNKe5NZBnXXMMyzZG+7KQvLhY2+VxoLRZeHQuVNjgh/yw7MwAX0eCmO\nQyIDbZ/q7Tc6FQ5zTgdz0vM28ORxauI+51lo80PNPW5ir/NIIMNFQd/s8hHtedMl\nGKHmva6GBf/kFXXi7WdueLOaqZ6UNVZ+3+Nfeop8UaX0rGiZ2Rats6F775Yb3F+c\npQAQ0wk1mX8ZG5Rg+PLl/wktHthW7XTRH9pc688Wf4SgpIn5wqZWOJjmSSUPE7m8\nn8qpQHsZQlu6HKBoTfrS2YyrFhWlXFhwST+/scbUbHceEtpYvfSiTaNC+GF3E3o=\n=dw78\n-----END PGP SIGNATURE-----\n", "payload": "tree 32d90da339a385c2b25b0387c68fbc80a755ab37\nparent b6852428a8ea9728369b64b9964cad8e258403d3\nparent 14a9cf2ba2178f6f776ca22bd45a83bdf27b39cd\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670342092 +0100\ncommitter GitHub <noreply@github.com> 1670342092 +0100\n\nRollup merge of #104898 - oli-obk:group_all_the_things, r=wesleywiser\n\nPut all cached values into a central struct instead of just the stable hash\n\ncc `@nnethercote`\n\nthis allows re-use of the type for Predicate without duplicating all the logic for the non-hash cached fields\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "html_url": "https://github.com/rust-lang/rust/commit/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6852428a8ea9728369b64b9964cad8e258403d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6852428a8ea9728369b64b9964cad8e258403d3", "html_url": "https://github.com/rust-lang/rust/commit/b6852428a8ea9728369b64b9964cad8e258403d3"}, {"sha": "14a9cf2ba2178f6f776ca22bd45a83bdf27b39cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/14a9cf2ba2178f6f776ca22bd45a83bdf27b39cd", "html_url": "https://github.com/rust-lang/rust/commit/14a9cf2ba2178f6f776ca22bd45a83bdf27b39cd"}], "stats": {"total": 436, "additions": 182, "deletions": 254}, "files": [{"sha": "ba94f3776eb90bc5da1e4e534508d689aa20dda7", "filename": "compiler/rustc_data_structures/src/intern.rs", "status": "modified", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs?ref=db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "patch": "@@ -4,8 +4,6 @@ use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n use std::ptr;\n \n-use crate::fingerprint::Fingerprint;\n-\n mod private {\n     #[derive(Clone, Copy, Debug)]\n     pub struct PrivateZst;\n@@ -110,86 +108,5 @@ where\n     }\n }\n \n-/// A helper type that you can wrap round your own type in order to automatically\n-/// cache the stable hash on creation and not recompute it whenever the stable hash\n-/// of the type is computed.\n-/// This is only done in incremental mode. You can also opt out of caching by using\n-/// StableHash::ZERO for the hash, in which case the hash gets computed each time.\n-/// This is useful if you have values that you intern but never (can?) use for stable\n-/// hashing.\n-#[derive(Copy, Clone)]\n-pub struct WithStableHash<T> {\n-    pub internee: T,\n-    pub stable_hash: Fingerprint,\n-}\n-\n-impl<T: PartialEq> PartialEq for WithStableHash<T> {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.internee.eq(&other.internee)\n-    }\n-}\n-\n-impl<T: Eq> Eq for WithStableHash<T> {}\n-\n-impl<T: Ord> PartialOrd for WithStableHash<T> {\n-    fn partial_cmp(&self, other: &WithStableHash<T>) -> Option<Ordering> {\n-        Some(self.internee.cmp(&other.internee))\n-    }\n-}\n-\n-impl<T: Ord> Ord for WithStableHash<T> {\n-    fn cmp(&self, other: &WithStableHash<T>) -> Ordering {\n-        self.internee.cmp(&other.internee)\n-    }\n-}\n-\n-impl<T> Deref for WithStableHash<T> {\n-    type Target = T;\n-\n-    #[inline]\n-    fn deref(&self) -> &T {\n-        &self.internee\n-    }\n-}\n-\n-impl<T: Hash> Hash for WithStableHash<T> {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        if self.stable_hash != Fingerprint::ZERO {\n-            self.stable_hash.hash(s)\n-        } else {\n-            self.internee.hash(s)\n-        }\n-    }\n-}\n-\n-impl<T: HashStable<CTX>, CTX> HashStable<CTX> for WithStableHash<T> {\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        if self.stable_hash == Fingerprint::ZERO || cfg!(debug_assertions) {\n-            // No cached hash available. This can only mean that incremental is disabled.\n-            // We don't cache stable hashes in non-incremental mode, because they are used\n-            // so rarely that the performance actually suffers.\n-\n-            // We need to build the hash as if we cached it and then hash that hash, as\n-            // otherwise the hashes will differ between cached and non-cached mode.\n-            let stable_hash: Fingerprint = {\n-                let mut hasher = StableHasher::new();\n-                self.internee.hash_stable(hcx, &mut hasher);\n-                hasher.finish()\n-            };\n-            if cfg!(debug_assertions) && self.stable_hash != Fingerprint::ZERO {\n-                assert_eq!(\n-                    stable_hash, self.stable_hash,\n-                    \"cached stable hash does not match freshly computed stable hash\"\n-                );\n-            }\n-            stable_hash.hash_stable(hcx, hasher);\n-        } else {\n-            self.stable_hash.hash_stable(hcx, hasher);\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests;"}, {"sha": "0fa81b7e4e0bc20f2c644783199734475e474359", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "patch": "@@ -10,7 +10,7 @@ declare_tool_lint! {\n     /// The `rustc_pass_by_value` lint marks a type with `#[rustc_pass_by_value]` requiring it to\n     /// always be passed by value. This is usually used for types that are thin wrappers around\n     /// references, so there is no benefit to an extra layer of indirection. (Example: `Ty` which\n-    /// is a reference to an `Interned<TyS>`)\n+    /// is a reference to an `Interned<TyKind>`)\n     pub rustc::PASS_BY_VALUE,\n     Warn,\n     \"pass by reference of a type flagged as `#[rustc_pass_by_value]`\","}, {"sha": "6de68841fe91f41fa84faa97f77ce3448350d9e9", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "patch": "@@ -1,3 +1,5 @@\n+#![allow(rustc::usage_of_ty_tykind)]\n+\n /// This higher-order macro declares a list of types which can be allocated by `Arena`.\n ///\n /// Specifying the `decode` modifier will add decode impls for `&T` and `&[T]` where `T` is the type\n@@ -89,8 +91,8 @@ macro_rules! arena_types {\n             [] hir_id_set: rustc_hir::HirIdSet,\n \n             // Interned types\n-            [] tys: rustc_data_structures::intern::WithStableHash<rustc_middle::ty::TyS<'tcx>>,\n-            [] predicates: rustc_data_structures::intern::WithStableHash<rustc_middle::ty::PredicateS<'tcx>>,\n+            [] tys: rustc_type_ir::WithCachedTypeInfo<rustc_middle::ty::TyKind<'tcx>>,\n+            [] predicates: rustc_type_ir::WithCachedTypeInfo<rustc_middle::ty::PredicateKind<'tcx>>,\n             [] consts: rustc_middle::ty::ConstS<'tcx>,\n \n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,"}, {"sha": "221105ac48f79b5487374c7969cdd058d1515755", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "patch": "@@ -103,7 +103,7 @@ impl hash::Hash for Allocation {\n /// Interned types generally have an `Outer` type and an `Inner` type, where\n /// `Outer` is a newtype around `Interned<Inner>`, and all the operations are\n /// done on `Outer`, because all occurrences are interned. E.g. `Ty` is an\n-/// outer type and `TyS` is its inner type.\n+/// outer type and `TyKind` is its inner type.\n ///\n /// Here things are different because only const allocations are interned. This\n /// means that both the inner type (`Allocation`) and the outer type"}, {"sha": "82ca1b87535d89780909a8d5c5f95789138c60b7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 27, "deletions": 56, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "patch": "@@ -1,5 +1,7 @@\n //! Type context book-keeping.\n \n+#![allow(rustc::usage_of_ty_tykind)]\n+\n use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n@@ -19,15 +21,15 @@ use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n     ClosureSizeProfileData, Const, ConstS, DefIdTree, FloatTy, FloatVar, FloatVid,\n     GenericParamDefKind, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n-    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, PredicateS, ProjectionTy,\n-    Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut,\n-    UintTy, Visibility,\n+    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, ProjectionTy, Region,\n+    RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, UintTy,\n+    Visibility,\n };\n use crate::ty::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef, UserSubsts};\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::intern::{Interned, WithStableHash};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n@@ -68,6 +70,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, LayoutS, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n use rustc_type_ir::sty::TyKind::*;\n+use rustc_type_ir::WithCachedTypeInfo;\n use rustc_type_ir::{DynKind, InternAs, InternIteratorElement, Interner, TypeFlags};\n \n use std::any::Any;\n@@ -137,13 +140,13 @@ pub struct CtxtInterners<'tcx> {\n \n     // Specifically use a speedy hash algorithm for these hash sets, since\n     // they're accessed quite often.\n-    type_: InternedSet<'tcx, WithStableHash<TyS<'tcx>>>,\n+    type_: InternedSet<'tcx, WithCachedTypeInfo<TyKind<'tcx>>>,\n     const_lists: InternedSet<'tcx, List<ty::Const<'tcx>>>,\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind<'tcx>>,\n     poly_existential_predicates: InternedSet<'tcx, List<PolyExistentialPredicate<'tcx>>>,\n-    predicate: InternedSet<'tcx, WithStableHash<PredicateS<'tcx>>>,\n+    predicate: InternedSet<'tcx, WithCachedTypeInfo<ty::Binder<'tcx, PredicateKind<'tcx>>>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n@@ -194,15 +197,12 @@ impl<'tcx> CtxtInterners<'tcx> {\n                     let stable_hash =\n                         self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n \n-                    let ty_struct = TyS {\n-                        kind,\n+                    InternedInSet(self.arena.alloc(WithCachedTypeInfo {\n+                        internee: kind,\n+                        stable_hash,\n                         flags: flags.flags,\n                         outer_exclusive_binder: flags.outer_exclusive_binder,\n-                    };\n-\n-                    InternedInSet(\n-                        self.arena.alloc(WithStableHash { internee: ty_struct, stable_hash }),\n-                    )\n+                    }))\n                 })\n                 .0,\n         ))\n@@ -246,16 +246,12 @@ impl<'tcx> CtxtInterners<'tcx> {\n                     let stable_hash =\n                         self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n \n-                    let predicate_struct = PredicateS {\n-                        kind,\n+                    InternedInSet(self.arena.alloc(WithCachedTypeInfo {\n+                        internee: kind,\n+                        stable_hash,\n                         flags: flags.flags,\n                         outer_exclusive_binder: flags.outer_exclusive_binder,\n-                    };\n-\n-                    InternedInSet(\n-                        self.arena\n-                            .alloc(WithStableHash { internee: predicate_struct, stable_hash }),\n-                    )\n+                    }))\n                 })\n                 .0,\n         ))\n@@ -2104,7 +2100,7 @@ macro_rules! sty_debug_print {\n                 let shards = tcx.interners.type_.lock_shards();\n                 let types = shards.iter().flat_map(|shard| shard.keys());\n                 for &InternedInSet(t) in types {\n-                    let variant = match t.kind {\n+                    let variant = match t.internee {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n                         ty::Error(_) => /* unimportant */ continue,\n@@ -2214,51 +2210,26 @@ impl<'tcx, T: 'tcx + ?Sized> IntoPointer for InternedInSet<'tcx, T> {\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx> Borrow<TyKind<'tcx>> for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n-        &self.0.kind\n-    }\n-}\n-\n-impl<'tcx> PartialEq for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {\n-    fn eq(&self, other: &InternedInSet<'tcx, WithStableHash<TyS<'tcx>>>) -> bool {\n-        // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n-        // `x == y`.\n-        self.0.kind == other.0.kind\n-    }\n-}\n-\n-impl<'tcx> Eq for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {}\n-\n-impl<'tcx> Hash for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n-        self.0.kind.hash(s)\n-    }\n-}\n-\n-impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>>\n-    for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>>\n-{\n-    fn borrow<'a>(&'a self) -> &'a Binder<'tcx, PredicateKind<'tcx>> {\n-        &self.0.kind\n+impl<'tcx, T> Borrow<T> for InternedInSet<'tcx, WithCachedTypeInfo<T>> {\n+    fn borrow<'a>(&'a self) -> &'a T {\n+        &self.0.internee\n     }\n }\n \n-impl<'tcx> PartialEq for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {\n-    fn eq(&self, other: &InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>>) -> bool {\n+impl<'tcx, T: PartialEq> PartialEq for InternedInSet<'tcx, WithCachedTypeInfo<T>> {\n+    fn eq(&self, other: &InternedInSet<'tcx, WithCachedTypeInfo<T>>) -> bool {\n         // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n         // `x == y`.\n-        self.0.kind == other.0.kind\n+        self.0.internee == other.0.internee\n     }\n }\n \n-impl<'tcx> Eq for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {}\n+impl<'tcx, T: Eq> Eq for InternedInSet<'tcx, WithCachedTypeInfo<T>> {}\n \n-impl<'tcx> Hash for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {\n+impl<'tcx, T: Hash> Hash for InternedInSet<'tcx, WithCachedTypeInfo<T>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n-        self.0.kind.hash(s)\n+        self.0.internee.hash(s)\n     }\n }\n "}, {"sha": "cd679ffdfbc67d6f72efadd5a4fb028c2d021e94", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 107, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "patch": "@@ -9,6 +9,8 @@\n //!\n //! [\"The `ty` module: representing types\"]: https://rustc-dev-guide.rust-lang.org/ty.html\n \n+#![allow(rustc::usage_of_ty_tykind)]\n+\n pub use self::fold::{FallibleTypeFolder, TypeFoldable, TypeFolder, TypeSuperFoldable};\n pub use self::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n pub use self::AssocItemContainer::*;\n@@ -32,7 +34,7 @@ use rustc_ast::node_id::NodeMap;\n use rustc_attr as attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n-use rustc_data_structures::intern::{Interned, WithStableHash};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n@@ -50,6 +52,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, Span};\n use rustc_target::abi::{Align, Integer, IntegerType, VariantIdx};\n pub use rustc_target::abi::{ReprFlags, ReprOptions};\n+use rustc_type_ir::WithCachedTypeInfo;\n pub use subst::*;\n pub use vtable::*;\n \n@@ -445,86 +448,22 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n-/// Represents a type.\n-///\n-/// IMPORTANT:\n-/// - This is a very \"dumb\" struct (with no derives and no `impls`).\n-/// - Values of this type are always interned and thus unique, and are stored\n-///   as an `Interned<TyS>`.\n-/// - `Ty` (which contains a reference to a `Interned<TyS>`) or `Interned<TyS>`\n-///   should be used everywhere instead of `TyS`. In particular, `Ty` has most\n-///   of the relevant methods.\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-#[allow(rustc::usage_of_ty_tykind)]\n-pub(crate) struct TyS<'tcx> {\n-    /// This field shouldn't be used directly and may be removed in the future.\n-    /// Use `Ty::kind()` instead.\n-    kind: TyKind<'tcx>,\n-\n-    /// This field provides fast access to information that is also contained\n-    /// in `kind`.\n-    ///\n-    /// This field shouldn't be used directly and may be removed in the future.\n-    /// Use `Ty::flags()` instead.\n-    flags: TypeFlags,\n-\n-    /// This field provides fast access to information that is also contained\n-    /// in `kind`.\n-    ///\n-    /// This is a kind of confusing thing: it stores the smallest\n-    /// binder such that\n-    ///\n-    /// (a) the binder itself captures nothing but\n-    /// (b) all the late-bound things within the type are captured\n-    ///     by some sub-binder.\n-    ///\n-    /// So, for a type without any late-bound things, like `u32`, this\n-    /// will be *innermost*, because that is the innermost binder that\n-    /// captures nothing. But for a type `&'D u32`, where `'D` is a\n-    /// late-bound region with De Bruijn index `D`, this would be `D + 1`\n-    /// -- the binder itself does not capture `D`, but `D` is captured\n-    /// by an inner binder.\n-    ///\n-    /// We call this concept an \"exclusive\" binder `D` because all\n-    /// De Bruijn indices within the type are contained within `0..D`\n-    /// (exclusive).\n-    outer_exclusive_binder: ty::DebruijnIndex,\n-}\n-\n-/// Use this rather than `TyS`, whenever possible.\n+/// Use this rather than `TyKind`, whenever possible.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n #[rustc_diagnostic_item = \"Ty\"]\n #[rustc_pass_by_value]\n-pub struct Ty<'tcx>(Interned<'tcx, WithStableHash<TyS<'tcx>>>);\n+pub struct Ty<'tcx>(Interned<'tcx, WithCachedTypeInfo<TyKind<'tcx>>>);\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// A \"bool\" type used in rustc_mir_transform unit tests when we\n     /// have not spun up a TyCtxt.\n-    pub const BOOL_TY_FOR_UNIT_TESTING: Ty<'tcx> = Ty(Interned::new_unchecked(&WithStableHash {\n-        internee: TyS {\n-            kind: ty::Bool,\n+    pub const BOOL_TY_FOR_UNIT_TESTING: Ty<'tcx> =\n+        Ty(Interned::new_unchecked(&WithCachedTypeInfo {\n+            internee: ty::Bool,\n+            stable_hash: Fingerprint::ZERO,\n             flags: TypeFlags::empty(),\n             outer_exclusive_binder: DebruijnIndex::from_usize(0),\n-        },\n-        stable_hash: Fingerprint::ZERO,\n-    }));\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let TyS {\n-            kind,\n-\n-            // The other fields just provide fast access to information that is\n-            // also contained in `kind`, so no need to hash them.\n-            flags: _,\n-\n-            outer_exclusive_binder: _,\n-        } = self;\n-\n-        kind.hash_stable(hcx, hasher)\n-    }\n+        }));\n }\n \n impl ty::EarlyBoundRegion {\n@@ -535,28 +474,18 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n-/// Represents a predicate.\n-///\n-/// See comments on `TyS`, which apply here too (albeit for\n-/// `PredicateS`/`Predicate` rather than `TyS`/`Ty`).\n-#[derive(Debug)]\n-pub(crate) struct PredicateS<'tcx> {\n-    kind: Binder<'tcx, PredicateKind<'tcx>>,\n-    flags: TypeFlags,\n-    /// See the comment for the corresponding field of [TyS].\n-    outer_exclusive_binder: ty::DebruijnIndex,\n-}\n-\n-/// Use this rather than `PredicateS`, whenever possible.\n+/// Use this rather than `PredicateKind`, whenever possible.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, HashStable)]\n #[rustc_pass_by_value]\n-pub struct Predicate<'tcx>(Interned<'tcx, WithStableHash<PredicateS<'tcx>>>);\n+pub struct Predicate<'tcx>(\n+    Interned<'tcx, WithCachedTypeInfo<ty::Binder<'tcx, PredicateKind<'tcx>>>>,\n+);\n \n impl<'tcx> Predicate<'tcx> {\n     /// Gets the inner `Binder<'tcx, PredicateKind<'tcx>>`.\n     #[inline]\n     pub fn kind(self) -> Binder<'tcx, PredicateKind<'tcx>> {\n-        self.0.kind\n+        self.0.internee\n     }\n \n     #[inline(always)]\n@@ -631,21 +560,6 @@ impl<'tcx> Predicate<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for PredicateS<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let PredicateS {\n-            ref kind,\n-\n-            // The other fields just provide fast access to information that is\n-            // also contained in `kind`, so no need to hash them.\n-            flags: _,\n-            outer_exclusive_binder: _,\n-        } = self;\n-\n-        kind.hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl rustc_errors::IntoDiagnosticArg for Predicate<'_> {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n         rustc_errors::DiagnosticArgValue::Str(std::borrow::Cow::Owned(self.to_string()))\n@@ -1028,7 +942,7 @@ impl<'tcx> Term<'tcx> {\n         unsafe {\n             match ptr & TAG_MASK {\n                 TYPE_TAG => TermKind::Ty(Ty(Interned::new_unchecked(\n-                    &*((ptr & !TAG_MASK) as *const WithStableHash<ty::TyS<'tcx>>),\n+                    &*((ptr & !TAG_MASK) as *const WithCachedTypeInfo<ty::TyKind<'tcx>>),\n                 ))),\n                 CONST_TAG => TermKind::Const(ty::Const(Interned::new_unchecked(\n                     &*((ptr & !TAG_MASK) as *const ty::ConstS<'tcx>),\n@@ -1072,7 +986,7 @@ impl<'tcx> TermKind<'tcx> {\n             TermKind::Ty(ty) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(&*ty.0.0) & TAG_MASK, 0);\n-                (TYPE_TAG, ty.0.0 as *const WithStableHash<ty::TyS<'tcx>> as usize)\n+                (TYPE_TAG, ty.0.0 as *const WithCachedTypeInfo<ty::TyKind<'tcx>> as usize)\n             }\n             TermKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n@@ -2692,8 +2606,7 @@ mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // tidy-alphabetical-start\n-    static_assert_size!(PredicateS<'_>, 48);\n-    static_assert_size!(TyS<'_>, 40);\n-    static_assert_size!(WithStableHash<TyS<'_>>, 56);\n+    static_assert_size!(PredicateKind<'_>, 32);\n+    static_assert_size!(WithCachedTypeInfo<TyKind<'_>>, 56);\n     // tidy-alphabetical-end\n }"}, {"sha": "9cbda95a4df7a7f1e582dadbcf021829f45791a4", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "patch": "@@ -1611,7 +1611,7 @@ impl<'tcx> Region<'tcx> {\n impl<'tcx> Ty<'tcx> {\n     #[inline(always)]\n     pub fn kind(self) -> &'tcx TyKind<'tcx> {\n-        &self.0.0.kind\n+        &self.0.0\n     }\n \n     #[inline(always)]"}, {"sha": "a1b084a5e891eca1bb2bf780597bae2fb06cbb40", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "patch": "@@ -6,10 +6,11 @@ use crate::ty::sty::{ClosureSubsts, GeneratorSubsts, InlineConstSubsts};\n use crate::ty::visit::{TypeVisitable, TypeVisitor};\n use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n-use rustc_data_structures::intern::{Interned, WithStableHash};\n+use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_serialize::{self, Decodable, Encodable};\n+use rustc_type_ir::WithCachedTypeInfo;\n use smallvec::SmallVec;\n \n use core::intrinsics;\n@@ -84,7 +85,7 @@ impl<'tcx> GenericArgKind<'tcx> {\n             GenericArgKind::Type(ty) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(&*ty.0.0) & TAG_MASK, 0);\n-                (TYPE_TAG, ty.0.0 as *const WithStableHash<ty::TyS<'tcx>> as usize)\n+                (TYPE_TAG, ty.0.0 as *const WithCachedTypeInfo<ty::TyKind<'tcx>> as usize)\n             }\n             GenericArgKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n@@ -162,7 +163,7 @@ impl<'tcx> GenericArg<'tcx> {\n                     &*((ptr & !TAG_MASK) as *const ty::RegionKind<'tcx>),\n                 ))),\n                 TYPE_TAG => GenericArgKind::Type(Ty(Interned::new_unchecked(\n-                    &*((ptr & !TAG_MASK) as *const WithStableHash<ty::TyS<'tcx>>),\n+                    &*((ptr & !TAG_MASK) as *const WithCachedTypeInfo<ty::TyKind<'tcx>>),\n                 ))),\n                 CONST_TAG => GenericArgKind::Const(ty::Const(Interned::new_unchecked(\n                     &*((ptr & !TAG_MASK) as *const ty::ConstS<'tcx>),"}, {"sha": "e3f7a1bd033cea39b7ed706a45ed49ce7e8474e6", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "patch": "@@ -19,9 +19,11 @@ use std::mem::discriminant;\n \n pub mod codec;\n pub mod sty;\n+pub mod ty_info;\n \n pub use codec::*;\n pub use sty::*;\n+pub use ty_info::*;\n \n /// Needed so we can use #[derive(HashStable_Generic)]\n pub trait HashStableContext {}"}, {"sha": "4e5d424886ad8017e91627f310d848e3288a59ee", "filename": "compiler/rustc_type_ir/src/ty_info.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_type_ir%2Fsrc%2Fty_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90/compiler%2Frustc_type_ir%2Fsrc%2Fty_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fty_info.rs?ref=db416ea195e46fa8f7c8adabc9e9b3e0b71f5c90", "patch": "@@ -0,0 +1,122 @@\n+use std::{\n+    cmp::Ordering,\n+    hash::{Hash, Hasher},\n+    ops::Deref,\n+};\n+\n+use rustc_data_structures::{\n+    fingerprint::Fingerprint,\n+    stable_hasher::{HashStable, StableHasher},\n+};\n+\n+use crate::{DebruijnIndex, TypeFlags};\n+\n+/// A helper type that you can wrap round your own type in order to automatically\n+/// cache the stable hash, type flags and debruijn index on creation and\n+/// not recompute it whenever the information is needed.\n+/// This is only done in incremental mode. You can also opt out of caching by using\n+/// StableHash::ZERO for the hash, in which case the hash gets computed each time.\n+/// This is useful if you have values that you intern but never (can?) use for stable\n+/// hashing.\n+#[derive(Copy, Clone)]\n+pub struct WithCachedTypeInfo<T> {\n+    pub internee: T,\n+    pub stable_hash: Fingerprint,\n+\n+    /// This field provides fast access to information that is also contained\n+    /// in `kind`.\n+    ///\n+    /// This field shouldn't be used directly and may be removed in the future.\n+    /// Use `Ty::flags()` instead.\n+    pub flags: TypeFlags,\n+\n+    /// This field provides fast access to information that is also contained\n+    /// in `kind`.\n+    ///\n+    /// This is a kind of confusing thing: it stores the smallest\n+    /// binder such that\n+    ///\n+    /// (a) the binder itself captures nothing but\n+    /// (b) all the late-bound things within the type are captured\n+    ///     by some sub-binder.\n+    ///\n+    /// So, for a type without any late-bound things, like `u32`, this\n+    /// will be *innermost*, because that is the innermost binder that\n+    /// captures nothing. But for a type `&'D u32`, where `'D` is a\n+    /// late-bound region with De Bruijn index `D`, this would be `D + 1`\n+    /// -- the binder itself does not capture `D`, but `D` is captured\n+    /// by an inner binder.\n+    ///\n+    /// We call this concept an \"exclusive\" binder `D` because all\n+    /// De Bruijn indices within the type are contained within `0..D`\n+    /// (exclusive).\n+    pub outer_exclusive_binder: DebruijnIndex,\n+}\n+\n+impl<T: PartialEq> PartialEq for WithCachedTypeInfo<T> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.internee.eq(&other.internee)\n+    }\n+}\n+\n+impl<T: Eq> Eq for WithCachedTypeInfo<T> {}\n+\n+impl<T: Ord> PartialOrd for WithCachedTypeInfo<T> {\n+    fn partial_cmp(&self, other: &WithCachedTypeInfo<T>) -> Option<Ordering> {\n+        Some(self.internee.cmp(&other.internee))\n+    }\n+}\n+\n+impl<T: Ord> Ord for WithCachedTypeInfo<T> {\n+    fn cmp(&self, other: &WithCachedTypeInfo<T>) -> Ordering {\n+        self.internee.cmp(&other.internee)\n+    }\n+}\n+\n+impl<T> Deref for WithCachedTypeInfo<T> {\n+    type Target = T;\n+\n+    #[inline]\n+    fn deref(&self) -> &T {\n+        &self.internee\n+    }\n+}\n+\n+impl<T: Hash> Hash for WithCachedTypeInfo<T> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        if self.stable_hash != Fingerprint::ZERO {\n+            self.stable_hash.hash(s)\n+        } else {\n+            self.internee.hash(s)\n+        }\n+    }\n+}\n+\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for WithCachedTypeInfo<T> {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        if self.stable_hash == Fingerprint::ZERO || cfg!(debug_assertions) {\n+            // No cached hash available. This can only mean that incremental is disabled.\n+            // We don't cache stable hashes in non-incremental mode, because they are used\n+            // so rarely that the performance actually suffers.\n+\n+            // We need to build the hash as if we cached it and then hash that hash, as\n+            // otherwise the hashes will differ between cached and non-cached mode.\n+            let stable_hash: Fingerprint = {\n+                let mut hasher = StableHasher::new();\n+                self.internee.hash_stable(hcx, &mut hasher);\n+                hasher.finish()\n+            };\n+            if cfg!(debug_assertions) && self.stable_hash != Fingerprint::ZERO {\n+                assert_eq!(\n+                    stable_hash, self.stable_hash,\n+                    \"cached stable hash does not match freshly computed stable hash\"\n+                );\n+            }\n+            stable_hash.hash_stable(hcx, hasher);\n+        } else {\n+            self.stable_hash.hash_stable(hcx, hasher);\n+        }\n+    }\n+}"}]}