{"sha": "36a50c29f6c5c386fba6ab685818755ac55152e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2YTUwYzI5ZjZjNWMzODZmYmE2YWI2ODU4MTg3NTVhYzU1MTUyZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-09T06:56:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-09T06:56:25Z"}, "message": "Auto merge of #55803 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #55576 (Clarify error message for -C opt-level)\n - #55633 (Support memcpy/memmove with differing src/dst alignment)\n - #55638 (Fix ICE in msg_span_from_free_region on ReEmpty)\n - #55659 (rustc: Delete grouping logic from the musl target)\n - #55719 (Sidestep link error from rustfix'ed code by using a *defined* static.)\n - #55736 (Elide anon lifetimes in conflicting impl note)\n - #55739 (Consume optimization fuel from the MIR inliner)\n - #55742 (Avoid panic when matching function call)\n - #55753 (borrow_set: remove a helper function and a clone it uses)\n - #55755 (Improve creation of 3 IndexVecs)\n - #55758 ([regression - rust2018]: unused_mut lint false positives on nightly)\n - #55760 (Remove intermediate font specs)\n - #55761 (mir: remove a hacky recursive helper function)\n - #55774 (wasm32-unknown-emscripten expects the rust_eh_personality symbol)\n - #55777 (Use `Lit` rather than `P<Lit>` in `ast::ExprKind`.)\n - #55783 (Deprecate mpsc channel selection)\n - #55788 (rustc: Request ansi colors if stderr isn't a tty)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "67c50601ac77481c7b2a8410c1c67f32fef2081f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67c50601ac77481c7b2a8410c1c67f32fef2081f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36a50c29f6c5c386fba6ab685818755ac55152e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36a50c29f6c5c386fba6ab685818755ac55152e5", "html_url": "https://github.com/rust-lang/rust/commit/36a50c29f6c5c386fba6ab685818755ac55152e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36a50c29f6c5c386fba6ab685818755ac55152e5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "653da4fd006c97625247acd7e076d0782cdc149b", "url": "https://api.github.com/repos/rust-lang/rust/commits/653da4fd006c97625247acd7e076d0782cdc149b", "html_url": "https://github.com/rust-lang/rust/commit/653da4fd006c97625247acd7e076d0782cdc149b"}, {"sha": "d293d1eea0b41e4ff65e8027e74eca9efd2dc7df", "url": "https://api.github.com/repos/rust-lang/rust/commits/d293d1eea0b41e4ff65e8027e74eca9efd2dc7df", "html_url": "https://github.com/rust-lang/rust/commit/d293d1eea0b41e4ff65e8027e74eca9efd2dc7df"}], "stats": {"total": 575, "additions": 403, "deletions": 172}, "files": [{"sha": "9235f8e7660a1112609a86e1f4ea85b237b15a08", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -97,7 +97,10 @@ pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n pub mod personalities {\n     #[no_mangle]\n     #[cfg(not(any(\n-        target_arch = \"wasm32\",\n+        all(\n+            target_arch = \"wasm32\",\n+            not(target_os = \"emscripten\"),\n+        ),\n         all(\n             target_os = \"windows\",\n             target_env = \"gnu\","}, {"sha": "dd5d4b8f6afff546875f9d0d29e4aad19e103f3a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -3705,7 +3705,7 @@ impl<'a> LoweringContext<'a> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::Unary(op, ohs)\n             }\n-            ExprKind::Lit(ref l) => hir::ExprKind::Lit(P((**l).clone())),\n+            ExprKind::Lit(ref l) => hir::ExprKind::Lit(P((*l).clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n                 hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))"}, {"sha": "f833ebc7ca763ec9ffab99f78e997de8249f35cc", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -178,6 +178,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.msg_span_from_early_bound_and_free_regions(region)\n             }\n             ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+            ty::ReEmpty => (\"an empty lifetime\".to_owned(), None),\n             _ => bug!(\"{:?}\", region),\n         }\n     }"}, {"sha": "a84226bf665d0df364b6604961f641233c728e1f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -304,6 +304,20 @@ impl<'tcx> Mir<'tcx> {\n         })\n     }\n \n+    /// Returns an iterator over all user-declared mutable locals.\n+    #[inline]\n+    pub fn mut_vars_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n+        (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n+            let local = Local::new(index);\n+            let decl = &self.local_decls[local];\n+            if decl.is_user_variable.is_some() && decl.mutability == Mutability::Mut {\n+                Some(local)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n     /// Returns an iterator over all user-declared mutable arguments and locals.\n     #[inline]\n     pub fn mut_vars_and_args_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {"}, {"sha": "78aabf86e300d72ae2a8784897db7bff0356a679", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -2082,7 +2082,7 @@ pub fn build_session_options_and_crate_config(\n                         error_format,\n                         &format!(\n                             \"optimization level needs to be \\\n-                             between 0-3 (instead was `{}`)\",\n+                             between 0-3, s or z (instead was `{}`)\",\n                             arg\n                         ),\n                     );"}, {"sha": "d7b5dd049e35088f015a6628a1794e8489089d2b", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -396,7 +396,10 @@ fn to_pretty_impl_header(tcx: TyCtxt<'_, '_, '_>, impl_def_id: DefId) -> Option<\n     if !substs.is_noop() {\n         types_without_default_bounds.extend(substs.types());\n         w.push('<');\n-        w.push_str(&substs.iter().map(|k| k.to_string()).collect::<Vec<_>>().join(\", \"));\n+        w.push_str(&substs.iter()\n+            .map(|k| k.to_string())\n+            .filter(|k| &k[..] != \"'_\")\n+            .collect::<Vec<_>>().join(\", \"));\n         w.push('>');\n     }\n "}, {"sha": "54550b8a2055f44214f38b818c6b8b88836201b6", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -450,8 +450,7 @@ impl<'sess> OnDiskCache<'sess> {\n                                      .map(|&(cnum, ..)| cnum)\n                                      .max()\n                                      .unwrap_or(0) + 1;\n-            let mut map = IndexVec::new();\n-            map.resize(map_size as usize, None);\n+            let mut map = IndexVec::from_elem_n(None, map_size as usize);\n \n             for &(prev_cnum, ref crate_name, crate_disambiguator) in prev_cnums {\n                 let key = (crate_name.clone(), crate_disambiguator);"}, {"sha": "bd7a1c2c3293eb28194d3b8e4f2af54d56580d46", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -225,9 +225,10 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                 // ...and then memcpy it to the intended destination.\n                 base::call_memcpy(bx,\n                                   bx.pointercast(dst.llval, Type::i8p(cx)),\n+                                  self.layout.align,\n                                   bx.pointercast(llscratch, Type::i8p(cx)),\n+                                  scratch_align,\n                                   C_usize(cx, self.layout.size.bytes()),\n-                                  self.layout.align.min(scratch_align),\n                                   MemFlags::empty());\n \n                 bx.lifetime_end(llscratch, scratch_size);"}, {"sha": "806025937cb110c75028094c56caee1e6fda7f1e", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -53,7 +53,7 @@ use mir::place::PlaceRef;\n use attributes;\n use builder::{Builder, MemFlags};\n use callee;\n-use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n+use common::{C_bool, C_bytes_in_context, C_usize};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use common::{C_struct_in_context, C_array, val_ty};\n use consts;\n@@ -77,7 +77,6 @@ use rustc_data_structures::sync::Lrc;\n use std::any::Any;\n use std::cmp;\n use std::ffi::CString;\n-use std::i32;\n use std::ops::{Deref, DerefMut};\n use std::sync::mpsc;\n use std::time::{Instant, Duration};\n@@ -319,8 +318,8 @@ pub fn coerce_unsized_into(\n                 }\n \n                 if src_f.layout.ty == dst_f.layout.ty {\n-                    memcpy_ty(bx, dst_f.llval, src_f.llval, src_f.layout,\n-                              src_f.align.min(dst_f.align), MemFlags::empty());\n+                    memcpy_ty(bx, dst_f.llval, dst_f.align, src_f.llval, src_f.align,\n+                              src_f.layout, MemFlags::empty());\n                 } else {\n                     coerce_unsized_into(bx, src_f, dst_f);\n                 }\n@@ -420,44 +419,42 @@ pub fn to_immediate_scalar(\n pub fn call_memcpy(\n     bx: &Builder<'_, 'll, '_>,\n     dst: &'ll Value,\n+    dst_align: Align,\n     src: &'ll Value,\n+    src_align: Align,\n     n_bytes: &'ll Value,\n-    align: Align,\n     flags: MemFlags,\n ) {\n     if flags.contains(MemFlags::NONTEMPORAL) {\n         // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n-        let val = bx.load(src, align);\n+        let val = bx.load(src, src_align);\n         let ptr = bx.pointercast(dst, val_ty(val).ptr_to());\n-        bx.store_with_flags(val, ptr, align, flags);\n+        bx.store_with_flags(val, ptr, dst_align, flags);\n         return;\n     }\n     let cx = bx.cx;\n-    let ptr_width = &cx.sess().target.target.target_pointer_width;\n-    let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n-    let memcpy = cx.get_intrinsic(&key);\n     let src_ptr = bx.pointercast(src, Type::i8p(cx));\n     let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n     let size = bx.intcast(n_bytes, cx.isize_ty, false);\n-    let align = C_i32(cx, align.abi() as i32);\n-    let volatile = C_bool(cx, flags.contains(MemFlags::VOLATILE));\n-    bx.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n+    let volatile = flags.contains(MemFlags::VOLATILE);\n+    bx.memcpy(dst_ptr, dst_align.abi(), src_ptr, src_align.abi(), size, volatile);\n }\n \n pub fn memcpy_ty(\n     bx: &Builder<'_, 'll, 'tcx>,\n     dst: &'ll Value,\n+    dst_align: Align,\n     src: &'ll Value,\n+    src_align: Align,\n     layout: TyLayout<'tcx>,\n-    align: Align,\n     flags: MemFlags,\n ) {\n     let size = layout.size.bytes();\n     if size == 0 {\n         return;\n     }\n \n-    call_memcpy(bx, dst, src, C_usize(bx.cx, size), align, flags);\n+    call_memcpy(bx, dst, dst_align, src, src_align, C_usize(bx.cx, size), flags);\n }\n \n pub fn call_memset("}, {"sha": "1b1a31def3759bea88c4642f44e8b7a2d5b922c8", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -781,6 +781,24 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n+    pub fn memcpy(&self, dst: &'ll Value, dst_align: u64,\n+                  src: &'ll Value, src_align: u64,\n+                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMRustBuildMemCpy(self.llbuilder, dst, dst_align as c_uint,\n+                                      src, src_align as c_uint, size, is_volatile)\n+        }\n+    }\n+\n+    pub fn memmove(&self, dst: &'ll Value, dst_align: u64,\n+                  src: &'ll Value, src_align: u64,\n+                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMRustBuildMemMove(self.llbuilder, dst, dst_align as c_uint,\n+                                      src, src_align as c_uint, size, is_volatile)\n+        }\n+    }\n+\n     pub fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"minnum\");\n         unsafe {"}, {"sha": "555e4012c3add7c54d5e331c7e7aa372c22e645c", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -530,12 +530,6 @@ fn declare_intrinsic(cx: &CodegenCx<'ll, '_>, key: &str) -> Option<&'ll Value> {\n     let t_v4f64 = Type::vector(t_f64, 4);\n     let t_v8f64 = Type::vector(t_f64, 8);\n \n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i64\", fn(i8p, t_i8, t_i64, t_i32, i1) -> void);"}, {"sha": "a4401cf96d9deed201aa62a27f7031172ab1df0a", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -23,7 +23,7 @@ use glue;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{HasDataLayout, LayoutOf};\n+use rustc::ty::layout::LayoutOf;\n use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -690,28 +690,14 @@ fn copy_intrinsic(\n     let cx = bx.cx;\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = C_usize(cx, size.bytes());\n-    let align = C_i32(cx, align.abi() as i32);\n-\n-    let operation = if allow_overlap {\n-        \"memmove\"\n-    } else {\n-        \"memcpy\"\n-    };\n-\n-    let name = format!(\"llvm.{}.p0i8.p0i8.i{}\", operation,\n-                       cx.data_layout().pointer_size.bits());\n-\n+    let align = align.abi();\n     let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n     let src_ptr = bx.pointercast(src, Type::i8p(cx));\n-    let llfn = cx.get_intrinsic(&name);\n-\n-    bx.call(llfn,\n-        &[dst_ptr,\n-        src_ptr,\n-        bx.mul(size, count),\n-        align,\n-        C_bool(cx, volatile)],\n-        None)\n+    if allow_overlap {\n+        bx.memmove(dst_ptr, align, src_ptr, align, bx.mul(size, count), volatile)\n+    } else {\n+        bx.memcpy(dst_ptr, align, src_ptr, align, bx.mul(size, count), volatile)\n+    }\n }\n \n fn memset_intrinsic("}, {"sha": "b994b1ffc4bce91842b64630d4d88cf2a4afc974", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -998,6 +998,22 @@ extern \"C\" {\n                              Bundle: Option<&OperandBundleDef<'a>>,\n                              Name: *const c_char)\n                              -> &'a Value;\n+    pub fn LLVMRustBuildMemCpy(B: &Builder<'a>,\n+                               Dst: &'a Value,\n+                               DstAlign: c_uint,\n+                               Src: &'a Value,\n+                               SrcAlign: c_uint,\n+                               Size: &'a Value,\n+                               IsVolatile: bool)\n+                               -> &'a Value;\n+    pub fn LLVMRustBuildMemMove(B: &Builder<'a>,\n+                                Dst: &'a Value,\n+                                DstAlign: c_uint,\n+                                Src: &'a Value,\n+                                SrcAlign: c_uint,\n+                                Size: &'a Value,\n+                                IsVolatile: bool)\n+                                -> &'a Value;\n     pub fn LLVMBuildSelect(B: &Builder<'a>,\n                            If: &'a Value,\n                            Then: &'a Value,"}, {"sha": "3f9921a5cf930b68372a3584a17f6b725727d6f4", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -784,7 +784,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     // have scary latent bugs around.\n \n                     let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n-                    base::memcpy_ty(bx, scratch.llval, llval, op.layout, align, MemFlags::empty());\n+                    base::memcpy_ty(bx, scratch.llval, scratch.align, llval, align,\n+                                    op.layout, MemFlags::empty());\n                     (scratch.llval, scratch.align, true)\n                 } else {\n                     (llval, align, true)"}, {"sha": "c76cbfcd9717711e244a7a3b6e1421be3dfd0e2c", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -282,8 +282,8 @@ impl OperandValue<'ll> {\n         }\n         match self {\n             OperandValue::Ref(r, None, source_align) => {\n-                base::memcpy_ty(bx, dest.llval, r, dest.layout,\n-                                source_align.min(dest.align), flags)\n+                base::memcpy_ty(bx, dest.llval, dest.align, r, source_align,\n+                                dest.layout, flags)\n             }\n             OperandValue::Ref(_, Some(_), _) => {\n                 bug!(\"cannot directly store unsized values\");\n@@ -324,7 +324,7 @@ impl OperandValue<'ll> {\n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(&bx, unsized_ty, Some(llextra));\n         let lldst = bx.array_alloca(Type::i8(bx.cx), llsize, \"unsized_tmp\", max_align);\n-        base::call_memcpy(&bx, lldst, llptr, llsize, min_align, flags);\n+        base::call_memcpy(&bx, lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place.\n         let indirect_operand = OperandValue::Pair(lldst, llextra);"}, {"sha": "7e69e98071d4b1fa29ad1453d8f9733f8e1e1424", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -108,7 +108,13 @@ pub enum ColorConfig {\n impl ColorConfig {\n     fn to_color_choice(&self) -> ColorChoice {\n         match *self {\n-            ColorConfig::Always => ColorChoice::Always,\n+            ColorConfig::Always => {\n+                if atty::is(atty::Stream::Stderr) {\n+                    ColorChoice::Always\n+                } else {\n+                    ColorChoice::AlwaysAnsi\n+                }\n+            }\n             ColorConfig::Never => ColorChoice::Never,\n             ColorConfig::Auto if atty::is(atty::Stream::Stderr) => {\n                 ColorChoice::Auto"}, {"sha": "c432826dca865de3a8cba3850b947966b462a1b1", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -21,7 +21,6 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::bit_set::BitSet;\n use std::fmt;\n-use std::hash::Hash;\n use std::ops::Index;\n \n crate struct BorrowSet<'tcx> {\n@@ -233,21 +232,13 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n \n             self.insert_as_pending_if_two_phase(location, &assigned_place, region, kind, idx);\n \n-            insert(&mut self.region_map, &region, idx);\n+            self.region_map.entry(region).or_default().insert(idx);\n             if let Some(local) = borrowed_place.root_local() {\n-                insert(&mut self.local_map, &local, idx);\n+                self.local_map.entry(local).or_default().insert(idx);\n             }\n         }\n \n-        return self.super_assign(block, assigned_place, rvalue, location);\n-\n-        fn insert<'a, K, V>(map: &'a mut FxHashMap<K, FxHashSet<V>>, k: &K, v: V)\n-        where\n-            K: Clone + Eq + Hash,\n-            V: Eq + Hash,\n-        {\n-            map.entry(k.clone()).or_default().insert(v);\n-        }\n+        self.super_assign(block, assigned_place, rvalue, location)\n     }\n \n     fn visit_place("}, {"sha": "4e03f6f7f5e7a3e48e41f499f1af8c35672ac615", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -281,23 +281,21 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     // Note that this set is expected to be small - only upvars from closures\n     // would have a chance of erroneously adding non-user-defined mutable vars\n     // to the set.\n-    let temporary_used_locals: FxHashSet<Local> = mbcx\n-        .used_mut\n-        .iter()\n+    let temporary_used_locals: FxHashSet<Local> = mbcx.used_mut.iter()\n         .filter(|&local| mbcx.mir.local_decls[*local].is_user_variable.is_none())\n         .cloned()\n         .collect();\n-    mbcx.gather_used_muts(temporary_used_locals);\n+    // For the remaining unused locals that are marked as mutable, we avoid linting any that\n+    // were never initialized. These locals may have been removed as unreachable code; or will be\n+    // linted as unused variables.\n+    let unused_mut_locals = mbcx.mir.mut_vars_iter()\n+        .filter(|local| !mbcx.used_mut.contains(local))\n+        .collect();\n+    mbcx.gather_used_muts(temporary_used_locals, unused_mut_locals);\n \n     debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n-\n     let used_mut = mbcx.used_mut;\n-\n-    for local in mbcx\n-        .mir\n-        .mut_vars_and_args_iter()\n-        .filter(|local| !used_mut.contains(local))\n-    {\n+    for local in mbcx.mir.mut_vars_and_args_iter().filter(|local| !used_mut.contains(local)) {\n         if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.source_scope_local_data {\n             let local_decl = &mbcx.mir.local_decls[local];\n "}, {"sha": "7c75fb59917c00e5b73e8eb5dff46c2a15d9c75f", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 87, "deletions": 17, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -9,43 +9,113 @@\n // except according to those terms.\n \n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{Local, Location, Place};\n+use rustc::mir::{BasicBlock, Local, Location, Place, Statement, StatementKind, TerminatorKind};\n \n use rustc_data_structures::fx::FxHashSet;\n \n use borrow_check::MirBorrowckCtxt;\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    /// Walks the MIR looking for assignments to a set of locals, as part of the unused mutable\n-    /// local variables lint, to update the context's `used_mut` in a single walk.\n-    crate fn gather_used_muts(&mut self, locals: FxHashSet<Local>) {\n-        let mut visitor = GatherUsedMutsVisitor {\n-            needles: locals,\n-            mbcx: self,\n-        };\n-        visitor.visit_mir(visitor.mbcx.mir);\n+    /// Walks the MIR adding to the set of `used_mut` locals that will be ignored for the purposes\n+    /// of the `unused_mut` lint.\n+    ///\n+    /// `temporary_used_locals` should contain locals that were found to be temporary, mutable and\n+    ///  used from borrow checking. This function looks for assignments into these locals from\n+    ///  user-declared locals and adds those user-defined locals to the `used_mut` set. This can\n+    ///  occur due to a rare case involving upvars in closures.\n+    ///\n+    /// `never_initialized_mut_locals` should contain the set of user-declared mutable locals\n+    ///  (not arguments) that have not already been marked as being used.\n+    ///  This function then looks for assignments from statements or the terminator into the locals\n+    ///  from this set and removes them from the set. This leaves only those locals that have not\n+    ///  been assigned to - this set is used as a proxy for locals that were not initialized due to\n+    ///  unreachable code. These locals are then considered \"used\" to silence the lint for them.\n+    ///  See #55344 for context.\n+    crate fn gather_used_muts(\n+        &mut self,\n+        temporary_used_locals: FxHashSet<Local>,\n+        mut never_initialized_mut_locals: FxHashSet<Local>,\n+    ) {\n+        {\n+            let mut visitor = GatherUsedMutsVisitor {\n+                temporary_used_locals,\n+                never_initialized_mut_locals: &mut never_initialized_mut_locals,\n+                mbcx: self,\n+            };\n+            visitor.visit_mir(visitor.mbcx.mir);\n+        }\n+\n+        // Take the union of the existed `used_mut` set with those variables we've found were\n+        // never initialized.\n+        debug!(\"gather_used_muts: never_initialized_mut_locals={:?}\", never_initialized_mut_locals);\n+        self.used_mut = self.used_mut.union(&never_initialized_mut_locals).cloned().collect();\n     }\n }\n \n-/// MIR visitor gathering the assignments to a set of locals, in a single walk.\n-/// 'visit = the duration of the MIR walk\n+/// MIR visitor for collecting used mutable variables.\n+/// The 'visit lifetime represents the duration of the MIR walk.\n struct GatherUsedMutsVisitor<'visit, 'cx: 'visit, 'gcx: 'tcx, 'tcx: 'cx> {\n-    needles: FxHashSet<Local>,\n+    temporary_used_locals: FxHashSet<Local>,\n+    never_initialized_mut_locals: &'visit mut FxHashSet<Local>,\n     mbcx: &'visit mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n }\n \n impl<'visit, 'cx, 'gcx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'gcx, 'tcx> {\n+    fn visit_terminator_kind(\n+        &mut self,\n+        _block: BasicBlock,\n+        kind: &TerminatorKind<'tcx>,\n+        _location: Location,\n+    ) {\n+        debug!(\"visit_terminator_kind: kind={:?}\", kind);\n+        match &kind {\n+            TerminatorKind::Call { destination: Some((into, _)), .. } => {\n+                if let Some(local) = into.base_local() {\n+                    debug!(\n+                        \"visit_terminator_kind: kind={:?} local={:?} \\\n+                         never_initialized_mut_locals={:?}\",\n+                        kind, local, self.never_initialized_mut_locals\n+                    );\n+                    let _ = self.never_initialized_mut_locals.remove(&local);\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    fn visit_statement(\n+        &mut self,\n+        _block: BasicBlock,\n+        statement: &Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+        match &statement.kind {\n+            StatementKind::Assign(into, _) => {\n+                // Remove any locals that we found were initialized from the\n+                // `never_initialized_mut_locals` set. At the end, the only remaining locals will\n+                // be those that were never initialized - we will consider those as being used as\n+                // they will either have been removed by unreachable code optimizations; or linted\n+                // as unused variables.\n+                if let Some(local) = into.base_local() {\n+                    debug!(\n+                        \"visit_statement: statement={:?} local={:?} \\\n+                         never_initialized_mut_locals={:?}\",\n+                        statement, local, self.never_initialized_mut_locals\n+                    );\n+                    let _ = self.never_initialized_mut_locals.remove(&local);\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+\n     fn visit_local(\n         &mut self,\n         local: &Local,\n         place_context: PlaceContext<'tcx>,\n         location: Location,\n     ) {\n-        if !self.needles.contains(local) {\n-            return;\n-        }\n-\n-        if place_context.is_place_assignment() {\n+        if place_context.is_place_assignment() && self.temporary_used_locals.contains(local) {\n             // Propagate the Local assigned at this Location as a used mutable local variable\n             for moi in &self.mbcx.move_data.loc_map[location] {\n                 let mpi = &self.mbcx.move_data.moves[*moi].path;"}, {"sha": "54983b8f4e026abd40026540e985dd2095a7cd80", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -196,7 +196,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let source_info = SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE };\n \n     let return_block = BasicBlock::new(1);\n-    let mut blocks = IndexVec::new();\n+    let mut blocks = IndexVec::with_capacity(2);\n     let block = |blocks: &mut IndexVec<_, _>, kind| {\n         blocks.push(BasicBlockData {\n             statements: vec![],\n@@ -768,7 +768,8 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }));\n     }\n \n-    let mut blocks = IndexVec::new();\n+    let n_blocks = if let Adjustment::RefMut = rcvr_adjustment { 5 } else { 2 };\n+    let mut blocks = IndexVec::with_capacity(n_blocks);\n     let block = |blocks: &mut IndexVec<_, _>, statements, kind, is_cleanup| {\n         blocks.push(BasicBlockData {\n             statements,"}, {"sha": "2db3bbda3233bf8c895e0352a587511b4b92ceb2", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                 let callee_mir = match self.tcx.try_optimized_mir(callsite.location.span,\n                                                                   callsite.callee) {\n-                    Ok(callee_mir) if self.should_inline(callsite, callee_mir) => {\n+                    Ok(callee_mir) if self.consider_optimizing(callsite, callee_mir) => {\n                         self.tcx.subst_and_normalize_erasing_regions(\n                             &callsite.substs,\n                             param_env,\n@@ -198,6 +198,18 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n+    fn consider_optimizing(&self,\n+                           callsite: CallSite<'tcx>,\n+                           callee_mir: &Mir<'tcx>)\n+                           -> bool\n+    {\n+        debug!(\"consider_optimizing({:?})\", callsite);\n+        self.should_inline(callsite, callee_mir)\n+            && self.tcx.consider_optimizing(|| format!(\"Inline {:?} into {:?}\",\n+                                                       callee_mir.span,\n+                                                       callsite))\n+    }\n+\n     fn should_inline(&self,\n                      callsite: CallSite<'tcx>,\n                      callee_mir: &Mir<'tcx>)"}, {"sha": "c5add6260789a34e485f5852b45695cc3d093374", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -310,16 +310,11 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     match statement.kind {\n                         StatementKind::Assign(_, box Rvalue::Ref(_, _, ref mut place)) => {\n                             // Find the underlying local for this (necessarily interior) borrow.\n-                            // HACK(eddyb) using a recursive function because of mutable borrows.\n-                            fn interior_base<'a, 'tcx>(place: &'a mut Place<'tcx>)\n-                                                       -> &'a mut Place<'tcx> {\n-                                if let Place::Projection(ref mut proj) = *place {\n-                                    assert_ne!(proj.elem, ProjectionElem::Deref);\n-                                    return interior_base(&mut proj.base);\n-                                }\n-                                place\n-                            }\n-                            let place = interior_base(place);\n+                            let mut place = place;\n+                            while let Place::Projection(ref mut proj) = *place {\n+                                assert_ne!(proj.elem, ProjectionElem::Deref);\n+                                place = &mut proj.base;\n+                            };\n \n                             let ty = place.ty(local_decls, self.tcx).to_ty(self.tcx);\n                             let span = statement.source_info.span;"}, {"sha": "c87f14977cb1d5f50702d58e47874e6699835816", "filename": "src/librustc_target/spec/linux_musl_base.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_target%2Fspec%2Flinux_musl_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_target%2Fspec%2Flinux_musl_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Flinux_musl_base.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -24,31 +24,6 @@ pub fn opts() -> TargetOptions {\n     // argument is *not* necessary for normal builds, but it can't hurt!\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-Wl,--eh-frame-hdr\".to_string());\n \n-    // There's a whole bunch of circular dependencies when dealing with MUSL\n-    // unfortunately. To put this in perspective libc is statically linked to\n-    // liblibc and libunwind is statically linked to libstd:\n-    //\n-    // * libcore depends on `fmod` which is in libc (transitively in liblibc).\n-    //   liblibc, however, depends on libcore.\n-    // * compiler-rt has personality symbols that depend on libunwind, but\n-    //   libunwind is in libstd which depends on compiler-rt.\n-    //\n-    // Recall that linkers discard libraries and object files as much as\n-    // possible, and with all the static linking and archives flying around with\n-    // MUSL the linker is super aggressively stripping out objects. For example\n-    // the first case has fmod stripped from liblibc (it's in its own object\n-    // file) so it's not there when libcore needs it. In the second example all\n-    // the unused symbols from libunwind are stripped (each is in its own object\n-    // file in libstd) before we end up linking compiler-rt which depends on\n-    // those symbols.\n-    //\n-    // To deal with these circular dependencies we just force the compiler to\n-    // link everything as a group, not stripping anything out until everything\n-    // is processed. The linker will still perform a pass to strip out object\n-    // files but it won't do so until all objects/archives have been processed.\n-    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-Wl,-(\".to_string());\n-    base.post_link_args.insert(LinkerFlavor::Gcc, vec![\"-Wl,-)\".to_string()]);\n-\n     // When generating a statically linked executable there's generally some\n     // small setup needed which is listed in these files. These are provided by\n     // a musl toolchain and are linked by default by the `musl-gcc` script. Note"}, {"sha": "4a300fe09215cbfc01e2dbd068b409dbfb2e400e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -814,11 +814,6 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             report_unexpected_def(def);\n             return self.tcx.types.err;\n         }\n-        // Replace constructor type with constructed type for tuple struct patterns.\n-        let pat_ty = pat_ty.fn_sig(tcx).output();\n-        let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n-\n-        self.demand_eqtype(pat.span, expected, pat_ty);\n \n         let variant = match def {\n             Def::Err => {\n@@ -836,6 +831,13 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             }\n             _ => bug!(\"unexpected pattern definition: {:?}\", def)\n         };\n+\n+        // Replace constructor type with constructed type for tuple struct patterns.\n+        let pat_ty = pat_ty.fn_sig(tcx).output();\n+        let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n+\n+        self.demand_eqtype(pat.span, expected, pat_ty);\n+\n         // Type check subpatterns.\n         if subpats.len() == variant.fields.len() ||\n                 subpats.len() < variant.fields.len() && ddpos.is_some() {"}, {"sha": "1ae3b0b88c6dd5ea1f6120cf9471b7524da452d0", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -70,7 +70,7 @@\n /* General structure and fonts */\n \n body {\n-\tfont: 16px/1.4 \"Source Serif Pro\", Georgia, Times, \"Times New Roman\", serif;\n+\tfont: 16px/1.4 \"Source Serif Pro\", serif;\n \tmargin: 0;\n \tposition: relative;\n \tpadding: 10px 15px 20px 15px;\n@@ -114,7 +114,7 @@ h3.impl, h3.method, h3.type {\n h1, h2, h3, h4,\n .sidebar, a.source, .search-input, .content table :not(code)>a,\n .collapse-toggle, div.item-list .out-of-band {\n-\tfont-family: \"Fira Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n+\tfont-family: \"Fira Sans\", sans-serif;\n }\n \n ol, ul {\n@@ -133,7 +133,7 @@ summary {\n }\n \n code, pre {\n-\tfont-family: \"Source Code Pro\", Menlo, Monaco, Consolas, \"DejaVu Sans Mono\", Inconsolata, monospace;\n+\tfont-family: \"Source Code Pro\", monospace;\n \twhite-space: pre-wrap;\n }\n .docblock code, .docblock-short code {\n@@ -415,7 +415,7 @@ h4 > code, h3 > code, .invisible > code {\n }\n #main > .since {\n \ttop: inherit;\n-\tfont-family: \"Fira Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n+\tfont-family: \"Fira Sans\", sans-serif;\n }\n \n .content table:not(.table-display) {\n@@ -1338,7 +1338,7 @@ h3.important {\n kbd {\n \tdisplay: inline-block;\n \tpadding: 3px 5px;\n-\tfont: 15px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n+\tfont: 15px monospace;\n \tline-height: 10px;\n \tvertical-align: middle;\n \tborder: solid 1px;"}, {"sha": "96c92ceb5bb4127052b311a03b2ed4b5b86f6625", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -399,6 +399,8 @@ macro_rules! await {\n /// For more information about select, see the `std::sync::mpsc::Select` structure.\n #[macro_export]\n #[unstable(feature = \"mpsc_select\", issue = \"27800\")]\n+#[rustc_deprecated(since = \"1.32.0\",\n+                   reason = \"channel selection will be removed in a future release\")]\n macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+"}, {"sha": "059ced4f56efda5f3fea5e7ebcc63681d8d4f698", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -124,6 +124,7 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![allow(deprecated)] // for mpsc_select\n \n // A description of how Rust's channel implementation works\n //"}, {"sha": "2ec4b52dbf3cba3153f9db2721f227465a7a24a4", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -51,11 +51,10 @@\n #![unstable(feature = \"mpsc_select\",\n             reason = \"This implementation, while likely sufficient, is unsafe and \\\n                       likely to be error prone. At some point in the future this \\\n-                      module will likely be replaced, and it is currently \\\n-                      unknown how much API breakage that will cause. The ability \\\n-                      to select over a number of channels will remain forever, \\\n-                      but no guarantees beyond this are being made\",\n+                      module will be removed.\",\n             issue = \"27800\")]\n+#![rustc_deprecated(since = \"1.32.0\",\n+                    reason = \"channel selection will be removed in a future release\")]\n \n \n use fmt;"}, {"sha": "2f17bc0548cad75c77fa58445fff0e92e99ffea5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -1086,7 +1086,7 @@ pub enum ExprKind {\n     /// A unary operation (For example: `!x`, `*x`)\n     Unary(UnOp, P<Expr>),\n     /// A literal (For example: `1`, `\"foo\"`)\n-    Lit(P<Lit>),\n+    Lit(Lit),\n     /// A cast (`foo as f64`)\n     Cast(P<Expr>, P<Ty>),\n     Type(P<Expr>, P<Ty>),"}, {"sha": "88ee80e60888f93a2d8cace0b01a332e29443aa5", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -491,7 +491,7 @@ impl DummyResult {\n     pub fn raw_expr(sp: Span) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprKind::Lit(P(source_map::respan(sp, ast::LitKind::Bool(false)))),\n+            node: ast::ExprKind::Lit(source_map::respan(sp, ast::LitKind::Bool(false))),\n             span: sp,\n             attrs: ThinVec::new(),\n         })"}, {"sha": "cacec867cf198053cc6b187d4bf9cba2db551dcb", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -695,7 +695,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_lit(&self, sp: Span, lit: ast::LitKind) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Lit(P(respan(sp, lit))))\n+        self.expr(sp, ast::ExprKind::Lit(respan(sp, lit)))\n     }\n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n         self.expr_lit(span, ast::LitKind::Int(i as u128,"}, {"sha": "c6e0adbb5a43e087a73b867cd13843dcc1db37a5", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -274,7 +274,7 @@ pub mod rt {\n             // FIXME: This is wrong\n             P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprKind::Lit(P(self.clone())),\n+                node: ast::ExprKind::Lit(self.clone()),\n                 span: DUMMY_SP,\n                 attrs: ThinVec::new(),\n             }).to_tokens(cx)\n@@ -305,7 +305,7 @@ pub mod rt {\n                     let lit = ast::LitKind::Int(val as u128, ast::LitIntType::Signed($tag));\n                     let lit = P(ast::Expr {\n                         id: ast::DUMMY_NODE_ID,\n-                        node: ast::ExprKind::Lit(P(dummy_spanned(lit))),\n+                        node: ast::ExprKind::Lit(dummy_spanned(lit)),\n                         span: DUMMY_SP,\n                         attrs: ThinVec::new(),\n                     });"}, {"sha": "68e7e40c43efe4a1b74c035905c376c629e5662f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -1989,7 +1989,7 @@ impl<'a> Parser<'a> {\n         let minus_lo = self.span;\n         let minus_present = self.eat(&token::BinOp(token::Minus));\n         let lo = self.span;\n-        let literal = P(self.parse_lit()?);\n+        let literal = self.parse_lit()?;\n         let hi = self.prev_span;\n         let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), ThinVec::new());\n "}, {"sha": "f00b7f3a58f9c2c91e95a263535c4a9039c5020e", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -1237,6 +1237,40 @@ extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n       unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles, Name));\n }\n \n+extern \"C\" LLVMValueRef LLVMRustBuildMemCpy(LLVMBuilderRef B,\n+                                            LLVMValueRef Dst, unsigned DstAlign,\n+                                            LLVMValueRef Src, unsigned SrcAlign,\n+                                            LLVMValueRef Size, bool IsVolatile) {\n+#if LLVM_VERSION_GE(7, 0)\n+  return wrap(unwrap(B)->CreateMemCpy(\n+      unwrap(Dst), DstAlign,\n+      unwrap(Src), SrcAlign,\n+      unwrap(Size), IsVolatile));\n+#else\n+  unsigned Align = std::min(DstAlign, SrcAlign);\n+  return wrap(unwrap(B)->CreateMemCpy(\n+      unwrap(Dst), unwrap(Src),\n+      unwrap(Size), Align, IsVolatile));\n+#endif\n+}\n+\n+extern \"C\" LLVMValueRef LLVMRustBuildMemMove(LLVMBuilderRef B,\n+                                             LLVMValueRef Dst, unsigned DstAlign,\n+                                             LLVMValueRef Src, unsigned SrcAlign,\n+                                             LLVMValueRef Size, bool IsVolatile) {\n+#if LLVM_VERSION_GE(7, 0)\n+  return wrap(unwrap(B)->CreateMemMove(\n+      unwrap(Dst), DstAlign,\n+      unwrap(Src), SrcAlign,\n+      unwrap(Size), IsVolatile));\n+#else\n+  unsigned Align = std::min(DstAlign, SrcAlign);\n+  return wrap(unwrap(B)->CreateMemMove(\n+      unwrap(Dst), unwrap(Src),\n+      unwrap(Size), Align, IsVolatile));\n+#endif\n+}\n+\n extern \"C\" LLVMValueRef\n LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n                     unsigned NumArgs, LLVMBasicBlockRef Then,"}, {"sha": "b50f5b6f16fedad9743b5be8b2be36fea7a6eb7b", "filename": "src/test/codegen/packed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fcodegen%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fcodegen%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpacked.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -65,7 +65,7 @@ pub struct BigPacked2 {\n pub fn call_pkd1(f: fn() -> Array) -> BigPacked1 {\n // CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n // CHECK: call void %{{.*}}(%Array* noalias nocapture sret dereferenceable(32) [[ALLOCA]])\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 %{{.*}}, i8* align 1 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 %{{.*}}, i8* align 4 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n     // check that calls whose destination is a field of a packed struct\n     // go through an alloca rather than calling the function with an\n     // unaligned destination.\n@@ -77,7 +77,7 @@ pub fn call_pkd1(f: fn() -> Array) -> BigPacked1 {\n pub fn call_pkd2(f: fn() -> Array) -> BigPacked2 {\n // CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n // CHECK: call void %{{.*}}(%Array* noalias nocapture sret dereferenceable(32) [[ALLOCA]])\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 2 %{{.*}}, i8* align 2 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 2 %{{.*}}, i8* align 4 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n     // check that calls whose destination is a field of a packed struct\n     // go through an alloca rather than calling the function with an\n     // unaligned destination."}, {"sha": "871bee13b1931eddf04b259ad387f3bd2cb70f08", "filename": "src/test/codegen/stores.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fcodegen%2Fstores.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fcodegen%2Fstores.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstores.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -31,7 +31,7 @@ pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n // CHECK: store i32 %0, i32* [[TMP]]\n // CHECK: [[Y8:%[0-9]+]] = bitcast [4 x i8]* %y to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 [[Y8]], i8* align 1 [[TMP8]], i{{[0-9]+}} 4, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 [[Y8]], i8* align 4 [[TMP8]], i{{[0-9]+}} 4, i1 false)\n     *x = y;\n }\n \n@@ -45,6 +45,6 @@ pub fn small_struct_alignment(x: &mut Bytes, y: Bytes) {\n // CHECK: store i32 %0, i32* [[TMP]]\n // CHECK: [[Y8:%[0-9]+]] = bitcast %Bytes* %y to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 [[Y8]], i8* align 1 [[TMP8]], i{{[0-9]+}} 4, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 [[Y8]], i8* align 4 [[TMP8]], i{{[0-9]+}} 4, i1 false)\n     *x = y;\n }"}, {"sha": "a31ad72b0881a8228f15dfce376e5f0f88ab2c78", "filename": "src/test/run-pass/issues/issue-13494.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13494.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -16,6 +16,7 @@\n // expose is still present.\n \n #![feature(mpsc_select)]\n+#![allow(deprecated)]\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::thread;"}, {"sha": "dc417957795f5b3b6765e7ea37de569e47ee7cce", "filename": "src/test/ui/coherence/coherence-impls-copy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-copy.stderr?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -14,7 +14,7 @@ LL | impl Copy for &'static NotSync {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: conflicting implementation in crate `core`:\n-           - impl<'_, T> std::marker::Copy for &T\n+           - impl<T> std::marker::Copy for &T\n              where T: ?Sized;\n \n error[E0119]: conflicting implementations of trait `std::marker::Copy` for type `&[NotSync]`:\n@@ -24,7 +24,7 @@ LL | impl Copy for &'static [NotSync] {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: conflicting implementation in crate `core`:\n-           - impl<'_, T> std::marker::Copy for &T\n+           - impl<T> std::marker::Copy for &T\n              where T: ?Sized;\n \n error[E0206]: the trait `Copy` may not be implemented for this type"}, {"sha": "76ff88d6cc62346b52412741cd1026668d7b5627", "filename": "src/test/ui/e0119/issue-28981.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fe0119%2Fissue-28981.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fe0119%2Fissue-28981.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fe0119%2Fissue-28981.stderr?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -5,7 +5,7 @@ LL | impl<Foo> Deref for Foo { } //~ ERROR must be used\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: conflicting implementation in crate `core`:\n-           - impl<'_, T> std::ops::Deref for &T\n+           - impl<T> std::ops::Deref for &T\n              where T: ?Sized;\n \n error[E0210]: type parameter `Foo` must be used as the type parameter for some local type (e.g. `MyStruct<Foo>`)"}, {"sha": "dca5698a70c20792d6eb8eebf50866bbd3cc42de", "filename": "src/test/ui/extern/extern-const.fixed", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fextern%2Fextern-const.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fextern%2Fextern-const.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-const.fixed?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -0,0 +1,25 @@\n+// Check extern items cannot be const + `rustfix` suggests using\n+// extern static.\n+//\n+// #54388: an unused reference to an undefined static may or may not\n+// compile. To sidestep this by using one that *is* defined.\n+\n+// run-rustfix\n+// ignore-wasm32 no external library to link to.\n+// compile-flags: -g -Z continue-parse-after-error\n+#![feature(libc)]\n+extern crate libc;\n+\n+#[link(name = \"rust_test_helpers\", kind = \"static\")]\n+extern \"C\" {\n+    static rust_dbg_static_mut: libc::c_int; //~ ERROR extern items cannot be `const`\n+}\n+\n+fn main() {\n+    // We suggest turning the (illegal) extern `const` into an extern `static`,\n+    // but this also requires `unsafe` (a deny-by-default lint at comment time,\n+    // future error; Issue #36247)\n+    unsafe {\n+        let _x = rust_dbg_static_mut;\n+    }\n+}"}, {"sha": "07dbe545a850a46c26fb7e68abd58a3e88e68752", "filename": "src/test/ui/extern/extern-const.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fextern%2Fextern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fextern%2Fextern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-const.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -1,25 +1,25 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n+// Check extern items cannot be const + `rustfix` suggests using\n+// extern static.\n //\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// #54388: an unused reference to an undefined static may or may not\n+// compile. To sidestep this by using one that *is* defined.\n \n-// FIXME(#54388): re-enable rustfix later, when this test has consistent output across targets\n-// compile-flags: -Z continue-parse-after-error\n+// run-rustfix\n+// ignore-wasm32 no external library to link to.\n+// compile-flags: -g -Z continue-parse-after-error\n+#![feature(libc)]\n+extern crate libc;\n \n+#[link(name = \"rust_test_helpers\", kind = \"static\")]\n extern \"C\" {\n-    const C: u8; //~ ERROR extern items cannot be `const`\n+    const rust_dbg_static_mut: libc::c_int; //~ ERROR extern items cannot be `const`\n }\n \n fn main() {\n     // We suggest turning the (illegal) extern `const` into an extern `static`,\n     // but this also requires `unsafe` (a deny-by-default lint at comment time,\n     // future error; Issue #36247)\n     unsafe {\n-        let _x = C;\n+        let _x = rust_dbg_static_mut;\n     }\n }"}, {"sha": "7ebaec0368e3d46f53c4f429a6fc3aad5e0f0343", "filename": "src/test/ui/extern/extern-const.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fextern%2Fextern-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fextern%2Fextern-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-const.stderr?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -1,7 +1,7 @@\n error: extern items cannot be `const`\n   --> $DIR/extern-const.rs:15:5\n    |\n-LL |     const C: u8; //~ ERROR extern items cannot be `const`\n+LL |     const rust_dbg_static_mut: libc::c_int; //~ ERROR extern items cannot be `const`\n    |     ^^^^^ help: try using a static value: `static`\n \n error: aborting due to previous error"}, {"sha": "7ebc348996f5e7bfa40a8c6145b9e457ffffd63c", "filename": "src/test/ui/impl-trait/issue-55608-captures-empty-region.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -0,0 +1,22 @@\n+// This used to ICE because it creates an `impl Trait` that captures a\n+// hidden empty region.\n+\n+#![feature(conservative_impl_trait)]\n+\n+fn server() -> impl FilterBase2 { //~ ERROR [E0700]\n+    segment2(|| { loop { } }).map2(|| \"\")\n+}\n+\n+trait FilterBase2 {\n+    fn map2<F>(self, _fn: F) -> Map2<F> where Self: Sized { loop { } }\n+}\n+\n+struct Map2<F> { _func: F }\n+\n+impl<F> FilterBase2 for Map2<F> { }\n+\n+fn segment2<F>(_fn: F) -> Map2<F> where F: Fn() -> Result<(), ()> {\n+    loop { }\n+}\n+\n+fn main() { server(); }"}, {"sha": "d1f147834d2efa0d7b9a83a26af29ce624f343f1", "filename": "src/test/ui/impl-trait/issue-55608-captures-empty-region.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.stderr?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -0,0 +1,11 @@\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/issue-55608-captures-empty-region.rs:6:16\n+   |\n+LL | fn server() -> impl FilterBase2 { //~ ERROR [E0700]\n+   |                ^^^^^^^^^^^^^^^^\n+   |\n+   = note: hidden type `Map2<[closure@$DIR/issue-55608-captures-empty-region.rs:7:36: 7:41]>` captures an empty lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "d9c50e75c494486abc32cd65a8d8b149b673977a", "filename": "src/test/ui/match/match-fn-call.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fmatch%2Fmatch-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fmatch%2Fmatch-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-fn-call.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -0,0 +1,12 @@\n+use std::path::Path;\n+\n+fn main() {\n+    let path = Path::new(\"foo\");\n+    match path {\n+        Path::new(\"foo\") => println!(\"foo\"),\n+        //~^ ERROR expected tuple struct/variant\n+        Path::new(\"bar\") => println!(\"bar\"),\n+        //~^ ERROR expected tuple struct/variant\n+        _ => (),\n+    }\n+}"}, {"sha": "4e24621706bdb91864ed914339081cd3d6d51b6f", "filename": "src/test/ui/match/match-fn-call.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fmatch%2Fmatch-fn-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fmatch%2Fmatch-fn-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-fn-call.stderr?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -0,0 +1,15 @@\n+error[E0164]: expected tuple struct/variant, found method `<Path>::new`\n+  --> $DIR/match-fn-call.rs:6:9\n+   |\n+LL |         Path::new(\"foo\") => println!(\"foo\"),\n+   |         ^^^^^^^^^^^^^^^^ not a tuple variant or struct\n+\n+error[E0164]: expected tuple struct/variant, found method `<Path>::new`\n+  --> $DIR/match-fn-call.rs:8:9\n+   |\n+LL |         Path::new(\"bar\") => println!(\"bar\"),\n+   |         ^^^^^^^^^^^^^^^^ not a tuple variant or struct\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0164`."}, {"sha": "131c979a24b7d414a0939a6d90013146c98863e8", "filename": "src/test/ui/nll/issue-55344.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fnll%2Fissue-55344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a50c29f6c5c386fba6ab685818755ac55152e5/src%2Ftest%2Fui%2Fnll%2Fissue-55344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55344.rs?ref=36a50c29f6c5c386fba6ab685818755ac55152e5", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![feature(nll)]\n+#![allow(unreachable_code)]\n+#![deny(unused_mut)]\n+\n+pub fn foo() {\n+    return;\n+\n+    let mut v = 0;\n+    assert_eq!(v, 0);\n+    v = 1;\n+    assert_eq!(v, 1);\n+}\n+\n+fn main() {}"}]}