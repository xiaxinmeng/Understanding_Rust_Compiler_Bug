{"sha": "05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YWZlMTVkMWY3YjI5YjVmOGYwMDZmNmU5ZWMxNmM4YTdjZDRhMGM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-05T01:58:59Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T03:22:47Z"}, "message": "Refactor `record_used: bool` -> `record_used: Option<Span>`.", "tree": {"sha": "20669e7ea74a08efb7542d55a70fda279d61d09e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20669e7ea74a08efb7542d55a70fda279d61d09e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c", "html_url": "https://github.com/rust-lang/rust/commit/05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75c3fd89d47d6da340ef6c1b98e80968d0218337", "url": "https://api.github.com/repos/rust-lang/rust/commits/75c3fd89d47d6da340ef6c1b98e80968d0218337", "html_url": "https://github.com/rust-lang/rust/commit/75c3fd89d47d6da340ef6c1b98e80968d0218337"}], "stats": {"total": 39, "additions": 22, "deletions": 17}, "files": [{"sha": "f200ae2f75873eec402ac1872f6b55d1edf82a38", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c", "patch": "@@ -1246,7 +1246,7 @@ impl<'a> Resolver<'a> {\n                                      -> ResolveResult<Module<'a>> {\n         fn search_parent_externals<'a>(this: &mut Resolver<'a>, needle: Name, module: Module<'a>)\n                                        -> Option<Module<'a>> {\n-            match this.resolve_name_in_module(module, needle, TypeNS, false, false) {\n+            match this.resolve_name_in_module(module, needle, TypeNS, false, None) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n                 _ => match module.parent_link {\n                     ModuleParentLink(ref parent, _) => {\n@@ -1265,7 +1265,7 @@ impl<'a> Resolver<'a> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index];\n-            match self.resolve_name_in_module(search_module, name, TypeNS, false, true) {\n+            match self.resolve_name_in_module(search_module, name, TypeNS, false, Some(span)) {\n                 Failed(None) => {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n@@ -1361,7 +1361,7 @@ impl<'a> Resolver<'a> {\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n                         let ident = ast::Ident::with_empty_ctxt(module_path[0]);\n-                        match self.resolve_ident_in_lexical_scope(ident, TypeNS, true)\n+                        match self.resolve_ident_in_lexical_scope(ident, TypeNS, Some(span))\n                                   .and_then(LexicalScopeBinding::module) {\n                             None => return Failed(None),\n                             Some(containing_module) => {\n@@ -1404,7 +1404,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_ident_in_lexical_scope(&mut self,\n                                       mut ident: ast::Ident,\n                                       ns: Namespace,\n-                                      record_used: bool)\n+                                      record_used: Option<Span>)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n             ident = ast::Ident::with_empty_ctxt(ident.name);\n@@ -1432,7 +1432,7 @@ impl<'a> Resolver<'a> {\n                 if module.def.is_some() {\n                     return match self.prelude {\n                         Some(prelude) if !module.no_implicit_prelude.get() => {\n-                            self.resolve_name_in_module(prelude, name, ns, false, false).success()\n+                            self.resolve_name_in_module(prelude, name, ns, false, None).success()\n                                 .map(LexicalScopeBinding::Item)\n                         }\n                         _ => None,\n@@ -2287,7 +2287,7 @@ impl<'a> Resolver<'a> {\n                 PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n-                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS, false)\n+                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS, None)\n                                       .and_then(LexicalScopeBinding::item);\n                     let resolution = binding.and_then(NameBinding::def).and_then(|def| {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n@@ -2454,11 +2454,11 @@ impl<'a> Resolver<'a> {\n             //\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n-            let def = resolve_identifier_with_fallback(self, true).ok_or(false);\n+            let def = resolve_identifier_with_fallback(self, Some(span)).ok_or(false);\n             return def.and_then(|def| self.adjust_local_def(def, span).ok_or(true)).map(mk_res);\n         }\n \n-        let unqualified_def = resolve_identifier_with_fallback(self, false);\n+        let unqualified_def = resolve_identifier_with_fallback(self, None);\n         let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n         match (qualified_binding, unqualified_def) {\n             (Ok(binding), Some(ref ud)) if binding.def().unwrap() == ud.def => {\n@@ -2478,7 +2478,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_identifier(&mut self,\n                           identifier: ast::Ident,\n                           namespace: Namespace,\n-                          record_used: bool)\n+                          record_used: Option<Span>)\n                           -> Option<LocalDef> {\n         if identifier.name == keywords::Invalid.name() {\n             return None;\n@@ -2613,7 +2613,8 @@ impl<'a> Resolver<'a> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n+        let result =\n+            self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n         result.success().map(|binding| {\n             self.check_privacy(name, binding, span);\n             binding\n@@ -2657,7 +2658,8 @@ impl<'a> Resolver<'a> {\n         }\n \n         let name = segments.last().unwrap().name();\n-        let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n+        let result =\n+            self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n         result.success().map(|binding| {\n             self.check_privacy(name, binding, span);\n             binding"}, {"sha": "28401b2e240f0f1e20837431d8e4ba67e53e7cec", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c", "patch": "@@ -149,7 +149,7 @@ impl<'a> Resolver<'a> {\n                                   name: Name,\n                                   ns: Namespace,\n                                   allow_private_imports: bool,\n-                                  record_used: bool)\n+                                  record_used: Option<Span>)\n                                   -> ResolveResult<&'a NameBinding<'a>> {\n         self.populate_module_if_necessary(module);\n \n@@ -165,7 +165,7 @@ impl<'a> Resolver<'a> {\n                 if !allow_private_imports && binding.is_import() && !binding.is_pseudo_public() {\n                     return Failed(None);\n                 }\n-                if record_used {\n+                if record_used.is_some() {\n                     self.record_use(name, ns, binding);\n                 }\n                 Success(binding)\n@@ -176,7 +176,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.globs.borrow().iter() {\n             if !allow_private_imports && directive.vis != ty::Visibility::Public { continue }\n             if let Some(target_module) = directive.target_module.get() {\n-                let result = self.resolve_name_in_module(target_module, name, ns, false, false);\n+                let result = self.resolve_name_in_module(target_module, name, ns, false, None);\n                 if let Indeterminate = result {\n                     return Indeterminate;\n                 }\n@@ -222,7 +222,7 @@ impl<'a> Resolver<'a> {\n                     SingleImport { source, .. } => source,\n                     GlobImport { .. } => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(target_module, name, ns, false, false) {\n+                match self.resolve_name_in_module(target_module, name, ns, false, None) {\n                     Failed(_) => {}\n                     _ => return Some(Indeterminate),\n                 }\n@@ -495,8 +495,11 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n-        let value_result = self.resolve_name_in_module(target_module, source, ValueNS, false, true);\n-        let type_result = self.resolve_name_in_module(target_module, source, TypeNS, false, true);\n+        let span = directive.span;\n+        let value_result =\n+            self.resolve_name_in_module(target_module, source, ValueNS, false, Some(span));\n+        let type_result =\n+            self.resolve_name_in_module(target_module, source, TypeNS, false, Some(span));\n \n         let mut privacy_error = true;\n         for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),"}]}