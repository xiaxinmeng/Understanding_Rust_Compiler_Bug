{"sha": "c51c377982694d1ed3d545099f4262635defb284", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MWMzNzc5ODI2OTRkMWVkM2Q1NDUwOTlmNDI2MjYzNWRlZmIyODQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-24T21:51:37Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-24T21:51:37Z"}, "message": "Rollup merge of #22539 - oli-obk:style_nitpicks, r=Manishearth\n\n I tried to follow [the style guide][1] as much as possible. This is just from some random readings of the code, so no guarantees on completeness, even in the edited files.\n\n[1]: http://aturon.github.io/style/README.html", "tree": {"sha": "f60efe7ffaeddcb78e162beb9d1188e5a93858d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f60efe7ffaeddcb78e162beb9d1188e5a93858d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c51c377982694d1ed3d545099f4262635defb284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c51c377982694d1ed3d545099f4262635defb284", "html_url": "https://github.com/rust-lang/rust/commit/c51c377982694d1ed3d545099f4262635defb284", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c51c377982694d1ed3d545099f4262635defb284/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a429bf6a2497ddc7ebe941f59548880b6e381bc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a429bf6a2497ddc7ebe941f59548880b6e381bc8", "html_url": "https://github.com/rust-lang/rust/commit/a429bf6a2497ddc7ebe941f59548880b6e381bc8"}, {"sha": "0bea550a2a78eba05533f333cc2a0e7f9b5b44e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bea550a2a78eba05533f333cc2a0e7f9b5b44e8", "html_url": "https://github.com/rust-lang/rust/commit/0bea550a2a78eba05533f333cc2a0e7f9b5b44e8"}], "stats": {"total": 572, "additions": 251, "deletions": 321}, "files": [{"sha": "532aee1c3fd62d1f7ad9f4cb7d43e1bfb531aef4", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c51c377982694d1ed3d545099f4262635defb284/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c51c377982694d1ed3d545099f4262635defb284/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=c51c377982694d1ed3d545099f4262635defb284", "patch": "@@ -347,7 +347,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             let result = stack.with(move |pusher, node| {\n                 // Same basic logic as found in `find`, but with PartialSearchStack mediating the\n                 // actual nodes for us\n-                return match Node::search(node, &key) {\n+                match Node::search(node, &key) {\n                     Found(mut handle) => {\n                         // Perfect match, swap the values and return the old one\n                         mem::swap(handle.val_mut(), &mut value);\n@@ -372,7 +372,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 }\n             });\n             match result {\n-                Finished(ret) => { return ret; },\n+                Finished(ret) => return ret,\n                 Continue((new_stack, renewed_key, renewed_val)) => {\n                     stack = new_stack;\n                     key = renewed_key;\n@@ -439,7 +439,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n             let result = stack.with(move |pusher, node| {\n-                return match Node::search(node, key) {\n+                match Node::search(node, key) {\n                     Found(handle) => {\n                         // Perfect match. Terminate the stack here, and remove the entry\n                         Finished(Some(pusher.seal(handle).remove()))\n@@ -1560,7 +1560,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n             let result = stack.with(move |pusher, node| {\n-                return match Node::search(node, &key) {\n+                match Node::search(node, &key) {\n                     Found(handle) => {\n                         // Perfect match\n                         Finished(Occupied(OccupiedEntry {"}, {"sha": "07082d818769c44ba1d2cf25e5528b396fe1f346", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c51c377982694d1ed3d545099f4262635defb284/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c51c377982694d1ed3d545099f4262635defb284/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=c51c377982694d1ed3d545099f4262635defb284", "patch": "@@ -736,12 +736,10 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n             }\n         };\n         return match ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar)) {\n-            None => {\n-                return Err((format!(\"failed to read rlib metadata: '{}'\",\n-                                    filename.display())))\n-            }\n-            Some(blob) => return Ok(blob)\n-        }\n+            None => Err(format!(\"failed to read rlib metadata: '{}'\",\n+                                filename.display())),\n+            Some(blob) => Ok(blob)\n+        };\n     }\n     unsafe {\n         let buf = CString::new(filename.as_vec()).unwrap();\n@@ -791,7 +789,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        return Err(format!(\"metadata not found: '{}'\", filename.display()));\n+        Err(format!(\"metadata not found: '{}'\", filename.display()))\n     }\n }\n "}, {"sha": "38dd9a4d6ecf14d9a6122f0597fa2b1f6d4b6b9b", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 167, "deletions": 185, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/c51c377982694d1ed3d545099f4262635defb284/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c51c377982694d1ed3d545099f4262635defb284/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=c51c377982694d1ed3d545099f4262635defb284", "patch": "@@ -228,11 +228,11 @@ pub trait Combine<'tcx> : Sized {\n                              variadic: a.variadic});\n \n \n-        fn argvecs<'tcx, C: Combine<'tcx>>(combiner: &C,\n-                                           a_args: &[Ty<'tcx>],\n-                                           b_args: &[Ty<'tcx>])\n-                                           -> cres<'tcx, Vec<Ty<'tcx>>>\n-        {\n+        fn argvecs<'tcx, C>(combiner: &C,\n+                            a_args: &[Ty<'tcx>],\n+                            b_args: &[Ty<'tcx>])\n+                            -> cres<'tcx, Vec<Ty<'tcx>>>\n+                            where C: Combine<'tcx> {\n             if a_args.len() == b_args.len() {\n                 a_args.iter().zip(b_args.iter())\n                     .map(|(a, b)| combiner.args(*a, *b)).collect()\n@@ -351,51 +351,51 @@ pub trait Combineable<'tcx> : Repr<'tcx> + TypeFoldable<'tcx> {\n impl<'tcx,T> Combineable<'tcx> for Rc<T>\n     where T : Combineable<'tcx>\n {\n-    fn combine<C:Combine<'tcx>>(combiner: &C,\n-                                a: &Rc<T>,\n-                                b: &Rc<T>)\n-                                -> cres<'tcx, Rc<T>>\n-    {\n+    fn combine<C>(combiner: &C,\n+                  a: &Rc<T>,\n+                  b: &Rc<T>)\n+                  -> cres<'tcx, Rc<T>>\n+                  where C: Combine<'tcx> {\n         Ok(Rc::new(try!(Combineable::combine(combiner, &**a, &**b))))\n     }\n }\n \n impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n-    fn combine<C:Combine<'tcx>>(combiner: &C,\n-                                a: &ty::TraitRef<'tcx>,\n-                                b: &ty::TraitRef<'tcx>)\n-                                -> cres<'tcx, ty::TraitRef<'tcx>>\n-    {\n+    fn combine<C>(combiner: &C,\n+                  a: &ty::TraitRef<'tcx>,\n+                  b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>>\n+                  where C: Combine<'tcx> {\n         combiner.trait_refs(a, b)\n     }\n }\n \n impl<'tcx> Combineable<'tcx> for Ty<'tcx> {\n-    fn combine<C:Combine<'tcx>>(combiner: &C,\n-                                a: &Ty<'tcx>,\n-                                b: &Ty<'tcx>)\n-                                -> cres<'tcx, Ty<'tcx>>\n-    {\n+    fn combine<C>(combiner: &C,\n+                  a: &Ty<'tcx>,\n+                  b: &Ty<'tcx>)\n+                  -> cres<'tcx, Ty<'tcx>>\n+                  where C: Combine<'tcx> {\n         combiner.tys(*a, *b)\n     }\n }\n \n impl<'tcx> Combineable<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn combine<C:Combine<'tcx>>(combiner: &C,\n-                                a: &ty::ProjectionPredicate<'tcx>,\n-                                b: &ty::ProjectionPredicate<'tcx>)\n-                                -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n-    {\n+    fn combine<C>(combiner: &C,\n+                  a: &ty::ProjectionPredicate<'tcx>,\n+                  b: &ty::ProjectionPredicate<'tcx>)\n+                  -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n+                  where C: Combine<'tcx> {\n         combiner.projection_predicates(a, b)\n     }\n }\n \n impl<'tcx> Combineable<'tcx> for ty::FnSig<'tcx> {\n-    fn combine<C:Combine<'tcx>>(combiner: &C,\n-                                a: &ty::FnSig<'tcx>,\n-                                b: &ty::FnSig<'tcx>)\n-                                -> cres<'tcx, ty::FnSig<'tcx>>\n-    {\n+    fn combine<C>(combiner: &C,\n+                  a: &ty::FnSig<'tcx>,\n+                  b: &ty::FnSig<'tcx>)\n+                  -> cres<'tcx, ty::FnSig<'tcx>>\n+                  where C: Combine<'tcx> {\n         combiner.fn_sigs(a, b)\n     }\n }\n@@ -407,38 +407,38 @@ pub struct CombineFields<'a, 'tcx: 'a> {\n     pub trace: TypeTrace<'tcx>,\n }\n \n-pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n-        this: &C, a: T, b: T) -> ty::expected_found<T> {\n+pub fn expected_found<'tcx, C, T>(this: &C,\n+                                  a: T,\n+                                  b: T)\n+                                  -> ty::expected_found<T>\n+                                  where C: Combine<'tcx> {\n     if this.a_is_expected() {\n         ty::expected_found {expected: a, found: b}\n     } else {\n         ty::expected_found {expected: b, found: a}\n     }\n }\n \n-pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n-                                         a: Ty<'tcx>,\n-                                         b: Ty<'tcx>)\n-                                         -> cres<'tcx, Ty<'tcx>>\n-{\n+pub fn super_tys<'tcx, C>(this: &C,\n+                          a: Ty<'tcx>,\n+                          b: Ty<'tcx>)\n+                          -> cres<'tcx, Ty<'tcx>>\n+                          where C: Combine<'tcx> {\n     let tcx = this.infcx().tcx;\n     let a_sty = &a.sty;\n     let b_sty = &b.sty;\n     debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n     return match (a_sty, b_sty) {\n-      // The \"subtype\" ought to be handling cases involving var:\n-      (&ty::ty_infer(TyVar(_)), _) |\n-      (_, &ty::ty_infer(TyVar(_))) => {\n-        tcx.sess.bug(\n-            &format!(\"{}: bot and var types should have been handled ({},{})\",\n-                    this.tag(),\n-                    a.repr(this.infcx().tcx),\n-                    b.repr(this.infcx().tcx)));\n-      }\n-\n-      (&ty::ty_err, _) | (_, &ty::ty_err) => {\n-          Ok(tcx.types.err)\n-      }\n+        // The \"subtype\" ought to be handling cases involving var:\n+        (&ty::ty_infer(TyVar(_)), _)\n+        | (_, &ty::ty_infer(TyVar(_))) =>\n+            tcx.sess.bug(\n+                &format!(\"{}: bot and var types should have been handled ({},{})\",\n+                this.tag(),\n+                a.repr(this.infcx().tcx),\n+                b.repr(this.infcx().tcx))),\n+\n+        (&ty::ty_err, _) | (_, &ty::ty_err) => Ok(tcx.types.err),\n \n         // Relate integral variables to other types\n         (&ty::ty_infer(IntVar(a_id)), &ty::ty_infer(IntVar(b_id))) => {\n@@ -475,68 +475,62 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             unify_float_variable(this, !this.a_is_expected(), v_id, v)\n         }\n \n-      (&ty::ty_char, _) |\n-      (&ty::ty_bool, _) |\n-      (&ty::ty_int(_), _) |\n-      (&ty::ty_uint(_), _) |\n-      (&ty::ty_float(_), _) => {\n-        if a == b {\n-            Ok(a)\n-        } else {\n-            Err(ty::terr_sorts(expected_found(this, a, b)))\n-        }\n-      }\n-\n-      (&ty::ty_param(ref a_p), &ty::ty_param(ref b_p)) if\n-          a_p.idx == b_p.idx && a_p.space == b_p.space => {\n-        Ok(a)\n-      }\n-\n-      (&ty::ty_enum(a_id, a_substs),\n-       &ty::ty_enum(b_id, b_substs))\n-      if a_id == b_id => {\n-          let substs = try!(this.substs(a_id,\n-                                          a_substs,\n-                                          b_substs));\n-          Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n-      }\n-\n-      (&ty::ty_trait(ref a_),\n-       &ty::ty_trait(ref b_)) => {\n-          debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n-          let principal = try!(this.binders(&a_.principal, &b_.principal));\n-          let bounds = try!(this.existential_bounds(&a_.bounds, &b_.bounds));\n-          Ok(ty::mk_trait(tcx, principal, bounds))\n-      }\n-\n-      (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n-      if a_id == b_id => {\n+        (&ty::ty_char, _)\n+        | (&ty::ty_bool, _)\n+        | (&ty::ty_int(_), _)\n+        | (&ty::ty_uint(_), _)\n+        | (&ty::ty_float(_), _) => {\n+            if a == b {\n+                Ok(a)\n+            } else {\n+                Err(ty::terr_sorts(expected_found(this, a, b)))\n+            }\n+        }\n+\n+        (&ty::ty_param(ref a_p), &ty::ty_param(ref b_p)) if\n+          a_p.idx == b_p.idx && a_p.space == b_p.space => Ok(a),\n+\n+        (&ty::ty_enum(a_id, a_substs), &ty::ty_enum(b_id, b_substs))\n+          if a_id == b_id => {\n+            let substs = try!(this.substs(a_id, a_substs, b_substs));\n+            Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_trait(ref a_), &ty::ty_trait(ref b_)) => {\n+            debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n+            let principal = try!(this.binders(&a_.principal, &b_.principal));\n+            let bounds = try!(this.existential_bounds(&a_.bounds, &b_.bounds));\n+            Ok(ty::mk_trait(tcx, principal, bounds))\n+        }\n+\n+        (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n+          if a_id == b_id => {\n             let substs = try!(this.substs(a_id, a_substs, b_substs));\n             Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n-      }\n-\n-      (&ty::ty_closure(a_id, a_region, a_substs),\n-       &ty::ty_closure(b_id, b_region, b_substs))\n-      if a_id == b_id => {\n-          // All ty_closure types with the same id represent\n-          // the (anonymous) type of the same closure expression. So\n-          // all of their regions should be equated.\n-          let region = try!(this.equate().regions(*a_region, *b_region));\n-          let substs = try!(this.substs_variances(None, a_substs, b_substs));\n-          Ok(ty::mk_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n-      }\n-\n-      (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n-          let typ = try!(this.tys(a_inner, b_inner));\n-          Ok(ty::mk_uniq(tcx, typ))\n-      }\n-\n-      (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-          let mt = try!(this.mts(a_mt, b_mt));\n-          Ok(ty::mk_ptr(tcx, mt))\n-      }\n-\n-      (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n+        }\n+\n+        (&ty::ty_closure(a_id, a_region, a_substs),\n+         &ty::ty_closure(b_id, b_region, b_substs))\n+          if a_id == b_id => {\n+            // All ty_closure types with the same id represent\n+            // the (anonymous) type of the same closure expression. So\n+            // all of their regions should be equated.\n+            let region = try!(this.equate().regions(*a_region, *b_region));\n+            let substs = try!(this.substs_variances(None, a_substs, b_substs));\n+            Ok(ty::mk_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n+            let typ = try!(this.tys(a_inner, b_inner));\n+            Ok(ty::mk_uniq(tcx, typ))\n+        }\n+\n+        (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n+            let mt = try!(this.mts(a_mt, b_mt));\n+            Ok(ty::mk_ptr(tcx, mt))\n+        }\n+\n+        (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n             let r = try!(this.regions_with_variance(ty::Contravariant, *a_r, *b_r));\n \n             // FIXME(14985)  If we have mutable references to trait objects, we\n@@ -551,45 +545,43 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n                 _ => try!(this.mts(a_mt, b_mt))\n             };\n             Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n-      }\n+        }\n \n-      (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) => {\n-        this.tys(a_t, b_t).and_then(|t| {\n-            if sz_a == sz_b {\n-                Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n-            } else {\n-                Err(ty::terr_fixed_array_size(expected_found(this, sz_a, sz_b)))\n-            }\n-        })\n-      }\n+        (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) => {\n+            this.tys(a_t, b_t).and_then(|t| {\n+                if sz_a == sz_b {\n+                    Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n+                } else {\n+                    Err(ty::terr_fixed_array_size(expected_found(this, sz_a, sz_b)))\n+                }\n+            })\n+        }\n \n-      (&ty::ty_vec(a_t, sz_a), &ty::ty_vec(b_t, sz_b)) => {\n-        this.tys(a_t, b_t).and_then(|t| {\n-            if sz_a == sz_b {\n-                Ok(ty::mk_vec(tcx, t, sz_a))\n+        (&ty::ty_vec(a_t, sz_a), &ty::ty_vec(b_t, sz_b)) => {\n+            this.tys(a_t, b_t).and_then(|t| {\n+                if sz_a == sz_b {\n+                    Ok(ty::mk_vec(tcx, t, sz_a))\n+                } else {\n+                    Err(ty::terr_sorts(expected_found(this, a, b)))\n+                }\n+            })\n+        }\n+\n+        (&ty::ty_str, &ty::ty_str) => Ok(ty::mk_str(tcx)),\n+\n+        (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {\n+            if as_.len() == bs.len() {\n+                as_.iter().zip(bs.iter())\n+                   .map(|(a, b)| this.tys(*a, *b))\n+                   .collect::<Result<_, _>>()\n+                   .map(|ts| ty::mk_tup(tcx, ts))\n+            } else if as_.len() != 0 && bs.len() != 0 {\n+                Err(ty::terr_tuple_size(\n+                    expected_found(this, as_.len(), bs.len())))\n             } else {\n                 Err(ty::terr_sorts(expected_found(this, a, b)))\n             }\n-        })\n-      }\n-\n-      (&ty::ty_str, &ty::ty_str) => {\n-            Ok(ty::mk_str(tcx))\n-      }\n-\n-      (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {\n-        if as_.len() == bs.len() {\n-            as_.iter().zip(bs.iter())\n-               .map(|(a, b)| this.tys(*a, *b))\n-               .collect::<Result<_, _>>()\n-               .map(|ts| ty::mk_tup(tcx, ts))\n-        } else if as_.len() != 0 && bs.len() != 0 {\n-            Err(ty::terr_tuple_size(\n-                expected_found(this, as_.len(), bs.len())))\n-        } else {\n-            Err(ty::terr_sorts(expected_found(this, a, b)))\n         }\n-      }\n \n         (&ty::ty_bare_fn(a_opt_def_id, a_fty), &ty::ty_bare_fn(b_opt_def_id, b_fty))\n             if a_opt_def_id == b_opt_def_id =>\n@@ -598,33 +590,33 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n         }\n \n-      (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) => {\n-          let projection_ty = try!(this.projection_tys(a_data, b_data));\n-          Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n-      }\n+        (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) => {\n+            let projection_ty = try!(this.projection_tys(a_data, b_data));\n+            Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n+        }\n \n-      _ => Err(ty::terr_sorts(expected_found(this, a, b)))\n+        _ => Err(ty::terr_sorts(expected_found(this, a, b))),\n     };\n \n-    fn unify_integral_variable<'tcx, C: Combine<'tcx>>(\n-        this: &C,\n-        vid_is_expected: bool,\n-        vid: ty::IntVid,\n-        val: ty::IntVarValue) -> cres<'tcx, Ty<'tcx>>\n-    {\n+    fn unify_integral_variable<'tcx, C>(this: &C,\n+                                        vid_is_expected: bool,\n+                                        vid: ty::IntVid,\n+                                        val: ty::IntVarValue)\n+                                        -> cres<'tcx, Ty<'tcx>>\n+                                        where C: Combine<'tcx> {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         match val {\n             IntType(v) => Ok(ty::mk_mach_int(this.tcx(), v)),\n-            UintType(v) => Ok(ty::mk_mach_uint(this.tcx(), v))\n+            UintType(v) => Ok(ty::mk_mach_uint(this.tcx(), v)),\n         }\n     }\n \n-    fn unify_float_variable<'tcx, C: Combine<'tcx>>(\n-        this: &C,\n-        vid_is_expected: bool,\n-        vid: ty::FloatVid,\n-        val: ast::FloatTy) -> cres<'tcx, Ty<'tcx>>\n-    {\n+    fn unify_float_variable<'tcx, C>(this: &C,\n+                                     vid_is_expected: bool,\n+                                     vid: ty::FloatVid,\n+                                     val: ast::FloatTy)\n+                                     -> cres<'tcx, Ty<'tcx>>\n+                                     where C: Combine<'tcx> {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         Ok(ty::mk_mach_float(this.tcx(), val))\n     }\n@@ -696,12 +688,8 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                 None => {     // ...not yet instantiated:\n                     // Generalize type if necessary.\n                     let generalized_ty = try!(match dir {\n-                        EqTo => {\n-                            self.generalize(a_ty, b_vid, false)\n-                        }\n-                        BiTo | SupertypeOf | SubtypeOf => {\n-                            self.generalize(a_ty, b_vid, true)\n-                        }\n+                        EqTo => self.generalize(a_ty, b_vid, false),\n+                        BiTo | SupertypeOf | SubtypeOf => self.generalize(a_ty, b_vid, true),\n                     });\n                     debug!(\"instantiate(a_ty={}, dir={:?}, \\\n                                         b_vid={}, generalized_ty={})\",\n@@ -723,22 +711,14 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n             match dir {\n-                BiTo => {\n-                    try!(self.bivariate().tys(a_ty, b_ty));\n-                }\n+                BiTo => try!(self.bivariate().tys(a_ty, b_ty)),\n \n-                EqTo => {\n-                    try!(self.equate().tys(a_ty, b_ty));\n-                }\n+                EqTo => try!(self.equate().tys(a_ty, b_ty)),\n \n-                SubtypeOf => {\n-                    try!(self.sub().tys(a_ty, b_ty));\n-                }\n+                SubtypeOf => try!(self.sub().tys(a_ty, b_ty)),\n \n-                SupertypeOf => {\n-                    try!(self.sub().tys_with_variance(ty::Contravariant, a_ty, b_ty));\n-                }\n-            }\n+                SupertypeOf => try!(self.sub().tys_with_variance(ty::Contravariant, a_ty, b_ty)),\n+            };\n         }\n \n         Ok(())\n@@ -754,11 +734,13 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                   make_region_vars: bool)\n                   -> cres<'tcx, Ty<'tcx>>\n     {\n-        let mut generalize = Generalizer { infcx: self.infcx,\n-                                           span: self.trace.origin.span(),\n-                                           for_vid: for_vid,\n-                                           make_region_vars: make_region_vars,\n-                                           cycle_detected: false };\n+        let mut generalize = Generalizer {\n+            infcx: self.infcx,\n+            span: self.trace.origin.span(),\n+            for_vid: for_vid,\n+            make_region_vars: make_region_vars,\n+            cycle_detected: false\n+        };\n         let u = ty.fold_with(&mut generalize);\n         if generalize.cycle_detected {\n             Err(ty::terr_cyclic_ty)"}, {"sha": "759d7357df1931d71b0843e61594c2dd4624cbcb", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c51c377982694d1ed3d545099f4262635defb284/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c51c377982694d1ed3d545099f4262635defb284/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=c51c377982694d1ed3d545099f4262635defb284", "patch": "@@ -1133,18 +1133,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 true // changed\n             }\n \n-            ErrorValue => {\n-                false // no change\n-            }\n+            ErrorValue => false, // no change\n \n             Value(a_region) => {\n                 match a_data.classification {\n-                    Expanding => {\n-                        check_node(self, a_vid, a_data, a_region, b_region)\n-                    }\n-                    Contracting => {\n-                        adjust_node(self, a_vid, a_data, a_region, b_region)\n-                    }\n+                    Expanding => check_node(self, a_vid, a_data, a_region, b_region),\n+                    Contracting => adjust_node(self, a_vid, a_data, a_region, b_region),\n                 }\n             }\n         };\n@@ -1154,7 +1148,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                       a_data: &mut VarData,\n                       a_region: Region,\n                       b_region: Region)\n-                   -> bool {\n+                      -> bool {\n             if !this.is_subregion_of(a_region, b_region) {\n                 debug!(\"Setting {:?} to ErrorValue: {} not subregion of {}\",\n                        a_vid,\n@@ -1170,7 +1164,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                        a_data: &mut VarData,\n                        a_region: Region,\n                        b_region: Region)\n-                    -> bool {\n+                       -> bool {\n             match this.glb_concrete_regions(a_region, b_region) {\n                 Ok(glb) => {\n                     if glb == a_region {"}, {"sha": "9ec89f55b8f329cd61ae5715580cb65aed420893", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 58, "deletions": 102, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/c51c377982694d1ed3d545099f4262635defb284/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c51c377982694d1ed3d545099f4262635defb284/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c51c377982694d1ed3d545099f4262635defb284", "patch": "@@ -1409,27 +1409,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n         return match self_ty.sty {\n-            ty::ty_infer(ty::IntVar(_)) |\n-            ty::ty_infer(ty::FloatVar(_)) |\n-            ty::ty_uint(_) |\n-            ty::ty_int(_) |\n-            ty::ty_bool |\n-            ty::ty_float(_) |\n-            ty::ty_bare_fn(..) |\n-            ty::ty_char => {\n+            ty::ty_infer(ty::IntVar(_))\n+            | ty::ty_infer(ty::FloatVar(_))\n+            | ty::ty_uint(_)\n+            | ty::ty_int(_)\n+            | ty::ty_bool\n+            | ty::ty_float(_)\n+            | ty::ty_bare_fn(..)\n+            | ty::ty_char => {\n                 // safe for everything\n                 Ok(If(Vec::new()))\n             }\n \n             ty::ty_uniq(_) => {  // Box<T>\n                 match bound {\n-                    ty::BoundCopy => {\n-                        Err(Unimplemented)\n-                    }\n+                    ty::BoundCopy => Err(Unimplemented),\n \n-                    ty::BoundSized => {\n-                        Ok(If(Vec::new()))\n-                    }\n+                    ty::BoundSized => Ok(If(Vec::new())),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1439,9 +1435,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::ty_ptr(..) => {     // *const T, *mut T\n                 match bound {\n-                    ty::BoundCopy | ty::BoundSized => {\n-                        Ok(If(Vec::new()))\n-                    }\n+                    ty::BoundCopy | ty::BoundSized => Ok(If(Vec::new())),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1451,9 +1445,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::ty_trait(ref data) => {\n                 match bound {\n-                    ty::BoundSized => {\n-                        Err(Unimplemented)\n-                    }\n+                    ty::BoundSized => Err(Unimplemented),\n                     ty::BoundCopy => {\n                         if data.bounds.builtin_bounds.contains(&bound) {\n                             Ok(If(Vec::new()))\n@@ -1485,20 +1477,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundCopy => {\n                         match mutbl {\n                             // &mut T is affine and hence never `Copy`\n-                            ast::MutMutable => {\n-                                Err(Unimplemented)\n-                            }\n+                            ast::MutMutable => Err(Unimplemented),\n \n                             // &T is always copyable\n-                            ast::MutImmutable => {\n-                                Ok(If(Vec::new()))\n-                            }\n+                            ast::MutImmutable => Ok(If(Vec::new())),\n                         }\n                     }\n \n-                    ty::BoundSized => {\n-                        Ok(If(Vec::new()))\n-                    }\n+                    ty::BoundSized => Ok(If(Vec::new())),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1511,14 +1497,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 match bound {\n                     ty::BoundCopy => {\n                         match *len {\n-                            Some(_) => {\n-                                // [T, ..n] is copy iff T is copy\n-                                Ok(If(vec![element_ty]))\n-                            }\n-                            None => {\n-                                // [T] is unsized and hence affine\n-                                Err(Unimplemented)\n-                            }\n+                            // [T, ..n] is copy iff T is copy\n+                            Some(_) => Ok(If(vec![element_ty])),\n+\n+                            // [T] is unsized and hence affine\n+                            None => Err(Unimplemented),\n                         }\n                     }\n \n@@ -1543,16 +1526,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n \n-                    ty::BoundCopy | ty::BoundSized => {\n-                        Err(Unimplemented)\n-                    }\n+                    ty::BoundCopy | ty::BoundSized => Err(Unimplemented),\n                 }\n             }\n \n-            ty::ty_tup(ref tys) => {\n-                // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-                Ok(If(tys.clone()))\n-            }\n+            // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n+            ty::ty_tup(ref tys) => Ok(If(tys.clone())),\n \n             ty::ty_closure(def_id, _, substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n@@ -1581,9 +1560,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 match self.closure_typer.closure_upvars(def_id, substs) {\n-                    Some(upvars) => {\n-                        Ok(If(upvars.iter().map(|c| c.ty).collect()))\n-                    }\n+                    Some(upvars) => Ok(If(upvars.iter().map(|c| c.ty).collect())),\n                     None => {\n                         debug!(\"assemble_builtin_bound_candidates: no upvar types available yet\");\n                         Ok(AmbiguousBuiltin)\n@@ -1609,8 +1586,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nominal(bound, types)\n             }\n \n-            ty::ty_projection(_) |\n-            ty::ty_param(_) => {\n+            ty::ty_projection(_) | ty::ty_param(_) => {\n                 // Note: A type parameter is only considered to meet a\n                 // particular bound if there is a where clause telling\n                 // us that it does, and that case is handled by\n@@ -1626,12 +1602,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(AmbiguousBuiltin)\n             }\n \n-            ty::ty_err => {\n-                Ok(If(Vec::new()))\n-            }\n+            ty::ty_err => Ok(If(Vec::new())),\n \n-            ty::ty_infer(ty::FreshTy(_)) |\n-            ty::ty_infer(ty::FreshIntTy(_)) => {\n+            ty::ty_infer(ty::FreshTy(_))\n+            | ty::ty_infer(ty::FreshIntTy(_)) => {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n@@ -1641,7 +1615,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         fn nominal<'cx, 'tcx>(bound: ty::BuiltinBound,\n                               types: Vec<Ty<'tcx>>)\n-                              -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n+                              -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>>\n         {\n             // First check for markers and other nonsense.\n             match bound {\n@@ -1692,7 +1666,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble constituent types of unexpected type: {}\",\n-                        t.repr(self.tcx()))[]);\n+                        t.repr(self.tcx())));\n             }\n \n             ty::ty_uniq(referent_ty) => {  // Box<T>\n@@ -1909,7 +1883,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }).collect::<Result<_, _>>();\n         let obligations = match obligations {\n             Ok(o) => o,\n-            Err(ErrorReported) => Vec::new()\n+            Err(ErrorReported) => Vec::new(),\n         };\n \n         let obligations = VecPerParamSpace::new(obligations, Vec::new(), Vec::new());\n@@ -1937,14 +1911,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n         match self.constituent_types_for_ty(self_ty) {\n-            Some(types) => {\n-                Ok(self.vtable_default_impl(obligation, impl_def_id, types))\n-            }\n+            Some(types) => Ok(self.vtable_default_impl(obligation, impl_def_id, types)),\n             None => {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to confirm default implementation for ambiguous type: {}\",\n-                        self_ty.repr(self.tcx()))[]);\n+                        self_ty.repr(self.tcx())));\n             }\n         }\n     }\n@@ -2223,9 +2195,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         match self.match_impl(impl_def_id, obligation, snapshot,\n                               skol_map, skol_obligation_trait_ref) {\n-            Ok(substs) => {\n-                substs\n-            }\n+            Ok(substs) => substs,\n             Err(()) => {\n                 self.tcx().sess.bug(\n                     &format!(\"Impl {} was matchable against {} but now is not\",\n@@ -2273,30 +2243,26 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                skol_obligation_trait_ref.repr(self.tcx()));\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n-        match self.infcx.sub_trait_refs(false,\n-                                        origin,\n-                                        impl_trait_ref.value.clone(),\n-                                        skol_obligation_trait_ref) {\n-            Ok(()) => { }\n-            Err(e) => {\n-                debug!(\"match_impl: failed sub_trait_refs due to `{}`\",\n-                       ty::type_err_to_str(self.tcx(), &e));\n-                return Err(());\n-            }\n+        if let Err(e) = self.infcx.sub_trait_refs(false,\n+                                                  origin,\n+                                                  impl_trait_ref.value.clone(),\n+                                                  skol_obligation_trait_ref) {\n+            debug!(\"match_impl: failed sub_trait_refs due to `{}`\",\n+                   ty::type_err_to_str(self.tcx(), &e));\n+            return Err(());\n         }\n \n-        match self.infcx.leak_check(skol_map, snapshot) {\n-            Ok(()) => { }\n-            Err(e) => {\n-                debug!(\"match_impl: failed leak check due to `{}`\",\n-                       ty::type_err_to_str(self.tcx(), &e));\n-                return Err(());\n-            }\n+        if let Err(e) = self.infcx.leak_check(skol_map, snapshot) {\n+            debug!(\"match_impl: failed leak check due to `{}`\",\n+                   ty::type_err_to_str(self.tcx(), &e));\n+            return Err(());\n         }\n \n         debug!(\"match_impl: success impl_substs={}\", impl_substs.repr(self.tcx()));\n-        Ok(Normalized { value: impl_substs,\n-                        obligations: impl_trait_ref.obligations })\n+        Ok(Normalized {\n+            value: impl_substs,\n+            obligations: impl_trait_ref.obligations\n+        })\n     }\n \n     fn fast_reject_trait_refs(&mut self,\n@@ -2332,9 +2298,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n-        let () =\n-            try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref));\n-\n+        try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref));\n         Ok(Vec::new())\n     }\n \n@@ -2451,7 +2415,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match self.tcx().trait_impls.borrow().get(&trait_def_id) {\n             None => Vec::new(),\n-            Some(impls) => impls.borrow().clone()\n+            Some(impls) => impls.borrow().clone(),\n         }\n     }\n \n@@ -2549,9 +2513,7 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             DefaultImplCandidate(t) => format!(\"DefaultImplCandidate({:?})\", t),\n             ProjectionCandidate => format!(\"ProjectionCandidate\"),\n             FnPointerCandidate => format!(\"FnPointerCandidate\"),\n-            ObjectCandidate => {\n-                format!(\"ObjectCandidate\")\n-            }\n+            ObjectCandidate => format!(\"ObjectCandidate\"),\n             ClosureCandidate(c, ref s) => {\n                 format!(\"ClosureCandidate({:?},{})\", c, s.repr(tcx))\n             }\n@@ -2582,9 +2544,7 @@ impl<'o, 'tcx> Iterator for Option<&'o TraitObligationStack<'o, 'tcx>> {\n                 *self = o.previous;\n                 Some(o)\n             }\n-            None => {\n-                None\n-            }\n+            None => None\n         }\n     }\n }\n@@ -2599,15 +2559,11 @@ impl<'o, 'tcx> Repr<'tcx> for TraitObligationStack<'o, 'tcx> {\n impl<'tcx> EvaluationResult<'tcx> {\n     fn may_apply(&self) -> bool {\n         match *self {\n-            EvaluatedToOk |\n-            EvaluatedToAmbig |\n-            EvaluatedToErr(Overflow) |\n-            EvaluatedToErr(OutputTypeParameterMismatch(..)) => {\n-                true\n-            }\n-            EvaluatedToErr(Unimplemented) => {\n-                false\n-            }\n+            EvaluatedToOk\n+            | EvaluatedToAmbig\n+            | EvaluatedToErr(Overflow)\n+            | EvaluatedToErr(OutputTypeParameterMismatch(..)) => true,\n+            EvaluatedToErr(Unimplemented) => false,\n         }\n     }\n }"}, {"sha": "5cbe9dd71fb2495734a104af2f3f09a14a65c3d6", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c51c377982694d1ed3d545099f4262635defb284/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c51c377982694d1ed3d545099f4262635defb284/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=c51c377982694d1ed3d545099f4262635defb284", "patch": "@@ -359,7 +359,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n-        return match e.node {\n+        match e.node {\n           ast::ExprLit(ref lit) => {\n               const_lit(cx, e, &**lit)\n           }\n@@ -379,7 +379,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let (te2, _) = const_expr(cx, &**e2, param_substs);\n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n-            return match b.node {\n+            match b.node {\n               ast::BiAdd   => {\n                 if is_float { llvm::LLVMConstFAdd(te1, te2) }\n                 else        { llvm::LLVMConstAdd(te1, te2) }\n@@ -433,7 +433,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprUnary(u, ref e) => {\n             let (te, ty) = const_expr(cx, &**e, param_substs);\n             let is_float = ty::type_is_fp(ty);\n-            return match u {\n+            match u {\n               ast::UnUniq | ast::UnDeref => {\n                 const_deref(cx, te, ty).0\n               }\n@@ -514,8 +514,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if expr::cast_is_noop(basety, ety) {\n                 return v;\n             }\n-            return match (expr::cast_type_kind(cx.tcx(), basety),\n-                           expr::cast_type_kind(cx.tcx(), ety)) {\n+            match (expr::cast_type_kind(cx.tcx(), basety),\n+                   expr::cast_type_kind(cx.tcx(), ety)) {\n \n               (expr::cast_integral, expr::cast_integral) => {\n                 let s = ty::type_is_signed(basety) as Bool;\n@@ -584,13 +584,13 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               }\n               let opt_def = cx.tcx().def_map.borrow().get(&cur.id).cloned();\n               if let Some(def::DefStatic(def_id, _)) = opt_def {\n-                  return get_static_val(cx, def_id, ety);\n+                  get_static_val(cx, def_id, ety)\n+              } else {\n+                  // If this isn't the address of a static, then keep going through\n+                  // normal constant evaluation.\n+                  let (v, _) = const_expr(cx, &**sub, param_substs);\n+                  addr_of(cx, v, \"ref\", e.id)\n               }\n-\n-              // If this isn't the address of a static, then keep going through\n-              // normal constant evaluation.\n-              let (v, _) = const_expr(cx, &**sub, param_substs);\n-              addr_of(cx, v, \"ref\", e.id)\n           }\n           ast::ExprAddrOf(ast::MutMutable, ref sub) => {\n               let (v, _) = const_expr(cx, &**sub, param_substs);\n@@ -740,7 +740,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           }\n           _ => cx.sess().span_bug(e.span,\n                   \"bad constant expression type in consts::const_expr\")\n-        };\n+        }\n     }\n }\n "}]}