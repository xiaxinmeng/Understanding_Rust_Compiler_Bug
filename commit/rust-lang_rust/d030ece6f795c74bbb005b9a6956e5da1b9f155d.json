{"sha": "d030ece6f795c74bbb005b9a6956e5da1b9f155d", "node_id": "C_kwDOAAsO6NoAKGQwMzBlY2U2Zjc5NWM3NGJiYjAwNWI5YTY5NTZlNWRhMWI5ZjE1NWQ", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-02-14T09:17:34Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-05-31T14:02:57Z"}, "message": "Only rewrite valtree-constants to patterns and keep other constants opaque", "tree": {"sha": "1ee53e257d3a80f4320a5ef2c09a83919204b7f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee53e257d3a80f4320a5ef2c09a83919204b7f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d030ece6f795c74bbb005b9a6956e5da1b9f155d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d030ece6f795c74bbb005b9a6956e5da1b9f155d", "html_url": "https://github.com/rust-lang/rust/commit/d030ece6f795c74bbb005b9a6956e5da1b9f155d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d030ece6f795c74bbb005b9a6956e5da1b9f155d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a2f47c271b99e30225382e53522b28dd5779103", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a2f47c271b99e30225382e53522b28dd5779103", "html_url": "https://github.com/rust-lang/rust/commit/7a2f47c271b99e30225382e53522b28dd5779103"}], "stats": {"total": 411, "additions": 236, "deletions": 175}, "files": [{"sha": "72cd2218e4aac9475a2dd5f7315cd5dc32331f15", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d030ece6f795c74bbb005b9a6956e5da1b9f155d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d030ece6f795c74bbb005b9a6956e5da1b9f155d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=d030ece6f795c74bbb005b9a6956e5da1b9f155d", "patch": "@@ -2487,8 +2487,8 @@ impl<'tcx> ConstantKind<'tcx> {\n         if let Some(lit_input) = lit_input {\n             // If an error occurred, ignore that it's a literal and leave reporting the error up to\n             // mir.\n-            match tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n-                Ok(c) => return c,\n+            match tcx.at(expr.span).lit_to_const(lit_input) {\n+                Ok(c) => return Self::Ty(c),\n                 Err(_) => {}\n             }\n         }"}, {"sha": "fd4e5e4a177abac97f0ff9d686f518dbfca47632", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 164, "deletions": 124, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/d030ece6f795c74bbb005b9a6956e5da1b9f155d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d030ece6f795c74bbb005b9a6956e5da1b9f155d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=d030ece6f795c74bbb005b9a6956e5da1b9f155d", "patch": "@@ -1,13 +1,14 @@\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_index::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n use rustc_middle::mir;\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, ValTree};\n use rustc_session::lint;\n use rustc_span::Span;\n-use rustc_target::abi::FieldIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n \n@@ -29,11 +30,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         cv: mir::ConstantKind<'tcx>,\n         id: hir::HirId,\n         span: Span,\n-        mir_structural_match_violation: bool,\n+        check_body_for_struct_match_violation: Option<DefId>,\n     ) -> Box<Pat<'tcx>> {\n         let infcx = self.tcx.infer_ctxt().build();\n         let mut convert = ConstToPat::new(self, id, span, infcx);\n-        convert.to_pat(cv, mir_structural_match_violation)\n+        convert.to_pat(cv, check_body_for_struct_match_violation)\n     }\n }\n \n@@ -104,7 +105,7 @@ impl<'tcx> ConstToPat<'tcx> {\n     fn to_pat(\n         &mut self,\n         cv: mir::ConstantKind<'tcx>,\n-        mir_structural_match_violation: bool,\n+        check_body_for_struct_match_violation: Option<DefId>,\n     ) -> Box<Pat<'tcx>> {\n         trace!(self.treat_byte_string_as_slice);\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n@@ -114,14 +115,44 @@ impl<'tcx> ConstToPat<'tcx> {\n         // once indirect_structural_match is a full fledged error, this\n         // level of indirection can be eliminated\n \n-        let inlined_const_as_pat =\n-            self.recur(cv, mir_structural_match_violation).unwrap_or_else(|_| {\n-                Box::new(Pat {\n-                    span: self.span,\n-                    ty: cv.ty(),\n-                    kind: PatKind::Constant { value: cv },\n-                })\n-            });\n+        let mir_structural_match_violation = check_body_for_struct_match_violation.map(|def_id| {\n+            // `mir_const_qualif` must be called with the `DefId` of the item where the const is\n+            // defined, not where it is declared. The difference is significant for associated\n+            // constants.\n+            self.tcx().mir_const_qualif(def_id).custom_eq\n+        });\n+        debug!(?check_body_for_struct_match_violation, ?mir_structural_match_violation);\n+\n+        let inlined_const_as_pat = match cv {\n+            mir::ConstantKind::Ty(c) => match c.kind() {\n+                ty::ConstKind::Param(_)\n+                | ty::ConstKind::Infer(_)\n+                | ty::ConstKind::Bound(_, _)\n+                | ty::ConstKind::Placeholder(_)\n+                | ty::ConstKind::Unevaluated(_)\n+                | ty::ConstKind::Error(_)\n+                | ty::ConstKind::Expr(_) => {\n+                    span_bug!(self.span, \"unevaluated const in `to_pat`: {:?}\", c.kind())\n+                }\n+                ty::ConstKind::Value(valtree) => self\n+                    .recur(valtree, cv.ty(), mir_structural_match_violation.unwrap_or(false))\n+                    .unwrap_or_else(|_| {\n+                        Box::new(Pat {\n+                            span: self.span,\n+                            ty: cv.ty(),\n+                            kind: PatKind::Constant { value: cv },\n+                        })\n+                    }),\n+            },\n+            mir::ConstantKind::Unevaluated(_, _) => {\n+                span_bug!(self.span, \"unevaluated const in `to_pat`: {cv:?}\")\n+            }\n+            mir::ConstantKind::Val(_, _) => Box::new(Pat {\n+                span: self.span,\n+                ty: cv.ty(),\n+                kind: PatKind::Constant { value: cv },\n+            }),\n+        };\n \n         if !self.saw_const_match_error.get() {\n             // If we were able to successfully convert the const to some pat,\n@@ -141,36 +172,78 @@ impl<'tcx> ConstToPat<'tcx> {\n             //\n             // FIXME(#73448): Find a way to bring const qualification into parity with\n             // `search_for_structural_match_violation`.\n-            if structural.is_none() && mir_structural_match_violation {\n+            if structural.is_none() && mir_structural_match_violation.unwrap_or(false) {\n                 warn!(\"MIR const-checker found novel structural match violation. See #73448.\");\n                 return inlined_const_as_pat;\n             }\n \n             if let Some(non_sm_ty) = structural {\n                 if !self.type_may_have_partial_eq_impl(cv.ty()) {\n-                    // fatal avoids ICE from resolution of nonexistent method (rare case).\n-                    self.tcx()\n-                        .sess\n-                        .emit_fatal(TypeNotStructural { span: self.span, non_sm_ty: non_sm_ty });\n-                } else if mir_structural_match_violation && !self.saw_const_match_lint.get() {\n-                    self.tcx().emit_spanned_lint(\n-                        lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n-                        self.id,\n-                        self.span,\n-                        IndirectStructuralMatch { non_sm_ty },\n-                    );\n-                } else {\n-                    debug!(\n-                        \"`search_for_structural_match_violation` found one, but `CustomEq` was \\\n-                          not in the qualifs for that `const`\"\n-                    );\n+                    if let ty::Adt(def, ..) = non_sm_ty.kind() {\n+                        if def.is_union() {\n+                            let err = UnionPattern { span: self.span };\n+                            self.tcx().sess.emit_err(err);\n+                        } else {\n+                            // fatal avoids ICE from resolution of nonexistent method (rare case).\n+                            self.tcx()\n+                                .sess\n+                                .emit_fatal(TypeNotStructural { span: self.span, non_sm_ty });\n+                        }\n+                    } else {\n+                        let err = InvalidPattern { span: self.span, non_sm_ty };\n+                        self.tcx().sess.emit_err(err);\n+                        return Box::new(Pat { span: self.span, ty: cv.ty(), kind: PatKind::Wild });\n+                    }\n+                } else if !self.saw_const_match_lint.get() {\n+                    if let Some(mir_structural_match_violation) = mir_structural_match_violation {\n+                        match non_sm_ty.kind() {\n+                            ty::RawPtr(pointee)\n+                                if pointee.ty.is_sized(self.tcx(), self.param_env) => {}\n+                            ty::FnPtr(..) | ty::RawPtr(..) => {\n+                                self.tcx().emit_spanned_lint(\n+                                    lint::builtin::POINTER_STRUCTURAL_MATCH,\n+                                    self.id,\n+                                    self.span,\n+                                    PointerPattern,\n+                                );\n+                            }\n+                            ty::Adt(..) if mir_structural_match_violation => {\n+                                self.tcx().emit_spanned_lint(\n+                                    lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n+                                    self.id,\n+                                    self.span,\n+                                    IndirectStructuralMatch { non_sm_ty },\n+                                );\n+                            }\n+                            _ => {\n+                                debug!(\n+                                    \"`search_for_structural_match_violation` found one, but `CustomEq` was \\\n+                                  not in the qualifs for that `const`\"\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n+            } else if !self.saw_const_match_lint.get() {\n+                match cv.ty().kind() {\n+                    ty::RawPtr(pointee) if pointee.ty.is_sized(self.tcx(), self.param_env) => {}\n+                    ty::FnPtr(..) | ty::RawPtr(..) => {\n+                        self.tcx().emit_spanned_lint(\n+                            lint::builtin::POINTER_STRUCTURAL_MATCH,\n+                            self.id,\n+                            self.span,\n+                            PointerPattern,\n+                        );\n+                    }\n+                    _ => {}\n                 }\n             }\n         }\n \n         inlined_const_as_pat\n     }\n \n+    #[instrument(level = \"trace\", skip(self), ret)]\n     fn type_may_have_partial_eq_impl(&self, ty: Ty<'tcx>) -> bool {\n         // double-check there even *is* a semantic `PartialEq` to dispatch to.\n         //\n@@ -192,12 +265,14 @@ impl<'tcx> ConstToPat<'tcx> {\n \n     fn field_pats(\n         &self,\n-        vals: impl Iterator<Item = mir::ConstantKind<'tcx>>,\n+        vals: impl Iterator<Item = (ValTree<'tcx>, Ty<'tcx>)>,\n     ) -> Result<Vec<FieldPat<'tcx>>, FallbackToConstRef> {\n         vals.enumerate()\n-            .map(|(idx, val)| {\n+            .map(|(idx, (val, ty))| {\n                 let field = FieldIdx::new(idx);\n-                Ok(FieldPat { field, pattern: self.recur(val, false)? })\n+                // Patterns can only use monomorphic types.\n+                let ty = self.tcx().normalize_erasing_regions(self.param_env, ty);\n+                Ok(FieldPat { field, pattern: self.recur(val, ty, false)? })\n             })\n             .collect()\n     }\n@@ -206,16 +281,18 @@ impl<'tcx> ConstToPat<'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     fn recur(\n         &self,\n-        cv: mir::ConstantKind<'tcx>,\n+        cv: ValTree<'tcx>,\n+        ty: Ty<'tcx>,\n         mir_structural_match_violation: bool,\n     ) -> Result<Box<Pat<'tcx>>, FallbackToConstRef> {\n         let id = self.id;\n         let span = self.span;\n         let tcx = self.tcx();\n         let param_env = self.param_env;\n \n-        let kind = match cv.ty().kind() {\n+        let kind = match ty.kind() {\n             ty::Float(_) => {\n+                self.saw_const_match_lint.set(true);\n                 tcx.emit_spanned_lint(\n                     lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                     id,\n@@ -224,27 +301,6 @@ impl<'tcx> ConstToPat<'tcx> {\n                 );\n                 return Err(FallbackToConstRef);\n             }\n-            ty::Adt(adt_def, _) if adt_def.is_union() => {\n-                // Matching on union fields is unsafe, we can't hide it in constants\n-                self.saw_const_match_error.set(true);\n-                let err = UnionPattern { span };\n-                tcx.sess.emit_err(err);\n-                PatKind::Wild\n-            }\n-            ty::Adt(..)\n-                if !self.type_may_have_partial_eq_impl(cv.ty())\n-                    // FIXME(#73448): Find a way to bring const qualification into parity with\n-                    // `search_for_structural_match_violation` and then remove this condition.\n-\n-                    // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n-                    // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-                    && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty()) =>\n-            {\n-                self.saw_const_match_error.set(true);\n-                let err = TypeNotStructural { span, non_sm_ty };\n-                tcx.sess.emit_err(err);\n-                PatKind::Wild\n-            }\n             // If the type is not structurally comparable, just emit the constant directly,\n             // causing the pattern match code to treat it opaquely.\n             // FIXME: This code doesn't emit errors itself, the caller emits the errors.\n@@ -254,56 +310,60 @@ impl<'tcx> ConstToPat<'tcx> {\n             // details.\n             // Backwards compatibility hack because we can't cause hard errors on these\n             // types, so we compare them via `PartialEq::eq` at runtime.\n-            ty::Adt(..) if !self.type_marked_structural(cv.ty()) && self.behind_reference.get() => {\n-                if !self.saw_const_match_error.get()\n-                    && !self.saw_const_match_lint.get()\n-                {\n+            ty::Adt(..) if !self.type_marked_structural(ty) && self.behind_reference.get() => {\n+                if !self.saw_const_match_error.get() && !self.saw_const_match_lint.get() {\n                     self.saw_const_match_lint.set(true);\n                     tcx.emit_spanned_lint(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        IndirectStructuralMatch { non_sm_ty: cv.ty() },\n+                        IndirectStructuralMatch { non_sm_ty: ty },\n                     );\n                 }\n                 // Since we are behind a reference, we can just bubble the error up so we get a\n                 // constant at reference type, making it easy to let the fallback call\n                 // `PartialEq::eq` on it.\n                 return Err(FallbackToConstRef);\n             }\n-            ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty()) => {\n-                debug!(\n-                    \"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\",\n-                    adt_def,\n-                    cv.ty()\n-                );\n+            ty::Adt(adt_def, _) if !self.type_marked_structural(ty) => {\n+                debug!(\"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\", adt_def, ty,);\n                 self.saw_const_match_error.set(true);\n-                let err = TypeNotStructural { span, non_sm_ty: cv.ty() };\n+                let err = TypeNotStructural { span, non_sm_ty: ty };\n                 tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let destructured = tcx.destructure_mir_constant(param_env, cv);\n-\n+                let (&variant_index, fields) = cv.unwrap_branch().split_first().unwrap();\n+                let variant_index =\n+                    VariantIdx::from_u32(variant_index.unwrap_leaf().try_to_u32().ok().unwrap());\n                 PatKind::Variant {\n                     adt_def: *adt_def,\n                     substs,\n-                    variant_index: destructured\n-                        .variant\n-                        .expect(\"destructed const of adt without variant id\"),\n-                    subpatterns: self.field_pats(destructured.fields.iter().copied())?,\n+                    variant_index,\n+                    subpatterns: self.field_pats(\n+                        fields.iter().copied().zip(\n+                            adt_def.variants()[variant_index]\n+                                .fields\n+                                .iter()\n+                                .map(|field| field.ty(self.tcx(), substs)),\n+                        ),\n+                    )?,\n                 }\n             }\n-            ty::Tuple(_) | ty::Adt(_, _) => {\n-                let destructured = tcx.destructure_mir_constant(param_env, cv);\n-                PatKind::Leaf { subpatterns: self.field_pats(destructured.fields.iter().copied())? }\n-            }\n-            ty::Array(..) => PatKind::Array {\n-                prefix: tcx\n-                    .destructure_mir_constant(param_env, cv)\n-                    .fields\n+            ty::Tuple(fields) => PatKind::Leaf {\n+                subpatterns: self\n+                    .field_pats(cv.unwrap_branch().iter().copied().zip(fields.iter()))?,\n+            },\n+            ty::Adt(def, substs) => PatKind::Leaf {\n+                subpatterns: self.field_pats(cv.unwrap_branch().iter().copied().zip(\n+                    def.non_enum_variant().fields.iter().map(|field| field.ty(self.tcx(), substs)),\n+                ))?,\n+            },\n+            ty::Array(elem_ty, _) => PatKind::Array {\n+                prefix: cv\n+                    .unwrap_branch()\n                     .iter()\n-                    .map(|val| self.recur(*val, false))\n+                    .map(|val| self.recur(*val, *elem_ty, false))\n                     .collect::<Result<_, _>>()?,\n                 slice: None,\n                 suffix: Box::new([]),\n@@ -312,36 +372,35 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // These are not allowed and will error elsewhere anyway.\n                 ty::Dynamic(..) => {\n                     self.saw_const_match_error.set(true);\n-                    let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n+                    let err = InvalidPattern { span, non_sm_ty: ty };\n                     tcx.sess.emit_err(err);\n                     PatKind::Wild\n                 }\n-                // `&str` is represented as `ConstValue::Slice`, let's keep using this\n+                // `&str` is represented as a valtree, let's keep using this\n                 // optimization for now.\n-                ty::Str => PatKind::Constant { value: cv },\n+                ty::Str => PatKind::Constant { value: mir::ConstantKind::Ty(tcx.mk_const(cv, ty)) },\n                 // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n                 // matching against references, you can only use byte string literals.\n                 // The typechecker has a special case for byte string literals, by treating them\n                 // as slices. This means we turn `&[T; N]` constants into slice patterns, which\n                 // has no negative effects on pattern matching, even if we're actually matching on\n                 // arrays.\n-                ty::Array(..) if !self.treat_byte_string_as_slice => {\n+                ty::Array(elem_ty, _) if !self.treat_byte_string_as_slice => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n+                    // References have the same valtree representation as their pointee.\n+                    let array = cv;\n                     let val = PatKind::Deref {\n                         subpattern: Box::new(Pat {\n                             kind: PatKind::Array {\n-                                prefix: tcx\n-                                    .destructure_mir_constant(param_env, array)\n-                                    .fields\n+                                prefix: array.unwrap_branch()\n                                     .iter()\n-                                    .map(|val| self.recur(*val, false))\n+                                    .map(|val| self.recur(*val, elem_ty, false))\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n                                 suffix: Box::new([]),\n                             },\n                             span,\n-                            ty: *pointee_ty,\n+                            ty: tcx.mk_slice(elem_ty),\n                         }),\n                     };\n                     self.behind_reference.set(old);\n@@ -353,15 +412,14 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // pattern.\n                 ty::Slice(elem_ty) => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n+                    // References have the same valtree representation as their pointee.\n+                    let array = cv;\n                     let val = PatKind::Deref {\n                         subpattern: Box::new(Pat {\n                             kind: PatKind::Slice {\n-                                prefix: tcx\n-                                    .destructure_mir_constant(param_env, array)\n-                                    .fields\n+                                prefix: array.unwrap_branch()\n                                     .iter()\n-                                    .map(|val| self.recur(*val, false))\n+                                    .map(|val| self.recur(*val, elem_ty, false))\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n                                 suffix: Box::new([]),\n@@ -415,39 +473,21 @@ impl<'tcx> ConstToPat<'tcx> {\n                         PatKind::Wild\n                     } else {\n                         let old = self.behind_reference.replace(true);\n-                        let subpattern = self.recur(tcx.deref_mir_constant(self.param_env.and(cv)), false)?;\n+                        // References have the same valtree representation as their pointee.\n+                        let subpattern = self.recur(cv, *pointee_ty, false)?;\n                         self.behind_reference.set(old);\n                         PatKind::Deref { subpattern }\n                     }\n                 }\n             },\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::FnDef(..) => {\n-                PatKind::Constant { value: cv }\n-            }\n-            ty::RawPtr(pointee) if pointee.ty.is_sized(tcx, param_env) => {\n-                return Err(FallbackToConstRef);\n-            }\n-            // FIXME: these can have very surprising behaviour where optimization levels or other\n-            // compilation choices change the runtime behaviour of the match.\n-            // See https://github.com/rust-lang/rust/issues/70861 for examples.\n-            ty::FnPtr(..) | ty::RawPtr(..) => {\n-                if !self.saw_const_match_error.get()\n-                    && !self.saw_const_match_lint.get()\n-                {\n-                    self.saw_const_match_lint.set(true);\n-                    tcx.emit_spanned_lint(\n-                        lint::builtin::POINTER_STRUCTURAL_MATCH,\n-                        id,\n-                        span,\n-                        PointerPattern\n-                    );\n-                }\n-                return Err(FallbackToConstRef);\n+                PatKind::Constant { value: mir::ConstantKind::Ty(tcx.mk_const(cv, ty)) }\n             }\n+            ty::FnPtr(..) | ty::RawPtr(..) => unreachable!(),\n             _ => {\n                 self.saw_const_match_error.set(true);\n-                let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n-                    tcx.sess.emit_err(err);\n+                let err = InvalidPattern { span, non_sm_ty: ty };\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n         };\n@@ -460,7 +500,7 @@ impl<'tcx> ConstToPat<'tcx> {\n \n             // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n             // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-            && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty())\n+            && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, ty)\n         {\n             self.saw_const_match_lint.set(true);\n             tcx.emit_spanned_lint(\n@@ -471,6 +511,6 @@ impl<'tcx> ConstToPat<'tcx> {\n             );\n         }\n \n-        Ok(Box::new(Pat { span, ty: cv.ty(), kind }))\n+        Ok(Box::new(Pat { span, ty, kind }))\n     }\n }"}, {"sha": "6ab6fb11080de1a24a6d4323a5204237145bb5f6", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d030ece6f795c74bbb005b9a6956e5da1b9f155d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d030ece6f795c74bbb005b9a6956e5da1b9f155d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=d030ece6f795c74bbb005b9a6956e5da1b9f155d", "patch": "@@ -141,22 +141,21 @@ impl IntRange {\n     ) -> Option<IntRange> {\n         let ty = value.ty();\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, ty) {\n-            let val = if let mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) = value {\n-                // For this specific pattern we can skip a lot of effort and go\n-                // straight to the result, after doing a bit of checking. (We\n-                // could remove this branch and just fall through, which\n-                // is more general but much slower.)\n-                scalar.to_bits_or_ptr_internal(target_size).unwrap().left()?\n-            } else {\n-                if let mir::ConstantKind::Ty(c) = value\n-                    && let ty::ConstKind::Value(_) = c.kind()\n-                {\n-                    bug!(\"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\");\n+            let val = match value {\n+                mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) => {\n+                    // For this specific pattern we can skip a lot of effort and go\n+                    // straight to the result, after doing a bit of checking. (We\n+                    // could remove this branch and just fall through, which\n+                    // is more general but much slower.)\n+                    scalar.to_bits_or_ptr_internal(target_size).unwrap().left()\n                 }\n-\n+                mir::ConstantKind::Ty(c) if let ty::ConstKind::Value(valtree) = c.kind() => {\n+                    valtree.unwrap_leaf().to_bits(target_size).ok()\n+                },\n                 // This is a more general form of the previous case.\n-                value.try_eval_bits(tcx, param_env, ty)?\n-            };\n+                _ => value.try_eval_bits(tcx, param_env, ty),\n+            }?;\n+\n             let val = val ^ bias;\n             Some(IntRange { range: val..=val, bias })\n         } else {"}, {"sha": "1b4ce20004e792e50f12cb95d0be4d21dc7e2e5a", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 47, "deletions": 18, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d030ece6f795c74bbb005b9a6956e5da1b9f155d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d030ece6f795c74bbb005b9a6956e5da1b9f155d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=d030ece6f795c74bbb005b9a6956e5da1b9f155d", "patch": "@@ -18,7 +18,7 @@ use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::RangeEnd;\n use rustc_index::Idx;\n use rustc_middle::mir::interpret::{\n-    ConstValue, ErrorHandled, LitToConstError, LitToConstInput, Scalar,\n+    ConstValue, ErrorHandled, GlobalId, LitToConstError, LitToConstInput, Scalar,\n };\n use rustc_middle::mir::{self, UserTypeProjection};\n use rustc_middle::mir::{BorrowKind, Mutability};\n@@ -518,16 +518,22 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n         };\n \n-        // `mir_const_qualif` must be called with the `DefId` of the item where the const is\n-        // defined, not where it is declared. The difference is significant for associated\n-        // constants.\n-        let mir_structural_match_violation = self.tcx.mir_const_qualif(instance.def_id()).custom_eq;\n-        debug!(\"mir_structural_match_violation({:?}) -> {}\", qpath, mir_structural_match_violation);\n-\n-        match self.tcx.const_eval_instance(param_env_reveal_all, instance, Some(span)) {\n-            Ok(literal) => {\n-                let const_ = mir::ConstantKind::Val(literal, ty);\n-                let pattern = self.const_to_pat(const_, id, span, mir_structural_match_violation);\n+        let cid = GlobalId { instance, promoted: None };\n+        // Prefer\n+        let const_value = self\n+            .tcx\n+            .const_eval_global_id_for_typeck(param_env_reveal_all, cid, Some(span))\n+            .and_then(|val| match val {\n+                Some(valtree) => Ok(mir::ConstantKind::Ty(self.tcx.mk_const(valtree, ty))),\n+                None => self\n+                    .tcx\n+                    .const_eval_global_id(param_env_reveal_all, cid, Some(span))\n+                    .map(|lit| mir::ConstantKind::Val(lit, ty)),\n+            });\n+\n+        match const_value {\n+            Ok(const_) => {\n+                let pattern = self.const_to_pat(const_, id, span, Some(instance.def_id()));\n \n                 if !is_associated_const {\n                     return pattern;\n@@ -578,9 +584,21 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         span: Span,\n     ) -> PatKind<'tcx> {\n         let value = mir::ConstantKind::from_inline_const(self.tcx, anon_const.def_id);\n-\n-        // Evaluate early like we do in `lower_path`.\n-        let value = value.eval(self.tcx, self.param_env);\n+        let value = match value {\n+            mir::ConstantKind::Ty(_) => value,\n+            // Evaluate early like we do in `lower_path`.\n+            mir::ConstantKind::Unevaluated(ct, ty) => {\n+                let ct = ty::UnevaluatedConst { def: ct.def, substs: ct.substs };\n+                if let Ok(Some(valtree)) =\n+                    self.tcx.const_eval_resolve_for_typeck(self.param_env, ct, Some(span))\n+                {\n+                    mir::ConstantKind::Ty(self.tcx.mk_const(valtree, ty))\n+                } else {\n+                    value.eval(self.tcx, self.param_env)\n+                }\n+            }\n+            mir::ConstantKind::Val(_, _) => unreachable!(),\n+        };\n \n         match value {\n             mir::ConstantKind::Ty(c) => match c.kind() {\n@@ -591,15 +609,17 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 ConstKind::Error(_) => {\n                     return PatKind::Wild;\n                 }\n-                _ => bug!(\"Expected ConstKind::Param\"),\n+                _ => {}\n             },\n-            mir::ConstantKind::Val(_, _) => self.const_to_pat(value, id, span, false).kind,\n+            mir::ConstantKind::Val(_, _) => {}\n             mir::ConstantKind::Unevaluated(..) => {\n                 // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n                 self.tcx.sess.emit_err(ConstPatternDependsOnGenericParameter { span });\n                 return PatKind::Wild;\n             }\n         }\n+\n+        self.const_to_pat(value, id, span, None).kind\n     }\n \n     /// Converts literals, paths and negation of literals to patterns.\n@@ -626,8 +646,14 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         let lit_input =\n             LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n-        match self.tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n-            Ok(constant) => self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n+        match self\n+            .tcx\n+            .at(expr.span)\n+            .lit_to_const(lit_input)\n+            .map(mir::ConstantKind::Ty)\n+            .or_else(|_| self.tcx.at(expr.span).lit_to_mir_constant(lit_input))\n+        {\n+            Ok(constant) => self.const_to_pat(constant, expr.hir_id, lit.span, None).kind,\n             Err(LitToConstError::Reported(_)) => PatKind::Wild,\n             Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n         }\n@@ -806,6 +832,9 @@ pub(crate) fn compare_const_vals<'tcx>(\n                 mir::ConstantKind::Val(ConstValue::Scalar(Scalar::Int(a)), _a_ty),\n                 mir::ConstantKind::Val(ConstValue::Scalar(Scalar::Int(b)), _b_ty),\n             ) => return Some(a.cmp(&b)),\n+            (mir::ConstantKind::Ty(a), mir::ConstantKind::Ty(b)) => {\n+                return Some(a.kind().cmp(&b.kind()));\n+            }\n             _ => {}\n         },\n     }"}, {"sha": "243cb463560e4e32246e08db42ff25373976b9e1", "filename": "compiler/rustc_mir_transform/src/required_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d030ece6f795c74bbb005b9a6956e5da1b9f155d/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d030ece6f795c74bbb005b9a6956e5da1b9f155d/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs?ref=d030ece6f795c74bbb005b9a6956e5da1b9f155d", "patch": "@@ -17,8 +17,8 @@ impl<'tcx> Visitor<'tcx> for RequiredConstsVisitor<'_, 'tcx> {\n         let literal = constant.literal;\n         match literal {\n             ConstantKind::Ty(c) => match c.kind() {\n-                ConstKind::Param(_) | ConstKind::Error(_) => {}\n-                _ => bug!(\"only ConstKind::Param should be encountered here, got {:#?}\", c),\n+                ConstKind::Param(_) | ConstKind::Error(_) | ConstKind::Value(_) => {}\n+                _ => bug!(\"only ConstKind::Param/Value should be encountered here, got {:#?}\", c),\n             },\n             ConstantKind::Unevaluated(..) => self.required_consts.push(*constant),\n             ConstantKind::Val(..) => {}"}, {"sha": "39373da6a9f605ae7a52f85d7d9306f1d6b7b43e", "filename": "tests/incremental/issue-101518.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fincremental%2Fissue-101518.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fincremental%2Fissue-101518.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fincremental%2Fissue-101518.rs?ref=d030ece6f795c74bbb005b9a6956e5da1b9f155d", "patch": "@@ -1,27 +1,20 @@\n-// revisions: cfail1\n-// should-ice\n-// error-pattern: forcing query\n-// known-bug: #101518\n+// revisions: cpass\n \n #[derive(PartialEq, Eq)]\n struct Id<'a> {\n     ns: &'a str,\n }\n fn visit_struct() {\n     let id = Id { ns: \"random1\" };\n-    const FLAG: Id<'static> = Id {\n-        ns: \"needs_to_be_the_same\",\n-    };\n+    const FLAG: Id<'static> = Id { ns: \"needs_to_be_the_same\" };\n     match id {\n         FLAG => {}\n         _ => {}\n     }\n }\n fn visit_struct2() {\n     let id = Id { ns: \"random2\" };\n-    const FLAG: Id<'static> = Id {\n-        ns: \"needs_to_be_the_same\",\n-    };\n+    const FLAG: Id<'static> = Id { ns: \"needs_to_be_the_same\" };\n     match id {\n         FLAG => {}\n         _ => {}"}, {"sha": "61ce5e54fdc1af550914715deb88b9e8d3447aff", "filename": "tests/mir-opt/deref-patterns/string.foo.PreCodegen.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir?ref=d030ece6f795c74bbb005b9a6956e5da1b9f155d", "patch": "@@ -35,7 +35,7 @@ fn foo(_1: Option<String>) -> i32 {\n                                          // + literal: Const { ty: for<'a, 'b> fn(&'a str, &'b str) -> bool {<str as PartialEq>::eq}, val: Value(<ZST>) }\n                                          // mir::Constant\n                                          // + span: $DIR/string.rs:9:14: 9:17\n-                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }\n+                                         // + literal: Const { ty: &str, val: Value(ValTree::Branch(..)) }\n     }\n \n     bb3: {"}, {"sha": "df28c474ab0a2012c95ae24fce475dfcdbedc1d2", "filename": "tests/ui/match/issue-70972-dyn-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs?ref=d030ece6f795c74bbb005b9a6956e5da1b9f155d", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let a: &dyn Send = &7u32;\n     match a {\n         F => panic!(),\n-        //~^ ERROR `&dyn Send` cannot be used in patterns\n+        //~^ ERROR `dyn Send` cannot be used in patterns\n         _ => {}\n     }\n }"}, {"sha": "f4dc910c34a6596eb3bc659705897c3425b51a58", "filename": "tests/ui/match/issue-70972-dyn-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr?ref=d030ece6f795c74bbb005b9a6956e5da1b9f155d", "patch": "@@ -1,4 +1,4 @@\n-error: `&dyn Send` cannot be used in patterns\n+error: `dyn Send` cannot be used in patterns\n   --> $DIR/issue-70972-dyn-trait.rs:6:9\n    |\n LL |         F => panic!(),"}, {"sha": "21edb26de082eb4d0c7d43519db3751e7453b055", "filename": "tests/ui/pattern/issue-72565.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fui%2Fpattern%2Fissue-72565.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fui%2Fpattern%2Fissue-72565.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-72565.rs?ref=d030ece6f795c74bbb005b9a6956e5da1b9f155d", "patch": "@@ -3,6 +3,6 @@ const F: &'static dyn PartialEq<u32> = &7u32;\n fn main() {\n     let a: &dyn PartialEq<u32> = &7u32;\n     match a {\n-        F => panic!(), //~ ERROR: `&dyn PartialEq<u32>` cannot be used in patterns\n+        F => panic!(), //~ ERROR: `dyn PartialEq<u32>` cannot be used in patterns\n     }\n }"}, {"sha": "0519720694d70b25aead81d4d840976def03f898", "filename": "tests/ui/pattern/issue-72565.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fui%2Fpattern%2Fissue-72565.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d030ece6f795c74bbb005b9a6956e5da1b9f155d/tests%2Fui%2Fpattern%2Fissue-72565.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-72565.stderr?ref=d030ece6f795c74bbb005b9a6956e5da1b9f155d", "patch": "@@ -1,4 +1,4 @@\n-error: `&dyn PartialEq<u32>` cannot be used in patterns\n+error: `dyn PartialEq<u32>` cannot be used in patterns\n   --> $DIR/issue-72565.rs:6:9\n    |\n LL |         F => panic!(),"}]}