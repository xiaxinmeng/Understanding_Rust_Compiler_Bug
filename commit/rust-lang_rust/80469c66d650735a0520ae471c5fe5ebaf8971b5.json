{"sha": "80469c66d650735a0520ae471c5fe5ebaf8971b5", "node_id": "C_kwDOAAsO6NoAKDgwNDY5YzY2ZDY1MDczNWEwNTIwYWU0NzFjNWZlNWViYWY4OTcxYjU", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-03-13T19:07:36Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-03-13T19:07:36Z"}, "message": "Move comparisons to SimdPartialOrd and SimdOrd traits", "tree": {"sha": "50fb71e0cbf4b55823e69eecffc7c463a38e432b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50fb71e0cbf4b55823e69eecffc7c463a38e432b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80469c66d650735a0520ae471c5fe5ebaf8971b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80469c66d650735a0520ae471c5fe5ebaf8971b5", "html_url": "https://github.com/rust-lang/rust/commit/80469c66d650735a0520ae471c5fe5ebaf8971b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80469c66d650735a0520ae471c5fe5ebaf8971b5/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72df4c45056a8bc0d1b3f06fdc828722177f0763", "url": "https://api.github.com/repos/rust-lang/rust/commits/72df4c45056a8bc0d1b3f06fdc828722177f0763", "html_url": "https://github.com/rust-lang/rust/commit/72df4c45056a8bc0d1b3f06fdc828722177f0763"}], "stats": {"total": 554, "additions": 354, "deletions": 200}, "files": [{"sha": "7b0d0a6864b9e631f5e4be1c417fcf5b4c01ef6e", "filename": "crates/core_simd/src/comparisons.rs", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=72df4c45056a8bc0d1b3f06fdc828722177f0763", "patch": "@@ -1,120 +0,0 @@\n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    T: SimdElement + PartialEq,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Test if each lane is equal to the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_eq(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n-    }\n-\n-    /// Test if each lane is not equal to the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_ne(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n-    }\n-}\n-\n-impl<T, const LANES: usize> Simd<T, LANES>\n-where\n-    T: SimdElement + PartialOrd,\n-    LaneCount<LANES>: SupportedLaneCount,\n-{\n-    /// Test if each lane is less than the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_lt(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n-    }\n-\n-    /// Test if each lane is greater than the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_gt(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n-    }\n-\n-    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_le(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n-    }\n-\n-    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn lanes_ge(self, other: Self) -> Mask<T::Mask, LANES> {\n-        // Safety: `self` is a vector, and the result of the comparison\n-        // is always a valid mask.\n-        unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n-    }\n-}\n-\n-macro_rules! impl_ord_methods_vector {\n-    { $type:ty } => {\n-        impl<const LANES: usize> Simd<$type, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Returns the lane-wise minimum with `other`.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn min(self, other: Self) -> Self {\n-                self.lanes_gt(other).select(other, self)\n-            }\n-\n-            /// Returns the lane-wise maximum with `other`.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn max(self, other: Self) -> Self {\n-                self.lanes_lt(other).select(other, self)\n-            }\n-\n-            /// Restrict each lane to a certain interval.\n-            ///\n-            /// For each lane, returns `max` if `self` is greater than `max`, and `min` if `self` is\n-            /// less than `min`. Otherwise returns `self`.\n-            ///\n-            /// # Panics\n-            ///\n-            /// Panics if `min > max` on any lane.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn clamp(self, min: Self, max: Self) -> Self {\n-                assert!(\n-                    min.lanes_le(max).all(),\n-                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n-                );\n-                self.max(min).min(max)\n-            }\n-        }\n-    }\n-}\n-\n-impl_ord_methods_vector!(i8);\n-impl_ord_methods_vector!(i16);\n-impl_ord_methods_vector!(i32);\n-impl_ord_methods_vector!(i64);\n-impl_ord_methods_vector!(isize);\n-impl_ord_methods_vector!(u8);\n-impl_ord_methods_vector!(u16);\n-impl_ord_methods_vector!(u32);\n-impl_ord_methods_vector!(u64);\n-impl_ord_methods_vector!(usize);"}, {"sha": "c7111f720a8ac51ba99b38cfc24dab07d616dea4", "filename": "crates/core_simd/src/eq.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Feq.rs?ref=80469c66d650735a0520ae471c5fe5ebaf8971b5", "patch": "@@ -0,0 +1,73 @@\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n+\n+/// Parallel `PartialEq`.\n+pub trait SimdPartialEq {\n+    /// The mask type returned by each comparison.\n+    type Mask;\n+\n+    /// Test if each lane is equal to the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_eq(self, other: Self) -> Self::Mask;\n+\n+    /// Test if each lane is equal to the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_ne(self, other: Self) -> Self::Mask;\n+}\n+\n+macro_rules! impl_number {\n+    { $($number:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdPartialEq for Simd<$number, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Mask<<$number as SimdElement>::Mask, LANES>;\n+\n+            #[inline]\n+            fn simd_eq(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_ne(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_number! { f32, f64, u8, u16, u32, u64, usize, i8, i16, i32, i64, isize }\n+\n+macro_rules! impl_mask {\n+    { $($integer:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdPartialEq for Mask<$integer, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Self;\n+\n+            #[inline]\n+            fn simd_eq(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_eq(self.to_int(), other.to_int())) }\n+            }\n+\n+            #[inline]\n+            fn simd_ne(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_ne(self.to_int(), other.to_int())) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_mask! { i8, i16, i32, i64, isize }"}, {"sha": "d4e57ed90bffd3bfe3d31ad20ad7b4e17a4a361a", "filename": "crates/core_simd/src/masks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=80469c66d650735a0520ae471c5fe5ebaf8971b5", "patch": "@@ -15,7 +15,7 @@ mod mask_impl;\n mod to_bitmask;\n pub use to_bitmask::ToBitMask;\n \n-use crate::simd::{intrinsics, LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use crate::simd::{intrinsics, LaneCount, Simd, SimdElement, SimdPartialEq, SupportedLaneCount};\n use core::cmp::Ordering;\n use core::{fmt, mem};\n \n@@ -56,7 +56,7 @@ macro_rules! impl_element {\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n-                (value.lanes_eq(Simd::splat(0)) | value.lanes_eq(Simd::splat(-1))).all()\n+                (value.simd_eq(Simd::splat(0 as _)) | value.simd_eq(Simd::splat(-1 as _))).all()\n             }\n \n             fn eq(self, other: Self) -> bool { self == other }"}, {"sha": "42257f4e119b9b0fdd9f6b7b1f8c6066846147d7", "filename": "crates/core_simd/src/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=80469c66d650735a0520ae471c5fe5ebaf8971b5", "patch": "@@ -9,13 +9,14 @@ pub(crate) mod intrinsics;\n #[cfg(feature = \"generic_const_exprs\")]\n mod to_bytes;\n \n-mod comparisons;\n+mod eq;\n mod fmt;\n mod iter;\n mod lane_count;\n mod masks;\n mod math;\n mod ops;\n+mod ord;\n mod round;\n mod select;\n mod vector;\n@@ -25,8 +26,10 @@ mod vendor;\n pub mod simd {\n     pub(crate) use crate::core_simd::intrinsics;\n \n+    pub use crate::core_simd::eq::*;\n     pub use crate::core_simd::lane_count::{LaneCount, SupportedLaneCount};\n     pub use crate::core_simd::masks::*;\n+    pub use crate::core_simd::ord::*;\n     pub use crate::core_simd::swizzle::*;\n     pub use crate::core_simd::vector::*;\n }"}, {"sha": "d39b4091df981d1db3e291dfb055a472800f18f3", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=80469c66d650735a0520ae471c5fe5ebaf8971b5", "patch": "@@ -1,4 +1,4 @@\n-use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SimdElement, SimdPartialEq, SupportedLaneCount};\n use core::ops::{Add, Mul};\n use core::ops::{BitAnd, BitOr, BitXor};\n use core::ops::{Div, Rem, Sub};\n@@ -74,18 +74,18 @@ macro_rules! int_divrem_guard {\n             $simd_call:ident\n         },\n         $int:ident ) => {\n-        if $rhs.lanes_eq(Simd::splat(0)).any() {\n+        if $rhs.simd_eq(Simd::splat(0 as _)).any() {\n             panic!($zero);\n         } else {\n             // Prevent otherwise-UB overflow on the MIN / -1 case.\n             let rhs = if <$int>::MIN != 0 {\n                 // This should, at worst, optimize to a few branchless logical ops\n                 // Ideally, this entire conditional should evaporate\n                 // Fire LLVM and implement those manually if it doesn't get the hint\n-                ($lhs.lanes_eq(Simd::splat(<$int>::MIN))\n+                ($lhs.simd_eq(Simd::splat(<$int>::MIN))\n                 // type inference can break here, so cut an SInt to size\n-                & $rhs.lanes_eq(Simd::splat(-1i64 as _)))\n-                .select(Simd::splat(1), $rhs)\n+                & $rhs.simd_eq(Simd::splat(-1i64 as _)))\n+                .select(Simd::splat(1 as _), $rhs)\n             } else {\n                 // Nice base case to make it easy to const-fold away the other branch.\n                 $rhs"}, {"sha": "befa4594595e3b1ada8d86150a60593cba334694", "filename": "crates/core_simd/src/ord.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ford.rs?ref=80469c66d650735a0520ae471c5fe5ebaf8971b5", "patch": "@@ -0,0 +1,222 @@\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n+\n+/// Parallel `PartialOrd`.\n+pub trait SimdPartialOrd {\n+    /// The mask type returned by each comparison.\n+    type Mask;\n+\n+    /// Test if each lane is less than the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_lt(self, other: Self) -> Self::Mask;\n+\n+    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_le(self, other: Self) -> Self::Mask;\n+\n+    /// Test if each lane is greater than the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_gt(self, other: Self) -> Self::Mask;\n+\n+    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n+    fn simd_ge(self, other: Self) -> Self::Mask;\n+}\n+\n+/// Parallel `Ord`.\n+pub trait SimdOrd: SimdPartialOrd {\n+    /// Returns the lane-wise maximum with `other`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_max(self, other: Self) -> Self;\n+\n+    /// Returns the lane-wise minimum with `other`.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_min(self, other: Self) -> Self;\n+\n+    /// Restrict each lane to a certain interval.\n+    ///\n+    /// For each lane, returns `max` if `self` is greater than `max`, and `min` if `self` is\n+    /// less than `min`. Otherwise returns `self`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `min > max` on any lane.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self;\n+}\n+\n+macro_rules! impl_integer {\n+    { $($integer:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdPartialOrd for Simd<$integer, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Mask<<$integer as SimdElement>::Mask, LANES>;\n+\n+            #[inline]\n+            fn simd_lt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_le(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_gt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_ge(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n+            }\n+        }\n+\n+        impl<const LANES: usize> SimdOrd for Simd<$integer, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            #[inline]\n+            fn simd_max(self, other: Self) -> Self {\n+                self.simd_lt(other).select(other, self)\n+            }\n+\n+            #[inline]\n+            fn simd_min(self, other: Self) -> Self {\n+                self.simd_gt(other).select(other, self)\n+            }\n+\n+            #[inline]\n+            fn simd_clamp(self, min: Self, max: Self) -> Self {\n+                assert!(\n+                    min.simd_le(max).all(),\n+                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+                );\n+                self.simd_max(min).simd_min(max)\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_integer! { u8, u16, u32, u64, usize, i8, i16, i32, i64, isize }\n+\n+macro_rules! impl_float {\n+    { $($float:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdPartialOrd for Simd<$float, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Mask<<$float as SimdElement>::Mask, LANES>;\n+\n+            #[inline]\n+            fn simd_lt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_le(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_gt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n+            }\n+\n+            #[inline]\n+            fn simd_ge(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_float! { f32, f64 }\n+\n+macro_rules! impl_mask {\n+    { $($integer:ty),* } => {\n+        $(\n+        impl<const LANES: usize> SimdPartialOrd for Mask<$integer, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Mask = Self;\n+\n+            #[inline]\n+            fn simd_lt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_lt(self.to_int(), other.to_int())) }\n+            }\n+\n+            #[inline]\n+            fn simd_le(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_le(self.to_int(), other.to_int())) }\n+            }\n+\n+            #[inline]\n+            fn simd_gt(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_gt(self.to_int(), other.to_int())) }\n+            }\n+\n+            #[inline]\n+            fn simd_ge(self, other: Self) -> Self::Mask {\n+                // Safety: `self` is a vector, and the result of the comparison\n+                // is always a valid mask.\n+                unsafe { Self::from_int_unchecked(intrinsics::simd_ge(self.to_int(), other.to_int())) }\n+            }\n+        }\n+\n+        impl<const LANES: usize> SimdOrd for Mask<$integer, LANES>\n+        where\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            #[inline]\n+            fn simd_max(self, other: Self) -> Self {\n+                self.simd_gt(other).select_mask(other, self)\n+            }\n+\n+            #[inline]\n+            fn simd_min(self, other: Self) -> Self {\n+                self.simd_lt(other).select_mask(other, self)\n+            }\n+\n+            #[inline]\n+            fn simd_clamp(self, min: Self, max: Self) -> Self {\n+                assert!(\n+                    min.simd_le(max).all(),\n+                    \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+                );\n+                self.simd_max(min).simd_min(max)\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_mask! { i8, i16, i32, i64, isize }"}, {"sha": "13e35ecfa49d349ebd9933a6b0e03097ba95a6c5", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=80469c66d650735a0520ae471c5fe5ebaf8971b5", "patch": "@@ -10,7 +10,7 @@ pub use uint::*;\n pub(crate) mod ptr;\n \n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Mask, MaskElement, SupportedLaneCount};\n+use crate::simd::{LaneCount, Mask, MaskElement, SimdPartialOrd, SupportedLaneCount};\n \n /// A SIMD vector of `LANES` elements of type `T`. `Simd<T, N>` has the same shape as [`[T; N]`](array), but operates like `T`.\n ///\n@@ -243,7 +243,7 @@ where\n         idxs: Simd<usize, LANES>,\n         or: Self,\n     ) -> Self {\n-        let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n+        let enable: Mask<isize, LANES> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n         // Safety: We have masked-off out-of-bounds lanes.\n         unsafe { Self::gather_select_unchecked(slice, enable, idxs, or) }\n     }\n@@ -260,13 +260,13 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # use core::simd::{Simd, Mask};\n+    /// # use core_simd::simd::{Simd, SimdPartialOrd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 5]);\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n     /// let enable = Mask::from_array([true, true, true, false]); // Note the final mask lane.\n     /// // If this mask was used to gather, it would be unsound. Let's fix that.\n-    /// let enable = enable & idxs.lanes_lt(Simd::splat(vec.len()));\n+    /// let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n     ///\n     /// // We have masked the OOB lane, so it's safe to gather now.\n     /// let result = unsafe { Simd::gather_select_unchecked(&vec, enable, idxs, alt) };\n@@ -317,7 +317,7 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # use core::simd::{Simd, Mask};\n+    /// # use core_simd::simd::{Simd, Mask};\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n@@ -333,7 +333,7 @@ where\n         enable: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n     ) {\n-        let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n+        let enable: Mask<isize, LANES> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n         // Safety: We have masked-off out-of-bounds lanes.\n         unsafe { self.scatter_select_unchecked(slice, enable, idxs) }\n     }\n@@ -351,13 +351,13 @@ where\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n-    /// # use core::simd::{Simd, Mask};\n+    /// # use core_simd::simd::{Simd, SimdPartialOrd, Mask};\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n     /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n     /// // If this mask was used to scatter, it would be unsound. Let's fix that.\n-    /// let enable = enable & idxs.lanes_lt(Simd::splat(vec.len()));\n+    /// let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n     ///\n     /// // We have masked the OOB lane, so it's safe to scatter now.\n     /// unsafe { vals.scatter_select_unchecked(&mut vec, enable, idxs); }"}, {"sha": "ebe4fbcb6fa863d3447a42da6e069b46fee6e88d", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=80469c66d650735a0520ae471c5fe5ebaf8971b5", "patch": "@@ -1,7 +1,7 @@\n #![allow(non_camel_case_types)]\n \n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Mask, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Mask, Simd, SimdPartialEq, SimdPartialOrd, SupportedLaneCount};\n \n /// Implements inherent methods for a float vector containing multiple\n /// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n@@ -74,43 +74,43 @@ macro_rules! impl_float_vector {\n             #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_sign_negative(self) -> Mask<$mask_ty, LANES> {\n                 let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n-                sign_bits.lanes_gt(Simd::splat(0))\n+                sign_bits.simd_gt(Simd::splat(0))\n             }\n \n             /// Returns true for each lane if its value is `NaN`.\n             #[inline]\n             #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_nan(self) -> Mask<$mask_ty, LANES> {\n-                self.lanes_ne(self)\n+                self.simd_ne(self)\n             }\n \n             /// Returns true for each lane if its value is positive infinity or negative infinity.\n             #[inline]\n             #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_infinite(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().lanes_eq(Self::splat(<$type>::INFINITY))\n+                self.abs().simd_eq(Self::splat(<$type>::INFINITY))\n             }\n \n             /// Returns true for each lane if its value is neither infinite nor `NaN`.\n             #[inline]\n             #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_finite(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().lanes_lt(Self::splat(<$type>::INFINITY))\n+                self.abs().simd_lt(Self::splat(<$type>::INFINITY))\n             }\n \n             /// Returns true for each lane if its value is subnormal.\n             #[inline]\n             #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_subnormal(self) -> Mask<$mask_ty, LANES> {\n-                self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).lanes_eq(Simd::splat(0))\n+                self.abs().simd_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).simd_eq(Simd::splat(0))\n             }\n \n             /// Returns true for each lane if its value is neither zero, infinite,\n             /// subnormal, nor `NaN`.\n             #[inline]\n             #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_normal(self) -> Mask<$mask_ty, LANES> {\n-                !(self.abs().lanes_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n+                !(self.abs().simd_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n             }\n \n             /// Replaces each lane with a number that represents its sign.\n@@ -140,7 +140,7 @@ macro_rules! impl_float_vector {\n             /// If one of the values is `NAN`, then the other value is returned.\n             #[inline]\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn min(self, other: Self) -> Self {\n+            pub fn simd_min(self, other: Self) -> Self {\n                 unsafe { intrinsics::simd_fmin(self, other) }\n             }\n \n@@ -149,7 +149,7 @@ macro_rules! impl_float_vector {\n             /// If one of the values is `NAN`, then the other value is returned.\n             #[inline]\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn max(self, other: Self) -> Self {\n+            pub fn simd_max(self, other: Self) -> Self {\n                 unsafe { intrinsics::simd_fmax(self, other) }\n             }\n \n@@ -160,14 +160,14 @@ macro_rules! impl_float_vector {\n             /// than `min`.  Otherwise returns the lane in `self`.\n             #[inline]\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn clamp(self, min: Self, max: Self) -> Self {\n+            pub fn simd_clamp(self, min: Self, max: Self) -> Self {\n                 assert!(\n-                    min.lanes_le(max).all(),\n+                    min.simd_le(max).all(),\n                     \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n                 );\n                 let mut x = self;\n-                x = x.lanes_lt(min).select(min, x);\n-                x = x.lanes_gt(max).select(max, x);\n+                x = x.simd_lt(min).select(min, x);\n+                x = x.simd_gt(max).select(max, x);\n                 x\n             }\n         }"}, {"sha": "85fabdc4e00200f2d90e7cad9d1e61976f5cc86d", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=80469c66d650735a0520ae471c5fe5ebaf8971b5", "patch": "@@ -1,6 +1,6 @@\n #![allow(non_camel_case_types)]\n \n-use crate::simd::{LaneCount, Mask, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Mask, Simd, SimdPartialOrd, SupportedLaneCount};\n \n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_integer_vector {\n@@ -12,13 +12,13 @@ macro_rules! impl_integer_vector {\n             /// Returns true for each positive lane and false if it is zero or negative.\n             #[inline]\n             pub fn is_positive(self) -> Mask<$type, LANES> {\n-                self.lanes_gt(Self::splat(0))\n+                self.simd_gt(Self::splat(0))\n             }\n \n             /// Returns true for each negative lane and false if it is zero or positive.\n             #[inline]\n             pub fn is_negative(self) -> Mask<$type, LANES> {\n-                self.lanes_lt(Self::splat(0))\n+                self.simd_lt(Self::splat(0))\n             }\n \n             /// Returns numbers representing the sign of each lane."}, {"sha": "f6c5d74fbbcc62ffcd2f044b33b9ed594e31abbd", "filename": "crates/core_simd/tests/i16_ops.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fi16_ops.rs?ref=80469c66d650735a0520ae471c5fe5ebaf8971b5", "patch": "@@ -1,32 +1,5 @@\n #![feature(portable_simd)]\n-use core_simd::i16x2;\n \n #[macro_use]\n mod ops_macros;\n impl_signed_tests! { i16 }\n-\n-#[test]\n-fn max_is_not_lexicographic() {\n-    let a = i16x2::splat(10);\n-    let b = i16x2::from_array([-4, 12]);\n-    assert_eq!(a.max(b), i16x2::from_array([10, 12]));\n-}\n-\n-#[test]\n-fn min_is_not_lexicographic() {\n-    let a = i16x2::splat(10);\n-    let b = i16x2::from_array([12, -4]);\n-    assert_eq!(a.min(b), i16x2::from_array([10, -4]));\n-}\n-\n-#[test]\n-fn clamp_is_not_lexicographic() {\n-    let a = i16x2::splat(10);\n-    let lo = i16x2::from_array([-12, -4]);\n-    let up = i16x2::from_array([-4, 12]);\n-    assert_eq!(a.clamp(lo, up), i16x2::from_array([-4, 10]));\n-\n-    let x = i16x2::from_array([1, 10]);\n-    let y = x.clamp(i16x2::splat(0), i16x2::splat(9));\n-    assert_eq!(y, i16x2::from_array([1, 9]));\n-}"}, {"sha": "f8389c910c68052fcb3889b310f9573e559193b9", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80469c66d650735a0520ae471c5fe5ebaf8971b5/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=80469c66d650735a0520ae471c5fe5ebaf8971b5", "patch": "@@ -222,34 +222,37 @@ macro_rules! impl_signed_tests {\n                     assert_eq!(a % b, Vector::<LANES>::splat(0));\n                 }\n \n-                fn min<const LANES: usize>() {\n+                fn simd_min<const LANES: usize>() {\n+                    use core_simd::simd::SimdOrd;\n                     let a = Vector::<LANES>::splat(Scalar::MIN);\n                     let b = Vector::<LANES>::splat(0);\n-                    assert_eq!(a.min(b), a);\n+                    assert_eq!(a.simd_min(b), a);\n                     let a = Vector::<LANES>::splat(Scalar::MAX);\n                     let b = Vector::<LANES>::splat(0);\n-                    assert_eq!(a.min(b), b);\n+                    assert_eq!(a.simd_min(b), b);\n                 }\n \n-                fn max<const LANES: usize>() {\n+                fn simd_max<const LANES: usize>() {\n+                    use core_simd::simd::SimdOrd;\n                     let a = Vector::<LANES>::splat(Scalar::MIN);\n                     let b = Vector::<LANES>::splat(0);\n-                    assert_eq!(a.max(b), b);\n+                    assert_eq!(a.simd_max(b), b);\n                     let a = Vector::<LANES>::splat(Scalar::MAX);\n                     let b = Vector::<LANES>::splat(0);\n-                    assert_eq!(a.max(b), a);\n+                    assert_eq!(a.simd_max(b), a);\n                 }\n \n-                fn clamp<const LANES: usize>() {\n+                fn simd_clamp<const LANES: usize>() {\n+                    use core_simd::simd::SimdOrd;\n                     let min = Vector::<LANES>::splat(Scalar::MIN);\n                     let max = Vector::<LANES>::splat(Scalar::MAX);\n                     let zero = Vector::<LANES>::splat(0);\n                     let one = Vector::<LANES>::splat(1);\n                     let negone = Vector::<LANES>::splat(-1);\n-                    assert_eq!(zero.clamp(min, max), zero);\n-                    assert_eq!(zero.clamp(min, one), zero);\n-                    assert_eq!(zero.clamp(one, max), one);\n-                    assert_eq!(zero.clamp(min, negone), negone);\n+                    assert_eq!(zero.simd_clamp(min, max), zero);\n+                    assert_eq!(zero.simd_clamp(min, one), zero);\n+                    assert_eq!(zero.simd_clamp(one, max), one);\n+                    assert_eq!(zero.simd_clamp(min, negone), negone);\n                 }\n             }\n \n@@ -458,10 +461,10 @@ macro_rules! impl_float_tests {\n                     )\n                 }\n \n-                fn min<const LANES: usize>() {\n+                fn simd_min<const LANES: usize>() {\n                     // Regular conditions (both values aren't zero)\n                     test_helpers::test_binary_elementwise(\n-                        &Vector::<LANES>::min,\n+                        &Vector::<LANES>::simd_min,\n                         &Scalar::min,\n                         // Reject the case where both values are zero with different signs\n                         &|a, b| {\n@@ -477,14 +480,14 @@ macro_rules! impl_float_tests {\n                     // Special case where both values are zero\n                     let p_zero = Vector::<LANES>::splat(0.);\n                     let n_zero = Vector::<LANES>::splat(-0.);\n-                    assert!(p_zero.min(n_zero).to_array().iter().all(|x| *x == 0.));\n-                    assert!(n_zero.min(p_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(p_zero.simd_min(n_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(n_zero.simd_min(p_zero).to_array().iter().all(|x| *x == 0.));\n                 }\n \n-                fn max<const LANES: usize>() {\n+                fn simd_max<const LANES: usize>() {\n                     // Regular conditions (both values aren't zero)\n                     test_helpers::test_binary_elementwise(\n-                        &Vector::<LANES>::max,\n+                        &Vector::<LANES>::simd_max,\n                         &Scalar::max,\n                         // Reject the case where both values are zero with different signs\n                         &|a, b| {\n@@ -500,11 +503,11 @@ macro_rules! impl_float_tests {\n                     // Special case where both values are zero\n                     let p_zero = Vector::<LANES>::splat(0.);\n                     let n_zero = Vector::<LANES>::splat(-0.);\n-                    assert!(p_zero.max(n_zero).to_array().iter().all(|x| *x == 0.));\n-                    assert!(n_zero.max(p_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(p_zero.simd_max(n_zero).to_array().iter().all(|x| *x == 0.));\n+                    assert!(n_zero.simd_max(p_zero).to_array().iter().all(|x| *x == 0.));\n                 }\n \n-                fn clamp<const LANES: usize>() {\n+                fn simd_clamp<const LANES: usize>() {\n                     test_helpers::test_3(&|value: [Scalar; LANES], mut min: [Scalar; LANES], mut max: [Scalar; LANES]| {\n                         for (min, max) in min.iter_mut().zip(max.iter_mut()) {\n                             if max < min {\n@@ -522,7 +525,7 @@ macro_rules! impl_float_tests {\n                         for i in 0..LANES {\n                             result_scalar[i] = value[i].clamp(min[i], max[i]);\n                         }\n-                        let result_vector = Vector::from_array(value).clamp(min.into(), max.into()).to_array();\n+                        let result_vector = Vector::from_array(value).simd_clamp(min.into(), max.into()).to_array();\n                         test_helpers::prop_assert_biteq!(result_scalar, result_vector);\n                         Ok(())\n                     })"}]}