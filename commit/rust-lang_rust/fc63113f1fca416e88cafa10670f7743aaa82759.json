{"sha": "fc63113f1fca416e88cafa10670f7743aaa82759", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNjMxMTNmMWZjYTQxNmU4OGNhZmExMDY3MGY3NzQzYWFhODI3NTk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-30T14:19:05Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-30T14:19:05Z"}, "message": "clarify ZST comment", "tree": {"sha": "38652258a5d0b33b825dc9b968ef53a9510852af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38652258a5d0b33b825dc9b968ef53a9510852af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc63113f1fca416e88cafa10670f7743aaa82759", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc63113f1fca416e88cafa10670f7743aaa82759", "html_url": "https://github.com/rust-lang/rust/commit/fc63113f1fca416e88cafa10670f7743aaa82759", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc63113f1fca416e88cafa10670f7743aaa82759/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "098bec82f6171c2e7e5b4136880eb52eda876bde", "url": "https://api.github.com/repos/rust-lang/rust/commits/098bec82f6171c2e7e5b4136880eb52eda876bde", "html_url": "https://github.com/rust-lang/rust/commit/098bec82f6171c2e7e5b4136880eb52eda876bde"}], "stats": {"total": 32, "additions": 16, "deletions": 16}, "files": [{"sha": "c82eaa13eef6f5fe255eb09ac4ec8162cae6b744", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc63113f1fca416e88cafa10670f7743aaa82759/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc63113f1fca416e88cafa10670f7743aaa82759/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=fc63113f1fca416e88cafa10670f7743aaa82759", "patch": "@@ -991,8 +991,8 @@ extern \"rust-intrinsic\" {\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///\n-    /// These restrictions apply even if the effectively copied size (`count *\n-    /// size_of::<T>()`) is `0`.\n+    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+    /// `0`, the pointers must be non-NULL and properly aligned.\n     ///\n     /// [`Copy`]: ../marker/trait.Copy.html\n     /// [`read`]: ../ptr/fn.read.html\n@@ -1074,8 +1074,8 @@ extern \"rust-intrinsic\" {\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///\n-    /// These restrictions apply even if the effectively copied size (`count *\n-    /// size_of::<T>()`) is `0`.\n+    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+    /// `0`, the pointers must be non-NULL and properly aligned.\n     ///\n     /// [`Copy`]: ../marker/trait.Copy.html\n     /// [`read`]: ../ptr/fn.read.html\n@@ -1121,8 +1121,8 @@ extern \"rust-intrinsic\" {\n     /// value of `T`. Creating an invalid value of `T` can result in undefined\n     /// behavior.\n     ///\n-    /// These restrictions apply even if the effectively written size (`count *\n-    /// size_of::<T>()`) is `0`.\n+    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+    /// `0`, the pointer must be non-NULL and properly aligned.\n     ///\n     /// [valid]: ../ptr/index.html#safety\n     ///"}, {"sha": "98f5ab21f27526c2abd531a3618d9893032e1b7a", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc63113f1fca416e88cafa10670f7743aaa82759/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc63113f1fca416e88cafa10670f7743aaa82759/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fc63113f1fca416e88cafa10670f7743aaa82759", "patch": "@@ -114,7 +114,7 @@ pub use intrinsics::write_bytes;\n /// again. [`write`] can be used to overwrite data without causing it to be\n /// dropped.\n ///\n-/// These restrictions apply even if `T` has size `0`.\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n /// [valid]: ../ptr/index.html#safety\n /// [`Copy`]: ../marker/trait.Copy.html\n@@ -205,7 +205,7 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n ///\n /// * Both `x` and `y` must be properly aligned.\n ///\n-/// These restrictions apply even if `T` has size `0`.\n+/// Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.\n ///\n /// [valid]: ../ptr/index.html#safety\n ///\n@@ -274,7 +274,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n ///   size_of::<T>()` bytes must *not* overlap with the region of memory\n ///   beginning at `y` with the same size.\n ///\n-/// These restrictions apply even if `T` has size `0`.\n+/// Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.\n ///\n /// [valid]: ../ptr/index.html#safety\n ///\n@@ -387,7 +387,7 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n ///\n /// * `dest` must be properly aligned.\n ///\n-/// These restrictions apply even if `T` has size `0`.\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n /// [valid]: ../ptr/index.html#safety\n ///\n@@ -426,7 +426,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n ///   case.\n ///\n-/// These restrictions apply even if `T` has size `0`.\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n /// ## Ownership of the Returned Value\n ///\n@@ -542,7 +542,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n ///\n-/// These restrictions apply even if `T` has size `0`.\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n /// [`Copy`]: ../marker/trait.Copy.html\n /// [`read`]: ./fn.read.html\n@@ -620,7 +620,7 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n ///   case.\n ///\n-/// These restrictions apply even if `T` has size `0`.\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n /// [valid]: ../ptr/index.html#safety\n /// [`write_unaligned`]: ./fn.write_unaligned.html\n@@ -693,7 +693,7 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// * `dst` must be [valid] for writes.\n ///\n-/// These restrictions apply even if `T` has size `0`.\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n /// [valid]: ../ptr/index.html#safety\n ///\n@@ -778,7 +778,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// However, storing non-[`Copy`] types in volatile memory is almost certainly\n /// incorrect.\n ///\n-/// These restrictions apply even if `T` has size `0`.\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n /// [valid]: ../ptr/index.html#safety\n /// [`Copy`]: ../marker/trait.Copy.html\n@@ -849,7 +849,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// * `dst` must be properly aligned.\n ///\n-/// These restrictions apply even if `T` has size `0`.\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n /// [valid]: ../ptr/index.html#safety\n ///"}]}