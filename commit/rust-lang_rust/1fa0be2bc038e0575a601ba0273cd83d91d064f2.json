{"sha": "1fa0be2bc038e0575a601ba0273cd83d91d064f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYTBiZTJiYzAzOGUwNTc1YTYwMWJhMDI3M2NkODNkOTFkMDY0ZjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-01-21T18:28:39Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-01-26T16:39:07Z"}, "message": "std: Stabilize custom hasher support in HashMap\n\nThis commit implements the stabilization of the custom hasher support intended\nfor 1.7 but left out due to some last-minute questions that needed some\ndecisions. A summary of the actions done in this PR are:\n\nStable\n\n* `std::hash::BuildHasher`\n* `BuildHasher::Hasher`\n* `BuildHasher::build_hasher`\n* `std::hash::BuildHasherDefault`\n* `HashMap::with_hasher`\n* `HashMap::with_capacity_and_hasher`\n* `HashSet::with_hasher`\n* `HashSet::with_capacity_and_hasher`\n* `std::collections::hash_map::RandomState`\n* `RandomState::new`\n\nDeprecated\n\n* `std::collections::hash_state`\n* `std::collections::hash_state::HashState` - this trait was also moved into\n  `std::hash` with a reexport here to ensure that we can have a blanket impl to\n  prevent immediate breakage on nightly. Note that this is unstable in both\n  location.\n* `HashMap::with_hash_state` - renamed\n* `HashMap::with_capacity_and_hash_state` - renamed\n* `HashSet::with_hash_state` - renamed\n* `HashSet::with_capacity_and_hash_state` - renamed\n\nCloses #27713", "tree": {"sha": "7f73d02c1762d6958e343176469b934b46ef31cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f73d02c1762d6958e343176469b934b46ef31cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fa0be2bc038e0575a601ba0273cd83d91d064f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fa0be2bc038e0575a601ba0273cd83d91d064f2", "html_url": "https://github.com/rust-lang/rust/commit/1fa0be2bc038e0575a601ba0273cd83d91d064f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fa0be2bc038e0575a601ba0273cd83d91d064f2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "670f5b06e47d847b3fc8c61392a65202f1d3dfa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/670f5b06e47d847b3fc8c61392a65202f1d3dfa2", "html_url": "https://github.com/rust-lang/rust/commit/670f5b06e47d847b3fc8c61392a65202f1d3dfa2"}], "stats": {"total": 357, "additions": 215, "deletions": 142}, "files": [{"sha": "9ab55620e0aece5ebad170eb205792215975639e", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -73,6 +73,7 @@\n \n use prelude::v1::*;\n \n+use marker;\n use mem;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -190,6 +191,77 @@ pub trait Hasher {\n     }\n }\n \n+/// A `BuildHasher` is typically used as a factory for instances of `Hasher`\n+/// which a `HashMap` can then use to hash keys independently.\n+///\n+/// Note that for each instance of `BuildHasher` the create hashers should be\n+/// identical. That is if the same stream of bytes is fed into each hasher the\n+/// same output will also be generated.\n+#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n+pub trait BuildHasher {\n+    /// Type of the hasher that will be created.\n+    #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n+    type Hasher: Hasher;\n+\n+    /// Creates a new hasher.\n+    #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n+    fn build_hasher(&self) -> Self::Hasher;\n+}\n+\n+/// A structure which implements `BuildHasher` for all `Hasher` types which also\n+/// implement `Default`.\n+///\n+/// This struct is 0-sized and does not need construction.\n+#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n+pub struct BuildHasherDefault<H>(marker::PhantomData<H>);\n+\n+#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n+impl<H: Default + Hasher> BuildHasher for BuildHasherDefault<H> {\n+    type Hasher = H;\n+\n+    fn build_hasher(&self) -> H {\n+        H::default()\n+    }\n+}\n+\n+#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n+impl<H> Clone for BuildHasherDefault<H> {\n+    fn clone(&self) -> BuildHasherDefault<H> {\n+        BuildHasherDefault(marker::PhantomData)\n+    }\n+}\n+\n+#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n+impl<H> Default for BuildHasherDefault<H> {\n+    fn default() -> BuildHasherDefault<H> {\n+        BuildHasherDefault(marker::PhantomData)\n+    }\n+}\n+\n+// The HashState trait is super deprecated, but it's here to have the blanket\n+// impl that goes from HashState -> BuildHasher\n+\n+/// Deprecated, renamed to `BuildHasher`\n+#[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n+           issue = \"27713\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"support moved to std::hash and \\\n+                                              renamed to BuildHasher\")]\n+pub trait HashState {\n+    /// Type of the hasher that will be created.\n+    type Hasher: Hasher;\n+\n+    /// Creates a new hasher based on the given state of this object.\n+    fn hasher(&self) -> Self::Hasher;\n+}\n+\n+#[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n+           issue = \"27713\")]\n+#[allow(deprecated)]\n+impl<T: HashState> BuildHasher for T {\n+    type Hasher = T::Hasher;\n+    fn build_hasher(&self) -> T::Hasher { self.hasher() }\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n \n mod impls {"}, {"sha": "2712ed2a190380dba8c16ebd3672403501c4a350", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -29,7 +29,6 @@\n #![feature(collections)]\n #![feature(const_fn)]\n #![feature(enumset)]\n-#![feature(hashmap_hasher)]\n #![feature(iter_arith)]\n #![feature(libc)]\n #![feature(nonzero)]"}, {"sha": "9441e34cb9b1fad3b011d6ede0475f96bf2fc14a", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -12,10 +12,9 @@\n \n use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n-use std::collections::hash_state::HashState;\n use std::ffi::CString;\n use std::fmt::Debug;\n-use std::hash::Hash;\n+use std::hash::{Hash, BuildHasher};\n use std::iter::repeat;\n use std::path::Path;\n use std::time::Instant;\n@@ -217,7 +216,7 @@ pub trait MemoizationMap {\n }\n \n impl<K, V, S> MemoizationMap for RefCell<HashMap<K,V,S>>\n-    where K: Hash+Eq+Clone, V: Clone, S: HashState\n+    where K: Hash+Eq+Clone, V: Clone, S: BuildHasher\n {\n     type Key = K;\n     type Value = V;"}, {"sha": "6f4dc28e12221c13c423f67e9b6904dde5c029a8", "filename": "src/librustc_data_structures/fnv.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibrustc_data_structures%2Ffnv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibrustc_data_structures%2Ffnv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffnv.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -9,21 +9,20 @@\n // except according to those terms.\n \n use std::collections::{HashMap, HashSet};\n-use std::collections::hash_state::DefaultState;\n use std::default::Default;\n-use std::hash::{Hasher, Hash};\n+use std::hash::{Hasher, Hash, BuildHasherDefault};\n \n-pub type FnvHashMap<K, V> = HashMap<K, V, DefaultState<FnvHasher>>;\n-pub type FnvHashSet<V> = HashSet<V, DefaultState<FnvHasher>>;\n+pub type FnvHashMap<K, V> = HashMap<K, V, BuildHasherDefault<FnvHasher>>;\n+pub type FnvHashSet<V> = HashSet<V, BuildHasherDefault<FnvHasher>>;\n \n #[allow(non_snake_case)]\n pub fn FnvHashMap<K: Hash + Eq, V>() -> FnvHashMap<K, V> {\n-    Default::default()\n+    HashMap::default()\n }\n \n #[allow(non_snake_case)]\n pub fn FnvHashSet<V: Hash + Eq>() -> FnvHashSet<V> {\n-    Default::default()\n+    HashSet::default()\n }\n \n /// A speedy hash algorithm for node ids and def ids. The hashmap in"}, {"sha": "20caf7dd0cfc1c59046327038f3c46a1bccad44a", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -24,7 +24,6 @@\n       html_favicon_url = \"https://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n-#![feature(hashmap_hasher)]\n #![feature(nonzero)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "804e1af19aba2816f8b42baf9f13a1822484f861", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -10,8 +10,7 @@\n \n //! Implementations of serialization for structures found in libcollections\n \n-use std::hash::Hash;\n-use std::collections::hash_state::HashState;\n+use std::hash::{Hash, BuildHasher};\n use std::mem;\n \n use {Decodable, Encodable, Decoder, Encoder};\n@@ -159,7 +158,7 @@ impl<\n impl<K, V, S> Encodable for HashMap<K, V, S>\n     where K: Encodable + Hash + Eq,\n           V: Encodable,\n-          S: HashState,\n+          S: BuildHasher,\n {\n     fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n@@ -177,12 +176,12 @@ impl<K, V, S> Encodable for HashMap<K, V, S>\n impl<K, V, S> Decodable for HashMap<K, V, S>\n     where K: Decodable + Hash + Eq,\n           V: Decodable,\n-          S: HashState + Default,\n+          S: BuildHasher + Default,\n {\n     fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n         d.read_map(|d, len| {\n             let state = Default::default();\n-            let mut map = HashMap::with_capacity_and_hash_state(len, state);\n+            let mut map = HashMap::with_capacity_and_hasher(len, state);\n             for i in 0..len {\n                 let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n                 let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n@@ -195,7 +194,7 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n \n impl<T, S> Encodable for HashSet<T, S>\n     where T: Encodable + Hash + Eq,\n-          S: HashState,\n+          S: BuildHasher,\n {\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n@@ -211,12 +210,12 @@ impl<T, S> Encodable for HashSet<T, S>\n \n impl<T, S> Decodable for HashSet<T, S>\n     where T: Decodable + Hash + Eq,\n-          S: HashState + Default,\n+          S: BuildHasher + Default,\n {\n     fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n         d.read_seq(|d, len| {\n             let state = Default::default();\n-            let mut set = HashSet::with_capacity_and_hash_state(len, state);\n+            let mut set = HashSet::with_capacity_and_hasher(len, state);\n             for i in 0..len {\n                 set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }"}, {"sha": "8bb596c8bb2485b95f579a659a92de484e76c64d", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -29,7 +29,6 @@ Core encoding and decoding interfaces.\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(enumset)]\n-#![feature(hashmap_hasher)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(str_char)]"}, {"sha": "509964cd29b888b988cc60083e9625ce40c449e2", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 66, "deletions": 58, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -13,16 +13,12 @@ use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n use borrow::Borrow;\n-use clone::Clone;\n-use cmp::{max, Eq, PartialEq};\n-use default::Default;\n+use cmp::max;\n use fmt::{self, Debug};\n-use hash::{Hash, SipHasher};\n-use iter::{self, Iterator, ExactSizeIterator, IntoIterator, FromIterator, Extend, Map};\n-use marker::Sized;\n+use hash::{Hash, SipHasher, BuildHasher};\n+use iter::{self, Map, FromIterator};\n use mem::{self, replace};\n-use ops::{Deref, FnMut, FnOnce, Index};\n-use option::Option::{self, Some, None};\n+use ops::{Deref, Index};\n use rand::{self, Rng};\n \n use super::table::{\n@@ -39,7 +35,6 @@ use super::table::BucketState::{\n     Empty,\n     Full,\n };\n-use super::state::HashState;\n \n const INITIAL_LOG2_CAP: usize = 5;\n const INITIAL_CAPACITY: usize = 1 << INITIAL_LOG2_CAP; // 2^5\n@@ -307,7 +302,7 @@ fn test_resize_policy() {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashMap<K, V, S = RandomState> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n-    hash_state: S,\n+    hash_builder: S,\n \n     table: RawTable<K, V>,\n \n@@ -455,10 +450,10 @@ impl<K, V, M> SearchResult<K, V, M> {\n }\n \n impl<K, V, S> HashMap<K, V, S>\n-    where K: Eq + Hash, S: HashState\n+    where K: Eq + Hash, S: BuildHasher\n {\n     fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash {\n-        table::make_hash(&self.hash_state, x)\n+        table::make_hash(&self.hash_builder, x)\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n@@ -528,40 +523,52 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> {\n-        HashMap::with_capacity_and_hash_state(capacity, Default::default())\n+        HashMap::with_capacity_and_hasher(capacity, Default::default())\n     }\n }\n \n impl<K, V, S> HashMap<K, V, S>\n-    where K: Eq + Hash, S: HashState\n+    where K: Eq + Hash, S: BuildHasher\n {\n-    /// Creates an empty hashmap which will use the given hasher to hash keys.\n+    /// Creates an empty hashmap which will use the given hash builder to hash\n+    /// keys.\n     ///\n     /// The created map has the default initial capacity.\n     ///\n+    /// Warning: `hash_builder` is normally randomly generated, and\n+    /// is designed to allow HashMaps to be resistant to attacks that\n+    /// cause many collisions and very poor performance. Setting it\n+    /// manually using this function can expose a DoS attack vector.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(hashmap_hasher)]\n-    ///\n     /// use std::collections::HashMap;\n     /// use std::collections::hash_map::RandomState;\n     ///\n     /// let s = RandomState::new();\n-    /// let mut map = HashMap::with_hash_state(s);\n+    /// let mut map = HashMap::with_hasher(s);\n     /// map.insert(1, 2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n-               issue = \"27713\")]\n-    pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n+    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n+    pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n         HashMap {\n-            hash_state:    hash_state,\n+            hash_builder: hash_builder,\n             resize_policy: DefaultResizePolicy::new(),\n-            table:         RawTable::new(0),\n+            table: RawTable::new(0),\n         }\n     }\n \n+    /// Deprecated, renamed to `with_hasher`\n+    #[inline]\n+    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n+               issue = \"27713\")]\n+    #[rustc_deprecated(since = \"1.7.0\", reason = \"renamed to with_hasher\")]\n+    pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n+        HashMap::with_hasher(hash_state)\n+    }\n+\n     /// Creates an empty HashMap with space for at least `capacity`\n     /// elements, using `hasher` to hash the keys.\n     ///\n@@ -573,31 +580,39 @@ impl<K, V, S> HashMap<K, V, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(hashmap_hasher)]\n-    ///\n     /// use std::collections::HashMap;\n     /// use std::collections::hash_map::RandomState;\n     ///\n     /// let s = RandomState::new();\n-    /// let mut map = HashMap::with_capacity_and_hash_state(10, s);\n+    /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n     /// map.insert(1, 2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n-               issue = \"27713\")]\n-    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n-                                        -> HashMap<K, V, S> {\n+    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n+    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S)\n+                                    -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n         let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n         let internal_cap = min_cap.checked_next_power_of_two().expect(\"capacity overflow\");\n         assert!(internal_cap >= capacity, \"capacity overflow\");\n         HashMap {\n-            hash_state:    hash_state,\n+            hash_builder: hash_builder,\n             resize_policy: resize_policy,\n-            table:         RawTable::new(internal_cap),\n+            table: RawTable::new(internal_cap),\n         }\n     }\n \n+    /// Deprecated, renamed to `with_capacity_and_hasher`\n+    #[inline]\n+    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n+               issue = \"27713\")]\n+    #[rustc_deprecated(since = \"1.7.0\",\n+                       reason = \"renamed to with_capacity_and_hasher\")]\n+    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n+                                        -> HashMap<K, V, S> {\n+        HashMap::with_capacity_and_hasher(capacity, hash_state)\n+    }\n+\n     /// Returns the number of elements the map can hold without reallocating.\n     ///\n     /// This number is a lower bound; the `HashMap<K, V>` might be able to hold\n@@ -1212,7 +1227,7 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> PartialEq for HashMap<K, V, S>\n-    where K: Eq + Hash, V: PartialEq, S: HashState\n+    where K: Eq + Hash, V: PartialEq, S: BuildHasher\n {\n     fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n         if self.len() != other.len() { return false; }\n@@ -1225,12 +1240,12 @@ impl<K, V, S> PartialEq for HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Eq for HashMap<K, V, S>\n-    where K: Eq + Hash, V: Eq, S: HashState\n+    where K: Eq + Hash, V: Eq, S: BuildHasher\n {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Debug for HashMap<K, V, S>\n-    where K: Eq + Hash + Debug, V: Debug, S: HashState\n+    where K: Eq + Hash + Debug, V: Debug, S: BuildHasher\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_map().entries(self.iter()).finish()\n@@ -1240,18 +1255,18 @@ impl<K, V, S> Debug for HashMap<K, V, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Default for HashMap<K, V, S>\n     where K: Eq + Hash,\n-          S: HashState + Default,\n+          S: BuildHasher + Default,\n {\n     fn default() -> HashMap<K, V, S> {\n-        HashMap::with_hash_state(Default::default())\n+        HashMap::with_hasher(Default::default())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>\n     where K: Eq + Hash + Borrow<Q>,\n           Q: Eq + Hash,\n-          S: HashState,\n+          S: BuildHasher,\n {\n     type Output = V;\n \n@@ -1368,7 +1383,7 @@ enum VacantEntryState<K, V, M> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n-    where K: Eq + Hash, S: HashState\n+    where K: Eq + Hash, S: BuildHasher\n {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n@@ -1380,7 +1395,7 @@ impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n-    where K: Eq + Hash, S: HashState\n+    where K: Eq + Hash, S: BuildHasher\n {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n@@ -1392,7 +1407,7 @@ impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> IntoIterator for HashMap<K, V, S>\n-    where K: Eq + Hash, S: HashState\n+    where K: Eq + Hash, S: BuildHasher\n {\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V>;\n@@ -1571,21 +1586,20 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash, S: HashState + Default\n+    where K: Eq + Hash, S: BuildHasher + Default\n {\n     fn from_iter<T: IntoIterator<Item=(K, V)>>(iterable: T) -> HashMap<K, V, S> {\n         let iter = iterable.into_iter();\n         let lower = iter.size_hint().0;\n-        let mut map = HashMap::with_capacity_and_hash_state(lower,\n-                                                            Default::default());\n+        let mut map = HashMap::with_capacity_and_hasher(lower, Default::default());\n         map.extend(iter);\n         map\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash, S: HashState\n+    where K: Eq + Hash, S: BuildHasher\n {\n     fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n@@ -1596,7 +1610,7 @@ impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\n \n #[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\n impl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>\n-    where K: Eq + Hash + Copy, V: Copy, S: HashState\n+    where K: Eq + Hash + Copy, V: Copy, S: BuildHasher\n {\n     fn extend<T: IntoIterator<Item=(&'a K, &'a V)>>(&mut self, iter: T) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n@@ -1609,34 +1623,28 @@ impl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>\n /// `Hasher`, but the hashers created by two different `RandomState`\n /// instances are unlikely to produce the same result for the same values.\n #[derive(Clone)]\n-#[unstable(feature = \"hashmap_hasher\",\n-           reason = \"hashing an hash maps may be altered\",\n-           issue = \"27713\")]\n+#[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n pub struct RandomState {\n     k0: u64,\n     k1: u64,\n }\n \n-#[unstable(feature = \"hashmap_hasher\",\n-           reason = \"hashing an hash maps may be altered\",\n-           issue = \"27713\")]\n impl RandomState {\n     /// Constructs a new `RandomState` that is initialized with random keys.\n     #[inline]\n     #[allow(deprecated)] // rand\n+    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn new() -> RandomState {\n         let mut r = rand::thread_rng();\n         RandomState { k0: r.gen(), k1: r.gen() }\n     }\n }\n \n-#[unstable(feature = \"hashmap_hasher\",\n-           reason = \"hashing an hash maps may be altered\",\n-           issue = \"27713\")]\n-impl HashState for RandomState {\n+#[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n+impl BuildHasher for RandomState {\n     type Hasher = SipHasher;\n     #[inline]\n-    fn hasher(&self) -> SipHasher {\n+    fn build_hasher(&self) -> SipHasher {\n         SipHasher::new_with_keys(self.k0, self.k1)\n     }\n }\n@@ -1650,7 +1658,7 @@ impl Default for RandomState {\n }\n \n impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n-    where K: Eq + Hash + Borrow<Q>, S: HashState, Q: Eq + Hash\n+    where K: Eq + Hash + Borrow<Q>, S: BuildHasher, Q: Eq + Hash\n {\n     type Key = K;\n "}, {"sha": "b5f47853afd4ef0bebbcd254f2ee5949a47d8734", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 54, "deletions": 41, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -9,19 +9,13 @@\n // except according to those terms.\n \n use borrow::Borrow;\n-use clone::Clone;\n-use cmp::{Eq, PartialEq};\n-use core::marker::Sized;\n-use default::Default;\n use fmt;\n-use hash::Hash;\n-use iter::{Iterator, IntoIterator, ExactSizeIterator, FromIterator, Map, Chain, Extend};\n+use hash::{Hash, BuildHasher};\n+use iter::{Map, Chain, FromIterator};\n use ops::{BitOr, BitAnd, BitXor, Sub};\n-use option::Option::{Some, None, self};\n \n use super::Recover;\n use super::map::{self, HashMap, Keys, RandomState};\n-use super::state::HashState;\n \n const INITIAL_CAPACITY: usize = 32;\n \n@@ -144,30 +138,32 @@ impl<T: Hash + Eq> HashSet<T, RandomState> {\n }\n \n impl<T, S> HashSet<T, S>\n-    where T: Eq + Hash, S: HashState\n+    where T: Eq + Hash, S: BuildHasher\n {\n     /// Creates a new empty hash set which will use the given hasher to hash\n     /// keys.\n     ///\n     /// The hash set is also created with the default initial capacity.\n     ///\n+    /// Warning: `hasher` is normally randomly generated, and\n+    /// is designed to allow `HashSet`s to be resistant to attacks that\n+    /// cause many collisions and very poor performance. Setting it\n+    /// manually using this function can expose a DoS attack vector.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(hashmap_hasher)]\n-    ///\n     /// use std::collections::HashSet;\n     /// use std::collections::hash_map::RandomState;\n     ///\n     /// let s = RandomState::new();\n-    /// let mut set = HashSet::with_hash_state(s);\n+    /// let mut set = HashSet::with_hasher(s);\n     /// set.insert(2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n-               issue = \"27713\")]\n-    pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n-        HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n+    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n+    pub fn with_hasher(hasher: S) -> HashSet<T, S> {\n+        HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n \n     /// Creates an empty HashSet with space for at least `capacity`\n@@ -181,23 +177,40 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(hashmap_hasher)]\n-    ///\n     /// use std::collections::HashSet;\n     /// use std::collections::hash_map::RandomState;\n     ///\n     /// let s = RandomState::new();\n-    /// let mut set = HashSet::with_capacity_and_hash_state(10, s);\n+    /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n     /// set.insert(1);\n     /// ```\n     #[inline]\n+    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n+    pub fn with_capacity_and_hasher(capacity: usize, hasher: S)\n+                                    -> HashSet<T, S> {\n+        HashSet {\n+            map: HashMap::with_capacity_and_hasher(capacity, hasher),\n+        }\n+    }\n+\n+    /// Deprecated, renamed to `with_hasher`\n+    #[inline]\n     #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n                issue = \"27713\")]\n+    #[rustc_deprecated(since = \"1.7.0\", reason = \"renamed to with_hasher\")]\n+    pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n+        HashSet::with_hasher(hash_state)\n+    }\n+\n+    /// Deprecated, renamed to `with_capacity_and_hasher`\n+    #[inline]\n+    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n+               issue = \"27713\")]\n+    #[rustc_deprecated(since = \"1.7.0\",\n+                       reason = \"renamed to with_capacity_and_hasher\")]\n     pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n                                         -> HashSet<T, S> {\n-        HashSet {\n-            map: HashMap::with_capacity_and_hash_state(capacity, hash_state),\n-        }\n+        HashSet::with_capacity_and_hasher(capacity, hash_state)\n     }\n \n     /// Returns the number of elements the set can hold without reallocating.\n@@ -604,7 +617,7 @@ impl<T, S> HashSet<T, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> PartialEq for HashSet<T, S>\n-    where T: Eq + Hash, S: HashState\n+    where T: Eq + Hash, S: BuildHasher\n {\n     fn eq(&self, other: &HashSet<T, S>) -> bool {\n         if self.len() != other.len() { return false; }\n@@ -615,13 +628,13 @@ impl<T, S> PartialEq for HashSet<T, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Eq for HashSet<T, S>\n-    where T: Eq + Hash, S: HashState\n+    where T: Eq + Hash, S: BuildHasher\n {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> fmt::Debug for HashSet<T, S>\n     where T: Eq + Hash + fmt::Debug,\n-          S: HashState\n+          S: BuildHasher\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_set().entries(self.iter()).finish()\n@@ -631,12 +644,12 @@ impl<T, S> fmt::Debug for HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> FromIterator<T> for HashSet<T, S>\n     where T: Eq + Hash,\n-          S: HashState + Default,\n+          S: BuildHasher + Default,\n {\n     fn from_iter<I: IntoIterator<Item=T>>(iterable: I) -> HashSet<T, S> {\n         let iter = iterable.into_iter();\n         let lower = iter.size_hint().0;\n-        let mut set = HashSet::with_capacity_and_hash_state(lower, Default::default());\n+        let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n         set.extend(iter);\n         set\n     }\n@@ -645,7 +658,7 @@ impl<T, S> FromIterator<T> for HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Extend<T> for HashSet<T, S>\n     where T: Eq + Hash,\n-          S: HashState,\n+          S: BuildHasher,\n {\n     fn extend<I: IntoIterator<Item=T>>(&mut self, iter: I) {\n         for k in iter {\n@@ -657,7 +670,7 @@ impl<T, S> Extend<T> for HashSet<T, S>\n #[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\n impl<'a, T, S> Extend<&'a T> for HashSet<T, S>\n     where T: 'a + Eq + Hash + Copy,\n-          S: HashState,\n+          S: BuildHasher,\n {\n     fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n@@ -667,17 +680,17 @@ impl<'a, T, S> Extend<&'a T> for HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Default for HashSet<T, S>\n     where T: Eq + Hash,\n-          S: HashState + Default,\n+          S: BuildHasher + Default,\n {\n     fn default() -> HashSet<T, S> {\n-        HashSet::with_hash_state(Default::default())\n+        HashSet::with_hasher(Default::default())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: HashState + Default,\n+          S: BuildHasher + Default,\n {\n     type Output = HashSet<T, S>;\n \n@@ -709,7 +722,7 @@ impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: HashState + Default,\n+          S: BuildHasher + Default,\n {\n     type Output = HashSet<T, S>;\n \n@@ -741,7 +754,7 @@ impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: HashState + Default,\n+          S: BuildHasher + Default,\n {\n     type Output = HashSet<T, S>;\n \n@@ -773,7 +786,7 @@ impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: HashState + Default,\n+          S: BuildHasher + Default,\n {\n     type Output = HashSet<T, S>;\n \n@@ -852,7 +865,7 @@ pub struct Union<'a, T: 'a, S: 'a> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> IntoIterator for &'a HashSet<T, S>\n-    where T: Eq + Hash, S: HashState\n+    where T: Eq + Hash, S: BuildHasher\n {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n@@ -865,7 +878,7 @@ impl<'a, T, S> IntoIterator for &'a HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> IntoIterator for HashSet<T, S>\n     where T: Eq + Hash,\n-          S: HashState\n+          S: BuildHasher\n {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n@@ -947,7 +960,7 @@ impl<'a, T, S> Clone for Intersection<'a, T, S> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Intersection<'a, T, S>\n-    where T: Eq + Hash, S: HashState\n+    where T: Eq + Hash, S: BuildHasher\n {\n     type Item = &'a T;\n \n@@ -977,7 +990,7 @@ impl<'a, T, S> Clone for Difference<'a, T, S> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Difference<'a, T, S>\n-    where T: Eq + Hash, S: HashState\n+    where T: Eq + Hash, S: BuildHasher\n {\n     type Item = &'a T;\n \n@@ -1007,7 +1020,7 @@ impl<'a, T, S> Clone for SymmetricDifference<'a, T, S> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>\n-    where T: Eq + Hash, S: HashState\n+    where T: Eq + Hash, S: BuildHasher\n {\n     type Item = &'a T;\n \n@@ -1022,7 +1035,7 @@ impl<'a, T, S> Clone for Union<'a, T, S> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Union<'a, T, S>\n-    where T: Eq + Hash, S: HashState\n+    where T: Eq + Hash, S: BuildHasher\n {\n     type Item = &'a T;\n "}, {"sha": "167aca083038ef948caeb368239c3620ddb81715", "filename": "src/libstd/collections/hash/state.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -10,31 +10,15 @@\n \n #![unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n             issue = \"27713\")]\n+#![rustc_deprecated(since = \"1.7.0\", reason = \"support moved to std::hash\")]\n+#![allow(deprecated)]\n \n use clone::Clone;\n use default::Default;\n use hash;\n use marker;\n \n-/// A trait representing stateful hashes which can be used to hash keys in a\n-/// `HashMap`.\n-///\n-/// A HashState is used as a factory for instances of `Hasher` which a `HashMap`\n-/// can then use to hash keys independently. A `HashMap` by default uses a state\n-/// which will create instances of a `SipHasher`, but a custom state factory can\n-/// be provided to the `with_hash_state` function.\n-///\n-/// If a hashing algorithm has no initial state, then the `Hasher` type for that\n-/// algorithm can implement the `Default` trait and create hash maps with the\n-/// `DefaultState` structure. This state is 0-sized and will simply delegate\n-/// to `Default` when asked to create a hasher.\n-pub trait HashState {\n-    /// Type of the hasher that will be created.\n-    type Hasher: hash::Hasher;\n-\n-    /// Creates a new hasher based on the given state of this object.\n-    fn hasher(&self) -> Self::Hasher;\n-}\n+pub use hash::HashState;\n \n /// A structure which is a factory for instances of `Hasher` which implement the\n /// default trait."}, {"sha": "316c75952667c9e621e91da24e2bc40657c78bab", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -11,13 +11,12 @@\n use alloc::heap::{allocate, deallocate, EMPTY};\n \n use cmp;\n-use hash::{Hash, Hasher};\n+use hash::{Hash, Hasher, BuildHasher};\n use marker;\n use mem::{align_of, size_of};\n use mem;\n use ops::{Deref, DerefMut};\n use ptr::{self, Unique};\n-use collections::hash_state::HashState;\n \n use self::BucketState::*;\n \n@@ -144,9 +143,9 @@ impl SafeHash {\n /// This function wraps up `hash_keyed` to be the only way outside this\n /// module to generate a SafeHash.\n pub fn make_hash<T: ?Sized, S>(hash_state: &S, t: &T) -> SafeHash\n-    where T: Hash, S: HashState\n+    where T: Hash, S: BuildHasher\n {\n-    let mut state = hash_state.hasher();\n+    let mut state = hash_state.build_hasher();\n     t.hash(&mut state);\n     // We need to avoid 0 in order to prevent collisions with\n     // EMPTY_HASH. We can maintain our precious uniform distribution"}, {"sha": "417261cf4c304a3073aa624c773692b302e6ac1b", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -444,6 +444,8 @@ pub mod hash_set {\n /// HashSet.\n #[unstable(feature = \"hashmap_hasher\", reason = \"module was recently added\",\n            issue = \"27713\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"support moved to std::hash\")]\n+#[allow(deprecated)]\n pub mod hash_state {\n     pub use super::hash::state::*;\n }"}, {"sha": "e7bcdcc785f22a35c3fcccfc14d63ec5030282e3", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa0be2bc038e0575a601ba0273cd83d91d064f2/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=1fa0be2bc038e0575a601ba0273cd83d91d064f2", "patch": "@@ -231,6 +231,7 @@\n #![feature(float_from_str_radix)]\n #![feature(fnbox)]\n #![feature(heap_api)]\n+#![feature(hashmap_hasher)]\n #![feature(int_error_internals)]\n #![feature(into_cow)]\n #![feature(lang_items)]"}]}