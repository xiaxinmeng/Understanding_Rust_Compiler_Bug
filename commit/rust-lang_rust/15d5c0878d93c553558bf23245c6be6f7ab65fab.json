{"sha": "15d5c0878d93c553558bf23245c6be6f7ab65fab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZDVjMDg3OGQ5M2M1NTM1NThiZjIzMjQ1YzZiZTZmN2FiNjVmYWI=", "commit": {"author": {"name": "Simon Mazur", "email": "semmaz.box@gmail.com", "date": "2015-09-10T13:48:11Z"}, "committer": {"name": "Simon Mazur", "email": "semmaz.box@gmail.com", "date": "2015-09-11T16:44:06Z"}, "message": "some code improvements in libfmt_macros", "tree": {"sha": "c8ffb98a5c622270a3205383dcf2e403331f1c1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8ffb98a5c622270a3205383dcf2e403331f1c1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15d5c0878d93c553558bf23245c6be6f7ab65fab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15d5c0878d93c553558bf23245c6be6f7ab65fab", "html_url": "https://github.com/rust-lang/rust/commit/15d5c0878d93c553558bf23245c6be6f7ab65fab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15d5c0878d93c553558bf23245c6be6f7ab65fab/comments", "author": {"login": "semmaz", "id": 3989426, "node_id": "MDQ6VXNlcjM5ODk0MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3989426?v=4", "gravatar_id": "", "url": "https://api.github.com/users/semmaz", "html_url": "https://github.com/semmaz", "followers_url": "https://api.github.com/users/semmaz/followers", "following_url": "https://api.github.com/users/semmaz/following{/other_user}", "gists_url": "https://api.github.com/users/semmaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/semmaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/semmaz/subscriptions", "organizations_url": "https://api.github.com/users/semmaz/orgs", "repos_url": "https://api.github.com/users/semmaz/repos", "events_url": "https://api.github.com/users/semmaz/events{/privacy}", "received_events_url": "https://api.github.com/users/semmaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "semmaz", "id": 3989426, "node_id": "MDQ6VXNlcjM5ODk0MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3989426?v=4", "gravatar_id": "", "url": "https://api.github.com/users/semmaz", "html_url": "https://github.com/semmaz", "followers_url": "https://api.github.com/users/semmaz/followers", "following_url": "https://api.github.com/users/semmaz/following{/other_user}", "gists_url": "https://api.github.com/users/semmaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/semmaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/semmaz/subscriptions", "organizations_url": "https://api.github.com/users/semmaz/orgs", "repos_url": "https://api.github.com/users/semmaz/repos", "events_url": "https://api.github.com/users/semmaz/events{/privacy}", "received_events_url": "https://api.github.com/users/semmaz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69092ffdf23f5be5b2a9cbdd3145daed5004b2b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/69092ffdf23f5be5b2a9cbdd3145daed5004b2b2", "html_url": "https://github.com/rust-lang/rust/commit/69092ffdf23f5be5b2a9cbdd3145daed5004b2b2"}], "stats": {"total": 182, "additions": 74, "deletions": 108}, "files": [{"sha": "9c02ccb08acd84764f56d94a307842916b80e1e2", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 74, "deletions": 108, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/15d5c0878d93c553558bf23245c6be6f7ab65fab/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d5c0878d93c553558bf23245c6be6f7ab65fab/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=15d5c0878d93c553558bf23245c6be6f7ab65fab", "patch": "@@ -151,28 +151,31 @@ impl<'a> Iterator for Parser<'a> {\n     type Item = Piece<'a>;\n \n     fn next(&mut self) -> Option<Piece<'a>> {\n-        match self.cur.peek() {\n-            Some(&(pos, '{')) => {\n-                self.cur.next();\n-                if self.consume('{') {\n-                    Some(String(self.string(pos + 1)))\n-                } else {\n-                    let ret = Some(NextArgument(self.argument()));\n-                    self.must_consume('}');\n-                    ret\n+        if let Some(&(pos, c)) = self.cur.peek() {\n+            match c {\n+                '{' => {\n+                    self.cur.next();\n+                    if self.consume('{') {\n+                        Some(String(self.string(pos + 1)))\n+                    } else {\n+                        let ret = Some(NextArgument(self.argument()));\n+                        self.must_consume('}');\n+                        ret\n+                    }\n                 }\n-            }\n-            Some(&(pos, '}')) => {\n-                self.cur.next();\n-                if self.consume('}') {\n-                    Some(String(self.string(pos + 1)))\n-                } else {\n-                    self.err(\"unmatched `}` found\");\n-                    None\n+                '}' => {\n+                    self.cur.next();\n+                    if self.consume('}') {\n+                        Some(String(self.string(pos + 1)))\n+                    } else {\n+                        self.err(\"unmatched `}` found\");\n+                        None\n+                    }\n                 }\n+                _ => Some(String(self.string(pos))),\n             }\n-            Some(&(pos, _)) => { Some(String(self.string(pos))) }\n-            None => None\n+        } else {\n+            None\n         }\n     }\n }\n@@ -198,61 +201,47 @@ impl<'a> Parser<'a> {\n     /// the current position, then the current iterator isn't moved and false is\n     /// returned, otherwise the character is consumed and true is returned.\n     fn consume(&mut self, c: char) -> bool {\n-        match self.cur.peek() {\n-            Some(&(_, maybe)) if c == maybe => {\n-                self.cur.next();\n-                true\n-            }\n-            Some(..) | None => false,\n+        if let Some(&(_, maybe)) = self.cur.peek() {\n+            if c == maybe { self.cur.next(); true } else { false }\n+        } else {\n+            false\n         }\n     }\n \n     /// Forces consumption of the specified character. If the character is not\n     /// found, an error is emitted.\n     fn must_consume(&mut self, c: char) {\n         self.ws();\n-        match self.cur.peek() {\n-            Some(&(_, maybe)) if c == maybe => {\n+        if let Some(&(_, maybe)) = self.cur.peek() {\n+            if c == maybe {\n                 self.cur.next();\n+            } else {\n+                self.err(&format!(\"expected `{:?}`, found `{:?}`\", c, maybe));\n             }\n-            Some(&(_, other)) => {\n-                self.err(&format!(\"expected `{:?}`, found `{:?}`\", c,\n-                                  other));\n-            }\n-            None => {\n-                self.err(&format!(\"expected `{:?}` but string was terminated\",\n-                                  c));\n-            }\n+        } else {\n+            self.err(&format!(\"expected `{:?}` but string was terminated\", c));\n         }\n     }\n \n     /// Consumes all whitespace characters until the first non-whitespace\n     /// character\n     fn ws(&mut self) {\n-        loop {\n-            match self.cur.peek() {\n-                Some(&(_, c)) if c.is_whitespace() => { self.cur.next(); }\n-                Some(..) | None => { return }\n-            }\n+        while let Some(&(_, c)) = self.cur.peek() {\n+            if c.is_whitespace() { self.cur.next(); } else { break }\n         }\n     }\n \n     /// Parses all of a string which is to be considered a \"raw literal\" in a\n     /// format string. This is everything outside of the braces.\n     fn string(&mut self, start: usize) -> &'a str {\n-        loop {\n-            // we may not consume the character, so clone the iterator\n-            match self.cur.peek() {\n-                Some(&(pos, '}')) | Some(&(pos, '{')) => {\n-                    return &self.input[start..pos];\n-                }\n-                Some(..) => { self.cur.next(); }\n-                None => {\n-                    self.cur.next();\n-                    return &self.input[start..self.input.len()];\n-                }\n+        // we may not consume the character, peek the iterator\n+        while let Some(&(pos, c)) = self.cur.peek() {\n+            match c {\n+                '{' | '}' => { return &self.input[start..pos]; }\n+                _ => { self.cur.next(); }\n             }\n         }\n+        &self.input[start..self.input.len()]\n     }\n \n     /// Parses an Argument structure, or what's contained within braces inside\n@@ -267,15 +256,14 @@ impl<'a> Parser<'a> {\n     /// Parses a positional argument for a format. This could either be an\n     /// integer index of an argument, a named argument, or a blank string.\n     fn position(&mut self) -> Position<'a> {\n-        match self.integer() {\n-            Some(i) => { ArgumentIs(i) }\n-            None => {\n-                match self.cur.peek() {\n-                    Some(&(_, c)) if c.is_alphabetic() => {\n-                        ArgumentNamed(self.word())\n-                    }\n-                    _ => ArgumentNext\n+        if let Some(i) = self.integer() {\n+            ArgumentIs(i)\n+        } else {\n+            match self.cur.peek() {\n+                Some(&(_, c)) if c.is_alphabetic() => {\n+                    ArgumentNamed(self.word())\n                 }\n+                _ => ArgumentNext\n             }\n         }\n     }\n@@ -294,17 +282,14 @@ impl<'a> Parser<'a> {\n         if !self.consume(':') { return spec }\n \n         // fill character\n-        match self.cur.peek() {\n-            Some(&(_, c)) => {\n-                match self.cur.clone().skip(1).next() {\n-                    Some((_, '>')) | Some((_, '<')) | Some((_, '^')) => {\n-                        spec.fill = Some(c);\n-                        self.cur.next();\n-                    }\n-                    Some(..) | None => {}\n+        if let Some(&(_, c)) = self.cur.peek() {\n+            match self.cur.clone().skip(1).next() {\n+                Some((_, '>')) | Some((_, '<')) | Some((_, '^')) => {\n+                    spec.fill = Some(c);\n+                    self.cur.next();\n                 }\n+                _ => {}\n             }\n-            None => {}\n         }\n         // Alignment\n         if self.consume('<') {\n@@ -361,29 +346,20 @@ impl<'a> Parser<'a> {\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n     fn count(&mut self) -> Count<'a> {\n-        match self.integer() {\n-            Some(i) => {\n+        if let Some(i) = self.integer() {\n+            if self.consume('$') { CountIsParam(i) } else { CountIs(i) }\n+        } else {\n+            let tmp = self.cur.clone();\n+            let word = self.word();\n+            if word.is_empty() {\n+                self.cur = tmp;\n+                CountImplied\n+            } else {\n                 if self.consume('$') {\n-                    CountIsParam(i)\n+                    CountIsName(word)\n                 } else {\n-                    CountIs(i)\n-                }\n-            }\n-            None => {\n-                let tmp = self.cur.clone();\n-                match self.word() {\n-                    word if !word.is_empty() => {\n-                        if self.consume('$') {\n-                            CountIsName(word)\n-                        } else {\n-                            self.cur = tmp;\n-                            CountImplied\n-                        }\n-                    }\n-                    _ => {\n-                        self.cur = tmp;\n-                        CountImplied\n-                    }\n+                    self.cur = tmp;\n+                    CountImplied\n                 }\n             }\n         }\n@@ -394,23 +370,17 @@ impl<'a> Parser<'a> {\n     /// characters.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.peek() {\n-            Some(&(pos, c)) if c.is_xid_start() => {\n-                self.cur.next();\n-                pos\n-            }\n-            Some(..) | None => { return &self.input[..0]; }\n+            Some(&(pos, c)) if c.is_xid_start() => { self.cur.next(); pos }\n+            _ => { return &self.input[..0]; }\n         };\n-        let end;\n-        loop {\n-            match self.cur.peek() {\n-                Some(&(_, c)) if c.is_xid_continue() => {\n-                    self.cur.next();\n-                }\n-                Some(&(pos, _)) => { end = pos; break }\n-                None => { end = self.input.len(); break }\n+        while let Some(&(pos, c)) = self.cur.peek() {\n+            if c.is_xid_continue() {\n+                self.cur.next();\n+            } else {\n+                return &self.input[start..pos];\n             }\n         }\n-        &self.input[start..end]\n+        &self.input[start..self.input.len()]\n     }\n \n     /// Optionally parses an integer at the current position. This doesn't deal\n@@ -427,11 +397,7 @@ impl<'a> Parser<'a> {\n                 break\n             }\n         }\n-        if found {\n-            Some(cur)\n-        } else {\n-            None\n-        }\n+        if found { Some(cur) } else { None }\n     }\n }\n "}]}