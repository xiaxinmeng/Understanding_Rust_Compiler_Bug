{"sha": "fe2f3d210a536ea951596c7df491c9b1d33764e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMmYzZDIxMGE1MzZlYTk1MTU5NmM3ZGY0OTFjOWIxZDMzNzY0ZTA=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-08-03T23:01:19Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-08-03T23:17:54Z"}, "message": "Further work on default methods in traits.\n\nAnd some trait-related code cleanup in typeck::collect.", "tree": {"sha": "fd97695a3ab1dd656f56c903a62b03b4fb17ae7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd97695a3ab1dd656f56c903a62b03b4fb17ae7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe2f3d210a536ea951596c7df491c9b1d33764e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe2f3d210a536ea951596c7df491c9b1d33764e0", "html_url": "https://github.com/rust-lang/rust/commit/fe2f3d210a536ea951596c7df491c9b1d33764e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe2f3d210a536ea951596c7df491c9b1d33764e0/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a98407ee34550f988b94b77bf0cc8c3b74cb40d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a98407ee34550f988b94b77bf0cc8c3b74cb40d5", "html_url": "https://github.com/rust-lang/rust/commit/a98407ee34550f988b94b77bf0cc8c3b74cb40d5"}], "stats": {"total": 103, "additions": 63, "deletions": 40}, "files": [{"sha": "e80a2c8070a5c37f2ac8ac070404b372c1d5cdef", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 63, "deletions": 40, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/fe2f3d210a536ea951596c7df491c9b1d33764e0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe2f3d210a536ea951596c7df491c9b1d33764e0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=fe2f3d210a536ea951596c7df491c9b1d33764e0", "patch": "@@ -177,33 +177,33 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id) {\n  *\n  * - impl_m: the method in the impl\n  * - impl_tps: the type params declared on the impl itself (not the method!)\n- * - if_m: the method in the trait\n- * - if_substs: the substitutions used on the type of the trait\n+ * - trait_m: the method in the trait\n+ * - trait_substs: the substitutions used on the type of the trait\n  * - self_ty: the self type of the impl\n  */\n fn compare_impl_method(tcx: ty::ctxt, sp: span,\n                        impl_m: ty::method, impl_tps: uint,\n-                       if_m: ty::method, if_substs: ty::substs,\n+                       trait_m: ty::method, trait_substs: ty::substs,\n                        self_ty: ty::t) {\n \n-    if impl_m.tps != if_m.tps {\n-        tcx.sess.span_err(sp, ~\"method `\" + *if_m.ident +\n+    if impl_m.tps != trait_m.tps {\n+        tcx.sess.span_err(sp, ~\"method `\" + *trait_m.ident +\n                           ~\"` has an incompatible set of type parameters\");\n         return;\n     }\n \n-    if vec::len(impl_m.fty.inputs) != vec::len(if_m.fty.inputs) {\n+    if vec::len(impl_m.fty.inputs) != vec::len(trait_m.fty.inputs) {\n         tcx.sess.span_err(sp,fmt!{\"method `%s` has %u parameters \\\n                                    but the trait has %u\",\n-                                  *if_m.ident,\n+                                  *trait_m.ident,\n                                   vec::len(impl_m.fty.inputs),\n-                                  vec::len(if_m.fty.inputs)});\n+                                  vec::len(trait_m.fty.inputs)});\n         return;\n     }\n \n     // Perform substitutions so that the trait/impl methods are expressed\n     // in terms of the same set of type/region parameters:\n-    // - replace trait type parameters with those from `if_substs`\n+    // - replace trait type parameters with those from `trait_substs`\n     // - replace method parameters on the trait with fresh, dummy parameters\n     //   that correspond to the parameters we will find on the impl\n     // - replace self region with a fresh, dummy region\n@@ -212,23 +212,23 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n         let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n-    let if_fty = {\n-        let dummy_tps = do vec::from_fn((*if_m.tps).len()) |i| {\n+    let trait_fty = {\n+        let dummy_tps = do vec::from_fn((*trait_m.tps).len()) |i| {\n             // hack: we don't know the def id of the impl tp, but it\n             // is not important for unification\n             ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n         };\n         let substs = {\n             self_r: some(dummy_self_r),\n             self_ty: some(self_ty),\n-            tps: vec::append(if_substs.tps, dummy_tps)\n+            tps: vec::append(trait_substs.tps, dummy_tps)\n         };\n-        let if_fty = ty::mk_fn(tcx, if_m.fty);\n-        ty::subst(tcx, substs, if_fty)\n+        let trait_fty = ty::mk_fn(tcx, trait_m.fty);\n+        ty::subst(tcx, substs, trait_fty)\n     };\n     require_same_types(\n-        tcx, none, sp, impl_fty, if_fty,\n-        || ~\"method `\" + *if_m.ident + ~\"` has an incompatible type\");\n+        tcx, none, sp, impl_fty, trait_fty,\n+        || ~\"method `\" + *trait_m.ident + ~\"` has an incompatible type\");\n     return;\n \n     // Replaces bound references to the self region with `with_r`.\n@@ -245,36 +245,59 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n                                rp: bool,\n                                selfty: ty::t,\n                                a_trait_ty: @ast::trait_ref,\n-                               ms: ~[converted_method]) {\n+                               impl_ms: ~[converted_method]) {\n \n     let tcx = ccx.tcx;\n     let (did, tpt) = instantiate_trait_ref(ccx, a_trait_ty, rp);\n     if did.crate == ast::local_crate {\n         ensure_trait_methods(ccx, did.node);\n     }\n-    for vec::each(*ty::trait_methods(tcx, did)) |if_m| {\n-        alt vec::find(ms, |m| if_m.ident == m.mty.ident) {\n-          some({mty: m, id, span}) {\n-            if m.purity != if_m.purity {\n+    for vec::each(*ty::trait_methods(tcx, did)) |trait_m| {\n+        alt vec::find(impl_ms, |impl_m| trait_m.ident == impl_m.mty.ident) {\n+          some({mty: impl_m, id, span}) {\n+            if impl_m.purity != trait_m.purity {\n                 ccx.tcx.sess.span_err(\n                     span, fmt!{\"method `%s`'s purity does \\\n                                 not match the trait method's \\\n-                                purity\", *m.ident});\n+                                purity\", *impl_m.ident});\n             }\n             compare_impl_method(\n-                ccx.tcx, span, m, vec::len(tps),\n-                if_m, tpt.substs, selfty);\n+                ccx.tcx, span, impl_m, vec::len(tps),\n+                trait_m, tpt.substs, selfty);\n           }\n           none {\n-            // FIXME (#2794): if there's a default impl in the trait,\n-            // use that.\n-\n-            tcx.sess.span_err(\n-                a_trait_ty.path.span,\n-                fmt!{\"missing method `%s`\", *if_m.ident});\n+              // If we couldn't find an implementation for trait_m in\n+              // the impl, then see if there was a default\n+              // implementation in the trait itself.  If not, raise a\n+              // \"missing method\" error.\n+\n+              alt tcx.items.get(did.node) {\n+                ast_map::node_item(\n+                    @{node: ast::item_trait(_, _, trait_methods), _}, _) {\n+                  let (_, provided_methods) =\n+                      split_trait_methods(trait_methods);\n+\n+                  alt vec::find(provided_methods, |provided_method|\n+                                provided_method.ident == trait_m.ident) {\n+                    some(m) {\n+                      // If there's a provided method with the name we\n+                      // want, then we're fine; nothing else to do.\n+                    }\n+                    none {\n+                      tcx.sess.span_err(\n+                          a_trait_ty.path.span,\n+                          fmt!{\"missing method `%s`\", *trait_m.ident});\n+                    }\n+                  }\n+                }\n+                _ {\n+                    tcx.sess.bug(~\"check_methods_against_trait(): trait_ref \\\n+                                   didn't refer to a trait\");\n+                }\n+              }\n           }\n         } // alt\n-    } // |if_m|\n+    } // |trait_m|\n } // fn\n \n fn convert_field(ccx: @crate_ctxt,\n@@ -324,7 +347,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         get_enum_variant_types(ccx, tpt.ty, variants, ty_params, rp);\n       }\n-      ast::item_impl(tps, trt, selfty, ms) {\n+      ast::item_impl(tps, trait_ref, selfty, ms) {\n         let i_bounds = ty_param_bounds(ccx, tps);\n         let selfty = ccx.to_ty(type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n@@ -334,7 +357,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                            ty: selfty});\n \n         let cms = convert_methods(ccx, ms, rp, i_bounds, selfty);\n-        for trt.each |t| {\n+        for trait_ref.each |t| {\n             check_methods_against_trait(ccx, tps, rp, selfty, t, cms);\n         }\n       }\n@@ -351,11 +374,11 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         let _cms = convert_methods(ccx, provided_methods, rp, bounds, selfty);\n         // FIXME (#2616): something like this, when we start having\n         // trait inheritance?\n-        // for trt.each |t| {\n+        // for trait_ref.each |t| {\n         // check_methods_against_trait(ccx, tps, rp, selfty, t, cms);\n         // }\n       }\n-      ast::item_class(tps, traits, members, m_ctor, m_dtor) {\n+      ast::item_class(tps, trait_refs, members, m_ctor, m_dtor) {\n         // Write the class type\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n@@ -405,11 +428,11 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n         let selfty = ty::mk_class(tcx, local_def(it.id), substs);\n         let cms = convert_methods(ccx, methods, rp, bounds, selfty);\n-        for traits.each |trt| {\n-            check_methods_against_trait(ccx, tps, rp, selfty, trt, cms);\n-            // trt.impl_id represents (class, trait) pair\n-            write_ty_to_tcx(tcx, trt.impl_id, tpt.ty);\n-            tcx.tcache.insert(local_def(trt.impl_id), tpt);\n+        for trait_refs.each |trait_ref| {\n+            check_methods_against_trait(ccx, tps, rp, selfty, trait_ref, cms);\n+            // trait_ref.impl_id represents (class, trait) pair\n+            write_ty_to_tcx(tcx, trait_ref.impl_id, tpt.ty);\n+            tcx.tcache.insert(local_def(trait_ref.impl_id), tpt);\n         }\n       }\n       _ {"}]}