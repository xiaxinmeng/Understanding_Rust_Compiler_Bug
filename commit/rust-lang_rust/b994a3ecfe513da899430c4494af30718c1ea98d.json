{"sha": "b994a3ecfe513da899430c4494af30718c1ea98d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5OTRhM2VjZmU1MTNkYTg5OTQzMGM0NDk0YWYzMDcxOGMxZWE5OGQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-22T23:10:00Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-22T23:10:00Z"}, "message": "Rollup merge of #21516 - steveklabnik:document_box, r=alexcrichton", "tree": {"sha": "3c524bf95982c4c9bb81b7a67a650a7f02478b78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c524bf95982c4c9bb81b7a67a650a7f02478b78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b994a3ecfe513da899430c4494af30718c1ea98d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b994a3ecfe513da899430c4494af30718c1ea98d", "html_url": "https://github.com/rust-lang/rust/commit/b994a3ecfe513da899430c4494af30718c1ea98d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b994a3ecfe513da899430c4494af30718c1ea98d/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb803100704abe7244cf43cb4827aa22a80e54c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb803100704abe7244cf43cb4827aa22a80e54c9", "html_url": "https://github.com/rust-lang/rust/commit/bb803100704abe7244cf43cb4827aa22a80e54c9"}, {"sha": "5a3bdedd7741db7c031a5fabea83519f9879dd4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a3bdedd7741db7c031a5fabea83519f9879dd4b", "html_url": "https://github.com/rust-lang/rust/commit/5a3bdedd7741db7c031a5fabea83519f9879dd4b"}], "stats": {"total": 79, "additions": 68, "deletions": 11}, "files": [{"sha": "c4abedf3fe89a4324e4aa84a1153c154db3d19d9", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 68, "deletions": 11, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b994a3ecfe513da899430c4494af30718c1ea98d/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b994a3ecfe513da899430c4494af30718c1ea98d/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=b994a3ecfe513da899430c4494af30718c1ea98d", "patch": "@@ -8,7 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A unique pointer type.\n+//! A pointer type for heap allocation.\n+//!\n+//! `Box<T>`, casually referred to as a 'box', provides the simplest form of heap allocation in\n+//! Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of\n+//! scope.\n+//!\n+//! Boxes are useful in two situations: recursive data structures, and occasionally when returning\n+//! data. [The Pointer chapter of the Book](../../../book/pointers.html#best-practices-1) explains\n+//! these cases in detail.\n+//!\n+//! # Examples\n+//!\n+//! Creating a box:\n+//!\n+//! ```\n+//! let x = Box::new(5);\n+//! ```\n+//!\n+//! Creating a recursive data structure:\n+//!\n+//! ```\n+//! #[derive(Show)]\n+//! enum List<T> {\n+//!     Cons(T, Box<List<T>>),\n+//!     Nil,\n+//! }\n+//!\n+//! fn main() {\n+//!     let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n+//!     println!(\"{:?}\", list);\n+//! }\n+//! ```\n+//!\n+//! This will print `Cons(1i32, Box(Cons(2i32, Box(Nil))))`.\n \n #![stable]\n \n@@ -29,8 +62,8 @@ use core::raw::TraitObject;\n use core::result::Result::{Ok, Err};\n use core::result::Result;\n \n-/// A value that represents the global exchange heap. This is the default\n-/// place that the `box` keyword allocates into when no place is supplied.\n+/// A value that represents the heap. This is the default place that the `box` keyword allocates\n+/// into when no place is supplied.\n ///\n /// The following two examples are equivalent:\n ///\n@@ -39,23 +72,29 @@ use core::result::Result;\n /// use std::boxed::HEAP;\n ///\n /// fn main() {\n-/// # struct Bar;\n-/// # impl Bar { fn new(_a: int) { } }\n-///     let foo = box(HEAP) Bar::new(2);\n-///     let foo = box Bar::new(2);\n+///     let foo = box(HEAP) 5;\n+///     let foo = box 5;\n /// }\n /// ```\n #[lang = \"exchange_heap\"]\n #[unstable = \"may be renamed; uncertain about custom allocator design\"]\n pub static HEAP: () = ();\n \n-/// A type that represents a uniquely-owned value.\n+/// A pointer type for heap allocation.\n+///\n+/// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]\n #[stable]\n pub struct Box<T>(Unique<T>);\n \n impl<T> Box<T> {\n-    /// Moves `x` into a freshly allocated box on the global exchange heap.\n+    /// Allocates memory on the heap and then moves `x` into it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Box::new(5);\n+    /// ```\n     #[stable]\n     pub fn new(x: T) -> Box<T> {\n         box x\n@@ -76,11 +115,29 @@ impl<T> Default for Box<[T]> {\n \n #[stable]\n impl<T: Clone> Clone for Box<T> {\n-    /// Returns a copy of the owned box.\n+    /// Returns a new box with a `clone()` of this box's contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Box::new(5);\n+    /// let y = x.clone();\n+    /// ```\n     #[inline]\n     fn clone(&self) -> Box<T> { box {(**self).clone()} }\n \n-    /// Performs copy-assignment from `source` by reusing the existing allocation.\n+    /// Copies `source`'s contents into `self` without creating a new allocation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Box::new(5);\n+    /// let mut y = Box::new(10);\n+    ///\n+    /// y.clone_from(&x);\n+    ///\n+    /// assert_eq!(*y, 5);\n+    /// ```\n     #[inline]\n     fn clone_from(&mut self, source: &Box<T>) {\n         (**self).clone_from(&(**source));"}]}