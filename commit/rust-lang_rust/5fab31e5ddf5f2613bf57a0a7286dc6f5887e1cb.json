{"sha": "5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYWIzMWU1ZGRmNWYyNjEzYmY1N2EwYTcyODZkYzZmNTg4N2UxY2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-15T13:19:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-15T13:19:05Z"}, "message": "Auto merge of #79070 - jonas-schievink:rollup-wacn2b8, r=jonas-schievink\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #77802 (Allow making `RUSTC_BOOTSTRAP` conditional on the crate name)\n - #79004 (Add `--color` support to bootstrap)\n - #79005 (cleanup: Remove `ParseSess::injected_crate_name`)\n - #79016 (Make `_` an expression, to discard values in destructuring assignments)\n - #79019 (astconv: extract closures into a separate trait)\n - #79026 (Implement BTreeMap::retain and BTreeSet::retain)\n - #79031 (Validate that locals have a corresponding `LocalDecl`)\n - #79034 (rustc_resolve: Make `macro_rules` scope chain compression lazy)\n - #79036 (Move Steal to rustc_data_structures.)\n - #79041 (Rename clean::{ItemEnum -> ItemKind}, clean::Item::{inner -> kind})\n - #79058 (Move likely/unlikely argument outside of invisible unsafe block)\n - #79059 (Print 'checking cranelift artifacts' to easily separate it from other artifacts)\n - #79063 (Update rustfmt to v1.4.26)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "bf2540f955bf3e3adb49330b1fd06ee628d9fc35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf2540f955bf3e3adb49330b1fd06ee628d9fc35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "html_url": "https://github.com/rust-lang/rust/commit/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04688459242356c0f6b9fdad3ba76c9ec4dcc354", "url": "https://api.github.com/repos/rust-lang/rust/commits/04688459242356c0f6b9fdad3ba76c9ec4dcc354", "html_url": "https://github.com/rust-lang/rust/commit/04688459242356c0f6b9fdad3ba76c9ec4dcc354"}, {"sha": "568354f01f22148709e51fe1130826addb455e18", "url": "https://api.github.com/repos/rust-lang/rust/commits/568354f01f22148709e51fe1130826addb455e18", "html_url": "https://github.com/rust-lang/rust/commit/568354f01f22148709e51fe1130826addb455e18"}], "stats": {"total": 1488, "additions": 972, "deletions": 516}, "files": [{"sha": "c7178ba255ab0b703088645bec6dec04aeaafe87", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -4337,7 +4337,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.25\"\n+version = \"1.4.26\"\n dependencies = [\n  \"annotate-snippets 0.6.1\",\n  \"anyhow\","}, {"sha": "328086af183d6076b171fcd270f4a5b5aae446b1", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1192,6 +1192,7 @@ impl Expr {\n             ExprKind::Field(..) => ExprPrecedence::Field,\n             ExprKind::Index(..) => ExprPrecedence::Index,\n             ExprKind::Range(..) => ExprPrecedence::Range,\n+            ExprKind::Underscore => ExprPrecedence::Path,\n             ExprKind::Path(..) => ExprPrecedence::Path,\n             ExprKind::AddrOf(..) => ExprPrecedence::AddrOf,\n             ExprKind::Break(..) => ExprPrecedence::Break,\n@@ -1324,6 +1325,8 @@ pub enum ExprKind {\n     Index(P<Expr>, P<Expr>),\n     /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`; and `..` in destructuring assingment).\n     Range(Option<P<Expr>>, Option<P<Expr>>, RangeLimits),\n+    /// An underscore, used in destructuring assignment to ignore a value.\n+    Underscore,\n \n     /// Variable reference, possibly containing `::` and/or type\n     /// parameters (e.g., `foo::bar::<baz>`)."}, {"sha": "ddae0ab03e40497dddbf5147e14492559138a9d6", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1232,6 +1232,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             visit_opt(e1, |e1| vis.visit_expr(e1));\n             visit_opt(e2, |e2| vis.visit_expr(e2));\n         }\n+        ExprKind::Underscore => {}\n         ExprKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n             vis.visit_path(path);"}, {"sha": "560064182e18df54246dcf638f11db15ccaf24ea", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -806,6 +806,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             walk_list!(visitor, visit_expr, start);\n             walk_list!(visitor, visit_expr, end);\n         }\n+        ExprKind::Underscore => {}\n         ExprKind::Path(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n                 visitor.visit_ty(&qself.ty);"}, {"sha": "f83fc29577bfb30e9b4614beb2ca48758fa0787b", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -164,6 +164,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::Range(ref e1, ref e2, lims) => {\n                     self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n                 }\n+                ExprKind::Underscore => {\n+                    self.sess\n+                        .struct_span_err(\n+                            e.span,\n+                            \"in expressions, `_` can only be used on the left-hand side of an assignment\",\n+                        )\n+                        .span_label(e.span, \"`_` not allowed here\")\n+                        .emit();\n+                    hir::ExprKind::Err\n+                }\n                 ExprKind::Path(ref qself, ref path) => {\n                     let qpath = self.lower_qpath(\n                         e.id,\n@@ -863,7 +873,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // Return early in case of an ordinary assignment.\n         fn is_ordinary(lower_ctx: &mut LoweringContext<'_, '_>, lhs: &Expr) -> bool {\n             match &lhs.kind {\n-                ExprKind::Array(..) | ExprKind::Struct(..) | ExprKind::Tup(..) => false,\n+                ExprKind::Array(..)\n+                | ExprKind::Struct(..)\n+                | ExprKind::Tup(..)\n+                | ExprKind::Underscore => false,\n                 // Check for tuple struct constructor.\n                 ExprKind::Call(callee, ..) => lower_ctx.extract_tuple_struct_path(callee).is_none(),\n                 ExprKind::Paren(e) => {\n@@ -943,6 +956,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         assignments: &mut Vec<hir::Stmt<'hir>>,\n     ) -> &'hir hir::Pat<'hir> {\n         match &lhs.kind {\n+            // Underscore pattern.\n+            ExprKind::Underscore => {\n+                return self.pat_without_dbm(lhs.span, hir::PatKind::Wild);\n+            }\n             // Slice patterns.\n             ExprKind::Array(elements) => {\n                 let (pats, rest) ="}, {"sha": "d93655e59050da240db12108043535b8edb7789e", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -53,7 +53,6 @@ use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, ParamName};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_session::config::nightly_options;\n use rustc_session::lint::{builtin::BARE_TRAIT_OBJECTS, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n@@ -1398,8 +1397,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             \"`impl Trait` not allowed outside of {}\",\n                             allowed_in,\n                         );\n-                        if pos == ImplTraitPosition::Binding && nightly_options::is_nightly_build()\n-                        {\n+                        if pos == ImplTraitPosition::Binding && self.sess.is_nightly_build() {\n                             err.help(\n                                 \"add `#![feature(impl_trait_in_bindings)]` to the crate \\\n                                    attributes to enable\","}, {"sha": "181783441f3ff6e1678d4a8004cc9aac8d190b5e", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -630,7 +630,11 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(const_trait_impl, \"const trait impls are experimental\");\n     gate_all!(half_open_range_patterns, \"half-open range patterns are unstable\");\n     gate_all!(inline_const, \"inline-const is experimental\");\n-    gate_all!(destructuring_assignment, \"destructuring assignments are unstable\");\n+    if sess.parse_sess.span_diagnostic.err_count() == 0 {\n+        // Errors for `destructuring_assignment` can get quite noisy, especially where `_` is\n+        // involved, so we only emit errors where there are no other parsing errors.\n+        gate_all!(destructuring_assignment, \"destructuring assignments are unstable\");\n+    }\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "fdb129d9e2aa22100da0bdc997cb7e78d9eaf013", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -109,7 +109,6 @@ pub fn print_crate<'a>(\n     ann: &'a dyn PpAnn,\n     is_expanded: bool,\n     edition: Edition,\n-    has_injected_crate: bool,\n ) -> String {\n     let mut s = State {\n         s: pp::mk_printer(),\n@@ -119,7 +118,7 @@ pub fn print_crate<'a>(\n         insert_extra_parens: true,\n     };\n \n-    if is_expanded && has_injected_crate {\n+    if is_expanded && !krate.attrs.iter().any(|attr| attr.has_name(sym::no_core)) {\n         // We need to print `#![no_std]` (and its feature gate) so that\n         // compiling pretty-printed source won't inject libstd again.\n         // However, we don't want these attributes in the AST because\n@@ -2068,6 +2067,7 @@ impl<'a> State<'a> {\n                     self.print_expr_maybe_paren(e, fake_prec);\n                 }\n             }\n+            ast::ExprKind::Underscore => self.s.word(\"_\"),\n             ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n             ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n             ast::ExprKind::Break(opt_label, ref opt_expr) => {"}, {"sha": "91566ec1ef24540323c9769cbd2f88e3fad78fed", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -13,12 +13,12 @@ pub fn inject(\n     resolver: &mut dyn ResolverExpand,\n     sess: &Session,\n     alt_std_name: Option<Symbol>,\n-) -> (ast::Crate, Option<Symbol>) {\n+) -> ast::Crate {\n     let rust_2018 = sess.parse_sess.edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n     let names: &[Symbol] = if sess.contains_name(&krate.attrs, sym::no_core) {\n-        return (krate, None);\n+        return krate;\n     } else if sess.contains_name(&krate.attrs, sym::no_std) {\n         if sess.contains_name(&krate.attrs, sym::compiler_builtins) {\n             &[sym::core]\n@@ -81,5 +81,5 @@ pub fn inject(\n \n     krate.module.items.insert(0, use_item);\n \n-    (krate, Some(name))\n+    krate\n }"}, {"sha": "a8a1646183c868de8bf0865af07fa6a7650aa826", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -3,7 +3,6 @@ use crate::llvm;\n use libc::c_int;\n use rustc_codegen_ssa::target_features::supported_target_features;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_feature::UnstableFeatures;\n use rustc_middle::bug;\n use rustc_session::config::PrintRequest;\n use rustc_session::Session;\n@@ -147,13 +146,11 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n     let target_machine = create_informational_target_machine(sess);\n     supported_target_features(sess)\n         .iter()\n-        .filter_map(|&(feature, gate)| {\n-            if UnstableFeatures::from_environment().is_nightly_build() || gate.is_none() {\n-                Some(feature)\n-            } else {\n-                None\n-            }\n-        })\n+        .filter_map(\n+            |&(feature, gate)| {\n+                if sess.is_nightly_build() || gate.is_none() { Some(feature) } else { None }\n+            },\n+        )\n         .filter(|feature| {\n             let llvm_feature = to_llvm_feature(sess, feature);\n             let cstr = CString::new(llvm_feature).unwrap();"}, {"sha": "322c7a71160cdcb9f46765860b7966be0b9f3e27", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -47,19 +47,19 @@ pub fn cold_path<F: FnOnce() -> R, R>(f: F) -> R {\n #[macro_export]\n macro_rules! likely {\n     ($e:expr) => {\n-        #[allow(unused_unsafe)]\n-        {\n-            unsafe { std::intrinsics::likely($e) }\n+        match $e {\n+            #[allow(unused_unsafe)]\n+            e => unsafe { std::intrinsics::likely(e) },\n         }\n     };\n }\n \n #[macro_export]\n macro_rules! unlikely {\n     ($e:expr) => {\n-        #[allow(unused_unsafe)]\n-        {\n-            unsafe { std::intrinsics::unlikely($e) }\n+        match $e {\n+            #[allow(unused_unsafe)]\n+            e => unsafe { std::intrinsics::unlikely(e) },\n         }\n     };\n }\n@@ -102,6 +102,7 @@ pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;\n pub mod sso;\n+pub mod steal;\n pub mod tagged_ptr;\n pub mod temp_dir;\n pub mod unhash;"}, {"sha": "e532a84cea3f23398807c2428e73743b2b4e91b7", "filename": "compiler/rustc_data_structures/src/steal.rs", "status": "renamed", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1,4 +1,5 @@\n-use rustc_data_structures::sync::{MappedReadGuard, ReadGuard, RwLock};\n+use crate::stable_hasher::{HashStable, StableHasher};\n+use crate::sync::{MappedReadGuard, ReadGuard, RwLock};\n \n /// The `Steal` struct is intended to used as the value for a query.\n /// Specifically, we sometimes have queries (*cough* MIR *cough*)\n@@ -31,7 +32,7 @@ impl<T> Steal<T> {\n \n     pub fn borrow(&self) -> MappedReadGuard<'_, T> {\n         ReadGuard::map(self.value.borrow(), |opt| match *opt {\n-            None => bug!(\"attempted to read from stolen value\"),\n+            None => panic!(\"attempted to read from stolen value\"),\n             Some(ref v) => v,\n         })\n     }\n@@ -42,3 +43,9 @@ impl<T> Steal<T> {\n         value.expect(\"attempt to read from stolen value\")\n     }\n }\n+\n+impl<CTX, T: HashStable<CTX>> HashStable<CTX> for Steal<T> {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.borrow().hash_stable(hcx, hasher);\n+    }\n+}", "previous_filename": "compiler/rustc_middle/src/ty/steal.rs"}, {"sha": "c5447612555346fdc617bc30c56c9eb687874631", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -20,7 +20,7 @@ use rustc_data_structures::profiling::print_time_passes_entry;\n use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{ErrorReported, PResult};\n-use rustc_feature::{find_gated_cfg, UnstableFeatures};\n+use rustc_feature::find_gated_cfg;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_interface::util::{self, collect_crate_types, get_builtin_codegen_backend};\n use rustc_interface::{interface, Queries};\n@@ -746,9 +746,6 @@ impl RustcDefaultCalls {\n                     }\n                 }\n                 Cfg => {\n-                    let allow_unstable_cfg =\n-                        UnstableFeatures::from_environment().is_nightly_build();\n-\n                     let mut cfgs = sess\n                         .parse_sess\n                         .config\n@@ -763,7 +760,7 @@ impl RustcDefaultCalls {\n                             // it, this is intended to get into Cargo and then go\n                             // through to build scripts.\n                             if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n-                                && !allow_unstable_cfg\n+                                && !sess.is_nightly_build()\n                                 && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n                             {\n                                 return None;\n@@ -814,14 +811,14 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n     }\n }\n \n-fn usage(verbose: bool, include_unstable_options: bool) {\n+fn usage(verbose: bool, include_unstable_options: bool, nightly_build: bool) {\n     let groups = if verbose { config::rustc_optgroups() } else { config::rustc_short_optgroups() };\n     let mut options = getopts::Options::new();\n     for option in groups.iter().filter(|x| include_unstable_options || x.is_stable()) {\n         (option.apply)(&mut options);\n     }\n     let message = \"Usage: rustc [OPTIONS] INPUT\";\n-    let nightly_help = if nightly_options::is_nightly_build() {\n+    let nightly_help = if nightly_build {\n         \"\\n    -Z help             Print unstable compiler options\"\n     } else {\n         \"\"\n@@ -831,7 +828,7 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n     } else {\n         \"\\n    --help -v           Print the full set of options rustc accepts\"\n     };\n-    let at_path = if verbose && nightly_options::is_nightly_build() {\n+    let at_path = if verbose && nightly_build {\n         \"    @path               Read newline separated options from `path`\\n\"\n     } else {\n         \"\"\n@@ -1034,7 +1031,9 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     if args.is_empty() {\n         // user did not write `-v` nor `-Z unstable-options`, so do not\n         // include that extra information.\n-        usage(false, false);\n+        let nightly_build =\n+            rustc_feature::UnstableFeatures::from_environment(None).is_nightly_build();\n+        usage(false, false, nightly_build);\n         return None;\n     }\n \n@@ -1063,7 +1062,9 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         // Only show unstable options in --help if we accept unstable options.\n-        usage(matches.opt_present(\"verbose\"), nightly_options::is_unstable_enabled(&matches));\n+        let unstable_enabled = nightly_options::is_unstable_enabled(&matches);\n+        let nightly_build = nightly_options::match_is_nightly_build(&matches);\n+        usage(matches.opt_present(\"verbose\"), unstable_enabled, nightly_build);\n         return None;\n     }\n "}, {"sha": "305fa838afad2293a46b5c870de5aa9a89079be6", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -404,7 +404,6 @@ pub fn print_after_parsing(\n                 annotation.pp_ann(),\n                 false,\n                 parse.edition,\n-                parse.injected_crate_name.get().is_some(),\n             )\n         })\n     } else {\n@@ -446,7 +445,6 @@ pub fn print_after_hir_lowering<'tcx>(\n                     annotation.pp_ann(),\n                     true,\n                     parse.edition,\n-                    parse.injected_crate_name.get().is_some(),\n                 )\n             })\n         }"}, {"sha": "f965f7fdefe4ac26fcef591d8b0bf3b22ecab414", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -59,7 +59,7 @@ pub enum Stability {\n     Deprecated(&'static str, Option<&'static str>),\n }\n \n-#[derive(Clone, Copy, Hash)]\n+#[derive(Clone, Copy, Debug, Hash)]\n pub enum UnstableFeatures {\n     /// Hard errors for unstable features are active, as on beta/stable channels.\n     Disallow,\n@@ -73,11 +73,20 @@ pub enum UnstableFeatures {\n }\n \n impl UnstableFeatures {\n-    pub fn from_environment() -> UnstableFeatures {\n+    /// This takes into account `RUSTC_BOOTSTRAP`.\n+    ///\n+    /// If `krate` is [`Some`], then setting `RUSTC_BOOTSTRAP=krate` will enable the nightly features.\n+    /// Otherwise, only `RUSTC_BOOTSTRAP=1` will work.\n+    pub fn from_environment(krate: Option<&str>) -> Self {\n         // `true` if this is a feature-staged build, i.e., on the beta or stable channel.\n         let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+        // Returns whether `krate` should be counted as unstable\n+        let is_unstable_crate = |var: &str| {\n+            krate.map_or(false, |name| var.split(',').any(|new_krate| new_krate == name))\n+        };\n         // `true` if we should enable unstable features for bootstrapping.\n-        let bootstrap = std::env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n+        let bootstrap = std::env::var(\"RUSTC_BOOTSTRAP\")\n+            .map_or(false, |var| var == \"1\" || is_unstable_crate(&var));\n         match (disable_unstable_features, bootstrap) {\n             (_, true) => UnstableFeatures::Cheat,\n             (true, _) => UnstableFeatures::Disallow,\n@@ -140,3 +149,30 @@ pub use builtin_attrs::{\n     AttributeType, BuiltinAttribute, GatedCfg, BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n };\n pub use removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};\n+\n+#[cfg(test)]\n+mod test {\n+    use super::UnstableFeatures;\n+\n+    #[test]\n+    fn rustc_bootstrap_parsing() {\n+        let is_bootstrap = |env, krate| {\n+            std::env::set_var(\"RUSTC_BOOTSTRAP\", env);\n+            matches!(UnstableFeatures::from_environment(krate), UnstableFeatures::Cheat)\n+        };\n+        assert!(is_bootstrap(\"1\", None));\n+        assert!(is_bootstrap(\"1\", Some(\"x\")));\n+        // RUSTC_BOOTSTRAP allows specifying a specific crate\n+        assert!(is_bootstrap(\"x\", Some(\"x\")));\n+        // RUSTC_BOOTSTRAP allows multiple comma-delimited crates\n+        assert!(is_bootstrap(\"x,y,z\", Some(\"x\")));\n+        assert!(is_bootstrap(\"x,y,z\", Some(\"y\")));\n+        // Crate that aren't specified do not get unstable features\n+        assert!(!is_bootstrap(\"x\", Some(\"a\")));\n+        assert!(!is_bootstrap(\"x,y,z\", Some(\"a\")));\n+        assert!(!is_bootstrap(\"x,y,z\", None));\n+\n+        // this is technically a breaking change, but there are no stability guarantees for RUSTC_BOOTSTRAP\n+        assert!(!is_bootstrap(\"0\", None));\n+    }\n+}"}, {"sha": "e185ee24d171bdcd8a4085505d83b5ddc0c15c4e", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -15,7 +15,6 @@ use std::io::{self, Read};\n use std::path::Path;\n \n use rustc_serialize::opaque::Encoder;\n-use rustc_session::config::nightly_options;\n \n /// The first few bytes of files generated by incremental compilation.\n const FILE_MAGIC: &[u8] = b\"RSIC\";\n@@ -28,12 +27,12 @@ const HEADER_FORMAT_VERSION: u16 = 0;\n /// the Git commit hash.\n const RUSTC_VERSION: Option<&str> = option_env!(\"CFG_VERSION\");\n \n-pub fn write_file_header(stream: &mut Encoder) {\n+pub fn write_file_header(stream: &mut Encoder, nightly_build: bool) {\n     stream.emit_raw_bytes(FILE_MAGIC);\n     stream\n         .emit_raw_bytes(&[(HEADER_FORMAT_VERSION >> 0) as u8, (HEADER_FORMAT_VERSION >> 8) as u8]);\n \n-    let rustc_version = rustc_version();\n+    let rustc_version = rustc_version(nightly_build);\n     assert_eq!(rustc_version.len(), (rustc_version.len() as u8) as usize);\n     stream.emit_raw_bytes(&[rustc_version.len() as u8]);\n     stream.emit_raw_bytes(rustc_version.as_bytes());\n@@ -51,6 +50,7 @@ pub fn write_file_header(stream: &mut Encoder) {\n pub fn read_file(\n     report_incremental_info: bool,\n     path: &Path,\n+    nightly_build: bool,\n ) -> io::Result<Option<(Vec<u8>, usize)>> {\n     if !path.exists() {\n         return Ok(None);\n@@ -93,7 +93,7 @@ pub fn read_file(\n         let mut buffer = vec![0; rustc_version_str_len];\n         file.read_exact(&mut buffer)?;\n \n-        if buffer != rustc_version().as_bytes() {\n+        if buffer != rustc_version(nightly_build).as_bytes() {\n             report_format_mismatch(report_incremental_info, path, \"Different compiler version\");\n             return Ok(None);\n         }\n@@ -115,8 +115,8 @@ fn report_format_mismatch(report_incremental_info: bool, file: &Path, message: &\n     }\n }\n \n-fn rustc_version() -> String {\n-    if nightly_options::is_nightly_build() {\n+fn rustc_version(nightly_build: bool) -> String {\n+    if nightly_build {\n         if let Some(val) = env::var_os(\"RUSTC_FORCE_INCR_COMP_ARTIFACT_HEADER\") {\n             return val.to_string_lossy().into_owned();\n         }"}, {"sha": "578c045a2b4e5d92aeaa7a9498a2a6220b88033e", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -53,8 +53,12 @@ impl LoadResult<(PreviousDepGraph, WorkProductMap)> {\n     }\n }\n \n-fn load_data(report_incremental_info: bool, path: &Path) -> LoadResult<(Vec<u8>, usize)> {\n-    match file_format::read_file(report_incremental_info, path) {\n+fn load_data(\n+    report_incremental_info: bool,\n+    path: &Path,\n+    nightly_build: bool,\n+) -> LoadResult<(Vec<u8>, usize)> {\n+    match file_format::read_file(report_incremental_info, path, nightly_build) {\n         Ok(Some(data_and_pos)) => LoadResult::Ok { data: data_and_pos },\n         Ok(None) => {\n             // The file either didn't exist or was produced by an incompatible\n@@ -111,13 +115,14 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     let expected_hash = sess.opts.dep_tracking_hash();\n \n     let mut prev_work_products = FxHashMap::default();\n+    let nightly_build = sess.is_nightly_build();\n \n     // If we are only building with -Zquery-dep-graph but without an actual\n     // incr. comp. session directory, we skip this. Otherwise we'd fail\n     // when trying to load work products.\n     if sess.incr_comp_session_dir_opt().is_some() {\n         let work_products_path = work_products_path(sess);\n-        let load_result = load_data(report_incremental_info, &work_products_path);\n+        let load_result = load_data(report_incremental_info, &work_products_path, nightly_build);\n \n         if let LoadResult::Ok { data: (work_products_data, start_pos) } = load_result {\n             // Decode the list of work_products\n@@ -163,7 +168,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     MaybeAsync::Async(std::thread::spawn(move || {\n         let _prof_timer = prof.generic_activity(\"incr_comp_load_dep_graph\");\n \n-        match load_data(report_incremental_info, &path) {\n+        match load_data(report_incremental_info, &path, nightly_build) {\n             LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n             LoadResult::Error { message } => LoadResult::Error { message },\n             LoadResult::Ok { data: (bytes, start_pos) } => {\n@@ -201,7 +206,11 @@ pub fn load_query_result_cache(sess: &Session) -> OnDiskCache<'_> {\n \n     let _prof_timer = sess.prof.generic_activity(\"incr_comp_load_query_result_cache\");\n \n-    match load_data(sess.opts.debugging_opts.incremental_info, &query_cache_path(sess)) {\n+    match load_data(\n+        sess.opts.debugging_opts.incremental_info,\n+        &query_cache_path(sess),\n+        sess.is_nightly_build(),\n+    ) {\n         LoadResult::Ok { data: (bytes, start_pos) } => OnDiskCache::new(sess, bytes, start_pos),\n         _ => OnDiskCache::new_empty(sess.source_map()),\n     }"}, {"sha": "102a77e8e79a7260f611486d6e0db5a5c9488905", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -119,7 +119,7 @@ where\n \n     // generate the data in a memory buffer\n     let mut encoder = Encoder::new(Vec::new());\n-    file_format::write_file_header(&mut encoder);\n+    file_format::write_file_header(&mut encoder, sess.is_nightly_build());\n     encode(&mut encoder);\n \n     // write the data out"}, {"sha": "82cf4ab7f5c0864c5fdab21739d9dcb67d20b720", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -6,6 +6,7 @@ use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self as ast, visit};\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{par_iter, Lrc, OnceCell, ParallelIterator, WorkerLocal};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n@@ -20,7 +21,6 @@ use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::middle;\n use rustc_middle::middle::cstore::{CrateStore, MetadataLoader, MetadataLoaderDyn};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::steal::Steal;\n use rustc_middle::ty::{self, GlobalCtxt, ResolverOutputs, TyCtxt};\n use rustc_mir as mir;\n use rustc_mir_build as mir_build;\n@@ -239,16 +239,12 @@ fn configure_and_expand_inner<'a>(\n \n     krate = sess.time(\"crate_injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| Symbol::intern(s));\n-        let (krate, name) = rustc_builtin_macros::standard_library_imports::inject(\n+        rustc_builtin_macros::standard_library_imports::inject(\n             krate,\n             &mut resolver,\n             &sess,\n             alt_std_name,\n-        );\n-        if let Some(name) = name {\n-            sess.parse_sess.injected_crate_name.set(name).expect(\"not yet initialized\");\n-        }\n-        krate\n+        )\n     });\n \n     util::check_attr_crate_type(&sess, &krate.attrs, &mut resolver.lint_buffer());"}, {"sha": "a2704c3adbf00e28e3cabff7b40f702ac792cb02", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -3,6 +3,7 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n \n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::ErrorReported;\n@@ -12,7 +13,6 @@ use rustc_incremental::DepGraphFuture;\n use rustc_lint::LintStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n-use rustc_middle::ty::steal::Steal;\n use rustc_middle::ty::{GlobalCtxt, ResolverOutputs, TyCtxt};\n use rustc_serialize::json;\n use rustc_session::config::{self, OutputFilenames, OutputType};"}, {"sha": "672073b1d3472766eaa5c32ceb8283c5ad811736", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -14,10 +14,10 @@ macro_rules! arena_types {\n             [] layouts: rustc_target::abi::Layout,\n             // AdtDef are interned and compared by address\n             [] adt_def: rustc_middle::ty::AdtDef,\n-            [] steal_mir: rustc_middle::ty::steal::Steal<rustc_middle::mir::Body<$tcx>>,\n+            [] steal_mir: rustc_data_structures::steal::Steal<rustc_middle::mir::Body<$tcx>>,\n             [decode] mir: rustc_middle::mir::Body<$tcx>,\n             [] steal_promoted:\n-                rustc_middle::ty::steal::Steal<\n+                rustc_data_structures::steal::Steal<\n                     rustc_index::vec::IndexVec<\n                         rustc_middle::mir::Promoted,\n                         rustc_middle::mir::Body<$tcx>"}, {"sha": "69bb4e23c4c0dccecaa87e12292a2c7f7a0d3d23", "filename": "compiler/rustc_middle/src/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -184,15 +184,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::FloatVid {\n     }\n }\n \n-impl<'a, T> HashStable<StableHashingContext<'a>> for ty::steal::Steal<T>\n-where\n-    T: HashStable<StableHashingContext<'a>>,\n-{\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.borrow().hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::privacy::AccessLevels {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {"}, {"sha": "b29e6d4a967058b3b248a28f46df4bd1363fe3ed", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -14,7 +14,6 @@ use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::traits;\n use crate::ty::query::{self, TyCtxtAt};\n-use crate::ty::steal::Steal;\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n use crate::ty::TyKind::*;\n use crate::ty::{\n@@ -33,6 +32,7 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{\n     hash_stable_hashmap, HashStable, StableHasher, StableVec,\n };\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::ErrorReported;"}, {"sha": "5e8a4a56db32c5b07594482d9afc871ec827fd23", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -106,7 +106,6 @@ pub mod outlives;\n pub mod print;\n pub mod query;\n pub mod relate;\n-pub mod steal;\n pub mod subst;\n pub mod trait_def;\n pub mod util;"}, {"sha": "187f86a52f4dc34abb5784c6811114a176826cfb", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -28,13 +28,13 @@ use crate::traits::query::{\n };\n use crate::traits::specialization_graph;\n use crate::traits::{self, ImplSource};\n-use crate::ty::steal::Steal;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::StableVec;\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorReported;"}, {"sha": "d2e65abfbc7ee74da9adb15da394a9c3c926fab7", "filename": "compiler/rustc_mir/src/transform/check_consts/ops.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -4,7 +4,6 @@ use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir;\n-use rustc_session::config::nightly_options;\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n@@ -104,7 +103,7 @@ impl NonConstOp for FnCallUnstable {\n \n         if ccx.is_const_stable_const_fn() {\n             err.help(\"Const-stable functions can only call other const-stable functions\");\n-        } else if nightly_options::is_nightly_build() {\n+        } else if ccx.tcx.sess.is_nightly_build() {\n             if let Some(feature) = feature {\n                 err.help(&format!(\n                     \"add `#![feature({})]` to the crate attributes to enable\","}, {"sha": "e86d11e248fceb3562eae8fa3e88970fd003d0b1", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1,14 +1,14 @@\n use crate::{shim, util};\n use required_consts::RequiredConstsVisitor;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::steal::Steal;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::Visitor as _;\n use rustc_middle::mir::{traversal, Body, ConstQualifs, MirPhase, Promoted};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::steal::Steal;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_span::{Span, Symbol};\n use std::borrow::Cow;"}, {"sha": "75399e9c32cc7b4e923395aa70e3dec80dc31a2c", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -181,6 +181,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n     fn visit_local(&mut self, local: &Local, context: PlaceContext, location: Location) {\n+        if self.body.local_decls.get(*local).is_none() {\n+            self.fail(\n+                location,\n+                format!(\"local {:?} has no corresponding declaration in `body.local_decls`\", local),\n+            );\n+        }\n+\n         if self.reachable_blocks.contains(location.block) && context.is_use() {\n             // Uses of locals must occur while the local's storage is allocated.\n             self.storage_liveness.seek_after_primary_effect(location);"}, {"sha": "6982cdccd52059f8bd6e69accf7aaf9ceae98da6", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -24,7 +24,7 @@ use super::lints;\n crate fn mir_built<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> &'tcx ty::steal::Steal<Body<'tcx>> {\n+) -> &'tcx rustc_data_structures::steal::Steal<Body<'tcx>> {\n     if let Some(def) = def.try_upgrade(tcx) {\n         return tcx.mir_built(def);\n     }"}, {"sha": "d395ae4ca2aa7637be5a18a0f6faf4cb639a5c09", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -12,7 +12,6 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{HirId, Pat};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_session::config::nightly_options;\n use rustc_session::lint::builtin::BINDINGS_WITH_VARIANT_NAME;\n use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS};\n use rustc_session::parse::feature_err;\n@@ -502,7 +501,7 @@ fn check_exhaustive<'p, 'tcx>(\n                 so a wildcard `_` is necessary to match exhaustively\",\n             scrut_ty,\n         ));\n-        if nightly_options::is_nightly_build() {\n+        if cx.tcx.sess.is_nightly_build() {\n             err.help(&format!(\n                 \"add `#![feature(precise_pointer_size_matching)]` \\\n                     to the crate attributes to enable precise `{}` matching\","}, {"sha": "ffbf786491df2d6035020e4bbf0ee689c40eb503", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1089,6 +1089,9 @@ impl<'a> Parser<'a> {\n             self.parse_yield_expr(attrs)\n         } else if self.eat_keyword(kw::Let) {\n             self.parse_let_expr(attrs)\n+        } else if self.eat_keyword(kw::Underscore) {\n+            self.sess.gated_spans.gate(sym::destructuring_assignment, self.prev_token.span);\n+            Ok(self.mk_expr(self.prev_token.span, ExprKind::Underscore, attrs))\n         } else if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n             // Don't complain about bare semicolons after unclosed braces\n             // recovery in order to keep the error count down. Fixing the"}, {"sha": "e37c6418eb81caace69acc2f6fe2216715c50d12", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -15,7 +15,6 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::nightly_options;\n use rustc_session::parse::feature_err;\n use rustc_span::{sym, Span, Symbol};\n \n@@ -145,7 +144,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n                 //\n                 // FIXME(ecstaticmorse): Maybe this could be incorporated into `feature_err`? This\n                 // is a pretty narrow case, however.\n-                if nightly_options::is_nightly_build() {\n+                if tcx.sess.is_nightly_build() {\n                     for gate in missing_secondary {\n                         let note = format!(\n                             \"add `#![feature({})]` to the crate attributes to enable\","}, {"sha": "493b9f15271ef8258fbf63f8846bdc75fb85690d", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1163,9 +1163,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n         assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");\n \n-        let scope = self.r.arenas.alloc_macro_rules_scope(MacroRulesScope::Invocation(invoc_id));\n-        self.r.invocation_macro_rules_scopes.entry(invoc_id).or_default().insert(scope);\n-        scope\n+        self.r.arenas.alloc_macro_rules_scope(MacroRulesScope::Invocation(invoc_id))\n     }\n \n     fn proc_macro_stub(&self, item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {"}, {"sha": "2473436a91675b14cbd9c3afe1193deb1ff4b4b0", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -16,7 +16,6 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n-use rustc_session::config::nightly_options;\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -890,7 +889,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             }\n             (Res::Def(DefKind::TyAlias, def_id), PathSource::Trait(_)) => {\n                 err.span_label(span, \"type aliases cannot be used as traits\");\n-                if nightly_options::is_nightly_build() {\n+                if self.r.session.is_nightly_build() {\n                     let msg = \"you might have meant to use `#![feature(trait_alias)]` instead of a \\\n                                `type` alias\";\n                     if let Some(span) = self.def_span(def_id) {\n@@ -1675,7 +1674,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                 _ => {}\n             }\n         }\n-        if nightly_options::is_nightly_build()\n+        if self.tcx.sess.is_nightly_build()\n             && !self.tcx.features().in_band_lifetimes\n             && suggests_in_band\n         {"}, {"sha": "d18335ef2e63a205d755e3a85241d75a96a12461", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -976,9 +976,6 @@ pub struct Resolver<'a> {\n     /// `macro_rules` scopes *produced* by expanding the macro invocations,\n     /// include all the `macro_rules` items and other invocations generated by them.\n     output_macro_rules_scopes: FxHashMap<ExpnId, MacroRulesScopeRef<'a>>,\n-    /// References to all `MacroRulesScope::Invocation(invoc_id)`s, used to update such scopes\n-    /// when their corresponding `invoc_id`s get expanded.\n-    invocation_macro_rules_scopes: FxHashMap<ExpnId, FxHashSet<MacroRulesScopeRef<'a>>>,\n     /// Helper attributes that are in scope for the given expansion.\n     helper_attrs: FxHashMap<ExpnId, Vec<Ident>>,\n \n@@ -1310,7 +1307,6 @@ impl<'a> Resolver<'a> {\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n             invocation_parent_scopes: Default::default(),\n             output_macro_rules_scopes: Default::default(),\n-            invocation_macro_rules_scopes: Default::default(),\n             helper_attrs: Default::default(),\n             local_macro_def_scopes: FxHashMap::default(),\n             name_already_seen: FxHashMap::default(),\n@@ -1680,7 +1676,20 @@ impl<'a> Resolver<'a> {\n                     !(expn_id == parent_scope.expansion && macro_kind == Some(MacroKind::Derive))\n                 }\n                 Scope::DeriveHelpersCompat => true,\n-                Scope::MacroRules(..) => true,\n+                Scope::MacroRules(macro_rules_scope) => {\n+                    // Use \"path compression\" on `macro_rules` scope chains. This is an optimization\n+                    // used to avoid long scope chains, see the comments on `MacroRulesScopeRef`.\n+                    // As another consequence of this optimization visitors never observe invocation\n+                    // scopes for macros that were already expanded.\n+                    while let MacroRulesScope::Invocation(invoc_id) = macro_rules_scope.get() {\n+                        if let Some(next_scope) = self.output_macro_rules_scopes.get(&invoc_id) {\n+                            macro_rules_scope.set(next_scope.get());\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                    true\n+                }\n                 Scope::CrateRoot => true,\n                 Scope::Module(..) => true,\n                 Scope::RegisteredAttrs => use_prelude,\n@@ -1716,11 +1725,9 @@ impl<'a> Resolver<'a> {\n                     MacroRulesScope::Binding(binding) => {\n                         Scope::MacroRules(binding.parent_macro_rules_scope)\n                     }\n-                    MacroRulesScope::Invocation(invoc_id) => Scope::MacroRules(\n-                        self.output_macro_rules_scopes.get(&invoc_id).cloned().unwrap_or_else(\n-                            || self.invocation_parent_scopes[&invoc_id].macro_rules,\n-                        ),\n-                    ),\n+                    MacroRulesScope::Invocation(invoc_id) => {\n+                        Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n+                    }\n                     MacroRulesScope::Empty => Scope::Module(module),\n                 },\n                 Scope::CrateRoot => match ns {"}, {"sha": "e052b6b334529c036ee4ba29e5f443f96abe4023", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -62,8 +62,8 @@ pub enum MacroRulesScope<'a> {\n }\n \n /// `macro_rules!` scopes are always kept by reference and inside a cell.\n-/// The reason is that we update all scopes with value `MacroRulesScope::Invocation(invoc_id)`\n-/// in-place immediately after `invoc_id` gets expanded.\n+/// The reason is that we update scopes with value `MacroRulesScope::Invocation(invoc_id)`\n+/// in-place after `invoc_id` gets expanded.\n /// This helps to avoid uncontrollable growth of `macro_rules!` scope chains,\n /// which usually grow lineraly with the number of macro invocations\n /// in a module (including derives) and hurt performance.\n@@ -173,22 +173,6 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         let output_macro_rules_scope = self.build_reduced_graph(fragment, parent_scope);\n         self.output_macro_rules_scopes.insert(expansion, output_macro_rules_scope);\n \n-        // Update all `macro_rules` scopes referring to this invocation. This is an optimization\n-        // used to avoid long scope chains, see the comments on `MacroRulesScopeRef`.\n-        if let Some(invocation_scopes) = self.invocation_macro_rules_scopes.remove(&expansion) {\n-            for invocation_scope in &invocation_scopes {\n-                invocation_scope.set(output_macro_rules_scope.get());\n-            }\n-            // All `macro_rules` scopes that previously referred to `expansion`\n-            // are now rerouted to its output scope, if it's also an invocation.\n-            if let MacroRulesScope::Invocation(invoc_id) = output_macro_rules_scope.get() {\n-                self.invocation_macro_rules_scopes\n-                    .entry(invoc_id)\n-                    .or_default()\n-                    .extend(invocation_scopes);\n-            }\n-        }\n-\n         parent_scope.module.unexpanded_invocations.borrow_mut().remove(&expansion);\n     }\n \n@@ -687,11 +671,7 @@ impl<'a> Resolver<'a> {\n                         {\n                             Ok((macro_rules_binding.binding, Flags::MACRO_RULES))\n                         }\n-                        MacroRulesScope::Invocation(invoc_id)\n-                            if !this.output_macro_rules_scopes.contains_key(&invoc_id) =>\n-                        {\n-                            Err(Determinacy::Undetermined)\n-                        }\n+                        MacroRulesScope::Invocation(_) => Err(Determinacy::Undetermined),\n                         _ => Err(Determinacy::Determined),\n                     },\n                     Scope::CrateRoot => {"}, {"sha": "db16a90cc60fa38262e20ae334087650c9f9b16b", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1250,7 +1250,7 @@ fn parse_crate_edition(matches: &getopts::Matches) -> Edition {\n         None => DEFAULT_EDITION,\n     };\n \n-    if !edition.is_stable() && !nightly_options::is_nightly_build() {\n+    if !edition.is_stable() && !nightly_options::match_is_nightly_build(matches) {\n         early_error(\n             ErrorOutputType::default(),\n             &format!(\n@@ -1547,7 +1547,9 @@ fn parse_libs(\n                     );\n                 }\n             };\n-            if kind == NativeLibKind::StaticNoBundle && !nightly_options::is_nightly_build() {\n+            if kind == NativeLibKind::StaticNoBundle\n+                && !nightly_options::match_is_nightly_build(matches)\n+            {\n                 early_error(\n                     error_format,\n                     \"the library kind 'static-nobundle' is only \\\n@@ -1836,10 +1838,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         cg,\n         error_format,\n         externs,\n+        unstable_features: UnstableFeatures::from_environment(crate_name.as_deref()),\n         crate_name,\n         alt_std_name: None,\n         libs,\n-        unstable_features: UnstableFeatures::from_environment(),\n         debug_assertions,\n         actually_rustdoc: false,\n         trimmed_def_paths: TrimmedDefPaths::default(),\n@@ -1960,17 +1962,21 @@ pub mod nightly_options {\n     use rustc_feature::UnstableFeatures;\n \n     pub fn is_unstable_enabled(matches: &getopts::Matches) -> bool {\n-        is_nightly_build() && matches.opt_strs(\"Z\").iter().any(|x| *x == \"unstable-options\")\n+        match_is_nightly_build(matches)\n+            && matches.opt_strs(\"Z\").iter().any(|x| *x == \"unstable-options\")\n     }\n \n-    pub fn is_nightly_build() -> bool {\n-        UnstableFeatures::from_environment().is_nightly_build()\n+    pub fn match_is_nightly_build(matches: &getopts::Matches) -> bool {\n+        is_nightly_build(matches.opt_str(\"crate-name\").as_deref())\n+    }\n+\n+    pub fn is_nightly_build(krate: Option<&str>) -> bool {\n+        UnstableFeatures::from_environment(krate).is_nightly_build()\n     }\n \n     pub fn check_nightly_options(matches: &getopts::Matches, flags: &[RustcOptGroup]) {\n         let has_z_unstable_option = matches.opt_strs(\"Z\").iter().any(|x| *x == \"unstable-options\");\n-        let really_allows_unstable_options =\n-            UnstableFeatures::from_environment().is_nightly_build();\n+        let really_allows_unstable_options = match_is_nightly_build(matches);\n \n         for opt in flags.iter() {\n             if opt.stability == OptionStability::Stable {"}, {"sha": "66c3738fb5b5ae1716205deadbab597c9a8d6460", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -4,7 +4,7 @@\n use crate::lint::{BufferedEarlyLint, BuiltinLintDiagnostics, Lint, LintId};\n use rustc_ast::node_id::NodeId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync::{Lock, Lrc, OnceCell};\n+use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder};\n use rustc_feature::{find_feature_issue, GateIssue, UnstableFeatures};\n@@ -129,7 +129,6 @@ pub struct ParseSess {\n     /// operation token that followed it, but that the parser cannot identify without further\n     /// analysis.\n     pub ambiguous_block_expr_parse: Lock<FxHashMap<Span, Span>>,\n-    pub injected_crate_name: OnceCell<Symbol>,\n     pub gated_spans: GatedSpans,\n     pub symbol_gallery: SymbolGallery,\n     /// The parser has reached `Eof` due to an unclosed brace. Used to silence unnecessary errors.\n@@ -150,15 +149,14 @@ impl ParseSess {\n     pub fn with_span_handler(handler: Handler, source_map: Lrc<SourceMap>) -> Self {\n         Self {\n             span_diagnostic: handler,\n-            unstable_features: UnstableFeatures::from_environment(),\n+            unstable_features: UnstableFeatures::from_environment(None),\n             config: FxHashSet::default(),\n             edition: ExpnId::root().expn_data().edition,\n             raw_identifier_spans: Lock::new(Vec::new()),\n             included_mod_stack: Lock::new(vec![]),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n-            injected_crate_name: OnceCell::new(),\n             gated_spans: GatedSpans::default(),\n             symbol_gallery: SymbolGallery::default(),\n             reached_eof: Lock::new(false),"}, {"sha": "419d1447764ec833e0182adef3ee8580ebfc44d9", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -745,6 +745,9 @@ impl Session {\n     pub fn unstable_options(&self) -> bool {\n         self.opts.debugging_opts.unstable_options\n     }\n+    pub fn is_nightly_build(&self) -> bool {\n+        self.opts.unstable_features.is_nightly_build()\n+    }\n     pub fn overflow_checks(&self) -> bool {\n         self.opts\n             .cg"}, {"sha": "37538e7aac4957cf6fac3521dd9d9704596ea40b", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -12,7 +12,6 @@ use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_session::config::nightly_options;\n use rustc_span::Span;\n \n use std::ops::ControlFlow;\n@@ -602,7 +601,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n         err.span_label(span, label);\n \n-        if nightly_options::is_nightly_build() {\n+        if self.tcx.sess.is_nightly_build() {\n             err.help(\"add #![feature(member_constraints)] to the crate attributes to enable\");\n         }\n "}, {"sha": "301ede66006de64970547151f0429ef5cc6f54f7", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1,12 +1,13 @@\n use crate::astconv::{\n-    AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, GenericArgPosition,\n+    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n+    GenericArgCountResult, GenericArgPosition,\n };\n use crate::errors::AssocTypeBindingNotAllowed;\n use rustc_ast::ast::ParamKindOrd;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{GenericArg, GenericArgs};\n+use rustc_hir::GenericArg;\n use rustc_middle::ty::{\n     self, subst, subst::SubstsRef, GenericParamDef, GenericParamDefKind, Ty, TyCtxt,\n };\n@@ -90,20 +91,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ///   instantiate a `GenericArg`.\n     /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n     ///   creates a suitable inference variable.\n-    pub fn create_substs_for_generic_args<'b>(\n+    pub fn create_substs_for_generic_args<'a>(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n         arg_count: GenericArgCountResult,\n-        args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n-        mut provided_kind: impl FnMut(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n-        mut inferred_kind: impl FnMut(\n-            Option<&[subst::GenericArg<'tcx>]>,\n-            &GenericParamDef,\n-            bool,\n-        ) -> subst::GenericArg<'tcx>,\n+        ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n     ) -> SubstsRef<'tcx> {\n         // Collect the segments of the path; we need to substitute arguments\n         // for parameters throughout the entire path (wherever there are\n@@ -142,7 +137,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             substs.push(\n                                 self_ty\n                                     .map(|ty| ty.into())\n-                                    .unwrap_or_else(|| inferred_kind(None, param, true)),\n+                                    .unwrap_or_else(|| ctx.inferred_kind(None, param, true)),\n                             );\n                             params.next();\n                         }\n@@ -151,7 +146,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n \n             // Check whether this segment takes generic arguments and the user has provided any.\n-            let (generic_args, infer_args) = args_for_def_id(def_id);\n+            let (generic_args, infer_args) = ctx.args_for_def_id(def_id);\n \n             let mut args =\n                 generic_args.iter().flat_map(|generic_args| generic_args.args.iter()).peekable();\n@@ -173,7 +168,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n                             | (GenericArg::Type(_), GenericParamDefKind::Type { .. }, _)\n                             | (GenericArg::Const(_), GenericParamDefKind::Const, _) => {\n-                                substs.push(provided_kind(param, arg));\n+                                substs.push(ctx.provided_kind(param, arg));\n                                 args.next();\n                                 params.next();\n                             }\n@@ -184,7 +179,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             ) => {\n                                 // We expected a lifetime argument, but got a type or const\n                                 // argument. That means we're inferring the lifetimes.\n-                                substs.push(inferred_kind(None, param, infer_args));\n+                                substs.push(ctx.inferred_kind(None, param, infer_args));\n                                 force_infer_lt = Some(arg);\n                                 params.next();\n                             }\n@@ -302,7 +297,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     (None, Some(&param)) => {\n                         // If there are fewer arguments than parameters, it means\n                         // we're inferring the remaining arguments.\n-                        substs.push(inferred_kind(Some(&substs), param, infer_args));\n+                        substs.push(ctx.inferred_kind(Some(&substs), param, infer_args));\n                         params.next();\n                     }\n "}, {"sha": "89c5adfa14c670a0c9e1749af59203518186de4f", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 143, "deletions": 81, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -165,6 +165,23 @@ pub struct GenericArgCountResult {\n     pub correct: Result<(), GenericArgCountMismatch>,\n }\n \n+pub trait CreateSubstsForGenericArgsCtxt<'a, 'tcx> {\n+    fn args_for_def_id(&mut self, def_id: DefId) -> (Option<&'a GenericArgs<'a>>, bool);\n+\n+    fn provided_kind(\n+        &mut self,\n+        param: &ty::GenericParamDef,\n+        arg: &GenericArg<'_>,\n+    ) -> subst::GenericArg<'tcx>;\n+\n+    fn inferred_kind(\n+        &mut self,\n+        substs: Option<&[subst::GenericArg<'tcx>]>,\n+        param: &ty::GenericParamDef,\n+        infer_args: bool,\n+    ) -> subst::GenericArg<'tcx>;\n+}\n+\n impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn ast_region_to_region(\n         &self,\n@@ -321,81 +338,102 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n \n         let is_object = self_ty.map_or(false, |ty| ty == self.tcx().types.trait_object_dummy_self);\n-        let default_needs_object_self = |param: &ty::GenericParamDef| {\n-            if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n-                if is_object && has_default {\n-                    let default_ty = tcx.at(span).type_of(param.def_id);\n-                    let self_param = tcx.types.self_param;\n-                    if default_ty.walk().any(|arg| arg == self_param.into()) {\n-                        // There is no suitable inference default for a type parameter\n-                        // that references self, in an object type.\n-                        return true;\n+\n+        struct SubstsForAstPathCtxt<'a, 'tcx> {\n+            astconv: &'a (dyn AstConv<'tcx> + 'a),\n+            def_id: DefId,\n+            generic_args: &'a GenericArgs<'a>,\n+            span: Span,\n+            missing_type_params: Vec<String>,\n+            inferred_params: Vec<Span>,\n+            infer_args: bool,\n+            is_object: bool,\n+        }\n+\n+        impl<'tcx, 'a> SubstsForAstPathCtxt<'tcx, 'a> {\n+            fn default_needs_object_self(&mut self, param: &ty::GenericParamDef) -> bool {\n+                let tcx = self.astconv.tcx();\n+                if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n+                    if self.is_object && has_default {\n+                        let default_ty = tcx.at(self.span).type_of(param.def_id);\n+                        let self_param = tcx.types.self_param;\n+                        if default_ty.walk().any(|arg| arg == self_param.into()) {\n+                            // There is no suitable inference default for a type parameter\n+                            // that references self, in an object type.\n+                            return true;\n+                        }\n                     }\n                 }\n-            }\n \n-            false\n-        };\n+                false\n+            }\n+        }\n \n-        let mut missing_type_params = vec![];\n-        let mut inferred_params = vec![];\n-        let substs = Self::create_substs_for_generic_args(\n-            tcx,\n-            def_id,\n-            parent_substs,\n-            self_ty.is_some(),\n-            self_ty,\n-            arg_count.clone(),\n-            // Provide the generic args, and whether types should be inferred.\n-            |did| {\n-                if did == def_id {\n-                    (Some(generic_args), infer_args)\n+        impl<'a, 'tcx> CreateSubstsForGenericArgsCtxt<'a, 'tcx> for SubstsForAstPathCtxt<'a, 'tcx> {\n+            fn args_for_def_id(&mut self, did: DefId) -> (Option<&'a GenericArgs<'a>>, bool) {\n+                if did == self.def_id {\n+                    (Some(self.generic_args), self.infer_args)\n                 } else {\n                     // The last component of this tuple is unimportant.\n                     (None, false)\n                 }\n-            },\n-            // Provide substitutions for parameters for which (valid) arguments have been provided.\n-            |param, arg| match (&param.kind, arg) {\n-                (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                    self.ast_region_to_region(&lt, Some(param)).into()\n-                }\n-                (GenericParamDefKind::Type { has_default, .. }, GenericArg::Type(ty)) => {\n-                    if *has_default {\n-                        tcx.check_optional_stability(\n-                            param.def_id,\n-                            Some(arg.id()),\n-                            arg.span(),\n-                            |_, _| {\n-                                // Default generic parameters may not be marked\n-                                // with stability attributes, i.e. when the\n-                                // default parameter was defined at the same time\n-                                // as the rest of the type. As such, we ignore missing\n-                                // stability attributes.\n+            }\n+\n+            fn provided_kind(\n+                &mut self,\n+                param: &ty::GenericParamDef,\n+                arg: &GenericArg<'_>,\n+            ) -> subst::GenericArg<'tcx> {\n+                let tcx = self.astconv.tcx();\n+                match (&param.kind, arg) {\n+                    (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n+                        self.astconv.ast_region_to_region(&lt, Some(param)).into()\n+                    }\n+                    (&GenericParamDefKind::Type { has_default, .. }, GenericArg::Type(ty)) => {\n+                        if has_default {\n+                            tcx.check_optional_stability(\n+                                param.def_id,\n+                                Some(arg.id()),\n+                                arg.span(),\n+                                |_, _| {\n+                                    // Default generic parameters may not be marked\n+                                    // with stability attributes, i.e. when the\n+                                    // default parameter was defined at the same time\n+                                    // as the rest of the type. As such, we ignore missing\n+                                    // stability attributes.\n+                                },\n+                            )\n+                        }\n+                        if let (hir::TyKind::Infer, false) =\n+                            (&ty.kind, self.astconv.allow_ty_infer())\n+                        {\n+                            self.inferred_params.push(ty.span);\n+                            tcx.ty_error().into()\n+                        } else {\n+                            self.astconv.ast_ty_to_ty(&ty).into()\n+                        }\n+                    }\n+                    (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n+                        ty::Const::from_opt_const_arg_anon_const(\n+                            tcx,\n+                            ty::WithOptConstParam {\n+                                did: tcx.hir().local_def_id(ct.value.hir_id),\n+                                const_param_did: Some(param.def_id),\n                             },\n                         )\n+                        .into()\n                     }\n-                    if let (hir::TyKind::Infer, false) = (&ty.kind, self.allow_ty_infer()) {\n-                        inferred_params.push(ty.span);\n-                        tcx.ty_error().into()\n-                    } else {\n-                        self.ast_ty_to_ty(&ty).into()\n-                    }\n-                }\n-                (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                    ty::Const::from_opt_const_arg_anon_const(\n-                        tcx,\n-                        ty::WithOptConstParam {\n-                            did: tcx.hir().local_def_id(ct.value.hir_id),\n-                            const_param_did: Some(param.def_id),\n-                        },\n-                    )\n-                    .into()\n+                    _ => unreachable!(),\n                 }\n-                _ => unreachable!(),\n-            },\n-            // Provide substitutions for parameters for which arguments are inferred.\n-            |substs, param, infer_args| {\n+            }\n+\n+            fn inferred_kind(\n+                &mut self,\n+                substs: Option<&[subst::GenericArg<'tcx>]>,\n+                param: &ty::GenericParamDef,\n+                infer_args: bool,\n+            ) -> subst::GenericArg<'tcx> {\n+                let tcx = self.astconv.tcx();\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => tcx.lifetimes.re_static.into(),\n                     GenericParamDefKind::Type { has_default, .. } => {\n@@ -407,48 +445,72 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             // other type parameters may reference `Self` in their\n                             // defaults. This will lead to an ICE if we are not\n                             // careful!\n-                            if default_needs_object_self(param) {\n-                                missing_type_params.push(param.name.to_string());\n+                            if self.default_needs_object_self(param) {\n+                                self.missing_type_params.push(param.name.to_string());\n                                 tcx.ty_error().into()\n                             } else {\n                                 // This is a default type parameter.\n-                                self.normalize_ty(\n-                                    span,\n-                                    tcx.at(span).type_of(param.def_id).subst_spanned(\n-                                        tcx,\n-                                        substs.unwrap(),\n-                                        Some(span),\n-                                    ),\n-                                )\n-                                .into()\n+                                self.astconv\n+                                    .normalize_ty(\n+                                        self.span,\n+                                        tcx.at(self.span).type_of(param.def_id).subst_spanned(\n+                                            tcx,\n+                                            substs.unwrap(),\n+                                            Some(self.span),\n+                                        ),\n+                                    )\n+                                    .into()\n                             }\n                         } else if infer_args {\n                             // No type parameters were provided, we can infer all.\n-                            let param =\n-                                if !default_needs_object_self(param) { Some(param) } else { None };\n-                            self.ty_infer(param, span).into()\n+                            let param = if !self.default_needs_object_self(param) {\n+                                Some(param)\n+                            } else {\n+                                None\n+                            };\n+                            self.astconv.ty_infer(param, self.span).into()\n                         } else {\n                             // We've already errored above about the mismatch.\n                             tcx.ty_error().into()\n                         }\n                     }\n                     GenericParamDefKind::Const => {\n-                        let ty = tcx.at(span).type_of(param.def_id);\n+                        let ty = tcx.at(self.span).type_of(param.def_id);\n                         // FIXME(const_generics:defaults)\n                         if infer_args {\n                             // No const parameters were provided, we can infer all.\n-                            self.ct_infer(ty, Some(param), span).into()\n+                            self.astconv.ct_infer(ty, Some(param), self.span).into()\n                         } else {\n                             // We've already errored above about the mismatch.\n                             tcx.const_error(ty).into()\n                         }\n                     }\n                 }\n-            },\n+            }\n+        }\n+\n+        let mut substs_ctx = SubstsForAstPathCtxt {\n+            astconv: self,\n+            def_id,\n+            span,\n+            generic_args,\n+            missing_type_params: vec![],\n+            inferred_params: vec![],\n+            infer_args,\n+            is_object,\n+        };\n+        let substs = Self::create_substs_for_generic_args(\n+            tcx,\n+            def_id,\n+            parent_substs,\n+            self_ty.is_some(),\n+            self_ty,\n+            arg_count.clone(),\n+            &mut substs_ctx,\n         );\n \n         self.complain_about_missing_type_params(\n-            missing_type_params,\n+            substs_ctx.missing_type_params,\n             def_id,\n             span,\n             generic_args.args.is_empty(),"}, {"sha": "300ee8f85f8dd39c327a913de1016b87646ad197", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 90, "deletions": 57, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1,5 +1,6 @@\n use crate::astconv::{\n-    AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, PathSeg,\n+    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n+    GenericArgCountResult, PathSeg,\n };\n use crate::check::callee::{self, DeferredCallResolution};\n use crate::check::method::{self, MethodCallee, SelfSource};\n@@ -1298,76 +1299,108 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         };\n \n-        let substs = self_ctor_substs.unwrap_or_else(|| {\n-            AstConv::create_substs_for_generic_args(\n-                tcx,\n-                def_id,\n-                &[][..],\n-                has_self,\n-                self_ty,\n-                arg_count,\n-                // Provide the generic args, and whether types should be inferred.\n-                |def_id| {\n-                    if let Some(&PathSeg(_, index)) =\n-                        path_segs.iter().find(|&PathSeg(did, _)| *did == def_id)\n-                    {\n-                        // If we've encountered an `impl Trait`-related error, we're just\n-                        // going to infer the arguments for better error messages.\n-                        if !infer_args_for_err.contains(&index) {\n-                            // Check whether the user has provided generic arguments.\n-                            if let Some(ref data) = segments[index].args {\n-                                return (Some(data), segments[index].infer_args);\n-                            }\n+        struct CreateCtorSubstsContext<'a, 'tcx> {\n+            fcx: &'a FnCtxt<'a, 'tcx>,\n+            span: Span,\n+            path_segs: &'a [PathSeg],\n+            infer_args_for_err: &'a FxHashSet<usize>,\n+            segments: &'a [hir::PathSegment<'a>],\n+        }\n+        impl<'tcx, 'a> CreateSubstsForGenericArgsCtxt<'a, 'tcx> for CreateCtorSubstsContext<'a, 'tcx> {\n+            fn args_for_def_id(\n+                &mut self,\n+                def_id: DefId,\n+            ) -> (Option<&'a hir::GenericArgs<'a>>, bool) {\n+                if let Some(&PathSeg(_, index)) =\n+                    self.path_segs.iter().find(|&PathSeg(did, _)| *did == def_id)\n+                {\n+                    // If we've encountered an `impl Trait`-related error, we're just\n+                    // going to infer the arguments for better error messages.\n+                    if !self.infer_args_for_err.contains(&index) {\n+                        // Check whether the user has provided generic arguments.\n+                        if let Some(ref data) = self.segments[index].args {\n+                            return (Some(data), self.segments[index].infer_args);\n                         }\n-                        return (None, segments[index].infer_args);\n                     }\n+                    return (None, self.segments[index].infer_args);\n+                }\n \n-                    (None, true)\n-                },\n-                // Provide substitutions for parameters for which (valid) arguments have been provided.\n-                |param, arg| match (&param.kind, arg) {\n+                (None, true)\n+            }\n+\n+            fn provided_kind(\n+                &mut self,\n+                param: &ty::GenericParamDef,\n+                arg: &GenericArg<'_>,\n+            ) -> subst::GenericArg<'tcx> {\n+                match (&param.kind, arg) {\n                     (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                        AstConv::ast_region_to_region(self, lt, Some(param)).into()\n+                        AstConv::ast_region_to_region(self.fcx, lt, Some(param)).into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n-                        self.to_ty(ty).into()\n+                        self.fcx.to_ty(ty).into()\n                     }\n                     (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                        self.const_arg_to_const(&ct.value, param.def_id).into()\n+                        self.fcx.const_arg_to_const(&ct.value, param.def_id).into()\n                     }\n                     _ => unreachable!(),\n-                },\n-                // Provide substitutions for parameters for which arguments are inferred.\n-                |substs, param, infer_args| {\n-                    match param.kind {\n-                        GenericParamDefKind::Lifetime => {\n-                            self.re_infer(Some(param), span).unwrap().into()\n-                        }\n-                        GenericParamDefKind::Type { has_default, .. } => {\n-                            if !infer_args && has_default {\n-                                // If we have a default, then we it doesn't matter that we're not\n-                                // inferring the type arguments: we provide the default where any\n-                                // is missing.\n-                                let default = tcx.type_of(param.def_id);\n-                                self.normalize_ty(\n-                                    span,\n-                                    default.subst_spanned(tcx, substs.unwrap(), Some(span)),\n+                }\n+            }\n+\n+            fn inferred_kind(\n+                &mut self,\n+                substs: Option<&[subst::GenericArg<'tcx>]>,\n+                param: &ty::GenericParamDef,\n+                infer_args: bool,\n+            ) -> subst::GenericArg<'tcx> {\n+                let tcx = self.fcx.tcx();\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => {\n+                        self.fcx.re_infer(Some(param), self.span).unwrap().into()\n+                    }\n+                    GenericParamDefKind::Type { has_default, .. } => {\n+                        if !infer_args && has_default {\n+                            // If we have a default, then we it doesn't matter that we're not\n+                            // inferring the type arguments: we provide the default where any\n+                            // is missing.\n+                            let default = tcx.type_of(param.def_id);\n+                            self.fcx\n+                                .normalize_ty(\n+                                    self.span,\n+                                    default.subst_spanned(tcx, substs.unwrap(), Some(self.span)),\n                                 )\n                                 .into()\n-                            } else {\n-                                // If no type arguments were provided, we have to infer them.\n-                                // This case also occurs as a result of some malformed input, e.g.\n-                                // a lifetime argument being given instead of a type parameter.\n-                                // Using inference instead of `Error` gives better error messages.\n-                                self.var_for_def(span, param)\n-                            }\n-                        }\n-                        GenericParamDefKind::Const => {\n-                            // FIXME(const_generics:defaults)\n-                            // No const parameters were provided, we have to infer them.\n-                            self.var_for_def(span, param)\n+                        } else {\n+                            // If no type arguments were provided, we have to infer them.\n+                            // This case also occurs as a result of some malformed input, e.g.\n+                            // a lifetime argument being given instead of a type parameter.\n+                            // Using inference instead of `Error` gives better error messages.\n+                            self.fcx.var_for_def(self.span, param)\n                         }\n                     }\n+                    GenericParamDefKind::Const => {\n+                        // FIXME(const_generics:defaults)\n+                        // No const parameters were provided, we have to infer them.\n+                        self.fcx.var_for_def(self.span, param)\n+                    }\n+                }\n+            }\n+        }\n+\n+        let substs = self_ctor_substs.unwrap_or_else(|| {\n+            AstConv::create_substs_for_generic_args(\n+                tcx,\n+                def_id,\n+                &[][..],\n+                has_self,\n+                self_ty,\n+                arg_count,\n+                &mut CreateCtorSubstsContext {\n+                    fcx: self,\n+                    span,\n+                    path_segs: &path_segs,\n+                    infer_args_for_err: &infer_args_for_err,\n+                    segments,\n                 },\n             )\n         });"}, {"sha": "fb048abc0e9cd9f74645669761a9dc7318c92894", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1,6 +1,6 @@\n use super::{probe, MethodCallee};\n \n-use crate::astconv::AstConv;\n+use crate::astconv::{AstConv, CreateSubstsForGenericArgsCtxt};\n use crate::check::{callee, FnCtxt};\n use crate::hir::def_id::DefId;\n use crate::hir::GenericArg;\n@@ -10,7 +10,7 @@ use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n+use rustc_middle::ty::subst::{self, Subst, SubstsRef};\n use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n@@ -307,36 +307,60 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // parameters from the type and those from the method.\n         assert_eq!(generics.parent_count, parent_substs.len());\n \n+        struct MethodSubstsCtxt<'a, 'tcx> {\n+            cfcx: &'a ConfirmContext<'a, 'tcx>,\n+            pick: &'a probe::Pick<'tcx>,\n+            seg: &'a hir::PathSegment<'a>,\n+        }\n+        impl<'a, 'tcx> CreateSubstsForGenericArgsCtxt<'a, 'tcx> for MethodSubstsCtxt<'a, 'tcx> {\n+            fn args_for_def_id(\n+                &mut self,\n+                def_id: DefId,\n+            ) -> (Option<&'a hir::GenericArgs<'a>>, bool) {\n+                if def_id == self.pick.item.def_id {\n+                    if let Some(ref data) = self.seg.args {\n+                        return (Some(data), false);\n+                    }\n+                }\n+                (None, false)\n+            }\n+\n+            fn provided_kind(\n+                &mut self,\n+                param: &ty::GenericParamDef,\n+                arg: &GenericArg<'_>,\n+            ) -> subst::GenericArg<'tcx> {\n+                match (&param.kind, arg) {\n+                    (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n+                        AstConv::ast_region_to_region(self.cfcx.fcx, lt, Some(param)).into()\n+                    }\n+                    (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n+                        self.cfcx.to_ty(ty).into()\n+                    }\n+                    (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n+                        self.cfcx.const_arg_to_const(&ct.value, param.def_id).into()\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+\n+            fn inferred_kind(\n+                &mut self,\n+                _substs: Option<&[subst::GenericArg<'tcx>]>,\n+                param: &ty::GenericParamDef,\n+                _infer_args: bool,\n+            ) -> subst::GenericArg<'tcx> {\n+                self.cfcx.var_for_def(self.cfcx.span, param)\n+            }\n+        }\n         AstConv::create_substs_for_generic_args(\n             self.tcx,\n             pick.item.def_id,\n             parent_substs,\n             false,\n             None,\n             arg_count_correct,\n-            // Provide the generic args, and whether types should be inferred.\n-            |def_id| {\n-                // The last component of the returned tuple here is unimportant.\n-                if def_id == pick.item.def_id {\n-                    if let Some(ref data) = seg.args {\n-                        return (Some(data), false);\n-                    }\n-                }\n-                (None, false)\n-            },\n-            // Provide substitutions for parameters for which (valid) arguments have been provided.\n-            |param, arg| match (&param.kind, arg) {\n-                (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                    AstConv::ast_region_to_region(self.fcx, lt, Some(param)).into()\n-                }\n-                (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => self.to_ty(ty).into(),\n-                (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                    self.const_arg_to_const(&ct.value, param.def_id).into()\n-                }\n-                _ => unreachable!(),\n-            },\n-            // Provide substitutions for parameters for which arguments are inferred.\n-            |_, param, _| self.var_for_def(self.span, param),\n+            &mut MethodSubstsCtxt { cfcx: self, pick, seg },\n         )\n     }\n "}, {"sha": "84efae694db6f1595f468e67042903fc297232c6", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -25,7 +25,6 @@ use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{\n     self, ParamEnvAnd, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n-use rustc_session::config::nightly_options;\n use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n@@ -1272,7 +1271,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     self.tcx.def_path_str(stable_pick.item.def_id),\n                 ));\n \n-                if nightly_options::is_nightly_build() {\n+                if self.tcx.sess.is_nightly_build() {\n                     for (candidate, feature) in unstable_candidates {\n                         diag.help(&format!(\n                             \"add `#![feature({})]` to the crate attributes to enable `{}`\","}, {"sha": "7151d3763f01fcb3c0dd7f8572fcf24aa2e49881", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -863,6 +863,30 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n+    /// Retains only the elements specified by the predicate.\n+    ///\n+    /// In other words, remove all pairs `(k, v)` such that `f(&k, &mut v)` returns `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(btree_retain)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x*10)).collect();\n+    /// // Keep only the elements with even-numbered keys.\n+    /// map.retain(|&k, _| k % 2 == 0);\n+    /// assert!(map.into_iter().eq(vec![(0, 0), (2, 20), (4, 40), (6, 60)]));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"btree_retain\", issue = \"79025\")]\n+    pub fn retain<F>(&mut self, mut f: F)\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        self.drain_filter(|k, v| !f(k, v));\n+    }\n+\n     /// Moves all elements from `other` into `Self`, leaving `other` empty.\n     ///\n     /// # Examples"}, {"sha": "11dbb584abdac6de774d6c6b5b99b2bc7bf6bd3e", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -808,6 +808,17 @@ fn test_range_mut() {\n     map.check();\n }\n \n+#[test]\n+fn test_retain() {\n+    let mut map: BTreeMap<i32, i32> = (0..100).map(|x| (x, x * 10)).collect();\n+\n+    map.retain(|&k, _| k % 2 == 0);\n+    assert_eq!(map.len(), 50);\n+    assert_eq!(map[&2], 20);\n+    assert_eq!(map[&4], 40);\n+    assert_eq!(map[&6], 60);\n+}\n+\n mod test_drain_filter {\n     use super::*;\n "}, {"sha": "1a807100653bc1a9270d679dd7107d9d824616de", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -798,6 +798,30 @@ impl<T: Ord> BTreeSet<T> {\n         Recover::take(&mut self.map, value)\n     }\n \n+    /// Retains only the elements specified by the predicate.\n+    ///\n+    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(btree_retain)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let xs = [1, 2, 3, 4, 5, 6];\n+    /// let mut set: BTreeSet<i32> = xs.iter().cloned().collect();\n+    /// // Keep only the even numbers.\n+    /// set.retain(|&k| k % 2 == 0);\n+    /// assert!(set.iter().eq([2, 4, 6].iter()));\n+    /// ```\n+    #[unstable(feature = \"btree_retain\", issue = \"79025\")]\n+    pub fn retain<F>(&mut self, mut f: F)\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        self.drain_filter(|v| !f(v));\n+    }\n+\n     /// Moves all elements from `other` into `Self`, leaving `other` empty.\n     ///\n     /// # Examples"}, {"sha": "ef40a048a382ecccf8911610c8e9e64e13dc9f18", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -324,6 +324,17 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[99, 100], &large), false);\n }\n \n+#[test]\n+fn test_retain() {\n+    let xs = [1, 2, 3, 4, 5, 6];\n+    let mut set: BTreeSet<i32> = xs.iter().cloned().collect();\n+    set.retain(|&k| k % 2 == 0);\n+    assert_eq!(set.len(), 3);\n+    assert!(set.contains(&2));\n+    assert!(set.contains(&4));\n+    assert!(set.contains(&6));\n+}\n+\n #[test]\n fn test_drain_filter() {\n     let mut x: BTreeSet<_> = [1].iter().copied().collect();"}, {"sha": "508d785834fce0b3e5d6ad555b9c29954d6b1ec6", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -19,7 +19,7 @@ use crate::compile;\n use crate::config::TargetSelection;\n use crate::dist;\n use crate::doc;\n-use crate::flags::Subcommand;\n+use crate::flags::{Color, Subcommand};\n use crate::install;\n use crate::native;\n use crate::run;\n@@ -811,6 +811,16 @@ impl<'a> Builder<'a> {\n             cargo.env(\"REAL_LIBRARY_PATH\", e);\n         }\n \n+        match self.build.config.color {\n+            Color::Always => {\n+                cargo.arg(\"--color=always\");\n+            }\n+            Color::Never => {\n+                cargo.arg(\"--color=never\");\n+            }\n+            Color::Auto => {} // nothing to do\n+        }\n+\n         if cmd != \"install\" {\n             cargo.arg(\"--target\").arg(target.rustc_target_arg());\n         } else {"}, {"sha": "f65b2b2c79f750aea3ae4a65214d057beceb9d8f", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -232,6 +232,11 @@ impl Step for CodegenBackend {\n             .arg(builder.src.join(format!(\"compiler/rustc_codegen_{}/Cargo.toml\", backend)));\n         rustc_cargo_env(builder, &mut cargo, target);\n \n+        builder.info(&format!(\n+            \"Checking {} artifacts ({} -> {})\",\n+            backend, &compiler.host.triple, target.triple\n+        ));\n+\n         run_cargo(\n             builder,\n             cargo,"}, {"sha": "94319a6d1e9e2d06680eee52d4fe1cd28dae204f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -13,8 +13,8 @@ use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n use crate::cache::{Interned, INTERNER};\n-use crate::flags::Flags;\n pub use crate::flags::Subcommand;\n+use crate::flags::{Color, Flags};\n use crate::util::exe;\n use build_helper::t;\n use merge::Merge;\n@@ -67,6 +67,7 @@ pub struct Config {\n     pub json_output: bool,\n     pub test_compare_mode: bool,\n     pub llvm_libunwind: Option<LlvmLibunwind>,\n+    pub color: Color,\n \n     pub on_fail: Option<String>,\n     pub stage: u32,\n@@ -577,6 +578,7 @@ impl Config {\n         config.keep_stage = flags.keep_stage;\n         config.keep_stage_std = flags.keep_stage_std;\n         config.bindir = \"bin\".into(); // default\n+        config.color = flags.color;\n         if let Some(value) = flags.deny_warnings {\n             config.deny_warnings = value;\n         }"}, {"sha": "5a8096674c6dae4e8b1d3dbf760b71e6e3fc3660", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -15,6 +15,31 @@ use crate::config::{Config, TargetSelection};\n use crate::setup::Profile;\n use crate::{Build, DocTests};\n \n+pub enum Color {\n+    Always,\n+    Never,\n+    Auto,\n+}\n+\n+impl Default for Color {\n+    fn default() -> Self {\n+        Self::Auto\n+    }\n+}\n+\n+impl std::str::FromStr for Color {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s.to_lowercase().as_str() {\n+            \"always\" => Ok(Self::Always),\n+            \"never\" => Ok(Self::Never),\n+            \"auto\" => Ok(Self::Auto),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n     pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n@@ -34,6 +59,7 @@ pub struct Flags {\n     pub rustc_error_format: Option<String>,\n     pub json_output: bool,\n     pub dry_run: bool,\n+    pub color: Color,\n \n     // This overrides the deny-warnings configuration option,\n     // which passes -Dwarnings to the compiler invocations.\n@@ -184,6 +210,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         );\n         opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n         opts.optflag(\"\", \"json-output\", \"use message-format=json\");\n+        opts.optopt(\"\", \"color\", \"whether to use color in cargo and rustc output\", \"STYLE\");\n         opts.optopt(\n             \"\",\n             \"llvm-skip-rebuild\",\n@@ -644,6 +671,9 @@ Arguments:\n             llvm_skip_rebuild: matches.opt_str(\"llvm-skip-rebuild\").map(|s| s.to_lowercase()).map(\n                 |s| s.parse::<bool>().expect(\"`llvm-skip-rebuild` should be either true or false\"),\n             ),\n+            color: matches\n+                .opt_get_default(\"color\", Color::Auto)\n+                .expect(\"`color` should be `always`, `never`, or `auto`\"),\n         }\n     }\n }"}, {"sha": "a07d6b73f06c1a434ff441312fc93ffa0bea944a", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     def_id: self.cx.next_def_id(param_env_def_id.krate),\n                     stability: None,\n                     deprecation: None,\n-                    inner: ImplItem(Impl {\n+                    kind: ImplItem(Impl {\n                         unsafety: hir::Unsafety::Normal,\n                         generics: new_generics,\n                         provided_trait_methods: Default::default(),"}, {"sha": "f15142f4983d62d8abeea01d87ec830e28c7d379", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     def_id: self.cx.next_def_id(impl_def_id.krate),\n                     stability: None,\n                     deprecation: None,\n-                    inner: ImplItem(Impl {\n+                    kind: ImplItem(Impl {\n                         unsafety: hir::Unsafety::Normal,\n                         generics: (\n                             self.cx.tcx.generics_of(impl_def_id),"}, {"sha": "d6f8870c859f5388cd234b6bcf1cc7bf4e03fb93", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -54,7 +54,7 @@ crate fn try_inline(\n     debug!(\"attrs={:?}\", attrs);\n     let attrs_clone = attrs;\n \n-    let inner = match res {\n+    let kind = match res {\n         Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n             ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n@@ -128,7 +128,7 @@ crate fn try_inline(\n         source: cx.tcx.def_span(did).clean(cx),\n         name: Some(name.clean(cx)),\n         attrs,\n-        inner,\n+        kind,\n         visibility: clean::Public,\n         stability: cx.tcx.lookup_stability(did).cloned(),\n         deprecation: cx.tcx.lookup_deprecation(did).clean(cx),\n@@ -446,7 +446,7 @@ crate fn build_impl(\n     debug!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n \n     ret.push(clean::Item {\n-        inner: clean::ImplItem(clean::Impl {\n+        kind: clean::ImplItem(clean::Impl {\n             unsafety: hir::Unsafety::Normal,\n             generics,\n             provided_trait_methods: provided,\n@@ -498,7 +498,7 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n                         visibility: clean::Public,\n                         stability: None,\n                         deprecation: None,\n-                        inner: clean::ImportItem(clean::Import::new_simple(\n+                        kind: clean::ImportItem(clean::Import::new_simple(\n                             item.ident.to_string(),\n                             clean::ImportSource {\n                                 path: clean::Path {\n@@ -555,7 +555,7 @@ fn build_static(cx: &DocContext<'_>, did: DefId, mutable: bool) -> clean::Static\n     }\n }\n \n-fn build_macro(cx: &DocContext<'_>, did: DefId, name: Symbol) -> clean::ItemEnum {\n+fn build_macro(cx: &DocContext<'_>, did: DefId, name: Symbol) -> clean::ItemKind {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n     match cx.enter_resolver(|r| r.cstore().load_macro_untracked(did, cx.sess())) {\n         LoadedMacro::MacroDef(def, _) => {"}, {"sha": "56ce0bae8bb7b969d956455763b32a1760462311", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -42,7 +42,7 @@ use utils::*;\n pub use utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n \n pub use self::types::FnRetTy::*;\n-pub use self::types::ItemEnum::*;\n+pub use self::types::ItemKind::*;\n pub use self::types::SelfTy::*;\n pub use self::types::Type::*;\n pub use self::types::Visibility::{Inherited, Public};\n@@ -276,7 +276,7 @@ impl Clean<Item> for doctree::Module<'_> {\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            inner: ModuleItem(Module { is_crate: self.is_crate, items }),\n+            kind: ModuleItem(Module { is_crate: self.is_crate, items }),\n         }\n     }\n }\n@@ -916,7 +916,7 @@ impl Clean<Item> for doctree::Function<'_> {\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: did.to_def_id(),\n-            inner: FunctionItem(Function {\n+            kind: FunctionItem(Function {\n                 decl,\n                 generics,\n                 header: hir::FnHeader { constness, ..self.header },\n@@ -1023,7 +1023,7 @@ impl Clean<Item> for doctree::Trait<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: TraitItem(Trait {\n+            kind: TraitItem(Trait {\n                 auto: self.is_auto.clean(cx),\n                 unsafety: self.unsafety,\n                 items: self.items.iter().map(|ti| ti.clean(cx)).collect(),\n@@ -1047,7 +1047,7 @@ impl Clean<Item> for doctree::TraitAlias<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: TraitAliasItem(TraitAlias {\n+            kind: TraitAliasItem(TraitAlias {\n                 generics: self.generics.clean(cx),\n                 bounds: self.bounds.clean(cx),\n             }),\n@@ -1102,7 +1102,7 @@ impl Clean<TypeKind> for hir::def::DefKind {\n impl Clean<Item> for hir::TraitItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n-        let inner = match self.kind {\n+        let kind = match self.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n             }\n@@ -1140,15 +1140,15 @@ impl Clean<Item> for hir::TraitItem<'_> {\n             visibility: Visibility::Inherited,\n             stability: get_stability(cx, local_did.to_def_id()),\n             deprecation: get_deprecation(cx, local_did.to_def_id()),\n-            inner,\n+            kind,\n         }\n     }\n }\n \n impl Clean<Item> for hir::ImplItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n-        let inner = match self.kind {\n+        let kind = match self.kind {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n             }\n@@ -1175,14 +1175,14 @@ impl Clean<Item> for hir::ImplItem<'_> {\n             visibility: self.vis.clean(cx),\n             stability: get_stability(cx, local_did.to_def_id()),\n             deprecation: get_deprecation(cx, local_did.to_def_id()),\n-            inner,\n+            kind,\n         }\n     }\n }\n \n impl Clean<Item> for ty::AssocItem {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let inner = match self.kind {\n+        let kind = match self.kind {\n             ty::AssocKind::Const => {\n                 let ty = cx.tcx.type_of(self.def_id);\n                 let default = if self.defaultness.has_value() {\n@@ -1343,7 +1343,7 @@ impl Clean<Item> for ty::AssocItem {\n             def_id: self.def_id,\n             attrs: inline::load_attrs(cx, self.def_id).clean(cx),\n             source: cx.tcx.def_span(self.def_id).clean(cx),\n-            inner,\n+            kind,\n         }\n     }\n }\n@@ -1784,7 +1784,7 @@ impl Clean<Item> for hir::StructField<'_> {\n             stability: get_stability(cx, local_did.to_def_id()),\n             deprecation: get_deprecation(cx, local_did.to_def_id()),\n             def_id: local_did.to_def_id(),\n-            inner: StructFieldItem(self.ty.clean(cx)),\n+            kind: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n }\n@@ -1799,7 +1799,7 @@ impl Clean<Item> for ty::FieldDef {\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n-            inner: StructFieldItem(cx.tcx.type_of(self.did).clean(cx)),\n+            kind: StructFieldItem(cx.tcx.type_of(self.did).clean(cx)),\n         }\n     }\n }\n@@ -1835,7 +1835,7 @@ impl Clean<Item> for doctree::Struct<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: StructItem(Struct {\n+            kind: StructItem(Struct {\n                 struct_type: self.struct_type,\n                 generics: self.generics.clean(cx),\n                 fields: self.fields.clean(cx),\n@@ -1855,7 +1855,7 @@ impl Clean<Item> for doctree::Union<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: UnionItem(Union {\n+            kind: UnionItem(Union {\n                 struct_type: self.struct_type,\n                 generics: self.generics.clean(cx),\n                 fields: self.fields.clean(cx),\n@@ -1885,7 +1885,7 @@ impl Clean<Item> for doctree::Enum<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: EnumItem(Enum {\n+            kind: EnumItem(Enum {\n                 variants: self.variants.iter().map(|v| v.clean(cx)).collect(),\n                 generics: self.generics.clean(cx),\n                 variants_stripped: false,\n@@ -1904,7 +1904,7 @@ impl Clean<Item> for doctree::Variant<'_> {\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            inner: VariantItem(Variant { kind: self.def.clean(cx) }),\n+            kind: VariantItem(Variant { kind: self.def.clean(cx) }),\n         }\n     }\n }\n@@ -1930,7 +1930,7 @@ impl Clean<Item> for ty::VariantDef {\n                         def_id: field.did,\n                         stability: get_stability(cx, field.did),\n                         deprecation: get_deprecation(cx, field.did),\n-                        inner: StructFieldItem(cx.tcx.type_of(field.did).clean(cx)),\n+                        kind: StructFieldItem(cx.tcx.type_of(field.did).clean(cx)),\n                     })\n                     .collect(),\n             }),\n@@ -1941,7 +1941,7 @@ impl Clean<Item> for ty::VariantDef {\n             source: cx.tcx.def_span(self.def_id).clean(cx),\n             visibility: Inherited,\n             def_id: self.def_id,\n-            inner: VariantItem(Variant { kind }),\n+            kind: VariantItem(Variant { kind }),\n             stability: get_stability(cx, self.def_id),\n             deprecation: get_deprecation(cx, self.def_id),\n         }\n@@ -2057,7 +2057,7 @@ impl Clean<Item> for doctree::Typedef<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n+            kind: TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n         }\n     }\n }\n@@ -2072,7 +2072,7 @@ impl Clean<Item> for doctree::OpaqueTy<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: OpaqueTyItem(OpaqueTy {\n+            kind: OpaqueTyItem(OpaqueTy {\n                 bounds: self.opaque_ty.bounds.clean(cx),\n                 generics: self.opaque_ty.generics.clean(cx),\n             }),\n@@ -2100,7 +2100,7 @@ impl Clean<Item> for doctree::Static<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: StaticItem(Static {\n+            kind: StaticItem(Static {\n                 type_: self.type_.clean(cx),\n                 mutability: self.mutability,\n                 expr: print_const_expr(cx, self.expr),\n@@ -2121,7 +2121,7 @@ impl Clean<Item> for doctree::Constant<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: ConstantItem(Constant {\n+            kind: ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n                 expr: print_const_expr(cx, self.expr),\n                 value: print_evaluated_const(cx, def_id.to_def_id()),\n@@ -2175,7 +2175,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: ImplItem(Impl {\n+            kind: ImplItem(Impl {\n                 unsafety: self.unsafety,\n                 generics: self.generics.clean(cx),\n                 provided_trait_methods: provided.clone(),\n@@ -2231,7 +2231,7 @@ impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,\n-            inner: ExternCrateItem(self.name.clean(cx), self.path.clone()),\n+            kind: ExternCrateItem(self.name.clean(cx), self.path.clone()),\n         }]\n     }\n }\n@@ -2302,7 +2302,7 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n                         visibility: self.vis.clean(cx),\n                         stability: None,\n                         deprecation: None,\n-                        inner: ImportItem(Import::new_simple(\n+                        kind: ImportItem(Import::new_simple(\n                             self.name.clean(cx),\n                             resolve_use_source(cx, path),\n                             false,\n@@ -2322,14 +2322,14 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,\n-            inner: ImportItem(inner),\n+            kind: ImportItem(inner),\n         }]\n     }\n }\n \n impl Clean<Item> for doctree::ForeignItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let inner = match self.kind {\n+        let kind = match self.kind {\n             hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n                 let abi = cx.tcx.hir().get_foreign_abi(self.id);\n                 let (generics, decl) =\n@@ -2364,7 +2364,7 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner,\n+            kind,\n         }\n     }\n }\n@@ -2380,7 +2380,7 @@ impl Clean<Item> for doctree::Macro<'_> {\n             stability: cx.stability(self.hid),\n             deprecation: cx.deprecation(self.hid).clean(cx),\n             def_id: self.def_id,\n-            inner: MacroItem(Macro {\n+            kind: MacroItem(Macro {\n                 source: format!(\n                     \"macro_rules! {} {{\\n{}}}\",\n                     name,\n@@ -2405,7 +2405,7 @@ impl Clean<Item> for doctree::ProcMacro<'_> {\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            inner: ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n+            kind: ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n         }\n     }\n }"}, {"sha": "3060cf79cd57ac19ad11a8e21e64fc2d276ca07c", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -41,7 +41,7 @@ use crate::formats::item_type::ItemType;\n use crate::html::render::cache::ExternalLocation;\n \n use self::FnRetTy::*;\n-use self::ItemEnum::*;\n+use self::ItemKind::*;\n use self::SelfTy::*;\n use self::Type::*;\n \n@@ -81,7 +81,7 @@ pub struct Item {\n     /// Not everything has a name. E.g., impls\n     pub name: Option<String>,\n     pub attrs: Attributes,\n-    pub inner: ItemEnum,\n+    pub kind: ItemKind,\n     pub visibility: Visibility,\n     pub def_id: DefId,\n     pub stability: Option<Stability>,\n@@ -90,14 +90,13 @@ pub struct Item {\n \n impl fmt::Debug for Item {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let fake = self.is_fake();\n-        let def_id: &dyn fmt::Debug = if fake { &\"**FAKE**\" } else { &self.def_id };\n+        let def_id: &dyn fmt::Debug = if self.is_fake() { &\"**FAKE**\" } else { &self.def_id };\n \n         fmt.debug_struct(\"Item\")\n             .field(\"source\", &self.source)\n             .field(\"name\", &self.name)\n             .field(\"attrs\", &self.attrs)\n-            .field(\"inner\", &self.inner)\n+            .field(\"kind\", &self.kind)\n             .field(\"visibility\", &self.visibility)\n             .field(\"def_id\", def_id)\n             .field(\"stability\", &self.stability)\n@@ -124,7 +123,7 @@ impl Item {\n     }\n \n     pub fn is_crate(&self) -> bool {\n-        match self.inner {\n+        match self.kind {\n             StrippedItem(box ModuleItem(Module { is_crate: true, .. }))\n             | ModuleItem(Module { is_crate: true, .. }) => true,\n             _ => false,\n@@ -176,14 +175,14 @@ impl Item {\n         self.type_() == ItemType::Keyword\n     }\n     pub fn is_stripped(&self) -> bool {\n-        match self.inner {\n+        match self.kind {\n             StrippedItem(..) => true,\n             ImportItem(ref i) => !i.should_be_displayed,\n             _ => false,\n         }\n     }\n     pub fn has_stripped_fields(&self) -> Option<bool> {\n-        match self.inner {\n+        match self.kind {\n             StructItem(ref _struct) => Some(_struct.fields_stripped),\n             UnionItem(ref union) => Some(union.fields_stripped),\n             VariantItem(Variant { kind: VariantKind::Struct(ref vstruct) }) => {\n@@ -227,8 +226,8 @@ impl Item {\n     }\n \n     pub fn is_default(&self) -> bool {\n-        match self.inner {\n-            ItemEnum::MethodItem(ref meth) => {\n+        match self.kind {\n+            ItemKind::MethodItem(ref meth) => {\n                 if let Some(defaultness) = meth.defaultness {\n                     defaultness.has_value() && !defaultness.is_final()\n                 } else {\n@@ -248,7 +247,7 @@ impl Item {\n }\n \n #[derive(Clone, Debug)]\n-pub enum ItemEnum {\n+pub enum ItemKind {\n     ExternCrateItem(String, Option<String>),\n     ImportItem(Import),\n     StructItem(Struct),\n@@ -282,23 +281,23 @@ pub enum ItemEnum {\n     AssocConstItem(Type, Option<String>),\n     AssocTypeItem(Vec<GenericBound>, Option<Type>),\n     /// An item that has been stripped by a rustdoc pass\n-    StrippedItem(Box<ItemEnum>),\n+    StrippedItem(Box<ItemKind>),\n     KeywordItem(String),\n }\n \n-impl ItemEnum {\n+impl ItemKind {\n     pub fn is_type_alias(&self) -> bool {\n         match *self {\n-            ItemEnum::TypedefItem(_, _) | ItemEnum::AssocTypeItem(_, _) => true,\n+            ItemKind::TypedefItem(_, _) | ItemKind::AssocTypeItem(_, _) => true,\n             _ => false,\n         }\n     }\n \n     pub fn as_assoc_kind(&self) -> Option<AssocKind> {\n         match *self {\n-            ItemEnum::AssocConstItem(..) => Some(AssocKind::Const),\n-            ItemEnum::AssocTypeItem(..) => Some(AssocKind::Type),\n-            ItemEnum::TyMethodItem(..) | ItemEnum::MethodItem(..) => Some(AssocKind::Fn),\n+            ItemKind::AssocConstItem(..) => Some(AssocKind::Const),\n+            ItemKind::AssocTypeItem(..) => Some(AssocKind::Type),\n+            ItemKind::TyMethodItem(..) | ItemKind::MethodItem(..) => Some(AssocKind::Fn),\n             _ => None,\n         }\n     }\n@@ -681,7 +680,9 @@ impl Attributes {\n                                 }\n                                 Some(&(_, _, ExternalLocation::Remote(ref s))) => s.to_string(),\n                                 Some(&(_, _, ExternalLocation::Unknown)) | None => String::from(\n-                                    if UnstableFeatures::from_environment().is_nightly_build() {\n+                                    // NOTE: intentionally doesn't pass crate name to avoid having\n+                                    // different primitive links between crates\n+                                    if UnstableFeatures::from_environment(None).is_nightly_build() {\n                                         \"https://doc.rust-lang.org/nightly\"\n                                     } else {\n                                         \"https://doc.rust-lang.org\""}, {"sha": "e5fb656cbb9167087194ecd9977b590299dd8c3b", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -2,7 +2,7 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::{\n     inline, Clean, Crate, Deprecation, ExternalCrate, FnDecl, FnRetTy, Generic, GenericArg,\n-    GenericArgs, GenericBound, Generics, GetDefId, ImportSource, Item, ItemEnum, Lifetime,\n+    GenericArgs, GenericBound, Generics, GetDefId, ImportSource, Item, ItemKind, Lifetime,\n     MacroKind, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Span, Type, TypeBinding,\n     TypeKind, Visibility, WherePredicate,\n };\n@@ -44,8 +44,8 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n     let mut module = module.clean(cx);\n     let mut masked_crates = FxHashSet::default();\n \n-    match module.inner {\n-        ItemEnum::ModuleItem(ref module) => {\n+    match module.kind {\n+        ItemKind::ModuleItem(ref module) => {\n             for it in &module.items {\n                 // `compiler_builtins` should be masked too, but we can't apply\n                 // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n@@ -62,8 +62,8 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n \n     let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n     {\n-        let m = match module.inner {\n-            ItemEnum::ModuleItem(ref mut m) => m,\n+        let m = match module.kind {\n+            ItemKind::ModuleItem(ref mut m) => m,\n             _ => unreachable!(),\n         };\n         m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| Item {\n@@ -74,7 +74,7 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n             stability: get_stability(cx, def_id),\n             deprecation: get_deprecation(cx, def_id),\n             def_id,\n-            inner: ItemEnum::PrimitiveItem(prim),\n+            kind: ItemKind::PrimitiveItem(prim),\n         }));\n         m.items.extend(keywords.into_iter().map(|(def_id, kw, attrs)| Item {\n             source: Span::empty(),\n@@ -84,7 +84,7 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n             stability: get_stability(cx, def_id),\n             deprecation: get_deprecation(cx, def_id),\n             def_id,\n-            inner: ItemEnum::KeywordItem(kw),\n+            kind: ItemKind::KeywordItem(kw),\n         }));\n     }\n \n@@ -355,8 +355,8 @@ pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut V\n     let tcx = cx.tcx;\n \n     for item in items {\n-        let target = match item.inner {\n-            ItemEnum::TypedefItem(ref t, true) => &t.type_,\n+        let target = match item.kind {\n+            ItemKind::TypedefItem(ref t, true) => &t.type_,\n             _ => continue,\n         };\n         let primitive = match *target {"}, {"sha": "f0fc0dc6514c00df74f04402a354417540e10fce", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -257,6 +257,7 @@ pub struct RenderOptions {\n     pub document_private: bool,\n     /// Document items that have `doc(hidden)`.\n     pub document_hidden: bool,\n+    pub unstable_features: rustc_feature::UnstableFeatures,\n }\n \n /// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n@@ -299,7 +300,7 @@ impl Options {\n                 println_condition(p.condition);\n             }\n \n-            if nightly_options::is_nightly_build() {\n+            if nightly_options::match_is_nightly_build(matches) {\n                 println!(\"\\nPasses run with `--show-coverage`:\");\n                 for p in passes::COVERAGE_PASSES {\n                     print!(\"{:>20}\", p.pass.name);\n@@ -483,6 +484,7 @@ impl Options {\n             &matches.opt_strs(\"html-after-content\"),\n             &matches.opt_strs(\"markdown-before-content\"),\n             &matches.opt_strs(\"markdown-after-content\"),\n+            nightly_options::match_is_nightly_build(&matches),\n             &diag,\n             &mut id_map,\n             edition,\n@@ -539,7 +541,9 @@ impl Options {\n         let output_format = match matches.opt_str(\"output-format\") {\n             Some(s) => match OutputFormat::try_from(s.as_str()) {\n                 Ok(o) => {\n-                    if o.is_json() && !(show_coverage || nightly_options::is_nightly_build()) {\n+                    if o.is_json()\n+                        && !(show_coverage || nightly_options::match_is_nightly_build(matches))\n+                    {\n                         diag.struct_err(\"json output format isn't supported for doc generation\")\n                             .emit();\n                         return Err(1);\n@@ -591,7 +595,6 @@ impl Options {\n \n         Ok(Options {\n             input,\n-            crate_name,\n             proc_macro_crate,\n             error_format,\n             libs,\n@@ -643,7 +646,11 @@ impl Options {\n                 generate_search_filter,\n                 document_private,\n                 document_hidden,\n+                unstable_features: rustc_feature::UnstableFeatures::from_environment(\n+                    crate_name.as_deref(),\n+                ),\n             },\n+            crate_name,\n             output_format,\n         })\n     }\n@@ -661,7 +668,8 @@ fn check_deprecated_options(matches: &getopts::Matches, diag: &rustc_errors::Han\n     for flag in deprecated_flags.iter() {\n         if matches.opt_present(flag) {\n             if *flag == \"output-format\"\n-                && (matches.opt_present(\"show-coverage\") || nightly_options::is_nightly_build())\n+                && (matches.opt_present(\"show-coverage\")\n+                    || nightly_options::match_is_nightly_build(matches))\n             {\n                 continue;\n             }"}, {"sha": "14a2def138310af0d4c1043c377af28a68b21feb", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -371,7 +371,7 @@ pub fn run_core(\n         cg: codegen_options,\n         externs,\n         target_triple: target,\n-        unstable_features: UnstableFeatures::from_environment(),\n+        unstable_features: UnstableFeatures::from_environment(crate_name.as_deref()),\n         actually_rustdoc: true,\n         debugging_opts,\n         error_format,"}, {"sha": "5e40e6b151d30bb2bc1bb8caab8dc537c1592c92", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1,7 +1,6 @@\n use rustc_ast as ast;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorReported;\n-use rustc_feature::UnstableFeatures;\n use rustc_hir as hir;\n use rustc_hir::intravisit;\n use rustc_hir::{HirId, CRATE_HIR_ID};\n@@ -70,7 +69,7 @@ pub fn run(options: Options) -> Result<(), ErrorReported> {\n         lint_cap: Some(options.lint_cap.clone().unwrap_or_else(|| lint::Forbid)),\n         cg: options.codegen_options.clone(),\n         externs: options.externs.clone(),\n-        unstable_features: UnstableFeatures::from_environment(),\n+        unstable_features: options.render_options.unstable_features,\n         actually_rustdoc: true,\n         debugging_opts: config::DebuggingOptions { ..config::basic_debugging_options() },\n         edition: options.edition,"}, {"sha": "900821dbf4a6bb7d33de32a06b105aa29109897a", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1,6 +1,5 @@\n use crate::html::markdown::{ErrorCodes, IdMap, Markdown, Playground};\n use crate::rustc_span::edition::Edition;\n-use rustc_feature::UnstableFeatures;\n use std::fs;\n use std::path::Path;\n use std::str;\n@@ -25,12 +24,13 @@ impl ExternalHtml {\n         after_content: &[String],\n         md_before_content: &[String],\n         md_after_content: &[String],\n+        nightly_build: bool,\n         diag: &rustc_errors::Handler,\n         id_map: &mut IdMap,\n         edition: Edition,\n         playground: &Option<Playground>,\n     ) -> Option<ExternalHtml> {\n-        let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n+        let codes = ErrorCodes::from(nightly_build);\n         let ih = load_external_files(in_header, diag)?;\n         let bc = load_external_files(before_content, diag)?;\n         let m_bc = load_external_files(md_before_content, diag)?;"}, {"sha": "694051aa54f4d416bd0504d38257d5b24110f209", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -5,9 +5,9 @@ pub struct StripItem(pub Item);\n impl StripItem {\n     pub fn strip(self) -> Option<Item> {\n         match self.0 {\n-            Item { inner: StrippedItem(..), .. } => Some(self.0),\n+            Item { kind: StrippedItem(..), .. } => Some(self.0),\n             mut i => {\n-                i.inner = StrippedItem(box i.inner);\n+                i.kind = StrippedItem(box i.kind);\n                 Some(i)\n             }\n         }\n@@ -20,8 +20,8 @@ pub trait DocFolder: Sized {\n     }\n \n     /// don't override!\n-    fn fold_inner_recur(&mut self, inner: ItemEnum) -> ItemEnum {\n-        match inner {\n+    fn fold_inner_recur(&mut self, kind: ItemKind) -> ItemKind {\n+        match kind {\n             StrippedItem(..) => unreachable!(),\n             ModuleItem(i) => ModuleItem(self.fold_mod(i)),\n             StructItem(mut i) => {\n@@ -72,14 +72,14 @@ pub trait DocFolder: Sized {\n \n     /// don't override!\n     fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n+        let Item { attrs, name, source, visibility, def_id, kind, stability, deprecation } = item;\n \n-        let inner = match inner {\n+        let kind = match kind {\n             StrippedItem(box i) => StrippedItem(box self.fold_inner_recur(i)),\n-            _ => self.fold_inner_recur(inner),\n+            _ => self.fold_inner_recur(kind),\n         };\n \n-        Some(Item { attrs, name, source, inner, visibility, stability, deprecation, def_id })\n+        Some(Item { attrs, name, source, kind, visibility, stability, deprecation, def_id })\n     }\n \n     fn fold_mod(&mut self, m: Module) -> Module {"}, {"sha": "277571b11f51b0de385beb0d4706207a9079d255", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -218,7 +218,7 @@ impl DocFolder for Cache {\n \n         // If this is a stripped module,\n         // we don't want it or its children in the search index.\n-        let orig_stripped_mod = match item.inner {\n+        let orig_stripped_mod = match item.kind {\n             clean::StrippedItem(box clean::ModuleItem(..)) => {\n                 mem::replace(&mut self.stripped_mod, true)\n             }\n@@ -227,7 +227,7 @@ impl DocFolder for Cache {\n \n         // If the impl is from a masked crate or references something from a\n         // masked crate then remove it completely.\n-        if let clean::ImplItem(ref i) = item.inner {\n+        if let clean::ImplItem(ref i) = item.kind {\n             if self.masked_crates.contains(&item.def_id.krate)\n                 || i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n                 || i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n@@ -238,12 +238,12 @@ impl DocFolder for Cache {\n \n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n-        if let clean::TraitItem(ref t) = item.inner {\n+        if let clean::TraitItem(ref t) = item.kind {\n             self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n         }\n \n         // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = item.inner {\n+        if let clean::ImplItem(ref i) = item.kind {\n             if let Some(did) = i.trait_.def_id() {\n                 if i.blanket_impl.is_none() {\n                     self.implementors\n@@ -256,7 +256,7 @@ impl DocFolder for Cache {\n \n         // Index this method for searching later on.\n         if let Some(ref s) = item.name {\n-            let (parent, is_inherent_impl_item) = match item.inner {\n+            let (parent, is_inherent_impl_item) = match item.kind {\n                 clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n                     if self.parent_is_trait_impl =>\n@@ -345,7 +345,7 @@ impl DocFolder for Cache {\n             _ => false,\n         };\n \n-        match item.inner {\n+        match item.kind {\n             clean::StructItem(..)\n             | clean::EnumItem(..)\n             | clean::TypedefItem(..)\n@@ -384,7 +384,7 @@ impl DocFolder for Cache {\n \n         // Maintain the parent stack\n         let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n-        let parent_pushed = match item.inner {\n+        let parent_pushed = match item.kind {\n             clean::TraitItem(..)\n             | clean::EnumItem(..)\n             | clean::ForeignTypeItem\n@@ -422,12 +422,12 @@ impl DocFolder for Cache {\n         // Once we've recursively found all the generics, hoard off all the\n         // implementations elsewhere.\n         let ret = self.fold_item_recur(item).and_then(|item| {\n-            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n+            if let clean::Item { kind: clean::ImplItem(_), .. } = item {\n                 // Figure out the id of this impl. This may map to a\n                 // primitive rather than always to a struct/enum.\n                 // Note: matching twice to restrict the lifetime of the `i` borrow.\n                 let mut dids = FxHashSet::default();\n-                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n+                if let clean::Item { kind: clean::ImplItem(ref i), .. } = item {\n                     match i.for_ {\n                         clean::ResolvedPath { did, .. }\n                         | clean::BorrowedRef {"}, {"sha": "a0f4502f750f1968389c51fac41f0b20881e0cc1", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -60,12 +60,12 @@ impl Serialize for ItemType {\n \n impl<'a> From<&'a clean::Item> for ItemType {\n     fn from(item: &'a clean::Item) -> ItemType {\n-        let inner = match item.inner {\n+        let kind = match item.kind {\n             clean::StrippedItem(box ref item) => item,\n-            ref inner => inner,\n+            ref kind => kind,\n         };\n \n-        match *inner {\n+        match *kind {\n             clean::ModuleItem(..) => ItemType::Module,\n             clean::ExternCrateItem(..) => ItemType::ExternCrate,\n             clean::ImportItem(..) => ItemType::Import,"}, {"sha": "b893d6c64ec9446b95db8aaa9675e77710a4bacd", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -32,7 +32,7 @@ pub struct Impl {\n \n impl Impl {\n     pub fn inner_impl(&self) -> &clean::Impl {\n-        match self.impl_item.inner {\n+        match self.impl_item.kind {\n             clean::ImplItem(ref impl_) => impl_,\n             _ => panic!(\"non-impl item found in impl\"),\n         }"}, {"sha": "273e281925742a43fa6cbc5d30d01f1773de867f", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -86,7 +86,7 @@ pub fn run_format<T: FormatRenderer>(\n             }\n \n             cx.mod_item_in(&item, &name, &cache)?;\n-            let module = match item.inner {\n+            let module = match item.kind {\n                 clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n                 _ => unreachable!(),\n             };"}, {"sha": "0541bf118e14f2876c1a608c3333720c9d60a88d", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -165,7 +165,7 @@ pub fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n }\n \n crate fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n-    let (all_types, ret_types) = match item.inner {\n+    let (all_types, ret_types) = match item.kind {\n         clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n         clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n         clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),"}, {"sha": "eebb07f0476c083fa1f73e083ea08b94fce84979", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -52,7 +52,6 @@ use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::flock;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_feature::UnstableFeatures;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::Mutability;\n@@ -397,6 +396,7 @@ impl FormatRenderer for Context {\n             resource_suffix,\n             static_root_path,\n             generate_search_filter,\n+            unstable_features,\n             ..\n         } = options;\n \n@@ -466,7 +466,7 @@ impl FormatRenderer for Context {\n             static_root_path,\n             fs: DocFS::new(sender),\n             edition,\n-            codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n+            codes: ErrorCodes::from(unstable_features.is_nightly_build()),\n             playground,\n         };\n \n@@ -618,7 +618,7 @@ impl FormatRenderer for Context {\n \n         // Render sidebar-items.js used throughout this module.\n         if !self.render_redirect_pages {\n-            let module = match item.inner {\n+            let module = match item.kind {\n                 clean::StrippedItem(box clean::ModuleItem(ref m)) | clean::ModuleItem(ref m) => m,\n                 _ => unreachable!(),\n             };\n@@ -1717,7 +1717,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache)\n \n     write!(buf, \"</span>\"); // out-of-band\n     write!(buf, \"<span class=\\\"in-band\\\">\");\n-    let name = match item.inner {\n+    let name = match item.kind {\n         clean::ModuleItem(ref m) => {\n             if m.is_crate {\n                 \"Crate \"\n@@ -1766,7 +1766,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache)\n \n     write!(buf, \"</span></h1>\"); // in-band\n \n-    match item.inner {\n+    match item.kind {\n         clean::ModuleItem(ref m) => item_module(buf, cx, item, &m.items),\n         clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n             item_function(buf, cx, item, f)\n@@ -2133,7 +2133,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n             );\n         }\n \n-        match myitem.inner {\n+        match myitem.kind {\n             clean::ExternCrateItem(ref name, ref src) => {\n                 use crate::html::format::anchor;\n \n@@ -2169,7 +2169,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n                     continue;\n                 }\n \n-                let unsafety_flag = match myitem.inner {\n+                let unsafety_flag = match myitem.kind {\n                     clean::FunctionItem(ref func) | clean::ForeignFunctionItem(ref func)\n                         if func.header.unsafety == hir::Unsafety::Unsafe =>\n                     {\n@@ -2582,7 +2582,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n             }\n             for (pos, m) in provided.iter().enumerate() {\n                 render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait);\n-                match m.inner {\n+                match m.kind {\n                     clean::MethodItem(ref inner) if !inner.generics.where_predicates.is_empty() => {\n                         write!(w, \",\\n    {{ ... }}\\n\");\n                     }\n@@ -2958,7 +2958,7 @@ fn render_assoc_item(\n             where_clause = WhereClause { gens: g, indent, end_newline }\n         )\n     }\n-    match item.inner {\n+    match item.kind {\n         clean::StrippedItem(..) => {}\n         clean::TyMethodItem(ref m) => method(w, item, m.header, &m.generics, &m.decl, link, parent),\n         clean::MethodItem(ref m) => method(w, item, m.header, &m.generics, &m.decl, link, parent),\n@@ -2994,7 +2994,7 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n     let mut fields = s\n         .fields\n         .iter()\n-        .filter_map(|f| match f.inner {\n+        .filter_map(|f| match f.kind {\n             clean::StructFieldItem(ref ty) => Some((f, ty)),\n             _ => None,\n         })\n@@ -3044,7 +3044,7 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union,\n     let mut fields = s\n         .fields\n         .iter()\n-        .filter_map(|f| match f.inner {\n+        .filter_map(|f| match f.kind {\n             clean::StructFieldItem(ref ty) => Some((f, ty)),\n             _ => None,\n         })\n@@ -3097,7 +3097,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, ca\n             for v in &e.variants {\n                 write!(w, \"    \");\n                 let name = v.name.as_ref().unwrap();\n-                match v.inner {\n+                match v.kind {\n                     clean::VariantItem(ref var) => match var.kind {\n                         clean::VariantKind::CLike => write!(w, \"{}\", name),\n                         clean::VariantKind::Tuple(ref tys) => {\n@@ -3147,7 +3147,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, ca\n                 id = id,\n                 name = variant.name.as_ref().unwrap()\n             );\n-            if let clean::VariantItem(ref var) = variant.inner {\n+            if let clean::VariantItem(ref var) = variant.kind {\n                 if let clean::VariantKind::Tuple(ref tys) = var.kind {\n                     write!(w, \"(\");\n                     for (i, ty) in tys.iter().enumerate() {\n@@ -3164,8 +3164,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, ca\n             document_non_exhaustive(w, variant);\n \n             use crate::clean::{Variant, VariantKind};\n-            if let clean::VariantItem(Variant { kind: VariantKind::Struct(ref s) }) = variant.inner\n-            {\n+            if let clean::VariantItem(Variant { kind: VariantKind::Struct(ref s) }) = variant.kind {\n                 let variant_id = cx.derive_id(format!(\n                     \"{}.{}.fields\",\n                     ItemType::Variant,\n@@ -3179,7 +3178,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, ca\n                 );\n                 for field in &s.fields {\n                     use crate::clean::StructFieldItem;\n-                    if let StructFieldItem(ref ty) = field.inner {\n+                    if let StructFieldItem(ref ty) = field.kind {\n                         let id = cx.derive_id(format!(\n                             \"variant.{}.field.{}\",\n                             variant.name.as_ref().unwrap(),\n@@ -3275,7 +3274,7 @@ fn render_struct(\n             let mut has_visible_fields = false;\n             write!(w, \" {{\");\n             for field in fields {\n-                if let clean::StructFieldItem(ref ty) = field.inner {\n+                if let clean::StructFieldItem(ref ty) = field.kind {\n                     write!(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n@@ -3306,7 +3305,7 @@ fn render_struct(\n                 if i > 0 {\n                     write!(w, \", \");\n                 }\n-                match field.inner {\n+                match field.kind {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n                     clean::StructFieldItem(ref ty) => {\n                         write!(w, \"{}{}\", field.visibility.print_with_space(), ty.print())\n@@ -3352,7 +3351,7 @@ fn render_union(\n \n     write!(w, \" {{\\n{}\", tab);\n     for field in fields {\n-        if let clean::StructFieldItem(ref ty) = field.inner {\n+        if let clean::StructFieldItem(ref ty) = field.kind {\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n@@ -3516,7 +3515,7 @@ fn render_deref_methods(\n         .inner_impl()\n         .items\n         .iter()\n-        .find_map(|item| match item.inner {\n+        .find_map(|item| match item.kind {\n             clean::TypedefItem(ref t, true) => Some(match *t {\n                 clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                 _ => (&t.type_, &t.type_),\n@@ -3538,7 +3537,7 @@ fn render_deref_methods(\n }\n \n fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n-    let self_type_opt = match item.inner {\n+    let self_type_opt = match item.kind {\n         clean::MethodItem(ref method) => method.decl.self_type(),\n         clean::TyMethodItem(ref method) => method.decl.self_type(),\n         _ => None,\n@@ -3589,7 +3588,7 @@ fn spotlight_decl(decl: &clean::FnDecl) -> String {\n                     ));\n                     let t_did = impl_.trait_.def_id().unwrap();\n                     for it in &impl_.items {\n-                        if let clean::TypedefItem(ref tydef, _) = it.inner {\n+                        if let clean::TypedefItem(ref tydef, _) = it.kind {\n                             out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n                             assoc_type(\n                                 &mut out,\n@@ -3657,7 +3656,7 @@ fn render_impl(\n             fmt_impl_for_trait_page(&i.inner_impl(), w, use_absolute);\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n-                    if let clean::TypedefItem(ref tydef, _) = it.inner {\n+                    if let clean::TypedefItem(ref tydef, _) = it.kind {\n                         write!(w, \"<span class=\\\"where fmt-newline\\\">  \");\n                         assoc_type(w, it, &[], Some(&tydef.type_), AssocItemLink::Anchor(None), \"\");\n                         write!(w, \";</span>\");\n@@ -3728,14 +3727,14 @@ fn render_impl(\n         };\n \n         let (is_hidden, extra_class) =\n-            if (trait_.is_none() || item.doc_value().is_some() || item.inner.is_type_alias())\n+            if (trait_.is_none() || item.doc_value().is_some() || item.kind.is_type_alias())\n                 && !is_default_item\n             {\n                 (false, \"\")\n             } else {\n                 (true, \" hidden\")\n             };\n-        match item.inner {\n+        match item.kind {\n             clean::MethodItem(clean::Method { .. })\n             | clean::TyMethodItem(clean::TyMethod { .. }) => {\n                 // Only render when the method is not static or we allow static methods\n@@ -4000,7 +3999,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer, cache: &Ca\n         write!(\n             buffer,\n             \"<p class=\\\"location\\\">{}{}</p>\",\n-            match it.inner {\n+            match it.kind {\n                 clean::StructItem(..) => \"Struct \",\n                 clean::TraitItem(..) => \"Trait \",\n                 clean::PrimitiveItem(..) => \"Primitive Type \",\n@@ -4040,7 +4039,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer, cache: &Ca\n             it.name.as_ref().expect(\"crates always have a name\")\n         );\n     }\n-    match it.inner {\n+    match it.kind {\n         clean::StructItem(ref s) => sidebar_struct(buffer, it, s),\n         clean::TraitItem(ref t) => sidebar_trait(buffer, it, t),\n         clean::PrimitiveItem(_) => sidebar_primitive(buffer, it),\n@@ -4180,7 +4179,7 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                 .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n             {\n                 if let Some((target, real_target)) =\n-                    impl_.inner_impl().items.iter().find_map(|item| match item.inner {\n+                    impl_.inner_impl().items.iter().find_map(|item| match item.kind {\n                         clean::TypedefItem(ref t, true) => Some(match *t {\n                             clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                             _ => (&t.type_, &t.type_),\n@@ -4319,8 +4318,8 @@ fn get_id_for_impl_on_foreign_type(for_: &clean::Type, trait_: &clean::Type) ->\n }\n \n fn extract_for_impl_name(item: &clean::Item) -> Option<(String, String)> {\n-    match item.inner {\n-        clean::ItemEnum::ImplItem(ref i) => {\n+    match item.kind {\n+        clean::ItemKind::ImplItem(ref i) => {\n             if let Some(ref trait_) = i.trait_ {\n                 Some((\n                     format!(\"{:#}\", i.for_.print()),\n@@ -4470,7 +4469,7 @@ fn sidebar_typedef(buf: &mut Buffer, it: &clean::Item) {\n fn get_struct_fields_name(fields: &[clean::Item]) -> String {\n     let mut fields = fields\n         .iter()\n-        .filter(|f| if let clean::StructFieldItem(..) = f.inner { true } else { false })\n+        .filter(|f| if let clean::StructFieldItem(..) = f.kind { true } else { false })\n         .filter_map(|f| match f.name {\n             Some(ref name) => {\n                 Some(format!(\"<a href=\\\"#structfield.{name}\\\">{name}</a>\", name = name))"}, {"sha": "33bd57223b8e944a311c0da27757ddce7f6d061c", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -2,7 +2,6 @@ use std::fs::{create_dir_all, read_to_string, File};\n use std::io::prelude::*;\n use std::path::Path;\n \n-use rustc_feature::UnstableFeatures;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::DUMMY_SP;\n \n@@ -66,7 +65,7 @@ pub fn render<P: AsRef<Path>>(\n     let title = metadata[0];\n \n     let mut ids = IdMap::new();\n-    let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n+    let error_codes = ErrorCodes::from(options.unstable_features.is_nightly_build());\n     let text = if !options.markdown_no_toc {\n         MarkdownWithToc(text, &mut ids, error_codes, edition, &playground).into_string()\n     } else {\n@@ -131,7 +130,7 @@ pub fn test(mut options: Options) -> Result<(), String> {\n         options.enable_per_target_ignores,\n     );\n     collector.set_position(DUMMY_SP);\n-    let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n+    let codes = ErrorCodes::from(options.render_options.unstable_features.is_nightly_build());\n \n     find_testable_code(&input_str, &mut collector, codes, options.enable_per_target_ignores, None);\n "}, {"sha": "ef68bae10782db3632dc7f191fd5b9d55979a657", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'b> CoverageCalculator<'a, 'b> {\n \n impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n     fn fold_item(&mut self, i: clean::Item) -> Option<clean::Item> {\n-        match i.inner {\n+        match i.kind {\n             _ if !i.def_id.is_local() => {\n                 // non-local items are skipped because they can be out of the users control,\n                 // especially in the case of trait impls, which rustdoc eagerly inlines"}, {"sha": "fd0dd339abdc22be4fef80cdb5104cef4c776e89", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -671,7 +671,7 @@ fn resolve_associated_trait_item(\n     let implicit_impls = crate::clean::get_auto_trait_and_blanket_impls(cx, ty, did);\n     let mut candidates: Vec<_> = implicit_impls\n         .flat_map(|impl_outer| {\n-            match impl_outer.inner {\n+            match impl_outer.kind {\n                 clean::ImplItem(impl_) => {\n                     debug!(\"considering auto or blanket impl for trait {:?}\", impl_.trait_);\n                     // Give precedence to methods that were overridden\n@@ -681,14 +681,14 @@ fn resolve_associated_trait_item(\n                                 return None;\n                             }\n                             let kind = assoc\n-                                .inner\n+                                .kind\n                                 .as_assoc_kind()\n                                 .expect(\"inner items for a trait should be associated items\");\n                             if kind.namespace() != ns {\n                                 return None;\n                             }\n \n-                            trace!(\"considering associated item {:?}\", assoc.inner);\n+                            trace!(\"considering associated item {:?}\", assoc.kind);\n                             // We have a slight issue: normal methods come from `clean` types,\n                             // but provided methods come directly from `tcx`.\n                             // Fortunately, we don't need the whole method, we just need to know\n@@ -832,7 +832,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n-        let current_item = match item.inner {\n+        let current_item = match item.kind {\n             clean::ModuleItem(..) => {\n                 if item.attrs.inner_docs {\n                     if item.def_id.is_top_level_module() { item.name.clone() } else { None }"}, {"sha": "81de07302478b0dce045e5d266be9c04d60ed489", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -55,11 +55,11 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in &new_items {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = it.inner {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = it.kind {\n             if cleaner.keep_item(for_) && trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n                 let target = items\n                     .iter()\n-                    .find_map(|item| match item.inner {\n+                    .find_map(|item| match item.kind {\n                         TypedefItem(ref t, true) => Some(&t.type_),\n                         _ => None,\n                     })\n@@ -75,7 +75,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n \n     new_items.retain(|it| {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = it.inner {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = it.kind {\n             cleaner.keep_item(for_)\n                 || trait_.as_ref().map_or(false, |t| cleaner.keep_item(t))\n                 || blanket_impl.is_some()\n@@ -96,7 +96,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n \n     if let Some(ref mut it) = krate.module {\n-        if let ModuleItem(Module { ref mut items, .. }) = it.inner {\n+        if let ModuleItem(Module { ref mut items, .. }) = it.kind {\n             items.extend(synth.impls);\n             items.extend(new_items);\n         } else {"}, {"sha": "094f85f2ccb06630bc7d2cdbf6c16fe90f858403", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -58,7 +58,7 @@ impl crate::doctest::Tester for Tests {\n }\n \n pub fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if matches!(item.inner,\n+    if matches!(item.kind,\n         clean::StructFieldItem(_)\n         | clean::VariantItem(_)\n         | clean::AssocConstItem(_, _)\n@@ -92,9 +92,7 @@ pub fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n \n     find_testable_code(&dox, &mut tests, ErrorCodes::No, false, None);\n \n-    if tests.found_tests == 0\n-        && rustc_feature::UnstableFeatures::from_environment().is_nightly_build()\n-    {\n+    if tests.found_tests == 0 && cx.tcx.sess.is_nightly_build() {\n         if should_have_doc_example(cx, &item) {\n             debug!(\"reporting error for {:?} (hir_id={:?})\", item, hir_id);\n             let sp = span_of_attrs(&item.attrs).unwrap_or(item.source.span());"}, {"sha": "26b64b4905ea77ef320765843bc108979671b12e", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -5,7 +5,6 @@ use crate::fold::DocFolder;\n use crate::html::markdown::opts;\n use core::ops::Range;\n use pulldown_cmark::{Event, Parser};\n-use rustc_feature::UnstableFeatures;\n use rustc_session::lint;\n use std::iter::Peekable;\n use std::str::CharIndices;\n@@ -27,7 +26,7 @@ impl<'a, 'tcx> InvalidHtmlTagsLinter<'a, 'tcx> {\n }\n \n pub fn check_invalid_html_tags(krate: Crate, cx: &DocContext<'_>) -> Crate {\n-    if !UnstableFeatures::from_environment().is_nightly_build() {\n+    if !cx.tcx.sess.is_nightly_build() {\n         krate\n     } else {\n         let mut coll = InvalidHtmlTagsLinter::new(cx);"}, {"sha": "964773dc0554bb198fe1c2469ef604d3f7b530e5", "filename": "src/librustdoc/passes/non_autolinks.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -7,7 +7,6 @@ use core::ops::Range;\n use pulldown_cmark::{Event, LinkType, Parser, Tag};\n use regex::Regex;\n use rustc_errors::Applicability;\n-use rustc_feature::UnstableFeatures;\n use rustc_session::lint;\n \n pub const CHECK_NON_AUTOLINKS: Pass = Pass {\n@@ -54,7 +53,7 @@ impl<'a, 'tcx> NonAutolinksLinter<'a, 'tcx> {\n }\n \n pub fn check_non_autolinks(krate: Crate, cx: &DocContext<'_>) -> Crate {\n-    if !UnstableFeatures::from_environment().is_nightly_build() {\n+    if !cx.tcx.sess.is_nightly_build() {\n         krate\n     } else {\n         let mut coll = NonAutolinksLinter::new(cx);"}, {"sha": "4b9e150eb1e30b43f4a451c485500cc2524d6578", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -41,7 +41,7 @@ impl<'a> DocFolder for Stripper<'a> {\n         if i.attrs.lists(sym::doc).has_word(sym::hidden) {\n             debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n             // use a dedicated hidden item for given item type if any\n-            match i.inner {\n+            match i.kind {\n                 clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n                     // We need to recurse into stripped modules to\n                     // strip things like impl methods but when doing so"}, {"sha": "4250c2b48fc5017c7c88d39a857688d1da0abecb", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -13,7 +13,7 @@ pub struct Stripper<'a> {\n \n impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n+        match i.kind {\n             clean::StrippedItem(..) => {\n                 // We need to recurse into stripped modules to strip things\n                 // like impl methods but when doing so we must not add any\n@@ -86,7 +86,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             clean::KeywordItem(..) => {}\n         }\n \n-        let fastreturn = match i.inner {\n+        let fastreturn = match i.kind {\n             // nothing left to do for traits (don't want to filter their\n             // methods out, visibility controlled by the trait)\n             clean::TraitItem(..) => true,\n@@ -123,7 +123,7 @@ pub struct ImplStripper<'a> {\n \n impl<'a> DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if let clean::ImplItem(ref imp) = i.inner {\n+        if let clean::ImplItem(ref imp) = i.kind {\n             // emptied none trait impls can be stripped\n             if imp.trait_.is_none() && imp.items.is_empty() {\n                 return None;\n@@ -162,7 +162,7 @@ pub struct ImportStripper;\n \n impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n+        match i.kind {\n             clean::ExternCrateItem(..) | clean::ImportItem(..) if i.visibility != clean::Public => {\n                 None\n             }"}, {"sha": "1902ab94d4c0d1ec136f397bbc4f3239ab9f1576", "filename": "src/test/ui/cross/cross-file-errors/main.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fcross%2Fcross-file-errors%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fcross%2Fcross-file-errors%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross%2Fcross-file-errors%2Fmain.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -3,5 +3,6 @@ mod underscore;\n \n fn main() {\n     underscore!();\n-    //~^ ERROR expected expression, found reserved identifier `_`\n+    //~^ ERROR `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR destructuring assignments are unstable\n }"}, {"sha": "b8658745060b014e5ed7ef03d7091a552d3f4689", "filename": "src/test/ui/cross/cross-file-errors/main.stderr", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fcross%2Fcross-file-errors%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fcross%2Fcross-file-errors%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross%2Fcross-file-errors%2Fmain.stderr?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1,15 +1,31 @@\n-error: expected expression, found reserved identifier `_`\n+error[E0658]: destructuring assignments are unstable\n   --> $DIR/underscore.rs:8:9\n    |\n LL |         _\n-   |         ^ expected expression\n+   |         ^\n    | \n   ::: $DIR/main.rs:5:5\n    |\n LL |     underscore!();\n    |     -------------- in this macro invocation\n    |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error\n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n+  --> $DIR/underscore.rs:8:9\n+   |\n+LL |         _\n+   |         ^ `_` not allowed here\n+   | \n+  ::: $DIR/main.rs:5:5\n+   |\n+LL |     underscore!();\n+   |     -------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "0d45ff7da7249d9a698325dc1bbb96a621f7a38c", "filename": "src/test/ui/destructuring-assignment/nested_destructure.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnested_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnested_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnested_destructure.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -14,4 +14,7 @@ fn main() {\n     Struct { a: TupleStruct((a, b), c), b: [d] } =\n         Struct { a: TupleStruct((0, 1), 2), b: [3] };\n     assert_eq!((a, b, c, d), (0, 1, 2, 3));\n+\n+    // unnested underscore: just discard\n+    _ = 1;\n }"}, {"sha": "76cdc1260fcded74a4530ee957ea89e9a1b8c10a", "filename": "src/test/ui/destructuring-assignment/slice_destructure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -9,6 +9,8 @@ fn main() {\n   let mut c;\n   [a, .., b, c] = [1, 2, 3, 4, 5];\n   assert_eq!((a, b, c), (1, 4, 5));\n+  [_, a, _] = [1, 2, 3];\n+  assert_eq!((a, b), (2, 4));\n   [..] = [1, 2, 3];\n   [c, ..] = [5, 6, 6];\n   assert_eq!(c, 5);"}, {"sha": "90d93892f7f2249f75155ca0e2ae1bfdfdd4fdec", "filename": "src/test/ui/destructuring-assignment/slice_destructure_fail.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -4,4 +4,5 @@ fn main() {\n   let (mut a, mut b);\n   [a, .., b, ..] = [0, 1]; //~ ERROR `..` can only be used once per slice pattern\n   [a, a, b] = [1, 2]; //~ ERROR pattern requires 3 elements but array has 2\n+  [_] = [1, 2]; //~ ERROR pattern requires 1 element but array has 2\n }"}, {"sha": "cc412c72df51def9888fbbaee18cfee2b519cb7b", "filename": "src/test/ui/destructuring-assignment/slice_destructure_fail.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.stderr?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -12,6 +12,12 @@ error[E0527]: pattern requires 3 elements but array has 2\n LL |   [a, a, b] = [1, 2];\n    |   ^^^^^^^^^ expected 2 elements\n \n-error: aborting due to 2 previous errors\n+error[E0527]: pattern requires 1 element but array has 2\n+  --> $DIR/slice_destructure_fail.rs:7:3\n+   |\n+LL |   [_] = [1, 2];\n+   |   ^^^ expected 2 elements\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0527`."}, {"sha": "2bcbd9d0d742e5292126e544e0009bcebfae66a8", "filename": "src/test/ui/destructuring-assignment/struct_destructure.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -12,8 +12,10 @@ fn main() {\n     assert_eq!((a, b), (0, 1));\n     Struct { a: b, b: a }  = Struct { a: 1, b: 2 };\n     assert_eq!((a,b), (2, 1));\n+    Struct { a: _, b } = Struct { a: 1, b: 2 };\n+    assert_eq!((a, b), (2, 2));\n     Struct { a, .. } = Struct { a: 1, b: 3 };\n-    assert_eq!((a, b), (1, 1));\n+    assert_eq!((a, b), (1, 2));\n     Struct { .. } = Struct { a: 1, b: 4 };\n-    assert_eq!((a, b), (1, 1));\n+    assert_eq!((a, b), (1, 2));\n }"}, {"sha": "4aa327b61f49709dd05f86fe8f400f90fe4b10a7", "filename": "src/test/ui/destructuring-assignment/struct_destructure_fail.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -9,6 +9,8 @@ fn main() {\n     let mut c;\n     let d = Struct { a: 0, b: 1 };\n     Struct { a, b, c } = Struct { a: 0, b: 1 }; //~ ERROR does not have a field named `c`\n+    Struct { a, _ } = Struct { a: 1, b: 2 }; //~ ERROR pattern does not mention field `b`\n+    //~| ERROR expected identifier, found reserved identifier `_`\n     Struct { a, ..d } = Struct { a: 1, b: 2 };\n     //~^ ERROR functional record updates are not allowed in destructuring assignments\n     Struct { a, .. }; //~ ERROR base expression required after `..`"}, {"sha": "81661a357e75079d46f32a717f1921139275ad48", "filename": "src/test/ui/destructuring-assignment/struct_destructure_fail.stderr", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1,11 +1,19 @@\n+error: expected identifier, found reserved identifier `_`\n+  --> $DIR/struct_destructure_fail.rs:12:17\n+   |\n+LL |     Struct { a, _ } = Struct { a: 1, b: 2 };\n+   |     ------      ^ expected identifier, found reserved identifier\n+   |     |\n+   |     while parsing this struct\n+\n error: functional record updates are not allowed in destructuring assignments\n-  --> $DIR/struct_destructure_fail.rs:12:19\n+  --> $DIR/struct_destructure_fail.rs:14:19\n    |\n LL |     Struct { a, ..d } = Struct { a: 1, b: 2 };\n    |                   ^ help: consider removing the trailing pattern\n \n error: base expression required after `..`\n-  --> $DIR/struct_destructure_fail.rs:14:19\n+  --> $DIR/struct_destructure_fail.rs:16:19\n    |\n LL |     Struct { a, .. };\n    |                   ^ add a base expression here\n@@ -16,6 +24,22 @@ error[E0026]: struct `Struct` does not have a field named `c`\n LL |     Struct { a, b, c } = Struct { a: 0, b: 1 };\n    |                    ^ struct `Struct` does not have this field\n \n-error: aborting due to 3 previous errors\n+error[E0027]: pattern does not mention field `b`\n+  --> $DIR/struct_destructure_fail.rs:12:5\n+   |\n+LL |     Struct { a, _ } = Struct { a: 1, b: 2 };\n+   |     ^^^^^^^^^^^^^^^ missing field `b`\n+   |\n+help: include the missing field in the pattern\n+   |\n+LL |     Struct { a, b, _ } = Struct { a: 1, b: 2 };\n+   |               ^^^\n+help: if you don't care about this missing field, you can explicitly ignore it\n+   |\n+LL |     Struct { a, .., _ } = Struct { a: 1, b: 2 };\n+   |               ^^^^\n+\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0026`.\n+Some errors have detailed explanations: E0026, E0027.\n+For more information about an error, try `rustc --explain E0026`."}, {"sha": "2096182d421cf5232478ef2caff1abd0282d189b", "filename": "src/test/ui/destructuring-assignment/tuple_destructure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -16,6 +16,8 @@ fn main() {\n     assert_eq!((a, b), (2, 2));\n     (b, ..) = (5, 6, 7);\n     assert_eq!(b, 5);\n+    (a, _) = (8, 9);\n+    assert_eq!(a, 8);\n \n     // Test for a non-Copy type (String):\n     let (mut c, mut d);"}, {"sha": "5524e91dc401b6859a190c6f1f334059c2830290", "filename": "src/test/ui/destructuring-assignment/tuple_destructure_fail.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -7,4 +7,5 @@ fn main() {\n     (a, .., b, ..) = (0, 1); //~ ERROR `..` can only be used once per tuple pattern\n     (a, a, b) = (1, 2); //~ ERROR mismatched types\n     (C, ..) = (0,1); //~ ERROR invalid left-hand side of assignment\n+    (_,) = (1, 2); //~ ERROR mismatched types\n }"}, {"sha": "1146b88278d49f87f8825c5c4236788b93f2393f", "filename": "src/test/ui/destructuring-assignment/tuple_destructure_fail.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_destructure_fail.stderr?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -25,7 +25,18 @@ LL |     (C, ..) = (0,1);\n    |      |\n    |      cannot assign to this expression\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/tuple_destructure_fail.rs:10:5\n+   |\n+LL |     (_,) = (1, 2);\n+   |     ^^^^   ------ this expression has type `({integer}, {integer})`\n+   |     |\n+   |     expected a tuple with 2 elements, found one with 1 element\n+   |\n+   = note: expected type `({integer}, {integer})`\n+             found tuple `(_,)`\n+\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0070, E0308.\n For more information about an error, try `rustc --explain E0070`."}, {"sha": "7b5c5ad2bae26b5156609dd44eb5b4da33ea7a35", "filename": "src/test/ui/destructuring-assignment/tuple_struct_destructure.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -23,8 +23,10 @@ fn main() {\n     assert_eq!((a, b), (0, 1));\n     TupleStruct(a, .., b) = TupleStruct(1, 2);\n     assert_eq!((a, b), (1, 2));\n+    TupleStruct(_, a) = TupleStruct(2, 2);\n+    assert_eq!((a, b), (2, 2));\n     TupleStruct(..) = TupleStruct(3, 4);\n-    assert_eq!((a, b), (1, 2));\n+    assert_eq!((a, b), (2, 2));\n     TupleStruct(5,6).assign(&mut a, &mut b);\n     assert_eq!((a, b), (5, 6));\n     Enum::SingleVariant(a, b) = Enum::SingleVariant(7, 8);"}, {"sha": "c39db06117767376a4c782df9786870f4c041c80", "filename": "src/test/ui/destructuring-assignment/tuple_struct_destructure_fail.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -29,8 +29,12 @@ fn main() {\n \n     TupleStruct(a, a, b) = TupleStruct(1, 2);\n     //~^ ERROR this pattern has 3 fields, but the corresponding tuple struct has 2 fields\n+    TupleStruct(_) = TupleStruct(1, 2);\n+    //~^ ERROR this pattern has 1 field, but the corresponding tuple struct has 2 fields\n     Enum::SingleVariant(a, a, b) = Enum::SingleVariant(1, 2);\n     //~^ ERROR this pattern has 3 fields, but the corresponding tuple variant has 2 fields\n+    Enum::SingleVariant(_) = Enum::SingleVariant(1, 2);\n+    //~^ ERROR this pattern has 1 field, but the corresponding tuple variant has 2 fields\n \n     // Check if `test` is recognized as not a tuple struct but a function call:\n     test() = TupleStruct(0, 0);"}, {"sha": "0e7174e5b19d6d4224ef4723f9765e833b8736cc", "filename": "src/test/ui/destructuring-assignment/tuple_struct_destructure_fail.stderr", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -23,40 +23,58 @@ LL | struct TupleStruct<S, T>(S, T);\n LL |     TupleStruct(a, a, b) = TupleStruct(1, 2);\n    |     ^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 3\n \n-error[E0023]: this pattern has 3 fields, but the corresponding tuple variant has 2 fields\n+error[E0023]: this pattern has 1 field, but the corresponding tuple struct has 2 fields\n   --> $DIR/tuple_struct_destructure_fail.rs:32:5\n    |\n+LL | struct TupleStruct<S, T>(S, T);\n+   | ------------------------------- tuple struct defined here\n+...\n+LL |     TupleStruct(_) = TupleStruct(1, 2);\n+   |     ^^^^^^^^^^^^^^ expected 2 fields, found 1\n+\n+error[E0023]: this pattern has 3 fields, but the corresponding tuple variant has 2 fields\n+  --> $DIR/tuple_struct_destructure_fail.rs:34:5\n+   |\n LL |     SingleVariant(S, T)\n    |     ------------------- tuple variant defined here\n ...\n LL |     Enum::SingleVariant(a, a, b) = Enum::SingleVariant(1, 2);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 3\n \n+error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n+  --> $DIR/tuple_struct_destructure_fail.rs:36:5\n+   |\n+LL |     SingleVariant(S, T)\n+   |     ------------------- tuple variant defined here\n+...\n+LL |     Enum::SingleVariant(_) = Enum::SingleVariant(1, 2);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 1\n+\n error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/tuple_struct_destructure_fail.rs:36:12\n+  --> $DIR/tuple_struct_destructure_fail.rs:40:12\n    |\n LL |     test() = TupleStruct(0, 0);\n    |     ------ ^\n    |     |\n    |     cannot assign to this expression\n \n error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/tuple_struct_destructure_fail.rs:38:14\n+  --> $DIR/tuple_struct_destructure_fail.rs:42:14\n    |\n LL |     (test)() = TupleStruct(0, 0);\n    |     -------- ^\n    |     |\n    |     cannot assign to this expression\n \n error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/tuple_struct_destructure_fail.rs:40:38\n+  --> $DIR/tuple_struct_destructure_fail.rs:44:38\n    |\n LL |     <Alias::<isize> as Test>::test() = TupleStruct(0, 0);\n    |     -------------------------------- ^\n    |     |\n    |     cannot assign to this expression\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0023, E0070.\n For more information about an error, try `rustc --explain E0023`."}, {"sha": "4ed4f56702c3208df595eef2c12b541743852698", "filename": "src/test/ui/destructuring-assignment/underscore-range-expr-gating.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -4,5 +4,7 @@ struct S { x : u32 }\n \n #[cfg(FALSE)]\n fn foo() {\n+    _; //~ ERROR destructuring assignments are unstable\n+\n     S { x: 5, .. }; //~ ERROR destructuring assignments are unstable\n }"}, {"sha": "a5ed761a01c33f31df6fa9deae7e4f8654ebb1cc", "filename": "src/test/ui/destructuring-assignment/underscore-range-expr-gating.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.stderr?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1,12 +1,21 @@\n error[E0658]: destructuring assignments are unstable\n-  --> $DIR/underscore-range-expr-gating.rs:7:15\n+  --> $DIR/underscore-range-expr-gating.rs:7:5\n+   |\n+LL |     _;\n+   |     ^\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/underscore-range-expr-gating.rs:9:15\n    |\n LL |     S { x: 5, .. };\n    |               ^^\n    |\n    = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n    = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "00638e04f5db9c38f4af93d80c474d2c9618664e", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-with-underscore-args.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -8,12 +8,18 @@ trait T {\n \n fn main() {\n     let _: usize = foo(_, _);\n-    //~^ ERROR expected expression\n-    //~| ERROR expected expression\n+    //~^ ERROR `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR destructuring assignments are unstable\n+    //~| ERROR destructuring assignments are unstable\n     let _: S = S(_, _);\n-    //~^ ERROR expected expression\n-    //~| ERROR expected expression\n+    //~^ ERROR `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR destructuring assignments are unstable\n+    //~| ERROR destructuring assignments are unstable\n     let _: usize = T::baz(_, _);\n-    //~^ ERROR expected expression\n-    //~| ERROR expected expression\n+    //~^ ERROR `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR `_` can only be used on the left-hand side of an assignment\n+    //~| ERROR destructuring assignments are unstable\n+    //~| ERROR destructuring assignments are unstable\n }"}, {"sha": "248fa6b9c9cb2e7fd0d16998ec5045dde7c70db7", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-with-underscore-args.stderr", "status": "modified", "additions": 72, "deletions": 17, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.stderr?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1,38 +1,93 @@\n-error: expected expression, found reserved identifier `_`\n+error[E0658]: destructuring assignments are unstable\n   --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:10:24\n    |\n LL |     let _: usize = foo(_, _);\n-   |                        ^ expected expression\n+   |                        ^\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:10:27\n+   |\n+LL |     let _: usize = foo(_, _);\n+   |                           ^\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:15:18\n+   |\n+LL |     let _: S = S(_, _);\n+   |                  ^\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:15:21\n+   |\n+LL |     let _: S = S(_, _);\n+   |                     ^\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:20:27\n+   |\n+LL |     let _: usize = T::baz(_, _);\n+   |                           ^\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:20:30\n+   |\n+LL |     let _: usize = T::baz(_, _);\n+   |                              ^\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:10:24\n+   |\n+LL |     let _: usize = foo(_, _);\n+   |                        ^ `_` not allowed here\n \n-error: expected expression, found reserved identifier `_`\n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n   --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:10:27\n    |\n LL |     let _: usize = foo(_, _);\n-   |                           ^ expected expression\n+   |                           ^ `_` not allowed here\n \n-error: expected expression, found reserved identifier `_`\n-  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:13:18\n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:15:18\n    |\n LL |     let _: S = S(_, _);\n-   |                  ^ expected expression\n+   |                  ^ `_` not allowed here\n \n-error: expected expression, found reserved identifier `_`\n-  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:13:21\n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:15:21\n    |\n LL |     let _: S = S(_, _);\n-   |                     ^ expected expression\n+   |                     ^ `_` not allowed here\n \n-error: expected expression, found reserved identifier `_`\n-  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:16:27\n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:20:27\n    |\n LL |     let _: usize = T::baz(_, _);\n-   |                           ^ expected expression\n+   |                           ^ `_` not allowed here\n \n-error: expected expression, found reserved identifier `_`\n-  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:16:30\n+error: in expressions, `_` can only be used on the left-hand side of an assignment\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:20:30\n    |\n LL |     let _: usize = T::baz(_, _);\n-   |                              ^ expected expression\n+   |                              ^ `_` not allowed here\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 12 previous errors\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "1fcd41e4dbfed7a2e27dc3f12b93040c3f698e62", "filename": "src/tools/clippy/clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -170,6 +170,7 @@ impl<'a> Sugg<'a> {\n             | ast::ExprKind::MacCall(..)\n             | ast::ExprKind::MethodCall(..)\n             | ast::ExprKind::Paren(..)\n+            | ast::ExprKind::Underscore\n             | ast::ExprKind::Path(..)\n             | ast::ExprKind::Repeat(..)\n             | ast::ExprKind::Ret(..)"}, {"sha": "293d7d01118c9fb5479649399e1dae60322b8e09", "filename": "src/tools/rustfmt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt?ref=5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "patch": "@@ -1 +1 @@\n-Subproject commit 0f29ff6da0c5ff622e739beb8fc3bbe77119b3c1\n+Subproject commit 293d7d01118c9fb5479649399e1dae60322b8e09"}]}