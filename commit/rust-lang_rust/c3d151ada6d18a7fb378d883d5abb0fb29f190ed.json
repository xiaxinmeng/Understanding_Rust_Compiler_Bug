{"sha": "c3d151ada6d18a7fb378d883d5abb0fb29f190ed", "node_id": "C_kwDOAAsO6NoAKGMzZDE1MWFkYTZkMThhN2ZiMzc4ZDg4M2Q1YWJiMGZiMjlmMTkwZWQ", "commit": {"author": {"name": "C\u00f4me ALLART", "email": "come.allart@etu.emse.fr", "date": "2021-12-10T13:16:07Z"}, "committer": {"name": "C\u00f4me ALLART", "email": "come.allart@etu.emse.fr", "date": "2021-12-10T13:42:31Z"}, "message": "fix: check correctly if function is exported", "tree": {"sha": "f60aaa64a8f6d642720a71804d256cea86c1f829", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f60aaa64a8f6d642720a71804d256cea86c1f829"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3d151ada6d18a7fb378d883d5abb0fb29f190ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3d151ada6d18a7fb378d883d5abb0fb29f190ed", "html_url": "https://github.com/rust-lang/rust/commit/c3d151ada6d18a7fb378d883d5abb0fb29f190ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3d151ada6d18a7fb378d883d5abb0fb29f190ed/comments", "author": null, "committer": null, "parents": [{"sha": "dc4e4c7daab74612cf730028790a8ccd564a0168", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4e4c7daab74612cf730028790a8ccd564a0168", "html_url": "https://github.com/rust-lang/rust/commit/dc4e4c7daab74612cf730028790a8ccd564a0168"}], "stats": {"total": 50, "additions": 30, "deletions": 20}, "files": [{"sha": "f65175dffe015c0ae25d8bfb12d12b20dcf80dc8", "filename": "crates/ide_assists/src/handlers/generate_documentation_template.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c3d151ada6d18a7fb378d883d5abb0fb29f190ed/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d151ada6d18a7fb378d883d5abb0fb29f190ed/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=c3d151ada6d18a7fb378d883d5abb0fb29f190ed", "patch": "@@ -1,8 +1,8 @@\n-use hir::ModuleDef;\n+use hir::{HasVisibility, ModuleDef, Visibility};\n use ide_db::assists::{AssistId, AssistKind};\n use stdx::to_lower_snake_case;\n use syntax::{\n-    ast::{self, edit::IndentLevel, HasDocComments, HasName, HasVisibility},\n+    ast::{self, edit::IndentLevel, HasDocComments, HasName},\n     AstNode,\n };\n \n@@ -43,7 +43,7 @@ pub(crate) fn generate_documentation_template(\n     let name = ctx.find_node_at_offset::<ast::Name>()?;\n     let ast_func = name.syntax().parent().and_then(ast::Fn::cast)?;\n     if is_in_trait_impl(&ast_func)\n-        || !is_public(&ast_func)\n+        || !is_public(&ast_func, ctx)?\n         || ast_func.doc_comments().next().is_some()\n     {\n         return None;\n@@ -187,7 +187,7 @@ struct ExHelper {\n     self_name: Option<String>,\n }\n \n-/// Build the start of the example and transmit the useful intermediary results.\n+/// Builds the start of the example and transmit the useful intermediary results.\n /// `None` if the function has a `self` parameter but is not in an `impl`.\n fn gen_ex_start_helper(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<(Vec<String>, ExHelper)> {\n     let mut lines = Vec::new();\n@@ -209,31 +209,41 @@ fn gen_ex_start_helper(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<(Vec<S\n     Some((lines, ex_helper))\n }\n \n-/// Check if the function and all its parent modules are exactly `pub`\n-fn is_public(ast_func: &ast::Fn) -> bool {\n-    has_pub(ast_func)\n-        && ast_func\n-            .syntax()\n-            .ancestors()\n-            .filter_map(ast::Module::cast)\n-            .all(|module| has_pub(&module))\n+/// Checks if the function is public / exported\n+fn is_public(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<bool> {\n+    let hir_func = ctx.sema.to_def(ast_func)?;\n+    Some(\n+        hir_func.visibility(ctx.db()) == Visibility::Public\n+            && all_parent_mods_public(&hir_func, ctx),\n+    )\n }\n \n-/// Get the name of the current crate\n+/// Checks that all parent modules of the function are public / exported\n+fn all_parent_mods_public(hir_func: &hir::Function, ctx: &AssistContext) -> bool {\n+    let mut module = hir_func.module(ctx.db());\n+    loop {\n+        if let Some(parent) = module.parent(ctx.db()) {\n+            match ModuleDef::from(module).visibility(ctx.db()) {\n+                Visibility::Public => module = parent,\n+                _ => break false,\n+            }\n+        } else {\n+            break true;\n+        }\n+    }\n+}\n+\n+/// Returns the name of the current crate\n fn crate_name(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n     let krate = ctx.sema.scope(&ast_func.syntax()).module()?.krate();\n     Some(krate.display_name(ctx.db())?.to_string())\n }\n \n-/// Check if visibility is exactly `pub` (not `pub(crate)` for instance)\n-fn has_pub<T: HasVisibility>(item: &T) -> bool {\n-    item.visibility().map(|v| v.path().is_none()).unwrap_or(false)\n-}\n-\n /// `None` if function without a body; some bool to guess if function can panic\n fn can_panic(ast_func: &ast::Fn) -> Option<bool> {\n     let body = ast_func.body()?.to_string();\n     let can_panic = body.contains(\"panic!(\")\n+        // FIXME it would be better to not match `debug_assert*!` macro invocations\n         || body.contains(\"assert!(\")\n         || body.contains(\".unwrap()\")\n         || body.contains(\".expect(\");\n@@ -387,8 +397,8 @@ fn build_path(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n     let leaf = self_partial_type(ast_func)\n         .or_else(|| ast_func.name().map(|n| n.to_string()))\n         .unwrap_or_else(|| \"*\".into());\n-    let func_module_def: ModuleDef = ctx.sema.to_def(ast_func)?.module(ctx.db()).into();\n-    match func_module_def.canonical_path(ctx.db()) {\n+    let module_def: ModuleDef = ctx.sema.to_def(ast_func)?.module(ctx.db()).into();\n+    match module_def.canonical_path(ctx.db()) {\n         Some(path) => Some(format!(\"{}::{}::{}\", crate_name, path, leaf)),\n         None => Some(format!(\"{}::{}\", crate_name, leaf)),\n     }"}]}