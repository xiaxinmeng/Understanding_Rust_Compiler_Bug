{"sha": "bb1eedb026931853e2f37e752c45b7f3b59c5fa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMWVlZGIwMjY5MzE4NTNlMmYzN2U3NTJjNDViN2YzYjU5YzVmYTY=", "commit": {"author": {"name": "YI", "email": "uuuuuu@protonmail.com", "date": "2020-04-22T07:33:34Z"}, "committer": {"name": "YI", "email": "uuuuuu@protonmail.com", "date": "2020-04-22T08:05:17Z"}, "message": "add message for resolution failure because wrong namespace", "tree": {"sha": "b10c94f300b6c3a45d965c99ce0680800b8f6696", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b10c94f300b6c3a45d965c99ce0680800b8f6696"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb1eedb026931853e2f37e752c45b7f3b59c5fa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb1eedb026931853e2f37e752c45b7f3b59c5fa6", "html_url": "https://github.com/rust-lang/rust/commit/bb1eedb026931853e2f37e752c45b7f3b59c5fa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb1eedb026931853e2f37e752c45b7f3b59c5fa6/comments", "author": {"login": "contrun", "id": 32609395, "node_id": "MDQ6VXNlcjMyNjA5Mzk1", "avatar_url": "https://avatars.githubusercontent.com/u/32609395?v=4", "gravatar_id": "", "url": "https://api.github.com/users/contrun", "html_url": "https://github.com/contrun", "followers_url": "https://api.github.com/users/contrun/followers", "following_url": "https://api.github.com/users/contrun/following{/other_user}", "gists_url": "https://api.github.com/users/contrun/gists{/gist_id}", "starred_url": "https://api.github.com/users/contrun/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/contrun/subscriptions", "organizations_url": "https://api.github.com/users/contrun/orgs", "repos_url": "https://api.github.com/users/contrun/repos", "events_url": "https://api.github.com/users/contrun/events{/privacy}", "received_events_url": "https://api.github.com/users/contrun/received_events", "type": "User", "site_admin": false}, "committer": {"login": "contrun", "id": 32609395, "node_id": "MDQ6VXNlcjMyNjA5Mzk1", "avatar_url": "https://avatars.githubusercontent.com/u/32609395?v=4", "gravatar_id": "", "url": "https://api.github.com/users/contrun", "html_url": "https://github.com/contrun", "followers_url": "https://api.github.com/users/contrun/followers", "following_url": "https://api.github.com/users/contrun/following{/other_user}", "gists_url": "https://api.github.com/users/contrun/gists{/gist_id}", "starred_url": "https://api.github.com/users/contrun/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/contrun/subscriptions", "organizations_url": "https://api.github.com/users/contrun/orgs", "repos_url": "https://api.github.com/users/contrun/repos", "events_url": "https://api.github.com/users/contrun/events{/privacy}", "received_events_url": "https://api.github.com/users/contrun/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25f070d1edf3d54d8933e00eeac95ce55ca8eabb", "url": "https://api.github.com/repos/rust-lang/rust/commits/25f070d1edf3d54d8933e00eeac95ce55ca8eabb", "html_url": "https://github.com/rust-lang/rust/commit/25f070d1edf3d54d8933e00eeac95ce55ca8eabb"}], "stats": {"total": 140, "additions": 95, "deletions": 45}, "files": [{"sha": "71fb8147793a8f66995bcac2a63abaa9078bfd5e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 80, "deletions": 45, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/bb1eedb026931853e2f37e752c45b7f3b59c5fa6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1eedb026931853e2f37e752c45b7f3b59c5fa6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bb1eedb026931853e2f37e752c45b7f3b59c5fa6", "patch": "@@ -2064,52 +2064,64 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n \n-            let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(\n-                    module,\n-                    ident,\n-                    ns,\n-                    parent_scope,\n-                    record_used,\n-                    path_span,\n-                )\n-            } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n-                let scopes = ScopeSet::All(ns, opt_ns.is_none());\n-                self.early_resolve_ident_in_lexical_scope(\n-                    ident,\n-                    scopes,\n-                    parent_scope,\n-                    record_used,\n-                    record_used,\n-                    path_span,\n-                )\n-            } else {\n-                let record_used_id =\n-                    if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n-                match self.resolve_ident_in_lexical_scope(\n-                    ident,\n-                    ns,\n-                    parent_scope,\n-                    record_used_id,\n-                    path_span,\n-                    &ribs.unwrap()[ns],\n-                ) {\n-                    // we found a locally-imported or available item/module\n-                    Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n-                    // we found a local variable or type param\n-                    Some(LexicalScopeBinding::Res(res))\n-                        if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n-                    {\n-                        record_segment_res(self, res);\n-                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n-                            res,\n-                            path.len() - 1,\n-                        ));\n+            enum FindBindingResult<'a> {\n+                Binding(Result<&'a NameBinding<'a>, Determinacy>),\n+                PathResult(PathResult<'a>),\n+            }\n+            let find_binding_in_ns = |this: &mut Self, ns| {\n+                let binding = if let Some(module) = module {\n+                    this.resolve_ident_in_module(\n+                        module,\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        record_used,\n+                        path_span,\n+                    )\n+                } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n+                    let scopes = ScopeSet::All(ns, opt_ns.is_none());\n+                    this.early_resolve_ident_in_lexical_scope(\n+                        ident,\n+                        scopes,\n+                        parent_scope,\n+                        record_used,\n+                        record_used,\n+                        path_span,\n+                    )\n+                } else {\n+                    let record_used_id = if record_used {\n+                        crate_lint.node_id().or(Some(CRATE_NODE_ID))\n+                    } else {\n+                        None\n+                    };\n+                    match this.resolve_ident_in_lexical_scope(\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        record_used_id,\n+                        path_span,\n+                        &ribs.unwrap()[ns],\n+                    ) {\n+                        // we found a locally-imported or available item/module\n+                        Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n+                        // we found a local variable or type param\n+                        Some(LexicalScopeBinding::Res(res))\n+                            if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n+                        {\n+                            record_segment_res(this, res);\n+                            return FindBindingResult::PathResult(PathResult::NonModule(\n+                                PartialRes::with_unresolved_segments(res, path.len() - 1),\n+                            ));\n+                        }\n+                        _ => Err(Determinacy::determined(record_used)),\n                     }\n-                    _ => Err(Determinacy::determined(record_used)),\n-                }\n+                };\n+                FindBindingResult::Binding(binding)\n+            };\n+            let binding = match find_binding_in_ns(self, ns) {\n+                FindBindingResult::PathResult(x) => return x,\n+                FindBindingResult::Binding(binding) => binding,\n             };\n-\n             match binding {\n                 Ok(binding) => {\n                     if i == 1 {\n@@ -2199,7 +2211,30 @@ impl<'a> Resolver<'a> {\n                     } else if i == 0 {\n                         (format!(\"use of undeclared type or module `{}`\", ident), None)\n                     } else {\n-                        (format!(\"could not find `{}` in `{}`\", ident, path[i - 1].ident), None)\n+                        let mut msg =\n+                            format!(\"could not find `{}` in `{}`\", ident, path[i - 1].ident);\n+                        if ns == TypeNS {\n+                            if let FindBindingResult::Binding(Ok(_)) =\n+                                find_binding_in_ns(self, ValueNS)\n+                            {\n+                                msg = format!(\n+                                    \"`{}` in `{}` is a concrete value, not a module or Struct you specified\",\n+                                    ident,\n+                                    path[i - 1].ident\n+                                );\n+                            };\n+                        } else if ns == ValueNS {\n+                            if let FindBindingResult::Binding(Ok(_)) =\n+                                find_binding_in_ns(self, TypeNS)\n+                            {\n+                                msg = format!(\n+                                    \"`{}` in `{}` is a type, not a concrete value you specified\",\n+                                    ident,\n+                                    path[i - 1].ident\n+                                );\n+                            };\n+                        }\n+                        (msg, None)\n                     };\n                     return PathResult::Failed {\n                         span: ident.span,"}, {"sha": "e3de30f92896efa4a8068c62b23efae5a4dcb0b6", "filename": "src/test/ui/issues/issue-71406.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb1eedb026931853e2f37e752c45b7f3b59c5fa6/src%2Ftest%2Fui%2Fissues%2Fissue-71406.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1eedb026931853e2f37e752c45b7f3b59c5fa6/src%2Ftest%2Fui%2Fissues%2Fissue-71406.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-71406.rs?ref=bb1eedb026931853e2f37e752c45b7f3b59c5fa6", "patch": "@@ -0,0 +1,6 @@\n+use std::sync::mpsc;\n+\n+fn main() {\n+    let (tx, rx) = mpsc::channel::new(1);\n+    //~^ ERROR `channel` in `mpsc` is a concrete value, not a module or Struct you specified\n+}"}, {"sha": "22a2ca4f3e233e997a94c9150dab7395f96945d9", "filename": "src/test/ui/issues/issue-71406.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb1eedb026931853e2f37e752c45b7f3b59c5fa6/src%2Ftest%2Fui%2Fissues%2Fissue-71406.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb1eedb026931853e2f37e752c45b7f3b59c5fa6/src%2Ftest%2Fui%2Fissues%2Fissue-71406.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-71406.stderr?ref=bb1eedb026931853e2f37e752c45b7f3b59c5fa6", "patch": "@@ -0,0 +1,9 @@\n+error[E0433]: failed to resolve: `channel` in `mpsc` is a concrete value, not a module or Struct you specified\n+  --> $DIR/issue-71406.rs:4:26\n+   |\n+LL |     let (tx, rx) = mpsc::channel::new(1);\n+   |                          ^^^^^^^ `channel` in `mpsc` is a concrete value, not a module or Struct you specified\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}]}