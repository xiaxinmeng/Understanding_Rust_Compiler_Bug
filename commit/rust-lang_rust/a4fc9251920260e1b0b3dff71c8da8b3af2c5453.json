{"sha": "a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZmM5MjUxOTIwMjYwZTFiMGIzZGZmNzFjOGRhOGIzYWYyYzU0NTM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-04-15T23:18:09Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-05-06T04:58:26Z"}, "message": "Move logic to `is_representable` instead of climbing HIR", "tree": {"sha": "f77724c757d4c9f61fe0b9a94da1eb501efaffb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f77724c757d4c9f61fe0b9a94da1eb501efaffb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "html_url": "https://github.com/rust-lang/rust/commit/a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7108e18cd4c88b971c6d548387fe2eeb5403c45", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7108e18cd4c88b971c6d548387fe2eeb5403c45", "html_url": "https://github.com/rust-lang/rust/commit/f7108e18cd4c88b971c6d548387fe2eeb5403c45"}], "stats": {"total": 244, "additions": 74, "deletions": 170}, "files": [{"sha": "cb7f530b9952f779011e899b13dbde7fde04b977", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "patch": "@@ -1739,24 +1739,6 @@ impl Item_ {\n             ItemDefaultImpl(..) => \"item\",\n         }\n     }\n-\n-    pub fn fields(&self) -> &[StructField] {\n-        match *self {\n-            ItemStruct(ref vd, _) => {\n-                return vd.fields();\n-            }\n-            ItemEnum(EnumDef { ref variants }, _) => {\n-                for variant in variants {\n-                    let fields = variant.node.data.fields();\n-                    if fields.len() > 0 {\n-                        return fields;\n-                    }\n-                }\n-            }\n-            _ => (),\n-        }\n-        &[]\n-    }\n }\n \n /// A reference from an trait to one of its associated items. This"}, {"sha": "e846d74febfb7af6f7a83fe6710ce9d8abd2f30e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 105, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "patch": "@@ -27,7 +27,7 @@ use errors::DiagnosticBuilder;\n use fmt_macros::{Parser, Piece, Position};\n use hir::{self, intravisit, Local, Pat, Body};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n-use hir::map::{Node, NodeExpr};\n+use hir::map::NodeExpr;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n@@ -778,53 +778,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Get the `DefId` for a given struct or enum `Ty`.\n-fn ty_def_id(ty: &hir::Ty) -> Option<DefId> {\n-    match ty.node {\n-        hir::TyPath(hir::QPath::Resolved(_, ref path)) => {\n-            match path.def {\n-                hir::def::Def::Struct(did) | hir::def::Def::Enum(did) => {\n-                    Some(did)\n-                }\n-                _ => None,\n-            }\n-        },\n-        _ => None,\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Add a span label to `err` pointing at `sp` if the field represented by `node_id` points\n-    /// recursively at the type `ty` without indirection.\n-    fn annotate_recursive_field_ty(&self,\n-                                   node_id: ast::NodeId,\n-                                   ty: &hir::Ty,\n-                                   sp: Span,\n-                                   err: &mut DiagnosticBuilder<'tcx>) -> bool {\n-        if let Some(did) = ty_def_id(ty) {\n-            return self.annotate_recursive_field_id(node_id, did, sp, err);\n-        }\n-        false\n-    }\n-\n-    /// Add a span label to `err` pointing at `sp` if the field represented by `node_id` points\n-    /// recursively at the type represented by `did` without indirection.\n-    fn annotate_recursive_field_id(&self,\n-                                   node_id:\n-                                   ast::NodeId,\n-                                   did: DefId,\n-                                   sp: Span,\n-                                   err: &mut DiagnosticBuilder<'tcx>) -> bool\n-    {\n-        if let Some(Node::NodeItem(item)) = self.hir.get_if_local(did) {\n-            if self.is_node_id_referenced_in_item(item, node_id) {\n-                err.span_label(sp, &\"recursive without indirection\");\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n     pub fn recursive_type_with_infinite_size_error(self,\n                                                    type_def_id: DefId)\n                                                    -> DiagnosticBuilder<'tcx>\n@@ -839,67 +793,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n                            at some point to make `{}` representable\",\n                           self.item_path_str(type_def_id)));\n-\n-        // Look at the type for the the recursive type's fields and label those that are causing it\n-        // to be of infinite size.\n-        if let Some(Node::NodeItem(self_item)) = self.hir.get_if_local(type_def_id) {\n-            for field in self_item.node.fields() {\n-                match field.ty.node {\n-                    hir::TyPath(ref qpath) => {\n-                        // Foo\n-                        if let &hir::QPath::Resolved(_, ref path) = qpath {\n-                            match path.def {\n-                                hir::def::Def::Struct(did) |\n-                                hir::def::Def::Enum(did) => {\n-                                    self.annotate_recursive_field_id(self_item.id,\n-                                                                     did,\n-                                                                     field.span,\n-                                                                     &mut err);\n-                                }\n-                                _ => (),\n-                            }\n-                        }\n-                    }\n-                    hir::TyArray(ref ty, _) => {\n-                        // [Foo]\n-                        self.annotate_recursive_field_ty(self_item.id, &ty, field.span, &mut err);\n-                    }\n-                    hir::TyTup(ref tys) => {\n-                        // (Foo, Bar)\n-                        for ty in tys {\n-                            if self.annotate_recursive_field_ty(self_item.id,\n-                                                                &ty,\n-                                                                field.span,\n-                                                                &mut err) {\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    _ => (),\n-                }\n-            }\n-        }\n         err\n     }\n \n-    /// Given `item`, determine wether the node identified by `node_id` is referenced without any\n-    /// indirection in any of `item`'s fields.\n-    fn is_node_id_referenced_in_item(&self, item: &hir::Item, node_id: ast::NodeId) -> bool {\n-        if item.id == node_id {\n-            return true;\n-        }\n-        for field in item.node.fields() {\n-            if let Some(Node::NodeItem(ref item)) = ty_def_id(&field.ty).and_then(|id| {\n-                self.hir.get_if_local(id)\n-            }) {\n-                if self.is_node_id_referenced_in_item(item, node_id) {\n-                    return true;\n-                }\n-            }\n-        }\n-        false\n-    }\n-\n     pub fn report_object_safety_error(self,\n                                       span: Span,\n                                       trait_def_id: DefId,"}, {"sha": "e3ca52281de62150ca24cd4c8a82b68a586fa5d9", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "patch": "@@ -145,11 +145,11 @@ pub enum CopyImplementationError<'tcx> {\n ///\n /// The ordering of the cases is significant. They are sorted so that cmp::max\n /// will keep the \"more erroneous\" of two values.\n-#[derive(Copy, Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n+#[derive(Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n pub enum Representability {\n     Representable,\n     ContainsRecursive,\n-    SelfRecursive,\n+    SelfRecursive(Vec<Span>),\n }\n \n impl<'tcx> ParameterEnvironment<'tcx> {\n@@ -1003,37 +1003,51 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span)\n+    pub fn is_representable(&'tcx self,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            sp: Span)\n                             -> Representability {\n \n         // Iterate until something non-representable is found\n-        fn find_nonrepresentable<'a, 'tcx, It>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               sp: Span,\n-                                               seen: &mut Vec<Ty<'tcx>>,\n-                                               iter: It)\n-                                               -> Representability\n-        where It: Iterator<Item=Ty<'tcx>> {\n-            iter.fold(Representability::Representable,\n-                      |r, ty| cmp::max(r, is_type_structurally_recursive(tcx, sp, seen, ty)))\n+        fn fold_repr<It: Iterator<Item=Representability>>(iter: It) -> Representability {\n+            iter.fold(Representability::Representable, |r1, r2| {\n+                match (r1, r2) {\n+                    (Representability::SelfRecursive(v1),\n+                     Representability::SelfRecursive(v2)) => {\n+                        Representability::SelfRecursive(v1.iter().map(|s| *s).chain(v2).collect())\n+                    }\n+                    (r1, r2) => cmp::max(r1, r2)\n+                }\n+            })\n         }\n \n         fn are_inner_types_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span,\n                                                seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n                                                -> Representability {\n             match ty.sty {\n                 TyTuple(ref ts, _) => {\n-                    find_nonrepresentable(tcx, sp, seen, ts.iter().cloned())\n+                    // Find non representable\n+                    fold_repr(ts.iter().map(|ty| {\n+                        is_type_structurally_recursive(tcx, sp, seen, ty)\n+                    }))\n                 }\n                 // Fixed-length vectors.\n                 // FIXME(#11924) Behavior undecided for zero-length vectors.\n                 TyArray(ty, _) => {\n                     is_type_structurally_recursive(tcx, sp, seen, ty)\n                 }\n                 TyAdt(def, substs) => {\n-                    find_nonrepresentable(tcx,\n-                                          sp,\n-                                          seen,\n-                                          def.all_fields().map(|f| f.ty(tcx, substs)))\n+                    // Find non representable fields with their spans\n+                    fold_repr(def.all_fields().map(|field| {\n+                        let ty = field.ty(tcx, substs);\n+                        let span = tcx.hir.span_if_local(field.did).unwrap_or(sp);\n+                        match is_type_structurally_recursive(tcx, span, seen, ty) {\n+                            Representability::SelfRecursive(_) => {\n+                                Representability::SelfRecursive(vec![span])\n+                            }\n+                            x => x,\n+                        }\n+                    }))\n                 }\n                 TyClosure(..) => {\n                     // this check is run on type definitions, so we don't expect\n@@ -1072,7 +1086,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                                                     sp: Span,\n                                                     seen: &mut Vec<Ty<'tcx>>,\n                                                     ty: Ty<'tcx>) -> Representability {\n-            debug!(\"is_type_structurally_recursive: {:?}\", ty);\n+            debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n \n             match ty.sty {\n                 TyAdt(def, _) => {\n@@ -1093,7 +1107,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                                 debug!(\"SelfRecursive: {:?} contains {:?}\",\n                                        seen_type,\n                                        ty);\n-                                return Representability::SelfRecursive;\n+                                return Representability::SelfRecursive(vec![sp]);\n                             }\n                         }\n "}, {"sha": "c07bd991b3e7beec7debc5d53448d2f62cad0d07", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "patch": "@@ -1378,8 +1378,12 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // contain themselves. For case 2, there must be an inner type that will be\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n-        Representability::SelfRecursive => {\n-            tcx.recursive_type_with_infinite_size_error(item_def_id).emit();\n+        Representability::SelfRecursive(spans) => {\n+            let mut err = tcx.recursive_type_with_infinite_size_error(item_def_id);\n+            for span in spans {\n+                err.span_label(span, &\"recursive without indirection\");\n+            }\n+            err.emit();\n             return false\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),"}, {"sha": "7ca6d9301a689349dd12362f1cd55184b1385003", "filename": "src/test/compile-fail/issue-3008-1.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs?ref=a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "patch": "@@ -8,9 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum foo { foo_(bar) }\n-enum bar { bar_none, bar_some(bar) }\n-//~^ ERROR recursive type `bar` has infinite size\n+enum Foo {\n+    Foo_(Bar)\n+}\n+\n+enum Bar {\n+    //~^ ERROR recursive type `Bar` has infinite size\n+    //~| NOTE recursive type has infinite size\n+    BarNone,\n+    BarSome(Bar)  //~ NOTE recursive without indirection\n+}\n \n fn main() {\n }"}, {"sha": "10f73dc086288aed40084f0bb3e441dc20a33f60", "filename": "src/test/compile-fail/issue-3779.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs?ref=a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S { //~ ERROR E0072\n-           //~| NOTE recursive type has infinite size\n+struct S {\n+    //~^ ERROR E0072\n+    //~| NOTE recursive type has infinite size\n     element: Option<S>\n+    //~^ NOTE recursive without indirection\n }\n \n fn main() {"}, {"sha": "1f6dd6b1d165f52c9eb3f5e257ccce7dcafd4718", "filename": "src/test/ui/span/E0072.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0072.stderr?ref=a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "patch": "@@ -3,6 +3,9 @@ error[E0072]: recursive type `ListNode` has infinite size\n    |\n 11 | struct ListNode {\n    | ^^^^^^^^^^^^^^^ recursive type has infinite size\n+12 |     head: u8,\n+13 |     tail: Option<ListNode>,\n+   |     ---------------------- recursive without indirection\n    |\n    = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `ListNode` representable\n "}, {"sha": "a06cbd04deb4fb4a32bc030387426608e8a913fd", "filename": "src/test/ui/span/multiline-span-E0072.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr?ref=a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "patch": "@@ -6,6 +6,7 @@ error[E0072]: recursive type `ListNode` has infinite size\n 14 | | {\n 15 | |     head: u8,\n 16 | |     tail: Option<ListNode>,\n+   | |     ---------------------- recursive without indirection\n 17 | | }\n    | |_^ recursive type has infinite size\n    |"}, {"sha": "b4d0b5a6a25d03557028beec40e27409ccb2b19e", "filename": "src/test/ui/span/recursive-type-field.stderr", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4fc9251920260e1b0b3dff71c8da8b3af2c5453/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr?ref=a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "patch": "@@ -1,34 +1,29 @@\n error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/recursive-type-field.rs:13:1\n    |\n-13 |   struct Foo<'a> {\n-   |  _^ starting here...\n-14 | |     bar: Bar<'a>,\n-   | |     ------------ recursive without indirection\n-15 | |     b: Rc<Bar<'a>>,\n-16 | | }\n-   | |_^ ...ending here: recursive type has infinite size\n+13 | struct Foo<'a> {\n+   | ^^^^^^^^^^^^^^ recursive type has infinite size\n+14 |     bar: Bar<'a>,\n+   |     ------------ recursive without indirection\n    |\n    = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n \n error[E0072]: recursive type `Bar` has infinite size\n   --> $DIR/recursive-type-field.rs:18:1\n    |\n-18 |   struct Bar<'a> {\n-   |  _^ starting here...\n-19 | |     y: (Foo<'a>, Foo<'a>),\n-   | |     --------------------- recursive without indirection\n-20 | |     z: Option<Bar<'a>>,\n-21 | |     a: &'a Foo<'a>,\n-22 | |     c: &'a [Bar<'a>],\n-23 | |     d: [Bar<'a>; 1],\n-   | |     --------------- recursive without indirection\n-24 | |     e: Foo<'a>,\n-   | |     ---------- recursive without indirection\n-25 | |     x: Bar<'a>,\n-   | |     ---------- recursive without indirection\n-26 | | }\n-   | |_^ ...ending here: recursive type has infinite size\n+18 | struct Bar<'a> {\n+   | ^^^^^^^^^^^^^^ recursive type has infinite size\n+19 |     y: (Foo<'a>, Foo<'a>),\n+   |     --------------------- recursive without indirection\n+20 |     z: Option<Bar<'a>>,\n+   |     ------------------ recursive without indirection\n+...\n+23 |     d: [Bar<'a>; 1],\n+   |     --------------- recursive without indirection\n+24 |     e: Foo<'a>,\n+   |     ---------- recursive without indirection\n+25 |     x: Bar<'a>,\n+   |     ---------- recursive without indirection\n    |\n    = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Bar` representable\n "}]}