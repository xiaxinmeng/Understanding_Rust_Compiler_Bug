{"sha": "f63c3fba4c14bbf64931791da0222e66133924bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2M2MzZmJhNGMxNGJiZjY0OTMxNzkxZGEwMjIyZTY2MTMzOTI0YmQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T04:53:11Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T15:59:03Z"}, "message": "arena: stop using @[].", "tree": {"sha": "c1264ad0dd9c711720de022d9e72dbc59e9528fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1264ad0dd9c711720de022d9e72dbc59e9528fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f63c3fba4c14bbf64931791da0222e66133924bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f63c3fba4c14bbf64931791da0222e66133924bd", "html_url": "https://github.com/rust-lang/rust/commit/f63c3fba4c14bbf64931791da0222e66133924bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f63c3fba4c14bbf64931791da0222e66133924bd/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "html_url": "https://github.com/rust-lang/rust/commit/2ed980fe253d0b7103ff0b16ce2aeecb03f09203"}], "stats": {"total": 42, "additions": 23, "deletions": 19}, "files": [{"sha": "9bd4c1d58fc6b7d1b7dd66b8a094c43ace5e469e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f63c3fba4c14bbf64931791da0222e66133924bd/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f63c3fba4c14bbf64931791da0222e66133924bd/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=f63c3fba4c14bbf64931791da0222e66133924bd", "patch": "@@ -27,28 +27,38 @@ extern mod extra;\n use extra::list::{List, Cons, Nil};\n use extra::list;\n \n-use std::at_vec;\n use std::cast::{transmute, transmute_mut, transmute_mut_region};\n use std::cast;\n use std::cell::{Cell, RefCell};\n use std::num;\n use std::ptr;\n use std::kinds::marker;\n use std::mem;\n+use std::rc::Rc;\n use std::rt::global_heap;\n use std::unstable::intrinsics::{TyDesc, get_tydesc};\n use std::unstable::intrinsics;\n use std::util;\n+use std::vec;\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n #[deriving(Clone)]\n struct Chunk {\n-    data: RefCell<@[u8]>,\n+    data: Rc<RefCell<~[u8]>>,\n     fill: Cell<uint>,\n     is_pod: Cell<bool>,\n }\n+impl Chunk {\n+    fn capacity(&self) -> uint {\n+        self.data.borrow().borrow().get().capacity()\n+    }\n+\n+    unsafe fn as_ptr(&self) -> *u8 {\n+        self.data.borrow().borrow().get().as_ptr()\n+    }\n+}\n \n // Arenas are used to quickly allocate objects that share a\n // lifetime. The arena uses ~[u8] vectors as a backing store to\n@@ -97,10 +107,8 @@ impl Arena {\n }\n \n fn chunk(size: uint, is_pod: bool) -> Chunk {\n-    let mut v: @[u8] = @[];\n-    unsafe { at_vec::raw::reserve(&mut v, size); }\n     Chunk {\n-        data: RefCell::new(unsafe { cast::transmute(v) }),\n+        data: Rc::new(RefCell::new(vec::with_capacity(size))),\n         fill: Cell::new(0u),\n         is_pod: Cell::new(is_pod),\n     }\n@@ -131,10 +139,7 @@ fn round_up(base: uint, align: uint) -> uint {\n // in it.\n unsafe fn destroy_chunk(chunk: &Chunk) {\n     let mut idx = 0;\n-    let buf = {\n-        let data = chunk.data.borrow();\n-        data.get().as_ptr()\n-    };\n+    let buf = chunk.as_ptr();\n     let fill = chunk.fill.get();\n \n     while idx < fill {\n@@ -172,11 +177,13 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TyDesc, bool) {\n }\n \n impl Arena {\n+    fn chunk_size(&self) -> uint {\n+        self.pod_head.capacity()\n+    }\n     // Functions for the POD part of the arena\n     fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n-        let chunk_size = at_vec::capacity(self.pod_head.data.get());\n-        let new_min_chunk_size = num::max(n_bytes, chunk_size);\n+        let new_min_chunk_size = num::max(n_bytes, self.chunk_size());\n         self.chunks.set(@Cons(self.pod_head.clone(), self.chunks.get()));\n         self.pod_head =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), true);\n@@ -190,15 +197,15 @@ impl Arena {\n             let this = transmute_mut_region(self);\n             let start = round_up(this.pod_head.fill.get(), align);\n             let end = start + n_bytes;\n-            if end > at_vec::capacity(this.pod_head.data.get()) {\n+            if end > self.chunk_size() {\n                 return this.alloc_pod_grow(n_bytes, align);\n             }\n             this.pod_head.fill.set(end);\n \n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill.get());\n \n-            ptr::offset(this.pod_head.data.get().as_ptr(), start as int)\n+            this.pod_head.as_ptr().offset(start as int)\n         }\n     }\n \n@@ -217,8 +224,7 @@ impl Arena {\n     fn alloc_nonpod_grow(&mut self, n_bytes: uint, align: uint)\n                          -> (*u8, *u8) {\n         // Allocate a new chunk.\n-        let chunk_size = at_vec::capacity(self.head.data.get());\n-        let new_min_chunk_size = num::max(n_bytes, chunk_size);\n+        let new_min_chunk_size = num::max(n_bytes, self.chunk_size());\n         self.chunks.set(@Cons(self.head.clone(), self.chunks.get()));\n         self.head =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), false);\n@@ -244,7 +250,7 @@ impl Arena {\n                 end = start + n_bytes;\n             }\n \n-            if end > at_vec::capacity(self.head.data.get()) {\n+            if end > self.head.capacity() {\n                 return self.alloc_nonpod_grow(n_bytes, align);\n             }\n \n@@ -254,7 +260,7 @@ impl Arena {\n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n-            let buf = self.head.data.get().as_ptr();\n+            let buf = self.head.as_ptr();\n             return (ptr::offset(buf, tydesc_start as int), ptr::offset(buf, start as int));\n         }\n     }\n@@ -606,5 +612,3 @@ mod test {\n         })\n     }\n }\n-\n-"}]}