{"sha": "90c02c1bc119890f63dedcb4bee5a278a85ff62f", "node_id": "C_kwDOAAsO6NoAKDkwYzAyYzFiYzExOTg5MGY2M2RlZGNiNGJlZTVhMjc4YTg1ZmY2MmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-08T23:47:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-08T23:47:39Z"}, "message": "Auto merge of #111296 - Sp00ph:const_gcd, r=nagisa,Mark-Simulacrum\n\nAlways const-evaluate the GCD in `slice::align_to_offsets`\n\nUse an inline `const`-block to force the compiler to calculate the GCD at compile time, even in debug mode. This shouldn't affect the behavior of the program at all, but it drastically cuts down on the number of instructions emitted with optimizations disabled.\n\nWith the current implementation, a single `slice::align_to` instantiation (specifically `<[u8]>::align_to::<u128>()`) generates 676 instructions (on x86-64). Forcing the GCD computation to be const cuts it down to 327 instructions, so just over 50% less. This is obviously not representative of actual runtime gains, but I still see it as a significant win as long as it doesn't degrade compile times.\n\nNot having to worry about LLVM const-evaluating the GCD function also allows it to use the textbook recursive euclidean algorithm instead of a much more complicated iterative implementation with multiple `unsafe`-blocks.", "tree": {"sha": "73791a158ba7239fcca776d8ac66ffb7cad71f7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73791a158ba7239fcca776d8ac66ffb7cad71f7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90c02c1bc119890f63dedcb4bee5a278a85ff62f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90c02c1bc119890f63dedcb4bee5a278a85ff62f", "html_url": "https://github.com/rust-lang/rust/commit/90c02c1bc119890f63dedcb4bee5a278a85ff62f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90c02c1bc119890f63dedcb4bee5a278a85ff62f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f2c438dce75d8cc532c3baa849eeddc0901802c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2c438dce75d8cc532c3baa849eeddc0901802c", "html_url": "https://github.com/rust-lang/rust/commit/2f2c438dce75d8cc532c3baa849eeddc0901802c"}, {"sha": "b5ee324d79b310761b98173825895b16b859361b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5ee324d79b310761b98173825895b16b859361b", "html_url": "https://github.com/rust-lang/rust/commit/b5ee324d79b310761b98173825895b16b859361b"}], "stats": {"total": 43, "additions": 6, "deletions": 37}, "files": [{"sha": "c2e9ba273a522c6f73820d511f23446fac492b72", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 37, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/90c02c1bc119890f63dedcb4bee5a278a85ff62f/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c02c1bc119890f63dedcb4bee5a278a85ff62f/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=90c02c1bc119890f63dedcb4bee5a278a85ff62f", "patch": "@@ -3478,44 +3478,13 @@ impl<T> [T] {\n         // Ts = size_of::<U> / gcd(size_of::<T>, size_of::<U>)\n         //\n         // Luckily since all this is constant-evaluated... performance here matters not!\n-        #[inline]\n-        fn gcd(a: usize, b: usize) -> usize {\n-            use crate::intrinsics;\n-            // iterative stein\u2019s algorithm\n-            // We should still make this `const fn` (and revert to recursive algorithm if we do)\n-            // because relying on llvm to consteval all this is\u2026 well, it makes me uncomfortable.\n-\n-            // SAFETY: `a` and `b` are checked to be non-zero values.\n-            let (ctz_a, mut ctz_b) = unsafe {\n-                if a == 0 {\n-                    return b;\n-                }\n-                if b == 0 {\n-                    return a;\n-                }\n-                (intrinsics::cttz_nonzero(a), intrinsics::cttz_nonzero(b))\n-            };\n-            let k = ctz_a.min(ctz_b);\n-            let mut a = a >> ctz_a;\n-            let mut b = b;\n-            loop {\n-                // remove all factors of 2 from b\n-                b >>= ctz_b;\n-                if a > b {\n-                    mem::swap(&mut a, &mut b);\n-                }\n-                b = b - a;\n-                // SAFETY: `b` is checked to be non-zero.\n-                unsafe {\n-                    if b == 0 {\n-                        break;\n-                    }\n-                    ctz_b = intrinsics::cttz_nonzero(b);\n-                }\n-            }\n-            a << k\n+        const fn gcd(a: usize, b: usize) -> usize {\n+            if b == 0 { a } else { gcd(b, a % b) }\n         }\n-        let gcd: usize = gcd(mem::size_of::<T>(), mem::size_of::<U>());\n+\n+        // Explicitly wrap the function call in a const block so it gets\n+        // constant-evaluated even in debug mode.\n+        let gcd: usize = const { gcd(mem::size_of::<T>(), mem::size_of::<U>()) };\n         let ts: usize = mem::size_of::<U>() / gcd;\n         let us: usize = mem::size_of::<T>() / gcd;\n "}]}