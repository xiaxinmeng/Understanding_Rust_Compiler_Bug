{"sha": "848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0OGUwYTIzZjM0YWFhYjNlNGE5NzRiMDMxYzg2ZWYyYTRlNGZjYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-02T12:25:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-02T12:25:00Z"}, "message": "Auto merge of #61922 - tmandry:moar-generator-optimization, r=matthewjasper\n\nDon't store locals that have been moved from in generators\n\nThis avoids reserving storage in generators for locals that are moved\nout of (and not re-initialized) prior to yield points. Fixes #59123.\n\nThis adds a new dataflow analysis, `RequiresStorage`, to determine whether the storage of a local can be destroyed without being observed by the program. The rules are:\n\n1. StorageLive(x) => mark x live\n2. StorageDead(x) => mark x dead\n3. If a local is moved from, _and has never had its address taken_, mark it dead\n4. If (any part of) a local is initialized, mark it live'\n\nThis is used to determine whether to save a local in the generator object at all, as well as which locals can be overlapped in the generator layout.\n\nHere's the size in bytes of all testcases included in the change, before and after the change:\n\nasync fn test    |Size before |Size after\n-----------------|------------|----------\nsingle           | 1028       | 1028\nsingle_with_noop | 2056       | 1032\njoined           | 5132       | 3084\njoined_with_noop | 8208       | 3084\n\ngenerator test              |Size before |Size after\n----------------------------|------------|----------\nmove_before_yield           | 1028       | 1028\nmove_before_yield_with_noop | 2056       | 1032\noverlap_move_points         | 3080       | 2056\n\n## Future work\n\nNote that there is a possible extension to this optimization, which modifies rule 3 to read: \"If a local is moved from, _**and either has never had its address taken, or is Freeze and has never been mutably borrowed**_, mark it dead.\" This was discussed at length in #59123 and then #61849. Because this would cause some behavior to be UB which was not UB before, it's a step that needs to be taken carefully.\n\nA more immediate priority for me is inlining `std::mem::size_of_val(&x)` so it becomes apparent that the address of `x` is not taken. This way, using `size_of_val` to look at the size of your inner futures does not affect the size of your outer future.\n\ncc @cramertj @eddyb @Matthias247 @nikomatsakis @RalfJung @Zoxc", "tree": {"sha": "028f767264e3d179b75d747d57662b93c72fa06b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/028f767264e3d179b75d747d57662b93c72fa06b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "html_url": "https://github.com/rust-lang/rust/commit/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "html_url": "https://github.com/rust-lang/rust/commit/ef064d2f66bf5851e1da1a016627ff1395f6c9ad"}, {"sha": "a68e2c716113d4f7a10a149cc13b18b851853000", "url": "https://api.github.com/repos/rust-lang/rust/commits/a68e2c716113d4f7a10a149cc13b18b851853000", "html_url": "https://github.com/rust-lang/rust/commit/a68e2c716113d4f7a10a149cc13b18b851853000"}], "stats": {"total": 487, "additions": 444, "deletions": 43}, "files": [{"sha": "f0014602e2d6b161089727ccbcf901fcf80c8362", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "patch": "@@ -8,6 +8,7 @@ use crate::dataflow::{BitDenotation, DataflowResults, GenKillSet};\n use crate::dataflow::move_paths::{HasMoveData, MovePathIndex};\n \n use std::iter;\n+use std::borrow::Borrow;\n \n /// A trait for \"cartesian products\" of multiple FlowAtLocation.\n ///\n@@ -60,18 +61,20 @@ pub trait FlowsAtLocation {\n /// (e.g., via `reconstruct_statement_effect` and\n /// `reconstruct_terminator_effect`; don't forget to call\n /// `apply_local_effect`).\n-pub struct FlowAtLocation<'tcx, BD>\n+pub struct FlowAtLocation<'tcx, BD, DR = DataflowResults<'tcx, BD>>\n where\n     BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n {\n-    base_results: DataflowResults<'tcx, BD>,\n+    base_results: DR,\n     curr_state: BitSet<BD::Idx>,\n     stmt_trans: GenKillSet<BD::Idx>,\n }\n \n-impl<'tcx, BD> FlowAtLocation<'tcx, BD>\n+impl<'tcx, BD, DR> FlowAtLocation<'tcx, BD, DR>\n where\n     BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n {\n     /// Iterate over each bit set in the current state.\n     pub fn each_state_bit<F>(&self, f: F)\n@@ -91,8 +94,8 @@ where\n         self.stmt_trans.gen_set.iter().for_each(f)\n     }\n \n-    pub fn new(results: DataflowResults<'tcx, BD>) -> Self {\n-        let bits_per_block = results.sets().bits_per_block();\n+    pub fn new(results: DR) -> Self {\n+        let bits_per_block = results.borrow().sets().bits_per_block();\n         let curr_state = BitSet::new_empty(bits_per_block);\n         let stmt_trans = GenKillSet::from_elem(HybridBitSet::new_empty(bits_per_block));\n         FlowAtLocation {\n@@ -104,7 +107,7 @@ where\n \n     /// Access the underlying operator.\n     pub fn operator(&self) -> &BD {\n-        self.base_results.operator()\n+        self.base_results.borrow().operator()\n     }\n \n     pub fn contains(&self, x: BD::Idx) -> bool {\n@@ -134,39 +137,45 @@ where\n     }\n }\n \n-impl<'tcx, BD> FlowsAtLocation for FlowAtLocation<'tcx, BD>\n-    where BD: BitDenotation<'tcx>\n+impl<'tcx, BD, DR> FlowsAtLocation for FlowAtLocation<'tcx, BD, DR>\n+where\n+    BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n {\n     fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        self.curr_state.overwrite(self.base_results.sets().entry_set_for(bb.index()));\n+        self.curr_state.overwrite(self.base_results.borrow().sets().entry_set_for(bb.index()));\n     }\n \n     fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n         self.reset_to_entry_of(bb);\n-        let trans = self.base_results.sets().trans_for(bb.index());\n+        let trans = self.base_results.borrow().sets().trans_for(bb.index());\n         trans.apply(&mut self.curr_state)\n     }\n \n     fn reconstruct_statement_effect(&mut self, loc: Location) {\n         self.stmt_trans.clear();\n         self.base_results\n+            .borrow()\n             .operator()\n             .before_statement_effect(&mut self.stmt_trans, loc);\n         self.stmt_trans.apply(&mut self.curr_state);\n \n         self.base_results\n+            .borrow()\n             .operator()\n             .statement_effect(&mut self.stmt_trans, loc);\n     }\n \n     fn reconstruct_terminator_effect(&mut self, loc: Location) {\n         self.stmt_trans.clear();\n         self.base_results\n+            .borrow()\n             .operator()\n             .before_terminator_effect(&mut self.stmt_trans, loc);\n         self.stmt_trans.apply(&mut self.curr_state);\n \n         self.base_results\n+            .borrow()\n             .operator()\n             .terminator_effect(&mut self.stmt_trans, loc);\n     }\n@@ -177,9 +186,10 @@ impl<'tcx, BD> FlowsAtLocation for FlowAtLocation<'tcx, BD>\n }\n \n \n-impl<'tcx, T> FlowAtLocation<'tcx, T>\n+impl<'tcx, T, DR> FlowAtLocation<'tcx, T, DR>\n where\n     T: HasMoveData<'tcx> + BitDenotation<'tcx, Idx = MovePathIndex>,\n+    DR: Borrow<DataflowResults<'tcx, T>>,\n {\n     pub fn has_any_child_of(&self, mpi: T::Idx) -> Option<T::Idx> {\n         // We process `mpi` before the loop below, for two reasons:"}, {"sha": "7fa950cb98d344886fa6b94698647d5fecab2f2b", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "patch": "@@ -1,7 +1,13 @@\n pub use super::*;\n \n use rustc::mir::*;\n+use rustc::mir::visit::{\n+    PlaceContext, Visitor, NonMutatingUseContext,\n+};\n+use std::cell::RefCell;\n use crate::dataflow::BitDenotation;\n+use crate::dataflow::HaveBeenBorrowedLocals;\n+use crate::dataflow::{DataflowResults, DataflowResultsCursor, DataflowResultsRefCursor};\n \n #[derive(Copy, Clone)]\n pub struct MaybeStorageLive<'a, 'tcx> {\n@@ -27,7 +33,9 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n     }\n \n     fn start_block_effect(&self, _on_entry: &mut BitSet<Local>) {\n-        // Nothing is live on function entry\n+        // Nothing is live on function entry (generators only have a self\n+        // argument, and we don't care about that)\n+        assert_eq!(1, self.body.arg_count);\n     }\n \n     fn statement_effect(&self,\n@@ -63,3 +71,123 @@ impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n     /// bottom = dead\n     const BOTTOM_VALUE: bool = false;\n }\n+\n+/// Dataflow analysis that determines whether each local requires storage at a\n+/// given location; i.e. whether its storage can go away without being observed.\n+pub struct RequiresStorage<'mir, 'tcx> {\n+    body: &'mir Body<'tcx>,\n+    borrowed_locals:\n+        RefCell<DataflowResultsRefCursor<'mir, 'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>>,\n+}\n+\n+impl<'mir, 'tcx: 'mir> RequiresStorage<'mir, 'tcx> {\n+    pub fn new(\n+        body: &'mir Body<'tcx>,\n+        borrowed_locals: &'mir DataflowResults<'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>,\n+    ) -> Self {\n+        RequiresStorage {\n+            body,\n+            borrowed_locals: RefCell::new(DataflowResultsCursor::new(borrowed_locals, body)),\n+        }\n+    }\n+\n+    pub fn body(&self) -> &Body<'tcx> {\n+        self.body\n+    }\n+}\n+\n+impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n+    type Idx = Local;\n+    fn name() -> &'static str { \"requires_storage\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.body.local_decls.len()\n+    }\n+\n+    fn start_block_effect(&self, _sets: &mut BitSet<Local>) {\n+        // Nothing is live on function entry (generators only have a self\n+        // argument, and we don't care about that)\n+        assert_eq!(1, self.body.arg_count);\n+    }\n+\n+    fn statement_effect(&self,\n+                        sets: &mut GenKillSet<Local>,\n+                        loc: Location) {\n+        self.check_for_move(sets, loc);\n+        self.check_for_borrow(sets, loc);\n+\n+        let stmt = &self.body[loc.block].statements[loc.statement_index];\n+        match stmt.kind {\n+            StatementKind::StorageLive(l) => sets.gen(l),\n+            StatementKind::StorageDead(l) => sets.kill(l),\n+            StatementKind::Assign(ref place, _)\n+            | StatementKind::SetDiscriminant { ref place, .. } => {\n+                place.base_local().map(|l| sets.gen(l));\n+            }\n+            StatementKind::InlineAsm(box InlineAsm { ref outputs, .. }) => {\n+                for p in &**outputs {\n+                    p.base_local().map(|l| sets.gen(l));\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    fn terminator_effect(&self,\n+                         sets: &mut GenKillSet<Local>,\n+                         loc: Location) {\n+        self.check_for_move(sets, loc);\n+        self.check_for_borrow(sets, loc);\n+    }\n+\n+    fn propagate_call_return(\n+        &self,\n+        in_out: &mut BitSet<Local>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        dest_place: &mir::Place<'tcx>,\n+    ) {\n+        dest_place.base_local().map(|l| in_out.insert(l));\n+    }\n+}\n+\n+impl<'mir, 'tcx> RequiresStorage<'mir, 'tcx> {\n+    /// Kill locals that are fully moved and have not been borrowed.\n+    fn check_for_move(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        let mut visitor = MoveVisitor {\n+            sets,\n+            borrowed_locals: &self.borrowed_locals,\n+        };\n+        visitor.visit_location(self.body, loc);\n+    }\n+\n+    /// Gen locals that are newly borrowed. This includes borrowing any part of\n+    /// a local (we rely on this behavior of `HaveBeenBorrowedLocals`).\n+    fn check_for_borrow(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n+        borrowed_locals.seek(loc);\n+        borrowed_locals.each_gen_bit(|l| sets.gen(l));\n+    }\n+}\n+\n+impl<'mir, 'tcx> BottomValue for RequiresStorage<'mir, 'tcx> {\n+    /// bottom = dead\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+struct MoveVisitor<'a, 'mir, 'tcx> {\n+    borrowed_locals:\n+        &'a RefCell<DataflowResultsRefCursor<'mir, 'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>>,\n+    sets: &'a mut GenKillSet<Local>,\n+}\n+\n+impl<'a, 'mir: 'a, 'tcx> Visitor<'tcx> for MoveVisitor<'a, 'mir, 'tcx> {\n+    fn visit_local(&mut self, local: &Local, context: PlaceContext, loc: Location) {\n+        if PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) == context {\n+            let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n+            borrowed_locals.seek(loc);\n+            if !borrowed_locals.contains(*local) {\n+                self.sets.kill(*local);\n+            }\n+        }\n+    }\n+}"}, {"sha": "5433a9013aa851d2c7dfcd7c2ba6aac3b8ae406d", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 94, "deletions": 1, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "patch": "@@ -17,7 +17,7 @@ use std::io;\n use std::path::PathBuf;\n use std::usize;\n \n-pub use self::impls::{MaybeStorageLive};\n+pub use self::impls::{MaybeStorageLive, RequiresStorage};\n pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n pub use self::impls::DefinitelyInitializedPlaces;\n pub use self::impls::EverInitializedPlaces;\n@@ -360,6 +360,99 @@ pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     fn body(&self) -> &'a Body<'tcx>;\n }\n \n+/// Allows iterating dataflow results in a flexible and reasonably fast way.\n+pub struct DataflowResultsCursor<'mir, 'tcx, BD, DR = DataflowResults<'tcx, BD>>\n+where\n+    BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n+{\n+    flow_state: FlowAtLocation<'tcx, BD, DR>,\n+\n+    // The statement (or terminator) whose effect has been reconstructed in\n+    // flow_state.\n+    curr_loc: Option<Location>,\n+\n+    body: &'mir Body<'tcx>,\n+}\n+\n+pub type DataflowResultsRefCursor<'mir, 'tcx, BD> =\n+    DataflowResultsCursor<'mir, 'tcx, BD, &'mir DataflowResults<'tcx, BD>>;\n+\n+impl<'mir, 'tcx, BD, DR> DataflowResultsCursor<'mir, 'tcx, BD, DR>\n+where\n+    BD: BitDenotation<'tcx>,\n+    DR: Borrow<DataflowResults<'tcx, BD>>,\n+{\n+    pub fn new(result: DR, body: &'mir Body<'tcx>) -> Self {\n+        DataflowResultsCursor {\n+            flow_state: FlowAtLocation::new(result),\n+            curr_loc: None,\n+            body,\n+        }\n+    }\n+\n+    /// Seek to the given location in MIR. This method is fast if you are\n+    /// traversing your MIR statements in order.\n+    ///\n+    /// After calling `seek`, the current state will reflect all effects up to\n+    /// and including the `before_statement_effect` of the statement at location\n+    /// `loc`. The `statement_effect` of the statement at `loc` will be\n+    /// available as the current effect (see e.g. `each_gen_bit`).\n+    ///\n+    /// If `loc.statement_index` equals the number of statements in the block,\n+    /// we will reconstruct the terminator effect in the same way as described\n+    /// above.\n+    pub fn seek(&mut self, loc: Location) {\n+        if self.curr_loc.map(|cur| loc == cur).unwrap_or(false) {\n+            return;\n+        }\n+\n+        let start_index;\n+        let should_reset = match self.curr_loc {\n+            None => true,\n+            Some(cur)\n+                if loc.block != cur.block || loc.statement_index < cur.statement_index => true,\n+            _ => false,\n+        };\n+        if should_reset {\n+            self.flow_state.reset_to_entry_of(loc.block);\n+            start_index = 0;\n+        } else {\n+            let curr_loc = self.curr_loc.unwrap();\n+            start_index = curr_loc.statement_index;\n+            // Apply the effect from the last seek to the current state.\n+            self.flow_state.apply_local_effect(curr_loc);\n+        }\n+\n+        for stmt in start_index..loc.statement_index {\n+            let mut stmt_loc = loc;\n+            stmt_loc.statement_index = stmt;\n+            self.flow_state.reconstruct_statement_effect(stmt_loc);\n+            self.flow_state.apply_local_effect(stmt_loc);\n+        }\n+\n+        if loc.statement_index == self.body[loc.block].statements.len() {\n+            self.flow_state.reconstruct_terminator_effect(loc);\n+        } else {\n+            self.flow_state.reconstruct_statement_effect(loc);\n+        }\n+        self.curr_loc = Some(loc);\n+    }\n+\n+    /// Return whether the current state contains bit `x`.\n+    pub fn contains(&self, x: BD::Idx) -> bool {\n+        self.flow_state.contains(x)\n+    }\n+\n+    /// Iterate over each `gen` bit in the current effect (invoke `seek` first).\n+    pub fn each_gen_bit<F>(&self, f: F)\n+    where\n+        F: FnMut(BD::Idx),\n+    {\n+        self.flow_state.each_gen_bit(f)\n+    }\n+}\n+\n pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n                                                         analysis: &T,\n                                                         result: &DataflowResults<'tcx, T>,"}, {"sha": "1acebede2e41b712ea6077b5c27c4fe94088ed2c", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "patch": "@@ -68,7 +68,7 @@ use crate::transform::simplify;\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::dataflow::{DataflowResults, DataflowResultsConsumer, FlowAtLocation};\n use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location};\n-use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals};\n+use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals, RequiresStorage};\n use crate::util::dump_mir;\n use crate::util::liveness;\n \n@@ -437,16 +437,18 @@ fn locals_live_across_suspend_points(\n \n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n-    // This is only used for immovable generators.\n-    let borrowed_locals = if !movable {\n-        let analysis = HaveBeenBorrowedLocals::new(body);\n-        let result =\n-            do_dataflow(tcx, body, def_id, &[], &dead_unwinds, analysis,\n-                        |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n-        Some((analysis, result))\n-    } else {\n-        None\n-    };\n+    let borrowed_locals_analysis = HaveBeenBorrowedLocals::new(body);\n+    let borrowed_locals_result =\n+        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, borrowed_locals_analysis,\n+                    |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n+\n+    // Calculate the MIR locals that we actually need to keep storage around\n+    // for.\n+    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_result);\n+    let requires_storage =\n+        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, requires_storage_analysis,\n+                    |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n+    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_result);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n     let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n@@ -471,10 +473,10 @@ fn locals_live_across_suspend_points(\n                 statement_index: data.statements.len(),\n             };\n \n-            if let Some((ref analysis, ref result)) = borrowed_locals {\n+            if !movable {\n                 let borrowed_locals = state_for_location(loc,\n-                                                         analysis,\n-                                                         result,\n+                                                         &borrowed_locals_analysis,\n+                                                         &borrowed_locals_result,\n                                                          body);\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n                 // This is correct for movable generators since borrows cannot live across\n@@ -489,34 +491,42 @@ fn locals_live_across_suspend_points(\n                 liveness.outs[block].union(&borrowed_locals);\n             }\n \n-            let mut storage_liveness = state_for_location(loc,\n-                                                          &storage_live_analysis,\n-                                                          &storage_live,\n-                                                          body);\n+            let storage_liveness = state_for_location(loc,\n+                                                      &storage_live_analysis,\n+                                                      &storage_live,\n+                                                      body);\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n             storage_liveness_map.insert(block, storage_liveness.clone());\n \n-            // Mark locals without storage statements as always having live storage\n-            storage_liveness.union(&ignored.0);\n+            let mut storage_required = state_for_location(loc,\n+                                                          &requires_storage_analysis,\n+                                                          &requires_storage,\n+                                                          body);\n+\n+            // Mark locals without storage statements as always requiring storage\n+            storage_required.union(&ignored.0);\n \n             // Locals live are live at this point only if they are used across\n             // suspension points (the `liveness` variable)\n-            // and their storage is live (the `storage_liveness` variable)\n-            let mut live_locals_here = storage_liveness;\n+            // and their storage is required (the `storage_required` variable)\n+            let mut live_locals_here = storage_required;\n             live_locals_here.intersect(&liveness.outs[block]);\n \n             // The generator argument is ignored\n             live_locals_here.remove(self_arg());\n \n+            debug!(\"loc = {:?}, live_locals_here = {:?}\", loc, live_locals_here);\n+\n             // Add the locals live at this suspension point to the set of locals which live across\n             // any suspension points\n             live_locals.union(&live_locals_here);\n \n             live_locals_at_suspension_points.push(live_locals_here);\n         }\n     }\n+    debug!(\"live_locals = {:?}\", live_locals);\n \n     // Renumber our liveness_map bitsets to include only the locals we are\n     // saving.\n@@ -529,8 +539,8 @@ fn locals_live_across_suspend_points(\n         body,\n         &live_locals,\n         &ignored,\n-        storage_live,\n-        storage_live_analysis);\n+        requires_storage,\n+        requires_storage_analysis);\n \n     LivenessInfo {\n         live_locals,\n@@ -567,8 +577,8 @@ fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n     stored_locals: &liveness::LiveVarSet,\n     ignored: &StorageIgnored,\n-    storage_live: DataflowResults<'tcx, MaybeStorageLive<'mir, 'tcx>>,\n-    _storage_live_analysis: MaybeStorageLive<'mir, 'tcx>,\n+    requires_storage: DataflowResults<'tcx, RequiresStorage<'mir, 'tcx>>,\n+    _requires_storage_analysis: RequiresStorage<'mir, 'tcx>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n     assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n     assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n@@ -584,9 +594,9 @@ fn compute_storage_conflicts(\n     let mut visitor = StorageConflictVisitor {\n         body,\n         stored_locals: &stored_locals,\n-        local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len())\n+        local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n     };\n-    let mut state = FlowAtLocation::new(storage_live);\n+    let mut state = FlowAtLocation::new(requires_storage);\n     visitor.analyze_results(&mut state);\n     let local_conflicts = visitor.local_conflicts;\n \n@@ -627,7 +637,7 @@ struct StorageConflictVisitor<'body, 'tcx, 's> {\n impl<'body, 'tcx, 's> DataflowResultsConsumer<'body, 'tcx>\n     for StorageConflictVisitor<'body, 'tcx, 's>\n {\n-    type FlowState = FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>;\n+    type FlowState = FlowAtLocation<'tcx, RequiresStorage<'body, 'tcx>>;\n \n     fn body(&self) -> &'body Body<'tcx> {\n         self.body\n@@ -657,7 +667,7 @@ impl<'body, 'tcx, 's> DataflowResultsConsumer<'body, 'tcx>\n \n impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n     fn apply_state(&mut self,\n-                   flow_state: &FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>,\n+                   flow_state: &FlowAtLocation<'tcx, RequiresStorage<'body, 'tcx>>,\n                    loc: Location) {\n         // Ignore unreachable blocks.\n         match self.body.basic_blocks()[loc.block].terminator().kind {"}, {"sha": "139be7fe0132b0f1527ac01a0a0a13772c3d94a4", "filename": "src/test/run-pass/async-await/async-fn-size-moved-locals.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Ftest%2Frun-pass%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Ftest%2Frun-pass%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await%2Fasync-fn-size-moved-locals.rs?ref=848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "patch": "@@ -0,0 +1,98 @@\n+// Test that we don't duplicate storage for futures moved around in .await, and\n+// for futures moved into other futures.\n+//\n+// The exact sizes can change by a few bytes (we'd like to know when they do).\n+// What we don't want to see is the wrong multiple of 1024 (the size of BigFut)\n+// being reflected in the size.\n+//\n+// See issue #59123 for a full explanation.\n+\n+// edition:2018\n+\n+#![feature(async_await)]\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+use std::task::{Context, Poll};\n+\n+const BIG_FUT_SIZE: usize = 1024;\n+struct BigFut([u8; BIG_FUT_SIZE]);\n+\n+impl BigFut {\n+    fn new() -> Self {\n+        BigFut([0; BIG_FUT_SIZE])\n+    } }\n+\n+impl Drop for BigFut {\n+    fn drop(&mut self) {}\n+}\n+\n+impl Future for BigFut {\n+    type Output = ();\n+\n+    fn poll(self: Pin<&mut Self>, _ctx: &mut Context<'_>) -> Poll<Self::Output> {\n+        Poll::Ready(())\n+    }\n+}\n+\n+#[allow(dead_code)]\n+struct Joiner {\n+    a: Option<BigFut>,\n+    b: Option<BigFut>,\n+    c: Option<BigFut>,\n+}\n+\n+impl Future for Joiner {\n+    type Output = ();\n+\n+    fn poll(self: Pin<&mut Self>, _ctx: &mut Context<'_>) -> Poll<Self::Output> {\n+        Poll::Ready(())\n+    }\n+}\n+\n+fn noop() {}\n+\n+async fn single() {\n+    let x = BigFut::new();\n+    x.await;\n+}\n+\n+async fn single_with_noop() {\n+    let x = BigFut::new();\n+    noop();\n+    x.await;\n+}\n+\n+async fn joined() {\n+    let a = BigFut::new();\n+    let b = BigFut::new();\n+    let c = BigFut::new();\n+\n+    let joiner = Joiner {\n+        a: Some(a),\n+        b: Some(b),\n+        c: Some(c),\n+    };\n+    joiner.await\n+}\n+\n+async fn joined_with_noop() {\n+    let a = BigFut::new();\n+    let b = BigFut::new();\n+    let c = BigFut::new();\n+\n+    let joiner = Joiner {\n+        a: Some(a),\n+        b: Some(b),\n+        c: Some(c),\n+    };\n+    noop();\n+    joiner.await\n+}\n+\n+fn main() {\n+    assert_eq!(1028, std::mem::size_of_val(&single()));\n+    assert_eq!(1032, std::mem::size_of_val(&single_with_noop()));\n+    assert_eq!(3084, std::mem::size_of_val(&joined()));\n+    assert_eq!(3084, std::mem::size_of_val(&joined_with_noop()));\n+}"}, {"sha": "37e2e0cfdcccf2de257fc22527810a6ff11ffc6e", "filename": "src/test/run-pass/generator/size-moved-locals.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Ftest%2Frun-pass%2Fgenerator%2Fsize-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1/src%2Ftest%2Frun-pass%2Fgenerator%2Fsize-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fsize-moved-locals.rs?ref=848e0a23f34aaab3e4a974b031c86ef2a4e4fcc1", "patch": "@@ -0,0 +1,62 @@\n+// Test that we don't duplicate storage for a variable that is moved to another\n+// binding. This used to happen in the presence of unwind and drop edges (see\n+// `complex` below.)\n+//\n+// The exact sizes here can change (we'd like to know when they do). What we\n+// don't want to see is the `complex` generator size being upwards of 2048 bytes\n+// (which would indicate it is reserving space for two copies of Foo.)\n+//\n+// See issue #59123 for a full explanation.\n+\n+// edition:2018\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+const FOO_SIZE: usize = 1024;\n+struct Foo([u8; FOO_SIZE]);\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+fn move_before_yield() -> impl Generator<Yield = (), Return = ()> {\n+    static || {\n+        let first = Foo([0; FOO_SIZE]);\n+        let _second = first;\n+        yield;\n+        // _second dropped here\n+    }\n+}\n+\n+fn noop() {}\n+\n+fn move_before_yield_with_noop() -> impl Generator<Yield = (), Return = ()> {\n+    static || {\n+        let first = Foo([0; FOO_SIZE]);\n+        noop();\n+        let _second = first;\n+        yield;\n+        // _second dropped here\n+    }\n+}\n+\n+// Today we don't have NRVO (we allocate space for both `first` and `second`,)\n+// but we can overlap `first` with `_third`.\n+fn overlap_move_points() -> impl Generator<Yield = (), Return = ()> {\n+    static || {\n+        let first = Foo([0; FOO_SIZE]);\n+        yield;\n+        let second = first;\n+        yield;\n+        let _third = second;\n+        yield;\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(1028, std::mem::size_of_val(&move_before_yield()));\n+    assert_eq!(1032, std::mem::size_of_val(&move_before_yield_with_noop()));\n+    assert_eq!(2056, std::mem::size_of_val(&overlap_move_points()));\n+}"}]}