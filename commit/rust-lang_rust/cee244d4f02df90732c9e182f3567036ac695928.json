{"sha": "cee244d4f02df90732c9e182f3567036ac695928", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZTI0NGQ0ZjAyZGY5MDczMmM5ZTE4MmYzNTY3MDM2YWM2OTU5Mjg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-05T12:34:13Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-05T12:34:13Z"}, "message": "trans: update Luqmana's patch for generalized pair handling.", "tree": {"sha": "0d1b13f9b8b11025bd9cbc5c43b705301f841638", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d1b13f9b8b11025bd9cbc5c43b705301f841638"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cee244d4f02df90732c9e182f3567036ac695928", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cee244d4f02df90732c9e182f3567036ac695928", "html_url": "https://github.com/rust-lang/rust/commit/cee244d4f02df90732c9e182f3567036ac695928", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cee244d4f02df90732c9e182f3567036ac695928/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da081e1eac64d981209a742f8edea1a55127ce42", "url": "https://api.github.com/repos/rust-lang/rust/commits/da081e1eac64d981209a742f8edea1a55127ce42", "html_url": "https://github.com/rust-lang/rust/commit/da081e1eac64d981209a742f8edea1a55127ce42"}], "stats": {"total": 113, "additions": 67, "deletions": 46}, "files": [{"sha": "b7aca4c8d7fed0fcd304cc8ded79840a7ac55fb0", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 53, "deletions": 42, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cee244d4f02df90732c9e182f3567036ac695928/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cee244d4f02df90732c9e182f3567036ac695928/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=cee244d4f02df90732c9e182f3567036ac695928", "patch": "@@ -852,63 +852,74 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     op: OperandRef<'tcx>) {\n         use self::ReturnDest::*;\n \n-        match dest {\n-            Nothing => (),\n+        // Handle the simple cases that don't require casts, first.\n+        let llcast_ty = match dest {\n+            Nothing => return,\n             Store(dst) => {\n                 if let Some(llcast_ty) = ret_ty.cast {\n-                    let ccx = bcx.ccx();\n-                    // The actual return type is a struct, but the ABI\n-                    // adaptation code has cast it into some scalar type.  The\n-                    // code that follows is the only reliable way I have\n-                    // found to do a transform like i64 -> {i32,i32}.\n-                    // Basically we dump the data onto the stack then memcpy it.\n-                    //\n-                    // Other approaches I tried:\n-                    // - Casting rust ret pointer to the foreign type and using Store\n-                    //   is (a) unsafe if size of foreign type > size of rust type and\n-                    //   (b) runs afoul of strict aliasing rules, yielding invalid\n-                    //   assembly under -O (specifically, the store gets removed).\n-                    // - Truncating foreign type to correct integral type and then\n-                    //   bitcasting to the struct type yields invalid cast errors.\n-\n-                    // We instead thus allocate some scratch space...\n-                    let llscratch = bcx.alloca(llcast_ty, \"fn_ret_cast\");\n-                    bcx.with_block(|bcx| base::call_lifetime_start(bcx, llscratch));\n-\n-                    // ...where we first store the value...\n-                    bcx.store(op.immediate(), llscratch);\n-\n-                    // ...and then memcpy it to the intended destination.\n-                    base::call_memcpy(bcx,\n-                                      bcx.pointercast(dst, Type::i8p(ccx)),\n-                                      bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                      C_uint(ccx, llsize_of_store(ccx, ret_ty.original_ty)),\n-                                      cmp::min(llalign_of_min(ccx, ret_ty.original_ty),\n-                                               llalign_of_min(ccx, llcast_ty)) as u32);\n-\n-                    bcx.with_block(|bcx| base::call_lifetime_end(bcx, llscratch));\n+                    llcast_ty\n                 } else {\n                     ret_ty.store(bcx, op.immediate(), dst);\n+                    return;\n                 }\n             }\n             IndirectOperand(tmp, idx) => {\n                 let op = self.trans_load(bcx, tmp, op.ty);\n                 self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                return;\n             }\n             DirectOperand(idx) => {\n-                // If there is a cast, we have to store and reload.\n-                let op = if ret_ty.cast.is_some() {\n-                    let tmp = bcx.with_block(|bcx| {\n-                        base::alloc_ty(bcx, op.ty, \"tmp_ret\")\n-                    });\n-                    ret_ty.store(bcx, op.immediate(), tmp);\n-                    self.trans_load(bcx, tmp, op.ty)\n+                if let Some(llcast_ty) = ret_ty.cast {\n+                    llcast_ty\n                 } else {\n-                    op.unpack_if_pair(bcx)\n-                };\n+                    let op = op.unpack_if_pair(bcx);\n+                    self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                    return;\n+                }\n+            }\n+        };\n+\n+        // The actual return type is a struct, but the ABI\n+        // adaptation code has cast it into some scalar type.  The\n+        // code that follows is the only reliable way I have\n+        // found to do a transform like i64 -> {i32,i32}.\n+        // Basically we dump the data onto the stack then memcpy it.\n+        //\n+        // Other approaches I tried:\n+        // - Casting rust ret pointer to the foreign type and using Store\n+        //   is (a) unsafe if size of foreign type > size of rust type and\n+        //   (b) runs afoul of strict aliasing rules, yielding invalid\n+        //   assembly under -O (specifically, the store gets removed).\n+        // - Truncating foreign type to correct integral type and then\n+        //   bitcasting to the struct type yields invalid cast errors.\n+\n+        // We instead thus allocate some scratch space...\n+        let llscratch = bcx.alloca(llcast_ty, \"fn_ret_cast\");\n+        bcx.with_block(|bcx| base::call_lifetime_start(bcx, llscratch));\n+\n+        // ...where we first store the value...\n+        bcx.store(op.immediate(), llscratch);\n+\n+        let ccx = bcx.ccx();\n+        match dest {\n+            Store(dst) => {\n+                // ...and then memcpy it to the intended destination.\n+                base::call_memcpy(bcx,\n+                                  bcx.pointercast(dst, Type::i8p(ccx)),\n+                                  bcx.pointercast(llscratch, Type::i8p(ccx)),\n+                                  C_uint(ccx, llsize_of_store(ccx, ret_ty.original_ty)),\n+                                  cmp::min(llalign_of_min(ccx, ret_ty.original_ty),\n+                                           llalign_of_min(ccx, llcast_ty)) as u32);\n+            }\n+            DirectOperand(idx) => {\n+                let llptr = bcx.pointercast(llscratch, ret_ty.original_ty.ptr_to());\n+                let op = self.trans_load(bcx, llptr, op.ty);\n                 self.temps[idx as usize] = TempRef::Operand(Some(op));\n             }\n+            Nothing | IndirectOperand(_, _) => bug!()\n         }\n+\n+        bcx.with_block(|bcx| base::call_lifetime_end(bcx, llscratch));\n     }\n }\n "}, {"sha": "8a723967aff5f04ce6764f9cb121f127b741b181", "filename": "src/test/run-pass/mir_cast_fn_ret.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cee244d4f02df90732c9e182f3567036ac695928/src%2Ftest%2Frun-pass%2Fmir_cast_fn_ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cee244d4f02df90732c9e182f3567036ac695928/src%2Ftest%2Frun-pass%2Fmir_cast_fn_ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_cast_fn_ret.rs?ref=cee244d4f02df90732c9e182f3567036ac695928", "patch": "@@ -10,15 +10,25 @@\n \n #![feature(rustc_attrs)]\n \n-pub extern \"C\" fn foo() -> (u8, u8, u8) {\n+pub extern \"C\" fn tuple2() -> (u16, u8) {\n+    (1, 2)\n+}\n+\n+pub extern \"C\" fn tuple3() -> (u8, u8, u8) {\n     (1, 2, 3)\n }\n \n #[rustc_mir]\n-pub fn bar() -> u8 {\n-    foo().2\n+pub fn test2() -> u8 {\n+    tuple2().1\n+}\n+\n+#[rustc_mir]\n+pub fn test3() -> u8 {\n+    tuple3().2\n }\n \n fn main() {\n-    assert_eq!(bar(), 3);\n+    assert_eq!(test2(), 2);\n+    assert_eq!(test3(), 3);\n }"}]}