{"sha": "7d3f892f3568d6641a39a9fabb8a44b7d0d85a25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkM2Y4OTJmMzU2OGQ2NjQxYTM5YTlmYWJiOGE0NGI3ZDBkODVhMjU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-07T21:44:14Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-08T22:07:15Z"}, "message": "First barely-working version of casting to iface\n\nIssue #1437", "tree": {"sha": "2e1d8c84386264944337a43e603781b7939e2fd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e1d8c84386264944337a43e603781b7939e2fd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25", "html_url": "https://github.com/rust-lang/rust/commit/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a161371d13fce27fa4aac1d9148b566a89e72571", "url": "https://api.github.com/repos/rust-lang/rust/commits/a161371d13fce27fa4aac1d9148b566a89e72571", "html_url": "https://github.com/rust-lang/rust/commit/a161371d13fce27fa4aac1d9148b566a89e72571"}], "stats": {"total": 132, "additions": 99, "deletions": 33}, "files": [{"sha": "ff760230d937c654af138d21f4a418e71822f69b", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=7d3f892f3568d6641a39a9fabb8a44b7d0d85a25", "patch": "@@ -52,6 +52,7 @@ const shape_res: u8 = 20u8;\n const shape_var: u8 = 21u8;\n const shape_uniq: u8 = 22u8;\n const shape_opaque_closure_ptr: u8 = 23u8; // the closure itself.\n+const shape_iface: u8 = 24u8;\n \n // FIXME: This is a bad API in trans_common.\n fn C_u8(n: u8) -> ValueRef { ret trans_common::C_u8(n as uint); }\n@@ -387,6 +388,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n       }\n       ty::ty_native_fn(_, _) { s += [shape_u32]; }\n       ty::ty_obj(_) { s += [shape_obj]; }\n+      ty::ty_iface(_, _) { s += [shape_iface]; }\n       ty::ty_res(did, raw_subt, tps) {\n         let subt = ty::substitute_type_params(ccx.tcx, tps, raw_subt);\n         let ri = {did: did, t: subt};"}, {"sha": "108f2c5b1c57da884f55e4b185d28b9b0a5f71f2", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7d3f892f3568d6641a39a9fabb8a44b7d0d85a25", "patch": "@@ -178,7 +178,8 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         let nft = native_fn_wrapper_type(cx, sp, [], t);\n         T_fn_pair(cx, nft)\n       }\n-      ty::ty_obj(meths) { cx.rust_object_type }\n+      ty::ty_obj(_) { cx.rust_object_type }\n+      ty::ty_iface(_, _) { T_opaque_iface_ptr(cx) }\n       ty::ty_res(_, sub, tps) {\n         let sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n         check non_ty_var(cx, sub1);\n@@ -483,7 +484,9 @@ fn mk_obstack_token(ccx: @crate_ctxt, fcx: @fn_ctxt) ->\n fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n     fn simplifier(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n         alt ty::struct(ccx.tcx, typ) {\n-          ty::ty_box(_) { ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)); }\n+          ty::ty_box(_) | ty::ty_iface(_, _) {\n+            ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx));\n+          }\n           ty::ty_uniq(_) {\n             ret ty::mk_imm_uniq(ccx.tcx, ty::mk_nil(ccx.tcx));\n           }\n@@ -1386,9 +1389,10 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n       ty::ty_vec(_) | ty::ty_str. {\n         tvec::make_free_glue(bcx, PointerCast(bcx, v, type_of_1(bcx, t)), t)\n       }\n-      ty::ty_obj(_) {\n+      ty::ty_obj(_) | ty::ty_iface(_, _) {\n         // Call through the obj's own fields-drop glue first.\n         // Then free the body.\n+        // (Same code of ifaces, whose layout is similar)\n         let ccx = bcx_ccx(bcx);\n         let llbox_ty = T_opaque_obj_ptr(ccx);\n         let b = PointerCast(bcx, v, llbox_ty);\n@@ -1425,13 +1429,14 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n     let ccx = bcx_ccx(bcx);\n     let bcx =\n         alt ty::struct(ccx.tcx, t) {\n-          ty::ty_box(_) { decr_refcnt_maybe_free(bcx, Load(bcx, v0), t) }\n+          ty::ty_box(_) | ty::ty_iface(_, _) {\n+              decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n+          }\n           ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str. | ty::ty_send_type. {\n             free_ty(bcx, Load(bcx, v0), t)\n           }\n           ty::ty_obj(_) {\n-            let box_cell =\n-                GEPi(bcx, v0, [0, abi::obj_field_box]);\n+            let box_cell = GEPi(bcx, v0, [0, abi::obj_field_box]);\n             decr_refcnt_maybe_free(bcx, Load(bcx, box_cell), t)\n           }\n           ty::ty_res(did, inner, tps) {\n@@ -1935,22 +1940,22 @@ fn drop_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n \n fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     alt ty::struct(bcx_tcx(bcx), t) {\n-      ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str. {\n-        ret free_ty(bcx, v, t);\n-      }\n-      ty::ty_box(_) { ret decr_refcnt_maybe_free(bcx, v, t); }\n+      ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str. { free_ty(bcx, v, t) }\n+      ty::ty_box(_) | ty::ty_iface(_, _) { decr_refcnt_maybe_free(bcx, v, t) }\n     }\n }\n \n fn take_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n     alt ty::struct(bcx_tcx(bcx), t) {\n-      ty::ty_box(_) { ret rslt(incr_refcnt_of_boxed(bcx, v), v); }\n+      ty::ty_box(_) | ty::ty_iface(_, _) {\n+        rslt(incr_refcnt_of_boxed(bcx, v), v)\n+      }\n       ty::ty_uniq(_) {\n         check trans_uniq::type_is_unique_box(bcx, t);\n-        ret trans_uniq::duplicate(bcx, v, t);\n+        trans_uniq::duplicate(bcx, v, t)\n       }\n-      ty::ty_str. | ty::ty_vec(_) { ret tvec::duplicate(bcx, v, t); }\n-      _ { ret rslt(bcx, v); }\n+      ty::ty_str. | ty::ty_vec(_) { tvec::duplicate(bcx, v, t) }\n+      _ { rslt(bcx, v) }\n     }\n }\n \n@@ -2873,9 +2878,12 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n                 ret trans_impl::trans_static_callee(bcx, e, base, did);\n               }\n               some(typeck::method_param(iid, off, p, b)) {\n-                ret trans_impl::trans_dict_callee(\n+                ret trans_impl::trans_param_callee(\n                     bcx, e, base, iid, off, p, b);\n               }\n+              some(typeck::method_iface(off)) {\n+                ret trans_impl::trans_iface_callee(bcx, e, base, off);\n+              }\n               none. { // An object method\n                 let of = trans_object_field(bcx, base, ident);\n                 ret {bcx: of.bcx, val: of.mthptr, kind: owned,\n@@ -3001,10 +3009,14 @@ fn float_cast(bcx: @block_ctxt, lldsttype: TypeRef, llsrctype: TypeRef,\n fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n               dest: dest) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n+    let t_out = node_id_type(ccx, id);\n+    alt ty::struct(ccx.tcx, t_out) {\n+      ty::ty_iface(_, _) { ret trans_impl::trans_cast(cx, e, id, dest); }\n+      _ {}\n+    }\n     let e_res = trans_temp_expr(cx, e);\n     let ll_t_in = val_ty(e_res.val);\n     let t_in = ty::expr_ty(ccx.tcx, e);\n-    let t_out = node_id_type(ccx, id);\n     // Check should be avoidable because it's a cast.\n     // FIXME: Constrain types so as to avoid this check.\n     check (type_has_static_size(ccx, t_out));"}, {"sha": "72803fd309a477a63e3f9fb7c2dcd0079642cac0", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=7d3f892f3568d6641a39a9fabb8a44b7d0d85a25", "patch": "@@ -754,6 +754,11 @@ fn T_obj_ptr(cx: @crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n \n fn T_opaque_obj_ptr(cx: @crate_ctxt) -> TypeRef { ret T_obj_ptr(cx, 0u); }\n \n+fn T_opaque_iface_ptr(cx: @crate_ctxt) -> TypeRef {\n+    let tdptr = T_ptr(cx.tydesc_type);\n+    T_ptr(T_box(cx, T_struct([tdptr, tdptr, T_i8()])))\n+}\n+\n fn T_opaque_port_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n \n fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }"}, {"sha": "f4d9e58e427ec459098929b00db7274ff36c2b77", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=7d3f892f3568d6641a39a9fabb8a44b7d0d85a25", "patch": "@@ -4,7 +4,7 @@ import trans_build::*;\n import option::{some, none};\n import syntax::{ast, ast_util};\n import metadata::csearch;\n-import back::link;\n+import back::{link, abi};\n import lib::llvm::llvm;\n import llvm::{ValueRef, TypeRef, LLVMGetParam};\n \n@@ -61,21 +61,20 @@ fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n     rslt(bcx, PointerCast(bcx, val, T_opaque_cbox_ptr(bcx_ccx(bcx))))\n }\n \n+// Method callee where the method is statically known\n fn trans_static_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n                        did: ast::def_id) -> lval_maybe_callee {\n     let {bcx, val} = trans_self_arg(bcx, base);\n     {env: obj_env(val) with lval_static_fn(bcx, did, e.id)}\n }\n \n-fn trans_dict_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n-                     iface_id: ast::def_id, n_method: uint,\n-                     n_param: uint, n_bound: uint) -> lval_maybe_callee {\n-    let tcx = bcx_tcx(bcx);\n-    let {bcx, val} = trans_self_arg(bcx, base);\n-    let dict = option::get(bcx.fcx.lltyparams[n_param].dicts)[n_bound];\n+fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n+                       fld_expr: @ast::expr, iface_id: ast::def_id,\n+                       n_method: uint) -> lval_maybe_callee {\n+    let bcx = bcx, ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n     let method = ty::iface_methods(tcx, iface_id)[n_method];\n-    let fty = ty::expr_ty(tcx, e);\n-    let bare_fn_ty = type_of_fn_from_ty(bcx_ccx(bcx), ast_util::dummy_sp(),\n+    let fty = ty::expr_ty(tcx, fld_expr);\n+    let bare_fn_ty = type_of_fn_from_ty(ccx, ast_util::dummy_sp(),\n                                         fty, *method.tps);\n     let {inputs: bare_inputs, output} = llfn_arg_tys(bare_fn_ty);\n     let fn_ty = T_fn([val_ty(dict)] + bare_inputs, output);\n@@ -85,9 +84,8 @@ fn trans_dict_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n     let generic = none;\n     if vec::len(*method.tps) > 0u {\n         let tydescs = [], tis = [];\n-        let tptys = ty::node_id_to_type_params(tcx, e.id);\n+        let tptys = ty::node_id_to_type_params(tcx, fld_expr.id);\n         for t in vec::tail_n(tptys, vec::len(tptys) - vec::len(*method.tps)) {\n-            // TODO: Doesn't always escape.\n             let ti = none;\n             let td = get_tydesc(bcx, t, true, tps_normal, ti).result;\n             tis += [ti];\n@@ -98,13 +96,40 @@ fn trans_dict_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n                         static_tis: tis,\n                         tydescs: tydescs,\n                         param_bounds: method.tps,\n-                        origins: bcx_ccx(bcx).dict_map.find(e.id)});\n+                        origins: bcx_ccx(bcx).dict_map.find(fld_expr.id)});\n     }\n     {bcx: bcx, val: mptr, kind: owned,\n-     env: dict_env(dict, val),\n+     env: dict_env(dict, self),\n      generic: generic}\n }\n \n+// Method callee where the dict comes from a type param\n+fn trans_param_callee(bcx: @block_ctxt, fld_expr: @ast::expr,\n+                      base: @ast::expr, iface_id: ast::def_id, n_method: uint,\n+                      n_param: uint, n_bound: uint) -> lval_maybe_callee {\n+    let {bcx, val} = trans_self_arg(bcx, base);\n+    let dict = option::get(bcx.fcx.lltyparams[n_param].dicts)[n_bound];\n+    trans_vtable_callee(bcx, val, dict, fld_expr, iface_id, n_method)\n+}\n+\n+// Method callee where the dict comes from a boxed iface\n+fn trans_iface_callee(bcx: @block_ctxt, fld_expr: @ast::expr, base: @ast::expr,\n+                      n_method: uint)\n+    -> lval_maybe_callee {\n+    let tcx = bcx_tcx(bcx);\n+    let {bcx, val} = trans_temp_expr(bcx, base);\n+    let box_body = GEPi(bcx, val, [0, abi::box_rc_field_body]);\n+    let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, box_body, [0, 1]),\n+                                     T_ptr(T_ptr(T_dict()))));\n+    // FIXME[impl] I doubt this is alignment-safe\n+    let self = PointerCast(bcx, GEPi(bcx, box_body, [0, 2]),\n+                           T_opaque_cbox_ptr(bcx_ccx(bcx)));\n+    let iface_id = alt ty::struct(tcx, ty::expr_ty(tcx, base)) {\n+        ty::ty_iface(did, _) { did }\n+    };\n+    trans_vtable_callee(bcx, self, dict, fld_expr, iface_id, n_method)\n+}\n+\n fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n     let out_ty = llvm::LLVMGetReturnType(ft);\n     let n_args = llvm::LLVMCountParamTypes(ft);\n@@ -274,3 +299,22 @@ fn get_dict_ptrs(bcx: @block_ctxt, origin: typeck::dict_origin)\n       }\n     }\n }\n+\n+fn trans_cast(bcx: @block_ctxt, val: @ast::expr, id: ast::node_id, dest: dest)\n+    -> @block_ctxt {\n+    let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n+    let val_ty = ty::expr_ty(tcx, val);\n+    let {bcx, val: dict} = get_dict(bcx, ccx.dict_map.get(id)[0]);\n+    let body_ty = ty::mk_tup(tcx, [ty::mk_type(tcx), ty::mk_type(tcx),\n+                                   val_ty]);\n+    let ti = none;\n+    let {bcx, val: tydesc} = get_tydesc(bcx, body_ty, true,\n+                                        tps_normal, ti).result;\n+    lazily_emit_all_tydesc_glue(bcx, ti);\n+    let {bcx, box, body: box_body} = trans_malloc_boxed(bcx, body_ty);\n+    Store(bcx, tydesc, GEPi(bcx, box_body, [0, 0]));\n+    Store(bcx, PointerCast(bcx, dict, T_ptr(ccx.tydesc_type)),\n+          GEPi(bcx, box_body, [0, 1]));\n+    bcx = trans_expr_save_in(bcx, val, GEPi(bcx, box_body, [0, 2]));\n+    store_in_dest(bcx, PointerCast(bcx, box, T_opaque_iface_ptr(ccx)), dest)\n+}"}, {"sha": "42225aa2acaeceabfc6989949631143ddb5b4e8f", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=7d3f892f3568d6641a39a9fabb8a44b7d0d85a25", "patch": "@@ -909,7 +909,7 @@ pure fn type_is_box(cx: ctxt, ty: t) -> bool {\n \n pure fn type_is_boxed(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_box(_) { ret true; }\n+      ty_box(_) | ty_iface(_, _) { ret true; }\n       _ { ret false; }\n     }\n }"}, {"sha": "540bae5b32b59abd73bf0bb593ecbd0b550a7f50", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f892f3568d6641a39a9fabb8a44b7d0d85a25/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=7d3f892f3568d6641a39a9fabb8a44b7d0d85a25", "patch": "@@ -18,14 +18,15 @@ import std::map::{hashmap, new_int_hash};\n import option::{none, some};\n import syntax::print::pprust::*;\n \n-export check_crate, method_map, method_origin, method_static, method_param;\n+export check_crate;\n+export method_map, method_origin, method_static, method_param, method_iface;\n export dict_map, dict_res, dict_origin, dict_static, dict_param;\n \n tag method_origin {\n     method_static(ast::def_id);\n     // iface id, method num, param num, bound num\n     method_param(ast::def_id, uint, uint, uint);\n-    method_iface;\n+    method_iface(uint);\n }\n type method_map = hashmap<ast::node_id, method_origin>;\n \n@@ -1575,13 +1576,15 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n         ret none;\n       }\n       ty::ty_iface(did, tps) {\n+        let i = 0u;\n         for m in *ty::iface_methods(tcx, did) {\n             if m.ident == name {\n                 ret some({method_ty: ty::mk_fn(tcx, m.fty),\n                           n_tps: vec::len(*m.tps),\n                           substs: tps,\n-                          origin: method_iface});\n+                          origin: method_iface(i)});\n             }\n+            i += 1u;\n         }\n       }\n       _ {}"}]}