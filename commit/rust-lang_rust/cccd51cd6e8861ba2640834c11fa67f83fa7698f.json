{"sha": "cccd51cd6e8861ba2640834c11fa67f83fa7698f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjY2Q1MWNkNmU4ODYxYmEyNjQwODM0YzExZmE2N2Y4M2ZhNzY5OGY=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-04-20T10:28:28Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-04-20T10:28:28Z"}, "message": "Speed up `nearest_common_ancestor()`.\n\n`nearest_common_ancestor()` uses an algorithm that requires computing\nthe full scope chain for both scopes, which is expensive because each\nelement involves a hash table lookup, and then looking for a common\ntail.\n\nThis patch changes `nearest_common_ancestor()` to use a different\nalgorithm, which starts at the given scopes and works outwards (i.e. up\nthe scope tree) until a common ancestor is found. This is much faster\nbecause in most cases the common ancestor is found well before the end\nof the scope chains. Also, the use of a SmallVec avoids the need for any\nallocation most of the time.", "tree": {"sha": "f6fd65c6c116aad4755423e0db710054d1b242b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6fd65c6c116aad4755423e0db710054d1b242b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cccd51cd6e8861ba2640834c11fa67f83fa7698f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cccd51cd6e8861ba2640834c11fa67f83fa7698f", "html_url": "https://github.com/rust-lang/rust/commit/cccd51cd6e8861ba2640834c11fa67f83fa7698f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cccd51cd6e8861ba2640834c11fa67f83fa7698f/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "144c0d5519dff9eca7bacd6191856ef57dbb7e0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/144c0d5519dff9eca7bacd6191856ef57dbb7e0f", "html_url": "https://github.com/rust-lang/rust/commit/144c0d5519dff9eca7bacd6191856ef57dbb7e0f"}], "stats": {"total": 140, "additions": 60, "deletions": 80}, "files": [{"sha": "5f4efbeeaa8762da80ffc0cf8119189a29e418d7", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 60, "deletions": 80, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/cccd51cd6e8861ba2640834c11fa67f83fa7698f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cccd51cd6e8861ba2640834c11fa67f83fa7698f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=cccd51cd6e8861ba2640834c11fa67f83fa7698f", "patch": "@@ -22,6 +22,7 @@ use ty;\n \n use std::fmt;\n use std::mem;\n+use rustc_data_structures::small_vec::SmallVec;\n use rustc_data_structures::sync::Lrc;\n use syntax::codemap;\n use syntax::ast;\n@@ -677,96 +678,75 @@ impl<'tcx> ScopeTree {\n                                    -> Scope {\n         if scope_a == scope_b { return scope_a; }\n \n-        // [1] The initial values for `a_buf` and `b_buf` are not used.\n-        // The `ancestors_of` function will return some prefix that\n-        // is re-initialized with new values (or else fallback to a\n-        // heap-allocated vector).\n-        let mut a_buf: [Scope; 32] = [scope_a /* [1] */; 32];\n-        let mut a_vec: Vec<Scope> = vec![];\n-        let mut b_buf: [Scope; 32] = [scope_b /* [1] */; 32];\n-        let mut b_vec: Vec<Scope> = vec![];\n-        let parent_map = &self.parent_map;\n-        let a_ancestors = ancestors_of(parent_map, scope_a, &mut a_buf, &mut a_vec);\n-        let b_ancestors = ancestors_of(parent_map, scope_b, &mut b_buf, &mut b_vec);\n-        let mut a_index = a_ancestors.len() - 1;\n-        let mut b_index = b_ancestors.len() - 1;\n-\n-        // Here, [ab]_ancestors is a vector going from narrow to broad.\n-        // The end of each vector will be the item where the scope is\n-        // defined; if there are any common ancestors, then the tails of\n-        // the vector will be the same.  So basically we want to walk\n-        // backwards from the tail of each vector and find the first point\n-        // where they diverge.  If one vector is a suffix of the other,\n-        // then the corresponding scope is a superscope of the other.\n-\n-        if a_ancestors[a_index] != b_ancestors[b_index] {\n-            // In this case, the two regions belong to completely\n-            // different functions.  Compare those fn for lexical\n-            // nesting. The reasoning behind this is subtle.  See the\n-            // \"Modeling closures\" section of the README in\n-            // infer::region_constraints for more details.\n-            let a_root_scope = a_ancestors[a_index];\n-            let b_root_scope = b_ancestors[b_index];\n-            return match (a_root_scope.data(), b_root_scope.data()) {\n-                (ScopeData::Destruction(a_root_id),\n-                 ScopeData::Destruction(b_root_id)) => {\n-                    if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n-                        // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n-                        scope_b\n-                    } else if self.closure_is_enclosed_by(b_root_id, a_root_id) {\n-                        // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n-                        scope_a\n-                    } else {\n-                        // neither fn encloses the other\n-                        bug!()\n-                    }\n+        // Process the lists in tandem from the innermost scope, recording the\n+        // scopes seen so far. The first scope that comes up for a second time\n+        // is the nearest common ancestor.\n+        //\n+        // Note: another way to compute the nearest common ancestor is to get\n+        // the full scope chain for both scopes and then compare the chains to\n+        // find the first scope in a common tail. But getting a parent scope\n+        // requires a hash table lookup, and we often have very long scope\n+        // chains (10s or 100s of scopes) that only differ by a few elements at\n+        // the start. So this algorithm is faster.\n+        let mut ma = Some(scope_a);\n+        let mut mb = Some(scope_b);\n+        let mut seen: SmallVec<[Scope; 32]> = SmallVec::new();\n+        loop {\n+            if let Some(a) = ma {\n+                if seen.iter().position(|s| *s == a).is_some() {\n+                    return a;\n                 }\n-                _ => {\n-                    // root ids are always Node right now\n-                    bug!()\n+                seen.push(a);\n+                ma = self.parent_map.get(&a).map(|s| *s);\n+            }\n+\n+            if let Some(b) = mb {\n+                if seen.iter().position(|s| *s == b).is_some() {\n+                    return b;\n                 }\n-            };\n-        }\n+                seen.push(b);\n+                mb = self.parent_map.get(&b).map(|s| *s);\n+            }\n \n-        loop {\n-            // Loop invariant: a_ancestors[a_index] == b_ancestors[b_index]\n-            // for all indices between a_index and the end of the array\n-            if a_index == 0 { return scope_a; }\n-            if b_index == 0 { return scope_b; }\n-            a_index -= 1;\n-            b_index -= 1;\n-            if a_ancestors[a_index] != b_ancestors[b_index] {\n-                return a_ancestors[a_index + 1];\n+            if ma.is_none() && mb.is_none() {\n+                break;\n             }\n-        }\n+        };\n \n-        fn ancestors_of<'a, 'tcx>(parent_map: &FxHashMap<Scope, Scope>,\n-                                  scope: Scope,\n-                                  buf: &'a mut [Scope; 32],\n-                                  vec: &'a mut Vec<Scope>)\n-                                  -> &'a [Scope] {\n-            // debug!(\"ancestors_of(scope={:?})\", scope);\n+        fn outermost_scope(parent_map: &FxHashMap<Scope, Scope>, scope: Scope) -> Scope {\n             let mut scope = scope;\n-\n-            let mut i = 0;\n-            while i < 32 {\n-                buf[i] = scope;\n-                match parent_map.get(&scope) {\n-                    Some(&superscope) => scope = superscope,\n-                    _ => return &buf[..i+1]\n-                }\n-                i += 1;\n+            loop {\n+               match parent_map.get(&scope) {\n+                   Some(&superscope) => scope = superscope,\n+                   None => break scope,\n+               }\n             }\n+        }\n \n-            *vec = Vec::with_capacity(64);\n-            vec.extend_from_slice(buf);\n-            loop {\n-                vec.push(scope);\n-                match parent_map.get(&scope) {\n-                    Some(&superscope) => scope = superscope,\n-                    _ => return &*vec\n+        // In this (rare) case, the two regions belong to completely different\n+        // functions. Compare those fn for lexical nesting. The reasoning\n+        // behind this is subtle. See the \"Modeling closures\" section of the\n+        // README in infer::region_constraints for more details.\n+        let a_root_scope = outermost_scope(&self.parent_map, scope_a);\n+        let b_root_scope = outermost_scope(&self.parent_map, scope_b);\n+        match (a_root_scope.data(), b_root_scope.data()) {\n+            (ScopeData::Destruction(a_root_id),\n+             ScopeData::Destruction(b_root_id)) => {\n+                if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n+                    // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n+                    scope_b\n+                } else if self.closure_is_enclosed_by(b_root_id, a_root_id) {\n+                    // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n+                    scope_a\n+                } else {\n+                    // neither fn encloses the other\n+                    bug!()\n                 }\n             }\n+            _ => {\n+                // root ids are always Node right now\n+                bug!()\n+            }\n         }\n     }\n "}]}