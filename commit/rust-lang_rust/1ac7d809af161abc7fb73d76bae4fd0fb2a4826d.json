{"sha": "1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhYzdkODA5YWYxNjFhYmM3ZmI3M2Q3NmJhZTRmZDBmYjJhNDgyNmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-26T22:51:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-26T22:51:15Z"}, "message": "auto merge of #8712 : catamorphism/rust/rustpkg-issue-7241, r=pcwalton\n\nr? @brson ...multiple workspaces\r\n\r\nThe test checks that rustpkg uses the first one, rather than complaining\r\nabout multiple matches.\r\n\r\nCloses #7241", "tree": {"sha": "1c30b2194fa837aa67dddb57aadc68ea538ec704", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c30b2194fa837aa67dddb57aadc68ea538ec704"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "html_url": "https://github.com/rust-lang/rust/commit/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cd91c8cc4e87f3abd9201515eefe24f0124810c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cd91c8cc4e87f3abd9201515eefe24f0124810c", "html_url": "https://github.com/rust-lang/rust/commit/9cd91c8cc4e87f3abd9201515eefe24f0124810c"}, {"sha": "3e4e1a274a7b3bf760c7a09d1a004728c8590362", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e4e1a274a7b3bf760c7a09d1a004728c8590362", "html_url": "https://github.com/rust-lang/rust/commit/3e4e1a274a7b3bf760c7a09d1a004728c8590362"}], "stats": {"total": 165, "additions": 122, "deletions": 43}, "files": [{"sha": "757c53354a24f20f1d05d9e9475f60e0a80115ae", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "patch": "@@ -13,13 +13,15 @@ use std::option;\n use std::os;\n use std::hashmap::HashSet;\n \n+pub enum FileMatch { FileMatches, FileDoesntMatch }\n+\n // A module for searching for libraries\n // FIXME (#2658): I'm not happy how this module turned out. Should\n // probably just be folded into cstore.\n \n /// Functions with type `pick` take a parent directory as well as\n /// a file found in that directory.\n-pub type pick<'self, T> = &'self fn(path: &Path) -> Option<T>;\n+pub type pick<'self> = &'self fn(path: &Path) -> FileMatch;\n \n pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n     if path.file_path() == file {\n@@ -31,7 +33,7 @@ pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n \n pub trait FileSearch {\n     fn sysroot(&self) -> @Path;\n-    fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool;\n+    fn for_each_lib_search_path(&self, f: &fn(&Path) -> FileMatch);\n     fn get_target_lib_path(&self) -> Path;\n     fn get_target_lib_file_path(&self, file: &Path) -> Path;\n }\n@@ -47,34 +49,51 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     }\n     impl FileSearch for FileSearchImpl {\n         fn sysroot(&self) -> @Path { self.sysroot }\n-        fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool {\n+        fn for_each_lib_search_path(&self, f: &fn(&Path) -> FileMatch) {\n             let mut visited_dirs = HashSet::new();\n+            let mut found = false;\n \n             debug!(\"filesearch: searching additional lib search paths [%?]\",\n                    self.addl_lib_search_paths.len());\n             for path in self.addl_lib_search_paths.iter() {\n-                f(path);\n+                match f(path) {\n+                    FileMatches => found = true,\n+                    FileDoesntMatch => ()\n+                }\n                 visited_dirs.insert(path.to_str());\n             }\n \n             debug!(\"filesearch: searching target lib path\");\n             let tlib_path = make_target_lib_path(self.sysroot,\n                                         self.target_triple);\n             if !visited_dirs.contains(&tlib_path.to_str()) {\n-                if !f(&tlib_path) {\n-                    return false;\n+                match f(&tlib_path) {\n+                    FileMatches => found = true,\n+                    FileDoesntMatch => ()\n                 }\n             }\n             visited_dirs.insert(tlib_path.to_str());\n             // Try RUST_PATH\n-            let rustpath = rust_path();\n-            for path in rustpath.iter() {\n+            if !found {\n+                let rustpath = rust_path();\n+                for path in rustpath.iter() {\n+                    debug!(\"is %s in visited_dirs? %?\",\n+                            path.push(\"lib\").to_str(),\n+                            visited_dirs.contains(&path.push(\"lib\").to_str()));\n+\n                     if !visited_dirs.contains(&path.push(\"lib\").to_str()) {\n-                        f(&path.push(\"lib\"));\n                         visited_dirs.insert(path.push(\"lib\").to_str());\n+                        // Don't keep searching the RUST_PATH if one match turns up --\n+                        // if we did, we'd get a \"multiple matching crates\" error\n+                        match f(&path.push(\"lib\")) {\n+                           FileMatches => {\n+                               break;\n+                           }\n+                           FileDoesntMatch => ()\n+                        }\n                     }\n+                }\n             }\n-            true\n         }\n         fn get_target_lib_path(&self) -> Path {\n             make_target_lib_path(self.sysroot, self.target_triple)\n@@ -93,28 +112,26 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     } as @FileSearch\n }\n \n-pub fn search<T>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n-    let mut rslt = None;\n+pub fn search(filesearch: @FileSearch, pick: pick) {\n     do filesearch.for_each_lib_search_path() |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());\n         let r = os::list_dir_path(lib_search_path);\n+        let mut rslt = FileDoesntMatch;\n         for path in r.iter() {\n             debug!(\"testing %s\", path.to_str());\n             let maybe_picked = pick(path);\n             match maybe_picked {\n-                Some(_) => {\n+                FileMatches => {\n                     debug!(\"picked %s\", path.to_str());\n-                    rslt = maybe_picked;\n-                    break;\n+                    rslt = FileMatches;\n                 }\n-                None => {\n+                FileDoesntMatch => {\n                     debug!(\"rejected %s\", path.to_str());\n                 }\n             }\n         }\n-        rslt.is_none()\n+        rslt\n     };\n-    return rslt;\n }\n \n pub fn relative_target_lib_path(target_triple: &str) -> Path {"}, {"sha": "fbf6e3fcff8a70820a55e8f89cf9a168ce02dc17", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "patch": "@@ -14,7 +14,7 @@\n use lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n use metadata::decoder;\n use metadata::encoder;\n-use metadata::filesearch::FileSearch;\n+use metadata::filesearch::{FileSearch, FileMatch, FileMatches, FileDoesntMatch};\n use metadata::filesearch;\n use syntax::codemap::span;\n use syntax::diagnostic::span_handler;\n@@ -92,10 +92,10 @@ fn find_library_crate_aux(\n     // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n     let prefix = fmt!(\"%s%s-\", prefix, crate_name);\n     let mut matches = ~[];\n-    filesearch::search(filesearch, |path| -> Option<()> {\n+    filesearch::search(filesearch, |path| -> FileMatch {\n       let path_str = path.filename();\n       match path_str {\n-          None => None,\n+          None => FileDoesntMatch,\n           Some(path_str) =>\n               if path_str.starts_with(prefix) && path_str.ends_with(suffix) {\n                   debug!(\"%s is a candidate\", path.to_str());\n@@ -104,20 +104,20 @@ fn find_library_crate_aux(\n                           if !crate_matches(cvec, cx.metas, cx.hash) {\n                               debug!(\"skipping %s, metadata doesn't match\",\n                                   path.to_str());\n-                              None\n+                              FileDoesntMatch\n                           } else {\n                               debug!(\"found %s with matching metadata\", path.to_str());\n                               matches.push((path.to_str(), cvec));\n-                              None\n+                              FileMatches\n                           },\n                       _ => {\n                           debug!(\"could not load metadata for %s\", path.to_str());\n-                          None\n+                          FileDoesntMatch\n                       }\n                   }\n                }\n                else {\n-                   None\n+                   FileDoesntMatch\n                }\n       }\n     });"}, {"sha": "467477ca479de6fe97e2aac3f2424a31c62f4ee7", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "patch": "@@ -49,6 +49,9 @@ pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, U_RWX) }\n /// True if there's a directory in <workspace> with\n /// pkgid's short name\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n+    debug!(\"Checking in src dir of %s for %s\",\n+           workspace.to_str(), pkgid.to_str());\n+\n     let src_dir = workspace.push(\"src\");\n \n     let mut found = false;\n@@ -81,6 +84,9 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n         }\n         true\n     };\n+\n+    debug!(if found { fmt!(\"Found %s in %s\", pkgid.to_str(), workspace.to_str()) }\n+           else     { fmt!(\"Didn't find %s in %s\", pkgid.to_str(), workspace.to_str()) });\n     found\n }\n "}, {"sha": "b78460dc2243b9538bee3a29bc51b8e33d06824a", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "patch": "@@ -250,6 +250,8 @@ impl CtxMethods for Ctx {\n                     // argument\n                     let pkgid = PkgId::new(args[0]);\n                     let workspaces = pkg_parent_workspaces(&pkgid);\n+                    debug!(\"package ID = %s, found it in %? workspaces\",\n+                           pkgid.to_str(), workspaces.len());\n                     if workspaces.is_empty() {\n                         let rp = rust_path();\n                         assert!(!rp.is_empty());"}, {"sha": "9862f870bcafb0a6d1afbe603c43837458d656c9", "filename": "src/librustpkg/search.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsearch.rs?ref=1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use path_util::installed_library_in_workspace;\n+use path_util::{installed_library_in_workspace, rust_path};\n+use version::Version;\n \n /// If a library with path `p` matching pkg_id's name exists under sroot_opt,\n /// return Some(p). Return None if there's no such path or if sroot_opt is None.\n@@ -19,3 +20,18 @@ pub fn find_library_in_search_path(sroot_opt: Option<@Path>, short_name: &str) -\n         installed_library_in_workspace(short_name, sroot)\n     }\n }\n+\n+/// If some workspace `p` in the RUST_PATH contains a package matching short_name,\n+/// return Some(p) (returns the first one of there are multiple matches.) Return\n+/// None if there's no such path.\n+/// FIXME #8711: This ignores the desired version.\n+pub fn find_installed_library_in_rust_path(short_name: &str, _version: &Version) -> Option<Path> {\n+    let rp = rust_path();\n+    for p in rp.iter() {\n+        match installed_library_in_workspace(short_name, p) {\n+            Some(path) => return Some(path),\n+            None => ()\n+        }\n+    }\n+    None\n+}"}, {"sha": "fc40c2cd5f79d839ea561c03cd681ca232b5e8f3", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "patch": "@@ -686,7 +686,7 @@ fn package_script_with_default_build() {\n         push(\"testsuite\").push(\"pass\").push(\"src\").push(\"fancy-lib\").push(\"pkg.rs\");\n     debug!(\"package_script_with_default_build: %s\", source.to_str());\n     if !os::copy_file(&source,\n-                      & dir.push(\"src\").push(\"fancy-lib-0.1\").push(\"pkg.rs\")) {\n+                      &dir.push(\"src\").push(\"fancy-lib-0.1\").push(\"pkg.rs\")) {\n         fail!(\"Couldn't copy file\");\n     }\n     command_line_test([~\"install\", ~\"fancy-lib\"], &dir);\n@@ -890,20 +890,28 @@ fn no_rebuilding_dep() {\n     assert!(bar_date < foo_date);\n }\n \n+// n.b. The following two tests are ignored; they worked \"accidentally\" before,\n+// when the behavior was \"always rebuild libraries\" (now it's \"never rebuild\n+// libraries if they already exist\"). They can be un-ignored once #7075 is done.\n #[test]\n+#[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn do_rebuild_dep_dates_change() {\n     let p_id = PkgId::new(\"foo\");\n     let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    let bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n+    let bar_lib_name = lib_output_file_name(&workspace, \"build\", \"bar\");\n+    let bar_date = datestamp(&bar_lib_name);\n+    debug!(\"Datestamp on %s is %?\", bar_lib_name.to_str(), bar_date);\n     touch_source_file(&workspace, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    let new_bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n+    let new_bar_date = datestamp(&bar_lib_name);\n+    debug!(\"Datestamp on %s is %?\", bar_lib_name.to_str(), new_bar_date);\n     assert!(new_bar_date > bar_date);\n }\n \n #[test]\n+#[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn do_rebuild_dep_only_contents_change() {\n     let p_id = PkgId::new(\"foo\");\n     let dep_id = PkgId::new(\"bar\");\n@@ -1060,6 +1068,23 @@ fn test_macro_pkg_script() {\n         os::EXE_SUFFIX))));\n }\n \n+#[test]\n+fn multiple_workspaces() {\n+// Make a package foo; build/install in directory A\n+// Copy the exact same package into directory B and install it\n+// Set the RUST_PATH to A:B\n+// Make a third package that uses foo, make sure we can build/install it\n+    let a_loc = mk_temp_workspace(&Path(\"foo\"), &NoVersion).pop().pop();\n+    let b_loc = mk_temp_workspace(&Path(\"foo\"), &NoVersion).pop().pop();\n+    debug!(\"Trying to install foo in %s\", a_loc.to_str());\n+    command_line_test([~\"install\", ~\"foo\"], &a_loc);\n+    debug!(\"Trying to install foo in %s\", b_loc.to_str());\n+    command_line_test([~\"install\", ~\"foo\"], &b_loc);\n+    let env = Some(~[(~\"RUST_PATH\", fmt!(\"%s:%s\", a_loc.to_str(), b_loc.to_str()))]);\n+    let c_loc = create_local_package_with_dep(&PkgId::new(\"bar\"), &PkgId::new(\"foo\"));\n+    command_line_test_with_env([~\"install\", ~\"bar\"], &c_loc, env);\n+}\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};"}, {"sha": "4bdb442c1e61920d98287fb985f3de1178e75dc8", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "patch": "@@ -20,9 +20,10 @@ use rustc::back::link::output_type_exe;\n use rustc::driver::session::{lib_crate, bin_crate};\n use context::{Ctx, in_target};\n use package_id::PkgId;\n-use search::find_library_in_search_path;\n+use search::{find_library_in_search_path, find_installed_library_in_rust_path};\n use path_util::{target_library_in_workspace, U_RWX};\n pub use target::{OutputType, Main, Lib, Bench, Test};\n+use version::NoVersion;\n \n // It would be nice to have the list of commands in just one place -- for example,\n // you could update the match in rustpkg.rc but forget to update this list. I think\n@@ -360,18 +361,32 @@ pub fn find_and_install_dependencies(ctxt: &Ctx,\n                         debug!(\"It exists: %s\", installed_path.to_str());\n                     }\n                     None => {\n-                        // Try to install it\n-                        let pkg_id = PkgId::new(lib_name);\n-                        my_ctxt.install(&my_workspace, &pkg_id);\n-                        // Also, add an additional search path\n-                        debug!(\"let installed_path...\")\n-                        let installed_path = target_library_in_workspace(&pkg_id,\n+                        // FIXME #8711: need to parse version out of path_opt\n+                        match find_installed_library_in_rust_path(lib_name, &NoVersion) {\n+                            Some(installed_path) => {\n+                               debug!(\"Found library %s, not rebuilding it\",\n+                                      installed_path.to_str());\n+                               // Once workcache is implemented, we'll actually check\n+                               // whether or not the library at installed_path is fresh\n+                               save(installed_path.pop());\n+                            }\n+                            None => {\n+                               debug!(\"Trying to install library %s, rebuilding it\",\n+                                      lib_name.to_str());\n+                               // Try to install it\n+                               let pkg_id = PkgId::new(lib_name);\n+                               my_ctxt.install(&my_workspace, &pkg_id);\n+                               // Also, add an additional search path\n+                               debug!(\"let installed_path...\")\n+                               let installed_path = target_library_in_workspace(&pkg_id,\n                                                                          &my_workspace).pop();\n-                        debug!(\"Great, I installed %s, and it's in %s\",\n-                               lib_name, installed_path.to_str());\n-                        save(installed_path);\n+                               debug!(\"Great, I installed %s, and it's in %s\",\n+                                   lib_name, installed_path.to_str());\n+                               save(installed_path);\n+                           }\n                     }\n                 }\n+              }\n             }\n             // Ignore `use`s\n             _ => ()"}, {"sha": "4528a02db19785502de817c9483636c59d25f7c5", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac7d809af161abc7fb73d76bae4fd0fb2a4826d/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=1ac7d809af161abc7fb73d76bae4fd0fb2a4826d", "patch": "@@ -213,11 +213,9 @@ fn is_url_like(p: &Path) -> bool {\n pub fn split_version<'a>(s: &'a str) -> Option<(&'a str, Version)> {\n     // Check for extra '#' characters separately\n     if s.split_iter('#').len() > 2 {\n-        None\n-    }\n-    else {\n-        split_version_general(s, '#')\n+        return None;\n     }\n+    split_version_general(s, '#')\n }\n \n pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Version)> {"}]}