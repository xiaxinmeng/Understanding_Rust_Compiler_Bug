{"sha": "c1ba28c7779a68b74b26ef70acd81d324d97e7dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYmEyOGM3Nzc5YTY4Yjc0YjI2ZWY3MGFjZDgxZDMyNGQ5N2U3ZGM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-30T07:59:30Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-30T11:04:57Z"}, "message": "Glob-import trans_build in other trans files\n\nThe capitalization already prevents name clashes. Being able to refer to the\nbitcode-construction primitives directly makes the code cleaner.", "tree": {"sha": "a5f8bf7b1f265ff300a10c8a5ca624f6fecb1f9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5f8bf7b1f265ff300a10c8a5ca624f6fecb1f9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1ba28c7779a68b74b26ef70acd81d324d97e7dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1ba28c7779a68b74b26ef70acd81d324d97e7dc", "html_url": "https://github.com/rust-lang/rust/commit/c1ba28c7779a68b74b26ef70acd81d324d97e7dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1ba28c7779a68b74b26ef70acd81d324d97e7dc/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41fb042def23e93742357238e0ea4fd2c6ec0f19", "url": "https://api.github.com/repos/rust-lang/rust/commits/41fb042def23e93742357238e0ea4fd2c6ec0f19", "html_url": "https://github.com/rust-lang/rust/commit/41fb042def23e93742357238e0ea4fd2c6ec0f19"}], "stats": {"total": 899, "additions": 449, "deletions": 450}, "files": [{"sha": "d3f169716d3f1047dc366dea95f5cae0b8a33e16", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 375, "deletions": 375, "changes": 750, "blob_url": "https://github.com/rust-lang/rust/blob/c1ba28c7779a68b74b26ef70acd81d324d97e7dc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ba28c7779a68b74b26ef70acd81d324d97e7dc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c1ba28c7779a68b74b26ef70acd81d324d97e7dc", "patch": "@@ -70,7 +70,7 @@ import syntax::print::pprust::expr_to_str;\n import syntax::print::pprust::path_to_str;\n \n import trans_common::*;\n-import bld = trans_build;\n+import trans_build::*;\n \n import trans_objects::trans_anon_obj;\n import trans_objects::trans_obj;\n@@ -399,38 +399,38 @@ fn trans_native_call(cx: &@block_ctxt, externs: &hashmap<istr, ValueRef>,\n     let llnative: ValueRef = get_simple_extern_fn(externs, llmod, name, n);\n     let call_args: [ValueRef] = [];\n     for a: ValueRef in args {\n-        call_args += [bld::ZExtOrBitCast(cx, a, T_int())];\n+        call_args += [ZExtOrBitCast(cx, a, T_int())];\n     }\n-    ret bld::Call(cx, llnative, call_args);\n+    ret Call(cx, llnative, call_args);\n }\n \n fn trans_non_gc_free(cx: &@block_ctxt, v: ValueRef) -> result {\n-    bld::Call(cx, bcx_ccx(cx).upcalls.free,\n-                  [cx.fcx.lltaskptr, bld::PointerCast(cx, v, T_ptr(T_i8())),\n+    Call(cx, bcx_ccx(cx).upcalls.free,\n+                  [cx.fcx.lltaskptr, PointerCast(cx, v, T_ptr(T_i8())),\n                    C_int(0)]);\n     ret rslt(cx, C_int(0));\n }\n \n fn trans_shared_free(cx: &@block_ctxt, v: ValueRef) -> result {\n-    bld::Call(cx, bcx_ccx(cx).upcalls.shared_free,\n-                  [cx.fcx.lltaskptr, bld::PointerCast(cx, v, T_ptr(T_i8()))]);\n+    Call(cx, bcx_ccx(cx).upcalls.shared_free,\n+                  [cx.fcx.lltaskptr, PointerCast(cx, v, T_ptr(T_i8()))]);\n     ret rslt(cx, C_int(0));\n }\n \n fn umax(cx: &@block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let cond = bld::ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n-    ret bld::Select(cx, cond, b, a);\n+    let cond = ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n+    ret Select(cx, cond, b, a);\n }\n \n fn umin(cx: &@block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let cond = bld::ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n-    ret bld::Select(cx, cond, a, b);\n+    let cond = ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n+    ret Select(cx, cond, a, b);\n }\n \n fn align_to(cx: &@block_ctxt, off: ValueRef, align: ValueRef) -> ValueRef {\n-    let mask = bld::Sub(cx, align, C_int(1));\n-    let bumped = bld::Add(cx, off, mask);\n-    ret bld::And(cx, bumped, bld::Not(cx, mask));\n+    let mask = Sub(cx, align, C_int(1));\n+    let bumped = Add(cx, off, mask);\n+    ret And(cx, bumped, Not(cx, mask));\n }\n \n \n@@ -469,7 +469,7 @@ fn align_of(cx: &@block_ctxt, t: ty::t) -> result {\n }\n \n fn alloca(cx: &@block_ctxt, t: TypeRef) -> ValueRef {\n-    ret bld::Alloca(new_raw_block_ctxt(cx.fcx, cx.fcx.llstaticallocas), t);\n+    ret Alloca(new_raw_block_ctxt(cx.fcx, cx.fcx.llstaticallocas), t);\n }\n \n fn array_alloca(cx: &@block_ctxt, t: TypeRef, n: ValueRef) -> ValueRef {\n@@ -485,15 +485,15 @@ fn array_alloca(cx: &@block_ctxt, t: TypeRef, n: ValueRef) -> ValueRef {\n     }\n \n     let dynastack_alloc = bcx_ccx(bcx).upcalls.dynastack_alloc;\n-    let llsz = bld::Mul(dy_cx, C_uint(llsize_of_real(bcx_ccx(bcx), t)), n);\n-    let llresult = bld::Call(dy_cx, dynastack_alloc, [lltaskptr, llsz]);\n-    ret bld::PointerCast(dy_cx, llresult, T_ptr(t));\n+    let llsz = Mul(dy_cx, C_uint(llsize_of_real(bcx_ccx(bcx), t)), n);\n+    let llresult = Call(dy_cx, dynastack_alloc, [lltaskptr, llsz]);\n+    ret PointerCast(dy_cx, llresult, T_ptr(t));\n }\n \n fn mk_obstack_token(ccx: &@crate_ctxt, fcx: @fn_ctxt,\n                     lltaskptr: ValueRef) -> ValueRef {\n     let cx = new_raw_block_ctxt(fcx, fcx.lldynamicallocas);\n-    ret bld::Call(cx, ccx.upcalls.dynastack_mark, [lltaskptr]);\n+    ret Call(cx, ccx.upcalls.dynastack_mark, [lltaskptr]);\n }\n \n \n@@ -581,7 +581,7 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n             let elt_size = size_of(bcx, e);\n             bcx = elt_size.bcx;\n             let aligned_off = align_to(bcx, off, elt_align.val);\n-            off = bld::Add(bcx, aligned_off, elt_size.val);\n+            off = Add(bcx, aligned_off, elt_size.val);\n             max_align = umax(bcx, max_align, elt_align.val);\n         }\n         off = align_to(bcx, off, max_align);\n@@ -590,7 +590,7 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_param(p, _) {\n         let szptr = field_of_tydesc(cx, t, false, abi::tydesc_field_size);\n-        ret rslt(szptr.bcx, bld::Load(szptr.bcx, szptr.val));\n+        ret rslt(szptr.bcx, Load(szptr.bcx, szptr.val));\n       }\n       ty::ty_rec(flds) {\n         let tys: [ty::t] = [];\n@@ -607,7 +607,7 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n         // Compute max(variant sizes).\n \n         let max_size: ValueRef = alloca(bcx, T_int());\n-        bld::Store(bcx, C_int(0), max_size);\n+        Store(bcx, C_int(0), max_size);\n         let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n         for variant: ty::variant_info in variants {\n             // Perform type substitution on the raw argument types.\n@@ -621,13 +621,13 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n             let rslt = align_elements(bcx, tys);\n             bcx = rslt.bcx;\n             let this_size = rslt.val;\n-            let old_max_size = bld::Load(bcx, max_size);\n-            bld::Store(bcx, umax(bcx, this_size, old_max_size), max_size);\n+            let old_max_size = Load(bcx, max_size);\n+            Store(bcx, umax(bcx, this_size, old_max_size), max_size);\n         }\n-        let max_size_val = bld::Load(bcx, max_size);\n+        let max_size_val = Load(bcx, max_size);\n         let total_size =\n             if std::vec::len(variants) != 1u {\n-                bld::Add(bcx, max_size_val, llsize_of(T_int()))\n+                Add(bcx, max_size_val, llsize_of(T_int()))\n             } else { max_size_val };\n         ret rslt(bcx, total_size);\n       }\n@@ -638,7 +638,7 @@ fn dynamic_align_of(cx: &@block_ctxt, t: ty::t) -> result {\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_param(p, _) {\n         let aptr = field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n-        ret rslt(aptr.bcx, bld::Load(aptr.bcx, aptr.val));\n+        ret rslt(aptr.bcx, Load(aptr.bcx, aptr.val));\n       }\n       ty::ty_rec(flds) {\n         let a = C_int(1);\n@@ -671,18 +671,18 @@ fn dynamic_align_of(cx: &@block_ctxt, t: ty::t) -> result {\n fn GEPi(cx: &@block_ctxt, base: ValueRef, ixs: &[int]) -> ValueRef {\n     let v: [ValueRef] = [];\n     for i: int in ixs { v += [C_int(i)]; }\n-    ret bld::InBoundsGEP(cx, base, v);\n+    ret InBoundsGEP(cx, base, v);\n }\n \n // Increment a pointer by a given amount and then cast it to be a pointer\n // to a given type.\n fn bump_ptr(bcx: &@block_ctxt, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n-    let raw = bld::PointerCast(bcx, base, T_ptr(T_i8()));\n-    let bumped = bld::GEP(bcx, raw, [sz]);\n+    let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n+    let bumped = GEP(bcx, raw, [sz]);\n     if ty::type_has_dynamic_size(bcx_tcx(bcx), t) { ret bumped; }\n     let typ = T_ptr(type_of(bcx_ccx(bcx), bcx.sp, t));\n-    ret bld::PointerCast(bcx, bumped, typ);\n+    ret PointerCast(bcx, bumped, typ);\n }\n \n // Replacement for the LLVM 'GEP' instruction when field-indexing into a\n@@ -796,7 +796,7 @@ fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: &ast::def_id,\n     let llunionptr: ValueRef;\n     if !ty::type_has_dynamic_size(bcx_tcx(cx), tup_ty) {\n         let llty = type_of(bcx_ccx(cx), cx.sp, tup_ty);\n-        llunionptr = bld::TruncOrBitCast(cx, llblobptr, T_ptr(llty));\n+        llunionptr = TruncOrBitCast(cx, llblobptr, T_ptr(llty));\n     } else { llunionptr = llblobptr; }\n     // Do the GEP_tup_like().\n \n@@ -806,7 +806,7 @@ fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: &ast::def_id,\n     let val;\n     if !ty::type_has_dynamic_size(bcx_tcx(cx), elem_ty) {\n         let llelemty = type_of(bcx_ccx(rs.bcx), cx.sp, elem_ty);\n-        val = bld::PointerCast(rs.bcx, rs.val, T_ptr(llelemty));\n+        val = PointerCast(rs.bcx, rs.val, T_ptr(llelemty));\n     } else { val = rs.val; }\n     ret rslt(rs.bcx, val);\n }\n@@ -819,9 +819,9 @@ fn trans_raw_malloc(cx: &@block_ctxt, llptr_ty: TypeRef, llsize: ValueRef) ->\n \n     let tydesc = C_null(T_ptr(bcx_ccx(cx).tydesc_type));\n     let rval =\n-        bld::Call(cx, bcx_ccx(cx).upcalls.malloc,\n+        Call(cx, bcx_ccx(cx).upcalls.malloc,\n                       [cx.fcx.lltaskptr, llsize, tydesc]);\n-    ret rslt(cx, bld::PointerCast(cx, rval, llptr_ty));\n+    ret rslt(cx, PointerCast(cx, rval, llptr_ty));\n }\n \n // trans_shared_malloc: expects a type indicating which pointer type we want\n@@ -832,9 +832,9 @@ fn trans_shared_malloc(cx: &@block_ctxt, llptr_ty: TypeRef, llsize: ValueRef)\n \n     let tydesc = C_null(T_ptr(bcx_ccx(cx).tydesc_type));\n     let rval =\n-        bld::Call(cx, bcx_ccx(cx).upcalls.shared_malloc,\n+        Call(cx, bcx_ccx(cx).upcalls.shared_malloc,\n                       [cx.fcx.lltaskptr, llsize, tydesc]);\n-    ret rslt(cx, bld::PointerCast(cx, rval, llptr_ty));\n+    ret rslt(cx, PointerCast(cx, rval, llptr_ty));\n }\n \n // trans_malloc_boxed_raw: expects an unboxed type and returns a pointer to\n@@ -868,7 +868,7 @@ fn trans_malloc_boxed(cx: &@block_ctxt, t: ty::t) ->\n     let res = trans_malloc_boxed_raw(cx, t);\n     let box = res.val;\n     let rc = GEPi(res.bcx, box, [0, abi::box_rc_field_refcnt]);\n-    bld::Store(res.bcx, C_int(1), rc);\n+    Store(res.bcx, C_int(1), rc);\n     let body = GEPi(res.bcx, box, [0, abi::box_rc_field_body]);\n     ret {bcx: res.bcx, box: res.val, body: body};\n }\n@@ -883,7 +883,7 @@ fn field_of_tydesc(cx: &@block_ctxt, t: ty::t, escapes: bool, field: int) ->\n     let ti = none::<@tydesc_info>;\n     let tydesc = get_tydesc(cx, t, escapes, tps_normal, ti).result;\n     ret rslt(tydesc.bcx,\n-             bld::GEP(tydesc.bcx, tydesc.val, [C_int(0), C_int(field)]));\n+             GEP(tydesc.bcx, tydesc.val, [C_int(0), C_int(field)]));\n }\n \n \n@@ -922,8 +922,8 @@ fn trans_stack_local_derived_tydesc(cx: &@block_ctxt, llsz: ValueRef,\n     let llmyroottydesc = alloca(cx, bcx_ccx(cx).tydesc_type);\n \n     // By convention, desc 0 is the root descriptor.\n-    llroottydesc = bld::Load(cx, llroottydesc);\n-    bld::Store(cx, llroottydesc, llmyroottydesc);\n+    llroottydesc = Load(cx, llroottydesc);\n+    Store(cx, llroottydesc, llmyroottydesc);\n \n     // Store a pointer to the rest of the descriptors.\n     store_inbounds(cx, llfirstparam, llmyroottydesc,\n@@ -989,17 +989,17 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: ty::t, escapes: bool,\n     // If the type descriptor escapes, we need to add in the root as\n     // the first parameter, because upcall_get_type_desc() expects it.\n     if escapes {\n-        bld::Store(bcx, root, GEPi(bcx, llparamtydescs, [0, 0]));\n+        Store(bcx, root, GEPi(bcx, llparamtydescs, [0, 0]));\n         i += 1;\n     }\n \n     for td: ValueRef in tys.descs {\n-        bld::Store(bcx, td, GEPi(bcx, llparamtydescs, [0, i]));\n+        Store(bcx, td, GEPi(bcx, llparamtydescs, [0, i]));\n         i += 1;\n     }\n \n     let llfirstparam =\n-        bld::PointerCast(bcx, llparamtydescs,\n+        PointerCast(bcx, llparamtydescs,\n                          T_ptr(T_ptr(bcx_ccx(bcx).tydesc_type)));\n \n     // The top bit indicates whether this type descriptor describes an object\n@@ -1014,7 +1014,7 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: ty::t, escapes: bool,\n     let v;\n     if escapes {\n         let td_val =\n-            bld::Call(bcx, bcx_ccx(bcx).upcalls.get_type_desc,\n+            Call(bcx, bcx_ccx(bcx).upcalls.get_type_desc,\n                            [bcx.fcx.lltaskptr, C_null(T_ptr(T_nil())), sz.val,\n                             align.val, C_uint(1u + n_params),\n                             llfirstparam, C_uint(obj_params)]);\n@@ -1192,8 +1192,8 @@ fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: ty::t,\n     let lltydescs = [mutable];\n     let p = 0u;\n     while p < ty_param_count {\n-        let llparam = bld::GEP(copy_args_bcx, lltyparams, [C_int(p as int)]);\n-        llparam = bld::Load(copy_args_bcx, llparam);\n+        let llparam = GEP(copy_args_bcx, lltyparams, [C_int(p as int)]);\n+        llparam = Load(copy_args_bcx, llparam);\n         std::vec::grow_set(lltydescs, ty_params[p], 0 as ValueRef, llparam);\n         p += 1u;\n     }\n@@ -1206,14 +1206,14 @@ fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: ty::t,\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n     let llrawptr0 = llvm::LLVMGetParam(llfn, 4u);\n-    let llval0 = bld::BitCast(bcx, llrawptr0, llty);\n+    let llval0 = BitCast(bcx, llrawptr0, llty);\n     alt helper {\n       default_helper(helper) {\n         helper(bcx, llval0, t);\n       }\n       copy_helper(helper) {\n         let llrawptr1 = llvm::LLVMGetParam(llfn, 5u);\n-        let llval1 = bld::BitCast(bcx, llrawptr1, llty);\n+        let llval1 = BitCast(bcx, llrawptr1, llty);\n         helper(bcx, llval0, llval1, t);\n       }\n     }\n@@ -1312,7 +1312,7 @@ fn make_take_glue(cx: &@block_ctxt, v: ValueRef, t: ty::t) {\n     let bcx = cx;\n     // NB: v is an *alias* of type t here, not a direct value.\n     if ty::type_is_boxed(bcx_tcx(bcx), t) {\n-        bcx = incr_refcnt_of_boxed(bcx, bld::Load(bcx, v)).bcx;\n+        bcx = incr_refcnt_of_boxed(bcx, Load(bcx, v)).bcx;\n     } else if ty::type_is_structural(bcx_tcx(bcx), t) {\n         bcx = iter_structural_ty(bcx, v, t, take_ty).bcx;\n     } else if ty::type_is_ivec(bcx_tcx(bcx), t) {\n@@ -1325,17 +1325,17 @@ fn make_take_glue(cx: &@block_ctxt, v: ValueRef, t: ty::t) {\n \n fn incr_refcnt_of_boxed(cx: &@block_ctxt, box_ptr: ValueRef) -> result {\n     let rc_ptr =\n-        bld::GEP(cx, box_ptr, [C_int(0), C_int(abi::box_rc_field_refcnt)]);\n-    let rc = bld::Load(cx, rc_ptr);\n+        GEP(cx, box_ptr, [C_int(0), C_int(abi::box_rc_field_refcnt)]);\n+    let rc = Load(cx, rc_ptr);\n     let rc_adj_cx = new_sub_block_ctxt(cx, ~\"rc++\");\n     let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n     let const_test =\n-        bld::ICmp(cx, lib::llvm::LLVMIntEQ, C_int(abi::const_refcount as int),\n+        ICmp(cx, lib::llvm::LLVMIntEQ, C_int(abi::const_refcount as int),\n                       rc);\n-    bld::CondBr(cx, const_test, next_cx.llbb, rc_adj_cx.llbb);\n-    rc = bld::Add(rc_adj_cx, rc, C_int(1));\n-    bld::Store(rc_adj_cx, rc, rc_ptr);\n-    bld::Br(rc_adj_cx, next_cx.llbb);\n+    CondBr(cx, const_test, next_cx.llbb, rc_adj_cx.llbb);\n+    rc = Add(rc_adj_cx, rc, C_int(1));\n+    Store(rc_adj_cx, rc, rc_ptr);\n+    Br(rc_adj_cx, next_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n \n@@ -1344,15 +1344,15 @@ fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n     let rs =\n         alt ty::struct(bcx_tcx(cx), t) {\n           ty::ty_str. {\n-            let v = bld::Load(cx, v0);\n+            let v = Load(cx, v0);\n             if !bcx_ccx(cx).sess.get_opts().do_gc {\n                 trans_non_gc_free(cx, v)\n             } else { rslt(cx, C_nil()) }\n           }\n           ty::ty_box(body_mt) {\n-            let v = bld::Load(cx, v0);\n+            let v = Load(cx, v0);\n             let body =\n-                bld::GEP(cx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n+                GEP(cx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n             let body_ty = body_mt.ty;\n             let rs = drop_ty(cx, body, body_ty);\n             if !bcx_ccx(cx).sess.get_opts().do_gc {\n@@ -1364,17 +1364,17 @@ fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n             // Call through the obj's own fields-drop glue first.\n             // Then free the body.\n             let box_cell =\n-                bld::GEP(cx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n-            let b = bld::Load(cx, box_cell);\n+                GEP(cx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n+            let b = Load(cx, box_cell);\n             let ccx = bcx_ccx(cx);\n             let llbox_ty = T_opaque_obj_ptr(*ccx);\n-            b = bld::PointerCast(cx, b, llbox_ty);\n+            b = PointerCast(cx, b, llbox_ty);\n             let body =\n-                bld::GEP(cx, b, [C_int(0), C_int(abi::box_rc_field_body)]);\n+                GEP(cx, b, [C_int(0), C_int(abi::box_rc_field_body)]);\n             let tydescptr =\n-                bld::GEP(cx, body,\n+                GEP(cx, body,\n                              [C_int(0), C_int(abi::obj_body_elt_tydesc)]);\n-            let tydesc = bld::Load(cx, tydescptr);\n+            let tydesc = Load(cx, tydescptr);\n             let ti = none::<@tydesc_info>;\n             call_tydesc_glue_full(cx, body, tydesc,\n                                   abi::tydesc_field_drop_glue, ti);\n@@ -1386,18 +1386,18 @@ fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n             // Call through the closure's own fields-drop glue first.\n             // Then free the body.\n             let box_cell =\n-                bld::GEP(cx, v0, [C_int(0), C_int(abi::fn_field_box)]);\n-            let v = bld::Load(cx, box_cell);\n+                GEP(cx, v0, [C_int(0), C_int(abi::fn_field_box)]);\n+            let v = Load(cx, box_cell);\n             let body =\n-                bld::GEP(cx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n+                GEP(cx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n             let bindings =\n-                bld::GEP(cx, body,\n+                GEP(cx, body,\n                              [C_int(0), C_int(abi::closure_elt_bindings)]);\n             let tydescptr =\n-                bld::GEP(cx, body,\n+                GEP(cx, body,\n                              [C_int(0), C_int(abi::closure_elt_tydesc)]);\n             let ti = none::<@tydesc_info>;\n-            call_tydesc_glue_full(cx, bindings, bld::Load(cx, tydescptr),\n+            call_tydesc_glue_full(cx, bindings, Load(cx, tydescptr),\n                                   abi::tydesc_field_drop_glue, ti);\n             if !bcx_ccx(cx).sess.get_opts().do_gc {\n                 trans_non_gc_free(cx, v)\n@@ -1422,18 +1422,18 @@ fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n             rslt(ivec::make_drop_glue(cx, v0, t), C_nil())\n           }\n           ty::ty_box(_) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n-          ty::ty_uniq(_) { trans_shared_free(cx, bld::Load(cx, v0)) }\n+          ty::ty_uniq(_) { trans_shared_free(cx, Load(cx, v0)) }\n           ty::ty_obj(_) {\n             let box_cell =\n-                bld::GEP(cx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n+                GEP(cx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n             decr_refcnt_maybe_free(cx, box_cell, v0, t)\n           }\n           ty::ty_res(did, inner, tps) {\n             trans_res_drop(cx, v0, did, inner, tps)\n           }\n           ty::ty_fn(_, _, _, _, _) {\n             let box_cell =\n-                bld::GEP(cx, v0, [C_int(0), C_int(abi::fn_field_box)]);\n+                GEP(cx, v0, [C_int(0), C_int(abi::fn_field_box)]);\n             decr_refcnt_maybe_free(cx, box_cell, v0, t)\n           }\n           _ {\n@@ -1457,19 +1457,19 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n \n     let drop_flag = GEP_tup_like(cx, tup_ty, rs, [0, 0]);\n     cx = drop_flag.bcx;\n-    let null_test = bld::IsNull(cx, bld::Load(cx, drop_flag.val));\n-    bld::CondBr(cx, null_test, next_cx.llbb, drop_cx.llbb);\n+    let null_test = IsNull(cx, Load(cx, drop_flag.val));\n+    CondBr(cx, null_test, next_cx.llbb, drop_cx.llbb);\n     cx = drop_cx;\n \n     let val = GEP_tup_like(cx, tup_ty, rs, [0, 1]);\n     cx = val.bcx;\n     // Find and call the actual destructor.\n     let dtor_pair = trans_common::get_res_dtor(ccx, cx.sp, did, inner_t);\n     let dtor_addr =\n-        bld::Load(cx, bld::GEP(cx, dtor_pair,\n+        Load(cx, GEP(cx, dtor_pair,\n                                    [C_int(0), C_int(abi::fn_field_code)]));\n     let dtor_env =\n-        bld::Load(cx, bld::GEP(cx, dtor_pair,\n+        Load(cx, GEP(cx, dtor_pair,\n                                    [C_int(0), C_int(abi::fn_field_box)]));\n     let args = [cx.fcx.llretptr, cx.fcx.lltaskptr, dtor_env];\n     for tp: ty::t in tps {\n@@ -1485,12 +1485,12 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n         lib::llvm::fn_ty_param_tys(\n             llvm::LLVMGetElementType(\n                 llvm::LLVMTypeOf(dtor_addr)))[std::vec::len(args)];\n-    let val_cast = bld::BitCast(cx, val.val, val_llty);\n-    bld::FastCall(cx, dtor_addr, args + [val_cast]);\n+    let val_cast = BitCast(cx, val.val, val_llty);\n+    FastCall(cx, dtor_addr, args + [val_cast]);\n \n     cx = drop_ty(cx, val.val, inner_t_s).bcx;\n-    bld::Store(cx, C_int(0), drop_flag.val);\n-    bld::Br(cx, next_cx.llbb);\n+    Store(cx, C_int(0), drop_flag.val);\n+    Br(cx, next_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n \n@@ -1501,30 +1501,30 @@ fn decr_refcnt_maybe_free(cx: &@block_ctxt, box_ptr_alias: ValueRef,\n     let rc_adj_cx = new_sub_block_ctxt(cx, ~\"rc--\");\n     let free_cx = new_sub_block_ctxt(cx, ~\"free\");\n     let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n-    let box_ptr = bld::Load(cx, box_ptr_alias);\n+    let box_ptr = Load(cx, box_ptr_alias);\n     let llbox_ty = T_opaque_obj_ptr(*ccx);\n-    box_ptr = bld::PointerCast(cx, box_ptr, llbox_ty);\n-    let null_test = bld::IsNull(cx, box_ptr);\n-    bld::CondBr(cx, null_test, next_cx.llbb, load_rc_cx.llbb);\n+    box_ptr = PointerCast(cx, box_ptr, llbox_ty);\n+    let null_test = IsNull(cx, box_ptr);\n+    CondBr(cx, null_test, next_cx.llbb, load_rc_cx.llbb);\n     let rc_ptr =\n-        bld::GEP(load_rc_cx, box_ptr,\n+        GEP(load_rc_cx, box_ptr,\n                              [C_int(0), C_int(abi::box_rc_field_refcnt)]);\n-    let rc = bld::Load(load_rc_cx, rc_ptr);\n+    let rc = Load(load_rc_cx, rc_ptr);\n     let const_test =\n-        bld::ICmp(load_rc_cx, lib::llvm::LLVMIntEQ,\n+        ICmp(load_rc_cx, lib::llvm::LLVMIntEQ,\n                               C_int(abi::const_refcount as int), rc);\n-    bld::CondBr(load_rc_cx, const_test, next_cx.llbb, rc_adj_cx.llbb);\n-    rc = bld::Sub(rc_adj_cx, rc, C_int(1));\n-    bld::Store(rc_adj_cx, rc, rc_ptr);\n-    let zero_test = bld::ICmp(rc_adj_cx, lib::llvm::LLVMIntEQ, C_int(0), rc);\n-    bld::CondBr(rc_adj_cx, zero_test, free_cx.llbb, next_cx.llbb);\n+    CondBr(load_rc_cx, const_test, next_cx.llbb, rc_adj_cx.llbb);\n+    rc = Sub(rc_adj_cx, rc, C_int(1));\n+    Store(rc_adj_cx, rc, rc_ptr);\n+    let zero_test = ICmp(rc_adj_cx, lib::llvm::LLVMIntEQ, C_int(0), rc);\n+    CondBr(rc_adj_cx, zero_test, free_cx.llbb, next_cx.llbb);\n     let free_res =\n         free_ty(free_cx, full_alias, t);\n-    bld::Br(free_res.bcx, next_cx.llbb);\n+    Br(free_res.bcx, next_cx.llbb);\n     let t_else = T_nil();\n     let v_else = C_nil();\n     let phi =\n-        bld::Phi(next_cx, t_else, [v_else, v_else, v_else, free_res.val],\n+        Phi(next_cx, t_else, [v_else, v_else, v_else, free_res.val],\n                           [cx.llbb, load_rc_cx.llbb, rc_adj_cx.llbb,\n                            free_res.bcx.llbb]);\n     ret rslt(next_cx, phi);\n@@ -1622,7 +1622,7 @@ fn compare_scalar_values(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef,\n     }\n     // FIXME: This wouldn't be necessary if we could bind methods off of\n     // objects and therefore abstract over FCmp and ICmp (issue #435).  Then\n-    // we could just write, e.g., \"cmp_fn = bind bld::FCmp(cx, _, _, _);\" in\n+    // we could just write, e.g., \"cmp_fn = bind FCmp(cx, _, _, _);\" in\n     // the above, and \"auto eq_result = cmp_fn(eq_cmp, lhs, rhs);\" in the\n     // below.\n \n@@ -1632,28 +1632,28 @@ fn compare_scalar_values(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef,\n         if nt == nil_type {\n             r = C_bool(op != 0u);\n         } else if nt == floating_point {\n-            r = bld::FCmp(cx, op, lhs, rhs);\n-        } else { r = bld::ICmp(cx, op, lhs, rhs); }\n+            r = FCmp(cx, op, lhs, rhs);\n+        } else { r = ICmp(cx, op, lhs, rhs); }\n         ret r;\n     }\n     let last_cx = new_sub_block_ctxt(cx, ~\"last\");\n     let eq_cx = new_sub_block_ctxt(cx, ~\"eq\");\n     let eq_result = generic_cmp(eq_cx, nt, eq_cmp, lhs, rhs);\n-    bld::Br(eq_cx, last_cx.llbb);\n+    Br(eq_cx, last_cx.llbb);\n     let lt_cx = new_sub_block_ctxt(cx, ~\"lt\");\n     let lt_result = generic_cmp(lt_cx, nt, lt_cmp, lhs, rhs);\n-    bld::Br(lt_cx, last_cx.llbb);\n+    Br(lt_cx, last_cx.llbb);\n     let le_cx = new_sub_block_ctxt(cx, ~\"le\");\n     let le_result = generic_cmp(le_cx, nt, le_cmp, lhs, rhs);\n-    bld::Br(le_cx, last_cx.llbb);\n+    Br(le_cx, last_cx.llbb);\n     let unreach_cx = new_sub_block_ctxt(cx, ~\"unreach\");\n-    bld::Unreachable(unreach_cx);\n-    let llswitch = bld::Switch(cx, llop, unreach_cx.llbb, 3u);\n+    Unreachable(unreach_cx);\n+    let llswitch = Switch(cx, llop, unreach_cx.llbb, 3u);\n     llvm::LLVMAddCase(llswitch, C_u8(abi::cmp_glue_op_eq), eq_cx.llbb);\n     llvm::LLVMAddCase(llswitch, C_u8(abi::cmp_glue_op_lt), lt_cx.llbb);\n     llvm::LLVMAddCase(llswitch, C_u8(abi::cmp_glue_op_le), le_cx.llbb);\n     let last_result =\n-        bld::Phi(last_cx, T_i1(), [eq_result, lt_result, le_result],\n+        Phi(last_cx, T_i1(), [eq_result, lt_result, le_result],\n                           [eq_cx.llbb, lt_cx.llbb, le_cx.llbb]);\n     ret rslt(last_cx, last_result);\n }\n@@ -1676,33 +1676,33 @@ fn iter_structural_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t,\n \n fn load_inbounds(cx: &@block_ctxt, p: ValueRef, idxs: &[ValueRef]) ->\n    ValueRef {\n-    ret bld::Load(cx, bld::InBoundsGEP(cx, p, idxs));\n+    ret Load(cx, InBoundsGEP(cx, p, idxs));\n }\n \n fn store_inbounds(cx: &@block_ctxt, v: ValueRef, p: ValueRef,\n                   idxs: &[ValueRef]) {\n-    bld::Store(cx, v, bld::InBoundsGEP(cx, p, idxs));\n+    Store(cx, v, InBoundsGEP(cx, p, idxs));\n }\n \n // This uses store and inboundsGEP, but it only doing so superficially; it's\n // really storing an incremented pointer to another pointer.\n fn incr_ptr(cx: &@block_ctxt, p: ValueRef, incr: ValueRef, pp: ValueRef) {\n-    bld::Store(cx, bld::InBoundsGEP(cx, p, [incr]), pp);\n+    Store(cx, InBoundsGEP(cx, p, [incr]), pp);\n }\n \n fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n                            f: &val_and_ty_fn) -> result {\n     fn iter_boxpp(cx: @block_ctxt, box_cell: ValueRef, f: &val_and_ty_fn) ->\n        result {\n-        let box_ptr = bld::Load(cx, box_cell);\n+        let box_ptr = Load(cx, box_cell);\n         let tnil = ty::mk_nil(bcx_tcx(cx));\n         let tbox = ty::mk_imm_box(bcx_tcx(cx), tnil);\n         let inner_cx = new_sub_block_ctxt(cx, ~\"iter box\");\n         let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n-        let null_test = bld::IsNull(cx, box_ptr);\n-        bld::CondBr(cx, null_test, next_cx.llbb, inner_cx.llbb);\n+        let null_test = IsNull(cx, box_ptr);\n+        CondBr(cx, null_test, next_cx.llbb, inner_cx.llbb);\n         let r = f(inner_cx, box_cell, tbox);\n-        bld::Br(r.bcx, next_cx.llbb);\n+        Br(r.bcx, next_cx.llbb);\n         ret rslt(next_cx, C_nil());\n     }\n \n@@ -1770,18 +1770,18 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         }\n \n         let lltagty = T_opaque_tag_ptr(bcx_ccx(cx).tn);\n-        let av_tag = bld::PointerCast(cx, av, lltagty);\n-        let lldiscrim_a_ptr = bld::GEP(cx, av_tag, [C_int(0), C_int(0)]);\n-        let llunion_a_ptr = bld::GEP(cx, av_tag, [C_int(0), C_int(1)]);\n-        let lldiscrim_a = bld::Load(cx, lldiscrim_a_ptr);\n+        let av_tag = PointerCast(cx, av, lltagty);\n+        let lldiscrim_a_ptr = GEP(cx, av_tag, [C_int(0), C_int(0)]);\n+        let llunion_a_ptr = GEP(cx, av_tag, [C_int(0), C_int(1)]);\n+        let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n \n         // NB: we must hit the discriminant first so that structural\n         // comparison know not to proceed when the discriminants differ.\n         let bcx = cx;\n         bcx = f(bcx, lldiscrim_a_ptr, ty::mk_int(bcx_tcx(cx))).bcx;\n         let unr_cx = new_sub_block_ctxt(bcx, ~\"tag-iter-unr\");\n-        bld::Unreachable(unr_cx);\n-        let llswitch = bld::Switch(bcx, lldiscrim_a, unr_cx.llbb, n_variants);\n+        Unreachable(unr_cx);\n+        let llswitch = Switch(bcx, lldiscrim_a, unr_cx.llbb, n_variants);\n         let next_cx = new_sub_block_ctxt(bcx, ~\"tag-iter-next\");\n         let i = 0u;\n         for variant: ty::variant_info in variants {\n@@ -1793,19 +1793,19 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n             variant_cx =\n                 iter_variant(variant_cx, llunion_a_ptr, variant, tps, tid,\n                              f).bcx;\n-            bld::Br(variant_cx, next_cx.llbb);\n+            Br(variant_cx, next_cx.llbb);\n             i += 1u;\n         }\n         ret rslt(next_cx, C_nil());\n       }\n       ty::ty_fn(_, _, _, _, _) {\n         let box_cell_a =\n-            bld::GEP(cx, av, [C_int(0), C_int(abi::fn_field_box)]);\n+            GEP(cx, av, [C_int(0), C_int(abi::fn_field_box)]);\n         ret iter_boxpp(cx, box_cell_a, f);\n       }\n       ty::ty_obj(_) {\n         let box_cell_a =\n-            bld::GEP(cx, av, [C_int(0), C_int(abi::obj_field_box)]);\n+            GEP(cx, av, [C_int(0), C_int(abi::obj_field_box)]);\n         ret iter_boxpp(cx, box_cell_a, f);\n       }\n       _ { bcx_ccx(cx).sess.unimpl(~\"type in iter_structural_ty_full\"); }\n@@ -1832,23 +1832,23 @@ fn iter_sequence_raw(cx: @block_ctxt, dst: ValueRef,\n     let cond_cx = new_scope_block_ctxt(cx, ~\"sequence-iter cond\");\n     let body_cx = new_scope_block_ctxt(cx, ~\"sequence-iter body\");\n     let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n-    bld::Br(bcx, cond_cx.llbb);\n+    Br(bcx, cond_cx.llbb);\n     let dst_curr: ValueRef =\n-        bld::Phi(cond_cx, T_int(), [dst_int], [bcx.llbb]);\n+        Phi(cond_cx, T_int(), [dst_int], [bcx.llbb]);\n     let src_curr: ValueRef =\n-        bld::Phi(cond_cx, T_int(), [src_int], [bcx.llbb]);\n+        Phi(cond_cx, T_int(), [src_int], [bcx.llbb]);\n     let end_test =\n-        bld::ICmp(cond_cx, lib::llvm::LLVMIntULT, src_curr, src_lim_int);\n-    bld::CondBr(cond_cx, end_test, body_cx.llbb, next_cx.llbb);\n+        ICmp(cond_cx, lib::llvm::LLVMIntULT, src_curr, src_lim_int);\n+    CondBr(cond_cx, end_test, body_cx.llbb, next_cx.llbb);\n     let dst_curr_ptr = vi2p(body_cx, dst_curr, T_ptr(T_i8()));\n     let src_curr_ptr = vi2p(body_cx, src_curr, T_ptr(T_i8()));\n     let body_res = f(body_cx, dst_curr_ptr, src_curr_ptr);\n     body_cx = body_res.bcx;\n-    let dst_next = bld::Add(body_cx, dst_curr, elt_sz);\n-    let src_next = bld::Add(body_cx, src_curr, elt_sz);\n-    bld::Br(body_cx, cond_cx.llbb);\n-    bld::AddIncomingToPhi(dst_curr, [dst_next], [body_cx.llbb]);\n-    bld::AddIncomingToPhi(src_curr, [src_next], [body_cx.llbb]);\n+    let dst_next = Add(body_cx, dst_curr, elt_sz);\n+    let src_next = Add(body_cx, src_curr, elt_sz);\n+    Br(body_cx, cond_cx.llbb);\n+    AddIncomingToPhi(dst_curr, [dst_next], [body_cx.llbb]);\n+    AddIncomingToPhi(src_curr, [src_next], [body_cx.llbb]);\n     ret rslt(next_cx, C_nil());\n }\n \n@@ -1865,7 +1865,7 @@ fn iter_sequence_inner(cx: &@block_ctxt, src: ValueRef,\n             let llty = type_of(bcx_ccx(cx), cx.sp, elt_ty);\n             llptrty = T_ptr(llty);\n         } else { llptrty = T_ptr(T_ptr(T_i8())); }\n-        let p = bld::PointerCast(cx, src, llptrty);\n+        let p = PointerCast(cx, src, llptrty);\n         ret f(cx, load_if_immediate(cx, p, elt_ty), elt_ty);\n     }\n     let elt_sz = size_of(cx, elt_ty);\n@@ -1884,9 +1884,9 @@ fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: ty::t, f: &val_and_ty_fn)\n         let len;\n         let llunit_ty = type_of_or_i8(bcx, elt_ty);\n         if !interior {\n-            p0 = bld::GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_data)]);\n-            let lp = bld::GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_fill)]);\n-            len = bld::Load(bcx, lp);\n+            p0 = GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_data)]);\n+            let lp = GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_fill)]);\n+            len = Load(bcx, lp);\n         } else {\n             len = ivec::get_fill(bcx, v);\n             p0 = ivec::get_dataptr(bcx, v, llunit_ty);\n@@ -1895,10 +1895,10 @@ fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: ty::t, f: &val_and_ty_fn)\n         if trailing_null {\n             let unit_sz = size_of(bcx, elt_ty);\n             bcx = unit_sz.bcx;\n-            len = bld::Sub(bcx, len, unit_sz.val);\n+            len = Sub(bcx, len, unit_sz.val);\n         }\n         let p1 =\n-            vi2p(bcx, bld::Add(bcx, vp2i(bcx, p0), len), T_ptr(llunit_ty));\n+            vi2p(bcx, Add(bcx, vp2i(bcx, p0), len), T_ptr(llunit_ty));\n         ret iter_sequence_inner(bcx, p0, p1, elt_ty, f);\n     }\n \n@@ -2046,22 +2046,22 @@ fn call_tydesc_glue_full(cx: &@block_ctxt, v: ValueRef, tydesc: ValueRef,\n       }\n     }\n \n-    let llrawptr = bld::PointerCast(cx, v, T_ptr(T_i8()));\n+    let llrawptr = PointerCast(cx, v, T_ptr(T_i8()));\n     let lltydescs =\n-        bld::GEP(cx, tydesc,\n+        GEP(cx, tydesc,\n                      [C_int(0), C_int(abi::tydesc_field_first_param)]);\n-    lltydescs = bld::Load(cx, lltydescs);\n+    lltydescs = Load(cx, lltydescs);\n \n     let llfn;\n     alt static_glue_fn {\n       none. {\n-        let llfnptr = bld::GEP(cx, tydesc, [C_int(0), C_int(field)]);\n-        llfn = bld::Load(cx, llfnptr);\n+        let llfnptr = GEP(cx, tydesc, [C_int(0), C_int(field)]);\n+        llfn = Load(cx, llfnptr);\n       }\n       some(sgf) { llfn = sgf; }\n     }\n \n-    bld::Call(cx, llfn,\n+    Call(cx, llfn,\n                   [C_null(T_ptr(T_nil())), cx.fcx.lltaskptr,\n                    C_null(T_ptr(T_nil())), lltydescs, llrawptr]);\n }\n@@ -2081,24 +2081,24 @@ fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n \n     let lllhs = spill_if_immediate(cx, lhs, t);\n     let llrhs = spill_if_immediate(cx, rhs, t);\n-    let llrawlhsptr = bld::BitCast(cx, lllhs, T_ptr(T_i8()));\n-    let llrawrhsptr = bld::BitCast(cx, llrhs, T_ptr(T_i8()));\n+    let llrawlhsptr = BitCast(cx, lllhs, T_ptr(T_i8()));\n+    let llrawrhsptr = BitCast(cx, llrhs, T_ptr(T_i8()));\n     let ti = none::<@tydesc_info>;\n     let r = get_tydesc(cx, t, false, tps_normal, ti).result;\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_cmp_glue, ti);\n     let lltydesc = r.val;\n     let lltydescs =\n-        bld::GEP(r.bcx, lltydesc,\n+        GEP(r.bcx, lltydesc,\n                         [C_int(0), C_int(abi::tydesc_field_first_param)]);\n-    lltydescs = bld::Load(r.bcx, lltydescs);\n+    lltydescs = Load(r.bcx, lltydescs);\n \n     let llfn;\n     alt ti {\n       none. {\n         let llfnptr =\n-            bld::GEP(r.bcx, lltydesc,\n+            GEP(r.bcx, lltydesc,\n                             [C_int(0), C_int(abi::tydesc_field_cmp_glue)]);\n-        llfn = bld::Load(r.bcx, llfnptr);\n+        llfn = Load(r.bcx, llfnptr);\n       }\n       some(sti) { llfn = option::get(sti.cmp_glue); }\n     }\n@@ -2107,45 +2107,45 @@ fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     let llargs: [ValueRef] =\n         [llcmpresultptr, r.bcx.fcx.lltaskptr, lltydesc, lltydescs,\n          llrawlhsptr, llrawrhsptr, llop];\n-    bld::Call(r.bcx, llfn, llargs);\n-    ret rslt(r.bcx, bld::Load(r.bcx, llcmpresultptr));\n+    Call(r.bcx, llfn, llargs);\n+    ret rslt(r.bcx, Load(r.bcx, llcmpresultptr));\n }\n \n fn call_copy_glue(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t,\n                   take: bool) -> @block_ctxt {\n     // You can't call this on immediate types. Those are simply copied with\n     // Load/Store.\n     assert !type_is_immediate(bcx_ccx(cx), t);\n-    let srcptr = bld::BitCast(cx, src, T_ptr(T_i8()));\n-    let dstptr = bld::BitCast(cx, dst, T_ptr(T_i8()));\n+    let srcptr = BitCast(cx, src, T_ptr(T_i8()));\n+    let dstptr = BitCast(cx, dst, T_ptr(T_i8()));\n     let ti = none;\n     let {bcx, val: lltydesc} =\n         get_tydesc(cx, t, false, tps_normal, ti).result;\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_copy_glue, ti);\n-    let lltydescs = bld::GEP\n+    let lltydescs = GEP\n         (bcx, lltydesc, [C_int(0), C_int(abi::tydesc_field_first_param)]);\n-    lltydescs = bld::Load(bcx, lltydescs);\n+    lltydescs = Load(bcx, lltydescs);\n \n     let llfn = alt ti {\n       none. {\n-        bld::Load(bcx, bld::GEP\n+        Load(bcx, GEP\n             (bcx, lltydesc, [C_int(0), C_int(abi::tydesc_field_copy_glue)]))\n       }\n       some(sti) { option::get(sti.copy_glue) }\n     };\n-    bld::Call(bcx, llfn, [C_null(T_ptr(T_nil())), bcx.fcx.lltaskptr,\n+    Call(bcx, llfn, [C_null(T_ptr(T_nil())), bcx.fcx.lltaskptr,\n                           C_null(T_ptr(T_nil())), lltydescs, srcptr, dstptr]);\n     if take {\n         lazily_emit_tydesc_glue(cx, abi::tydesc_field_take_glue, ti);\n         llfn = alt ti {\n           none. {\n-            bld::Load(bcx, bld::GEP(bcx, lltydesc,\n+            Load(bcx, GEP(bcx, lltydesc,\n                                     [C_int(0),\n                                      C_int(abi::tydesc_field_take_glue)]))\n           }\n           some(sti) { option::get(sti.take_glue) }\n         };\n-        bld::Call(bcx, llfn, [C_null(T_ptr(T_nil())), bcx.fcx.lltaskptr,\n+        Call(bcx, llfn, [C_null(T_ptr(T_nil())), bcx.fcx.lltaskptr,\n                               C_null(T_ptr(T_nil())), lltydescs, dstptr]);\n     }\n     ret bcx;\n@@ -2193,13 +2193,13 @@ fn call_memmove(cx: &@block_ctxt, dst: ValueRef, src: ValueRef,\n     let i = bcx_ccx(cx).intrinsics;\n     assert (i.contains_key(~\"llvm.memmove.p0i8.p0i8.i32\"));\n     let memmove = i.get(~\"llvm.memmove.p0i8.p0i8.i32\");\n-    let src_ptr = bld::PointerCast(cx, src, T_ptr(T_i8()));\n-    let dst_ptr = bld::PointerCast(cx, dst, T_ptr(T_i8()));\n-    let size = bld::IntCast(cx, n_bytes, T_i32());\n+    let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n+    let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n+    let size = IntCast(cx, n_bytes, T_i32());\n     let align = C_int(1);\n     let volatile = C_bool(false);\n     ret rslt(cx,\n-             bld::Call(cx, memmove,\n+             Call(cx, memmove,\n                            [dst_ptr, src_ptr, size, align, volatile]));\n }\n \n@@ -2210,15 +2210,15 @@ fn call_bzero(cx: &@block_ctxt, dst: ValueRef, n_bytes: ValueRef,\n     let i = bcx_ccx(cx).intrinsics;\n     assert (i.contains_key(~\"llvm.memset.p0i8.i32\"));\n     let memset = i.get(~\"llvm.memset.p0i8.i32\");\n-    let dst_ptr = bld::PointerCast(cx, dst, T_ptr(T_i8()));\n-    let size = bld::IntCast(cx, n_bytes, T_i32());\n+    let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n+    let size = IntCast(cx, n_bytes, T_i32());\n     let align =\n         if lib::llvm::llvm::LLVMIsConstant(align_bytes) == True {\n-            bld::IntCast(cx, align_bytes, T_i32())\n-        } else { bld::IntCast(cx, C_int(0), T_i32()) };\n+            IntCast(cx, align_bytes, T_i32())\n+        } else { IntCast(cx, C_int(0), T_i32()) };\n     let volatile = C_bool(false);\n     ret rslt(cx,\n-             bld::Call(cx, memset,\n+             Call(cx, memset,\n                            [dst_ptr, C_u8(0u), size, align, volatile]));\n }\n \n@@ -2230,7 +2230,7 @@ fn memmove_ty(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n     } else if ty::type_is_structural(bcx_tcx(cx), t) {\n         let llsz = llsize_of(type_of(bcx_ccx(cx), cx.sp, t));\n         ret call_memmove(cx, dst, src, llsz);\n-    } else { ret rslt(cx, bld::Store(cx, bld::Load(cx, src), dst)); }\n+    } else { ret rslt(cx, Store(cx, Load(cx, src), dst)); }\n }\n \n tag copy_action { INIT; DROP_EXISTING; }\n@@ -2251,11 +2251,11 @@ fn copy_val(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n         let do_copy_cx = new_sub_block_ctxt(cx, ~\"do_copy\");\n         let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n         let self_assigning =\n-            bld::ICmp(cx, lib::llvm::LLVMIntNE,\n-                          bld::PointerCast(cx, dst, val_ty(src)), src);\n-        bld::CondBr(cx, self_assigning, do_copy_cx.llbb, next_cx.llbb);\n+            ICmp(cx, lib::llvm::LLVMIntNE,\n+                          PointerCast(cx, dst, val_ty(src)), src);\n+        CondBr(cx, self_assigning, do_copy_cx.llbb, next_cx.llbb);\n         do_copy_cx = copy_val_no_check(do_copy_cx, action, dst, src, t);\n-        bld::Br(do_copy_cx, next_cx.llbb);\n+        Br(do_copy_cx, next_cx.llbb);\n         ret next_cx;\n     }\n     ret copy_val_no_check(cx, action, dst, src, t);\n@@ -2271,7 +2271,7 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n     }\n \n     if ty::type_is_scalar(ccx.tcx, t) || ty::type_is_native(ccx.tcx, t) {\n-        bld::Store(cx, src, dst);\n+        Store(cx, src, dst);\n         ret cx;\n     } else if ty::type_is_nil(ccx.tcx, t) || ty::type_is_bot(ccx.tcx, t) {\n         ret cx;\n@@ -2280,7 +2280,7 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n         let bcx = if action == DROP_EXISTING {\n             drop_ty(cx, dst, t).bcx\n         } else { cx };\n-        bld::Store(bcx, src, dst);\n+        Store(bcx, src, dst);\n         bcx = take_ty(bcx, dst, t).bcx;\n         ret bcx;\n     } else if type_is_structural_or_param(ccx.tcx, t) {\n@@ -2306,18 +2306,18 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n     let tcx = bcx_tcx(cx);\n     if ty::type_is_scalar(tcx, t) ||\n            ty::type_is_native(tcx, t) {\n-        if src.is_mem { src_val = bld::Load(cx, src_val); }\n-        bld::Store(cx, src_val, dst);\n+        if src.is_mem { src_val = Load(cx, src_val); }\n+        Store(cx, src_val, dst);\n         ret cx;\n     } else if ty::type_is_nil(tcx, t) || ty::type_is_bot(tcx, t) {\n         ret cx;\n     } else if ty::type_is_unique(tcx, t) ||\n               ty::type_is_boxed(tcx, t) {\n-        if src.is_mem { src_val = bld::Load(cx, src_val); }\n+        if src.is_mem { src_val = Load(cx, src_val); }\n         if action == DROP_EXISTING {\n             cx = drop_ty(cx, dst, t).bcx;\n         }\n-        bld::Store(cx, src_val, dst);\n+        Store(cx, src_val, dst);\n         if src.is_mem { ret zero_alloca(cx, src.res.val, t).bcx; }\n \n         // If we're here, it must be a temporary.\n@@ -2410,13 +2410,13 @@ fn trans_unary(cx: &@block_ctxt, op: ast::unop, e: &@ast::expr,\n     alt op {\n       ast::not. {\n         let sub = trans_expr(cx, e);\n-        ret rslt(sub.bcx, bld::Not(sub.bcx, sub.val));\n+        ret rslt(sub.bcx, Not(sub.bcx, sub.val));\n       }\n       ast::neg. {\n         let sub = trans_expr(cx, e);\n         if ty::struct(bcx_tcx(cx), e_ty) == ty::ty_float {\n-            ret rslt(sub.bcx, bld::FNeg(sub.bcx, sub.val));\n-        } else { ret rslt(sub.bcx, bld::Neg(sub.bcx, sub.val)); }\n+            ret rslt(sub.bcx, FNeg(sub.bcx, sub.val));\n+        } else { ret rslt(sub.bcx, Neg(sub.bcx, sub.val)); }\n       }\n       ast::box(_) {\n         let lv = trans_lval(cx, e);\n@@ -2430,7 +2430,7 @@ fn trans_unary(cx: &@block_ctxt, op: ast::unop, e: &@ast::expr,\n         // on whether they're boxed or not.\n         if !ty::type_has_dynamic_size(bcx_tcx(cx), e_ty) {\n             let llety = T_ptr(type_of(bcx_ccx(sub.bcx), e.span, e_ty));\n-            body = bld::PointerCast(sub.bcx, body, llety);\n+            body = PointerCast(sub.bcx, body, llety);\n         }\n         let bcx = move_val_if_temp(sub.bcx, INIT, body, lv, e_ty);\n         ret rslt(bcx, sub.box);\n@@ -2459,7 +2459,7 @@ fn trans_compare(cx: &@block_ctxt, op: ast::binop, lhs: ValueRef,\n     alt op {\n       ast::eq. | ast::lt. | ast::le. { ret rslt(rs.bcx, rs.val); }\n       ast::ne. | ast::ge. | ast::gt. {\n-        ret rslt(rs.bcx, bld::Not(rs.bcx, rs.val));\n+        ret rslt(rs.bcx, Not(rs.bcx, rs.val));\n       }\n     }\n }\n@@ -2482,10 +2482,10 @@ fn trans_evec_append(cx: &@block_ctxt, t: ty::t, lhs: ValueRef,\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_free_glue, ti);\n     bcx = llelt_tydesc.bcx;\n-    let dst = bld::PointerCast(bcx, lhs, T_ptr(T_opaque_vec_ptr()));\n-    let src = bld::PointerCast(bcx, rhs, T_opaque_vec_ptr());\n+    let dst = PointerCast(bcx, lhs, T_ptr(T_opaque_vec_ptr()));\n+    let src = PointerCast(bcx, rhs, T_opaque_vec_ptr());\n     ret rslt(bcx,\n-             bld::Call(bcx, bcx_ccx(cx).upcalls.evec_append,\n+             Call(bcx, bcx_ccx(cx).upcalls.evec_append,\n                             [cx.fcx.lltaskptr, llvec_tydesc.val,\n                              llelt_tydesc.val, dst, src, skip_null]));\n }\n@@ -2510,7 +2510,7 @@ fn trans_eager_binop(cx: &@block_ctxt, op: ast::binop, lhs: ValueRef,\n     // operation.\n     if ty::type_is_bot(bcx_tcx(cx), lhs_t) ||\n            ty::type_is_bot(bcx_tcx(cx), rhs_t) {\n-        ret rslt(cx, bld::Unreachable(cx));\n+        ret rslt(cx, Unreachable(cx));\n     }\n \n     let is_float = false;\n@@ -2530,37 +2530,37 @@ fn trans_eager_binop(cx: &@block_ctxt, op: ast::binop, lhs: ValueRef,\n             ret trans_evec_add(cx, intype, lhs, rhs);\n         }\n         if is_float {\n-            ret rslt(cx, bld::FAdd(cx, lhs, rhs));\n-        } else { ret rslt(cx, bld::Add(cx, lhs, rhs)); }\n+            ret rslt(cx, FAdd(cx, lhs, rhs));\n+        } else { ret rslt(cx, Add(cx, lhs, rhs)); }\n       }\n       ast::sub. {\n         if is_float {\n-            ret rslt(cx, bld::FSub(cx, lhs, rhs));\n-        } else { ret rslt(cx, bld::Sub(cx, lhs, rhs)); }\n+            ret rslt(cx, FSub(cx, lhs, rhs));\n+        } else { ret rslt(cx, Sub(cx, lhs, rhs)); }\n       }\n       ast::mul. {\n         if is_float {\n-            ret rslt(cx, bld::FMul(cx, lhs, rhs));\n-        } else { ret rslt(cx, bld::Mul(cx, lhs, rhs)); }\n+            ret rslt(cx, FMul(cx, lhs, rhs));\n+        } else { ret rslt(cx, Mul(cx, lhs, rhs)); }\n       }\n       ast::div. {\n-        if is_float { ret rslt(cx, bld::FDiv(cx, lhs, rhs)); }\n+        if is_float { ret rslt(cx, FDiv(cx, lhs, rhs)); }\n         if ty::type_is_signed(bcx_tcx(cx), intype) {\n-            ret rslt(cx, bld::SDiv(cx, lhs, rhs));\n-        } else { ret rslt(cx, bld::UDiv(cx, lhs, rhs)); }\n+            ret rslt(cx, SDiv(cx, lhs, rhs));\n+        } else { ret rslt(cx, UDiv(cx, lhs, rhs)); }\n       }\n       ast::rem. {\n-        if is_float { ret rslt(cx, bld::FRem(cx, lhs, rhs)); }\n+        if is_float { ret rslt(cx, FRem(cx, lhs, rhs)); }\n         if ty::type_is_signed(bcx_tcx(cx), intype) {\n-            ret rslt(cx, bld::SRem(cx, lhs, rhs));\n-        } else { ret rslt(cx, bld::URem(cx, lhs, rhs)); }\n-      }\n-      ast::bitor. { ret rslt(cx, bld::Or(cx, lhs, rhs)); }\n-      ast::bitand. { ret rslt(cx, bld::And(cx, lhs, rhs)); }\n-      ast::bitxor. { ret rslt(cx, bld::Xor(cx, lhs, rhs)); }\n-      ast::lsl. { ret rslt(cx, bld::Shl(cx, lhs, rhs)); }\n-      ast::lsr. { ret rslt(cx, bld::LShr(cx, lhs, rhs)); }\n-      ast::asr. { ret rslt(cx, bld::AShr(cx, lhs, rhs)); }\n+            ret rslt(cx, SRem(cx, lhs, rhs));\n+        } else { ret rslt(cx, URem(cx, lhs, rhs)); }\n+      }\n+      ast::bitor. { ret rslt(cx, Or(cx, lhs, rhs)); }\n+      ast::bitand. { ret rslt(cx, And(cx, lhs, rhs)); }\n+      ast::bitxor. { ret rslt(cx, Xor(cx, lhs, rhs)); }\n+      ast::lsl. { ret rslt(cx, Shl(cx, lhs, rhs)); }\n+      ast::lsr. { ret rslt(cx, LShr(cx, lhs, rhs)); }\n+      ast::asr. { ret rslt(cx, AShr(cx, lhs, rhs)); }\n       _ { ret trans_compare(cx, op, lhs, lhs_t, rhs, rhs_t); }\n     }\n }\n@@ -2573,7 +2573,7 @@ fn autoderef(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n         alt ty::struct(ccx.tcx, t1) {\n           ty::ty_box(mt) {\n             let body =\n-                bld::GEP(cx, v1, [C_int(0), C_int(abi::box_rc_field_body)]);\n+                GEP(cx, v1, [C_int(0), C_int(abi::box_rc_field_body)]);\n             t1 = mt.ty;\n \n             // Since we're changing levels of box indirection, we may have\n@@ -2582,13 +2582,13 @@ fn autoderef(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n             // or not.\n             if !ty::type_has_dynamic_size(ccx.tcx, mt.ty) {\n                 let llty = type_of(ccx, cx.sp, mt.ty);\n-                v1 = bld::PointerCast(cx, body, T_ptr(llty));\n+                v1 = PointerCast(cx, body, T_ptr(llty));\n             } else { v1 = body; }\n           }\n           ty::ty_uniq(t) { fail \"autoderef uniq unimplemented\"; }\n           ty::ty_res(did, inner, tps) {\n             t1 = ty::substitute_type_params(ccx.tcx, tps, inner);\n-            v1 = bld::GEP(cx, v1, [C_int(0), C_int(1)]);\n+            v1 = GEP(cx, v1, [C_int(0), C_int(1)]);\n           }\n           ty::ty_tag(did, tps) {\n             let variants = ty::tag_variants(ccx.tcx, did);\n@@ -2599,7 +2599,7 @@ fn autoderef(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n             t1 =\n                 ty::substitute_type_params(ccx.tcx, tps, variants[0].args[0]);\n             if !ty::type_has_dynamic_size(ccx.tcx, t1) {\n-                v1 = bld::PointerCast(cx, v1, T_ptr(type_of(ccx, cx.sp, t1)));\n+                v1 = PointerCast(cx, v1, T_ptr(type_of(ccx, cx.sp, t1)));\n             }\n           }\n           _ { break; }\n@@ -2628,7 +2628,7 @@ fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n         // because and/or are lazy. So the rhs may never execute,\n         // and the cleanups can't be pushed into later code.\n         let rhs_bcx = trans_block_cleanups(rhs_res.bcx, rhs_cx);\n-        bld::CondBr(lhs_res.bcx, lhs_res.val, rhs_cx.llbb, lhs_false_cx.llbb);\n+        CondBr(lhs_res.bcx, lhs_res.val, rhs_cx.llbb, lhs_false_cx.llbb);\n         ret join_results(cx, T_bool(),\n                          [lhs_false_res, {bcx: rhs_bcx, val: rhs_res.val}]);\n       }\n@@ -2642,7 +2642,7 @@ fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n \n         // see the and case for an explanation\n         let rhs_bcx = trans_block_cleanups(rhs_res.bcx, rhs_cx);\n-        bld::CondBr(lhs_res.bcx, lhs_res.val, lhs_true_cx.llbb, rhs_cx.llbb);\n+        CondBr(lhs_res.bcx, lhs_res.val, lhs_true_cx.llbb, rhs_cx.llbb);\n         ret join_results(cx, T_bool(),\n                          [lhs_true_res, {bcx: rhs_bcx, val: rhs_res.val}]);\n       }\n@@ -2684,15 +2684,15 @@ fn join_results(parent_cx: &@block_ctxt, t: TypeRef, ins: &[result]) ->\n     // We have >1 incoming edges. Make a join block and br+phi them into it.\n \n     let join_cx = new_sub_block_ctxt(parent_cx, ~\"join\");\n-    for r: result in live { bld::Br(r.bcx, join_cx.llbb); }\n-    let phi = bld::Phi(join_cx, t, vals, bbs);\n+    for r: result in live { Br(r.bcx, join_cx.llbb); }\n+    let phi = Phi(join_cx, t, vals, bbs);\n     ret rslt(join_cx, phi);\n }\n \n fn join_branches(parent_cx: &@block_ctxt, ins: &[result]) -> @block_ctxt {\n     let out = new_sub_block_ctxt(parent_cx, ~\"join\");\n     for r: result in ins {\n-        if !is_terminated(r.bcx) { bld::Br(r.bcx, out.llbb); }\n+        if !is_terminated(r.bcx) { Br(r.bcx, out.llbb); }\n     }\n     ret out;\n }\n@@ -2708,7 +2708,7 @@ fn trans_if(cx: &@block_ctxt, cond: &@ast::expr, thn: &ast::blk,\n         // No need to generate code for comparison,\n         // since the cond diverges.\n         if !is_terminated(cx) {\n-            ret rslt(cx, bld::Unreachable(cx));\n+            ret rslt(cx, Unreachable(cx));\n         } else { ret cond_res; }\n     }\n \n@@ -2736,7 +2736,7 @@ fn trans_if(cx: &@block_ctxt, cond: &@ast::expr, thn: &ast::blk,\n           }\n           _ { rslt(else_cx, C_nil()) }\n         };\n-    bld::CondBr(cond_res.bcx, cond_res.val, then_cx.llbb, else_cx.llbb);\n+    CondBr(cond_res.bcx, cond_res.val, then_cx.llbb, else_cx.llbb);\n     ret rslt(join_branches(cx, [then_res, else_res]), C_nil());\n }\n \n@@ -2751,7 +2751,7 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n             new_loop_scope_block_ctxt(cx,\n                                       option::some::<@block_ctxt>(next_cx),\n                                       outer_next_cx, ~\"for loop scope\");\n-        bld::Br(cx, scope_cx.llbb);\n+        Br(cx, scope_cx.llbb);\n         let local_res = alloc_local(scope_cx, local);\n         let bcx = copy_val(local_res.bcx, INIT, local_res.val, curr, t);\n         add_clean(scope_cx, local_res.val, t);\n@@ -2761,7 +2761,7 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n                                             false);\n         bcx = trans_block(bcx, body, return).bcx;\n         if !is_terminated(bcx) {\n-            bld::Br(bcx, next_cx.llbb);\n+            Br(bcx, next_cx.llbb);\n             // otherwise, this code is unreachable\n         }\n         ret rslt(next_cx, C_nil());\n@@ -2772,7 +2772,7 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n     let it =\n         iter_sequence(seq_res.bcx, seq_res.val, seq_ty,\n                       bind inner(_, local, _, _, body, next_cx));\n-    bld::Br(it.bcx, next_cx.llbb);\n+    Br(it.bcx, next_cx.llbb);\n     ret rslt(next_cx, it.val);\n }\n \n@@ -2841,7 +2841,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = bindings_tydesc.bcx;\n-        bld::Store(bcx, bindings_tydesc.val, bound_tydesc);\n+        Store(bcx, bindings_tydesc.val, bound_tydesc);\n     }\n \n     // Copy expr values into boxed bindings.\n@@ -2856,7 +2856,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         bcx = bound.bcx;\n         if copying {\n             bcx = move_val_if_temp(bcx, INIT, bound.val, lv, bound_tys[i]);\n-        } else { bld::Store(bcx, lv.res.val, bound.val); }\n+        } else { Store(bcx, lv.res.val, bound.val); }\n         i += 1u;\n     }\n \n@@ -2869,7 +2869,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     i = 0u;\n     for td: ValueRef in lltydescs {\n         let ty_param_slot = GEPi(bcx, ty_params_slot.val, [0, i as int]);\n-        bld::Store(bcx, td, ty_param_slot);\n+        Store(bcx, td, ty_param_slot);\n         i += 1u;\n     }\n \n@@ -2920,10 +2920,10 @@ fn find_environment_tydescs(bcx: &@block_ctxt, envty: ty::t,\n             let llenv = GEPi(bcx, closure, [0, abi::box_rc_field_body]);\n             // Load the tydesc and find the size of the body\n             let lldesc =\n-                bld::Load(bcx, GEPi(bcx, llenv,\n+                Load(bcx, GEPi(bcx, llenv,\n                                     [0, abi::closure_elt_tydesc]));\n             let llsz =\n-                bld::Load(bcx, GEPi(bcx, lldesc,\n+                Load(bcx, GEPi(bcx, lldesc,\n                                     [0, abi::tydesc_field_size]));\n \n             // Get the bindings pointer and add the size to it\n@@ -2941,7 +2941,7 @@ fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt, envty: ty::t,\n \n     let ty = ty::mk_imm_box(bcx_tcx(bcx), envty);\n     let llty = type_of(bcx_ccx(bcx), bcx.sp, ty);\n-    let llclosure = bld::PointerCast(bcx, fcx.llenv, llty);\n+    let llclosure = PointerCast(bcx, fcx.llenv, llty);\n \n     // Populate the type parameters from the environment. We need to\n     // do this first because the tydescs are needed to index into\n@@ -2951,7 +2951,7 @@ fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt, envty: ty::t,\n     let i = 0u;\n     while i < tydesc_count {\n         let lltydescptr = GEPi(bcx, lltydescs, [0, i as int]);\n-        fcx.lltydescs += [bld::Load(bcx, lltydescptr)];\n+        fcx.lltydescs += [Load(bcx, lltydescptr)];\n         i += 1u;\n     }\n \n@@ -2962,7 +2962,7 @@ fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt, envty: ty::t,\n     // the iterbody.\n     if !copying && !option::is_none(enclosing_cx.fcx.lliterbody) {\n         let iterbodyptr = GEP_tup_like(bcx, ty, llclosure, path + [0]);\n-        fcx.lliterbody = some(bld::Load(bcx, iterbodyptr.val));\n+        fcx.lliterbody = some(Load(bcx, iterbodyptr.val));\n         bcx = iterbodyptr.bcx;\n         i += 1u;\n     }\n@@ -2972,7 +2972,7 @@ fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt, envty: ty::t,\n         let upvarptr = GEP_tup_like(bcx, ty, llclosure, path + [i as int]);\n         bcx = upvarptr.bcx;\n         let llupvarptr = upvarptr.val;\n-        if !copying { llupvarptr = bld::Load(bcx, llupvarptr); }\n+        if !copying { llupvarptr = Load(bcx, llupvarptr); }\n         let def_id = ast_util::def_id_of_def(bcx_tcx(bcx).\n                                              def_map.get(upvar_id));\n         fcx.llupvars.insert(def_id.node, llupvarptr);\n@@ -3073,10 +3073,10 @@ fn trans_while(cx: &@block_ctxt, cond: &@ast::expr, body: &ast::blk) ->\n         new_scope_block_ctxt(cond_cx, ~\"while loop body\");\n     let body_res = trans_block(body_cx, body, return);\n     let cond_res = trans_expr(cond_cx, cond);\n-    bld::Br(body_res.bcx, cond_cx.llbb);\n+    Br(body_res.bcx, cond_cx.llbb);\n     let cond_bcx = trans_block_cleanups(cond_res.bcx, cond_cx);\n-    bld::CondBr(cond_bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n-    bld::Br(cx, cond_cx.llbb);\n+    CondBr(cond_bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n+    Br(cx, cond_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n \n@@ -3091,13 +3091,13 @@ fn trans_do_while(cx: &@block_ctxt, body: &ast::blk, cond: &@ast::expr) ->\n         // This is kind of ridiculous, but no permutations\n         // involving body_res or body_cx.val worked.\n         let rs = trans_block(cx, body, return);\n-        if !is_terminated(next_cx) { bld::Unreachable(next_cx); }\n-        if !is_terminated(body_cx) { bld::Unreachable(body_cx); }\n+        if !is_terminated(next_cx) { Unreachable(next_cx); }\n+        if !is_terminated(body_cx) { Unreachable(body_cx); }\n         ret rs;\n     }\n     let cond_res = trans_expr(body_res.bcx, cond);\n-    bld::CondBr(cond_res.bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n-    bld::Br(cx, body_cx.llbb);\n+    CondBr(cond_res.bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n+    Br(cx, body_cx.llbb);\n     ret rslt(next_cx, body_res.val);\n }\n \n@@ -3230,13 +3230,13 @@ fn trans_var(cx: &@block_ctxt, sp: &span, id: ast::node_id) -> lval_result {\n             let lltagblob = alloc_result.val;\n             let lltagty = type_of_tag(ccx, sp, tid, tag_ty);\n             let bcx = alloc_result.bcx;\n-            let lltagptr = bld::PointerCast(bcx, lltagblob, T_ptr(lltagty));\n+            let lltagptr = PointerCast(bcx, lltagblob, T_ptr(lltagty));\n             if std::vec::len(ty::tag_variants(ccx.tcx, tid)) != 1u {\n                 let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, vid);\n-                let lldiscrim = bld::Load(bcx, lldiscrim_gv);\n+                let lldiscrim = Load(bcx, lldiscrim_gv);\n                 let lldiscrimptr =\n-                    bld::GEP(bcx, lltagptr, [C_int(0), C_int(0)]);\n-                bld::Store(bcx, lldiscrim, lldiscrimptr);\n+                    GEP(bcx, lltagptr, [C_int(0), C_int(0)]);\n+                Store(bcx, lldiscrim, lldiscrimptr);\n             }\n             ret lval_val(bcx, lltagptr);\n           }\n@@ -3283,20 +3283,20 @@ fn trans_field(cx: &@block_ctxt, sp: &span, v: ValueRef, t0: ty::t,\n       ty::ty_obj(methods) {\n         let ix: uint = ty::method_idx(bcx_ccx(cx).sess, sp, field, methods);\n         let vtbl =\n-            bld::GEP(r.bcx, r.val, [C_int(0), C_int(abi::obj_field_vtbl)]);\n-        vtbl = bld::Load(r.bcx, vtbl);\n+            GEP(r.bcx, r.val, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+        vtbl = Load(r.bcx, vtbl);\n \n         let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n-        vtbl = bld::PointerCast(cx, vtbl, vtbl_type);\n+        vtbl = PointerCast(cx, vtbl, vtbl_type);\n \n-        let v = bld::GEP(r.bcx, vtbl, [C_int(0), C_int(ix as int)]);\n+        let v = GEP(r.bcx, vtbl, [C_int(0), C_int(ix as int)]);\n         let fn_ty: ty::t = ty::method_ty_to_fn_ty(bcx_tcx(cx), methods[ix]);\n         let tcx = bcx_tcx(cx);\n         let ll_fn_ty =\n             type_of_fn_full(bcx_ccx(cx), sp, ty::ty_fn_proto(tcx, fn_ty),\n                             true, ty::ty_fn_args(tcx, fn_ty),\n                             ty::ty_fn_ret(tcx, fn_ty), 0u);\n-        v = bld::PointerCast(r.bcx, v, T_ptr(T_ptr(ll_fn_ty)));\n+        v = PointerCast(r.bcx, v, T_ptr(T_ptr(ll_fn_ty)));\n         let lvo = lval_mem(r.bcx, v);\n         ret {llobj: some::<ValueRef>(r.val), method_ty: some::<ty::t>(fn_ty)\n                 with lvo};\n@@ -3323,15 +3323,15 @@ fn trans_index(cx: &@block_ctxt, sp: &span, base: &@ast::expr,\n     let ix_size = llsize_of_real(bcx_ccx(cx), val_ty(ix.val));\n     let int_size = llsize_of_real(bcx_ccx(cx), T_int());\n     if ix_size < int_size {\n-        ix_val = bld::ZExt(bcx, ix.val, T_int());\n+        ix_val = ZExt(bcx, ix.val, T_int());\n     } else if ix_size > int_size {\n-        ix_val = bld::Trunc(bcx, ix.val, T_int());\n+        ix_val = Trunc(bcx, ix.val, T_int());\n     } else { ix_val = ix.val; }\n     let unit_ty = node_id_type(bcx_ccx(cx), id);\n     let unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n     maybe_name_value(bcx_ccx(cx), unit_sz.val, ~\"unit_sz\");\n-    let scaled_ix = bld::Mul(bcx, ix_val, unit_sz.val);\n+    let scaled_ix = Mul(bcx, ix_val, unit_sz.val);\n     maybe_name_value(bcx_ccx(cx), scaled_ix, ~\"scaled_ix\");\n     let interior_len_and_data;\n     if is_interior {\n@@ -3343,14 +3343,14 @@ fn trans_index(cx: &@block_ctxt, sp: &span, base: &@ast::expr,\n     alt interior_len_and_data {\n       some(lad) { lim = lad.len; }\n       none. {\n-        lim = bld::GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_fill)]);\n-        lim = bld::Load(bcx, lim);\n+        lim = GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_fill)]);\n+        lim = Load(bcx, lim);\n       }\n     }\n-    let bounds_check = bld::ICmp(bcx, lib::llvm::LLVMIntULT, scaled_ix, lim);\n+    let bounds_check = ICmp(bcx, lib::llvm::LLVMIntULT, scaled_ix, lim);\n     let fail_cx = new_sub_block_ctxt(bcx, ~\"fail\");\n     let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n-    bld::CondBr(bcx, bounds_check, next_cx.llbb, fail_cx.llbb);\n+    CondBr(bcx, bounds_check, next_cx.llbb, fail_cx.llbb);\n     // fail: bad bounds check.\n \n     trans_fail(fail_cx, some::<span>(sp), ~\"bounds check\");\n@@ -3359,20 +3359,20 @@ fn trans_index(cx: &@block_ctxt, sp: &span, base: &@ast::expr,\n       some(lad) { body = lad.data; }\n       none. {\n         body =\n-            bld::GEP(next_cx, v,\n+            GEP(next_cx, v,\n                               [C_int(0), C_int(abi::vec_elt_data), C_int(0)]);\n       }\n     }\n     let elt;\n     if ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty) {\n-        body = bld::PointerCast(next_cx, body, T_ptr(T_i8()));\n-        elt = bld::GEP(next_cx, body, [scaled_ix]);\n+        body = PointerCast(next_cx, body, T_ptr(T_i8()));\n+        elt = GEP(next_cx, body, [scaled_ix]);\n     } else {\n-        elt = bld::GEP(next_cx, body, [ix_val]);\n+        elt = GEP(next_cx, body, [ix_val]);\n         // We're crossing a box boundary here, so we may need to pointer cast.\n \n         let llunitty = type_of(bcx_ccx(next_cx), sp, unit_ty);\n-        elt = bld::PointerCast(next_cx, elt, T_ptr(llunitty));\n+        elt = PointerCast(next_cx, elt, T_ptr(llunitty));\n     }\n     ret lval_mem(next_cx, elt);\n }\n@@ -3399,21 +3399,21 @@ fn trans_lval_gen(cx: &@block_ctxt, e: &@ast::expr) -> lval_result {\n         let val =\n             alt ty::struct(ccx.tcx, t) {\n               ty::ty_box(_) {\n-                bld::InBoundsGEP(sub.bcx, sub.val,\n+                InBoundsGEP(sub.bcx, sub.val,\n                                           [C_int(0),\n                                            C_int(abi::box_rc_field_body)])\n               }\n               ty::ty_uniq(_) { fail \"uniq lval translation unimplemented\" }\n               ty::ty_res(_, _, _) {\n-                bld::InBoundsGEP(sub.bcx, sub.val, [C_int(0), C_int(1)])\n+                InBoundsGEP(sub.bcx, sub.val, [C_int(0), C_int(1)])\n               }\n               ty::ty_tag(_, _) {\n                 let ety = ty::expr_ty(ccx.tcx, e);\n                 let ellty;\n                 if ty::type_has_dynamic_size(ccx.tcx, ety) {\n                     ellty = T_typaram_ptr(ccx.tn);\n                 } else { ellty = T_ptr(type_of(ccx, e.span, ety)); }\n-                bld::PointerCast(sub.bcx, sub.val, ellty)\n+                PointerCast(sub.bcx, sub.val, ellty)\n               }\n               ty::ty_ptr(_) { sub.val }\n             };\n@@ -3464,22 +3464,22 @@ fn int_cast(bcx: &@block_ctxt, lldsttype: TypeRef, llsrctype: TypeRef,\n     let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n     let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n     ret if dstsz == srcsz {\n-            bld::BitCast(bcx, llsrc, lldsttype)\n+            BitCast(bcx, llsrc, lldsttype)\n         } else if srcsz > dstsz {\n-            bld::TruncOrBitCast(bcx, llsrc, lldsttype)\n+            TruncOrBitCast(bcx, llsrc, lldsttype)\n         } else if signed {\n-            bld::SExtOrBitCast(bcx, llsrc, lldsttype)\n-        } else { bld::ZExtOrBitCast(bcx, llsrc, lldsttype) };\n+            SExtOrBitCast(bcx, llsrc, lldsttype)\n+        } else { ZExtOrBitCast(bcx, llsrc, lldsttype) };\n }\n \n fn float_cast(bcx: &@block_ctxt, lldsttype: TypeRef, llsrctype: TypeRef,\n               llsrc: ValueRef) -> ValueRef {\n     let srcsz = lib::llvm::float_width(llsrctype);\n     let dstsz = lib::llvm::float_width(lldsttype);\n     ret if dstsz > srcsz {\n-            bld::FPExt(bcx, llsrc, lldsttype)\n+            FPExt(bcx, llsrc, lldsttype)\n         } else if srcsz > dstsz {\n-            bld::FPTrunc(bcx, llsrc, lldsttype)\n+            FPTrunc(bcx, llsrc, lldsttype)\n         } else { llsrc };\n }\n \n@@ -3515,22 +3515,22 @@ fn trans_cast(cx: &@block_ctxt, e: &@ast::expr, id: ast::node_id) -> result {\n           }\n           {in: integral., out: float.} {\n             if s_in {\n-                bld::SIToFP(e_res.bcx, e_res.val, ll_t_out)\n-            } else { bld::UIToFP(e_res.bcx, e_res.val, ll_t_out) }\n+                SIToFP(e_res.bcx, e_res.val, ll_t_out)\n+            } else { UIToFP(e_res.bcx, e_res.val, ll_t_out) }\n           }\n           {in: float., out: integral.} {\n             if ty::type_is_signed(ccx.tcx, t_out) {\n-                bld::FPToSI(e_res.bcx, e_res.val, ll_t_out)\n-            } else { bld::FPToUI(e_res.bcx, e_res.val, ll_t_out) }\n+                FPToSI(e_res.bcx, e_res.val, ll_t_out)\n+            } else { FPToUI(e_res.bcx, e_res.val, ll_t_out) }\n           }\n           {in: integral., out: native_.} {\n-            bld::IntToPtr(e_res.bcx, e_res.val, ll_t_out)\n+            IntToPtr(e_res.bcx, e_res.val, ll_t_out)\n           }\n           {in: native_., out: integral.} {\n-            bld::PtrToInt(e_res.bcx, e_res.val, ll_t_out)\n+            PtrToInt(e_res.bcx, e_res.val, ll_t_out)\n           }\n           {in: native_., out: native_.} {\n-            bld::PointerCast(e_res.bcx, e_res.val, ll_t_out)\n+            PointerCast(e_res.bcx, e_res.val, ll_t_out)\n           }\n           _ { ccx.sess.bug(~\"Translating unsupported cast.\") }\n         };\n@@ -3595,7 +3595,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n     let closure_ty = ty::mk_imm_box(cx.ccx.tcx, env_ty);\n     let llclosure_ptr_ty = type_of(cx.ccx, sp, closure_ty);\n     let llclosure =\n-        bld::PointerCast(copy_args_bcx, fcx.llenv, llclosure_ptr_ty);\n+        PointerCast(copy_args_bcx, fcx.llenv, llclosure_ptr_ty);\n \n     // \"target\", in this context, means the function that's having some of its\n     // arguments bound and that will be called inside the thunk we're\n@@ -3618,8 +3618,8 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n     // And then, pick out the target function's own environment.  That's what\n     // we'll use as the environment the thunk gets.\n     let lltargetclosure =\n-        bld::GEP(bcx, lltarget, [C_int(0), C_int(abi::fn_field_box)]);\n-    lltargetclosure = bld::Load(bcx, lltargetclosure);\n+        GEP(bcx, lltarget, [C_int(0), C_int(abi::fn_field_box)]);\n+    lltargetclosure = Load(bcx, lltargetclosure);\n \n     // Get f's return type, which will also be the return type of the entire\n     // bind expression.\n@@ -3633,7 +3633,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n     let llretptr = fcx.llretptr;\n     if ty::type_contains_params(cx.ccx.tcx, outgoing_ret_ty) {\n         let llretty = type_of_inner(cx.ccx, sp, outgoing_ret_ty);\n-        llretptr = bld::PointerCast(bcx, llretptr, T_ptr(llretty));\n+        llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n     }\n \n     // Set up the three implicit arguments to the thunk.\n@@ -3647,7 +3647,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n                          [0, abi::box_rc_field_body,\n                           abi::closure_elt_ty_params, i as int]);\n         copy_args_bcx = lltyparam_ptr.bcx;\n-        let td = bld::Load(copy_args_bcx, lltyparam_ptr.val);\n+        let td = Load(copy_args_bcx, lltyparam_ptr.val);\n         llargs += [td];\n         fcx.lltydescs += [td];\n         i += 1u;\n@@ -3679,10 +3679,10 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n             if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n                 let ty =\n                     if is_val { T_ptr(llout_arg_ty) } else { llout_arg_ty };\n-                val = bld::PointerCast(bcx, val, ty);\n+                val = PointerCast(bcx, val, ty);\n             }\n             if is_val && type_is_immediate(cx.ccx, e_ty) {\n-                val = bld::Load(bcx, val);\n+                val = Load(bcx, val);\n             }\n             llargs += [val];\n             b += 1;\n@@ -3693,7 +3693,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n           none. {\n             let arg: ValueRef = llvm::LLVMGetParam(llthunk, a);\n             if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n-                arg = bld::PointerCast(bcx, arg, llout_arg_ty);\n+                arg = PointerCast(bcx, arg, llout_arg_ty);\n             }\n             llargs += [arg];\n             a += 1u;\n@@ -3703,17 +3703,17 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n     }\n \n     let lltargetfn =\n-        bld::GEP(bcx, lltarget, [C_int(0), C_int(abi::fn_field_code)]);\n+        GEP(bcx, lltarget, [C_int(0), C_int(abi::fn_field_code)]);\n \n     // Cast the outgoing function to the appropriate type.\n     // This is necessary because the type of the function that we have\n     // in the closure does not know how many type descriptors the function\n     // needs to take.\n     let lltargetty =\n         type_of_fn_from_ty(bcx_ccx(bcx), sp, outgoing_fty, ty_param_count);\n-    lltargetfn = bld::PointerCast(bcx, lltargetfn, T_ptr(T_ptr(lltargetty)));\n-    lltargetfn = bld::Load(bcx, lltargetfn);\n-    bld::FastCall(bcx, lltargetfn, llargs);\n+    lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(T_ptr(lltargetty)));\n+    lltargetfn = Load(bcx, lltargetfn);\n+    FastCall(bcx, lltargetfn, llargs);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n     ret {val: llthunk, ty: llthunk_ty};\n@@ -3762,7 +3762,7 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n             // about has the type parameters substituted with the real types.\n             let llclosurety =\n                 T_ptr(type_of(bcx_ccx(cx), cx.sp, outgoing_fty));\n-            let src_loc = bld::PointerCast(bcx, f_res.res.val, llclosurety);\n+            let src_loc = PointerCast(bcx, f_res.res.val, llclosurety);\n             let bound_f = {res: {bcx: bcx, val: src_loc} with f_res};\n             ([outgoing_fty], [bound_f], none)\n         } else { ([], [], some(f_res.res.val)) };\n@@ -3830,9 +3830,9 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n             add_clean_temp(bcx, val, e_ty);\n         } else {\n             if ty::type_is_ivec(ccx.tcx, e_ty) {\n-                let arg_copy = do_spill(bcx, bld::Load(bcx, val));\n+                let arg_copy = do_spill(bcx, Load(bcx, val));\n                 bcx = take_ty(bcx, arg_copy, e_ty).bcx;\n-                val = bld::Load(bcx, arg_copy);\n+                val = Load(bcx, arg_copy);\n             } else if lv.is_mem {\n                 bcx = take_ty(bcx, val, e_ty).bcx;\n                 val = load_if_immediate(bcx, val, e_ty);\n@@ -3848,7 +3848,7 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n \n     if !is_bot && ty::type_contains_params(ccx.tcx, arg.ty) {\n         let lldestty = lldestty0;\n-        val = bld::PointerCast(bcx, val, lldestty);\n+        val = PointerCast(bcx, val, lldestty);\n     }\n \n     // Collect arg for later if it happens to be one we've moving out.\n@@ -3918,7 +3918,7 @@ fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n         // of. If so, cast the caller's view of the restlot to the callee's\n         // view, for the sake of making a type-compatible call.\n         let llretty = T_ptr(type_of_inner(bcx_ccx(bcx), bcx.sp, retty));\n-        llargs += [bld::PointerCast(cx, llretslot, llretty)];\n+        llargs += [PointerCast(cx, llretslot, llretty)];\n     } else { llargs += [llretslot]; }\n \n     // Arg 1: task pointer.\n@@ -3938,9 +3938,9 @@ fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n             if ty::type_contains_params(bcx_tcx(cx), retty) {\n                 let body_ty = ty::mk_iter_body_fn(bcx_tcx(cx), retty);\n                 let body_llty = type_of_inner(bcx_ccx(cx), cx.sp, body_ty);\n-                bld::PointerCast(bcx, lli, T_ptr(body_llty))\n+                PointerCast(bcx, lli, T_ptr(body_llty))\n             } else { lli };\n-        llargs += [bld::Load(cx, lli)];\n+        llargs += [Load(cx, lli)];\n       }\n     }\n \n@@ -3977,7 +3977,7 @@ fn trans_call(in_cx: &@block_ctxt, f: &@ast::expr,\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n     let cx = new_scope_block_ctxt(in_cx, ~\"call\");\n-    bld::Br(in_cx, cx.llbb);\n+    Br(in_cx, cx.llbb);\n     let f_res = trans_lval_gen(cx, f);\n     let fn_ty: ty::t;\n     alt f_res.method_ty {\n@@ -3995,7 +3995,7 @@ fn trans_call(in_cx: &@block_ctxt, f: &@ast::expr,\n     alt f_res.llobj {\n       some(ob) {\n         // It's a vtbl entry.\n-        faddr = bld::Load(bcx, faddr);\n+        faddr = Load(bcx, faddr);\n         llenv = ob;\n       }\n       none. {\n@@ -4006,11 +4006,11 @@ fn trans_call(in_cx: &@block_ctxt, f: &@ast::expr,\n         fn_ty = res.ty;\n \n         let pair = res.val;\n-        faddr = bld::GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_code)]);\n-        faddr = bld::Load(bcx, faddr);\n+        faddr = GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_code)]);\n+        faddr = Load(bcx, faddr);\n         let llclosure =\n-            bld::GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_box)]);\n-        llenv = bld::Load(bcx, llclosure);\n+            GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_box)]);\n+        llenv = Load(bcx, llclosure);\n       }\n     }\n \n@@ -4034,7 +4034,7 @@ fn trans_call(in_cx: &@block_ctxt, f: &@ast::expr,\n        for the call itself is unreachable. */\n     let retval = C_nil();\n     if !is_terminated(bcx) {\n-        bld::FastCall(bcx, faddr, llargs);\n+        FastCall(bcx, faddr, llargs);\n         alt lliterbody {\n           none. {\n             if !ty::type_is_nil(bcx_tcx(cx), ret_ty) {\n@@ -4061,7 +4061,7 @@ fn trans_call(in_cx: &@block_ctxt, f: &@ast::expr,\n         }\n         bcx = trans_block_cleanups(bcx, cx);\n         let next_cx = new_sub_block_ctxt(in_cx, ~\"next\");\n-        bld::Br(bcx, next_cx.llbb);\n+        Br(bcx, next_cx.llbb);\n         bcx = next_cx;\n     }\n     ret rslt(bcx, retval);\n@@ -4197,8 +4197,8 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         let sub =\n             with_out_method(bind trans_block(sub_cx, blk, _), cx, e.id,\n                             output);\n-        bld::Br(cx, sub_cx.llbb);\n-        if !is_terminated(sub.bcx) { bld::Br(sub.bcx, next_cx.llbb); }\n+        Br(cx, sub_cx.llbb);\n+        if !is_terminated(sub.bcx) { Br(sub.bcx, next_cx.llbb); }\n         ret rslt(next_cx, sub.val);\n       }\n       ast::expr_copy(a) {\n@@ -4314,14 +4314,14 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         let c =\n             get_extern_const(bcx_ccx(cx).externs, bcx_ccx(cx).llmod,\n                              ~\"check_claims\", T_bool());\n-        let cond = bld::Load(cx, c);\n+        let cond = Load(cx, c);\n \n         let then_cx = new_scope_block_ctxt(cx, ~\"claim_then\");\n         let check_res = trans_check_expr(then_cx, a, ~\"Claim\");\n         let else_cx = new_scope_block_ctxt(cx, ~\"else\");\n         let els = rslt(else_cx, C_nil());\n \n-        bld::CondBr(cx, cond, then_cx.llbb, else_cx.llbb);\n+        CondBr(cx, cond, then_cx.llbb, else_cx.llbb);\n         ret rslt(join_branches(cx, [check_res, els]), C_nil());\n       }\n       ast::expr_break. { ret trans_break(e.span, cx); }\n@@ -4387,7 +4387,7 @@ fn type_is_immediate(ccx: &@crate_ctxt, t: ty::t) -> bool {\n fn do_spill(cx: &@block_ctxt, v: ValueRef) -> ValueRef {\n     // We have a value but we have to spill it to pass by alias.\n     let llptr = alloca(cx, val_ty(v));\n-    bld::Store(cx, v, llptr);\n+    Store(cx, v, llptr);\n     ret llptr;\n }\n \n@@ -4397,7 +4397,7 @@ fn spill_if_immediate(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n }\n \n fn load_if_immediate(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n-    if type_is_immediate(bcx_ccx(cx), t) { ret bld::Load(cx, v); }\n+    if type_is_immediate(bcx_ccx(cx), t) { ret Load(cx, v); }\n     ret v;\n }\n \n@@ -4424,9 +4424,9 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n     }\n     let log_cx = new_scope_block_ctxt(cx, ~\"log\");\n     let after_cx = new_sub_block_ctxt(cx, ~\"after\");\n-    let load = bld::Load(cx, global);\n-    let test = bld::ICmp(cx, lib::llvm::LLVMIntSGE, load, C_int(lvl));\n-    bld::CondBr(cx, test, log_cx.llbb, after_cx.llbb);\n+    let load = Load(cx, global);\n+    let test = ICmp(cx, lib::llvm::LLVMIntSGE, load, C_int(lvl));\n+    CondBr(cx, test, log_cx.llbb, after_cx.llbb);\n     let sub = trans_expr(log_cx, e);\n     let e_ty = ty::expr_ty(bcx_tcx(cx), e);\n     let log_bcx = sub.bcx;\n@@ -4437,13 +4437,13 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n \n     // Call the polymorphic log function.\n     let llvalptr = spill_if_immediate(log_bcx, sub.val, e_ty);\n-    let llval_i8 = bld::PointerCast(log_bcx, llvalptr, T_ptr(T_i8()));\n+    let llval_i8 = PointerCast(log_bcx, llvalptr, T_ptr(T_i8()));\n \n-    bld::Call(log_bcx, bcx_ccx(log_bcx).upcalls.log_type,\n+    Call(log_bcx, bcx_ccx(log_bcx).upcalls.log_type,\n                        [log_bcx.fcx.lltaskptr, r.val, llval_i8, C_int(lvl)]);\n \n     log_bcx = trans_block_cleanups(log_bcx, log_cx);\n-    bld::Br(log_bcx, after_cx.llbb);\n+    Br(log_bcx, after_cx.llbb);\n     ret rslt(after_cx, C_nil());\n }\n \n@@ -4453,7 +4453,7 @@ fn trans_check_expr(cx: &@block_ctxt, e: &@ast::expr, s: &istr) -> result {\n     let fail_cx = new_sub_block_ctxt(cx, ~\"fail\");\n     trans_fail(fail_cx, some::<span>(e.span), expr_str);\n     let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n-    bld::CondBr(cond_res.bcx, cond_res.val, next_cx.llbb, fail_cx.llbb);\n+    CondBr(cond_res.bcx, cond_res.val, next_cx.llbb, fail_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n \n@@ -4470,7 +4470,7 @@ fn trans_fail_expr(cx: &@block_ctxt, sp_opt: &option::t<span>,\n \n         if ty::type_is_str(tcx, e_ty) {\n             let elt =\n-                bld::GEP(bcx, expr_res.val,\n+                GEP(bcx, expr_res.val,\n                               [C_int(0), C_int(abi::vec_elt_data)]);\n             ret trans_fail_value(bcx, sp_opt, elt);\n         } else {\n@@ -4501,27 +4501,27 @@ fn trans_fail_value(cx: &@block_ctxt, sp_opt: &option::t<span>,\n       }\n       none. { V_filename = C_cstr(bcx_ccx(cx), ~\"<runtime>\"); V_line = 0; }\n     }\n-    let V_str = bld::PointerCast(cx, V_fail_str, T_ptr(T_i8()));\n-    V_filename = bld::PointerCast(cx, V_filename, T_ptr(T_i8()));\n+    let V_str = PointerCast(cx, V_fail_str, T_ptr(T_i8()));\n+    V_filename = PointerCast(cx, V_filename, T_ptr(T_i8()));\n     let args = [cx.fcx.lltaskptr, V_str, V_filename, C_int(V_line)];\n-    bld::Call(cx, bcx_ccx(cx).upcalls._fail, args);\n-    bld::Unreachable(cx);\n+    Call(cx, bcx_ccx(cx).upcalls._fail, args);\n+    Unreachable(cx);\n     ret rslt(cx, C_nil());\n }\n \n fn trans_put(in_cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n     let cx = new_scope_block_ctxt(in_cx, ~\"put\");\n-    bld::Br(in_cx, cx.llbb);\n+    Br(in_cx, cx.llbb);\n     let llcallee = C_nil();\n     let llenv = C_nil();\n     alt { cx.fcx.lliterbody } {\n       some(lli) {\n         let slot = alloca(cx, val_ty(lli));\n-        bld::Store(cx, lli, slot);\n-        llcallee = bld::GEP(cx, slot, [C_int(0), C_int(abi::fn_field_code)]);\n-        llcallee = bld::Load(cx, llcallee);\n-        llenv = bld::GEP(cx, slot, [C_int(0), C_int(abi::fn_field_box)]);\n-        llenv = bld::Load(cx, llenv);\n+        Store(cx, lli, slot);\n+        llcallee = GEP(cx, slot, [C_int(0), C_int(abi::fn_field_code)]);\n+        llcallee = Load(cx, llcallee);\n+        llenv = GEP(cx, slot, [C_int(0), C_int(abi::fn_field_box)]);\n+        llenv = Load(cx, llenv);\n       }\n     }\n     let bcx = cx;\n@@ -4540,10 +4540,10 @@ fn trans_put(in_cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n         llargs += [r.val];\n       }\n     }\n-    bld::FastCall(bcx, llcallee, llargs);\n+    FastCall(bcx, llcallee, llargs);\n     bcx = trans_block_cleanups(bcx, cx);\n     let next_cx = new_sub_block_ctxt(in_cx, ~\"next\");\n-    bld::Br(bcx, next_cx.llbb);\n+    Br(bcx, next_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n \n@@ -4561,7 +4561,7 @@ fn trans_uniq(cx: &@block_ctxt, contents: &@ast::expr) -> lval_result {\n     bcx = r.bcx;\n     let llptrptr = r.val;\n \n-    let llptr = bld::Load(bcx, llptrptr);\n+    let llptr = Load(bcx, llptrptr);\n     r = trans_expr_out(bcx, contents, save_in(llptr));\n     ret lval_val(r.bcx, llptrptr);\n }\n@@ -4576,11 +4576,11 @@ fn trans_break_cont(sp: &span, cx: &@block_ctxt, to_end: bool) -> result {\n         alt { cleanup_cx.kind } {\n           LOOP_SCOPE_BLOCK(_cont, _break) {\n             if to_end {\n-                bld::Br(bcx, _break.llbb);\n+                Br(bcx, _break.llbb);\n             } else {\n                 alt _cont {\n-                  option::some(_cont) { bld::Br(bcx, _cont.llbb); }\n-                  _ { bld::Br(bcx, cleanup_cx.llbb); }\n+                  option::some(_cont) { Br(bcx, _cont.llbb); }\n+                  _ { Br(bcx, cleanup_cx.llbb); }\n                 }\n             }\n             ret rslt(new_sub_block_ctxt(bcx, ~\"break_cont.unreachable\"),\n@@ -4638,7 +4638,7 @@ fn trans_ret(cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n       }\n       _ {\n         let t = llvm::LLVMGetElementType(val_ty(cx.fcx.llretptr));\n-        bld::Store(bcx, C_null(t), cx.fcx.llretptr);\n+        Store(bcx, C_null(t), cx.fcx.llretptr);\n       }\n     }\n     // run all cleanups and back out.\n@@ -4656,7 +4656,7 @@ fn trans_ret(cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n     ret rslt(new_sub_block_ctxt(bcx, ~\"ret.unreachable\"), C_nil());\n }\n \n-fn build_return(bcx: &@block_ctxt) { bld::Br(bcx, bcx_fcx(bcx).llreturn); }\n+fn build_return(bcx: &@block_ctxt) { Br(bcx, bcx_fcx(bcx).llreturn); }\n \n // fn trans_be(cx: &@block_ctxt, e: &@ast::expr) -> result {\n fn trans_be(cx: &@block_ctxt, e: &@ast::expr)\n@@ -4747,7 +4747,7 @@ fn zero_alloca(cx: &@block_ctxt, llptr: ValueRef, t: ty::t) -> result {\n         bcx = call_bzero(llsz.bcx, llptr, llsz.val, C_int(0)).bcx;\n     } else {\n         let llty = type_of(bcx_ccx(bcx), cx.sp, t);\n-        bld::Store(bcx, C_null(llty), llptr);\n+        Store(bcx, C_null(llty), llptr);\n     }\n     ret rslt(bcx, llptr);\n }\n@@ -4859,7 +4859,7 @@ fn trans_fn_cleanups(fcx: &@fn_ctxt, cx: &@block_ctxt) {\n     alt fcx.llobstacktoken {\n       some(lltoken_) {\n         let lltoken = lltoken_; // satisfy alias checker\n-        bld::Call(cx, fcx_ccx(fcx).upcalls.dynastack_free,\n+        Call(cx, fcx_ccx(fcx).upcalls.dynastack_free,\n                   [fcx.lltaskptr, lltoken]);\n       }\n       none. {/* nothing to do */ }\n@@ -5207,18 +5207,18 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n     let n_typarams = std::vec::len::<ast::ty_param>(bcx.fcx.lcx.obj_typarams);\n     let llobj_box_ty: TypeRef = T_obj_ptr(*bcx_ccx(bcx), n_typarams);\n     let box_cell =\n-        bld::GEP(bcx, llself.v, [C_int(0), C_int(abi::obj_field_box)]);\n-    let box_ptr = bld::Load(bcx, box_cell);\n-    box_ptr = bld::PointerCast(bcx, box_ptr, llobj_box_ty);\n+        GEP(bcx, llself.v, [C_int(0), C_int(abi::obj_field_box)]);\n+    let box_ptr = Load(bcx, box_cell);\n+    box_ptr = PointerCast(bcx, box_ptr, llobj_box_ty);\n     let obj_typarams =\n-        bld::GEP(bcx, box_ptr,\n+        GEP(bcx, box_ptr,\n                       [C_int(0), C_int(abi::box_rc_field_body),\n                        C_int(abi::obj_body_elt_typarams)]);\n     // The object fields immediately follow the type parameters, so we skip\n     // over them to get the pointer.\n \n     let et = llvm::LLVMGetElementType(val_ty(obj_typarams));\n-    let obj_fields = bld::Add(bcx, vp2i(bcx, obj_typarams), llsize_of(et));\n+    let obj_fields = Add(bcx, vp2i(bcx, obj_typarams), llsize_of(et));\n     // If we can (i.e. the type is statically sized), then cast the resulting\n     // fields pointer to the appropriate LLVM type. If not, just leave it as\n     // i8 *.\n@@ -5230,8 +5230,8 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n     let i: int = 0;\n     for p: ast::ty_param in fcx.lcx.obj_typarams {\n         let lltyparam: ValueRef =\n-            bld::GEP(bcx, obj_typarams, [C_int(0), C_int(i)]);\n-        lltyparam = bld::Load(bcx, lltyparam);\n+            GEP(bcx, obj_typarams, [C_int(0), C_int(i)]);\n+        lltyparam = Load(bcx, lltyparam);\n         fcx.lltydescs += [lltyparam];\n         i += 1;\n     }\n@@ -5250,16 +5250,16 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n // Ties up the llstaticallocas -> llcopyargs -> llderivedtydescs ->\n // lldynamicallocas -> lltop edges, and builds the return block.\n fn finish_fn(fcx: &@fn_ctxt, lltop: BasicBlockRef) {\n-    bld::Br(new_raw_block_ctxt(fcx, fcx.llstaticallocas), fcx.llcopyargs);\n-    bld::Br(new_raw_block_ctxt(fcx, fcx.llcopyargs),\n+    Br(new_raw_block_ctxt(fcx, fcx.llstaticallocas), fcx.llcopyargs);\n+    Br(new_raw_block_ctxt(fcx, fcx.llcopyargs),\n             fcx.llderivedtydescs_first);\n-    bld::Br(new_raw_block_ctxt(fcx, fcx.llderivedtydescs),\n+    Br(new_raw_block_ctxt(fcx, fcx.llderivedtydescs),\n             fcx.lldynamicallocas);\n-    bld::Br(new_raw_block_ctxt(fcx, fcx.lldynamicallocas), lltop);\n+    Br(new_raw_block_ctxt(fcx, fcx.lldynamicallocas), lltop);\n \n     let ret_cx = new_raw_block_ctxt(fcx, fcx.llreturn);\n     trans_fn_cleanups(fcx, ret_cx);\n-    bld::RetVoid(ret_cx);\n+    RetVoid(ret_cx);\n }\n \n // trans_closure: Builds an LLVM function out of a source function.\n@@ -5387,15 +5387,15 @@ fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n     let llretptr = fcx.llretptr;\n     if ty::type_has_dynamic_size(cx.ccx.tcx, ret_t) {\n         let llret_t = T_ptr(T_struct([T_i32(), llvm::LLVMTypeOf(arg)]));\n-        llretptr = bld::BitCast(bcx, llretptr, llret_t);\n+        llretptr = BitCast(bcx, llretptr, llret_t);\n     }\n \n     let dst = GEP_tup_like(bcx, tup_t, llretptr, [0, 1]);\n     bcx = dst.bcx;\n     bcx = copy_val(bcx, INIT, dst.val, arg, arg_t);\n     let flag = GEP_tup_like(bcx, tup_t, llretptr, [0, 0]);\n     bcx = flag.bcx;\n-    bld::Store(bcx, C_int(1), flag.val);\n+    Store(bcx, C_int(1), flag.val);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n }\n@@ -5449,11 +5449,11 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n             fcx.llretptr\n         } else {\n             let lltagptr =\n-                bld::PointerCast(bcx, fcx.llretptr,\n+                PointerCast(bcx, fcx.llretptr,\n                                       T_opaque_tag_ptr(fcx.lcx.ccx.tn));\n-            let lldiscrimptr = bld::GEP(bcx, lltagptr, [C_int(0), C_int(0)]);\n-            bld::Store(bcx, C_int(index), lldiscrimptr);\n-            bld::GEP(bcx, lltagptr, [C_int(0), C_int(1)])\n+            let lldiscrimptr = GEP(bcx, lltagptr, [C_int(0), C_int(0)]);\n+            Store(bcx, C_int(index), lldiscrimptr);\n+            GEP(bcx, lltagptr, [C_int(0), C_int(1)])\n         };\n     i = 0u;\n     for va: ast::variant_arg in variant.node.args {\n@@ -5469,7 +5469,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n \n         let llargptr;\n         alt fcx.llargs.find(va.id) {\n-          some(x) { llargptr = bld::PointerCast(bcx, x, val_ty(lldestptr)); }\n+          some(x) { llargptr = PointerCast(bcx, x, val_ty(lldestptr)); }\n           none. {\n             bcx_ccx(bcx).sess.bug(~\"unbound argptr in \\\n                                       trans_tag_variant\");\n@@ -5480,7 +5480,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         if ty::type_is_structural(cx.ccx.tcx, arg_ty) ||\n                ty::type_has_dynamic_size(cx.ccx.tcx, arg_ty) {\n             llargval = llargptr;\n-        } else { llargval = bld::Load(bcx, llargptr); }\n+        } else { llargval = Load(bcx, llargptr); }\n         bcx = copy_val(bcx, INIT, lldestptr, llargval, arg_ty);\n         i += 1u;\n     }\n@@ -5658,7 +5658,7 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n         let llargvarg = llvm::LLVMGetParam(llfdecl, 3u);\n         let args = [lloutputarg, lltaskarg, llenvarg];\n         if takes_ivec { args += [llargvarg]; }\n-        bld::FastCall(bcx, main_llfn, args);\n+        FastCall(bcx, main_llfn, args);\n         build_return(bcx);\n \n         finish_fn(fcx, lltop);\n@@ -5694,12 +5694,12 @@ fn create_real_fn_pair(cx: &@block_ctxt, llfnty: TypeRef, llfn: ValueRef,\n     let lcx = cx.fcx.lcx;\n \n     let pair = alloca(cx, T_fn_pair(*lcx.ccx, llfnty));\n-    let code_cell = bld::GEP(cx, pair, [C_int(0), C_int(abi::fn_field_code)]);\n-    bld::Store(cx, llfn, code_cell);\n-    let env_cell = bld::GEP(cx, pair, [C_int(0), C_int(abi::fn_field_box)]);\n+    let code_cell = GEP(cx, pair, [C_int(0), C_int(abi::fn_field_code)]);\n+    Store(cx, llfn, code_cell);\n+    let env_cell = GEP(cx, pair, [C_int(0), C_int(abi::fn_field_box)]);\n     let llenvblobptr =\n-        bld::PointerCast(cx, llenvptr, T_opaque_closure_ptr(*lcx.ccx));\n-    bld::Store(cx, llenvblobptr, env_cell);\n+        PointerCast(cx, llenvptr, T_opaque_closure_ptr(*lcx.ccx));\n+    Store(cx, llenvblobptr, env_cell);\n     ret pair;\n }\n \n@@ -5832,12 +5832,12 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[istr],\n                 let llsrctype = type_of(bcx_ccx(cx), cx.sp, t);\n                 if llvm::LLVMGetIntTypeWidth(lldsttype) >\n                        llvm::LLVMGetIntTypeWidth(llsrctype) {\n-                    ret bld::ZExtOrBitCast(cx, v, T_int());\n+                    ret ZExtOrBitCast(cx, v, T_int());\n                 }\n-                ret bld::TruncOrBitCast(cx, v, T_int());\n+                ret TruncOrBitCast(cx, v, T_int());\n             }\n             if ty::type_is_fp(bcx_tcx(cx), t) {\n-                ret bld::FPToSI(cx, v, T_int());\n+                ret FPToSI(cx, v, T_int());\n             }\n         }\n         ret vp2i(cx, v);\n@@ -5865,8 +5865,8 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[istr],\n                           llnativefnty);\n         let r =\n             if cc == lib::llvm::LLVMCCallConv {\n-                bld::Call(bcx, llnativefn, call_args)\n-            } else { bld::CallWithConv(bcx, llnativefn, call_args, cc) };\n+                Call(bcx, llnativefn, call_args)\n+            } else { CallWithConv(bcx, llnativefn, call_args, cc) };\n         let rptr = bcx.fcx.llretptr;\n         ret {val: r, rptr: rptr};\n     }\n@@ -5913,14 +5913,14 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[istr],\n       _ {\n         r = trans_native_call(new_raw_block_ctxt(bcx.fcx, bcx.llbb),\n                               ccx.externs, ccx.llmod, name, call_args);\n-        rptr = bld::BitCast(bcx, fcx.llretptr, T_ptr(T_i32()));\n+        rptr = BitCast(bcx, fcx.llretptr, T_ptr(T_i32()));\n       }\n     }\n     // We don't store the return value if it's nil, to avoid stomping on a nil\n     // pointer. This is the only concession made to non-i32 return values. See\n     // the FIXME above.\n \n-    if !rty_is_nil && !uses_retptr { bld::Store(bcx, r, rptr); }\n+    if !rty_is_nil && !uses_retptr { Store(bcx, r, rptr); }\n \n     build_return(bcx);\n     finish_fn(fcx, lltop);\n@@ -6066,11 +6066,11 @@ fn trans_constants(ccx: &@crate_ctxt, crate: @ast::crate) {\n }\n \n fn vp2i(cx: &@block_ctxt, v: ValueRef) -> ValueRef {\n-    ret bld::PtrToInt(cx, v, T_int());\n+    ret PtrToInt(cx, v, T_int());\n }\n \n fn vi2p(cx: &@block_ctxt, v: ValueRef, t: TypeRef) -> ValueRef {\n-    ret bld::IntToPtr(cx, v, t);\n+    ret IntToPtr(cx, v, t);\n }\n \n fn p2i(v: ValueRef) -> ValueRef { ret llvm::LLVMConstPtrToInt(v, T_int()); }\n@@ -6119,7 +6119,7 @@ fn declare_intrinsics(llmod: ModuleRef) -> hashmap<istr, ValueRef> {\n fn trap(bcx: &@block_ctxt) {\n     let v: [ValueRef] = [];\n     alt bcx_ccx(bcx).intrinsics.find(~\"llvm.trap\") {\n-      some(x) { bld::Call(bcx, x, v); }\n+      some(x) { Call(bcx, x, v); }\n       _ { bcx_ccx(bcx).sess.bug(~\"unbound llvm.trap in trap\"); }\n     }\n }\n@@ -6131,13 +6131,13 @@ fn decl_no_op_type_glue(llmod: ModuleRef, taskptr_type: TypeRef) -> ValueRef {\n }\n \n fn vec_fill(bcx: &@block_ctxt, v: ValueRef) -> ValueRef {\n-    ret bld::Load(bcx, bld::GEP(bcx, v,\n+    ret Load(bcx, GEP(bcx, v,\n                                      [C_int(0), C_int(abi::vec_elt_fill)]));\n }\n \n fn vec_p0(bcx: &@block_ctxt, v: ValueRef) -> ValueRef {\n-    let p = bld::GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_data)]);\n-    ret bld::PointerCast(bcx, p, T_ptr(T_i8()));\n+    let p = GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_data)]);\n+    ret PointerCast(bcx, p, T_ptr(T_i8()));\n }\n \n fn make_glues(llmod: ModuleRef, taskptr_type: TypeRef) -> @glue_fns {"}, {"sha": "76f4ef1ec0b84581502c2876ede41568a3306c42", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c1ba28c7779a68b74b26ef70acd81d324d97e7dc/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ba28c7779a68b74b26ef70acd81d324d97e7dc/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=c1ba28c7779a68b74b26ef70acd81d324d97e7dc", "patch": "@@ -10,7 +10,7 @@ import lib::llvm::llvm;\n import lib::llvm::llvm::ValueRef;\n import lib::llvm::llvm::TypeRef;\n import lib::llvm::llvm::BasicBlockRef;\n-import bld = trans_build;\n+import trans_build::*;\n import trans::new_sub_block_ctxt;\n import trans::new_scope_block_ctxt;\n import trans::load_if_immediate;\n@@ -212,9 +212,9 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n         vec::len(ty::tag_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n     if size > 0u && vec::len(variants) != 1u {\n         let tagptr =\n-            bld::PointerCast(bcx, val,\n+            PointerCast(bcx, val,\n                                   trans_common::T_opaque_tag_ptr(ccx.tn));\n-        blobptr = bld::GEP(bcx, tagptr, [C_int(0), C_int(1)]);\n+        blobptr = GEP(bcx, tagptr, [C_int(0), C_int(1)]);\n     }\n     let i = 0u;\n     while i < size {\n@@ -291,15 +291,15 @@ fn pick_col(m: &match) -> uint {\n \n fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n                     f: &mk_fail, exits: &mutable [exit_node]) {\n-    if vec::len(m) == 0u { bld::Br(bcx, f()); ret; }\n+    if vec::len(m) == 0u { Br(bcx, f()); ret; }\n     if vec::len(m[0].pats) == 0u {\n         let data = m[0].data;\n         alt data.guard {\n           some(e) {\n             let guard_cx = new_scope_block_ctxt(bcx, ~\"guard\");\n             let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n             let else_cx = new_sub_block_ctxt(bcx, ~\"else\");\n-            bld::Br(bcx, guard_cx.llbb);\n+            Br(bcx, guard_cx.llbb);\n             // Temporarily set bindings. They'll be rewritten to PHI nodes for\n             // the actual arm block.\n             for each @{key, val} in data.id_map.items() {\n@@ -310,15 +310,15 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             let {bcx: guard_bcx, val: guard_val} =\n                 trans::trans_expr(guard_cx, e);\n             guard_bcx = trans::trans_block_cleanups(guard_bcx, guard_cx);\n-            bld::CondBr(guard_bcx, guard_val, next_cx.llbb, else_cx.llbb);\n+            CondBr(guard_bcx, guard_val, next_cx.llbb, else_cx.llbb);\n             compile_submatch(else_cx, vec::slice(m, 1u, vec::len(m)),\n                              vals, f, exits);\n             bcx = next_cx;\n           }\n           _ {}\n         }\n         exits += [{bound: m[0].bound, from: bcx.llbb, to: data.body}];\n-        bld::Br(bcx, data.body);\n+        Br(bcx, data.body);\n         ret;\n     }\n \n@@ -375,9 +375,9 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n \n     // Unbox in case of a box field\n     if any_box_pat(m, col) {\n-        let box = bld::Load(bcx, val);\n+        let box = Load(bcx, val);\n         let unboxed =\n-            bld::InBoundsGEP(bcx, box,\n+            InBoundsGEP(bcx, box,\n                                   [C_int(0),\n                                    C_int(back::abi::box_rc_field_body)]);\n         compile_submatch(bcx, enter_box(m, col, val), [unboxed] + vals_left,\n@@ -397,15 +397,15 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n                 kind = single;\n             } else {\n                 let tagptr =\n-                    bld::PointerCast(bcx, val,\n+                    PointerCast(bcx, val,\n                         trans_common::T_opaque_tag_ptr(ccx.tn));\n-                let discrimptr = bld::GEP(bcx, tagptr, [C_int(0), C_int(0)]);\n-                test_val = bld::Load(bcx, discrimptr);\n+                let discrimptr = GEP(bcx, tagptr, [C_int(0), C_int(0)]);\n+                test_val = Load(bcx, discrimptr);\n                 kind = switch;\n             }\n           }\n           lit(l) {\n-            test_val = bld::Load(bcx, val);\n+            test_val = Load(bcx, val);\n             kind = alt l.node { ast::lit_str(_, _) { compare } _ { switch } };\n           }\n         }\n@@ -417,14 +417,14 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         };\n     let sw =\n         if kind == switch {\n-            bld::Switch(bcx, test_val, else_cx.llbb, vec::len(opts))\n+            Switch(bcx, test_val, else_cx.llbb, vec::len(opts))\n         } else { C_int(0) }; // Placeholder for when not using a switch\n \n      // Compile subtrees for each option\n     for opt: opt in opts {\n         let opt_cx = new_sub_block_ctxt(bcx, ~\"match_case\");\n         alt kind {\n-          single. { bld::Br(bcx, opt_cx.llbb); }\n+          single. { Br(bcx, opt_cx.llbb); }\n           switch. {\n             let r = trans_opt(bcx, opt);\n             bcx = r.bcx;\n@@ -437,7 +437,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             let eq =\n                 trans::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n             bcx = new_sub_block_ctxt(bcx, ~\"next\");\n-            bld::CondBr(eq.bcx, eq.val, opt_cx.llbb, bcx.llbb);\n+            CondBr(eq.bcx, eq.val, opt_cx.llbb, bcx.llbb);\n           }\n           _ { }\n         }\n@@ -457,7 +457,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n     }\n \n     // Compile the fall-through case\n-    if kind == compare { bld::Br(bcx, else_cx.llbb); }\n+    if kind == compare { Br(bcx, else_cx.llbb); }\n     if kind != single {\n         compile_submatch(else_cx, enter_default(m, col, val), vals_left, f,\n                          exits);\n@@ -481,7 +481,7 @@ fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n             }\n         }\n         if vec::len(vals) > 0u {\n-            let phi = bld::Phi(bcx, val_ty(vals[0]), vals, llbbs);\n+            let phi = Phi(bcx, val_ty(vals[0]), vals, llbbs);\n             bcx.fcx.lllocals.insert(item.val, phi);\n         } else { success = false; }\n     }\n@@ -498,7 +498,7 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n         // No need to generate code for alt,\n         // since the disc diverges.\n         if !is_terminated(cx) {\n-            ret rslt(cx, bld::Unreachable(cx));\n+            ret rslt(cx, Unreachable(cx));\n         } else { ret er; }\n     }\n \n@@ -596,9 +596,8 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_box(inner) {\n-        let box = bld::Load(bcx, val);\n-        let unboxed =\n-            bld::InBoundsGEP(bcx, box,\n+        let box = Load(bcx, val);\n+        let unboxed = InBoundsGEP(bcx, box,\n                                   [C_int(0),\n                                    C_int(back::abi::box_rc_field_body)]);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, table, true);"}, {"sha": "1268fa1ee17baf496c10d6082742ef4de8ff0591", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/c1ba28c7779a68b74b26ef70acd81d324d97e7dc/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ba28c7779a68b74b26ef70acd81d324d97e7dc/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=c1ba28c7779a68b74b26ef70acd81d324d97e7dc", "patch": "@@ -22,7 +22,7 @@ import syntax::codemap::span;\n \n import trans_common::*;\n import trans::*;\n-import bld = trans_build;\n+import trans_build::*;\n \n export trans_anon_obj;\n export trans_obj;\n@@ -81,17 +81,17 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n     // of 'pair'.\n     let pair_vtbl =\n-        bld::GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n-    let pair_box = bld::GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n+        GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    let pair_box = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n \n     // Make a vtable for this object: a static array of pointers to functions.\n     // It will be located in the read-only memory of the executable we're\n     // creating and will contain ValueRefs for all of this object's methods.\n     // create_vtbl returns a pointer to the vtable, which we store.\n     let vtbl = create_vtbl(cx, sp, self_ty, ob, ty_params, none, []);\n-    vtbl = bld::PointerCast(bcx, vtbl, T_ptr(T_empty_struct()));\n+    vtbl = PointerCast(bcx, vtbl, T_ptr(T_empty_struct()));\n \n-    bld::Store(bcx, vtbl, pair_vtbl);\n+    Store(bcx, vtbl, pair_vtbl);\n \n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n@@ -104,7 +104,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         // there's not much to do.\n \n         // Store null into pair, if no args or typarams.\n-        bld::Store(bcx, C_null(llbox_ty), pair_box);\n+        Store(bcx, C_null(llbox_ty), pair_box);\n     } else {\n         let obj_fields: [ty::t] = [];\n         for a: ty::arg in arg_tys { obj_fields += [a.ty]; }\n@@ -146,7 +146,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = body_td.bcx;\n-        bld::Store(bcx, body_td.val, body_tydesc.val);\n+        Store(bcx, body_td.val, body_tydesc.val);\n \n         // Copy the object's type parameters and fields into the space we\n         // allocated for the object body.  (This is something like saving the\n@@ -193,8 +193,8 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         }\n \n         // Store box ptr in outer pair.\n-        let p = bld::PointerCast(bcx, box.box, llbox_ty);\n-        bld::Store(bcx, p, pair_box);\n+        let p = PointerCast(bcx, box.box, llbox_ty);\n+        Store(bcx, p, pair_box);\n     }\n     build_return(bcx);\n \n@@ -287,11 +287,11 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n \n     // Grab onto the first and second elements of the pair.\n     let pair_vtbl =\n-        bld::GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n-    let pair_box = bld::GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n+        GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    let pair_box = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n \n-    vtbl = bld::PointerCast(bcx, vtbl, T_ptr(T_empty_struct()));\n-    bld::Store(bcx, vtbl, pair_vtbl);\n+    vtbl = PointerCast(bcx, vtbl, T_ptr(T_empty_struct()));\n+    Store(bcx, vtbl, pair_vtbl);\n \n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n@@ -303,7 +303,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n \n         // If the object we're translating has no fields and no inner_obj,\n         // there's not much to do.\n-        bld::Store(bcx, C_null(llbox_ty), pair_box);\n+        Store(bcx, C_null(llbox_ty), pair_box);\n \n     } else {\n \n@@ -333,7 +333,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n         bcx = body_td.bcx;\n-        bld::Store(bcx, body_td.val, body_tydesc.val);\n+        Store(bcx, body_td.val, body_tydesc.val);\n \n         // Copy the object's fields into the space we allocated for the object\n         // body.  (This is something like saving the lexical environment of a\n@@ -377,8 +377,8 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         }\n \n         // Store box ptr in outer pair.\n-        let p = bld::PointerCast(bcx, box.box, llbox_ty);\n-        bld::Store(bcx, p, pair_box);\n+        let p = PointerCast(bcx, box.box, llbox_ty);\n+        Store(bcx, p, pair_box);\n     }\n \n     // return the object we built.\n@@ -630,23 +630,23 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Cast to self-stack's type.\n     let llenv =\n-        bld::PointerCast(bcx, fcx.llenv,\n+        PointerCast(bcx, fcx.llenv,\n             T_ptr(T_struct([cx.ccx.rust_object_type,\n                             T_ptr(cx.ccx.rust_object_type)])));\n-    let llself_obj_ptr = bld::GEP(bcx, llenv, [C_int(0), C_int(1)]);\n-    llself_obj_ptr = bld::Load(bcx, llself_obj_ptr);\n+    let llself_obj_ptr = GEP(bcx, llenv, [C_int(0), C_int(1)]);\n+    llself_obj_ptr = Load(bcx, llself_obj_ptr);\n \n     // Cast it back to pointer-to-object-type, so LLVM won't complain.\n     llself_obj_ptr =\n-        bld::PointerCast(bcx, llself_obj_ptr, T_ptr(cx.ccx.rust_object_type));\n+        PointerCast(bcx, llself_obj_ptr, T_ptr(cx.ccx.rust_object_type));\n \n     // The 'llretptr' that will arrive in the backwarding function we're\n     // creating also needs to be the correct type.  Cast it to the method's\n     // return type, if necessary.\n     let llretptr = fcx.llretptr;\n     if ty::type_contains_params(cx.ccx.tcx, m.output) {\n         let llretty = type_of_inner(cx.ccx, sp, m.output);\n-        llretptr = bld::PointerCast(bcx, llretptr, T_ptr(llretty));\n+        llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n     }\n \n     // Get the index of the method we want.\n@@ -666,12 +666,12 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n \n     let llouter_obj_vtbl =\n-        bld::GEP(bcx, llself_obj_ptr, [C_int(0), C_int(abi::obj_field_vtbl)]);\n-    llouter_obj_vtbl = bld::Load(bcx, llouter_obj_vtbl);\n-    llouter_obj_vtbl = bld::PointerCast(bcx, llouter_obj_vtbl, vtbl_type);\n+        GEP(bcx, llself_obj_ptr, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    llouter_obj_vtbl = Load(bcx, llouter_obj_vtbl);\n+    llouter_obj_vtbl = PointerCast(bcx, llouter_obj_vtbl, vtbl_type);\n \n     let llouter_mthd =\n-        bld::GEP(bcx, llouter_obj_vtbl, [C_int(0), C_int(ix as int)]);\n+        GEP(bcx, llouter_obj_vtbl, [C_int(0), C_int(ix as int)]);\n \n     // Set up the outer method to be called.\n     let outer_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n@@ -681,8 +681,8 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                         m.inputs, m.output,\n                         std::vec::len::<ast::ty_param>(ty_params));\n     llouter_mthd =\n-        bld::PointerCast(bcx, llouter_mthd, T_ptr(T_ptr(llouter_mthd_ty)));\n-    llouter_mthd = bld::Load(bcx, llouter_mthd);\n+        PointerCast(bcx, llouter_mthd, T_ptr(T_ptr(llouter_mthd_ty)));\n+    llouter_mthd = Load(bcx, llouter_mthd);\n \n     // Set up the three implicit arguments to the outer method we'll need to\n     // call.\n@@ -703,7 +703,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     }\n \n     // And, finally, call the outer method.\n-    bld::FastCall(bcx, llouter_mthd, llouter_mthd_args);\n+    FastCall(bcx, llouter_mthd, llouter_mthd_args);\n \n     build_return(bcx);\n     finish_fn(fcx, lltop);\n@@ -765,7 +765,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let llretptr = fcx.llretptr;\n     if ty::type_contains_params(cx.ccx.tcx, m.output) {\n         let llretty = type_of_inner(cx.ccx, sp, m.output);\n-        llretptr = bld::PointerCast(bcx, llretptr, T_ptr(llretty));\n+        llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n     }\n \n     // Now, we have to get the the inner_obj's vtbl out of the self_obj.  This\n@@ -774,16 +774,16 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // First, grab the box out of the self_obj.  It contains a refcount and a\n     // body.\n     let llself_obj_box =\n-        bld::GEP(bcx, llself_obj_ptr, [C_int(0), C_int(abi::obj_field_box)]);\n-    llself_obj_box = bld::Load(bcx, llself_obj_box);\n+        GEP(bcx, llself_obj_ptr, [C_int(0), C_int(abi::obj_field_box)]);\n+    llself_obj_box = Load(bcx, llself_obj_box);\n \n     let ccx = bcx_ccx(bcx);\n     let llbox_ty = T_opaque_obj_ptr(*ccx);\n-    llself_obj_box = bld::PointerCast(bcx, llself_obj_box, llbox_ty);\n+    llself_obj_box = PointerCast(bcx, llself_obj_box, llbox_ty);\n \n     // Now, reach into the box and grab the body.\n     let llself_obj_body =\n-        bld::GEP(bcx, llself_obj_box,\n+        GEP(bcx, llself_obj_box,\n                       [C_int(0), C_int(abi::box_rc_field_body)]);\n \n     // Now, we need to figure out exactly what type the body is supposed to be\n@@ -793,7 +793,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                                 some(inner_obj_ty));\n     // And cast to that type.\n     llself_obj_body =\n-        bld::PointerCast(bcx, llself_obj_body,\n+        PointerCast(bcx, llself_obj_body,\n                               T_ptr(type_of(cx.ccx, sp, body_ty)));\n \n     // Now, reach into the body and grab the inner_obj.\n@@ -807,13 +807,13 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // method's entry out of the vtable so that the forwarding function can\n     // call it.\n     let llinner_obj_vtbl =\n-        bld::GEP(bcx, llinner_obj.val,\n+        GEP(bcx, llinner_obj.val,\n                       [C_int(0), C_int(abi::obj_field_vtbl)]);\n-    llinner_obj_vtbl = bld::Load(bcx, llinner_obj_vtbl);\n+    llinner_obj_vtbl = Load(bcx, llinner_obj_vtbl);\n \n     let llinner_obj_body =\n-        bld::GEP(bcx, llinner_obj.val, [C_int(0), C_int(abi::obj_field_box)]);\n-    llinner_obj_body = bld::Load(bcx, llinner_obj_body);\n+        GEP(bcx, llinner_obj.val, [C_int(0), C_int(abi::obj_field_box)]);\n+    llinner_obj_body = Load(bcx, llinner_obj_body);\n \n     // Get the index of the method we want.\n     let ix: uint = 0u;\n@@ -830,10 +830,10 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Pick out the original method from the vtable.\n     let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n-    llinner_obj_vtbl = bld::PointerCast(bcx, llinner_obj_vtbl, vtbl_type);\n+    llinner_obj_vtbl = PointerCast(bcx, llinner_obj_vtbl, vtbl_type);\n \n     let llorig_mthd =\n-        bld::GEP(bcx, llinner_obj_vtbl, [C_int(0), C_int(ix as int)]);\n+        GEP(bcx, llinner_obj_vtbl, [C_int(0), C_int(ix as int)]);\n \n     // Set up the original method to be called.\n     let orig_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n@@ -843,8 +843,8 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                         m.inputs, m.output,\n                         std::vec::len::<ast::ty_param>(ty_params));\n     llorig_mthd =\n-        bld::PointerCast(bcx, llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n-    llorig_mthd = bld::Load(bcx, llorig_mthd);\n+        PointerCast(bcx, llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n+    llorig_mthd = Load(bcx, llorig_mthd);\n \n     // Set up the self-stack.\n     let self_stack =\n@@ -857,7 +857,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Cast self_stack back to pointer-to-object-type to make LLVM happy.\n     self_stack =\n-        bld::PointerCast(bcx, self_stack, T_ptr(cx.ccx.rust_object_type));\n+        PointerCast(bcx, self_stack, T_ptr(cx.ccx.rust_object_type));\n \n     // Set up the three implicit arguments to the original method we'll need\n     // to call.\n@@ -877,7 +877,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     }\n \n     // And, finally, call the original (inner) method.\n-    bld::FastCall(bcx, llorig_mthd, llorig_mthd_args);\n+    FastCall(bcx, llorig_mthd, llorig_mthd_args);\n \n     build_return(bcx);\n     finish_fn(fcx, lltop);\n@@ -955,19 +955,19 @@ fn populate_self_stack(bcx: @block_ctxt, self_stack: ValueRef,\n                        inner_obj_body: ValueRef) -> ValueRef {\n \n     // Drop the outer obj into the second slot.\n-    let self_pair_ptr = bld::GEP(bcx, self_stack, [C_int(0), C_int(1)]);\n-    bld::Store(bcx, outer_obj, self_pair_ptr);\n+    let self_pair_ptr = GEP(bcx, self_stack, [C_int(0), C_int(1)]);\n+    Store(bcx, outer_obj, self_pair_ptr);\n \n     // Drop in the backwarding vtbl.\n-    let wrapper_pair = bld::GEP(bcx, self_stack, [C_int(0), C_int(0)]);\n-    let wrapper_vtbl_ptr = bld::GEP(bcx, wrapper_pair, [C_int(0), C_int(0)]);\n+    let wrapper_pair = GEP(bcx, self_stack, [C_int(0), C_int(0)]);\n+    let wrapper_vtbl_ptr = GEP(bcx, wrapper_pair, [C_int(0), C_int(0)]);\n     let backwarding_vtbl_cast =\n-        bld::PointerCast(bcx, backwarding_vtbl, T_ptr(T_empty_struct()));\n-    bld::Store(bcx, backwarding_vtbl_cast, wrapper_vtbl_ptr);\n+        PointerCast(bcx, backwarding_vtbl, T_ptr(T_empty_struct()));\n+    Store(bcx, backwarding_vtbl_cast, wrapper_vtbl_ptr);\n \n     // Drop in the inner obj body.\n-    let wrapper_body_ptr = bld::GEP(bcx, wrapper_pair, [C_int(0), C_int(1)]);\n-    bld::Store(bcx, inner_obj_body, wrapper_body_ptr);\n+    let wrapper_body_ptr = GEP(bcx, wrapper_pair, [C_int(0), C_int(1)]);\n+    Store(bcx, inner_obj_body, wrapper_body_ptr);\n \n     ret self_stack;\n }"}]}