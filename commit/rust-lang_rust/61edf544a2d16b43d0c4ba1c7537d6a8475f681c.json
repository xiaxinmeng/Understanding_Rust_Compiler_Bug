{"sha": "61edf544a2d16b43d0c4ba1c7537d6a8475f681c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZWRmNTQ0YTJkMTZiNDNkMGM0YmExYzc1MzdkNmE4NDc1ZjY4MWM=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-02-28T00:44:57Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-02T18:28:14Z"}, "message": "Implement #fmt conversion for int and uint", "tree": {"sha": "177669ff5ce99c71235b2e122240957c25618250", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/177669ff5ce99c71235b2e122240957c25618250"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61edf544a2d16b43d0c4ba1c7537d6a8475f681c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61edf544a2d16b43d0c4ba1c7537d6a8475f681c", "html_url": "https://github.com/rust-lang/rust/commit/61edf544a2d16b43d0c4ba1c7537d6a8475f681c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61edf544a2d16b43d0c4ba1c7537d6a8475f681c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9144d5972aef3e7078b272703bf275691991297", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9144d5972aef3e7078b272703bf275691991297", "html_url": "https://github.com/rust-lang/rust/commit/f9144d5972aef3e7078b272703bf275691991297"}], "stats": {"total": 115, "additions": 107, "deletions": 8}, "files": [{"sha": "bd5bab5b7ae1abc49c16faa75e5595579eb12a18", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 107, "deletions": 8, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/61edf544a2d16b43d0c4ba1c7537d6a8475f681c/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61edf544a2d16b43d0c4ba1c7537d6a8475f681c/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=61edf544a2d16b43d0c4ba1c7537d6a8475f681c", "patch": "@@ -21,6 +21,8 @@ import std.option;\n import std.option.none;\n import std.option.some;\n \n+export expand_syntax_ext;\n+\n tag signedness {\n     signed;\n     unsigned;\n@@ -61,7 +63,7 @@ type conv = rec(option.t[int] param,\n                 vec[flag] flags,\n                 count width,\n                 count precision,\n-                ty typ);\n+                ty ty);\n \n // A fragment of the output sequence\n tag piece {\n@@ -74,6 +76,7 @@ fn bad_fmt_call() {\n     fail;\n }\n \n+// TODO: Need to thread parser through here to handle errors correctly\n fn expand_syntax_ext(vec[@ast.expr] args,\n                      option.t[@ast.expr] body) -> @ast.expr {\n \n@@ -96,6 +99,8 @@ fn expand_syntax_ext(vec[@ast.expr] args,\n         }\n     }\n     log \"done printing all pieces\";\n+    auto args_len = _vec.len[@ast.expr](args);\n+    auto fmt_args = _vec.slice[@ast.expr](args, 1u, args_len - 1u);\n     ret pieces_to_expr(pieces, args);\n }\n \n@@ -179,7 +184,7 @@ fn parse_conversion(str s, uint i, uint lim) -> tup(piece, uint) {\n                            flags = flags._0,\n                            width = width._0,\n                            precision = prec._0,\n-                           typ = ty._0)),\n+                           ty = ty._0)),\n             ty._1);\n }\n \n@@ -252,22 +257,107 @@ fn parse_type(str s, uint i, uint lim) -> tup(ty, uint) {\n \n fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n \n-    fn make_new_str(common.span sp, str s) -> @ast.expr {\n-        auto strlit = ast.lit_str(s);\n-        auto spstrlit = @parser.spanned[ast.lit_](sp, sp, strlit);\n-        auto expr = ast.expr_lit(spstrlit, ast.ann_none);\n+    fn make_new_lit(common.span sp, ast.lit_ lit) -> @ast.expr {\n+        auto sp_lit = @parser.spanned[ast.lit_](sp, sp, lit);\n+        auto expr = ast.expr_lit(sp_lit, ast.ann_none);\n         ret @parser.spanned[ast.expr_](sp, sp, expr);\n     }\n \n+    fn make_new_str(common.span sp, str s) -> @ast.expr {\n+        auto lit = ast.lit_str(s);\n+        ret make_new_lit(sp, lit);\n+    }\n+\n+    fn make_new_uint(common.span sp, uint u) -> @ast.expr {\n+        auto lit = ast.lit_uint(u);\n+        ret make_new_lit(sp, lit);\n+    }\n+\n     fn make_add_expr(common.span sp,\n                      @ast.expr lhs, @ast.expr rhs) -> @ast.expr {\n         auto binexpr = ast.expr_binary(ast.add, lhs, rhs, ast.ann_none);\n         ret @parser.spanned[ast.expr_](sp, sp, binexpr);\n     }\n \n+    fn make_call(common.span sp, vec[ast.ident] fn_path,\n+                 vec[@ast.expr] args) -> @ast.expr {\n+        let vec[ast.ident] path_idents = fn_path;\n+        let vec[@ast.ty] path_types = vec();\n+        auto path = rec(idents = path_idents, types = path_types);\n+        auto sp_path = parser.spanned[ast.path_](sp, sp, path);\n+        auto pathexpr = ast.expr_path(sp_path, none[ast.def], ast.ann_none);\n+        auto sp_pathexpr = @parser.spanned[ast.expr_](sp, sp, pathexpr);\n+        auto callexpr = ast.expr_call(sp_pathexpr, args, ast.ann_none);\n+        auto sp_callexpr = @parser.spanned[ast.expr_](sp, sp, callexpr);\n+        ret sp_callexpr;\n+    }\n+\n+    fn make_new_conv(conv cnv, @ast.expr arg) -> @ast.expr {\n+\n+        auto unsupported = \"conversion not supported in #fmt string\";\n+\n+        alt (cnv.param) {\n+            case (option.none[int]) {\n+            }\n+            case (_) {\n+                log unsupported;\n+                fail;\n+            }\n+        }\n+\n+        if (_vec.len[flag](cnv.flags) != 0u) {\n+            log unsupported;\n+            fail;\n+        }\n+\n+        alt (cnv.width) {\n+            case (count_implied) {\n+            }\n+            case (_) {\n+                log unsupported;\n+                fail;\n+            }\n+        }\n+\n+        alt (cnv.precision) {\n+            case (count_implied) {\n+            }\n+            case (_) {\n+                log unsupported;\n+                fail;\n+            }\n+        }\n+\n+        alt (cnv.ty) {\n+            case (ty_str) {\n+                ret arg;\n+            }\n+            case (ty_int(?sign)) {\n+                alt (sign) {\n+                    case (signed) {\n+                        let vec[str] path = vec(\"std\", \"_int\", \"to_str\");\n+                        auto radix_expr = make_new_uint(arg.span, 10u);\n+                        let vec[@ast.expr] args = vec(arg, radix_expr);\n+                        ret make_call(arg.span, path, args);\n+                    }\n+                    case (unsigned) {\n+                        let vec[str] path = vec(\"std\", \"_uint\", \"to_str\");\n+                        auto radix_expr = make_new_uint(arg.span, 10u);\n+                        let vec[@ast.expr] args = vec(arg, radix_expr);\n+                        ret make_call(arg.span, path, args);\n+                    }\n+                }\n+            }\n+            case (_) {\n+                log unsupported;\n+                fail;\n+            }\n+        }\n+    }\n+\n     auto sp = args.(0).span;\n-    auto n = 0;\n-    auto tmp_expr = make_new_str(sp, \"whatever\");\n+    auto n = 0u;\n+    auto tmp_expr = make_new_str(sp, \"\");\n \n     for (piece p in pieces) {\n         alt (p) {\n@@ -276,6 +366,15 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n                 tmp_expr = make_add_expr(sp, tmp_expr, s_expr);\n             }\n             case (piece_conv(?conv)) {\n+                if (n >= _vec.len[@ast.expr](args)) {\n+                    log \"too many conversions in #fmt string\";\n+                    fail;\n+                }\n+\n+                n += 1u;\n+                auto arg_expr = args.(n);\n+                auto c_expr = make_new_conv(conv, arg_expr);\n+                tmp_expr = make_add_expr(sp, tmp_expr, c_expr);\n             }\n         }\n     }"}]}