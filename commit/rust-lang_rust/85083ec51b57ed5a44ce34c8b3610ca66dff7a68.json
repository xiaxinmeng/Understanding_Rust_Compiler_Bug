{"sha": "85083ec51b57ed5a44ce34c8b3610ca66dff7a68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MDgzZWM1MWI1N2VkNWE0NGNlMzRjOGIzNjEwY2E2NmRmZjdhNjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-10T17:14:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-16T23:16:40Z"}, "message": "begin efforts to use shim functions for c-stack calls", "tree": {"sha": "1c784554a3beb26ca0767f86262ca920ecd2331d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c784554a3beb26ca0767f86262ca920ecd2331d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85083ec51b57ed5a44ce34c8b3610ca66dff7a68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85083ec51b57ed5a44ce34c8b3610ca66dff7a68", "html_url": "https://github.com/rust-lang/rust/commit/85083ec51b57ed5a44ce34c8b3610ca66dff7a68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85083ec51b57ed5a44ce34c8b3610ca66dff7a68/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfbaa3d1e1b43eda2016a936dd4095bd79e64a1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfbaa3d1e1b43eda2016a936dd4095bd79e64a1b", "html_url": "https://github.com/rust-lang/rust/commit/bfbaa3d1e1b43eda2016a936dd4095bd79e64a1b"}], "stats": {"total": 243, "additions": 166, "deletions": 77}, "files": [{"sha": "1f1eae1d4ae875ee6b4f599c9a982717efd5c67f", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/85083ec51b57ed5a44ce34c8b3610ca66dff7a68/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85083ec51b57ed5a44ce34c8b3610ca66dff7a68/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=85083ec51b57ed5a44ce34c8b3610ca66dff7a68", "patch": "@@ -26,9 +26,7 @@ type upcalls =\n      dynastack_alloc: ValueRef,\n      dynastack_free: ValueRef,\n      alloc_c_stack: ValueRef,\n-     call_c_stack: ValueRef,\n-     call_c_stack_i64: ValueRef,\n-     call_c_stack_float: ValueRef,\n+     call_c_stack_shim: ValueRef,\n      rust_personality: ValueRef};\n \n fn declare_upcalls(targ_cfg: @session::config,\n@@ -46,7 +44,6 @@ fn declare_upcalls(targ_cfg: @session::config,\n     let dv = bind decl(llmod, _, _, T_void());\n \n     let int_t = T_int(targ_cfg);\n-    let float_t = T_float(targ_cfg);\n     let size_t = T_size_t(targ_cfg);\n     let opaque_vec_t = T_opaque_vec(targ_cfg);\n \n@@ -88,15 +85,11 @@ fn declare_upcalls(targ_cfg: @session::config,\n                 T_ptr(T_i8())),\n           dynastack_free: dv(\"dynastack_free\", [T_ptr(T_i8())]),\n           alloc_c_stack: d(\"alloc_c_stack\", [size_t], T_ptr(T_i8())),\n-          call_c_stack: d(\"call_c_stack\",\n-                              [T_ptr(T_fn([], int_t)), T_ptr(T_i8())],\n-                              int_t),\n-          call_c_stack_i64: d(\"call_c_stack_i64\",\n-                              [T_ptr(T_fn([], int_t)), T_ptr(T_i8())],\n-                              T_i64()),\n-          call_c_stack_float: d(\"call_c_stack_float\",\n-                                [T_ptr(T_fn([], int_t)), T_ptr(T_i8())],\n-                                float_t),\n+          call_c_stack_shim: d(\"call_c_stack_shim\",\n+                          // first arg is func ptr, but type of func varies,\n+                          // so just call it char* for LLVM\n+                          [T_ptr(T_i8()), T_ptr(T_i8())],\n+                          int_t),\n           rust_personality: d(\"rust_personality\", [], T_i32())\n          };\n }"}, {"sha": "da6a350d08a0df028633f2f71fa08c862464f3bd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 142, "deletions": 63, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/85083ec51b57ed5a44ce34c8b3610ca66dff7a68/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85083ec51b57ed5a44ce34c8b3610ca66dff7a68/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=85083ec51b57ed5a44ce34c8b3610ca66dff7a68", "patch": "@@ -1607,8 +1607,8 @@ fn compare_scalar_values(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n type val_pair_fn = fn(@block_ctxt, ValueRef, ValueRef) -> @block_ctxt;\n type val_and_ty_fn = fn(@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n \n-fn load_inbounds(cx: @block_ctxt, p: ValueRef, idxs: [ValueRef]) -> ValueRef {\n-    ret Load(cx, InBoundsGEP(cx, p, idxs));\n+fn load_inbounds(cx: @block_ctxt, p: ValueRef, idxs: [int]) -> ValueRef {\n+    ret Load(cx, GEPi(cx, p, idxs));\n }\n \n fn store_inbounds(cx: @block_ctxt, v: ValueRef, p: ValueRef,\n@@ -3833,7 +3833,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n }\n \n // Translates a native call on the C stack. Calls into the runtime to perform\n-// the stack switching operation.\n+// the stack switching operation. Must be kept in sync with trans_native_mod().\n fn trans_c_stack_native_call(bcx: @block_ctxt, f: @ast::expr,\n                              args: [@ast::expr], dest: dest) -> @block_ctxt {\n     let ccx = bcx_ccx(bcx);\n@@ -3846,74 +3846,37 @@ fn trans_c_stack_native_call(bcx: @block_ctxt, f: @ast::expr,\n     let fn_arg_tys = ty::ty_fn_args(bcx_tcx(bcx), fn_ty);\n     let llargtys = type_of_explicit_args(ccx, f.span, fn_arg_tys);\n \n-    // Translate arguments.\n-    let (to_zero, to_revoke) = ([], []);\n-    let i = 0u, n = vec::len(args);\n-    let llargs = [];\n-    while i < n {\n-        let ty_arg = fn_arg_tys[i];\n-        let arg = args[i];\n-        let llargty = llargtys[i];\n-        let r = trans_arg_expr(bcx, ty_arg, llargty, to_zero, to_revoke, arg);\n-        let llargval = r.val; bcx = r.bcx;\n-        llargs += [\n-            { llval: llargval, llty: llargty }\n-        ];\n-        i += 1u;\n-    }\n+    // Determine return type.\n+    let ret_ty = ty::ty_fn_ret(bcx_tcx(bcx), fn_ty);\n+    check type_has_static_size(ccx, ret_ty);\n+    let llretty = type_of(ccx, f.span, ret_ty);\n \n     // Allocate the argument bundle.\n-    let llargbundlety = T_struct(vec::map({ |r| r.llty }, llargs));\n+    let llargbundlety = T_struct(llargtys + [llretty]);\n     let llargbundlesz = llsize_of(ccx, llargbundlety);\n     let llrawargbundle = Call(bcx, ccx.upcalls.alloc_c_stack,\n                               [llargbundlesz]);\n     let llargbundle = PointerCast(bcx, llrawargbundle, T_ptr(llargbundlety));\n \n-    // Copy in arguments.\n-    let i = 0u, n = vec::len(llargs);\n+    // Translate arguments and store into bundle.\n+    let (to_zero, to_revoke) = ([], []);\n+    let i = 0u, n = vec::len(args);\n     while i < n {\n-        let llarg = llargs[i].llval;\n-        store_inbounds(bcx, llarg, llargbundle, [0, i as int]);\n+        let ty_arg = fn_arg_tys[i];\n+        let arg = args[i];\n+        let llargty = llargtys[i];\n+        let r = trans_arg_expr(bcx, ty_arg, llargty, to_zero, to_revoke, arg);\n+        bcx = r.bcx;\n+        store_inbounds(bcx, r.val, llargbundle, [0, i as int]);\n         i += 1u;\n     }\n \n-    // Determine return type.\n-    let ret_ty = ty::ty_fn_ret(bcx_tcx(bcx), fn_ty);\n-    check type_has_static_size(ccx, ret_ty);\n-    let llretty = type_of(ccx, f.span, ret_ty);\n-\n-    // Determine which upcall fn to use based on the return type.\n-    let upcall_fn = alt lib::llvm::llvm::LLVMGetTypeKind(llretty) {\n-      1 | 2 | 3 | 4 | 5 {\n-        // LLVMFloatTypeKind, LLVMDoubleTypeKind,\n-        // LLVMX86_FP80TypeKind, LLVMFP128TypeKind\n-        // LLVMPPC_FP128TypeKind\n-        ccx.upcalls.call_c_stack_float\n-      }\n-\n-      7 {\n-        // LLVMIntegerTypeKind\n-        let width = lib::llvm::llvm::LLVMGetIntTypeWidth(llretty);\n-        if width == 64u { ccx.upcalls.call_c_stack_i64 }\n-        else { ccx.upcalls.call_c_stack } // on 64-bit target, no diff\n-      }\n-\n-      _ { ccx.upcalls.call_c_stack }\n-    };\n-\n-    // Call and cast the return type.\n-    // TODO: Invoke instead.\n-    let llrawretval = Call(bcx, upcall_fn, [llfn, llrawargbundle]);\n-    let llretval;\n-    if lib::llvm::llvm::LLVMGetTypeKind(llretty) as int == 11 { // pointer\n-        llretval = IntToPtr(bcx, llrawretval, llretty);\n-    } else {\n-        llretval = TruncOrBitCast(bcx, llrawretval, llretty);\n-    }\n-\n-    // Forget about anything we moved out.\n-    bcx = zero_and_revoke(bcx, to_zero, to_revoke);\n-    ret store_in_dest(bcx, llretval, dest);\n+    // Call the upcall function then extract return value from the bundle.\n+    let upcall_fn = ccx.upcalls.call_c_stack_shim;\n+    let llfnptr = PointerCast(bcx, llfn, T_ptr(T_i8()));\n+    Call(bcx, upcall_fn, [llfnptr, llrawargbundle]);\n+    let llres = load_inbounds(bcx, llargbundle, [0, n as int]);\n+    ret store_in_dest(bcx, llres, dest);\n }\n \n fn zero_and_revoke(bcx: @block_ctxt,\n@@ -5373,6 +5336,116 @@ fn trans_const(cx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n     }\n }\n \n+type c_stack_tys = {\n+    arg_tys: [TypeRef],\n+    ret_ty: TypeRef,\n+    base_fn_ty: TypeRef,\n+    bundle_ty: TypeRef,\n+    shim_fn_ty: TypeRef\n+};\n+\n+fn c_stack_tys(ccx: @crate_ctxt,\n+               sp: span,\n+               id: ast::node_id) -> @c_stack_tys {\n+    alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)) {\n+      ty::ty_native_fn(_, arg_tys, ret_ty) {\n+        let llargtys = type_of_explicit_args(ccx, sp, arg_tys);\n+        check non_ty_var(ccx, ret_ty); // NDM does this truly hold?\n+        let llretty = type_of_inner(ccx, sp, ret_ty);\n+        let bundle_ty = T_struct(llargtys + [llretty]);\n+        ret @{\n+            arg_tys: llargtys,\n+            ret_ty: llretty,\n+            base_fn_ty: T_fn(llargtys, llretty),\n+            bundle_ty: bundle_ty,\n+            shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void())\n+        };\n+      }\n+\n+      _ {\n+        ccx.sess.span_fatal(\n+            sp,\n+            \"Non-function type for native fn\");\n+      }\n+    }\n+}\n+\n+// For c-stack ABIs, we must generate shim functions for making\n+// the call.  These shim functions will unpack arguments out of\n+// a struct and then invoke the base function.\n+//\n+// Example: Given a native c-stack function F(x: X, y: Y) -> Z,\n+// we generate a shim function S that is something like:\n+//\n+//     void S(struct F_Args { X x; Y y; Z *z; } *args) {\n+//         *args->z = F(args->x, args->y);\n+//     }\n+//\n+fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod) {\n+    fn build_shim_fn(lcx: @local_ctxt, native_item: @ast::native_item,\n+                     llshimfn: ValueRef) {\n+        let ccx = lcx_ccx(lcx);\n+        let span = native_item.span;\n+        let id = native_item.id;\n+        let tys = c_stack_tys(ccx, span, id);\n+\n+        // Declare the \"prototype\" for the base function F:\n+        let name = native_item.ident;\n+        let llbasefn = decl_cdecl_fn(ccx.llmod, name, tys.base_fn_ty);\n+\n+        // Declare the body of the shim function:\n+        let fcx = new_fn_ctxt(lcx, span, llshimfn);\n+        let bcx = new_top_block_ctxt(fcx);\n+        let lltop = bcx.llbb;\n+        let llargbundle = llvm::LLVMGetParam(llshimfn, 0u);\n+        let i = 0u, n = vec::len(tys.arg_tys);\n+        let llargvals = [];\n+        while i < n {\n+            let llargval = load_inbounds(bcx, llargbundle, [0, i as int]);\n+            llargvals += [llargval];\n+            i += 1u;\n+        }\n+\n+        // Create the call itself:\n+        let llretval = Call(bcx, llbasefn, llargvals);\n+        //log_err(\"llretval\", val_str(ccx.tn, llretval),\n+        //        \"llargbundle\", val_str(ccx.tn, llargbundle),\n+        //        \"tys.ret_ty\", ty_str(ccx.tn, tys.ret_ty),\n+        //        \"n\", n);\n+        store_inbounds(bcx, llretval, llargbundle, [0, n as int]);\n+\n+        // Finish up.\n+        build_return(bcx);\n+        finish_fn(fcx, lltop);\n+    }\n+\n+    let ccx = lcx_ccx(lcx);\n+    alt native_mod.abi {\n+      ast::native_abi_cdecl. {\n+        for native_item in native_mod.items {\n+            alt native_item.node {\n+              ast::native_item_ty. {}\n+              ast::native_item_fn(_, fn_decl, _) {\n+                let id = native_item.id;\n+                alt ccx.item_ids.find(id) {\n+                  some(llshimfn) {\n+                    build_shim_fn(lcx, native_item, llshimfn);\n+                  }\n+\n+                  none. {\n+                    ccx.sess.span_fatal(\n+                        native_item.span,\n+                        \"unbound function item in trans_native_mod\");\n+                  }\n+                }\n+              }\n+            }\n+        }\n+      }\n+      _ { /* nothing to do for other ABIs */ }\n+    }\n+}\n+\n fn trans_item(cx: @local_ctxt, item: ast::item) {\n     alt item.node {\n       ast::item_fn(f, tps) {\n@@ -5422,6 +5495,9 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n         }\n       }\n       ast::item_const(_, expr) { trans_const(cx.ccx, expr, item.id); }\n+      ast::item_native_mod(native_mod) {\n+        trans_native_mod(cx, native_mod);\n+      }\n       _ {/* fall through */ }\n     }\n }\n@@ -5641,9 +5717,12 @@ fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n         cast_to_i32 = false;\n       }\n       ast::native_abi_cdecl. {\n-        let llfn = decl_cdecl_fn(ccx.llmod, name, T_fn([], ccx.int_type));\n-        ccx.item_ids.insert(id, llfn);\n-        ccx.item_symbols.insert(id, name);\n+        let tys = c_stack_tys(ccx, sp, id);\n+        let shim_name = name + \"__c_stack_shim\";\n+        let llshimfn = decl_internal_cdecl_fn(\n+            ccx.llmod, shim_name, tys.shim_fn_ty);\n+        ccx.item_ids.insert(id, llshimfn);\n+        ccx.item_symbols.insert(id, shim_name);\n         ret;\n       }\n       ast::native_abi_stdcall. {"}, {"sha": "3e32de879a728824deef3422529acefdabf5c864", "filename": "src/rt/arch/i386/ccall.S", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/85083ec51b57ed5a44ce34c8b3610ca66dff7a68/src%2Frt%2Farch%2Fi386%2Fccall.S", "raw_url": "https://github.com/rust-lang/rust/raw/85083ec51b57ed5a44ce34c8b3610ca66dff7a68/src%2Frt%2Farch%2Fi386%2Fccall.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fccall.S?ref=85083ec51b57ed5a44ce34c8b3610ca66dff7a68", "patch": "@@ -1,6 +1,6 @@\n     .text\n \n-// upcall_call_c_stack(void (*fn)(), void *new_esp)\n+// upcall_call_c_stack(void (*fn)(), void *arg_struct)\n //\n // Note that we could use |enter| and |leave| but the manuals tell me they're\n // slower.\n@@ -28,3 +28,19 @@ upcall_call_c_stack_float:\n     popl %ebp\n     ret\n \n+#if defined(__APPLE__) || defined(_WIN32)\n+.globl _upcall_call_c_stack_shim\n+_upcall_call_c_stack_shim:\n+#else\n+.globl upcall_call_c_stack_shim\n+upcall_call_c_stack_shim:\n+#endif\n+    pushl %ebp\n+    movl %esp,%ebp          // save esp\n+    movl 8(%esp),%eax       // eax = callee\n+    movl 12(%esp),%esp      // switch stack\n+    pushl %esp              // push ptr to new arguments\n+    calll *%eax\n+    movl %ebp,%esp          // would like to use \"leave\" but it's slower\n+    popl %ebp\n+    ret"}, {"sha": "e9951a75d35130f48c5a295583c112e2da838bea", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85083ec51b57ed5a44ce34c8b3610ca66dff7a68/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/85083ec51b57ed5a44ce34c8b3610ca66dff7a68/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=85083ec51b57ed5a44ce34c8b3610ca66dff7a68", "patch": "@@ -53,6 +53,7 @@ upcall_alloc_c_stack\n upcall_call_c_stack\n upcall_call_c_stack_i64\n upcall_call_c_stack_float\n+upcall_call_c_stack_shim\n upcall_cmp_type\n upcall_dynastack_alloc\n upcall_dynastack_alloc_2"}]}