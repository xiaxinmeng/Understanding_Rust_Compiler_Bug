{"sha": "d7ea6addf06f0db99f4d21b229c7bfea223d827d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZWE2YWRkZjA2ZjBkYjk5ZjRkMjFiMjI5YzdiZmVhMjIzZDgyN2Q=", "commit": {"author": {"name": "Michael Recachinas", "email": "mgr3yp@virginia.edu", "date": "2017-09-17T16:18:12Z"}, "committer": {"name": "Michael Recachinas", "email": "mgr3yp@virginia.edu", "date": "2017-09-17T16:18:12Z"}, "message": "(#1955): Suggests `x > y` over `x >= y + 1` for ints\n\nThis module handles the following cases:\n- `... >= ... + 1` and `... >= 1 + ...`\n- `... - 1 >= ...` and `-1 + ... >= ...`\n- `... + 1 <= ...` and `... + 1 <= ...`\n- `... <= ... - 1` and `... <= -1 + ...`\n\nNote: this only goes 1 level deep (i.e., does not constant-fold) and\ndoes not currently simplify expressions. Examples of these\ncases include:\n```rust\nlet x = 1;\ny >= y + x; // won't catch this case or any permutation\n\nx + 1 >= y + 2; // won't catch this case\n\nx + 1 - 1 >= y - 1 + 1; // WILL catch this case when it likely shouldn't\n```", "tree": {"sha": "b595c3e601359e47a8b1d7909a67ac81be3f9dad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b595c3e601359e47a8b1d7909a67ac81be3f9dad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7ea6addf06f0db99f4d21b229c7bfea223d827d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ea6addf06f0db99f4d21b229c7bfea223d827d", "html_url": "https://github.com/rust-lang/rust/commit/d7ea6addf06f0db99f4d21b229c7bfea223d827d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7ea6addf06f0db99f4d21b229c7bfea223d827d/comments", "author": null, "committer": null, "parents": [{"sha": "708a81809498780760d6992ee86dd0aa47d32bde", "url": "https://api.github.com/repos/rust-lang/rust/commits/708a81809498780760d6992ee86dd0aa47d32bde", "html_url": "https://github.com/rust-lang/rust/commit/708a81809498780760d6992ee86dd0aa47d32bde"}], "stats": {"total": 115, "additions": 115, "deletions": 0}, "files": [{"sha": "75538e7946e1dbed9dd41e93491a8fb01a0d3fae", "filename": "clippy_lints/src/int_plus_one.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/d7ea6addf06f0db99f4d21b229c7bfea223d827d/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ea6addf06f0db99f4d21b229c7bfea223d827d/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=d7ea6addf06f0db99f4d21b229c7bfea223d827d", "patch": "@@ -0,0 +1,115 @@\n+//! lint on blocks unnecessarily using >= with a + 1 or - 1\n+\n+use rustc::lint::*;\n+use syntax::ast::*;\n+\n+use utils::span_help_and_lint;\n+\n+/// **What it does:** Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n+///\n+///\n+/// **Why is this bad?** Readability -- better to use `> y` instead of `>= y + 1`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// x >= y + 1\n+/// ```\n+///\n+/// Could be written:\n+///\n+/// ```rust\n+/// x > y\n+/// ```\n+declare_lint! {\n+    pub INT_PLUS_ONE,\n+    Allow,\n+    \"instead of using x >= y + 1, use x > y\"\n+}\n+\n+pub struct IntPlusOne;\n+\n+impl LintPass for IntPlusOne {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(INT_PLUS_ONE)\n+    }\n+}\n+\n+// cases:\n+// BinOpKind::Ge\n+// x >= y + 1\n+// x - 1 >= y\n+//\n+// BinOpKind::Le\n+// x + 1 <= y\n+// x <= y - 1\n+\n+impl IntPlusOne {\n+    #[allow(cast_sign_loss)]\n+    fn check_lit(&self, lit: &Lit, target_value: i128) -> bool {\n+        if let LitKind::Int(value, ..) = lit.node {\n+            return value == (target_value as u128)\n+        }\n+        false\n+    }\n+\n+    fn check_binop(&self, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> bool {\n+        match (binop, &lhs.node, &rhs.node) {\n+            // case where `x - 1 >= ...` or `-1 + x >= ...`\n+            (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n+                match (lhskind.node, &lhslhs.node, &lhsrhs.node) {\n+                    // `-1 + x`\n+                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) => self.check_lit(lit, -1),\n+                    // `x - 1`\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) => self.check_lit(lit, 1),\n+                    _ => false\n+                }\n+            },\n+            // case where `... >= y + 1` or `... >= 1 + y`\n+            (BinOpKind::Ge, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) if rhskind.node == BinOpKind::Add => {\n+                match (&rhslhs.node, &rhsrhs.node) {\n+                    // `y + 1` and `1 + y`\n+                    (&ExprKind::Lit(ref lit), _)|(_, &ExprKind::Lit(ref lit)) => self.check_lit(lit, 1),\n+                    _ => false\n+                }\n+            },\n+            // case where `x + 1 <= ...` or `1 + x <= ...`\n+            (BinOpKind::Le, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) if lhskind.node == BinOpKind::Add => {\n+                match (&lhslhs.node, &lhsrhs.node) {\n+                    // `1 + x` and `x + 1`\n+                    (&ExprKind::Lit(ref lit), _)|(_, &ExprKind::Lit(ref lit)) => self.check_lit(lit, 1),\n+                    _ => false\n+                }\n+            },\n+            // case where `... >= y - 1` or `... >= -1 + y`\n+            (BinOpKind::Le, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) => {\n+                match (rhskind.node, &rhslhs.node, &rhsrhs.node) {\n+                    // `-1 + y`\n+                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) => self.check_lit(lit, -1),\n+                    // `y - 1`\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) => self.check_lit(lit, 1),\n+                    _ => false\n+                }\n+            },\n+            _ => false\n+        }\n+    }\n+\n+}\n+\n+impl EarlyLintPass for IntPlusOne {\n+    fn check_expr(&mut self, cx: &EarlyContext, item: &Expr) {\n+        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = item.node {\n+            if self.check_binop(kind.node, lhs, rhs) {\n+                span_help_and_lint(\n+                    cx,\n+                    INT_PLUS_ONE,\n+                    item.span,\n+                    \"Unnecessary `>= y + 1` or `x - 1 >=`\",\n+                    \"Consider reducing `x >= y + 1` or `x - 1 >= y` to `x > y`\",\n+                );\n+            }\n+        }\n+    }\n+}"}]}