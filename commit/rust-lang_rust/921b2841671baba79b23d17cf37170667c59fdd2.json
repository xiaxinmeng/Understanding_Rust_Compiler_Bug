{"sha": "921b2841671baba79b23d17cf37170667c59fdd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMWIyODQxNjcxYmFiYTc5YjIzZDE3Y2YzNzE3MDY2N2M1OWZkZDI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-10-27T18:33:03Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-01-08T17:01:50Z"}, "message": "Make force_from_dep_node a function pointer.", "tree": {"sha": "65d7510a7d79c7021c286c668bb3bdae59fc4369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65d7510a7d79c7021c286c668bb3bdae59fc4369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/921b2841671baba79b23d17cf37170667c59fdd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/921b2841671baba79b23d17cf37170667c59fdd2", "html_url": "https://github.com/rust-lang/rust/commit/921b2841671baba79b23d17cf37170667c59fdd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/921b2841671baba79b23d17cf37170667c59fdd2/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bee1fbb67e6409494986af8bc2ac3048b750f29a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bee1fbb67e6409494986af8bc2ac3048b750f29a", "html_url": "https://github.com/rust-lang/rust/commit/bee1fbb67e6409494986af8bc2ac3048b750f29a"}], "stats": {"total": 200, "additions": 90, "deletions": 110}, "files": [{"sha": "86707b4283f78f58dcbbc697bedf35d1643b9d49", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/921b2841671baba79b23d17cf37170667c59fdd2/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/921b2841671baba79b23d17cf37170667c59fdd2/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=921b2841671baba79b23d17cf37170667c59fdd2", "patch": "@@ -66,6 +66,7 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::definitions::DefPathHash;\n use rustc_hir::HirId;\n use rustc_span::symbol::Symbol;\n+use rustc_span::DUMMY_SP;\n use std::hash::Hash;\n \n pub use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n@@ -95,6 +96,50 @@ pub struct DepKindStruct {\n     // can be made a specialized associated const.\n     can_reconstruct_query_key: fn() -> bool,\n \n+    /// The red/green evaluation system will try to mark a specific DepNode in the\n+    /// dependency graph as green by recursively trying to mark the dependencies of\n+    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+    /// where we don't know if it is red or green and we therefore actually have\n+    /// to recompute its value in order to find out. Since the only piece of\n+    /// information that we have at that point is the `DepNode` we are trying to\n+    /// re-evaluate, we need some way to re-run a query from just that. This is what\n+    /// `force_from_dep_node()` implements.\n+    ///\n+    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+    /// is usually constructed by computing a stable hash of the query-key that the\n+    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+    /// back from hash to query-key (since hash functions are not reversible). For\n+    /// this reason `force_from_dep_node()` is expected to fail from time to time\n+    /// because we just cannot find out, from the `DepNode` alone, what the\n+    /// corresponding query-key is and therefore cannot re-run the query.\n+    ///\n+    /// The system deals with this case letting `try_mark_green` fail which forces\n+    /// the root query to be re-evaluated.\n+    ///\n+    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+    /// Fortunately, we can use some contextual information that will allow us to\n+    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n+    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+    /// everything we need to re-run the query.\n+    ///\n+    /// Take the `mir_promoted` query as an example. Like many other queries, it\n+    /// just has a single parameter: the `DefId` of the item it will compute the\n+    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n+    ///\n+    /// When you implement a new query, it will likely have a corresponding new\n+    /// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n+    /// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n+    /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n+    /// add it to the \"We don't have enough information to reconstruct...\" group in\n+    /// the match below.\n+    pub(super) force_from_dep_node: fn(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool,\n+\n     /// Invoke a query to put the on-disk cached value in memory.\n     pub(super) try_load_from_on_disk_cache: fn(TyCtxt<'_>, &DepNode),\n }\n@@ -156,7 +201,7 @@ macro_rules! contains_eval_always_attr {\n pub mod dep_kind {\n     use super::*;\n     use crate::ty::query::{queries, query_keys};\n-    use rustc_query_system::query::QueryDescription;\n+    use rustc_query_system::query::{force_query, QueryDescription};\n \n     // We use this for most things when incr. comp. is turned off.\n     pub const Null: DepKindStruct = DepKindStruct {\n@@ -165,6 +210,7 @@ pub mod dep_kind {\n         is_eval_always: false,\n \n         can_reconstruct_query_key: || true,\n+        force_from_dep_node: |_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node),\n         try_load_from_on_disk_cache: |_, _| {},\n     };\n \n@@ -175,6 +221,7 @@ pub mod dep_kind {\n         is_eval_always: true,\n \n         can_reconstruct_query_key: || true,\n+        force_from_dep_node: |_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node),\n         try_load_from_on_disk_cache: |_, _| {},\n     };\n \n@@ -184,6 +231,7 @@ pub mod dep_kind {\n         is_eval_always: false,\n \n         can_reconstruct_query_key: || false,\n+        force_from_dep_node: |_, _| false,\n         try_load_from_on_disk_cache: |_, _| {},\n     };\n \n@@ -193,6 +241,7 @@ pub mod dep_kind {\n         is_eval_always: false,\n \n         can_reconstruct_query_key: || false,\n+        force_from_dep_node: |_, _| false,\n         try_load_from_on_disk_cache: |_, _| {},\n     };\n \n@@ -217,6 +266,24 @@ pub mod dep_kind {\n                     <query_keys::$variant<'_> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node)\n                 }\n \n+                fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n+                    if !can_reconstruct_query_key() {\n+                        return false;\n+                    }\n+\n+                    if let Some(key) = recover(tcx, dep_node) {\n+                        force_query::<queries::$variant<'_>, _>(\n+                            tcx,\n+                            key,\n+                            DUMMY_SP,\n+                            *dep_node\n+                        );\n+                        return true;\n+                    }\n+\n+                    false\n+                }\n+\n                 fn try_load_from_on_disk_cache(tcx: TyCtxt<'_>, dep_node: &DepNode) {\n                     if !can_reconstruct_query_key() {\n                         return\n@@ -238,6 +305,7 @@ pub mod dep_kind {\n                     is_anon,\n                     is_eval_always,\n                     can_reconstruct_query_key,\n+                    force_from_dep_node,\n                     try_load_from_on_disk_cache,\n                 }\n             };)*"}, {"sha": "a45617f9a5fe82ecc38f029d2af3afa5469b607a", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/921b2841671baba79b23d17cf37170667c59fdd2/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/921b2841671baba79b23d17cf37170667c59fdd2/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=921b2841671baba79b23d17cf37170667c59fdd2", "patch": "@@ -8,7 +8,6 @@ use rustc_hir::def_id::LocalDefId;\n \n mod dep_node;\n \n-pub(crate) use rustc_query_system::dep_graph::DepNodeParams;\n pub use rustc_query_system::dep_graph::{\n     debug, hash_result, DepContext, DepNodeColor, DepNodeIndex, SerializedDepNodeIndex,\n     WorkProduct, WorkProductId,\n@@ -155,7 +154,26 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n         }\n \n         debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n-        ty::query::force_from_dep_node(*self, dep_node)\n+\n+        // We must avoid ever having to call `force_from_dep_node()` for a\n+        // `DepNode::codegen_unit`:\n+        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+        // would always end up having to evaluate the first caller of the\n+        // `codegen_unit` query that *is* reconstructible. This might very well be\n+        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+        // to re-trigger calling the `codegen_unit` query with the right key. At\n+        // that point we would already have re-done all the work we are trying to\n+        // avoid doing in the first place.\n+        // The solution is simple: Just explicitly call the `codegen_unit` query for\n+        // each CGU, right after partitioning. This way `try_mark_green` will always\n+        // hit the cache instead of having to go through `force_from_dep_node`.\n+        // This assertion makes sure, we actually keep applying the solution above.\n+        debug_assert!(\n+            dep_node.kind != DepKind::codegen_unit,\n+            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+        );\n+\n+        (dep_node.kind.force_from_dep_node)(*self, dep_node)\n     }\n \n     fn has_errors_or_delayed_span_bugs(&self) -> bool {"}, {"sha": "acfa58e511ed1f030890901da29a888bf10578ca", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 107, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/921b2841671baba79b23d17cf37170667c59fdd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/921b2841671baba79b23d17cf37170667c59fdd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=921b2841671baba79b23d17cf37170667c59fdd2", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{self, DepKind, DepNode, DepNodeParams};\n+use crate::dep_graph;\n use crate::hir::exports::Export;\n use crate::hir::map;\n use crate::infer::canonical::{self, Canonical};\n@@ -103,112 +103,6 @@ pub use self::profiling_support::{IntoSelfProfilingString, QueryKeyStringBuilder\n \n rustc_query_append! { [define_queries!][<'tcx>] }\n \n-/// The red/green evaluation system will try to mark a specific DepNode in the\n-/// dependency graph as green by recursively trying to mark the dependencies of\n-/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-/// where we don't know if it is red or green and we therefore actually have\n-/// to recompute its value in order to find out. Since the only piece of\n-/// information that we have at that point is the `DepNode` we are trying to\n-/// re-evaluate, we need some way to re-run a query from just that. This is what\n-/// `force_from_dep_node()` implements.\n-///\n-/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-/// is usually constructed by computing a stable hash of the query-key that the\n-/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-/// back from hash to query-key (since hash functions are not reversible). For\n-/// this reason `force_from_dep_node()` is expected to fail from time to time\n-/// because we just cannot find out, from the `DepNode` alone, what the\n-/// corresponding query-key is and therefore cannot re-run the query.\n-///\n-/// The system deals with this case letting `try_mark_green` fail which forces\n-/// the root query to be re-evaluated.\n-///\n-/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-/// Fortunately, we can use some contextual information that will allow us to\n-/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-/// valid `DefPathHash`. Since we also always build a huge table that maps every\n-/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-/// everything we need to re-run the query.\n-///\n-/// Take the `mir_promoted` query as an example. Like many other queries, it\n-/// just has a single parameter: the `DefId` of the item it will compute the\n-/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-/// `DefId` in `tcx.def_path_hash_to_def_id`.\n-///\n-/// When you implement a new query, it will likely have a corresponding new\n-/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n-/// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n-/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n-/// add it to the \"We don't have enough information to reconstruct...\" group in\n-/// the match below.\n-pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool {\n-    // We must avoid ever having to call `force_from_dep_node()` for a\n-    // `DepNode::codegen_unit`:\n-    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-    // would always end up having to evaluate the first caller of the\n-    // `codegen_unit` query that *is* reconstructible. This might very well be\n-    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-    // to re-trigger calling the `codegen_unit` query with the right key. At\n-    // that point we would already have re-done all the work we are trying to\n-    // avoid doing in the first place.\n-    // The solution is simple: Just explicitly call the `codegen_unit` query for\n-    // each CGU, right after partitioning. This way `try_mark_green` will always\n-    // hit the cache instead of having to go through `force_from_dep_node`.\n-    // This assertion makes sure, we actually keep applying the solution above.\n-    debug_assert!(\n-        dep_node.kind != DepKind::codegen_unit,\n-        \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-    );\n-\n-    if !dep_node.kind.can_reconstruct_query_key() {\n-        return false;\n-    }\n-\n-    macro_rules! force_from_dep_node {\n-        ($($(#[$attr:meta])* [$($modifiers:tt)*] $name:ident($K:ty),)*) => {\n-            match dep_node.kind {\n-                // These are inputs that are expected to be pre-allocated and that\n-                // should therefore always be red or green already.\n-                DepKind::CrateMetadata |\n-\n-                // These are anonymous nodes.\n-                DepKind::TraitSelect |\n-\n-                // We don't have enough information to reconstruct the query key of\n-                // these.\n-                DepKind::CompileCodegenUnit |\n-\n-                // Forcing this makes no sense.\n-                DepKind::Null => {\n-                    bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n-                }\n-\n-                $(DepKind::$name => {\n-                    debug_assert!(<$K as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key());\n-\n-                    if let Some(key) = <$K as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node) {\n-                        force_query::<queries::$name<'_>, _>(\n-                            tcx,\n-                            key,\n-                            DUMMY_SP,\n-                            *dep_node\n-                        );\n-                        return true;\n-                    }\n-                })*\n-            }\n-        }\n-    }\n-\n-    rustc_dep_node_append! { [force_from_dep_node!][] }\n-\n-    false\n-}\n-\n mod sealed {\n     use super::{DefId, LocalDefId};\n "}]}