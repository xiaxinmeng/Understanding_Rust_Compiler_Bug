{"sha": "4b743da596e94fbf56418e82ab92a4952d9bfb8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNzQzZGE1OTZlOTRmYmY1NjQxOGU4MmFiOTJhNDk1MmQ5YmZiOGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-06T12:26:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:47Z"}, "message": "integrate NLL with MIR type-checker", "tree": {"sha": "6c8ee50f13bf37ee773f2e6f78385b66cc124aaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c8ee50f13bf37ee773f2e6f78385b66cc124aaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b743da596e94fbf56418e82ab92a4952d9bfb8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b743da596e94fbf56418e82ab92a4952d9bfb8b", "html_url": "https://github.com/rust-lang/rust/commit/4b743da596e94fbf56418e82ab92a4952d9bfb8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b743da596e94fbf56418e82ab92a4952d9bfb8b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9e841e756eab869ea3dcbe468c1ad95f80ae24b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9e841e756eab869ea3dcbe468c1ad95f80ae24b", "html_url": "https://github.com/rust-lang/rust/commit/d9e841e756eab869ea3dcbe468c1ad95f80ae24b"}], "stats": {"total": 418, "additions": 256, "deletions": 162}, "files": [{"sha": "da505f167241b812e6acdad32e1fa528a1f123be", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=4b743da596e94fbf56418e82ab92a4952d9bfb8b", "patch": "@@ -192,7 +192,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     ///\n     /// if `r_a` represents `'a`, this function would return `{'b, 'c}`.\n     pub fn regions_that_outlive<'a, 'gcx>(&self, r_a: Region<'tcx>) -> Vec<&Region<'tcx>> {\n-        assert!(is_free(r_a));\n+        assert!(is_free(r_a) || *r_a == ty::ReStatic);\n         self.relation.greater_than(&r_a)\n     }\n }"}, {"sha": "a72320cdbdd6f69e3e13a1f53c57161e54fcc72d", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=4b743da596e94fbf56418e82ab92a4952d9bfb8b", "patch": "@@ -112,7 +112,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     let opt_regioncx = if !tcx.sess.opts.debugging_opts.nll {\n         None\n     } else {\n-        Some(nll::compute_regions(infcx, def_id, mir))\n+        Some(nll::compute_regions(infcx, def_id, param_env, mir))\n     };\n \n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };"}, {"sha": "1f905d32f84e84b751ba6f773e7950f0fef2c116", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "modified", "additions": 13, "deletions": 50, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=4b743da596e94fbf56418e82ab92a4952d9bfb8b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::mir::{BasicBlock, BorrowKind, Location, Lvalue, Mir, Rvalue, Statement, StatementKind};\n+use rustc::mir::{Location, Lvalue, Mir, Rvalue};\n use rustc::mir::visit::Visitor;\n use rustc::mir::Lvalue::Projection;\n use rustc::mir::{LvalueProjection, ProjectionElem};\n@@ -21,7 +21,6 @@ use rustc::util::common::ErrorReported;\n use rustc_data_structures::fx::FxHashSet;\n use syntax::codemap::DUMMY_SP;\n \n-use super::subtype;\n use super::LivenessResults;\n use super::ToRegionVid;\n use super::region_infer::RegionInferenceContext;\n@@ -179,29 +178,6 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n         self.visit_mir(self.mir);\n     }\n \n-    fn add_borrow_constraint(\n-        &mut self,\n-        location: Location,\n-        destination_lv: &Lvalue<'tcx>,\n-        borrow_region: ty::Region<'tcx>,\n-        _borrow_kind: BorrowKind,\n-        _borrowed_lv: &Lvalue<'tcx>,\n-    ) {\n-        let tcx = self.infcx.tcx;\n-        let span = self.mir.source_info(location).span;\n-        let destination_ty = destination_lv.ty(self.mir, tcx).to_ty(tcx);\n-\n-        let destination_region = match destination_ty.sty {\n-            ty::TyRef(r, _) => r,\n-            _ => bug!()\n-        };\n-\n-        self.regioncx.add_outlives(span,\n-                                   borrow_region.to_region_vid(),\n-                                   destination_region.to_region_vid(),\n-                                   location.successor_within_block());\n-    }\n-\n     fn add_reborrow_constraint(\n         &mut self,\n         location: Location,\n@@ -237,35 +213,22 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n }\n \n impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cx, 'gcx, 'tcx> {\n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &Statement<'tcx>,\n-                       location: Location) {\n+    fn visit_rvalue(&mut self,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location) {\n+        debug!(\"visit_rvalue(rvalue={:?}, location={:?})\", rvalue, location);\n \n-        debug!(\"visit_statement(statement={:?}, location={:?})\", statement, location);\n-\n-        // Look for a statement like:\n+        // Look for an rvalue like:\n         //\n-        //     D = & L\n+        //     & L\n         //\n-        // where D is the path to which we are assigning, and\n-        // L is the path that is borrowed.\n-        if let StatementKind::Assign(ref destination_lv, ref rv) = statement.kind {\n-            if let Rvalue::Ref(region, bk, ref borrowed_lv) = *rv {\n-                self.add_borrow_constraint(location, destination_lv, region, bk, borrowed_lv);\n-                self.add_reborrow_constraint(location, region, borrowed_lv);\n-            }\n-\n-            let tcx = self.infcx.tcx;\n-            let destination_ty = destination_lv.ty(self.mir, tcx).to_ty(tcx);\n-            let rv_ty = rv.ty(self.mir, tcx);\n-\n-            let span = self.mir.source_info(location).span;\n-            for (a, b) in subtype::outlives_pairs(tcx, rv_ty, destination_ty) {\n-                self.regioncx.add_outlives(span, a, b, location.successor_within_block());\n-            }\n+        // where L is the path that is borrowed. In that case, we have\n+        // to add the reborrow constraints (which don't fall out\n+        // naturally from the type-checker).\n+        if let Rvalue::Ref(region, _bk, ref borrowed_lv) = *rvalue {\n+            self.add_reborrow_constraint(location, region, borrowed_lv);\n         }\n \n-        self.super_statement(block, statement, location);\n+        self.super_rvalue(rvalue, location);\n     }\n }"}, {"sha": "92a8a714d525a09a369a08f55167c77879613f00", "filename": "src/librustc_mir/transform/nll/free_regions.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs?ref=4b743da596e94fbf56418e82ab92a4952d9bfb8b", "patch": "@@ -50,6 +50,9 @@ pub fn free_regions<'a, 'gcx, 'tcx>(\n \n     let mut indices = FxHashMap();\n \n+    // `'static` is always free.\n+    insert_free_region(&mut indices, infcx.tcx.types.re_static);\n+\n     // Extract the early regions.\n     let item_substs = Substs::identity_for_item(infcx.tcx, item_def_id);\n     for item_subst in item_substs {"}, {"sha": "147f061ad113f52509fb0368bf5cda605473a545", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=4b743da596e94fbf56418e82ab92a4952d9bfb8b", "patch": "@@ -15,14 +15,15 @@ use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n use std::collections::BTreeSet;\n use transform::MirSource;\n+use transform::type_check;\n use util::liveness::{self, LivenessMode, LivenessResult, LocalSet};\n \n use util as mir_util;\n use self::mir_util::PassWhere;\n \n mod constraint_generation;\n+mod subtype_constraint_generation;\n mod free_regions;\n-mod subtype;\n \n pub(crate) mod region_infer;\n use self::region_infer::RegionInferenceContext;\n@@ -35,6 +36,7 @@ mod renumber;\n pub fn compute_regions<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     def_id: DefId,\n+    param_env: ty::ParamEnv<'gcx>,\n     mir: &mut Mir<'tcx>,\n ) -> RegionInferenceContext<'tcx> {\n     // Compute named region information.\n@@ -43,6 +45,16 @@ pub fn compute_regions<'a, 'gcx, 'tcx>(\n     // Replace all regions with fresh inference variables.\n     renumber::renumber_mir(infcx, free_regions, mir);\n \n+    // Run the MIR type-checker.\n+    let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n+    let constraint_sets = &type_check::type_check(infcx, mir_node_id, param_env, mir);\n+\n+    // Create the region inference context, taking ownership of the region inference\n+    // data that was contained in `infcx`.\n+    let var_origins = infcx.take_region_var_origins();\n+    let mut regioncx = RegionInferenceContext::new(var_origins, free_regions, mir);\n+    subtype_constraint_generation::generate(&mut regioncx, free_regions, mir, constraint_sets);\n+\n     // Compute what is live where.\n     let liveness = &LivenessResults {\n         regular: liveness::liveness_of_locals(\n@@ -62,12 +74,10 @@ pub fn compute_regions<'a, 'gcx, 'tcx>(\n         ),\n     };\n \n-    // Create the region inference context, generate the constraints,\n-    // and then solve them.\n-    let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, free_regions, mir);\n-    let param_env = infcx.tcx.param_env(def_id);\n+    // Generate non-subtyping constraints.\n     constraint_generation::generate_constraints(infcx, &mut regioncx, &mir, param_env, liveness);\n+\n+    // Solve the region constraints.\n     regioncx.solve(infcx, &mir);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n@@ -123,12 +133,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         match pass_where {\n             // Before the CFG, dump out the values for each region variable.\n             PassWhere::BeforeCFG => for region in regioncx.regions() {\n-                writeln!(\n-                    out,\n-                    \"| {:?}: {:?}\",\n-                    region,\n-                    regioncx.region_value(region)\n-                )?;\n+                writeln!(out, \"| {:?}: {:?}\", region, regioncx.region_value(region))?;\n             },\n \n             // Before each basic block, dump out the values"}, {"sha": "f218cc51d344b83f01760c7fb5e68cc5826a0a48", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=4b743da596e94fbf56418e82ab92a4952d9bfb8b", "patch": "@@ -183,6 +183,15 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n             // Add `end(X)` into the set for X.\n             self.definitions[variable].value.add_free_region(variable);\n \n+            // `'static` outlives all other free regions as well.\n+            if let ty::ReStatic = free_region {\n+                for &other_variable in indices.values() {\n+                    self.definitions[variable]\n+                        .value\n+                        .add_free_region(other_variable);\n+                }\n+            }\n+\n             // Go through each region Y that outlives X (i.e., where\n             // Y: X is true). Add `end(X)` into the set for `Y`.\n             for superregion in free_region_map.regions_that_outlive(&free_region) {"}, {"sha": "bb41477dcbf9e579892e9a19d2b8a3c5a2da4834", "filename": "src/librustc_mir/transform/nll/subtype.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d9e841e756eab869ea3dcbe468c1ad95f80ae24b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e841e756eab869ea3dcbe468c1ad95f80ae24b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype.rs?ref=d9e841e756eab869ea3dcbe468c1ad95f80ae24b", "patch": "@@ -1,98 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use transform::nll::ToRegionVid;\n-use rustc::ty::{self, Ty, TyCtxt, RegionVid};\n-use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-\n-pub fn outlives_pairs<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                      a: Ty<'tcx>,\n-                      b: Ty<'tcx>)\n-                      -> Vec<(RegionVid, RegionVid)>\n-{\n-    let mut subtype = Subtype::new(tcx);\n-    match subtype.relate(&a, &b) {\n-        Ok(_) => subtype.outlives_pairs,\n-\n-        Err(_) => bug!(\"Fail to relate a = {:?} and b = {:?}\", a, b)\n-    }\n-}\n-\n-struct Subtype<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    outlives_pairs: Vec<(RegionVid, RegionVid)>,\n-    ambient_variance: ty::Variance,\n-}\n-\n-impl<'a, 'gcx, 'tcx> Subtype<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Subtype<'a, 'gcx, 'tcx> {\n-        Subtype {\n-            tcx,\n-            outlives_pairs: vec![],\n-            ambient_variance: ty::Covariant,\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Subtype<'a, 'gcx, 'tcx> {\n-    fn tag(&self) -> &'static str { \"Subtype\" }\n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.tcx }\n-    fn a_is_expected(&self) -> bool { true } // irrelevant\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n-                                             variance: ty::Variance,\n-                                             a: &T,\n-                                             b: &T)\n-                                             -> RelateResult<'tcx, T>\n-    {\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.ambient_variance.xform(variance);\n-\n-        let result = self.relate(a, b);\n-        self.ambient_variance = old_ambient_variance;\n-        result\n-    }\n-\n-    fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        relate::super_relate_tys(self, t, t2)\n-    }\n-\n-    fn regions(&mut self, r_a: ty::Region<'tcx>, r_b: ty::Region<'tcx>)\n-               -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        let a = r_a.to_region_vid();\n-        let b = r_b.to_region_vid();\n-\n-        match self.ambient_variance {\n-            ty::Covariant => {\n-                self.outlives_pairs.push((b, a));\n-            },\n-\n-            ty::Invariant => {\n-                self.outlives_pairs.push((a, b));\n-                self.outlives_pairs.push((b, a));\n-            },\n-\n-            ty::Contravariant => {\n-                self.outlives_pairs.push((a, b));\n-            },\n-\n-            ty::Bivariant => {},\n-        }\n-\n-        Ok(r_a)\n-    }\n-\n-    fn binders<T>(&mut self, _a: &ty::Binder<T>, _b: &ty::Binder<T>)\n-                  -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'tcx>\n-    {\n-        unimplemented!();\n-    }\n-}"}, {"sha": "c1850c76541d78f75d4c1f6e06cf50ab6ab459f6", "filename": "src/librustc_mir/transform/nll/subtype_constraint_generation.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype_constraint_generation.rs?ref=4b743da596e94fbf56418e82ab92a4952d9bfb8b", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::mir::Mir;\n+use rustc::infer::region_constraints::Constraint;\n+use rustc::infer::region_constraints::RegionConstraintData;\n+use rustc::ty;\n+use transform::type_check::MirTypeckRegionConstraints;\n+use transform::type_check::OutlivesSet;\n+\n+use super::free_regions::FreeRegions;\n+use super::region_infer::RegionInferenceContext;\n+\n+/// When the MIR type-checker executes, it validates all the types in\n+/// the MIR, and in the process generates a set of constraints that\n+/// must hold regarding the regions in the MIR, along with locations\n+/// *where* they must hold. This code takes those constriants and adds\n+/// them into the NLL `RegionInferenceContext`.\n+pub(super) fn generate<'tcx>(\n+    regioncx: &mut RegionInferenceContext<'tcx>,\n+    free_regions: &FreeRegions<'tcx>,\n+    mir: &Mir<'tcx>,\n+    constraints: &MirTypeckRegionConstraints<'tcx>,\n+) {\n+    SubtypeConstraintGenerator {\n+        regioncx,\n+        free_regions,\n+        mir,\n+    }.generate(constraints);\n+}\n+\n+struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n+    regioncx: &'cx mut RegionInferenceContext<'tcx>,\n+    free_regions: &'cx FreeRegions<'tcx>,\n+    mir: &'cx Mir<'tcx>,\n+}\n+\n+impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n+    fn generate(&mut self, constraints: &MirTypeckRegionConstraints<'tcx>) {\n+        let MirTypeckRegionConstraints {\n+            liveness_set,\n+            outlives_sets,\n+        } = constraints;\n+\n+        debug!(\n+            \"generate(liveness_set={} items, outlives_sets={} items)\",\n+            liveness_set.len(),\n+            outlives_sets.len()\n+        );\n+\n+        for (region, location) in liveness_set {\n+            debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n+            let region_vid = self.to_region_vid(region);\n+            self.regioncx.add_live_point(region_vid, *location);\n+        }\n+\n+        for OutlivesSet { locations, data } in outlives_sets {\n+            debug!(\"generate: constraints at: {:#?}\", locations);\n+            let RegionConstraintData {\n+                constraints,\n+                verifys,\n+                givens,\n+            } = data;\n+\n+            for constraint in constraints.keys() {\n+                debug!(\"generate: constraint: {:?}\", constraint);\n+                let (a_vid, b_vid) = match constraint {\n+                    Constraint::VarSubVar(a_vid, b_vid) => (*a_vid, *b_vid),\n+                    Constraint::RegSubVar(a_r, b_vid) => (self.to_region_vid(a_r), *b_vid),\n+                    Constraint::VarSubReg(a_vid, b_r) => (*a_vid, self.to_region_vid(b_r)),\n+                    Constraint::RegSubReg(a_r, b_r) => {\n+                        (self.to_region_vid(a_r), self.to_region_vid(b_r))\n+                    }\n+                };\n+\n+                // We have the constraint that `a_vid <= b_vid`. Add\n+                // `b_vid: a_vid` to our region checker. Note that we\n+                // reverse direction, because `regioncx` talks about\n+                // \"outlives\" (`>=`) whereas the region constraints\n+                // talk about `<=`.\n+                let span = self.mir.source_info(locations.from_location).span;\n+                self.regioncx\n+                    .add_outlives(span, b_vid, a_vid, locations.at_location);\n+            }\n+\n+            assert!(verifys.is_empty(), \"verifys not yet implemented\");\n+            assert!(\n+                givens.is_empty(),\n+                \"MIR type-checker does not use givens (thank goodness)\"\n+            );\n+        }\n+    }\n+\n+    fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n+        // Every region that we see in the constraints came from the\n+        // MIR or from the parameter environment. If the former, it\n+        // will be a region variable.  If the latter, it will be in\n+        // the set of free regions *somewhere*.\n+        if let ty::ReVar(vid) = r {\n+            *vid\n+        } else {\n+            self.free_regions.indices[&r]\n+        }\n+    }\n+}"}, {"sha": "5605206221a117e5e54573b629898cfd6bf46d6c", "filename": "src/test/ui/nll/get_default.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.rs?ref=4b743da596e94fbf56418e82ab92a4952d9bfb8b", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for free regions in the NLL code. This test ought to\n+// report an error due to a reborrowing constraint. Right now, we get\n+// a variety of errors from the older, AST-based machinery (notably\n+// borrowck), and then we get the NLL error at the end.\n+\n+// compile-flags:-Znll -Zborrowck-mir\n+\n+struct Map {\n+}\n+\n+impl Map {\n+    fn get(&self) -> Option<&String> { None }\n+    fn set(&mut self, v: String) { }\n+}\n+\n+fn ok(map: &mut Map) -> &String {\n+    loop {\n+        match map.get() {\n+            Some(v) => {\n+                return v;\n+            }\n+            None => {\n+                map.set(String::new()); // Just AST errors here\n+            }\n+        }\n+    }\n+}\n+\n+fn err(map: &mut Map) -> &String {\n+    loop {\n+        match map.get() {\n+            Some(v) => {\n+                map.set(String::new()); // Both AST and MIR error here\n+                return v;\n+            }\n+            None => {\n+                map.set(String::new()); // Just AST errors here\n+            }\n+        }\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "9586f426720349e373b6d5f85a4b303e839bd7df", "filename": "src/test/ui/nll/get_default.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b743da596e94fbf56418e82ab92a4952d9bfb8b/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr?ref=4b743da596e94fbf56418e82ab92a4952d9bfb8b", "patch": "@@ -0,0 +1,47 @@\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n+  --> $DIR/get_default.rs:33:17\n+   |\n+28 |         match map.get() {\n+   |               --- immutable borrow occurs here\n+...\n+33 |                 map.set(String::new()); // Just AST errors here\n+   |                 ^^^ mutable borrow occurs here\n+...\n+37 | }\n+   | - immutable borrow ends here\n+\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n+  --> $DIR/get_default.rs:43:17\n+   |\n+41 |         match map.get() {\n+   |               --- immutable borrow occurs here\n+42 |             Some(v) => {\n+43 |                 map.set(String::new()); // Both AST and MIR error here\n+   |                 ^^^ mutable borrow occurs here\n+...\n+51 | }\n+   | - immutable borrow ends here\n+\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n+  --> $DIR/get_default.rs:47:17\n+   |\n+41 |         match map.get() {\n+   |               --- immutable borrow occurs here\n+...\n+47 |                 map.set(String::new()); // Just AST errors here\n+   |                 ^^^ mutable borrow occurs here\n+...\n+51 | }\n+   | - immutable borrow ends here\n+\n+error[E0502]: cannot borrow `(*map)` as mutable because it is also borrowed as immutable (Mir)\n+  --> $DIR/get_default.rs:43:17\n+   |\n+41 |         match map.get() {\n+   |               --- immutable borrow occurs here\n+42 |             Some(v) => {\n+43 |                 map.set(String::new()); // Both AST and MIR error here\n+   |                 ^^^ mutable borrow occurs here\n+\n+error: aborting due to 4 previous errors\n+"}]}