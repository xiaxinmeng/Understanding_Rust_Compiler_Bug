{"sha": "c45b1b16be9ce362f5e23bd5335cffac6679ea59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NWIxYjE2YmU5Y2UzNjJmNWUyM2JkNTMzNWNmZmFjNjY3OWVhNTk=", "commit": {"author": {"name": "JCTyBlaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-12-07T18:16:06Z"}, "committer": {"name": "JCTyblaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-12-13T11:04:58Z"}, "message": "More tests, fix issue 1643 and detect races with allocation.", "tree": {"sha": "1ea59aa29b6220ebe7cd1ac56fd9d2186c9bfbc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ea59aa29b6220ebe7cd1ac56fd9d2186c9bfbc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c45b1b16be9ce362f5e23bd5335cffac6679ea59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c45b1b16be9ce362f5e23bd5335cffac6679ea59", "html_url": "https://github.com/rust-lang/rust/commit/c45b1b16be9ce362f5e23bd5335cffac6679ea59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c45b1b16be9ce362f5e23bd5335cffac6679ea59/comments", "author": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2065b52dfef3cd5a5216e65c21a056a69574bddc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2065b52dfef3cd5a5216e65c21a056a69574bddc", "html_url": "https://github.com/rust-lang/rust/commit/2065b52dfef3cd5a5216e65c21a056a69574bddc"}], "stats": {"total": 584, "additions": 564, "deletions": 20}, "files": [{"sha": "a70c4a4e4c70f27a6e020e72c7ed5993b5e7bcf1", "filename": "src/data_race.rs", "status": "modified", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -192,6 +192,25 @@ struct AtomicMemoryCellClocks {\n     sync_vector: VClock,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum WriteType {\n+    /// Allocate memory.\n+    Allocate,\n+    /// Standard unsynchronized write.\n+    Write,\n+    /// Deallocate memory\n+    Deallocate,\n+}\n+impl WriteType {\n+    fn get_descriptor(self) -> &'static str {\n+        match self {\n+            WriteType::Allocate => \"ALLOCATE\",\n+            WriteType::Write => \"WRITE\",\n+            WriteType::Deallocate => \"DEALLOCATE\",\n+        }\n+    }\n+}\n+\n /// Memory Cell vector clock metadata\n /// for data-race detection.\n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -204,6 +223,11 @@ struct MemoryCellClocks {\n     /// that performed the last write operation.\n     write_index: VectorIdx,\n \n+    /// The type of operation that the write index represents,\n+    /// either newly allocated memory, a non-atomic write or\n+    /// a deallocation of memory.\n+    write_type: WriteType,\n+\n     /// The vector-clock of the timestamp of the last read operation\n     /// performed by a thread since the last write operation occurred.\n     /// It is reset to zero on each write operation.\n@@ -215,20 +239,19 @@ struct MemoryCellClocks {\n     atomic_ops: Option<Box<AtomicMemoryCellClocks>>,\n }\n \n-/// Create a default memory cell clocks instance\n-/// for uninitialized memory.\n-impl Default for MemoryCellClocks {\n-    fn default() -> Self {\n+impl MemoryCellClocks {\n+\n+    /// Create a new set of clocks representing memory allocated\n+    ///  at a given vector timestamp and index.\n+    fn new(alloc: VTimestamp, alloc_index: VectorIdx) -> Self {\n         MemoryCellClocks {\n             read: VClock::default(),\n-            write: 0,\n-            write_index: VectorIdx::MAX_INDEX,\n+            write: alloc,\n+            write_index: alloc_index,\n+            write_type: WriteType::Allocate,\n             atomic_ops: None,\n         }\n     }\n-}\n-\n-impl MemoryCellClocks {\n     \n     /// Load the internal atomic memory cells if they exist.\n     #[inline]\n@@ -382,6 +405,7 @@ impl MemoryCellClocks {\n         &mut self,\n         clocks: &ThreadClockSet,\n         index: VectorIdx,\n+        write_type: WriteType,\n     ) -> Result<(), DataRace> {\n         log::trace!(\"Unsynchronized write with vectors: {:#?} :: {:#?}\", self, clocks);\n         if self.write <= clocks.clock[self.write_index] && self.read <= clocks.clock {\n@@ -393,6 +417,7 @@ impl MemoryCellClocks {\n             if race_free {\n                 self.write = clocks.clock[index];\n                 self.write_index = index;\n+                self.write_type = write_type;\n                 self.read.set_zero_vector();\n                 Ok(())\n             } else {\n@@ -646,16 +671,28 @@ pub struct VClockAlloc {\n     /// Assigning each byte a MemoryCellClocks.\n     alloc_ranges: RefCell<RangeMap<MemoryCellClocks>>,\n \n-    // Pointer to global state.\n+    /// Pointer to global state.\n     global: MemoryExtra,\n }\n \n impl VClockAlloc {\n-    /// Create a new data-race allocation detector.\n-    pub fn new_allocation(global: &MemoryExtra, len: Size) -> VClockAlloc {\n+\n+    /// Create a new data-race detector for newly allocated memory.\n+    pub fn new_allocation(global: &MemoryExtra, len: Size, track_alloc: bool) -> VClockAlloc {\n+        //FIXME: stack allocations are currently ignored due to the lazy nature of stack\n+        // allocation, this results in data-races being missed.\n+        let (alloc_timestamp, alloc_index) = if !track_alloc {\n+            (0, VectorIdx::MAX_INDEX)\n+        }else{\n+            let (alloc_index, clocks) = global.current_thread_state();\n+            let alloc_timestamp = clocks.clock[alloc_index];\n+            (alloc_timestamp, alloc_index)\n+        };\n         VClockAlloc {\n             global: Rc::clone(global),\n-            alloc_ranges: RefCell::new(RangeMap::new(len, MemoryCellClocks::default())),\n+            alloc_ranges: RefCell::new(RangeMap::new(\n+                len, MemoryCellClocks::new(alloc_timestamp, alloc_index)\n+            )),\n         }\n     }\n \n@@ -712,7 +749,7 @@ impl VClockAlloc {\n             // Convert the write action into the vector clock it\n             // represents for diagnostic purposes.\n             write_clock = VClock::new_with_index(range.write_index, range.write);\n-            (\"WRITE\", range.write_index, &write_clock)\n+            (range.write_type.get_descriptor(), range.write_index, &write_clock)\n         } else if let Some(idx) = Self::find_gt_index(&range.read, &current_clocks.clock) {\n             (\"READ\", idx, &range.read)\n         } else if !is_atomic {\n@@ -792,17 +829,17 @@ impl VClockAlloc {\n         &mut self,\n         pointer: Pointer<Tag>,\n         len: Size,\n-        action: &str,\n+        write_type: WriteType,\n     ) -> InterpResult<'tcx> {\n         if self.global.multi_threaded.get() {\n             let (index, clocks) = self.global.current_thread_state();\n             for (_, range) in self.alloc_ranges.get_mut().iter_mut(pointer.offset, len) {\n-                if let Err(DataRace) = range.write_race_detect(&*clocks, index) {\n+                if let Err(DataRace) = range.write_race_detect(&*clocks, index, write_type) {\n                     // Report data-race\n                     return Self::report_data_race(\n                         &self.global,\n                         range,\n-                        action,\n+                        write_type.get_descriptor(),\n                         false,\n                         pointer,\n                         len,\n@@ -820,15 +857,15 @@ impl VClockAlloc {\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n     pub fn write<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n-        self.unique_access(pointer, len, \"Write\")\n+        self.unique_access(pointer, len, WriteType::Write)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n     /// data-race threads if `multi-threaded` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n     pub fn deallocate<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n-        self.unique_access(pointer, len, \"Deallocate\")\n+        self.unique_access(pointer, len, WriteType::Deallocate)\n     }\n }\n "}, {"sha": "159e08c87d3f022440b6a0607bb8145d6249d0a9", "filename": "src/machine.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -478,7 +478,24 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 (None, Tag::Untagged)\n             };\n         let race_alloc = if let Some(data_race) = &memory_extra.data_race {\n-            Some(data_race::AllocExtra::new_allocation(&data_race, alloc.size))\n+            match kind {\n+                // V-Table generation is lazy and so racy, so do not track races.\n+                // Also V-Tables are read only so no data races can be detected.\n+                MemoryKind::Vtable => None,\n+                // User allocated and stack memory should track allocation.\n+                MemoryKind::Machine(\n+                    MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap\n+                ) | MemoryKind::Stack => Some(\n+                    data_race::AllocExtra::new_allocation(&data_race, alloc.size, true)\n+                ),\n+                // Other global memory should trace races but be allocated at the 0 timestamp.\n+                MemoryKind::Machine(\n+                    MiriMemoryKind::Global | MiriMemoryKind::Machine | MiriMemoryKind::Env |\n+                    MiriMemoryKind::ExternStatic | MiriMemoryKind::Tls\n+                ) | MemoryKind::CallerLocation => Some(\n+                    data_race::AllocExtra::new_allocation(&data_race, alloc.size, false)\n+                )\n+            }\n         } else {\n             None\n         };"}, {"sha": "53b3866a2ed32935b07115997b399310a2b88c26", "filename": "tests/compile-fail/data_race/alloc_read_race.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,45 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. alloc\n+    //  2. write\n+    unsafe {\n+        let j1 = spawn(move || {\n+            //Concurrent allocate the memory.\n+            //Uses relaxed semantics to not generate\n+            //a release sequence.\n+            let pointer = &*ptr.0;\n+            pointer.store(Box::into_raw(Box::new(0usize)), Ordering::Relaxed);\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Relaxed) //~ ERROR Data race\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+\n+        // Clean up memory, will never be executed\n+        drop(Box::from_raw(pointer.load(Ordering::Relaxed)));\n+    }\n+}"}, {"sha": "e84ffa9dfef34d94bebc4a7a2b747fa2a4a68c45", "filename": "tests/compile-fail/data_race/alloc_write_race.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Falloc_write_race.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,45 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. alloc\n+    //  2. write\n+    unsafe {\n+        let j1 = spawn(move || {\n+            //Concurrent allocate the memory.\n+            //Uses relaxed semantics to not generate\n+            //a release sequence.\n+            let pointer = &*ptr.0;\n+            pointer.store(Box::into_raw(Box::new(0usize)), Ordering::Relaxed);\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Relaxed) = 2; //~ ERROR Data race\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+\n+        // Clean up memory, will never be executed\n+        drop(Box::from_raw(pointer.load(Ordering::Relaxed)));\n+    }\n+}"}, {"sha": "f6479d246f8d735055022dbc67b3411dac371950", "filename": "tests/compile-fail/data_race/dealloc_read_race.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,32 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+extern \"Rust\" {\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer: *mut usize = Box::into_raw(Box::new(0usize));\n+    let ptr = EvilSend(pointer);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *ptr.0\n+        });\n+\n+        let j2 = spawn(move || {\n+            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());  //~ ERROR Data race\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "67eda4d431e68a8c14152cd9512078650c7adacf", "filename": "tests/compile-fail/data_race/dealloc_read_race_stack.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,52 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. read\n+    //  3. stack-deallocate\n+    unsafe {\n+        let j1 = spawn(move || {\n+            //Concurrent allocate the memory.\n+            //Uses relaxed semantics to not generate\n+            //a release sequence.\n+            let pointer = &*ptr.0;\n+            {\n+                let mut stack_var = 0usize;\n+\n+                pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+\n+                sleep(Duration::from_millis(100));\n+\n+            } //~ ERROR Data race\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire)\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "81ad50c44a0562a99fbdac74e66006880e8d4b1f", "filename": "tests/compile-fail/data_race/dealloc_read_race_stack_drop.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_read_race_stack_drop.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,53 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. read\n+    //  3. stack-deallocate\n+    unsafe {\n+        let j1 = spawn(move || {\n+            //Concurrent allocate the memory.\n+            //Uses relaxed semantics to not generate\n+            //a release sequence.\n+            let pointer = &*ptr.0;\n+\n+            let mut stack_var = 0usize;\n+\n+            pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+\n+            sleep(Duration::from_millis(100));\n+\n+            // NOTE: the race is also detected with thread 0, and so reported for thread 0 instead of 2, unsure of the cause.\n+            drop(stack_var);\n+        });  //~ ERROR Data race detected between DEALLOCATE on Thread(id = 1) and READ on Thread(id = 0, name = \"main\")\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire)\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "e2527f6e904522353892eac0355e5d4ece97217c", "filename": "tests/compile-fail/data_race/dealloc_write_race.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,31 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+extern \"Rust\" {\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+}\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer: *mut usize = Box::into_raw(Box::new(0usize));\n+    let ptr = EvilSend(pointer);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *ptr.0 = 2;\n+        });\n+\n+        let j2 = spawn(move || {\n+            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());  //~ ERROR Data race\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "cda6e317aaeb29eaf82c419c17e53b2369813093", "filename": "tests/compile-fail/data_race/dealloc_write_race_stack.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,52 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. read\n+    //  3. stack-deallocate\n+    unsafe {\n+        let j1 = spawn(move || {\n+            //Concurrent allocate the memory.\n+            //Uses relaxed semantics to not generate\n+            //a release sequence.\n+            let pointer = &*ptr.0;\n+            {\n+                let mut stack_var = 0usize;\n+\n+                pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+\n+                sleep(Duration::from_millis(100));\n+\n+            } //~ ERROR Data race\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire) = 3;\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "9a633518a214d31760ec80e1215212ffa8269658", "filename": "tests/compile-fail/data_race/dealloc_write_race_stack_drop.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fdealloc_write_race_stack_drop.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,52 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. read\n+    //  3. stack-deallocate\n+    unsafe {\n+        let j1 = spawn(move || {\n+            //Concurrent allocate the memory.\n+            //Uses relaxed semantics to not generate\n+            //a release sequence.\n+            let pointer = &*ptr.0;\n+\n+            let mut stack_var = 0usize;\n+\n+            pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+            \n+            sleep(Duration::from_millis(100));\n+\n+            drop(stack_var);  //~ ERROR Data race\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire) = 3;\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "1762e12c28f0dcf37eaa4d64c071b6aac018f392", "filename": "tests/compile-fail/data_race/read_write_race_stack.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race_stack.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,55 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. atomic_store\n+    //  3. atomic_load\n+    //  4. write-value\n+    //  5. read-value\n+    unsafe {\n+        let j1 = spawn(move || {\n+            //Concurrent allocate the memory.\n+            //Uses relaxed semantics to not generate\n+            //a release sequence.\n+            let pointer = &*ptr.0;\n+\n+            let mut stack_var = 0usize;\n+\n+            pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+            \n+            sleep(Duration::from_millis(100));\n+\n+            //read\n+            stack_var //~ ERROR Data race\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire) = 3;\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "9acc26685d8942435dafd3753237b682516d9207", "filename": "tests/compile-fail/data_race/write_write_race_stack.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,57 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::ptr::null_mut;\n+use std::sync::atomic::{Ordering, AtomicPtr};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    // Shared atomic pointer\n+    let pointer = AtomicPtr::new(null_mut::<usize>());\n+    let ptr = EvilSend(&pointer as *const AtomicPtr<usize>);\n+\n+    // Note: this is scheduler-dependent\n+    // the operations need to occur in\n+    // order, otherwise the allocation is\n+    // not visible to the other-thread to\n+    // detect the race:\n+    //  1. stack-allocate\n+    //  2. atomic_store\n+    //  3. atomic_load\n+    //  4. write-value\n+    //  5. write-value\n+    unsafe {\n+        let j1 = spawn(move || {\n+            //Concurrent allocate the memory.\n+            //Uses relaxed semantics to not generate\n+            //a release sequence.\n+            let pointer = &*ptr.0;\n+\n+            let mut stack_var = 0usize;\n+\n+            pointer.store(&mut stack_var as *mut _, Ordering::Release);\n+            \n+            sleep(Duration::from_millis(100));\n+\n+            stack_var = 1usize; //~ ERROR Data race\n+            \n+            // read to silence errors\n+            stack_var\n+        });\n+\n+        let j2 = spawn(move || {\n+            let pointer = &*ptr.0;\n+            *pointer.load(Ordering::Acquire) = 3;\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}"}, {"sha": "c0956569ad8f918c82e6df267b0f69571b6d1df5", "filename": "tests/run-pass/concurrency/issue1643.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Frun-pass%2Fconcurrency%2Fissue1643.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Frun-pass%2Fconcurrency%2Fissue1643.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fissue1643.rs?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,14 @@\n+use std::thread::spawn;\n+\n+fn initialize() {\n+    initialize_inner(&mut || false)\n+}\n+\n+fn initialize_inner(_init: &mut dyn FnMut() -> bool) {}\n+\n+fn main() {\n+    let j1 = spawn(initialize);\n+    let j2 = spawn(initialize);\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+}"}, {"sha": "03676519d4f1c052581dee9227a650c2a4b8d782", "filename": "tests/run-pass/concurrency/issue1643.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Frun-pass%2Fconcurrency%2Fissue1643.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c45b1b16be9ce362f5e23bd5335cffac6679ea59/tests%2Frun-pass%2Fconcurrency%2Fissue1643.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fissue1643.stderr?ref=c45b1b16be9ce362f5e23bd5335cffac6679ea59", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+"}]}