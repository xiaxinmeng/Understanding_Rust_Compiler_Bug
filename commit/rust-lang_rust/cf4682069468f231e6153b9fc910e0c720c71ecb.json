{"sha": "cf4682069468f231e6153b9fc910e0c720c71ecb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNDY4MjA2OTQ2OGYyMzFlNjE1M2I5ZmM5MTBlMGM3MjBjNzFlY2I=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-03-06T12:54:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-05-28T14:37:58Z"}, "message": "Refactor away some functions from hir::pat_util", "tree": {"sha": "37407c7a144f143f0340c9c2e5fa4f8c32c247d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37407c7a144f143f0340c9c2e5fa4f8c32c247d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf4682069468f231e6153b9fc910e0c720c71ecb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf4682069468f231e6153b9fc910e0c720c71ecb", "html_url": "https://github.com/rust-lang/rust/commit/cf4682069468f231e6153b9fc910e0c720c71ecb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf4682069468f231e6153b9fc910e0c720c71ecb/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "216f5fba043ff787ba2dd6bbf01e0e077304adf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/216f5fba043ff787ba2dd6bbf01e0e077304adf0", "html_url": "https://github.com/rust-lang/rust/commit/216f5fba043ff787ba2dd6bbf01e0e077304adf0"}], "stats": {"total": 423, "additions": 168, "deletions": 255}, "files": [{"sha": "76b53094a722b491bdac0896c60e56ae19150605", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -456,8 +456,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     // Visit the guard expression\n                     let guard_exit = self.expr(&guard, guard_start);\n \n-                    let this_has_bindings = pat_util::pat_contains_bindings_or_wild(\n-                        &self.tcx.def_map.borrow(), &pat);\n+                    let this_has_bindings = pat_util::pat_contains_bindings_or_wild(&pat);\n \n                     // If both this pattern and the previous pattern\n                     // were free of bindings, they must consist only"}, {"sha": "bf3d003f51cb533a286becdeb02c54a297b0941e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -524,14 +524,7 @@ pub enum PatKind {\n     /// Represents a wildcard pattern (`_`)\n     Wild,\n \n-    /// A `PatKind::Ident` may either be a new bound variable,\n-    /// or a unit struct/variant pattern, or a const pattern (in the last two cases\n-    /// the third field must be `None`).\n-    ///\n-    /// In the unit or const pattern case, the parser can't determine\n-    /// which it is. The resolver determines this, and\n-    /// records this pattern's `NodeId` in an auxiliary\n-    /// set (of \"PatIdents that refer to unit patterns or constants\").\n+    /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n     Binding(BindingMode, Spanned<Name>, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n@@ -547,10 +540,8 @@ pub enum PatKind {\n     /// Such pattern can be resolved to a unit struct/variant or a constant.\n     Path(Path),\n \n-    /// An associated const named using the qualified path `<T>::CONST` or\n-    /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n-    /// referred to as simply `T::CONST`, in which case they will end up as\n-    /// PatKind::Path, and the resolver will have to sort that out.\n+    /// A path pattern written in qualified form, i.e. `<T as Trait>::CONST` or `<T>::CONST`.\n+    /// Such patterns can only refer to associated constants at the moment.\n     QPath(QSelf, Path),\n \n     /// A tuple pattern `(a, b)`."}, {"sha": "27530d8c75d13a1b64b15e4807436c58fbb7a5d4", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 27, "deletions": 48, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -10,14 +10,12 @@\n \n use hir::def::*;\n use hir::def_id::DefId;\n+use hir::{self, PatKind};\n use ty::TyCtxt;\n use util::nodemap::FnvHashMap;\n-\n use syntax::ast;\n-use hir::{self, PatKind};\n-use syntax::codemap::{respan, Span, Spanned, DUMMY_SP};\n+use syntax::codemap::{Span, Spanned, DUMMY_SP};\n \n-use std::cell::RefCell;\n use std::iter::{Enumerate, ExactSizeIterator};\n \n pub type PatIdMap = FnvHashMap<ast::Name, ast::NodeId>;\n@@ -57,9 +55,9 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(dm: &RefCell<DefMap>, pat: &hir::Pat) -> PatIdMap {\n+pub fn pat_id_map(pat: &hir::Pat) -> PatIdMap {\n     let mut map = FnvHashMap();\n-    pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n+    pat_bindings(pat, |_bm, p_id, _s, path1| {\n         map.insert(path1.node, p_id);\n     });\n     map\n@@ -123,42 +121,25 @@ pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding(_: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Binding(..) => true,\n-        _ => false\n-    }\n-}\n-\n-pub fn pat_is_binding_or_wild(_: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Binding(..) | PatKind::Wild => true,\n-        _ => false\n-    }\n-}\n-\n-/// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n+/// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings<I>(_: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n-    I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n+pub fn pat_bindings<F>(pat: &hir::Pat, mut f: F)\n+    where F: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n {\n     pat.walk(|p| {\n-        match p.node {\n-          PatKind::Binding(binding_mode, ref pth, _) => {\n-            it(binding_mode, p.id, p.span, &respan(pth.span, pth.node));\n-          }\n-          _ => {}\n+        if let PatKind::Binding(binding_mode, ref pth, _) = p.node {\n+            f(binding_mode, p.id, p.span, pth);\n         }\n         true\n     });\n }\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_contains_bindings(pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n     pat.walk(|p| {\n-        if pat_is_binding(dm, p) {\n+        if let PatKind::Binding(..) = p.node {\n             contains_bindings = true;\n             false // there's at least one binding, can short circuit now.\n         } else {\n@@ -170,28 +151,25 @@ pub fn pat_contains_bindings(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n /// Checks if the pattern contains any `ref` or `ref mut` bindings,\n /// and if yes whether its containing mutable ones or just immutables ones.\n-pub fn pat_contains_ref_binding(dm: &RefCell<DefMap>, pat: &hir::Pat) -> Option<hir::Mutability> {\n+pub fn pat_contains_ref_binding(pat: &hir::Pat) -> Option<hir::Mutability> {\n     let mut result = None;\n-    pat_bindings(dm, pat, |mode, _, _, _| {\n-        match mode {\n-            hir::BindingMode::BindByRef(m) => {\n-                // Pick Mutable as maximum\n-                match result {\n-                    None | Some(hir::MutImmutable) => result = Some(m),\n-                    _ => (),\n-                }\n+    pat_bindings(pat, |mode, _, _, _| {\n+        if let hir::BindingMode::BindByRef(m) = mode {\n+            // Pick Mutable as maximum\n+            match result {\n+                None | Some(hir::MutImmutable) => result = Some(m),\n+                _ => (),\n             }\n-            hir::BindingMode::BindByValue(_) => { }\n         }\n     });\n     result\n }\n \n /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n /// bindings, and if yes whether its containing mutable ones or just immutables ones.\n-pub fn arm_contains_ref_binding(dm: &RefCell<DefMap>, arm: &hir::Arm) -> Option<hir::Mutability> {\n+pub fn arm_contains_ref_binding(arm: &hir::Arm) -> Option<hir::Mutability> {\n     arm.pats.iter()\n-            .filter_map(|pat| pat_contains_ref_binding(dm, pat))\n+            .filter_map(|pat| pat_contains_ref_binding(pat))\n             .max_by_key(|m| match *m {\n                 hir::MutMutable => 1,\n                 hir::MutImmutable => 0,\n@@ -200,14 +178,15 @@ pub fn arm_contains_ref_binding(dm: &RefCell<DefMap>, arm: &hir::Arm) -> Option<\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n-pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_contains_bindings_or_wild(pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n     pat.walk(|p| {\n-        if pat_is_binding_or_wild(dm, p) {\n-            contains_bindings = true;\n-            false // there's at least one binding/wildcard, can short circuit now.\n-        } else {\n-            true\n+        match p.node {\n+            PatKind::Binding(..) | PatKind::Wild => {\n+                contains_bindings = true;\n+                false // there's at least one binding/wildcard, can short circuit now.\n+            }\n+            _ => true\n         }\n     });\n     contains_bindings"}, {"sha": "cf07493fa7b60376fa7140c1e854f5c3f4f9764b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 70, "deletions": 87, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -612,8 +612,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&self.mc.infcx.tcx.def_map, &local.pat,\n-                                       |_, id, span, _| {\n+                pat_util::pat_bindings(&local.pat, |_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n             }\n@@ -932,23 +931,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr,\n                pat);\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n-            let def_map = &self.tcx().def_map;\n-            if pat_util::pat_is_binding(&def_map.borrow(), pat) {\n-                match pat.node {\n-                    PatKind::Binding(hir::BindByRef(_), _, _) =>\n-                        mode.lub(BorrowingMatch),\n-                    PatKind::Binding(hir::BindByValue(_), _, _) => {\n-                        match copy_or_move(self.mc.infcx, &cmt_pat, PatBindingMove) {\n-                            Copy => mode.lub(CopyingMatch),\n-                            Move(_) => mode.lub(MovingMatch),\n-                        }\n-                    }\n-                    _ => {\n-                        span_bug!(\n-                            pat.span,\n-                            \"binding pattern not an identifier\");\n+            match pat.node {\n+                PatKind::Binding(hir::BindByRef(..), _, _) =>\n+                    mode.lub(BorrowingMatch),\n+                PatKind::Binding(hir::BindByValue(..), _, _) => {\n+                    match copy_or_move(self.mc.infcx, &cmt_pat, PatBindingMove) {\n+                        Copy => mode.lub(CopyingMatch),\n+                        Move(..) => mode.lub(MovingMatch),\n                     }\n                 }\n+                _ => {}\n             }\n         }));\n     }\n@@ -968,83 +960,74 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         let def_map = &self.tcx().def_map;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n-            if pat_util::pat_is_binding(&def_map.borrow(), pat) {\n-                debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n-                       cmt_pat,\n-                       pat,\n-                       match_mode);\n-\n-                // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n-\n-                // Each match binding is effectively an assignment to the\n-                // binding being produced.\n-                let def = def_map.borrow().get(&pat.id).unwrap().full_def();\n-                match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n-                    Ok(binding_cmt) => {\n+            match pat.node {\n+                PatKind::Binding(bmode, _, _) => {\n+                    debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n+                           cmt_pat,\n+                           pat,\n+                           match_mode);\n+\n+                    // pat_ty: the type of the binding being produced.\n+                    let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n+\n+                    // Each match binding is effectively an assignment to the\n+                    // binding being produced.\n+                    let def = def_map.borrow().get(&pat.id).unwrap().full_def();\n+                    if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                         delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                     }\n-                    Err(_) => { }\n-                }\n \n-                // It is also a borrow or copy/move of the value being matched.\n-                match pat.node {\n-                    PatKind::Binding(hir::BindByRef(m), _, _) => {\n-                        if let ty::TyRef(&r, _) = pat_ty.sty {\n-                            let bk = ty::BorrowKind::from_mutbl(m);\n-                            delegate.borrow(pat.id, pat.span, cmt_pat,\n-                                            r, bk, RefBinding);\n+                    // It is also a borrow or copy/move of the value being matched.\n+                    match bmode {\n+                        hir::BindByRef(m) => {\n+                            if let ty::TyRef(&r, _) = pat_ty.sty {\n+                                let bk = ty::BorrowKind::from_mutbl(m);\n+                                delegate.borrow(pat.id, pat.span, cmt_pat,\n+                                                r, bk, RefBinding);\n+                            }\n+                        }\n+                        hir::BindByValue(..) => {\n+                            let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n+                            debug!(\"walk_pat binding consuming pat\");\n+                            delegate.consume_pat(pat, cmt_pat, mode);\n                         }\n-                    }\n-                    PatKind::Binding(hir::BindByValue(_), _, _) => {\n-                        let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n-                        debug!(\"walk_pat binding consuming pat\");\n-                        delegate.consume_pat(pat, cmt_pat, mode);\n-                    }\n-                    _ => {\n-                        span_bug!(\n-                            pat.span,\n-                            \"binding pattern not an identifier\");\n                     }\n                 }\n-            } else {\n-                match pat.node {\n-                    PatKind::Vec(_, Some(ref slice_pat), _) => {\n-                        // The `slice_pat` here creates a slice into\n-                        // the original vector.  This is effectively a\n-                        // borrow of the elements of the vector being\n-                        // matched.\n-\n-                        let (slice_cmt, slice_mutbl, slice_r) =\n-                            return_if_err!(mc.cat_slice_pattern(cmt_pat, &slice_pat));\n-\n-                        // Note: We declare here that the borrow\n-                        // occurs upon entering the `[...]`\n-                        // pattern. This implies that something like\n-                        // `[a; b]` where `a` is a move is illegal,\n-                        // because the borrow is already in effect.\n-                        // In fact such a move would be safe-ish, but\n-                        // it effectively *requires* that we use the\n-                        // nulling out semantics to indicate when a\n-                        // value has been moved, which we are trying\n-                        // to move away from.  Otherwise, how can we\n-                        // indicate that the first element in the\n-                        // vector has been moved?  Eventually, we\n-                        // could perhaps modify this rule to permit\n-                        // `[..a, b]` where `b` is a move, because in\n-                        // that case we can adjust the length of the\n-                        // original vec accordingly, but we'd have to\n-                        // make trans do the right thing, and it would\n-                        // only work for `Box<[T]>`s. It seems simpler\n-                        // to just require that people call\n-                        // `vec.pop()` or `vec.unshift()`.\n-                        let slice_bk = ty::BorrowKind::from_mutbl(slice_mutbl);\n-                        delegate.borrow(pat.id, pat.span,\n-                                        slice_cmt, slice_r,\n-                                        slice_bk, RefBinding);\n-                    }\n-                    _ => { }\n+                PatKind::Vec(_, Some(ref slice_pat), _) => {\n+                    // The `slice_pat` here creates a slice into\n+                    // the original vector.  This is effectively a\n+                    // borrow of the elements of the vector being\n+                    // matched.\n+\n+                    let (slice_cmt, slice_mutbl, slice_r) =\n+                        return_if_err!(mc.cat_slice_pattern(cmt_pat, &slice_pat));\n+\n+                    // Note: We declare here that the borrow\n+                    // occurs upon entering the `[...]`\n+                    // pattern. This implies that something like\n+                    // `[a; b]` where `a` is a move is illegal,\n+                    // because the borrow is already in effect.\n+                    // In fact such a move would be safe-ish, but\n+                    // it effectively *requires* that we use the\n+                    // nulling out semantics to indicate when a\n+                    // value has been moved, which we are trying\n+                    // to move away from.  Otherwise, how can we\n+                    // indicate that the first element in the\n+                    // vector has been moved?  Eventually, we\n+                    // could perhaps modify this rule to permit\n+                    // `[..a, b]` where `b` is a move, because in\n+                    // that case we can adjust the length of the\n+                    // original vec accordingly, but we'd have to\n+                    // make trans do the right thing, and it would\n+                    // only work for `Box<[T]>`s. It seems simpler\n+                    // to just require that people call\n+                    // `vec.pop()` or `vec.unshift()`.\n+                    let slice_bk = ty::BorrowKind::from_mutbl(slice_mutbl);\n+                    delegate.borrow(pat.id, pat.span,\n+                                    slice_cmt, slice_r,\n+                                    slice_bk, RefBinding);\n                 }\n+                _ => {}\n             }\n         }));\n "}, {"sha": "f6ea10a70eb2a7aa1fa911576a6989aa278dd7f8", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -380,9 +380,7 @@ fn visit_fn(ir: &mut IrMaps,\n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n     for arg in &decl.inputs {\n-        pat_util::pat_bindings(&ir.tcx.def_map,\n-                               &arg.pat,\n-                               |_bm, arg_id, _x, path1| {\n+        pat_util::pat_bindings(&arg.pat, |_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n             let name = path1.node;\n             fn_maps.add_variable(Arg(arg_id, name));\n@@ -415,7 +413,7 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n-    pat_util::pat_bindings(&ir.tcx.def_map, &local.pat, |_, p_id, sp, path1| {\n+    pat_util::pat_bindings(&local.pat, |_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node;\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -429,7 +427,7 @@ fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n     for pat in &arm.pats {\n-        pat_util::pat_bindings(&ir.tcx.def_map, &pat, |bm, p_id, sp, path1| {\n+        pat_util::pat_bindings(&pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = path1.node;\n@@ -589,7 +587,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn pat_bindings<F>(&mut self, pat: &hir::Pat, mut f: F) where\n         F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n     {\n-        pat_util::pat_bindings(&self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n+        pat_util::pat_bindings(pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(self, ln, var, sp, p_id);\n@@ -1567,9 +1565,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn warn_about_unused_args(&self, decl: &hir::FnDecl, entry_ln: LiveNode) {\n         for arg in &decl.inputs {\n-            pat_util::pat_bindings(&self.ir.tcx.def_map,\n-                                   &arg.pat,\n-                                   |_bm, p_id, sp, path1| {\n+            pat_util::pat_bindings(&arg.pat, |_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self.\n                 let name = path1.node;"}, {"sha": "a4df02872166986c698ec10fae4477552ad147e1", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -173,11 +173,11 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn pat_contains_ref_binding(self, pat: &hir::Pat) -> Option<hir::Mutability> {\n-        pat_util::pat_contains_ref_binding(&self.def_map, pat)\n+        pat_util::pat_contains_ref_binding(pat)\n     }\n \n     pub fn arm_contains_ref_binding(self, arm: &hir::Arm) -> Option<hir::Mutability> {\n-        pat_util::arm_contains_ref_binding(&self.def_map, arm)\n+        pat_util::arm_contains_ref_binding(arm)\n     }\n \n     /// Returns the type of element at index `i` in tuple or tuple-like type `t`."}, {"sha": "49fa1896ff8dd68cd8b9fbc589d89e43509a421b", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -748,10 +748,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n             }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {\n-                if pat_is_binding_or_wild(&cx.tcx.def_map.borrow(), raw_pat(r[0])) {\n-                    Some(r[1..].to_vec())\n-                } else {\n-                    None\n+                match raw_pat(r[0]).node {\n+                    PatKind::Binding(..) | PatKind::Wild => Some(r[1..].to_vec()),\n+                    _ => None,\n                 }\n             }).collect();\n             match is_useful(cx, &matrix, &v[1..], witness) {\n@@ -1089,17 +1088,11 @@ fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A>\n fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                    has_guard: bool,\n                                    pats: &[P<Pat>]) {\n-    let tcx = cx.tcx;\n-    let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n     for pat in pats {\n-        pat_bindings(def_map, &pat, |bm, _, span, _path| {\n-            match bm {\n-                hir::BindByRef(_) => {\n-                    by_ref_span = Some(span);\n-                }\n-                hir::BindByValue(_) => {\n-                }\n+        pat_bindings(&pat, |bm, _, span, _path| {\n+            if let hir::BindByRef(..) = bm {\n+                by_ref_span = Some(span);\n             }\n         })\n     }\n@@ -1108,7 +1101,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n-        if sub.map_or(false, |p| pat_contains_bindings(&def_map.borrow(), &p)) {\n+        if sub.map_or(false, |p| pat_contains_bindings(&p)) {\n             span_err!(cx.tcx.sess, p.span, E0007, \"cannot bind by-move with sub-bindings\");\n         } else if has_guard {\n             span_err!(cx.tcx.sess, p.span, E0008, \"cannot bind by-move into a pattern guard\");\n@@ -1123,7 +1116,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n-                let pat_ty = tcx.node_id_to_type(p.id);\n+                let pat_ty = cx.tcx.node_id_to_type(p.id);\n                 //FIXME: (@jroesch) this code should be floated up as well\n                 cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n                                   ProjectionMode::AnyFinal).enter(|infcx| {\n@@ -1199,18 +1192,19 @@ struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     fn visit_pat(&mut self, pat: &Pat) {\n-        if !self.bindings_allowed && pat_is_binding(&self.cx.tcx.def_map.borrow(), pat) {\n-            span_err!(self.cx.tcx.sess, pat.span, E0303,\n-                                      \"pattern bindings are not allowed \\\n-                                       after an `@`\");\n-        }\n-\n         match pat.node {\n-            PatKind::Binding(_, _, Some(_)) => {\n-                let bindings_were_allowed = self.bindings_allowed;\n-                self.bindings_allowed = false;\n-                intravisit::walk_pat(self, pat);\n-                self.bindings_allowed = bindings_were_allowed;\n+            PatKind::Binding(_, _, ref subpat) => {\n+                if !self.bindings_allowed {\n+                    span_err!(self.cx.tcx.sess, pat.span, E0303,\n+                              \"pattern bindings are not allowed after an `@`\");\n+                }\n+\n+                if subpat.is_some() {\n+                    let bindings_were_allowed = self.bindings_allowed;\n+                    self.bindings_allowed = false;\n+                    intravisit::walk_pat(self, pat);\n+                    self.bindings_allowed = bindings_were_allowed;\n+                }\n             }\n             _ => intravisit::walk_pat(self, pat),\n         }"}, {"sha": "b765043da885363e23df9b2811a3dfb97ba18539", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -43,7 +43,7 @@ impl UnusedMut {\n \n         let mut mutables = FnvHashMap();\n         for p in pats {\n-            pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path1| {\n+            pat_util::pat_bindings(p, |mode, id, _, path1| {\n                 let name = path1.node;\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !name.as_str().starts_with(\"_\") {"}, {"sha": "1f560672b62a8e8a6a7754ec4d588be7f4a0117c", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -656,7 +656,7 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         None\n     } else {\n         map = FnvHashMap();\n-        pat_util::pat_bindings(&cx.tcx.def_map, &arm.pats[0], |_, p_id, _, path| {\n+        pat_util::pat_bindings(&arm.pats[0], |_, p_id, _, path| {\n             map.insert(path.node, p_id);\n         });\n         Some(&map)"}, {"sha": "419e19532dd7c3e738360cc2d5dd7c4f703c8317", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -540,7 +540,6 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n }\n \n fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     dm: &RefCell<DefMap>,\n                                      m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                      col: usize,\n                                      val: MatchInput)\n@@ -551,12 +550,13 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, m, col, val, |pats| {\n-        if pat_is_binding_or_wild(&dm.borrow(), &pats[col]) {\n-            let mut r = pats[..col].to_vec();\n-            r.extend_from_slice(&pats[col + 1..]);\n-            Some(r)\n-        } else {\n-            None\n+        match pats[col].node {\n+            PatKind::Binding(..) | PatKind::Wild => {\n+                let mut r = pats[..col].to_vec();\n+                r.extend_from_slice(&pats[col + 1..]);\n+                Some(r)\n+            }\n+            _ => None\n         }\n     })\n }\n@@ -1145,7 +1145,6 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n-    let dm = &tcx.def_map;\n \n     let mut vals_left = vals[0..col].to_vec();\n     vals_left.extend_from_slice(&vals[col + 1..]);\n@@ -1279,7 +1278,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         C_int(ccx, 0) // Placeholder for when not using a switch\n     };\n \n-    let defaults = enter_default(else_cx, dm, m, col, val);\n+    let defaults = enter_default(else_cx, m, col, val);\n     let exhaustive = chk.is_infallible() && defaults.is_empty();\n     let len = opts.len();\n \n@@ -1509,10 +1508,9 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &hir::Pat,\n     // Note that we use the names because each binding will have many ids\n     // from the various alternatives.\n     let ccx = bcx.ccx();\n-    let tcx = bcx.tcx();\n     let reassigned = is_discr_reassigned(bcx, discr, body);\n     let mut bindings_map = FnvHashMap();\n-    pat_bindings(&tcx.def_map, &pat, |bm, p_id, span, path1| {\n+    pat_bindings(&pat, |bm, p_id, span, path1| {\n         let name = path1.node;\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n@@ -1655,7 +1653,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n-        pat_bindings(&tcx.def_map, pat, |_, p_id, _, path1| {\n+        pat_bindings(pat, |_, p_id, _, path1| {\n             let scope = cleanup::var_scope(tcx, p_id);\n             bcx = mk_binding_alloca(\n                 bcx, p_id, path1.node, scope, (),"}, {"sha": "bba0edd5f0496d283c7a5daaeae763a0a01907b6", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -42,16 +42,13 @@ pub fn create_scope_map(cx: &CrateContext,\n                         fn_ast_id: ast::NodeId)\n                         -> NodeMap<DIScope> {\n     let mut scope_map = NodeMap();\n-\n-    let def_map = &cx.tcx().def_map;\n-\n     let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, name: None });\n     scope_map.insert(fn_ast_id, fn_metadata);\n \n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n     for arg in args {\n-        pat_util::pat_bindings(def_map, &arg.pat, |_, node_id, _, path1| {\n+        pat_util::pat_bindings(&arg.pat, |_, node_id, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n                                                name: Some(path1.node.unhygienize()) });\n             scope_map.insert(node_id, fn_metadata);"}, {"sha": "ab4860dff1510ce414e376be32cccfd9f677c20b", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -1889,11 +1889,8 @@ pub fn create_local_var_metadata(bcx: Block, local: &hir::Local) {\n         return;\n     }\n \n-    let cx = bcx.ccx();\n-    let def_map = &cx.tcx().def_map;\n     let locals = bcx.fcx.lllocals.borrow();\n-\n-    pat_util::pat_bindings(def_map, &local.pat, |_, node_id, span, var_name| {\n+    pat_util::pat_bindings(&local.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n@@ -2062,15 +2059,14 @@ pub fn create_argument_metadata(bcx: Block, arg: &hir::Arg) {\n         return;\n     }\n \n-    let def_map = &bcx.tcx().def_map;\n     let scope_metadata = bcx\n                          .fcx\n                          .debug_context\n                          .get_ref(arg.pat.span)\n                          .fn_metadata;\n     let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &arg.pat, |_, node_id, span, var_name| {\n+    pat_util::pat_bindings(&arg.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(v) => v,\n             None => {"}, {"sha": "99b443e292491fed7164c2950f2ff1c1704a001f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def::{self, Def};\n use rustc::infer::{self, InferOk, TypeOrigin};\n-use hir::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n+use hir::pat_util::{PatIdMap, pat_id_map};\n use hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n@@ -436,23 +436,19 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n-        let tcx = self.tcx;\n-        if pat_is_binding(&tcx.def_map.borrow(), inner) {\n-            let expected = self.shallow_resolve(expected);\n-            expected.builtin_deref(true, ty::NoPreference).map_or(true, |mt| match mt.ty.sty {\n-                ty::TyTrait(_) => {\n+        if let PatKind::Binding(..) = inner.node {\n+            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true, ty::NoPreference) {\n+                if let ty::TyTrait(..) = mt.ty.sty {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                    span_err!(tcx.sess, span, E0033,\n+                    span_err!(self.tcx.sess, span, E0033,\n                               \"type `{}` cannot be dereferenced\",\n                               self.ty_to_string(expected));\n-                    false\n+                    return false\n                 }\n-                _ => true\n-            })\n-        } else {\n-            true\n+            }\n         }\n+        true\n     }\n }\n \n@@ -491,7 +487,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         for arm in arms {\n             let pcx = PatCtxt {\n                 fcx: self,\n-                map: pat_id_map(&tcx.def_map, &arm.pats[0]),\n+                map: pat_id_map(&arm.pats[0]),\n             };\n             for p in &arm.pats {\n                 pcx.check_pat(&p, discrim_ty);"}, {"sha": "819448e6a80683910218dc0370bde2c732f95d0d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -630,8 +630,6 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             body: &'gcx hir::Block)\n                             -> FnCtxt<'a, 'gcx, 'tcx>\n {\n-    let tcx = inherited.tcx;\n-\n     let arg_tys = &fn_sig.inputs;\n     let ret_ty = fn_sig.output;\n \n@@ -667,19 +665,15 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             fcx.register_old_wf_obligation(arg_ty, input.ty.span, traits::MiscObligation);\n \n             // Create type variables for each argument.\n-            pat_util::pat_bindings(\n-                &tcx.def_map,\n-                &input.pat,\n-                |_bm, pat_id, sp, _path| {\n-                    let var_ty = visit.assign(sp, pat_id, None);\n-                    fcx.require_type_is_sized(var_ty, sp,\n-                                              traits::VariableType(pat_id));\n-                });\n+            pat_util::pat_bindings(&input.pat, |_bm, pat_id, sp, _path| {\n+                let var_ty = visit.assign(sp, pat_id, None);\n+                fcx.require_type_is_sized(var_ty, sp, traits::VariableType(pat_id));\n+            });\n \n             // Check the pattern.\n             let pcx = PatCtxt {\n                 fcx: &fcx,\n-                map: pat_id_map(&tcx.def_map, &input.pat),\n+                map: pat_id_map(&input.pat),\n             };\n             pcx.check_pat(&input.pat, *arg_ty);\n         }\n@@ -3932,8 +3926,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n-        let tcx = self.tcx;\n-\n         let t = self.local_ty(local.span, local.id);\n         self.write_ty(local.id, t);\n \n@@ -3947,7 +3939,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let pcx = PatCtxt {\n             fcx: self,\n-            map: pat_id_map(&tcx.def_map, &local.pat),\n+            map: pat_id_map(&local.pat),\n         };\n         pcx.check_pat(&local.pat, t);\n         let pat_ty = self.node_ty(local.pat.id);"}, {"sha": "fd1b60551734cffcb1bc576f418b02203a5c7469", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -452,7 +452,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n         let tcx = self.tcx;\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n-        pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n+        pat_util::pat_bindings(pat, |_, id, span, _| {\n             // If we have a variable that contains region'd data, that\n             // data will be accessible from anywhere that the variable is\n             // accessed. We must be wary of loops like this:"}, {"sha": "205eaf1a38e1494dc9ae2ce2ecb298d97cfc4a05", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -15,7 +15,6 @@ use self::ResolveReason::*;\n \n use check::FnCtxt;\n use hir::def_id::DefId;\n-use hir::pat_util;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n@@ -29,7 +28,7 @@ use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n use rustc::hir::print::pat_to_string;\n use rustc::hir::intravisit::{self, Visitor};\n-use rustc::hir;\n+use rustc::hir::{self, PatKind};\n \n ///////////////////////////////////////////////////////////////////////////\n // Entry point functions\n@@ -54,9 +53,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             wbcx.visit_pat(&arg.pat);\n \n             // Privacy needs the type for the whole pattern, not just each binding\n-            if !pat_util::pat_is_binding(&self.tcx.def_map.borrow(), &arg.pat) {\n-                wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n-                                   arg.pat.id);\n+            if let PatKind::Binding(..) = arg.pat.node {} else {\n+                wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.pat.id);\n             }\n         }\n         wbcx.visit_upvar_borrow_map();"}, {"sha": "be8d296dab09b5db740604935937c5786de92eb7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4682069468f231e6153b9fc910e0c720c71ecb/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cf4682069468f231e6153b9fc910e0c720c71ecb", "patch": "@@ -616,14 +616,10 @@ pub enum PatKind {\n     /// Represents a wildcard pattern (`_`)\n     Wild,\n \n-    /// A `PatKind::Ident` may either be a new bound variable,\n-    /// or a unit struct/variant pattern, or a const pattern (in the last two cases\n-    /// the third field must be `None`).\n-    ///\n-    /// In the unit or const pattern case, the parser can't determine\n-    /// which it is. The resolver determines this, and\n-    /// records this pattern's `NodeId` in an auxiliary\n-    /// set (of \"PatIdents that refer to unit patterns or constants\").\n+    /// A `PatKind::Ident` may either be a new bound variable (`ref mut binding @ OPT_SUBPATTERN`),\n+    /// or a unit struct/variant pattern, or a const pattern (in the last two cases the third\n+    /// field must be `None`). Disambiguation cannot be done with parser alone, so it happens\n+    /// during name resolution.\n     Ident(BindingMode, SpannedIdent, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n@@ -639,10 +635,8 @@ pub enum PatKind {\n     /// Such pattern can be resolved to a unit struct/variant or a constant.\n     Path(Path),\n \n-    /// An associated const named using the qualified path `<T>::CONST` or\n-    /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n-    /// referred to as simply `T::CONST`, in which case they will end up as\n-    /// PatKind::Path, and the resolver will have to sort that out.\n+    /// A path pattern written in qualified form, i.e. `<T as Trait>::CONST` or `<T>::CONST`.\n+    /// Such patterns can only refer to associated constants at the moment.\n     QPath(QSelf, Path),\n \n     /// A tuple pattern `(a, b)`."}]}