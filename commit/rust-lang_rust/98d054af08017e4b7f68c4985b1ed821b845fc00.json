{"sha": "98d054af08017e4b7f68c4985b1ed821b845fc00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZDA1NGFmMDgwMTdlNGI3ZjY4YzQ5ODViMWVkODIxYjg0NWZjMDA=", "commit": {"author": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2019-12-16T21:55:08Z"}, "committer": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2019-12-26T22:15:05Z"}, "message": "Rename wait_until/wait_timeout_until to wait_while/white_timeout_while", "tree": {"sha": "111d4306b797b742f61cca5a2bb02773872c6871", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/111d4306b797b742f61cca5a2bb02773872c6871"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98d054af08017e4b7f68c4985b1ed821b845fc00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98d054af08017e4b7f68c4985b1ed821b845fc00", "html_url": "https://github.com/rust-lang/rust/commit/98d054af08017e4b7f68c4985b1ed821b845fc00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98d054af08017e4b7f68c4985b1ed821b845fc00/comments", "author": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "207e60a364a23e15261f4fdd6471907d4fa906f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/207e60a364a23e15261f4fdd6471907d4fa906f4", "html_url": "https://github.com/rust-lang/rust/commit/207e60a364a23e15261f4fdd6471907d4fa906f4"}], "stats": {"total": 68, "additions": 32, "deletions": 36}, "files": [{"sha": "77e521eae9afefe72ff8180eb555a6f926ff774d", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/98d054af08017e4b7f68c4985b1ed821b845fc00/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d054af08017e4b7f68c4985b1ed821b845fc00/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=98d054af08017e4b7f68c4985b1ed821b845fc00", "patch": "@@ -204,9 +204,7 @@ impl Condvar {\n     }\n \n     /// Blocks the current thread until this condition variable receives a\n-    /// notification and the required condition is met. Spurious wakeups are\n-    /// ignored and this function will only return once the condition has been\n-    /// met.\n+    /// notification and the provided condition is false.\n     ///\n     /// This function will atomically unlock the mutex specified (represented by\n     /// `guard`) and block the current thread. This means that any calls\n@@ -231,32 +229,32 @@ impl Condvar {\n     /// use std::sync::{Arc, Mutex, Condvar};\n     /// use std::thread;\n     ///\n-    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair = Arc::new((Mutex::new(true), Condvar::new()));\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n     ///     let (lock, cvar) = &*pair2;\n-    ///     let mut started = lock.lock().unwrap();\n-    ///     *started = true;\n+    ///     let mut pending = lock.lock().unwrap();\n+    ///     *pending = false;\n     ///     // We notify the condvar that the value has changed.\n     ///     cvar.notify_one();\n     /// });\n     ///\n     /// // Wait for the thread to start up.\n     /// let (lock, cvar) = &*pair;\n-    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n-    /// let _guard = cvar.wait_until(lock.lock().unwrap(), |started| { *started }).unwrap();\n+    /// // As long as the value inside the `Mutex<bool>` is `true`, we wait.\n+    /// let _guard = cvar.wait_while(lock.lock().unwrap(), |pending| { *pending }).unwrap();\n     /// ```\n     #[stable(feature = \"wait_until\", since = \"1.42.0\")]\n-    pub fn wait_until<'a, T, F>(\n+    pub fn wait_while<'a, T, F>(\n         &self,\n         mut guard: MutexGuard<'a, T>,\n         mut condition: F,\n     ) -> LockResult<MutexGuard<'a, T>>\n     where\n         F: FnMut(&mut T) -> bool,\n     {\n-        while !condition(&mut *guard) {\n+        while condition(&mut *guard) {\n             guard = self.wait(guard)?;\n         }\n         Ok(guard)\n@@ -341,11 +339,10 @@ impl Condvar {\n     /// Condition variables normally have a boolean predicate associated with\n     /// them, and the predicate must always be checked each time this function\n     /// returns to protect against spurious wakeups. Additionally, it is\n-    /// typically desirable for the time-out to not exceed some duration in\n+    /// typically desirable for the timeout to not exceed some duration in\n     /// spite of spurious wakes, thus the sleep-duration is decremented by the\n-    /// amount slept. Alternatively, use the `wait_timeout_until` method\n-    /// to wait until a condition is met with a total time-out regardless\n-    /// of spurious wakes.\n+    /// amount slept. Alternatively, use the `wait_timeout_while` method\n+    /// to wait with a timeout while a predicate is true.\n     ///\n     /// The returned [`WaitTimeoutResult`] value indicates if the timeout is\n     /// known to have elapsed.\n@@ -354,7 +351,7 @@ impl Condvar {\n     /// returns, regardless of whether the timeout elapsed or not.\n     ///\n     /// [`wait`]: #method.wait\n-    /// [`wait_timeout_until`]: #method.wait_timeout_until\n+    /// [`wait_timeout_while`]: #method.wait_timeout_while\n     /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n     ///\n     /// # Examples\n@@ -405,10 +402,9 @@ impl Condvar {\n     }\n \n     /// Waits on this condition variable for a notification, timing out after a\n-    /// specified duration. Spurious wakes will not cause this function to\n-    /// return.\n+    /// specified duration.\n     ///\n-    /// The semantics of this function are equivalent to [`wait_until`] except\n+    /// The semantics of this function are equivalent to [`wait_while`] except\n     /// that the thread will be blocked for roughly no longer than `dur`. This\n     /// method should not be used for precise timing due to anomalies such as\n     /// preemption or platform differences that may not cause the maximum\n@@ -421,10 +417,10 @@ impl Condvar {\n     /// The returned [`WaitTimeoutResult`] value indicates if the timeout is\n     /// known to have elapsed without the condition being met.\n     ///\n-    /// Like [`wait_until`], the lock specified will be re-acquired when this\n+    /// Like [`wait_while`], the lock specified will be re-acquired when this\n     /// function returns, regardless of whether the timeout elapsed or not.\n     ///\n-    /// [`wait_until`]: #method.wait_until\n+    /// [`wait_while`]: #method.wait_while\n     /// [`wait_timeout`]: #method.wait_timeout\n     /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n     ///\n@@ -435,31 +431,31 @@ impl Condvar {\n     /// use std::thread;\n     /// use std::time::Duration;\n     ///\n-    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair = Arc::new((Mutex::new(true), Condvar::new()));\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n     ///     let (lock, cvar) = &*pair2;\n-    ///     let mut started = lock.lock().unwrap();\n-    ///     *started = true;\n+    ///     let mut pending = lock.lock().unwrap();\n+    ///     *pending = false;\n     ///     // We notify the condvar that the value has changed.\n     ///     cvar.notify_one();\n     /// });\n     ///\n     /// // wait for the thread to start up\n     /// let (lock, cvar) = &*pair;\n-    /// let result = cvar.wait_timeout_until(\n+    /// let result = cvar.wait_timeout_while(\n     ///     lock.lock().unwrap(),\n     ///     Duration::from_millis(100),\n-    ///     |&mut started| started,\n+    ///     |&mut pending| pending,\n     /// ).unwrap();\n     /// if result.1.timed_out() {\n-    ///     // timed-out without the condition ever evaluating to true.\n+    ///     // timed-out without the condition ever evaluating to false.\n     /// }\n     /// // access the locked mutex via result.0\n     /// ```\n     #[stable(feature = \"wait_timeout_until\", since = \"1.42.0\")]\n-    pub fn wait_timeout_until<'a, T, F>(\n+    pub fn wait_timeout_while<'a, T, F>(\n         &self,\n         mut guard: MutexGuard<'a, T>,\n         dur: Duration,\n@@ -470,7 +466,7 @@ impl Condvar {\n     {\n         let start = Instant::now();\n         loop {\n-            if condition(&mut *guard) {\n+            if !condition(&mut *guard) {\n                 return Ok((guard, WaitTimeoutResult(false)));\n             }\n             let timeout = match dur.checked_sub(start.elapsed()) {\n@@ -678,7 +674,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn wait_until() {\n+    fn wait_while() {\n         let pair = Arc::new((Mutex::new(false), Condvar::new()));\n         let pair2 = pair.clone();\n \n@@ -693,7 +689,7 @@ mod tests {\n \n         // Wait for the thread to start up.\n         let &(ref lock, ref cvar) = &*pair;\n-        let guard = cvar.wait_until(lock.lock().unwrap(), |started| *started);\n+        let guard = cvar.wait_while(lock.lock().unwrap(), |started| !*started);\n         assert!(*guard.unwrap());\n     }\n \n@@ -720,32 +716,32 @@ mod tests {\n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n     #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-    fn wait_timeout_until_wait() {\n+    fn wait_timeout_while_wait() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n \n         let g = m.lock().unwrap();\n-        let (_g, wait) = c.wait_timeout_until(g, Duration::from_millis(1), |_| false).unwrap();\n+        let (_g, wait) = c.wait_timeout_while(g, Duration::from_millis(1), |_| true).unwrap();\n         // no spurious wakeups. ensure it timed-out\n         assert!(wait.timed_out());\n     }\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn wait_timeout_until_instant_satisfy() {\n+    fn wait_timeout_while_instant_satisfy() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n \n         let g = m.lock().unwrap();\n-        let (_g, wait) = c.wait_timeout_until(g, Duration::from_millis(0), |_| true).unwrap();\n+        let (_g, wait) = c.wait_timeout_while(g, Duration::from_millis(0), |_| false).unwrap();\n         // ensure it didn't time-out even if we were not given any time.\n         assert!(!wait.timed_out());\n     }\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n     #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-    fn wait_timeout_until_wake() {\n+    fn wait_timeout_while_wake() {\n         let pair = Arc::new((Mutex::new(false), Condvar::new()));\n         let pair_copy = pair.clone();\n \n@@ -759,7 +755,7 @@ mod tests {\n             cvar.notify_one();\n         });\n         let (g2, wait) = c\n-            .wait_timeout_until(g, Duration::from_millis(u64::MAX), |&mut notified| notified)\n+            .wait_timeout_while(g, Duration::from_millis(u64::MAX), |&mut notified| !notified)\n             .unwrap();\n         // ensure it didn't time-out even if we were not given any time.\n         assert!(!wait.timed_out());"}]}