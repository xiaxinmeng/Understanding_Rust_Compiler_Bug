{"sha": "ae429e8cab135902df69135d8b4b4aca555f4ace", "node_id": "C_kwDOAAsO6NoAKGFlNDI5ZThjYWIxMzU5MDJkZjY5MTM1ZDhiNGI0YWNhNTU1ZjRhY2U", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-02-14T08:51:19Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-03-01T03:16:56Z"}, "message": "s/eval_usize/eval_target_usize/ for clarity", "tree": {"sha": "adb426d16b1c15c8aec1b7dbc80cc0f87c0d4a35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adb426d16b1c15c8aec1b7dbc80cc0f87c0d4a35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae429e8cab135902df69135d8b4b4aca555f4ace", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae429e8cab135902df69135d8b4b4aca555f4ace", "html_url": "https://github.com/rust-lang/rust/commit/ae429e8cab135902df69135d8b4b4aca555f4ace", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae429e8cab135902df69135d8b4b4aca555f4ace/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1640ccac4da37ae2095d6e9bec68ff90aa71aecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1640ccac4da37ae2095d6e9bec68ff90aa71aecf", "html_url": "https://github.com/rust-lang/rust/commit/1640ccac4da37ae2095d6e9bec68ff90aa71aecf"}], "stats": {"total": 189, "additions": 111, "deletions": 78}, "files": [{"sha": "b8c47997009145e1f3183860901d968b65af5a4f", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 111, "deletions": 78, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/ae429e8cab135902df69135d8b4b4aca555f4ace/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae429e8cab135902df69135d8b4b4aca555f4ace/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=ae429e8cab135902df69135d8b4b4aca555f4ace", "patch": "@@ -1,6 +1,7 @@\n #[cfg_attr(not(feature=\"master\"), allow(unused_imports))]\n use gccjit::{ToRValue, ComparisonOp, UnaryOp};\n use gccjit::{BinaryOp, RValue, Type};\n+\n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n@@ -10,52 +11,58 @@ use rustc_hir as hir;\n use rustc_middle::span_bug;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::{Span, Symbol, sym};\n+use rustc_span::{sym, Span, Symbol};\n use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n #[cfg(feature=\"master\")]\n use crate::context::CodegenCx;\n use crate::errors::{\n-    InvalidMonomorphizationInvalidFloatVector,\n-    InvalidMonomorphizationNotFloat,\n-    InvalidMonomorphizationUnrecognized,\n-    InvalidMonomorphizationExpectedSignedUnsigned,\n-    InvalidMonomorphizationUnsupportedElement,\n-    InvalidMonomorphizationInvalidBitmask,\n-    InvalidMonomorphizationSimdShuffle,\n-    InvalidMonomorphizationExpectedSimd,\n-    InvalidMonomorphizationMaskType,\n-    InvalidMonomorphizationReturnLength,\n-    InvalidMonomorphizationReturnLengthInputType,\n-    InvalidMonomorphizationReturnElement,\n-    InvalidMonomorphizationReturnType,\n-    InvalidMonomorphizationInsertedType,\n-    InvalidMonomorphizationReturnIntegerType,\n-    InvalidMonomorphizationMismatchedLengths,\n-    InvalidMonomorphizationUnsupportedOperation\n+    InvalidMonomorphizationExpectedSignedUnsigned, InvalidMonomorphizationExpectedSimd,\n+    InvalidMonomorphizationInsertedType, InvalidMonomorphizationInvalidBitmask,\n+    InvalidMonomorphizationInvalidFloatVector, InvalidMonomorphizationMaskType,\n+    InvalidMonomorphizationMismatchedLengths, InvalidMonomorphizationNotFloat,\n+    InvalidMonomorphizationReturnElement, InvalidMonomorphizationReturnIntegerType,\n+    InvalidMonomorphizationReturnLength, InvalidMonomorphizationReturnLengthInputType,\n+    InvalidMonomorphizationReturnType, InvalidMonomorphizationSimdShuffle,\n+    InvalidMonomorphizationUnrecognized, InvalidMonomorphizationUnsupportedElement,\n+    InvalidMonomorphizationUnsupportedOperation,\n };\n \n-pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n+pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n+    bx: &mut Builder<'a, 'gcc, 'tcx>,\n+    name: Symbol,\n+    callee_ty: Ty<'tcx>,\n+    args: &[OperandRef<'tcx, RValue<'gcc>>],\n+    ret_ty: Ty<'tcx>,\n+    llret_ty: Type<'gcc>,\n+    span: Span,\n+) -> Result<RValue<'gcc>, ()> {\n     // macros for error handling:\n     macro_rules! return_error {\n-        ($err:expr) => {\n-            {\n-                bx.sess().emit_err($err);\n-                return Err(());\n-            }\n-        }\n+        ($err:expr) => {{\n+            bx.sess().emit_err($err);\n+            return Err(());\n+        }};\n     }\n     macro_rules! require {\n         ($cond:expr, $err:expr) => {\n             if !$cond {\n                 return_error!($err);\n             }\n-        }\n+        };\n     }\n     macro_rules! require_simd {\n         ($ty: expr, $position: expr) => {\n-            require!($ty.is_simd(), InvalidMonomorphizationExpectedSimd { span, name, position: $position, found_ty: $ty })\n+            require!(\n+                $ty.is_simd(),\n+                InvalidMonomorphizationExpectedSimd {\n+                    span,\n+                    name,\n+                    position: $position,\n+                    found_ty: $ty\n+                }\n+            )\n         };\n     }\n \n@@ -77,7 +84,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n             ty::Array(elem, len)\n                 if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n-                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                    && len.try_eval_target_usize(bx.tcx, ty::ParamEnv::reveal_all())\n                         == Some(expected_bytes) =>\n             {\n                 let place = PlaceRef::alloca(bx, args[0].layout);\n@@ -86,9 +93,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 let ptr = bx.pointercast(place.llval, bx.cx.type_ptr_to(int_ty));\n                 bx.load(int_ty, ptr, Align::ONE)\n             }\n-            _ => return_error!(\n-                InvalidMonomorphizationInvalidBitmask { span, name, ty: mask_ty, expected_int_bits, expected_bytes }\n-            ),\n+            _ => return_error!(InvalidMonomorphizationInvalidBitmask {\n+                span,\n+                name,\n+                ty: mask_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            }),\n         };\n \n         let arg1 = args[1].immediate();\n@@ -134,11 +145,18 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n+            InvalidMonomorphizationReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         require!(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n-            InvalidMonomorphizationReturnIntegerType {span, name, ret_ty, out_ty}\n+            InvalidMonomorphizationReturnIntegerType { span, name, ret_ty, out_ty }\n         );\n \n         return Ok(compare_simd_types(\n@@ -152,26 +170,26 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     }\n \n     if let Some(stripped) = name.as_str().strip_prefix(\"simd_shuffle\") {\n-        let n: u64 =\n-            if stripped.is_empty() {\n-                // Make sure this is actually an array, since typeck only checks the length-suffixed\n-                // version of this intrinsic.\n-                match args[2].layout.ty.kind() {\n-                    ty::Array(ty, len) if matches!(ty.kind(), ty::Uint(ty::UintTy::U32)) => {\n-                        len.try_eval_usize(bx.cx.tcx, ty::ParamEnv::reveal_all()).unwrap_or_else(|| {\n-                            span_bug!(span, \"could not evaluate shuffle index array length\")\n-                        })\n-                    }\n-                    _ => return_error!(\n-                        InvalidMonomorphizationSimdShuffle { span, name, ty: args[2].layout.ty }\n-                    ),\n+        let n: u64 = if stripped.is_empty() {\n+            // Make sure this is actually an array, since typeck only checks the length-suffixed\n+            // version of this intrinsic.\n+            match args[2].layout.ty.kind() {\n+                ty::Array(ty, len) if matches!(ty.kind(), ty::Uint(ty::UintTy::U32)) => {\n+                    len.try_eval_target_usize(bx.cx.tcx, ty::ParamEnv::reveal_all()).unwrap_or_else(\n+                        || span_bug!(span, \"could not evaluate shuffle index array length\"),\n+                    )\n                 }\n+                _ => return_error!(InvalidMonomorphizationSimdShuffle {\n+                    span,\n+                    name,\n+                    ty: args[2].layout.ty\n+                }),\n             }\n-            else {\n-                stripped.parse().unwrap_or_else(|_| {\n-                    span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n-                })\n-            };\n+        } else {\n+            stripped.parse().unwrap_or_else(|_| {\n+                span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n+            })\n+        };\n \n         require_simd!(ret_ty, \"return\");\n \n@@ -187,14 +205,10 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n \n         let vector = args[2].immediate();\n \n-        return Ok(bx.shuffle_vector(\n-            args[0].immediate(),\n-            args[1].immediate(),\n-            vector,\n-        ));\n+        return Ok(bx.shuffle_vector(args[0].immediate(), args[1].immediate(), vector));\n     }\n \n-    #[cfg(feature=\"master\")]\n+    #[cfg(feature = \"master\")]\n     if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n@@ -211,7 +225,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         return Ok(variable.to_rvalue());\n     }\n \n-    #[cfg(feature=\"master\")]\n+    #[cfg(feature = \"master\")]\n     if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n@@ -243,7 +257,14 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n+            InvalidMonomorphizationReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         // casting cares about nominal type, not just structural type\n         if in_elem == out_elem {\n@@ -373,12 +394,10 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         args: &[OperandRef<'tcx, RValue<'gcc>>],\n     ) -> Result<RValue<'gcc>, ()> {\n         macro_rules! return_error {\n-            ($err:expr) => {\n-                {\n-                    bx.sess().emit_err($err);\n-                    return Err(());\n-                }\n-            }\n+            ($err:expr) => {{\n+                bx.sess().emit_err($err);\n+                return Err(());\n+            }};\n         }\n         let (elem_ty_str, elem_ty) =\n             if let ty::Float(f) = in_elem.kind() {\n@@ -391,9 +410,9 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     }\n                 }\n             }\n-            else {\n-                return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n-            };\n+        } else {\n+            return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n+        };\n \n         let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n \n@@ -778,7 +797,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         simd_neg: Int => neg, Float => fneg;\n     }\n \n-    #[cfg(feature=\"master\")]\n+    #[cfg(feature = \"master\")]\n     if name == sym::simd_saturating_add || name == sym::simd_saturating_sub {\n         let lhs = args[0].immediate();\n         let rhs = args[1].immediate();\n@@ -898,8 +917,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                             // if overflow occurs, the result is the\n                             // mathematical result modulo 2^n:\n                             Ok(bx.$op(args[1].immediate(), r))\n-                        }\n-                        else {\n+                        } else {\n                             Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n                         }\n                     }\n@@ -908,12 +926,17 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                             // ordered arithmetic reductions take an accumulator\n                             let acc = args[1].immediate();\n                             Ok(bx.$float_reduce(acc, args[0].immediate()))\n-                        }\n-                        else {\n+                        } else {\n                             Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n                         }\n                     }\n-                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n+                        span,\n+                        name,\n+                        in_ty,\n+                        elem_ty: in_elem,\n+                        ret_ty\n+                    }),\n                 };\n             }\n         };\n@@ -983,7 +1006,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 } else {\n                     match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n-                        _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n+                        _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n+                            span,\n+                            name,\n+                            in_ty,\n+                            elem_ty: in_elem,\n+                            ret_ty\n+                        }),\n                     }\n \n                     args[0].immediate()\n@@ -993,9 +1022,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         let r = bx.vector_reduce_op(input, $op);\n                         Ok(if !$boolean { r } else { bx.icmp(IntPredicate::IntNE, r, bx.context.new_rvalue_zero(r.get_type())) })\n                     }\n-                    _ => return_error!(\n-                        InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n+                        span,\n+                        name,\n+                        in_ty,\n+                        elem_ty: in_elem,\n+                        ret_ty\n+                    }),\n                 };\n             }\n         };"}]}