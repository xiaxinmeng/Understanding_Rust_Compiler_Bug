{"sha": "88f840bdea7a90b596ce9496b3c8f84c8567ab0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4Zjg0MGJkZWE3YTkwYjU5NmNlOTQ5NmIzYzhmODRjODU2N2FiMGY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-24T05:20:13Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-29T05:26:22Z"}, "message": "debuginfo: extract adt.rs", "tree": {"sha": "0f753e81e1c518c9816db19aace09f8da15d6f22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f753e81e1c518c9816db19aace09f8da15d6f22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88f840bdea7a90b596ce9496b3c8f84c8567ab0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88f840bdea7a90b596ce9496b3c8f84c8567ab0f", "html_url": "https://github.com/rust-lang/rust/commit/88f840bdea7a90b596ce9496b3c8f84c8567ab0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88f840bdea7a90b596ce9496b3c8f84c8567ab0f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9756349d118c4c5209395e804624786c8fcaeb51", "url": "https://api.github.com/repos/rust-lang/rust/commits/9756349d118c4c5209395e804624786c8fcaeb51", "html_url": "https://github.com/rust-lang/rust/commit/9756349d118c4c5209395e804624786c8fcaeb51"}], "stats": {"total": 1645, "additions": 841, "deletions": 804}, "files": [{"sha": "4dc96e0ee6942d431d09a2963cd9c4da973272ca", "filename": "src/librustc_trans/trans/debuginfo/adt.rs", "status": "added", "additions": 824, "deletions": 0, "changes": 824, "blob_url": "https://github.com/rust-lang/rust/blob/88f840bdea7a90b596ce9496b3c8f84c8567ab0f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f840bdea7a90b596ce9496b3c8f84c8567ab0f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fadt.rs?ref=88f840bdea7a90b596ce9496b3c8f84c8567ab0f", "patch": "@@ -0,0 +1,824 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://!rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://!www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://!opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Common facilities for record-like types (structs, enums, tuples)\n+\n+use self::MemberDescriptionFactory::*;\n+use self::EnumDiscriminantInfo::*;\n+use self::MemberOffset::*;\n+\n+use super::{UNKNOWN_FILE_METADATA, UNKNOWN_SCOPE_METADATA, UNKNOWN_LINE_NUMBER,\n+            UniqueTypeId, FLAGS_NONE, create_and_register_recursive_type_forward_declaration};\n+\n+use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n+                   get_namespace_and_span_for_item};\n+use super::create::create_DIArray;\n+use super::types::compute_debuginfo_type_name;\n+use super::metadata::{type_metadata, file_metadata};\n+\n+use super::RecursiveTypeDescription::{self, FinalMetadata};\n+\n+use llvm;\n+use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n+use metadata::csearch;\n+use middle::subst::{self, Substs};\n+use trans::{adt, machine, type_of};\n+use trans::common::CrateContext;\n+use trans::monomorphize;\n+use trans::type_::Type;\n+use middle::ty::{self, Ty, ClosureTyper};\n+\n+use libc::c_uint;\n+use std::ffi::CString;\n+use std::ptr;\n+use std::rc::Rc;\n+use syntax::codemap::Span;\n+use syntax::{ast, codemap};\n+use syntax::parse::token::{self, special_idents};\n+\n+pub enum MemberOffset {\n+    FixedMemberOffset { bytes: usize },\n+    // For ComputedMemberOffset, the offset is read from the llvm type definition.\n+    ComputedMemberOffset\n+}\n+\n+// Description of a type member, which can either be a regular field (as in\n+// structs or tuples) or an enum variant.\n+pub struct MemberDescription {\n+    pub name: String,\n+    pub llvm_type: Type,\n+    pub type_metadata: DIType,\n+    pub offset: MemberOffset,\n+    pub flags: c_uint\n+}\n+\n+// A factory for MemberDescriptions. It produces a list of member descriptions\n+// for some record-like type. MemberDescriptionFactories are used to defer the\n+// creation of type member descriptions in order to break cycles arising from\n+// recursive type definitions.\n+pub enum MemberDescriptionFactory<'tcx> {\n+    StructMDF(StructMemberDescriptionFactory<'tcx>),\n+    TupleMDF(TupleMemberDescriptionFactory<'tcx>),\n+    EnumMDF(EnumMemberDescriptionFactory<'tcx>),\n+    VariantMDF(VariantMemberDescriptionFactory<'tcx>)\n+}\n+\n+impl<'tcx> MemberDescriptionFactory<'tcx> {\n+    pub fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                          -> Vec<MemberDescription> {\n+        match *self {\n+            StructMDF(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+            TupleMDF(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+            EnumMDF(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+            VariantMDF(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+        }\n+    }\n+}\n+\n+//=-----------------------------------------------------------------------------\n+// Structs\n+//=-----------------------------------------------------------------------------\n+\n+// Creates MemberDescriptions for the fields of a struct\n+struct StructMemberDescriptionFactory<'tcx> {\n+    fields: Vec<ty::field<'tcx>>,\n+    is_simd: bool,\n+    span: Span,\n+}\n+\n+impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n+        if self.fields.is_empty() {\n+            return Vec::new();\n+        }\n+\n+        let field_size = if self.is_simd {\n+            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as usize\n+        } else {\n+            0xdeadbeef\n+        };\n+\n+        self.fields.iter().enumerate().map(|(i, field)| {\n+            let name = if field.name == special_idents::unnamed_field.name {\n+                format!(\"__{}\", i)\n+            } else {\n+                token::get_name(field.name).to_string()\n+            };\n+\n+            let offset = if self.is_simd {\n+                assert!(field_size != 0xdeadbeef);\n+                FixedMemberOffset { bytes: i * field_size }\n+            } else {\n+                ComputedMemberOffset\n+            };\n+\n+            MemberDescription {\n+                name: name,\n+                llvm_type: type_of::type_of(cx, field.mt.ty),\n+                type_metadata: type_metadata(cx, field.mt.ty, self.span),\n+                offset: offset,\n+                flags: FLAGS_NONE,\n+            }\n+        }).collect()\n+    }\n+}\n+\n+\n+pub fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                         struct_type: Ty<'tcx>,\n+                                         def_id: ast::DefId,\n+                                         substs: &subst::Substs<'tcx>,\n+                                         unique_type_id: UniqueTypeId,\n+                                         span: Span)\n+                                         -> RecursiveTypeDescription<'tcx> {\n+    let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n+    let struct_llvm_type = type_of::type_of(cx, struct_type);\n+\n+    let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n+\n+    let struct_metadata_stub = create_struct_stub(cx,\n+                                                  struct_llvm_type,\n+                                                  &struct_name[..],\n+                                                  unique_type_id,\n+                                                  containing_scope);\n+\n+    let mut fields = ty::struct_fields(cx.tcx(), def_id, substs);\n+\n+    // The `Ty` values returned by `ty::struct_fields` can still contain\n+    // `ty_projection` variants, so normalize those away.\n+    for field in &mut fields {\n+        field.mt.ty = monomorphize::normalize_associated_type(cx.tcx(), &field.mt.ty);\n+    }\n+\n+    create_and_register_recursive_type_forward_declaration(\n+        cx,\n+        struct_type,\n+        unique_type_id,\n+        struct_metadata_stub,\n+        struct_llvm_type,\n+        StructMDF(StructMemberDescriptionFactory {\n+            fields: fields,\n+            is_simd: ty::type_is_simd(cx.tcx(), struct_type),\n+            span: span,\n+        })\n+    )\n+}\n+\n+\n+//=-----------------------------------------------------------------------------\n+// Tuples\n+//=-----------------------------------------------------------------------------\n+\n+// Creates MemberDescriptions for the fields of a tuple\n+struct TupleMemberDescriptionFactory<'tcx> {\n+    component_types: Vec<Ty<'tcx>>,\n+    span: Span,\n+}\n+\n+impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n+        self.component_types\n+            .iter()\n+            .enumerate()\n+            .map(|(i, &component_type)| {\n+            MemberDescription {\n+                name: format!(\"__{}\", i),\n+                llvm_type: type_of::type_of(cx, component_type),\n+                type_metadata: type_metadata(cx, component_type, self.span),\n+                offset: ComputedMemberOffset,\n+                flags: FLAGS_NONE,\n+            }\n+        }).collect()\n+    }\n+}\n+\n+pub fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                        tuple_type: Ty<'tcx>,\n+                                        component_types: &[Ty<'tcx>],\n+                                        unique_type_id: UniqueTypeId,\n+                                        span: Span)\n+                                        -> RecursiveTypeDescription<'tcx> {\n+    let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n+    let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n+\n+    create_and_register_recursive_type_forward_declaration(\n+        cx,\n+        tuple_type,\n+        unique_type_id,\n+        create_struct_stub(cx,\n+                           tuple_llvm_type,\n+                           &tuple_name[..],\n+                           unique_type_id,\n+                           UNKNOWN_SCOPE_METADATA),\n+        tuple_llvm_type,\n+        TupleMDF(TupleMemberDescriptionFactory {\n+            component_types: component_types.to_vec(),\n+            span: span,\n+        })\n+    )\n+}\n+\n+\n+//=-----------------------------------------------------------------------------\n+// Enums\n+//=-----------------------------------------------------------------------------\n+\n+// Describes the members of an enum value: An enum is described as a union of\n+// structs in DWARF. This MemberDescriptionFactory provides the description for\n+// the members of this union; so for every variant of the given enum, this\n+// factory will produce one MemberDescription (all with no name and a fixed\n+// offset of zero bytes).\n+struct EnumMemberDescriptionFactory<'tcx> {\n+    enum_type: Ty<'tcx>,\n+    type_rep: Rc<adt::Repr<'tcx>>,\n+    variants: Rc<Vec<Rc<ty::VariantInfo<'tcx>>>>,\n+    discriminant_type_metadata: Option<DIType>,\n+    containing_scope: DIScope,\n+    file_metadata: DIFile,\n+    span: Span,\n+}\n+\n+impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n+        match *self.type_rep {\n+            adt::General(_, ref struct_defs, _) => {\n+                let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n+                    .expect(\"\"));\n+\n+                struct_defs\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, struct_def)| {\n+                        let (variant_type_metadata,\n+                             variant_llvm_type,\n+                             member_desc_factory) =\n+                            describe_enum_variant(cx,\n+                                                  self.enum_type,\n+                                                  struct_def,\n+                                                  &*(*self.variants)[i],\n+                                                  discriminant_info,\n+                                                  self.containing_scope,\n+                                                  self.span);\n+\n+                        let member_descriptions = member_desc_factory\n+                            .create_member_descriptions(cx);\n+\n+                        set_members_of_composite_type(cx,\n+                                                      variant_type_metadata,\n+                                                      variant_llvm_type,\n+                                                      &member_descriptions[..]);\n+                        MemberDescription {\n+                            name: \"\".to_string(),\n+                            llvm_type: variant_llvm_type,\n+                            type_metadata: variant_type_metadata,\n+                            offset: FixedMemberOffset { bytes: 0 },\n+                            flags: FLAGS_NONE\n+                        }\n+                    }).collect()\n+            },\n+            adt::Univariant(ref struct_def, _) => {\n+                assert!(self.variants.len() <= 1);\n+\n+                if self.variants.is_empty() {\n+                    vec![]\n+                } else {\n+                    let (variant_type_metadata,\n+                         variant_llvm_type,\n+                         member_description_factory) =\n+                        describe_enum_variant(cx,\n+                                              self.enum_type,\n+                                              struct_def,\n+                                              &*(*self.variants)[0],\n+                                              NoDiscriminant,\n+                                              self.containing_scope,\n+                                              self.span);\n+\n+                    let member_descriptions =\n+                        member_description_factory.create_member_descriptions(cx);\n+\n+                    set_members_of_composite_type(cx,\n+                                                  variant_type_metadata,\n+                                                  variant_llvm_type,\n+                                                  &member_descriptions[..]);\n+                    vec![\n+                        MemberDescription {\n+                            name: \"\".to_string(),\n+                            llvm_type: variant_llvm_type,\n+                            type_metadata: variant_type_metadata,\n+                            offset: FixedMemberOffset { bytes: 0 },\n+                            flags: FLAGS_NONE\n+                        }\n+                    ]\n+                }\n+            }\n+            adt::RawNullablePointer { nndiscr: non_null_variant_index, nnty, .. } => {\n+                // As far as debuginfo is concerned, the pointer this enum\n+                // represents is still wrapped in a struct. This is to make the\n+                // DWARF representation of enums uniform.\n+\n+                // First create a description of the artificial wrapper struct:\n+                let non_null_variant = &(*self.variants)[non_null_variant_index as usize];\n+                let non_null_variant_name = token::get_name(non_null_variant.name);\n+\n+                // The llvm type and metadata of the pointer\n+                let non_null_llvm_type = type_of::type_of(cx, nnty);\n+                let non_null_type_metadata = type_metadata(cx, nnty, self.span);\n+\n+                // The type of the artificial struct wrapping the pointer\n+                let artificial_struct_llvm_type = Type::struct_(cx,\n+                                                                &[non_null_llvm_type],\n+                                                                false);\n+\n+                // For the metadata of the wrapper struct, we need to create a\n+                // MemberDescription of the struct's single field.\n+                let sole_struct_member_description = MemberDescription {\n+                    name: match non_null_variant.arg_names {\n+                        Some(ref names) => token::get_name(names[0]).to_string(),\n+                        None => \"__0\".to_string()\n+                    },\n+                    llvm_type: non_null_llvm_type,\n+                    type_metadata: non_null_type_metadata,\n+                    offset: FixedMemberOffset { bytes: 0 },\n+                    flags: FLAGS_NONE\n+                };\n+\n+                let unique_type_id = debug_context(cx).type_map\n+                                                      .borrow_mut()\n+                                                      .get_unique_type_id_of_enum_variant(\n+                                                          cx,\n+                                                          self.enum_type,\n+                                                          &non_null_variant_name);\n+\n+                // Now we can create the metadata of the artificial struct\n+                let artificial_struct_metadata =\n+                    composite_type_metadata(cx,\n+                                            artificial_struct_llvm_type,\n+                                            &non_null_variant_name,\n+                                            unique_type_id,\n+                                            &[sole_struct_member_description],\n+                                            self.containing_scope,\n+                                            self.file_metadata,\n+                                            codemap::DUMMY_SP);\n+\n+                // Encode the information about the null variant in the union\n+                // member's name.\n+                let null_variant_index = (1 - non_null_variant_index) as usize;\n+                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n+                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n+                                                0,\n+                                                null_variant_name);\n+\n+                // Finally create the (singleton) list of descriptions of union\n+                // members.\n+                vec![\n+                    MemberDescription {\n+                        name: union_member_name,\n+                        llvm_type: artificial_struct_llvm_type,\n+                        type_metadata: artificial_struct_metadata,\n+                        offset: FixedMemberOffset { bytes: 0 },\n+                        flags: FLAGS_NONE\n+                    }\n+                ]\n+            },\n+            adt::StructWrappedNullablePointer { nonnull: ref struct_def,\n+                                                nndiscr,\n+                                                ref discrfield, ..} => {\n+                // Create a description of the non-null variant\n+                let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n+                    describe_enum_variant(cx,\n+                                          self.enum_type,\n+                                          struct_def,\n+                                          &*(*self.variants)[nndiscr as usize],\n+                                          OptimizedDiscriminant,\n+                                          self.containing_scope,\n+                                          self.span);\n+\n+                let variant_member_descriptions =\n+                    member_description_factory.create_member_descriptions(cx);\n+\n+                set_members_of_composite_type(cx,\n+                                              variant_type_metadata,\n+                                              variant_llvm_type,\n+                                              &variant_member_descriptions[..]);\n+\n+                // Encode the information about the null variant in the union\n+                // member's name.\n+                let null_variant_index = (1 - nndiscr) as usize;\n+                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n+                let discrfield = discrfield.iter()\n+                                           .skip(1)\n+                                           .map(|x| x.to_string())\n+                                           .collect::<Vec<_>>().connect(\"$\");\n+                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n+                                                discrfield,\n+                                                null_variant_name);\n+\n+                // Create the (singleton) list of descriptions of union members.\n+                vec![\n+                    MemberDescription {\n+                        name: union_member_name,\n+                        llvm_type: variant_llvm_type,\n+                        type_metadata: variant_type_metadata,\n+                        offset: FixedMemberOffset { bytes: 0 },\n+                        flags: FLAGS_NONE\n+                    }\n+                ]\n+            },\n+            adt::CEnum(..) => cx.sess().span_bug(self.span, \"This should be unreachable.\")\n+        }\n+    }\n+}\n+\n+// Creates MemberDescriptions for the fields of a single enum variant.\n+struct VariantMemberDescriptionFactory<'tcx> {\n+    args: Vec<(String, Ty<'tcx>)>,\n+    discriminant_type_metadata: Option<DIType>,\n+    span: Span,\n+}\n+\n+impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n+        self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n+            MemberDescription {\n+                name: name.to_string(),\n+                llvm_type: type_of::type_of(cx, ty),\n+                type_metadata: match self.discriminant_type_metadata {\n+                    Some(metadata) if i == 0 => metadata,\n+                    _ => type_metadata(cx, ty, self.span)\n+                },\n+                offset: ComputedMemberOffset,\n+                flags: FLAGS_NONE\n+            }\n+        }).collect()\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum EnumDiscriminantInfo {\n+    RegularDiscriminant(DIType),\n+    OptimizedDiscriminant,\n+    NoDiscriminant\n+}\n+\n+// Returns a tuple of (1) type_metadata_stub of the variant, (2) the llvm_type\n+// of the variant, and (3) a MemberDescriptionFactory for producing the\n+// descriptions of the fields of the variant. This is a rudimentary version of a\n+// full RecursiveTypeDescription.\n+fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                   enum_type: Ty<'tcx>,\n+                                   struct_def: &adt::Struct<'tcx>,\n+                                   variant_info: &ty::VariantInfo<'tcx>,\n+                                   discriminant_info: EnumDiscriminantInfo,\n+                                   containing_scope: DIScope,\n+                                   span: Span)\n+                                   -> (DICompositeType, Type, MemberDescriptionFactory<'tcx>) {\n+    let variant_llvm_type =\n+        Type::struct_(cx, &struct_def.fields\n+                                    .iter()\n+                                    .map(|&t| type_of::type_of(cx, t))\n+                                    .collect::<Vec<_>>()\n+                                    ,\n+                      struct_def.packed);\n+    // Could do some consistency checks here: size, align, field count, discr type\n+\n+    let variant_name = token::get_name(variant_info.name);\n+    let variant_name = &variant_name;\n+    let unique_type_id = debug_context(cx).type_map\n+                                          .borrow_mut()\n+                                          .get_unique_type_id_of_enum_variant(\n+                                              cx,\n+                                              enum_type,\n+                                              variant_name);\n+\n+    let metadata_stub = create_struct_stub(cx,\n+                                           variant_llvm_type,\n+                                           variant_name,\n+                                           unique_type_id,\n+                                           containing_scope);\n+\n+    // Get the argument names from the enum variant info\n+    let mut arg_names: Vec<_> = match variant_info.arg_names {\n+        Some(ref names) => {\n+            names.iter()\n+                 .map(|&name| token::get_name(name).to_string())\n+                 .collect()\n+        }\n+        None => {\n+            variant_info.args\n+                        .iter()\n+                        .enumerate()\n+                        .map(|(i, _)| format!(\"__{}\", i))\n+                        .collect()\n+        }\n+    };\n+\n+    // If this is not a univariant enum, there is also the discriminant field.\n+    match discriminant_info {\n+        RegularDiscriminant(_) => arg_names.insert(0, \"RUST$ENUM$DISR\".to_string()),\n+        _ => { /* do nothing */ }\n+    };\n+\n+    // Build an array of (field name, field type) pairs to be captured in the factory closure.\n+    let args: Vec<(String, Ty)> = arg_names.iter()\n+        .zip(struct_def.fields.iter())\n+        .map(|(s, &t)| (s.to_string(), t))\n+        .collect();\n+\n+    let member_description_factory =\n+        VariantMDF(VariantMemberDescriptionFactory {\n+            args: args,\n+            discriminant_type_metadata: match discriminant_info {\n+                RegularDiscriminant(discriminant_type_metadata) => {\n+                    Some(discriminant_type_metadata)\n+                }\n+                _ => None\n+            },\n+            span: span,\n+        });\n+\n+    (metadata_stub, variant_llvm_type, member_description_factory)\n+}\n+\n+pub fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                       enum_type: Ty<'tcx>,\n+                                       enum_def_id: ast::DefId,\n+                                       unique_type_id: UniqueTypeId,\n+                                       span: Span)\n+                                       -> RecursiveTypeDescription<'tcx> {\n+    let enum_name = compute_debuginfo_type_name(cx, enum_type, false);\n+\n+    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n+    let loc = span_start(cx, definition_span);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n+\n+    let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n+\n+    let enumerators_metadata: Vec<DIDescriptor> = variants\n+        .iter()\n+        .map(|v| {\n+            let token = token::get_name(v.name);\n+            let name = CString::new(token.as_bytes()).unwrap();\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateEnumerator(\n+                    DIB(cx),\n+                    name.as_ptr(),\n+                    v.disr_val as u64)\n+            }\n+        })\n+        .collect();\n+\n+    let discriminant_type_metadata = |inttype| {\n+        // We can reuse the type of the discriminant for all monomorphized\n+        // instances of an enum because it doesn't depend on any type\n+        // parameters. The def_id, uniquely identifying the enum's polytype acts\n+        // as key in this cache.\n+        let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n+                                                                 .borrow()\n+                                                                 .get(&enum_def_id).cloned();\n+        match cached_discriminant_type_metadata {\n+            Some(discriminant_type_metadata) => discriminant_type_metadata,\n+            None => {\n+                let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n+                let (discriminant_size, discriminant_align) =\n+                    size_and_align_of(cx, discriminant_llvm_type);\n+                let discriminant_base_type_metadata =\n+                    type_metadata(cx,\n+                                  adt::ty_of_inttype(cx.tcx(), inttype),\n+                                  codemap::DUMMY_SP);\n+                let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n+\n+                let name = CString::new(discriminant_name.as_bytes()).unwrap();\n+                let discriminant_type_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateEnumerationType(\n+                        DIB(cx),\n+                        containing_scope,\n+                        name.as_ptr(),\n+                        UNKNOWN_FILE_METADATA,\n+                        UNKNOWN_LINE_NUMBER,\n+                        bytes_to_bits(discriminant_size),\n+                        bytes_to_bits(discriminant_align),\n+                        create_DIArray(DIB(cx), &enumerators_metadata),\n+                        discriminant_base_type_metadata)\n+                };\n+\n+                debug_context(cx).created_enum_disr_types\n+                                 .borrow_mut()\n+                                 .insert(enum_def_id, discriminant_type_metadata);\n+\n+                discriminant_type_metadata\n+            }\n+        }\n+    };\n+\n+    let type_rep = adt::represent_type(cx, enum_type);\n+\n+    let discriminant_type_metadata = match *type_rep {\n+        adt::CEnum(inttype, _, _) => {\n+            return FinalMetadata(discriminant_type_metadata(inttype))\n+        },\n+        adt::RawNullablePointer { .. }           |\n+        adt::StructWrappedNullablePointer { .. } |\n+        adt::Univariant(..)                      => None,\n+        adt::General(inttype, _, _) => Some(discriminant_type_metadata(inttype)),\n+    };\n+\n+    let enum_llvm_type = type_of::type_of(cx, enum_type);\n+    let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n+\n+    let unique_type_id_str = debug_context(cx)\n+                             .type_map\n+                             .borrow()\n+                             .get_unique_type_id_as_string(unique_type_id);\n+\n+    let enum_name = CString::new(enum_name).unwrap();\n+    let unique_type_id_str = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let enum_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateUnionType(\n+        DIB(cx),\n+        containing_scope,\n+        enum_name.as_ptr(),\n+        UNKNOWN_FILE_METADATA,\n+        UNKNOWN_LINE_NUMBER,\n+        bytes_to_bits(enum_type_size),\n+        bytes_to_bits(enum_type_align),\n+        0, // Flags\n+        ptr::null_mut(),\n+        0, // RuntimeLang\n+        unique_type_id_str.as_ptr())\n+    };\n+\n+    return create_and_register_recursive_type_forward_declaration(\n+        cx,\n+        enum_type,\n+        unique_type_id,\n+        enum_metadata,\n+        enum_llvm_type,\n+        EnumMDF(EnumMemberDescriptionFactory {\n+            enum_type: enum_type,\n+            type_rep: type_rep.clone(),\n+            variants: variants,\n+            discriminant_type_metadata: discriminant_type_metadata,\n+            containing_scope: containing_scope,\n+            file_metadata: file_metadata,\n+            span: span,\n+        }),\n+    );\n+\n+    fn get_enum_discriminant_name(cx: &CrateContext,\n+                                  def_id: ast::DefId)\n+                                  -> token::InternedString {\n+        let name = if def_id.krate == ast::LOCAL_CRATE {\n+            cx.tcx().map.get_path_elem(def_id.node).name()\n+        } else {\n+            csearch::get_item_path(cx.tcx(), def_id).last().unwrap().name()\n+        };\n+\n+        token::get_name(name)\n+    }\n+}\n+\n+/// Creates debug information for a composite type, that is, anything that\n+/// results in a LLVM struct.\n+///\n+/// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n+pub fn composite_type_metadata(cx: &CrateContext,\n+                               composite_llvm_type: Type,\n+                               composite_type_name: &str,\n+                               composite_type_unique_id: UniqueTypeId,\n+                               member_descriptions: &[MemberDescription],\n+                               containing_scope: DIScope,\n+\n+                               // Ignore source location information as long as it\n+                               // can't be reconstructed for non-local crates.\n+                               _file_metadata: DIFile,\n+                               _definition_span: Span)\n+                               -> DICompositeType {\n+    // Create the (empty) struct metadata node ...\n+    let composite_type_metadata = create_struct_stub(cx,\n+                                                     composite_llvm_type,\n+                                                     composite_type_name,\n+                                                     composite_type_unique_id,\n+                                                     containing_scope);\n+    // ... and immediately create and add the member descriptions.\n+    set_members_of_composite_type(cx,\n+                                  composite_type_metadata,\n+                                  composite_llvm_type,\n+                                  member_descriptions);\n+\n+    return composite_type_metadata;\n+}\n+\n+pub fn set_members_of_composite_type(cx: &CrateContext,\n+                                     composite_type_metadata: DICompositeType,\n+                                     composite_llvm_type: Type,\n+                                     member_descriptions: &[MemberDescription]) {\n+    // In some rare cases LLVM metadata uniquing would lead to an existing type\n+    // description being used instead of a new one created in\n+    // create_struct_stub. This would cause a hard to trace assertion in\n+    // DICompositeType::SetTypeArray(). The following check makes sure that we\n+    // get a better error message if this should happen again due to some\n+    // regression.\n+    {\n+        let mut composite_types_completed =\n+            debug_context(cx).composite_types_completed.borrow_mut();\n+        if composite_types_completed.contains(&composite_type_metadata) {\n+            cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n+                           Already completed forward declaration re-encountered.\");\n+        } else {\n+            composite_types_completed.insert(composite_type_metadata);\n+        }\n+    }\n+\n+    let member_metadata: Vec<DIDescriptor> = member_descriptions\n+        .iter()\n+        .enumerate()\n+        .map(|(i, member_description)| {\n+            let (member_size, member_align) = size_and_align_of(cx, member_description.llvm_type);\n+            let member_offset = match member_description.offset {\n+                FixedMemberOffset { bytes } => bytes as u64,\n+                ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n+            };\n+\n+            let member_name = member_description.name.as_bytes();\n+            let member_name = CString::new(member_name).unwrap();\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    composite_type_metadata,\n+                    member_name.as_ptr(),\n+                    UNKNOWN_FILE_METADATA,\n+                    UNKNOWN_LINE_NUMBER,\n+                    bytes_to_bits(member_size),\n+                    bytes_to_bits(member_align),\n+                    bytes_to_bits(member_offset),\n+                    member_description.flags,\n+                    member_description.type_metadata)\n+            }\n+        })\n+        .collect();\n+\n+    unsafe {\n+        let type_array = create_DIArray(DIB(cx), &member_metadata[..]);\n+        llvm::LLVMDICompositeTypeSetTypeArray(DIB(cx), composite_type_metadata, type_array);\n+    }\n+}\n+\n+// A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any\n+// caching, does not add any fields to the struct. This can be done later with\n+// set_members_of_composite_type().\n+fn create_struct_stub(cx: &CrateContext,\n+                      struct_llvm_type: Type,\n+                      struct_type_name: &str,\n+                      unique_type_id: UniqueTypeId,\n+                      containing_scope: DIScope)\n+                   -> DICompositeType {\n+    let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n+\n+    let unique_type_id_str = debug_context(cx).type_map\n+                                              .borrow()\n+                                              .get_unique_type_id_as_string(unique_type_id);\n+    let name = CString::new(struct_type_name).unwrap();\n+    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let metadata_stub = unsafe {\n+        // LLVMDIBuilderCreateStructType() wants an empty array. A null\n+        // pointer will lead to hard to trace and debug LLVM assertions\n+        // later on in llvm/lib/IR/Value.cpp.\n+        let empty_array = create_DIArray(DIB(cx), &[]);\n+\n+        llvm::LLVMDIBuilderCreateStructType(\n+            DIB(cx),\n+            containing_scope,\n+            name.as_ptr(),\n+            UNKNOWN_FILE_METADATA,\n+            UNKNOWN_LINE_NUMBER,\n+            bytes_to_bits(struct_size),\n+            bytes_to_bits(struct_align),\n+            0,\n+            ptr::null_mut(),\n+            empty_array,\n+            0,\n+            ptr::null_mut(),\n+            unique_type_id.as_ptr())\n+    };\n+\n+    return metadata_stub;\n+}"}, {"sha": "d21002ffa95b6109e2ffc50128e8a8bbe7d516cb", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88f840bdea7a90b596ce9496b3c8f84c8567ab0f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f840bdea7a90b596ce9496b3c8f84c8567ab0f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=88f840bdea7a90b596ce9496b3c8f84c8567ab0f", "patch": "@@ -10,12 +10,13 @@\n \n use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n                   get_namespace_and_span_for_item};\n-use super::{prepare_struct_metadata, prepare_tuple_metadata, prepare_enum_metadata,\n-            composite_type_metadata, UNKNOWN_FILE_METADATA, UNKNOWN_SCOPE_METADATA,\n-            UniqueTypeId, MemberDescription, FLAGS_NONE};\n-use super::MemberOffset::ComputedMemberOffset;\n+use super::{UNKNOWN_FILE_METADATA, UNKNOWN_SCOPE_METADATA,\n+            UniqueTypeId, FLAGS_NONE};\n use super::types::compute_debuginfo_type_name;\n use super::create::create_DIArray;\n+use super::adt::{prepare_struct_metadata, prepare_tuple_metadata, prepare_enum_metadata,\n+                 composite_type_metadata, MemberDescription};\n+use super::adt::MemberOffset::ComputedMemberOffset;\n \n use llvm;\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor};"}, {"sha": "808a6cb01fb9f7c8a45fbd4f2f68d5546e6f0706", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 12, "deletions": 800, "changes": 812, "blob_url": "https://github.com/rust-lang/rust/blob/88f840bdea7a90b596ce9496b3c8f84c8567ab0f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f840bdea7a90b596ce9496b3c8f84c8567ab0f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=88f840bdea7a90b596ce9496b3c8f84c8567ab0f", "patch": "@@ -17,29 +17,27 @@ mod create;\n mod namespace;\n mod types;\n mod metadata;\n+mod adt;\n \n-use self::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n-                  assert_type_for_node_id, get_namespace_and_span_for_item, fn_should_be_ignored,\n+use self::VariableAccess::*;\n+use self::VariableKind::*;\n+use self::InternalDebugLocation::*;\n+use self::RecursiveTypeDescription::*;\n+\n+use self::utils::{debug_context, DIB, span_start,\n+                  assert_type_for_node_id, fn_should_be_ignored,\n                   contains_nodebug_attribute, create_scope_map};\n use self::create::{declare_local, create_DIArray, is_node_local_to_unit};\n use self::namespace::{namespace_for_item, NamespaceTreeNode};\n use self::types::{compute_debuginfo_type_name, push_debuginfo_type_name};\n use self::metadata::{type_metadata, file_metadata, scope_metadata, compile_unit_metadata, MetadataCreationResult};\n-\n-use self::VariableAccess::*;\n-use self::VariableKind::*;\n-use self::MemberOffset::*;\n-use self::MemberDescriptionFactory::*;\n-use self::RecursiveTypeDescription::*;\n-use self::EnumDiscriminantInfo::*;\n-use self::InternalDebugLocation::*;\n+use self::adt::{MemberDescriptionFactory, set_members_of_composite_type};\n \n use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::*;\n-use metadata::csearch;\n use middle::subst::{self, Substs};\n-use trans::{adt, machine, type_of};\n+use trans::machine;\n use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block,\n                     NormalizingClosureTyper};\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n@@ -80,7 +78,7 @@ const FLAGS_NONE: c_uint = 0;\n //=-----------------------------------------------------------------------------\n \n #[derive(Copy, Debug, Hash, Eq, PartialEq, Clone)]\n-struct UniqueTypeId(ast::Name);\n+pub struct UniqueTypeId(ast::Name);\n \n // The TypeMap is where the CrateDebugContext holds the type metadata nodes\n // created so far. The metadata nodes are indexed by UniqueTypeId, and, for\n@@ -1410,63 +1408,12 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-//=-----------------------------------------------------------------------------\n-// Common facilities for record-like types (structs, enums, tuples)\n-//=-----------------------------------------------------------------------------\n-\n-enum MemberOffset {\n-    FixedMemberOffset { bytes: usize },\n-    // For ComputedMemberOffset, the offset is read from the llvm type definition.\n-    ComputedMemberOffset\n-}\n-\n-// Description of a type member, which can either be a regular field (as in\n-// structs or tuples) or an enum variant.\n-struct MemberDescription {\n-    name: String,\n-    llvm_type: Type,\n-    type_metadata: DIType,\n-    offset: MemberOffset,\n-    flags: c_uint\n-}\n-\n-// A factory for MemberDescriptions. It produces a list of member descriptions\n-// for some record-like type. MemberDescriptionFactories are used to defer the\n-// creation of type member descriptions in order to break cycles arising from\n-// recursive type definitions.\n-enum MemberDescriptionFactory<'tcx> {\n-    StructMDF(StructMemberDescriptionFactory<'tcx>),\n-    TupleMDF(TupleMemberDescriptionFactory<'tcx>),\n-    EnumMDF(EnumMemberDescriptionFactory<'tcx>),\n-    VariantMDF(VariantMemberDescriptionFactory<'tcx>)\n-}\n-\n-impl<'tcx> MemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n-        match *self {\n-            StructMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-            TupleMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-            EnumMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-            VariantMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-        }\n-    }\n-}\n-\n // A description of some recursive type. It can either be already finished (as\n // with FinalMetadata) or it is not yet finished, but contains all information\n // needed to generate the missing parts of the description. See the\n // documentation section on Recursive Types at the top of this file for more\n // information.\n-enum RecursiveTypeDescription<'tcx> {\n+pub enum RecursiveTypeDescription<'tcx> {\n     UnfinishedMetadata {\n         unfinished_type: Ty<'tcx>,\n         unique_type_id: UniqueTypeId,\n@@ -1547,741 +1494,6 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n     }\n }\n \n-\n-//=-----------------------------------------------------------------------------\n-// Structs\n-//=-----------------------------------------------------------------------------\n-\n-// Creates MemberDescriptions for the fields of a struct\n-struct StructMemberDescriptionFactory<'tcx> {\n-    fields: Vec<ty::field<'tcx>>,\n-    is_simd: bool,\n-    span: Span,\n-}\n-\n-impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n-        if self.fields.is_empty() {\n-            return Vec::new();\n-        }\n-\n-        let field_size = if self.is_simd {\n-            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as usize\n-        } else {\n-            0xdeadbeef\n-        };\n-\n-        self.fields.iter().enumerate().map(|(i, field)| {\n-            let name = if field.name == special_idents::unnamed_field.name {\n-                format!(\"__{}\", i)\n-            } else {\n-                token::get_name(field.name).to_string()\n-            };\n-\n-            let offset = if self.is_simd {\n-                assert!(field_size != 0xdeadbeef);\n-                FixedMemberOffset { bytes: i * field_size }\n-            } else {\n-                ComputedMemberOffset\n-            };\n-\n-            MemberDescription {\n-                name: name,\n-                llvm_type: type_of::type_of(cx, field.mt.ty),\n-                type_metadata: type_metadata(cx, field.mt.ty, self.span),\n-                offset: offset,\n-                flags: FLAGS_NONE,\n-            }\n-        }).collect()\n-    }\n-}\n-\n-\n-fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                     struct_type: Ty<'tcx>,\n-                                     def_id: ast::DefId,\n-                                     substs: &subst::Substs<'tcx>,\n-                                     unique_type_id: UniqueTypeId,\n-                                     span: Span)\n-                                     -> RecursiveTypeDescription<'tcx> {\n-    let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n-    let struct_llvm_type = type_of::type_of(cx, struct_type);\n-\n-    let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n-\n-    let struct_metadata_stub = create_struct_stub(cx,\n-                                                  struct_llvm_type,\n-                                                  &struct_name[..],\n-                                                  unique_type_id,\n-                                                  containing_scope);\n-\n-    let mut fields = ty::struct_fields(cx.tcx(), def_id, substs);\n-\n-    // The `Ty` values returned by `ty::struct_fields` can still contain\n-    // `ty_projection` variants, so normalize those away.\n-    for field in &mut fields {\n-        field.mt.ty = monomorphize::normalize_associated_type(cx.tcx(), &field.mt.ty);\n-    }\n-\n-    create_and_register_recursive_type_forward_declaration(\n-        cx,\n-        struct_type,\n-        unique_type_id,\n-        struct_metadata_stub,\n-        struct_llvm_type,\n-        StructMDF(StructMemberDescriptionFactory {\n-            fields: fields,\n-            is_simd: ty::type_is_simd(cx.tcx(), struct_type),\n-            span: span,\n-        })\n-    )\n-}\n-\n-\n-//=-----------------------------------------------------------------------------\n-// Tuples\n-//=-----------------------------------------------------------------------------\n-\n-// Creates MemberDescriptions for the fields of a tuple\n-struct TupleMemberDescriptionFactory<'tcx> {\n-    component_types: Vec<Ty<'tcx>>,\n-    span: Span,\n-}\n-\n-impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n-        self.component_types\n-            .iter()\n-            .enumerate()\n-            .map(|(i, &component_type)| {\n-            MemberDescription {\n-                name: format!(\"__{}\", i),\n-                llvm_type: type_of::type_of(cx, component_type),\n-                type_metadata: type_metadata(cx, component_type, self.span),\n-                offset: ComputedMemberOffset,\n-                flags: FLAGS_NONE,\n-            }\n-        }).collect()\n-    }\n-}\n-\n-fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                    tuple_type: Ty<'tcx>,\n-                                    component_types: &[Ty<'tcx>],\n-                                    unique_type_id: UniqueTypeId,\n-                                    span: Span)\n-                                    -> RecursiveTypeDescription<'tcx> {\n-    let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n-    let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n-\n-    create_and_register_recursive_type_forward_declaration(\n-        cx,\n-        tuple_type,\n-        unique_type_id,\n-        create_struct_stub(cx,\n-                           tuple_llvm_type,\n-                           &tuple_name[..],\n-                           unique_type_id,\n-                           UNKNOWN_SCOPE_METADATA),\n-        tuple_llvm_type,\n-        TupleMDF(TupleMemberDescriptionFactory {\n-            component_types: component_types.to_vec(),\n-            span: span,\n-        })\n-    )\n-}\n-\n-\n-//=-----------------------------------------------------------------------------\n-// Enums\n-//=-----------------------------------------------------------------------------\n-\n-// Describes the members of an enum value: An enum is described as a union of\n-// structs in DWARF. This MemberDescriptionFactory provides the description for\n-// the members of this union; so for every variant of the given enum, this\n-// factory will produce one MemberDescription (all with no name and a fixed\n-// offset of zero bytes).\n-struct EnumMemberDescriptionFactory<'tcx> {\n-    enum_type: Ty<'tcx>,\n-    type_rep: Rc<adt::Repr<'tcx>>,\n-    variants: Rc<Vec<Rc<ty::VariantInfo<'tcx>>>>,\n-    discriminant_type_metadata: Option<DIType>,\n-    containing_scope: DIScope,\n-    file_metadata: DIFile,\n-    span: Span,\n-}\n-\n-impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n-        match *self.type_rep {\n-            adt::General(_, ref struct_defs, _) => {\n-                let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n-                    .expect(\"\"));\n-\n-                struct_defs\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, struct_def)| {\n-                        let (variant_type_metadata,\n-                             variant_llvm_type,\n-                             member_desc_factory) =\n-                            describe_enum_variant(cx,\n-                                                  self.enum_type,\n-                                                  struct_def,\n-                                                  &*(*self.variants)[i],\n-                                                  discriminant_info,\n-                                                  self.containing_scope,\n-                                                  self.span);\n-\n-                        let member_descriptions = member_desc_factory\n-                            .create_member_descriptions(cx);\n-\n-                        set_members_of_composite_type(cx,\n-                                                      variant_type_metadata,\n-                                                      variant_llvm_type,\n-                                                      &member_descriptions[..]);\n-                        MemberDescription {\n-                            name: \"\".to_string(),\n-                            llvm_type: variant_llvm_type,\n-                            type_metadata: variant_type_metadata,\n-                            offset: FixedMemberOffset { bytes: 0 },\n-                            flags: FLAGS_NONE\n-                        }\n-                    }).collect()\n-            },\n-            adt::Univariant(ref struct_def, _) => {\n-                assert!(self.variants.len() <= 1);\n-\n-                if self.variants.is_empty() {\n-                    vec![]\n-                } else {\n-                    let (variant_type_metadata,\n-                         variant_llvm_type,\n-                         member_description_factory) =\n-                        describe_enum_variant(cx,\n-                                              self.enum_type,\n-                                              struct_def,\n-                                              &*(*self.variants)[0],\n-                                              NoDiscriminant,\n-                                              self.containing_scope,\n-                                              self.span);\n-\n-                    let member_descriptions =\n-                        member_description_factory.create_member_descriptions(cx);\n-\n-                    set_members_of_composite_type(cx,\n-                                                  variant_type_metadata,\n-                                                  variant_llvm_type,\n-                                                  &member_descriptions[..]);\n-                    vec![\n-                        MemberDescription {\n-                            name: \"\".to_string(),\n-                            llvm_type: variant_llvm_type,\n-                            type_metadata: variant_type_metadata,\n-                            offset: FixedMemberOffset { bytes: 0 },\n-                            flags: FLAGS_NONE\n-                        }\n-                    ]\n-                }\n-            }\n-            adt::RawNullablePointer { nndiscr: non_null_variant_index, nnty, .. } => {\n-                // As far as debuginfo is concerned, the pointer this enum\n-                // represents is still wrapped in a struct. This is to make the\n-                // DWARF representation of enums uniform.\n-\n-                // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &(*self.variants)[non_null_variant_index as usize];\n-                let non_null_variant_name = token::get_name(non_null_variant.name);\n-\n-                // The llvm type and metadata of the pointer\n-                let non_null_llvm_type = type_of::type_of(cx, nnty);\n-                let non_null_type_metadata = type_metadata(cx, nnty, self.span);\n-\n-                // The type of the artificial struct wrapping the pointer\n-                let artificial_struct_llvm_type = Type::struct_(cx,\n-                                                                &[non_null_llvm_type],\n-                                                                false);\n-\n-                // For the metadata of the wrapper struct, we need to create a\n-                // MemberDescription of the struct's single field.\n-                let sole_struct_member_description = MemberDescription {\n-                    name: match non_null_variant.arg_names {\n-                        Some(ref names) => token::get_name(names[0]).to_string(),\n-                        None => \"__0\".to_string()\n-                    },\n-                    llvm_type: non_null_llvm_type,\n-                    type_metadata: non_null_type_metadata,\n-                    offset: FixedMemberOffset { bytes: 0 },\n-                    flags: FLAGS_NONE\n-                };\n-\n-                let unique_type_id = debug_context(cx).type_map\n-                                                      .borrow_mut()\n-                                                      .get_unique_type_id_of_enum_variant(\n-                                                          cx,\n-                                                          self.enum_type,\n-                                                          &non_null_variant_name);\n-\n-                // Now we can create the metadata of the artificial struct\n-                let artificial_struct_metadata =\n-                    composite_type_metadata(cx,\n-                                            artificial_struct_llvm_type,\n-                                            &non_null_variant_name,\n-                                            unique_type_id,\n-                                            &[sole_struct_member_description],\n-                                            self.containing_scope,\n-                                            self.file_metadata,\n-                                            codemap::DUMMY_SP);\n-\n-                // Encode the information about the null variant in the union\n-                // member's name.\n-                let null_variant_index = (1 - non_null_variant_index) as usize;\n-                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n-                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                0,\n-                                                null_variant_name);\n-\n-                // Finally create the (singleton) list of descriptions of union\n-                // members.\n-                vec![\n-                    MemberDescription {\n-                        name: union_member_name,\n-                        llvm_type: artificial_struct_llvm_type,\n-                        type_metadata: artificial_struct_metadata,\n-                        offset: FixedMemberOffset { bytes: 0 },\n-                        flags: FLAGS_NONE\n-                    }\n-                ]\n-            },\n-            adt::StructWrappedNullablePointer { nonnull: ref struct_def,\n-                                                nndiscr,\n-                                                ref discrfield, ..} => {\n-                // Create a description of the non-null variant\n-                let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n-                    describe_enum_variant(cx,\n-                                          self.enum_type,\n-                                          struct_def,\n-                                          &*(*self.variants)[nndiscr as usize],\n-                                          OptimizedDiscriminant,\n-                                          self.containing_scope,\n-                                          self.span);\n-\n-                let variant_member_descriptions =\n-                    member_description_factory.create_member_descriptions(cx);\n-\n-                set_members_of_composite_type(cx,\n-                                              variant_type_metadata,\n-                                              variant_llvm_type,\n-                                              &variant_member_descriptions[..]);\n-\n-                // Encode the information about the null variant in the union\n-                // member's name.\n-                let null_variant_index = (1 - nndiscr) as usize;\n-                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n-                let discrfield = discrfield.iter()\n-                                           .skip(1)\n-                                           .map(|x| x.to_string())\n-                                           .collect::<Vec<_>>().connect(\"$\");\n-                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                discrfield,\n-                                                null_variant_name);\n-\n-                // Create the (singleton) list of descriptions of union members.\n-                vec![\n-                    MemberDescription {\n-                        name: union_member_name,\n-                        llvm_type: variant_llvm_type,\n-                        type_metadata: variant_type_metadata,\n-                        offset: FixedMemberOffset { bytes: 0 },\n-                        flags: FLAGS_NONE\n-                    }\n-                ]\n-            },\n-            adt::CEnum(..) => cx.sess().span_bug(self.span, \"This should be unreachable.\")\n-        }\n-    }\n-}\n-\n-// Creates MemberDescriptions for the fields of a single enum variant.\n-struct VariantMemberDescriptionFactory<'tcx> {\n-    args: Vec<(String, Ty<'tcx>)>,\n-    discriminant_type_metadata: Option<DIType>,\n-    span: Span,\n-}\n-\n-impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n-        self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n-            MemberDescription {\n-                name: name.to_string(),\n-                llvm_type: type_of::type_of(cx, ty),\n-                type_metadata: match self.discriminant_type_metadata {\n-                    Some(metadata) if i == 0 => metadata,\n-                    _ => type_metadata(cx, ty, self.span)\n-                },\n-                offset: ComputedMemberOffset,\n-                flags: FLAGS_NONE\n-            }\n-        }).collect()\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-enum EnumDiscriminantInfo {\n-    RegularDiscriminant(DIType),\n-    OptimizedDiscriminant,\n-    NoDiscriminant\n-}\n-\n-// Returns a tuple of (1) type_metadata_stub of the variant, (2) the llvm_type\n-// of the variant, and (3) a MemberDescriptionFactory for producing the\n-// descriptions of the fields of the variant. This is a rudimentary version of a\n-// full RecursiveTypeDescription.\n-fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                   enum_type: Ty<'tcx>,\n-                                   struct_def: &adt::Struct<'tcx>,\n-                                   variant_info: &ty::VariantInfo<'tcx>,\n-                                   discriminant_info: EnumDiscriminantInfo,\n-                                   containing_scope: DIScope,\n-                                   span: Span)\n-                                   -> (DICompositeType, Type, MemberDescriptionFactory<'tcx>) {\n-    let variant_llvm_type =\n-        Type::struct_(cx, &struct_def.fields\n-                                    .iter()\n-                                    .map(|&t| type_of::type_of(cx, t))\n-                                    .collect::<Vec<_>>()\n-                                    ,\n-                      struct_def.packed);\n-    // Could do some consistency checks here: size, align, field count, discr type\n-\n-    let variant_name = token::get_name(variant_info.name);\n-    let variant_name = &variant_name;\n-    let unique_type_id = debug_context(cx).type_map\n-                                          .borrow_mut()\n-                                          .get_unique_type_id_of_enum_variant(\n-                                              cx,\n-                                              enum_type,\n-                                              variant_name);\n-\n-    let metadata_stub = create_struct_stub(cx,\n-                                           variant_llvm_type,\n-                                           variant_name,\n-                                           unique_type_id,\n-                                           containing_scope);\n-\n-    // Get the argument names from the enum variant info\n-    let mut arg_names: Vec<_> = match variant_info.arg_names {\n-        Some(ref names) => {\n-            names.iter()\n-                 .map(|&name| token::get_name(name).to_string())\n-                 .collect()\n-        }\n-        None => {\n-            variant_info.args\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(i, _)| format!(\"__{}\", i))\n-                        .collect()\n-        }\n-    };\n-\n-    // If this is not a univariant enum, there is also the discriminant field.\n-    match discriminant_info {\n-        RegularDiscriminant(_) => arg_names.insert(0, \"RUST$ENUM$DISR\".to_string()),\n-        _ => { /* do nothing */ }\n-    };\n-\n-    // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args: Vec<(String, Ty)> = arg_names.iter()\n-        .zip(struct_def.fields.iter())\n-        .map(|(s, &t)| (s.to_string(), t))\n-        .collect();\n-\n-    let member_description_factory =\n-        VariantMDF(VariantMemberDescriptionFactory {\n-            args: args,\n-            discriminant_type_metadata: match discriminant_info {\n-                RegularDiscriminant(discriminant_type_metadata) => {\n-                    Some(discriminant_type_metadata)\n-                }\n-                _ => None\n-            },\n-            span: span,\n-        });\n-\n-    (metadata_stub, variant_llvm_type, member_description_factory)\n-}\n-\n-fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                   enum_type: Ty<'tcx>,\n-                                   enum_def_id: ast::DefId,\n-                                   unique_type_id: UniqueTypeId,\n-                                   span: Span)\n-                                   -> RecursiveTypeDescription<'tcx> {\n-    let enum_name = compute_debuginfo_type_name(cx, enum_type, false);\n-\n-    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n-    let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, &loc.file.name);\n-\n-    let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n-\n-    let enumerators_metadata: Vec<DIDescriptor> = variants\n-        .iter()\n-        .map(|v| {\n-            let token = token::get_name(v.name);\n-            let name = CString::new(token.as_bytes()).unwrap();\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateEnumerator(\n-                    DIB(cx),\n-                    name.as_ptr(),\n-                    v.disr_val as u64)\n-            }\n-        })\n-        .collect();\n-\n-    let discriminant_type_metadata = |inttype| {\n-        // We can reuse the type of the discriminant for all monomorphized\n-        // instances of an enum because it doesn't depend on any type\n-        // parameters. The def_id, uniquely identifying the enum's polytype acts\n-        // as key in this cache.\n-        let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n-                                                                 .borrow()\n-                                                                 .get(&enum_def_id).cloned();\n-        match cached_discriminant_type_metadata {\n-            Some(discriminant_type_metadata) => discriminant_type_metadata,\n-            None => {\n-                let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n-                let (discriminant_size, discriminant_align) =\n-                    size_and_align_of(cx, discriminant_llvm_type);\n-                let discriminant_base_type_metadata =\n-                    type_metadata(cx,\n-                                  adt::ty_of_inttype(cx.tcx(), inttype),\n-                                  codemap::DUMMY_SP);\n-                let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n-\n-                let name = CString::new(discriminant_name.as_bytes()).unwrap();\n-                let discriminant_type_metadata = unsafe {\n-                    llvm::LLVMDIBuilderCreateEnumerationType(\n-                        DIB(cx),\n-                        containing_scope,\n-                        name.as_ptr(),\n-                        UNKNOWN_FILE_METADATA,\n-                        UNKNOWN_LINE_NUMBER,\n-                        bytes_to_bits(discriminant_size),\n-                        bytes_to_bits(discriminant_align),\n-                        create_DIArray(DIB(cx), &enumerators_metadata),\n-                        discriminant_base_type_metadata)\n-                };\n-\n-                debug_context(cx).created_enum_disr_types\n-                                 .borrow_mut()\n-                                 .insert(enum_def_id, discriminant_type_metadata);\n-\n-                discriminant_type_metadata\n-            }\n-        }\n-    };\n-\n-    let type_rep = adt::represent_type(cx, enum_type);\n-\n-    let discriminant_type_metadata = match *type_rep {\n-        adt::CEnum(inttype, _, _) => {\n-            return FinalMetadata(discriminant_type_metadata(inttype))\n-        },\n-        adt::RawNullablePointer { .. }           |\n-        adt::StructWrappedNullablePointer { .. } |\n-        adt::Univariant(..)                      => None,\n-        adt::General(inttype, _, _) => Some(discriminant_type_metadata(inttype)),\n-    };\n-\n-    let enum_llvm_type = type_of::type_of(cx, enum_type);\n-    let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n-\n-    let unique_type_id_str = debug_context(cx)\n-                             .type_map\n-                             .borrow()\n-                             .get_unique_type_id_as_string(unique_type_id);\n-\n-    let enum_name = CString::new(enum_name).unwrap();\n-    let unique_type_id_str = CString::new(unique_type_id_str.as_bytes()).unwrap();\n-    let enum_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateUnionType(\n-        DIB(cx),\n-        containing_scope,\n-        enum_name.as_ptr(),\n-        UNKNOWN_FILE_METADATA,\n-        UNKNOWN_LINE_NUMBER,\n-        bytes_to_bits(enum_type_size),\n-        bytes_to_bits(enum_type_align),\n-        0, // Flags\n-        ptr::null_mut(),\n-        0, // RuntimeLang\n-        unique_type_id_str.as_ptr())\n-    };\n-\n-    return create_and_register_recursive_type_forward_declaration(\n-        cx,\n-        enum_type,\n-        unique_type_id,\n-        enum_metadata,\n-        enum_llvm_type,\n-        EnumMDF(EnumMemberDescriptionFactory {\n-            enum_type: enum_type,\n-            type_rep: type_rep.clone(),\n-            variants: variants,\n-            discriminant_type_metadata: discriminant_type_metadata,\n-            containing_scope: containing_scope,\n-            file_metadata: file_metadata,\n-            span: span,\n-        }),\n-    );\n-\n-    fn get_enum_discriminant_name(cx: &CrateContext,\n-                                  def_id: ast::DefId)\n-                                  -> token::InternedString {\n-        let name = if def_id.krate == ast::LOCAL_CRATE {\n-            cx.tcx().map.get_path_elem(def_id.node).name()\n-        } else {\n-            csearch::get_item_path(cx.tcx(), def_id).last().unwrap().name()\n-        };\n-\n-        token::get_name(name)\n-    }\n-}\n-\n-/// Creates debug information for a composite type, that is, anything that\n-/// results in a LLVM struct.\n-///\n-/// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn composite_type_metadata(cx: &CrateContext,\n-                           composite_llvm_type: Type,\n-                           composite_type_name: &str,\n-                           composite_type_unique_id: UniqueTypeId,\n-                           member_descriptions: &[MemberDescription],\n-                           containing_scope: DIScope,\n-\n-                           // Ignore source location information as long as it\n-                           // can't be reconstructed for non-local crates.\n-                           _file_metadata: DIFile,\n-                           _definition_span: Span)\n-                        -> DICompositeType {\n-    // Create the (empty) struct metadata node ...\n-    let composite_type_metadata = create_struct_stub(cx,\n-                                                     composite_llvm_type,\n-                                                     composite_type_name,\n-                                                     composite_type_unique_id,\n-                                                     containing_scope);\n-    // ... and immediately create and add the member descriptions.\n-    set_members_of_composite_type(cx,\n-                                  composite_type_metadata,\n-                                  composite_llvm_type,\n-                                  member_descriptions);\n-\n-    return composite_type_metadata;\n-}\n-\n-fn set_members_of_composite_type(cx: &CrateContext,\n-                                 composite_type_metadata: DICompositeType,\n-                                 composite_llvm_type: Type,\n-                                 member_descriptions: &[MemberDescription]) {\n-    // In some rare cases LLVM metadata uniquing would lead to an existing type\n-    // description being used instead of a new one created in\n-    // create_struct_stub. This would cause a hard to trace assertion in\n-    // DICompositeType::SetTypeArray(). The following check makes sure that we\n-    // get a better error message if this should happen again due to some\n-    // regression.\n-    {\n-        let mut composite_types_completed =\n-            debug_context(cx).composite_types_completed.borrow_mut();\n-        if composite_types_completed.contains(&composite_type_metadata) {\n-            cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n-                           Already completed forward declaration re-encountered.\");\n-        } else {\n-            composite_types_completed.insert(composite_type_metadata);\n-        }\n-    }\n-\n-    let member_metadata: Vec<DIDescriptor> = member_descriptions\n-        .iter()\n-        .enumerate()\n-        .map(|(i, member_description)| {\n-            let (member_size, member_align) = size_and_align_of(cx, member_description.llvm_type);\n-            let member_offset = match member_description.offset {\n-                FixedMemberOffset { bytes } => bytes as u64,\n-                ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n-            };\n-\n-            let member_name = member_description.name.as_bytes();\n-            let member_name = CString::new(member_name).unwrap();\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateMemberType(\n-                    DIB(cx),\n-                    composite_type_metadata,\n-                    member_name.as_ptr(),\n-                    UNKNOWN_FILE_METADATA,\n-                    UNKNOWN_LINE_NUMBER,\n-                    bytes_to_bits(member_size),\n-                    bytes_to_bits(member_align),\n-                    bytes_to_bits(member_offset),\n-                    member_description.flags,\n-                    member_description.type_metadata)\n-            }\n-        })\n-        .collect();\n-\n-    unsafe {\n-        let type_array = create_DIArray(DIB(cx), &member_metadata[..]);\n-        llvm::LLVMDICompositeTypeSetTypeArray(DIB(cx), composite_type_metadata, type_array);\n-    }\n-}\n-\n-// A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any\n-// caching, does not add any fields to the struct. This can be done later with\n-// set_members_of_composite_type().\n-fn create_struct_stub(cx: &CrateContext,\n-                      struct_llvm_type: Type,\n-                      struct_type_name: &str,\n-                      unique_type_id: UniqueTypeId,\n-                      containing_scope: DIScope)\n-                   -> DICompositeType {\n-    let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n-\n-    let unique_type_id_str = debug_context(cx).type_map\n-                                              .borrow()\n-                                              .get_unique_type_id_as_string(unique_type_id);\n-    let name = CString::new(struct_type_name).unwrap();\n-    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n-    let metadata_stub = unsafe {\n-        // LLVMDIBuilderCreateStructType() wants an empty array. A null\n-        // pointer will lead to hard to trace and debug LLVM assertions\n-        // later on in llvm/lib/IR/Value.cpp.\n-        let empty_array = create_DIArray(DIB(cx), &[]);\n-\n-        llvm::LLVMDIBuilderCreateStructType(\n-            DIB(cx),\n-            containing_scope,\n-            name.as_ptr(),\n-            UNKNOWN_FILE_METADATA,\n-            UNKNOWN_LINE_NUMBER,\n-            bytes_to_bits(struct_size),\n-            bytes_to_bits(struct_align),\n-            0,\n-            ptr::null_mut(),\n-            empty_array,\n-            0,\n-            ptr::null_mut(),\n-            unique_type_id.as_ptr())\n-    };\n-\n-    return metadata_stub;\n-}\n-\n-\n #[derive(Copy, Clone, PartialEq)]\n enum InternalDebugLocation {\n     KnownLocation { scope: DIScope, line: usize, col: usize },"}]}