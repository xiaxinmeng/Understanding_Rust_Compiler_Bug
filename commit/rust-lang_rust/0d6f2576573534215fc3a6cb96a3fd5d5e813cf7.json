{"sha": "0d6f2576573534215fc3a6cb96a3fd5d5e813cf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNmYyNTc2NTczNTM0MjE1ZmMzYTZjYjk2YTNmZDVkNWU4MTNjZjc=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2014-07-23T15:39:13Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2014-07-23T15:39:13Z"}, "message": "Improve usage of lifetime intrinsics in match expressions\n\nThe allocas used in match expression currently don't get good lifetime\nmarkers, in fact they only get lifetime start markers, because their\nlifetimes don't match to cleanup scopes.\n\nWhile the bindings themselves are bog standard and just need a matching\npair of start and end markers, they might need them twice, once for a\nguard clause and once for the match body.\n\nThe __llmatch alloca OTOH needs a single lifetime start marker, but\nwhen there's a guard clause, it needs two end markers, because its\nlifetime ends either when the guard doesn't match or after the match\nbody.\n\nWith these intrinsics in place, LLVM can now, for example, optimize\ncode like this:\n\n````rust\nenum E {\n  A1(int),\n  A2(int),\n  A3(int),\n  A4(int),\n}\n\npub fn variants(x: E) {\n  match x {\n    A1(m) => bar(&m),\n    A2(m) => bar(&m),\n    A3(m) => bar(&m),\n    A4(m) => bar(&m),\n  }\n}\n````\n\nTo a single call to bar, using only a single stack slot. It still fails\nto eliminate some of checks.\n\n````gas\n.Ltmp5:\n\t.cfi_def_cfa_offset 16\n\tmovb\t(%rdi), %al\n\ttestb\t%al, %al\n\tje\t.LBB3_5\n\tmovzbl\t%al, %eax\n\tcmpl\t$1, %eax\n\tje\t.LBB3_5\n\tcmpl\t$2, %eax\n.LBB3_5:\n\tmovq\t8(%rdi), %rax\n\tmovq\t%rax, (%rsp)\n\tleaq\t(%rsp), %rdi\n\tcallq\t_ZN3bar20hcb7a0d8be8e17e37daaE@PLT\n\tpopq\t%rax\n\tretq\n````", "tree": {"sha": "a0ff995eb0f418fb8dde2ee308d05ead077a6fcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0ff995eb0f418fb8dde2ee308d05ead077a6fcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d6f2576573534215fc3a6cb96a3fd5d5e813cf7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d6f2576573534215fc3a6cb96a3fd5d5e813cf7", "html_url": "https://github.com/rust-lang/rust/commit/0d6f2576573534215fc3a6cb96a3fd5d5e813cf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d6f2576573534215fc3a6cb96a3fd5d5e813cf7/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b10dcbe53ae68ba97314b5c68eddbb4ea403d59f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b10dcbe53ae68ba97314b5c68eddbb4ea403d59f", "html_url": "https://github.com/rust-lang/rust/commit/b10dcbe53ae68ba97314b5c68eddbb4ea403d59f"}], "stats": {"total": 60, "additions": 44, "deletions": 16}, "files": [{"sha": "419fcffba3686f224612d60e1fc7f0eb2a86ad22", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0d6f2576573534215fc3a6cb96a3fd5d5e813cf7/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d6f2576573534215fc3a6cb96a3fd5d5e813cf7/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0d6f2576573534215fc3a6cb96a3fd5d5e813cf7", "patch": "@@ -892,7 +892,12 @@ fn insert_lllocals<'a>(mut bcx: &'a Block<'a>, bindings_map: &BindingsMap,\n             TrByCopy(llbinding) => {\n                 let llval = Load(bcx, binding_info.llmatch);\n                 let datum = Datum::new(llval, binding_info.ty, Lvalue);\n+                call_lifetime_start(bcx, llbinding);\n                 bcx = datum.store_to(bcx, llbinding);\n+                match cs {\n+                    Some(cs) => bcx.fcx.schedule_lifetime_end(cs, llbinding),\n+                    _ => {}\n+                }\n \n                 llbinding\n             },\n@@ -906,7 +911,10 @@ fn insert_lllocals<'a>(mut bcx: &'a Block<'a>, bindings_map: &BindingsMap,\n \n         let datum = Datum::new(llval, binding_info.ty, Lvalue);\n         match cs {\n-            Some(cs) => bcx.fcx.schedule_drop_and_zero_mem(cs, llval, binding_info.ty),\n+            Some(cs) => {\n+                bcx.fcx.schedule_drop_and_zero_mem(cs, llval, binding_info.ty);\n+                bcx.fcx.schedule_lifetime_end(cs, binding_info.llmatch);\n+            }\n             _ => {}\n         }\n \n@@ -945,9 +953,17 @@ fn compile_guard<'a, 'b>(\n     let val = unpack_datum!(bcx, expr::trans(bcx, guard_expr));\n     let val = val.to_llbool(bcx);\n \n+    for (_, &binding_info) in data.bindings_map.iter() {\n+        match binding_info.trmode {\n+            TrByCopy(llbinding) => call_lifetime_end(bcx, llbinding),\n+            _ => {}\n+        }\n+    }\n+\n     return with_cond(bcx, Not(bcx, val), |bcx| {\n         // Guard does not match: remove all bindings from the lllocals table\n         for (_, &binding_info) in data.bindings_map.iter() {\n+            call_lifetime_end(bcx, binding_info.llmatch);\n             bcx.fcx.lllocals.borrow_mut().remove(&binding_info.id);\n         }\n         match chk {\n@@ -988,6 +1004,7 @@ fn compile_submatch<'a, 'b>(\n         let data = &m[0].data;\n         for &(ref ident, ref value_ptr) in m[0].bound_ptrs.iter() {\n             let llmatch = data.bindings_map.get(ident).llmatch;\n+            call_lifetime_start(bcx, llmatch);\n             Store(bcx, *value_ptr, llmatch);\n         }\n         match data.arm.guard {\n@@ -1294,24 +1311,24 @@ fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n         match bm {\n             ast::BindByValue(_)\n                 if !ty::type_moves_by_default(tcx, variable_ty) => {\n-                llmatch = alloca(bcx,\n+                llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n                                  \"__llmatch\");\n-                trmode = TrByCopy(alloca(bcx,\n+                trmode = TrByCopy(alloca_no_lifetime(bcx,\n                                          llvariable_ty,\n                                          bcx.ident(ident).as_slice()));\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n-                llmatch = alloca(bcx,\n+                llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n                                  bcx.ident(ident).as_slice());\n                 trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n-                llmatch = alloca(bcx,\n+                llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty,\n                                  bcx.ident(ident).as_slice());\n                 trmode = TrByRef;"}, {"sha": "68d8ab3f04c6f9791bb2267edef632c5022aad50", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d6f2576573534215fc3a6cb96a3fd5d5e813cf7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d6f2576573534215fc3a6cb96a3fd5d5e813cf7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0d6f2576573534215fc3a6cb96a3fd5d5e813cf7", "patch": "@@ -1169,25 +1169,32 @@ pub fn alloc_ty(bcx: &Block, t: ty::t, name: &str) -> ValueRef {\n }\n \n pub fn alloca(cx: &Block, ty: Type, name: &str) -> ValueRef {\n-    alloca_maybe_zeroed(cx, ty, name, false)\n+    let p = alloca_no_lifetime(cx, ty, name);\n+    call_lifetime_start(cx, p);\n+    p\n }\n \n-pub fn alloca_maybe_zeroed(cx: &Block, ty: Type, name: &str, zero: bool) -> ValueRef {\n+pub fn alloca_no_lifetime(cx: &Block, ty: Type, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloca\");\n     if cx.unreachable.get() {\n         unsafe {\n             return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n         }\n     }\n     debuginfo::clear_source_location(cx.fcx);\n-    let p = Alloca(cx, ty, name);\n-    if zero {\n-        let b = cx.fcx.ccx.builder();\n-        b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n-        memzero(&b, p, ty);\n-    } else {\n-        call_lifetime_start(cx, p);\n+    Alloca(cx, ty, name)\n+}\n+\n+pub fn alloca_zeroed(cx: &Block, ty: Type, name: &str) -> ValueRef {\n+    if cx.unreachable.get() {\n+        unsafe {\n+            return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n+        }\n     }\n+    let p = alloca_no_lifetime(cx, ty, name);\n+    let b = cx.fcx.ccx.builder();\n+    b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n+    memzero(&b, p, ty);\n     p\n }\n "}, {"sha": "f69a8af9c08d33acfe0d7258bb64f9e8965a9934", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d6f2576573534215fc3a6cb96a3fd5d5e813cf7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d6f2576573534215fc3a6cb96a3fd5d5e813cf7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=0d6f2576573534215fc3a6cb96a3fd5d5e813cf7", "patch": "@@ -120,7 +120,11 @@ pub fn lvalue_scratch_datum<'a, A>(bcx: &'a Block<'a>,\n      */\n \n     let llty = type_of::type_of(bcx.ccx(), ty);\n-    let scratch = alloca_maybe_zeroed(bcx, llty, name, zero);\n+    let scratch = if zero {\n+        alloca_zeroed(bcx, llty, name)\n+    } else {\n+        alloca(bcx, llty, name)\n+    };\n \n     // Subtle. Populate the scratch memory *before* scheduling cleanup.\n     let bcx = populate(arg, bcx, scratch);\n@@ -145,7 +149,7 @@ pub fn rvalue_scratch_datum(bcx: &Block,\n      */\n \n     let llty = type_of::type_of(bcx.ccx(), ty);\n-    let scratch = alloca_maybe_zeroed(bcx, llty, name, false);\n+    let scratch = alloca(bcx, llty, name);\n     Datum::new(scratch, ty, Rvalue::new(ByRef))\n }\n "}]}