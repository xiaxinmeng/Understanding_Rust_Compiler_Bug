{"sha": "7cff3c74b8d313154379ab73f18baab57c09bd33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZmYzYzc0YjhkMzEzMTU0Mzc5YWI3M2YxOGJhYWI1N2MwOWJkMzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-01T16:36:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-01T16:36:25Z"}, "message": "auto merge of #10119 : Kimundi/rust/option_and_generic, r=alexcrichton\n\nThis takes the last reforms on the `Option` type and applies them to `Result` too. For that, I reordered and grouped the functions in both modules, and also did some refactorings:\r\n\r\n- Added `as_ref` and `as_mut` adapters to `Result`.\r\n- Renamed `Result::map_move` to `Result::map` (same for `_err` variant), deleted other map functions. \r\n- Made the `.expect()` methods be generic over anything you can\r\n  fail with.\r\n- Updated some doc comments to the line doc comment style\r\n- Cleaned up and extended standard trait implementations on `Option` and `Result`\r\n- Removed legacy implementations in the `option` and `result` module", "tree": {"sha": "bc38736b22804cf3f66ad2f80d2241e276b6003c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc38736b22804cf3f66ad2f80d2241e276b6003c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cff3c74b8d313154379ab73f18baab57c09bd33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cff3c74b8d313154379ab73f18baab57c09bd33", "html_url": "https://github.com/rust-lang/rust/commit/7cff3c74b8d313154379ab73f18baab57c09bd33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cff3c74b8d313154379ab73f18baab57c09bd33/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a15482b9c602d162c6c26c36ab608eb1bef953d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a15482b9c602d162c6c26c36ab608eb1bef953d", "html_url": "https://github.com/rust-lang/rust/commit/3a15482b9c602d162c6c26c36ab608eb1bef953d"}, {"sha": "415a04315e660aa95473493d8031322f3cbd6bbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/415a04315e660aa95473493d8031322f3cbd6bbe", "html_url": "https://github.com/rust-lang/rust/commit/415a04315e660aa95473493d8031322f3cbd6bbe"}], "stats": {"total": 965, "additions": 429, "deletions": 536}, "files": [{"sha": "c3c0c5ef20ff64fbfb06963e093e16bd2faba8ea", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7cff3c74b8d313154379ab73f18baab57c09bd33", "patch": "@@ -4560,14 +4560,14 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n }\n \n pub fn get_tydesc_ty(tcx: ctxt) -> Result<t, ~str> {\n-    do tcx.lang_items.require(TyDescStructLangItem).map_move |tydesc_lang_item| {\n+    do tcx.lang_items.require(TyDescStructLangItem).map |tydesc_lang_item| {\n         tcx.intrinsic_defs.find_copy(&tydesc_lang_item)\n             .expect(\"Failed to resolve TyDesc\")\n     }\n }\n \n pub fn get_opaque_ty(tcx: ctxt) -> Result<t, ~str> {\n-    do tcx.lang_items.require(OpaqueStructLangItem).map_move |opaque_lang_item| {\n+    do tcx.lang_items.require(OpaqueStructLangItem).map |opaque_lang_item| {\n         tcx.intrinsic_defs.find_copy(&opaque_lang_item)\n             .expect(\"Failed to resolve Opaque\")\n     }"}, {"sha": "c34d20ed4f50f93a0b542462f5c39463b5911355", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=7cff3c74b8d313154379ab73f18baab57c09bd33", "patch": "@@ -2464,7 +2464,7 @@ fn test_timer_sleep_simple() {\n         unsafe {\n             let io = local_io();\n             let timer = io.timer_init();\n-            do timer.map_move |mut t| { t.sleep(1) };\n+            do timer.map |mut t| { t.sleep(1) };\n         }\n     }\n }"}, {"sha": "0d9dc18726fb00cf235445b3a6b88075754085fb", "filename": "src/libstd/option.rs", "status": "modified", "additions": 229, "deletions": 247, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=7cff3c74b8d313154379ab73f18baab57c09bd33", "patch": "@@ -8,94 +8,86 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Operations on the ubiquitous `Option` type.\n-\n-Type `Option` represents an optional value.\n-\n-Every `Option<T>` value can either be `Some(T)` or `None`. Where in other\n-languages you might use a nullable type, in Rust you would use an option\n-type.\n-\n-Options are most commonly used with pattern matching to query the presence\n-of a value and take action, always accounting for the `None` case.\n-\n-# Example\n-\n- ```\n-let msg = Some(~\"howdy\");\n-\n-// Take a reference to the contained string\n-match msg {\n-    Some(ref m) => io::println(*m),\n-    None => ()\n-}\n-\n-// Remove the contained string, destroying the Option\n-let unwrapped_msg = match msg {\n-    Some(m) => m,\n-    None => ~\"default message\"\n-};\n- ```\n-\n-*/\n-\n+//! Operations on the ubiquitous `Option` type.\n+//!\n+//! Type `Option` represents an optional value.\n+//!\n+//! Every `Option<T>` value can either be `Some(T)` or `None`. Where in other\n+//! languages you might use a nullable type, in Rust you would use an option\n+//! type.\n+//!\n+//! Options are most commonly used with pattern matching to query the presence\n+//! of a value and take action, always accounting for the `None` case.\n+//!\n+//! # Example\n+//!\n+//! ```\n+//! let msg = Some(~\"howdy\");\n+//!\n+//! // Take a reference to the contained string\n+//! match msg {\n+//!     Some(ref m) => io::println(*m),\n+//!     None => ()\n+//! }\n+//!\n+//! // Remove the contained string, destroying the Option\n+//! let unwrapped_msg = match msg {\n+//!     Some(m) => m,\n+//!     None => ~\"default message\"\n+//! };\n+//! ```\n+\n+use any::Any;\n use clone::Clone;\n-use cmp::{Eq,Ord};\n+use clone::DeepClone;\n+use cmp::{Eq, TotalEq, TotalOrd};\n use default::Default;\n-use either;\n-use util;\n-use num::Zero;\n-use iter;\n+use fmt;\n use iter::{Iterator, DoubleEndedIterator, ExactSize};\n-use result;\n-use str::{StrSlice, OwnedStr};\n+use kinds::Send;\n+use result::{IntoResult, ToResult, AsResult};\n+use result::{Result, Ok, Err};\n+use str::OwnedStr;\n use to_str::ToStr;\n-use clone::DeepClone;\n+use util;\n \n /// The option type\n-#[deriving(Clone, DeepClone, Eq)]\n-#[allow(missing_doc)]\n+#[deriving(Clone, DeepClone, Eq, Ord, TotalEq, TotalOrd, ToStr)]\n pub enum Option<T> {\n+    /// No value\n     None,\n-    Some(T),\n+    /// Some value `T`\n+    Some(T)\n }\n \n-impl<T: Eq + Ord> Ord for Option<T> {\n-    fn lt(&self, other: &Option<T>) -> bool {\n-        iter::order::lt(self.iter(), other.iter())\n-    }\n+/////////////////////////////////////////////////////////////////////////////\n+// Type implementation\n+/////////////////////////////////////////////////////////////////////////////\n \n-    fn le(&self, other: &Option<T>) -> bool {\n-        iter::order::le(self.iter(), other.iter())\n-    }\n+impl<T> Option<T> {\n+    /////////////////////////////////////////////////////////////////////////\n+    // Querying the contained values\n+    /////////////////////////////////////////////////////////////////////////\n \n-    fn ge(&self, other: &Option<T>) -> bool {\n-        iter::order::ge(self.iter(), other.iter())\n+    /// Returns true if the option contains a `Some` value\n+    #[inline]\n+    pub fn is_some(&self) -> bool {\n+        match *self {\n+            Some(_) => true,\n+            None => false\n+        }\n     }\n \n-    fn gt(&self, other: &Option<T>) -> bool {\n-        iter::order::gt(self.iter(), other.iter())\n+    /// Returns true if the option equals `None`\n+    #[inline]\n+    pub fn is_none(&self) -> bool {\n+        !self.is_some()\n     }\n-}\n \n-// FIXME: #8242 implementing manually because deriving doesn't work for some reason\n-impl<T: ToStr> ToStr for Option<T> {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            Some(ref x) => {\n-                let mut s = ~\"Some(\";\n-                s.push_str(x.to_str());\n-                s.push_str(\")\");\n-                s\n-            }\n-            None => ~\"None\"\n-        }\n-    }\n-}\n+    /////////////////////////////////////////////////////////////////////////\n+    // Adapter for working with references\n+    /////////////////////////////////////////////////////////////////////////\n \n-impl<T> Option<T> {\n     /// Convert from `Option<T>` to `Option<&T>`\n     #[inline]\n     pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n@@ -108,6 +100,64 @@ impl<T> Option<T> {\n         match *self { Some(ref mut x) => Some(x), None => None }\n     }\n \n+    /////////////////////////////////////////////////////////////////////////\n+    // Getting to contained values\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Unwraps a option, yielding the content of a `Some`\n+    /// Fails if the value is a `None` with a custom failure message provided by `msg`.\n+    #[inline]\n+    pub fn expect<M: Any + Send>(self, msg: M) -> T {\n+        match self {\n+            Some(val) => val,\n+            None => fail!(msg),\n+        }\n+    }\n+\n+    /// Moves a value out of an option type and returns it.\n+    ///\n+    /// Useful primarily for getting strings, vectors and unique pointers out\n+    /// of option types without copying them.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`.\n+    ///\n+    /// # Safety note\n+    ///\n+    /// In general, because this function may fail, its use is discouraged.\n+    /// Instead, prefer to use pattern matching and handle the `None`\n+    /// case explicitly.\n+    #[inline]\n+    pub fn unwrap(self) -> T {\n+        match self {\n+            Some(val) => val,\n+            None => fail!(\"called `Option::unwrap()` on a `None` value\"),\n+        }\n+    }\n+\n+    /// Returns the contained value or a default\n+    #[inline]\n+    pub fn unwrap_or(self, def: T) -> T {\n+        match self {\n+            Some(x) => x,\n+            None => def\n+        }\n+    }\n+\n+    /// Returns the contained value or computes it from a closure\n+    #[inline]\n+    pub fn unwrap_or_else(self, f: &fn() -> T) -> T {\n+        match self {\n+            Some(x) => x,\n+            None => f()\n+        }\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Transforming contained values\n+    /////////////////////////////////////////////////////////////////////////\n+\n     /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n     #[inline]\n     pub fn map<U>(self, f: &fn(T) -> U) -> Option<U> {\n@@ -120,6 +170,31 @@ impl<T> Option<T> {\n         match self { None => def, Some(t) => f(t) }\n     }\n \n+    /// Apply a function to the contained value or do nothing.\n+    /// Returns true if the contained value was mutated.\n+    pub fn mutate(&mut self, f: &fn(T) -> T) -> bool {\n+        if self.is_some() {\n+            *self = Some(f(self.take_unwrap()));\n+            true\n+        } else { false }\n+    }\n+\n+    /// Apply a function to the contained value or set it to a default.\n+    /// Returns true if the contained value was mutated, or false if set to the default.\n+    pub fn mutate_default(&mut self, def: T, f: &fn(T) -> T) -> bool {\n+        if self.is_some() {\n+            *self = Some(f(self.take_unwrap()));\n+            true\n+        } else {\n+            *self = Some(def);\n+            false\n+        }\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Iterator constructors\n+    /////////////////////////////////////////////////////////////////////////\n+\n     /// Return an iterator over the possibly contained value\n     #[inline]\n     pub fn iter<'r>(&'r self) -> OptionIterator<&'r T> {\n@@ -144,19 +219,13 @@ impl<T> Option<T> {\n         OptionIterator{opt: self}\n     }\n \n-    /// Returns true if the option equals `None`\n-    #[inline]\n-    pub fn is_none(&self) -> bool {\n-        match *self { None => true, Some(_) => false }\n-    }\n-\n-    /// Returns true if the option contains a `Some` value\n-    #[inline]\n-    pub fn is_some(&self) -> bool { !self.is_none() }\n+    /////////////////////////////////////////////////////////////////////////\n+    // Boolean operations on the values, eager and lazy\n+    /////////////////////////////////////////////////////////////////////////\n \n     /// Returns `None` if the option is `None`, otherwise returns `optb`.\n     #[inline]\n-    pub fn and(self, optb: Option<T>) -> Option<T> {\n+    pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n         match self {\n             Some(_) => optb,\n             None => None,\n@@ -192,7 +261,17 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Filters an optional value using given function.\n+    /////////////////////////////////////////////////////////////////////////\n+    // Misc\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Take the value out of the option, leaving a `None` in its place.\n+    #[inline]\n+    pub fn take(&mut self) -> Option<T> {\n+        util::replace(self, None)\n+    }\n+\n+    /// Filters an optional value using a given function.\n     #[inline(always)]\n     pub fn filtered(self, f: &fn(t: &T) -> bool) -> Option<T> {\n         match self {\n@@ -201,31 +280,31 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Take the value out of the option, leaving a `None` in its place.\n+    /// Applies a function zero or more times until the result is `None`.\n     #[inline]\n-    pub fn take(&mut self) -> Option<T> {\n-        util::replace(self, None)\n+    pub fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n+        let mut opt = self;\n+        while opt.is_some() {\n+            opt = blk(opt.unwrap());\n+        }\n     }\n \n-    /// Apply a function to the contained value or do nothing.\n-    /// Returns true if the contained value was mutated.\n-    pub fn mutate(&mut self, f: &fn(T) -> T) -> bool {\n-        if self.is_some() {\n-            *self = Some(f(self.take_unwrap()));\n-            true\n-        } else { false }\n-    }\n+    /////////////////////////////////////////////////////////////////////////\n+    // Common special cases\n+    /////////////////////////////////////////////////////////////////////////\n \n-    /// Apply a function to the contained value or set it to a default.\n-    /// Returns true if the contained value was mutated, or false if set to the default.\n-    pub fn mutate_default(&mut self, def: T, f: &fn(T) -> T) -> bool {\n-        if self.is_some() {\n-            *self = Some(f(self.take_unwrap()));\n-            true\n-        } else {\n-            *self = Some(def);\n-            false\n+    /// The option dance. Moves a value out of an option type and returns it,\n+    /// replacing the original with `None`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`.\n+    #[inline]\n+    pub fn take_unwrap(&mut self) -> T {\n+        if self.is_none() {\n+            fail!(\"called `Option::take_unwrap()` on a `None` value\")\n         }\n+        self.take().unwrap()\n     }\n \n     /// Gets an immutable reference to the value inside an option.\n@@ -267,85 +346,23 @@ impl<T> Option<T> {\n             None => fail!(\"called `Option::get_mut_ref()` on a `None` value\"),\n         }\n     }\n+}\n \n-    /// Moves a value out of an option type and returns it.\n-    ///\n-    /// Useful primarily for getting strings, vectors and unique pointers out\n-    /// of option types without copying them.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value equals `None`.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// In general, because this function may fail, its use is discouraged.\n-    /// Instead, prefer to use pattern matching and handle the `None`\n-    /// case explicitly.\n-    #[inline]\n-    pub fn unwrap(self) -> T {\n-        match self {\n-            Some(x) => x,\n-            None => fail!(\"called `Option::unwrap()` on a `None` value\"),\n-        }\n-    }\n-\n-    /// The option dance. Moves a value out of an option type and returns it,\n-    /// replacing the original with `None`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value equals `None`.\n-    #[inline]\n-    pub fn take_unwrap(&mut self) -> T {\n-        if self.is_none() {\n-            fail!(\"called `Option::take_unwrap()` on a `None` value\")\n-        }\n-        self.take().unwrap()\n-    }\n-\n-    ///  Gets the value out of an option, printing a specified message on\n-    ///  failure\n-    ///\n-    ///  # Failure\n-    ///\n-    ///  Fails if the value equals `None`\n-    #[inline]\n-    pub fn expect(self, reason: &str) -> T {\n-        match self {\n-            Some(val) => val,\n-            None => fail!(\"{}\", reason.to_owned()),\n-        }\n-    }\n-\n-    /// Returns the contained value or a default\n-    #[inline]\n-    pub fn unwrap_or(self, def: T) -> T {\n-        match self {\n-            Some(x) => x,\n-            None => def\n-        }\n-    }\n-\n-    /// Returns the contained value or computes it from a closure\n+impl<T: Default> Option<T> {\n+    /// Returns the contained value or default (for this type)\n     #[inline]\n-    pub fn unwrap_or_else(self, f: &fn() -> T) -> T {\n+    pub fn unwrap_or_default(self) -> T {\n         match self {\n             Some(x) => x,\n-            None => f()\n-        }\n-    }\n-\n-    /// Applies a function zero or more times until the result is `None`.\n-    #[inline]\n-    pub fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n-        let mut opt = self;\n-        while opt.is_some() {\n-            opt = blk(opt.unwrap());\n+            None => Default::default()\n         }\n     }\n }\n \n+/////////////////////////////////////////////////////////////////////////////\n+// Constructor extension trait\n+/////////////////////////////////////////////////////////////////////////////\n+\n /// A generic trait for converting a value to a `Option`\n pub trait ToOption<T> {\n     /// Convert to the `option` type\n@@ -384,53 +401,47 @@ impl<T> AsOption<T> for Option<T> {\n     }\n }\n \n-impl<T: Clone> result::ToResult<T, ()> for Option<T> {\n+/////////////////////////////////////////////////////////////////////////////\n+// Trait implementations\n+/////////////////////////////////////////////////////////////////////////////\n+\n+impl<T: Clone> ToResult<T, ()> for Option<T> {\n     #[inline]\n-    fn to_result(&self) -> result::Result<T, ()> {\n+    fn to_result(&self) -> Result<T, ()> {\n         match *self {\n-            Some(ref x) => result::Ok(x.clone()),\n-            None => result::Err(()),\n+            Some(ref x) => Ok(x.clone()),\n+            None => Err(()),\n         }\n     }\n }\n \n-impl<T> result::IntoResult<T, ()> for Option<T> {\n+impl<T> IntoResult<T, ()> for Option<T> {\n     #[inline]\n-    fn into_result(self) -> result::Result<T, ()> {\n+    fn into_result(self) -> Result<T, ()> {\n         match self {\n-            Some(x) => result::Ok(x),\n-            None => result::Err(()),\n+            Some(x) => Ok(x),\n+            None => Err(()),\n         }\n     }\n }\n \n-impl<T: Clone> either::ToEither<(), T> for Option<T> {\n+impl<T> AsResult<T, ()> for Option<T> {\n     #[inline]\n-    fn to_either(&self) -> either::Either<(), T> {\n+    fn as_result<'a>(&'a self) -> Result<&'a T, &'a ()> {\n+        static UNIT: () = ();\n         match *self {\n-            Some(ref x) => either::Right(x.clone()),\n-            None => either::Left(()),\n+            Some(ref t) => Ok(t),\n+            None => Err(&UNIT),\n         }\n     }\n }\n \n-impl<T> either::IntoEither<(), T> for Option<T> {\n+impl<T: fmt::Default> fmt::Default for Option<T> {\n     #[inline]\n-    fn into_either(self) -> either::Either<(), T> {\n-        match self {\n-            Some(x) => either::Right(x),\n-            None => either::Left(()),\n-        }\n-    }\n-}\n-\n-impl<T: Default> Option<T> {\n-    /// Returns the contained value or default (for this type)\n-    #[inline]\n-    pub fn unwrap_or_default(self) -> T {\n-        match self {\n-            Some(x) => x,\n-            None => Default::default()\n+    fn fmt(s: &Option<T>, f: &mut fmt::Formatter) {\n+        match *s {\n+            Some(ref t) => write!(f.buf, \"Some({})\", *t),\n+            None        => write!(f.buf, \"None\")\n         }\n     }\n }\n@@ -440,16 +451,9 @@ impl<T> Default for Option<T> {\n     fn default() -> Option<T> { None }\n }\n \n-impl<T: Zero> Option<T> {\n-    /// Returns the contained value or zero (for this type)\n-    #[inline]\n-    pub fn unwrap_or_zero(self) -> T {\n-        match self {\n-            Some(x) => x,\n-            None => Zero::zero()\n-        }\n-    }\n-}\n+/////////////////////////////////////////////////////////////////////////////\n+// The Option Iterator\n+/////////////////////////////////////////////////////////////////////////////\n \n /// An iterator that yields either one or zero elements\n #[deriving(Clone, DeepClone)]\n@@ -481,14 +485,17 @@ impl<A> DoubleEndedIterator<A> for OptionIterator<A> {\n \n impl<A> ExactSize<A> for OptionIterator<A> {}\n \n+/////////////////////////////////////////////////////////////////////////////\n+// Tests\n+/////////////////////////////////////////////////////////////////////////////\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n \n-    use either::{IntoEither, ToEither};\n-    use either;\n     use result::{IntoResult, ToResult};\n-    use result;\n+    use result::{Ok, Err};\n+    use str::StrSlice;\n     use util;\n \n     #[test]\n@@ -550,6 +557,7 @@ mod tests {\n         assert_eq!(y2, 5);\n         assert!(y.is_none());\n     }\n+\n     #[test] #[should_fail]\n     fn test_option_too_much_dance() {\n         let mut y = Some(util::NonCopyable);\n@@ -561,11 +569,11 @@ mod tests {\n     fn test_and() {\n         let x: Option<int> = Some(1);\n         assert_eq!(x.and(Some(2)), Some(2));\n-        assert_eq!(x.and(None), None);\n+        assert_eq!(x.and(None::<int>), None);\n \n         let x: Option<int> = None;\n         assert_eq!(x.and(Some(2)), None);\n-        assert_eq!(x.and(None), None);\n+        assert_eq!(x.and(None::<int>), None);\n     }\n \n     #[test]\n@@ -630,7 +638,7 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn test_unwrap_fail() {\n+    fn test_unwrap_fail2() {\n         let x: Option<~str> = None;\n         x.unwrap();\n     }\n@@ -653,14 +661,6 @@ mod tests {\n         assert_eq!(x.unwrap_or_else(|| 2), 2);\n     }\n \n-    #[test]\n-    fn test_unwrap_or_zero() {\n-        let some_stuff = Some(42);\n-        assert_eq!(some_stuff.unwrap_or_zero(), 42);\n-        let no_stuff: Option<int> = None;\n-        assert_eq!(no_stuff.unwrap_or_zero(), 0);\n-    }\n-\n     #[test]\n     fn test_filtered() {\n         let some_stuff = Some(42);\n@@ -765,34 +765,16 @@ mod tests {\n         let some: Option<int> = Some(100);\n         let none: Option<int> = None;\n \n-        assert_eq!(some.to_result(), result::Ok(100));\n-        assert_eq!(none.to_result(), result::Err(()));\n+        assert_eq!(some.to_result(), Ok(100));\n+        assert_eq!(none.to_result(), Err(()));\n     }\n \n     #[test]\n     pub fn test_into_result() {\n         let some: Option<int> = Some(100);\n         let none: Option<int> = None;\n \n-        assert_eq!(some.into_result(), result::Ok(100));\n-        assert_eq!(none.into_result(), result::Err(()));\n-    }\n-\n-    #[test]\n-    pub fn test_to_either() {\n-        let some: Option<int> = Some(100);\n-        let none: Option<int> = None;\n-\n-        assert_eq!(some.to_either(), either::Right(100));\n-        assert_eq!(none.to_either(), either::Left(()));\n-    }\n-\n-    #[test]\n-    pub fn test_into_either() {\n-        let some: Option<int> = Some(100);\n-        let none: Option<int> = None;\n-\n-        assert_eq!(some.into_either(), either::Right(100));\n-        assert_eq!(none.into_either(), either::Left(()));\n+        assert_eq!(some.into_result(), Ok(100));\n+        assert_eq!(none.into_result(), Err(()));\n     }\n }"}, {"sha": "03860c8ab2211baaaf830d541b7aef632ce47d7b", "filename": "src/libstd/result.rs", "status": "modified", "additions": 155, "deletions": 239, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=7cff3c74b8d313154379ab73f18baab57c09bd33", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,47 +10,40 @@\n \n //! A type representing either success or failure\n \n-#[allow(missing_doc)];\n-\n+use any::Any;\n use clone::Clone;\n use cmp::Eq;\n-use either;\n+use fmt;\n use iter::Iterator;\n+use kinds::Send;\n use option::{None, Option, Some, OptionIterator};\n-use option;\n-use vec;\n-use vec::OwnedVector;\n+use option::{ToOption, IntoOption, AsOption};\n+use str::OwnedStr;\n use to_str::ToStr;\n-use str::StrSlice;\n-use fmt;\n+use vec::OwnedVector;\n+use vec;\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n /// In order to provide informative error messages, `E` is required to implement `ToStr`.\n /// It is further recommended for `E` to be a descriptive error type, eg a `enum` for\n /// all possible errors cases.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, DeepClone, Eq, Ord, TotalEq, TotalOrd, ToStr)]\n pub enum Result<T, E> {\n     /// Contains the successful result value\n     Ok(T),\n     /// Contains the error value\n     Err(E)\n }\n \n+/////////////////////////////////////////////////////////////////////////////\n+// Type implementation\n+/////////////////////////////////////////////////////////////////////////////\n+\n impl<T, E: ToStr> Result<T, E> {\n-    /// Get a reference to the value out of a successful result\n-    ///\n-    /// # Failure\n-    ///\n-    /// If the result is an error\n-    #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a T {\n-        match *self {\n-            Ok(ref t) => t,\n-            Err(ref e) => fail!(\"called `Result::get_ref()` on `Err` value: {}\",\n-                                 e.to_str()),\n-        }\n-    }\n+    /////////////////////////////////////////////////////////////////////////\n+    // Querying the contained values\n+    /////////////////////////////////////////////////////////////////////////\n \n     /// Returns true if the result is `Ok`\n     #[inline]\n@@ -67,137 +60,153 @@ impl<T, E: ToStr> Result<T, E> {\n         !self.is_ok()\n     }\n \n-    /// Call a method based on a previous result\n-    ///\n-    /// If `self` is `Ok` then the value is extracted and passed to `op`\n-    /// whereupon `op`s result is returned. if `self` is `Err` then it is\n-    /// immediately returned. This function can be used to compose the results\n-    /// of two functions.\n-    ///\n-    /// Example:\n-    ///\n-    ///     for buf in read_file(file) {\n-    ///         print_buf(buf)\n-    ///     }\n+    /////////////////////////////////////////////////////////////////////////\n+    // Adapter for working with references\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Convert from `Result<T, E>` to `Result<&T, &E>`\n     #[inline]\n-    pub fn iter<'r>(&'r self) -> OptionIterator<&'r T> {\n+    pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> {\n         match *self {\n-            Ok(ref t) => Some(t),\n-            Err(*) => None,\n-        }.move_iter()\n+            Ok(ref x) => Ok(x),\n+            Err(ref x) => Err(x),\n+        }\n     }\n \n-    /// Call a method based on a previous result\n-    ///\n-    /// If `self` is `Err` then the value is extracted and passed to `op`\n-    /// whereupon `op`s result is returned. if `self` is `Ok` then it is\n-    /// immediately returned.  This function can be used to pass through a\n-    /// successful result while handling an error.\n+    /// Convert from `Result<T, E>` to `Result<&mut T, &mut E>`\n     #[inline]\n-    pub fn iter_err<'r>(&'r self) -> OptionIterator<&'r E> {\n+    pub fn as_mut<'r>(&'r mut self) -> Result<&'r mut T, &'r mut E> {\n         match *self {\n-            Ok(*) => None,\n-            Err(ref t) => Some(t),\n-        }.move_iter()\n+            Ok(ref mut x) => Ok(x),\n+            Err(ref mut x) => Err(x),\n+        }\n     }\n \n+    /////////////////////////////////////////////////////////////////////////\n+    // Getting to contained values\n+    /////////////////////////////////////////////////////////////////////////\n+\n     /// Unwraps a result, yielding the content of an `Ok`.\n-    /// Fails if the value is a `Err` with an error message derived\n-    /// from `E`'s `ToStr` implementation.\n+    /// Fails if the value is a `Err` with a custom failure message provided by `msg`.\n     #[inline]\n-    pub fn unwrap(self) -> T {\n+    pub fn expect<M: Any + Send>(self, msg: M) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(e) => fail!(\"called `Result::unwrap()` on `Err` value: {}\",\n-                             e.to_str()),\n+            Err(_) => fail!(msg),\n         }\n     }\n \n     /// Unwraps a result, yielding the content of an `Err`.\n-    /// Fails if the value is a `Ok`.\n+    /// Fails if the value is a `Ok` with a custom failure message provided by `msg`.\n     #[inline]\n-    pub fn unwrap_err(self) -> E {\n-        self.expect_err(\"called `Result::unwrap_err()` on `Ok` value\")\n+    pub fn expect_err<M: Any + Send>(self, msg: M) -> E {\n+        match self {\n+            Err(e) => e,\n+            Ok(_) => fail!(msg),\n+        }\n     }\n \n     /// Unwraps a result, yielding the content of an `Ok`.\n-    /// Fails if the value is a `Err` with a custom failure message.\n+    /// Fails if the value is a `Err` with an error message derived\n+    /// from `E`'s `ToStr` implementation.\n     #[inline]\n-    pub fn expect(self, reason: &str) -> T {\n+    pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(_) => fail!(\"{}\", reason.to_owned()),\n+            Err(e) => fail!(\"called `Result::unwrap()` on `Err` value '{}'\",\n+                             e.to_str()),\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an `Err`\n-    /// Fails if the value is a `Ok` with a custom failure message.\n+    /// Unwraps a result, yielding the content of an `Err`.\n+    /// Fails if the value is a `Ok`.\n     #[inline]\n-    pub fn expect_err(self, reason: &str) -> E {\n+    pub fn unwrap_err(self) -> E {\n         match self {\n-            Err(e) => e,\n-            Ok(_) => fail!(\"{}\", reason.to_owned()),\n+            Ok(_) => fail!(\"called `Result::unwrap_err()` on an `Ok` value\"),\n+            Err(e) => e\n         }\n     }\n \n-    /// Call a method based on a previous result\n+    /////////////////////////////////////////////////////////////////////////\n+    // Transforming contained values\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Maps an `Result<T, E>` to `Result<U, E>` by applying a function to an\n+    /// contained `Ok` value, leaving an `Err` value untouched.\n     ///\n-    /// If `self` is `Ok` then the value is extracted and passed to `op`\n-    /// whereupon `op`s result is wrapped in `Ok` and returned. if `self` is\n-    /// `Err` then it is immediately returned.  This function can be used to\n-    /// compose the results of two functions.\n+    /// This function can be used to compose the results of two functions.\n     ///\n     /// Example:\n     ///\n-    ///     let res = do read_file(file).map_move |buf| {\n+    ///     let res = do read_file(file).map |buf| {\n     ///         parse_bytes(buf)\n     ///     }\n     #[inline]\n-    pub fn map_move<U>(self, op: &fn(T) -> U) -> Result<U,E> {\n+    pub fn map<U>(self, op: &fn(T) -> U) -> Result<U,E> {\n         match self {\n           Ok(t) => Ok(op(t)),\n           Err(e) => Err(e)\n         }\n     }\n \n-    /// Call a method based on a previous result\n+    /// Maps an `Result<T, E>` to `Result<T, F>` by applying a function to an\n+    /// contained `Err` value, leaving an `Ok` value untouched.\n     ///\n-    /// If `self` is `Err` then the value is extracted and passed to `op`\n-    /// whereupon `op`s result is wrapped in an `Err` and returned. if `self` is\n-    /// `Ok` then it is immediately returned.  This function can be used to pass\n-    /// through a successful result while handling an error.\n+    /// This function can be used to pass through a successful result while handling\n+    /// an error.\n     #[inline]\n-    pub fn map_err_move<F>(self, op: &fn(E) -> F) -> Result<T,F> {\n+    pub fn map_err<F>(self, op: &fn(E) -> F) -> Result<T,F> {\n         match self {\n           Ok(t) => Ok(t),\n           Err(e) => Err(op(e))\n         }\n     }\n \n-    /// Call a method based on a previous result\n+    /////////////////////////////////////////////////////////////////////////\n+    // Iterator constructors\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns an `Iterator` over one or zero references to the value of an `Ok`\n     ///\n-    /// If `self` is `Ok`, then `res` it is returned. If `self` is `Err`,\n-    /// then `self` is returned.\n+    /// Example:\n+    ///\n+    ///     for buf in read_file(file) {\n+    ///         print_buf(buf)\n+    ///     }\n     #[inline]\n-    pub fn and(self, res: Result<T, E>) -> Result<T, E> {\n+    pub fn iter<'r>(&'r self) -> OptionIterator<&'r T> {\n+        match *self {\n+            Ok(ref t) => Some(t),\n+            Err(*) => None,\n+        }.move_iter()\n+    }\n+\n+    /// Returns an `Iterator` over one or zero references to the value of an `Err`\n+    #[inline]\n+    pub fn iter_err<'r>(&'r self) -> OptionIterator<&'r E> {\n+        match *self {\n+            Ok(*) => None,\n+            Err(ref t) => Some(t),\n+        }.move_iter()\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////\n+    // Boolean operations on the values, eager and lazy\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n+    #[inline]\n+    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(_) => res,\n-            Err(_) => self,\n+            Err(e) => Err(e),\n         }\n     }\n \n-    /// Call a method based on a previous result\n-    ///\n-    /// If `self` is `Ok` then the value is extracted and passed to `op`\n-    /// whereupon `op`s result is returned. If `self` is `Err` then it is\n-    /// immediately returned. This function can be used to compose the results\n-    /// of two functions.\n+    /// Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n     ///\n-    /// Example:\n-    ///\n-    ///     let res = do read_file(file) |buf| {\n-    ///         Ok(parse_bytes(buf))\n-    ///     };\n+    /// This function can be used for control flow based on result values\n     #[inline]\n     pub fn and_then<U>(self, op: &fn(T) -> Result<U, E>) -> Result<U, E> {\n         match self {\n@@ -206,10 +215,7 @@ impl<T, E: ToStr> Result<T, E> {\n         }\n     }\n \n-    /// Call a method based on a previous result\n-    ///\n-    /// If `self` is `Ok`, then `self` is returned. If `self` is `Err`\n-    /// then `res` is returned.\n+    /// Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n     #[inline]\n     pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n         match self {\n@@ -218,59 +224,40 @@ impl<T, E: ToStr> Result<T, E> {\n         }\n     }\n \n-    /// Call a function based on a previous result\n+    /// Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n     ///\n-    /// If `self` is `Err` then the value is extracted and passed to `op`\n-    /// whereupon `op`s result is returned. if `self` is `Ok` then it is\n-    /// immediately returned.  This function can be used to pass through a\n-    /// successful result while handling an error.\n+    /// This function can be used for control flow based on result values\n     #[inline]\n     pub fn or_else<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n             Err(e) => op(e),\n         }\n     }\n-}\n \n-impl<T: Clone, E: ToStr> Result<T, E> {\n-    /// Call a method based on a previous result\n-    ///\n-    /// If `self` is `Err` then the value is extracted and passed to `op`\n-    /// whereupon `op`s result is wrapped in an `Err` and returned. if `self` is\n-    /// `Ok` then it is immediately returned.  This function can be used to pass\n-    /// through a successful result while handling an error.\n-    #[inline]\n-    pub fn map_err<F: Clone>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n-        match *self {\n-            Ok(ref t) => Ok(t.clone()),\n-            Err(ref e) => Err(op(e))\n-        }\n-    }\n-}\n+    /////////////////////////////////////////////////////////////////////////\n+    // Common special cases\n+    /////////////////////////////////////////////////////////////////////////\n \n-impl<T, E: Clone + ToStr> Result<T, E> {\n-    /// Call a method based on a previous result\n-    ///\n-    /// If `self` is `Ok` then the value is extracted and passed to `op`\n-    /// whereupon `op`s result is wrapped in `Ok` and returned. if `self` is\n-    /// `Err` then it is immediately returned.  This function can be used to\n-    /// compose the results of two functions.\n+    /// Get a reference to the value out of a successful result\n     ///\n-    /// Example:\n+    /// # Failure\n     ///\n-    ///     let res = do read_file(file).map |buf| {\n-    ///         parse_bytes(buf)\n-    ///     };\n+    /// If the result is an error\n     #[inline]\n-    pub fn map<U>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n+    pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n-            Ok(ref t) => Ok(op(t)),\n-            Err(ref e) => Err(e.clone())\n+            Ok(ref t) => t,\n+            Err(ref e) => fail!(\"called `Result::get_ref()` on `Err` value '{}'\",\n+                                 e.to_str()),\n         }\n     }\n }\n \n+/////////////////////////////////////////////////////////////////////////////\n+// Constructor extension trait\n+/////////////////////////////////////////////////////////////////////////////\n+\n /// A generic trait for converting a value to a `Result`\n pub trait ToResult<T, E> {\n     /// Convert to the `result` type\n@@ -289,36 +276,6 @@ pub trait AsResult<T, E> {\n     fn as_result<'a>(&'a self) -> Result<&'a T, &'a E>;\n }\n \n-impl<T: Clone, E> option::ToOption<T> for Result<T, E> {\n-    #[inline]\n-    fn to_option(&self) -> Option<T> {\n-        match *self {\n-            Ok(ref t) => Some(t.clone()),\n-            Err(_) => None,\n-        }\n-    }\n-}\n-\n-impl<T, E> option::IntoOption<T> for Result<T, E> {\n-    #[inline]\n-    fn into_option(self) -> Option<T> {\n-        match self {\n-            Ok(t) => Some(t),\n-            Err(_) => None,\n-        }\n-    }\n-}\n-\n-impl<T, E> option::AsOption<T> for Result<T, E> {\n-    #[inline]\n-    fn as_option<'a>(&'a self) -> Option<&'a T> {\n-        match *self {\n-            Ok(ref t) => Some(t),\n-            Err(_) => None,\n-        }\n-    }\n-}\n-\n impl<T: Clone, E: Clone> ToResult<T, E> for Result<T, E> {\n     #[inline]\n     fn to_result(&self) -> Result<T, E> { self.clone() }\n@@ -339,42 +296,36 @@ impl<T, E> AsResult<T, E> for Result<T, E> {\n     }\n }\n \n-impl<T: Clone, E: Clone> either::ToEither<E, T> for Result<T, E> {\n+/////////////////////////////////////////////////////////////////////////////\n+// Trait implementations\n+/////////////////////////////////////////////////////////////////////////////\n+\n+impl<T: Clone, E> ToOption<T> for Result<T, E> {\n     #[inline]\n-    fn to_either(&self) -> either::Either<E, T> {\n+    fn to_option(&self) -> Option<T> {\n         match *self {\n-            Ok(ref t) => either::Right(t.clone()),\n-            Err(ref e) => either::Left(e.clone()),\n+            Ok(ref t) => Some(t.clone()),\n+            Err(_) => None,\n         }\n     }\n }\n \n-impl<T, E> either::IntoEither<E, T> for Result<T, E> {\n+impl<T, E> IntoOption<T> for Result<T, E> {\n     #[inline]\n-    fn into_either(self) -> either::Either<E, T> {\n+    fn into_option(self) -> Option<T> {\n         match self {\n-            Ok(t) => either::Right(t),\n-            Err(e) => either::Left(e),\n-        }\n-    }\n-}\n-\n-impl<T, E> either::AsEither<E, T> for Result<T, E> {\n-    #[inline]\n-    fn as_either<'a>(&'a self) -> either::Either<&'a E, &'a T> {\n-        match *self {\n-            Ok(ref t) => either::Right(t),\n-            Err(ref e) => either::Left(e),\n+            Ok(t) => Some(t),\n+            Err(_) => None,\n         }\n     }\n }\n \n-impl<T: ToStr, E: ToStr> ToStr for Result<T, E> {\n+impl<T, E> AsOption<T> for Result<T, E> {\n     #[inline]\n-    fn to_str(&self) -> ~str {\n+    fn as_option<'a>(&'a self) -> Option<&'a T> {\n         match *self {\n-            Ok(ref t) => format!(\"Ok({:s})\", t.to_str()),\n-            Err(ref e) => format!(\"Err({:s})\", e.to_str())\n+            Ok(ref t) => Some(t),\n+            Err(_) => None,\n         }\n     }\n }\n@@ -389,6 +340,10 @@ impl<T: fmt::Default, E: fmt::Default> fmt::Default for Result<T, E> {\n     }\n }\n \n+/////////////////////////////////////////////////////////////////////////////\n+// Free functions\n+/////////////////////////////////////////////////////////////////////////////\n+\n /// Takes each element in the iterator: if it is an error, no further\n /// elements are taken, and the error is returned.\n /// Should no error occur, a vector containing the values of each Result\n@@ -450,17 +405,17 @@ pub fn fold_<T, E, Iter: Iterator<Result<T, E>>>(\n     fold(iterator, (), |_, _| ())\n }\n \n+/////////////////////////////////////////////////////////////////////////////\n+// Tests\n+/////////////////////////////////////////////////////////////////////////////\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n-    use either::{IntoEither, ToEither, AsEither};\n-    use either;\n     use iter::range;\n     use option::{IntoOption, ToOption, AsOption};\n-    use option;\n-    use str::OwnedStr;\n+    use option::{Some, None};\n     use vec::ImmutableVector;\n     use to_str::ToStr;\n \n@@ -470,10 +425,10 @@ mod tests {\n     #[test]\n     pub fn test_and() {\n         assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n-        assert_eq!(op1().and(Err(~\"bad\")).unwrap_err(), ~\"bad\");\n+        assert_eq!(op1().and(Err::<(), ~str>(~\"bad\")).unwrap_err(), ~\"bad\");\n \n         assert_eq!(op2().and(Ok(667)).unwrap_err(), ~\"sadface\");\n-        assert_eq!(op2().and(Err(~\"bad\")).unwrap_err(), ~\"sadface\");\n+        assert_eq!(op2().and(Err::<(), ~str>(~\"bad\")).unwrap_err(), ~\"sadface\");\n     }\n \n     #[test]\n@@ -530,26 +485,14 @@ mod tests {\n \n     #[test]\n     pub fn test_impl_map() {\n-        assert_eq!(Ok::<~str, ~str>(~\"a\").map(|x| (~\"b\").append(*x)), Ok(~\"ba\"));\n-        assert_eq!(Err::<~str, ~str>(~\"a\").map(|x| (~\"b\").append(*x)), Err(~\"a\"));\n+        assert_eq!(Ok::<~str, ~str>(~\"a\").map(|x| x + \"b\"), Ok(~\"ab\"));\n+        assert_eq!(Err::<~str, ~str>(~\"a\").map(|x| x + \"b\"), Err(~\"a\"));\n     }\n \n     #[test]\n     pub fn test_impl_map_err() {\n-        assert_eq!(Ok::<~str, ~str>(~\"a\").map_err(|x| (~\"b\").append(*x)), Ok(~\"a\"));\n-        assert_eq!(Err::<~str, ~str>(~\"a\").map_err(|x| (~\"b\").append(*x)), Err(~\"ba\"));\n-    }\n-\n-    #[test]\n-    pub fn test_impl_map_move() {\n-        assert_eq!(Ok::<~str, ~str>(~\"a\").map_move(|x| x + \"b\"), Ok(~\"ab\"));\n-        assert_eq!(Err::<~str, ~str>(~\"a\").map_move(|x| x + \"b\"), Err(~\"a\"));\n-    }\n-\n-    #[test]\n-    pub fn test_impl_map_err_move() {\n-        assert_eq!(Ok::<~str, ~str>(~\"a\").map_err_move(|x| x + \"b\"), Ok(~\"a\"));\n-        assert_eq!(Err::<~str, ~str>(~\"a\").map_err_move(|x| x + \"b\"), Err(~\"ab\"));\n+        assert_eq!(Ok::<~str, ~str>(~\"a\").map_err(|x| x + \"b\"), Ok(~\"a\"));\n+        assert_eq!(Err::<~str, ~str>(~\"a\").map_err(|x| x + \"b\"), Err(~\"ab\"));\n     }\n \n     #[test]\n@@ -603,17 +546,17 @@ mod tests {\n         let ok: Result<int, int> = Ok(100);\n         let err: Result<int, int> = Err(404);\n \n-        assert_eq!(ok.to_option(), option::Some(100));\n-        assert_eq!(err.to_option(), option::None);\n+        assert_eq!(ok.to_option(), Some(100));\n+        assert_eq!(err.to_option(), None);\n     }\n \n     #[test]\n     pub fn test_into_option() {\n         let ok: Result<int, int> = Ok(100);\n         let err: Result<int, int> = Err(404);\n \n-        assert_eq!(ok.into_option(), option::Some(100));\n-        assert_eq!(err.into_option(), option::None);\n+        assert_eq!(ok.into_option(), Some(100));\n+        assert_eq!(err.into_option(), None);\n     }\n \n     #[test]\n@@ -622,7 +565,7 @@ mod tests {\n         let err: Result<int, int> = Err(404);\n \n         assert_eq!(ok.as_option().unwrap(), &100);\n-        assert_eq!(err.as_option(), option::None);\n+        assert_eq!(err.as_option(), None);\n     }\n \n     #[test]\n@@ -655,33 +598,6 @@ mod tests {\n         assert_eq!(err.as_result(), Err(&x));\n     }\n \n-    #[test]\n-    pub fn test_to_either() {\n-        let ok: Result<int, int> = Ok(100);\n-        let err: Result<int, int> = Err(404);\n-\n-        assert_eq!(ok.to_either(), either::Right(100));\n-        assert_eq!(err.to_either(), either::Left(404));\n-    }\n-\n-    #[test]\n-    pub fn test_into_either() {\n-        let ok: Result<int, int> = Ok(100);\n-        let err: Result<int, int> = Err(404);\n-\n-        assert_eq!(ok.into_either(), either::Right(100));\n-        assert_eq!(err.into_either(), either::Left(404));\n-    }\n-\n-    #[test]\n-    pub fn test_as_either() {\n-        let ok: Result<int, int> = Ok(100);\n-        let err: Result<int, int> = Err(404);\n-\n-        assert_eq!(ok.as_either().unwrap_right(), &100);\n-        assert_eq!(err.as_either().unwrap_left(), &404);\n-    }\n-\n     #[test]\n     pub fn test_to_str() {\n         let ok: Result<int, ~str> = Ok(100);"}, {"sha": "fb1a3fac8d588913762ff1f9501c0bb48e2a8f61", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=7cff3c74b8d313154379ab73f18baab57c09bd33", "patch": "@@ -208,7 +208,7 @@ impl Reader for StdReader {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         let ret = match self.inner {\n             TTY(ref mut tty) => tty.read(buf),\n-            File(ref mut file) => file.read(buf).map_move(|i| i as uint),\n+            File(ref mut file) => file.read(buf).map(|i| i as uint),\n         };\n         match ret {\n             Ok(amt) => Some(amt as uint),"}, {"sha": "018180c85b7ac0f517f91895305052eeb5241e8f", "filename": "src/libstd/std.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=7cff3c74b8d313154379ab73f18baab57c09bd33", "patch": "@@ -8,45 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-# The Rust standard library\n-\n-The Rust standard library is a group of interrelated modules defining\n-the core language traits, operations on built-in data types, collections,\n-platform abstractions, the task scheduler, runtime support for language\n-features and other common functionality.\n-\n-`std` includes modules corresponding to each of the integer types,\n-each of the floating point types, the `bool` type, tuples, characters,\n-strings (`str`), vectors (`vec`), managed boxes (`managed`), owned\n-boxes (`owned`), and unsafe and borrowed pointers (`ptr`, `borrowed`).\n-Additionally, `std` provides pervasive types (`option` and `result`),\n-task creation and communication primitives (`task`, `comm`), platform\n-abstractions (`os` and `path`), basic I/O abstractions (`io`), common\n-traits (`kinds`, `ops`, `cmp`, `num`, `to_str`), and complete bindings\n-to the C standard library (`libc`).\n-\n-# Standard library injection and the Rust prelude\n-\n-`std` is imported at the topmost level of every crate by default, as\n-if the first line of each crate was\n-\n-    extern mod std;\n-\n-This means that the contents of std can be accessed from any context\n-with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`,\n-etc.\n-\n-Additionally, `std` contains a `prelude` module that reexports many of the\n-most common types, traits and functions. The contents of the prelude are\n-imported into every *module* by default.  Implicitly, all modules behave as if\n-they contained the following prologue:\n-\n-    use std::prelude::*;\n-\n-*/\n-\n+//! # The Rust standard library\n+//!\n+//! The Rust standard library is a group of interrelated modules defining\n+//! the core language traits, operations on built-in data types, collections,\n+//! platform abstractions, the task scheduler, runtime support for language\n+//! features and other common functionality.\n+//!\n+//! `std` includes modules corresponding to each of the integer types,\n+//! each of the floating point types, the `bool` type, tuples, characters,\n+//! strings (`str`), vectors (`vec`), managed boxes (`managed`), owned\n+//! boxes (`owned`), and unsafe and borrowed pointers (`ptr`, `borrowed`).\n+//! Additionally, `std` provides pervasive types (`option` and `result`),\n+//! task creation and communication primitives (`task`, `comm`), platform\n+//! abstractions (`os` and `path`), basic I/O abstractions (`io`), common\n+//! traits (`kinds`, `ops`, `cmp`, `num`, `to_str`), and complete bindings\n+//! to the C standard library (`libc`).\n+//!\n+//! # Standard library injection and the Rust prelude\n+//!\n+//! `std` is imported at the topmost level of every crate by default, as\n+//! if the first line of each crate was\n+//!\n+//!     extern mod std;\n+//!\n+//! This means that the contents of std can be accessed from any context\n+//! with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`,\n+//! etc.\n+//!\n+//! Additionally, `std` contains a `prelude` module that reexports many of the\n+//! most common types, traits and functions. The contents of the prelude are\n+//! imported into every *module* by default.  Implicitly, all modules behave as if\n+//! they contained the following prologue:\n+//!\n+//!     use std::prelude::*;\n \n #[link(name = \"std\",\n        vers = \"0.9-pre\",\n@@ -97,6 +92,7 @@ pub mod linkhack {\n \n pub mod prelude;\n \n+\n /* Primitive types */\n \n #[path = \"num/int_macros.rs\"]   mod int_macros;\n@@ -158,6 +154,7 @@ pub mod container;\n pub mod default;\n pub mod any;\n \n+\n /* Common data structures */\n \n pub mod option;\n@@ -198,11 +195,13 @@ pub mod util;\n pub mod routine;\n pub mod mem;\n \n+\n /* Unsupported interfaces */\n \n // Private APIs\n pub mod unstable;\n \n+\n /* For internal use, not exported */\n \n mod unicode;"}, {"sha": "c27f6e3d086b68840794f0f9bdd3433f8b1e8861", "filename": "src/libstd/unit.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibstd%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Flibstd%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funit.rs?ref=7cff3c74b8d313154379ab73f18baab57c09bd33", "patch": "@@ -8,11 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Functions for the unit type.\n-\n-*/\n+//! Functions for the unit type.\n \n #[cfg(not(test))]\n use prelude::*;"}, {"sha": "027faadecadfd4975fb4015c931014442c343f78", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cff3c74b8d313154379ab73f18baab57c09bd33/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=7cff3c74b8d313154379ab73f18baab57c09bd33", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:called `Result::unwrap()` on `Err` value: kitty\n+// error-pattern:called `Result::unwrap()` on `Err` value 'kitty'\n \n use std::result;\n "}]}