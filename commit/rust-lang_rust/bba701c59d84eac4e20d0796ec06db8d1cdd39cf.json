{"sha": "bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYTcwMWM1OWQ4NGVhYzRlMjBkMDc5NmVjMDZkYjhkMWNkZDM5Y2Y=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-31T17:43:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-01T17:31:27Z"}, "message": "std: Drop Total from Total{Eq,Ord}\n\nThis completes the last stage of the renaming of the comparison hierarchy of\ntraits. This change renames TotalEq to Eq and TotalOrd to Ord.\n\nIn the future the new Eq/Ord will be filled out with their appropriate methods,\nbut for now this change is purely a renaming change.\n\n[breaking-change]", "tree": {"sha": "3c2109ca567bbc7e7b8d66da7282dac8f8926da6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c2109ca567bbc7e7b8d66da7282dac8f8926da6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "html_url": "https://github.com/rust-lang/rust/commit/bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c605c2b57b412402e6b491e91852fd9dbadeb551", "url": "https://api.github.com/repos/rust-lang/rust/commits/c605c2b57b412402e6b491e91852fd9dbadeb551", "html_url": "https://github.com/rust-lang/rust/commit/c605c2b57b412402e6b491e91852fd9dbadeb551"}], "stats": {"total": 867, "additions": 436, "deletions": 431}, "files": [{"sha": "9377c96827261389f50bed468ba5dc70df6102d6", "filename": "src/liballoc/owned.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Fliballoc%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Fliballoc%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fowned.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -12,7 +12,7 @@\n \n use core::any::{Any, AnyRefExt};\n use core::clone::Clone;\n-use core::cmp::{PartialEq, PartialOrd, TotalEq, TotalOrd, Ordering};\n+use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::intrinsics;\n@@ -67,11 +67,11 @@ impl<T:PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn gt(&self, other: &Box<T>) -> bool { *(*self) > *(*other) }\n }\n-impl<T: TotalOrd> TotalOrd for Box<T> {\n+impl<T: Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering { (**self).cmp(*other) }\n }\n-impl<T: TotalEq> TotalEq for Box<T> {}\n+impl<T: Eq> Eq for Box<T> {}\n \n /// Extension methods for an owning `Any` trait object\n pub trait AnyOwnExt {"}, {"sha": "7177aa3de45e8f32d5cbb45365d634fd326c2f50", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -26,7 +26,7 @@ pointers, and then storing the parent pointers as `Weak` pointers.\n use core::mem::transmute;\n use core::cell::Cell;\n use core::clone::Clone;\n-use core::cmp::{PartialEq, PartialOrd, TotalEq, TotalOrd, Ordering};\n+use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::kinds::marker;\n use core::ops::{Deref, Drop};\n use core::option::{Option, Some, None};\n@@ -157,7 +157,7 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n }\n \n-impl<T: TotalEq> TotalEq for Rc<T> {}\n+impl<T: Eq> Eq for Rc<T> {}\n \n impl<T: PartialOrd> PartialOrd for Rc<T> {\n     #[inline(always)]\n@@ -173,7 +173,7 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n }\n \n-impl<T: TotalOrd> TotalOrd for Rc<T> {\n+impl<T: Ord> Ord for Rc<T> {\n     #[inline]\n     fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n }"}, {"sha": "cebf21ee7e783b8ba1418ac1f0461cf84c0dd11a", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -29,7 +29,7 @@ pub struct BTree<K, V> {\n     upper_bound: uint\n }\n \n-impl<K: TotalOrd, V> BTree<K, V> {\n+impl<K: Ord, V> BTree<K, V> {\n \n     ///Returns new BTree with root node (leaf) and user-supplied lower bound\n     ///The lower bound applies to every node except the root node.\n@@ -59,7 +59,7 @@ impl<K: TotalOrd, V> BTree<K, V> {\n //We would probably want to remove the dependence on the Clone trait in the future.\n //It is here as a crutch to ensure values can be passed around through the tree's nodes\n //especially during insertions and deletions.\n-impl<K: Clone + TotalOrd, V: Clone> BTree<K, V> {\n+impl<K: Clone + Ord, V: Clone> BTree<K, V> {\n     ///Returns the value of a given key, which may not exist in the tree.\n     ///Calls the root node's get method.\n     pub fn get(self, k: K) -> Option<V> {\n@@ -84,36 +84,36 @@ impl<K: Clone + TotalOrd, V: Clone> BTree<K, V> {\n     }\n }\n \n-impl<K: Clone + TotalOrd, V: Clone> Clone for BTree<K, V> {\n+impl<K: Clone + Ord, V: Clone> Clone for BTree<K, V> {\n     ///Implements the Clone trait for the BTree.\n     ///Uses a helper function/constructor to produce a new BTree.\n     fn clone(&self) -> BTree<K, V> {\n         BTree::new_with_node_len(self.root.clone(), self.len, self.lower_bound)\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> PartialEq for BTree<K, V> {\n+impl<K: Ord, V: Eq> PartialEq for BTree<K, V> {\n     fn eq(&self, other: &BTree<K, V>) -> bool {\n         self.root.cmp(&other.root) == Equal\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalEq for BTree<K, V> {}\n+impl<K: Ord, V: Eq> Eq for BTree<K, V> {}\n \n-impl<K: TotalOrd, V: TotalEq> PartialOrd for BTree<K, V> {\n+impl<K: Ord, V: Eq> PartialOrd for BTree<K, V> {\n     fn lt(&self, other: &BTree<K, V>) -> bool {\n         self.cmp(other) == Less\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalOrd for BTree<K, V> {\n+impl<K: Ord, V: Eq> Ord for BTree<K, V> {\n     ///Returns an ordering based on the root nodes of each BTree.\n     fn cmp(&self, other: &BTree<K, V>) -> Ordering {\n         self.root.cmp(&other.root)\n     }\n }\n \n-impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for BTree<K, V> {\n+impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for BTree<K, V> {\n     ///Returns a string representation of the BTree\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.root.fmt(f)\n@@ -133,7 +133,7 @@ enum Node<K, V> {\n \n \n //Node functions/methods\n-impl<K: TotalOrd, V> Node<K, V> {\n+impl<K: Ord, V> Node<K, V> {\n     ///Creates a new leaf node given a vector of elements.\n     fn new_leaf(vec: Vec<LeafElt<K, V>>) -> Node<K,V> {\n         LeafNode(Leaf::new(vec))\n@@ -164,7 +164,7 @@ impl<K: TotalOrd, V> Node<K, V> {\n      }\n }\n \n-impl<K: Clone + TotalOrd, V: Clone> Node<K, V> {\n+impl<K: Clone + Ord, V: Clone> Node<K, V> {\n     ///Returns the corresponding value to the provided key.\n     ///get() is called in different ways on a branch or a leaf.\n     fn get(&self, k: K) -> Option<V> {\n@@ -183,7 +183,7 @@ impl<K: Clone + TotalOrd, V: Clone> Node<K, V> {\n     }\n }\n \n-impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V> {\n+impl<K: Clone + Ord, V: Clone> Clone for Node<K, V> {\n     ///Returns a new node based on whether or not it is a branch or a leaf.\n     fn clone(&self) -> Node<K, V> {\n         match *self {\n@@ -198,7 +198,7 @@ impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> PartialEq for Node<K, V> {\n+impl<K: Ord, V: Eq> PartialEq for Node<K, V> {\n     fn eq(&self, other: &Node<K, V>) -> bool {\n         match *self{\n             BranchNode(ref branch) => {\n@@ -220,16 +220,16 @@ impl<K: TotalOrd, V: TotalEq> PartialEq for Node<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalEq for Node<K, V> {}\n+impl<K: Ord, V: Eq> Eq for Node<K, V> {}\n \n-impl<K: TotalOrd, V: TotalEq> PartialOrd for Node<K, V> {\n+impl<K: Ord, V: Eq> PartialOrd for Node<K, V> {\n     fn lt(&self, other: &Node<K, V>) -> bool {\n         self.cmp(other) == Less\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalOrd for Node<K, V> {\n-    ///Implementation of TotalOrd for Nodes.\n+impl<K: Ord, V: Eq> Ord for Node<K, V> {\n+    ///Implementation of Ord for Nodes.\n     fn cmp(&self, other: &Node<K, V>) -> Ordering {\n         match *self {\n             LeafNode(ref leaf) => {\n@@ -248,7 +248,7 @@ impl<K: TotalOrd, V: TotalEq> TotalOrd for Node<K, V> {\n     }\n }\n \n-impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Node<K, V> {\n+impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for Node<K, V> {\n     ///Returns a string representation of a Node.\n     ///Will iterate over the Node and show \"Key: x, value: y, child: () // \"\n     ///for all elements in the Node. \"Child\" only exists if the Node contains\n@@ -275,7 +275,7 @@ struct Branch<K, V> {\n }\n \n \n-impl<K: TotalOrd, V> Leaf<K, V> {\n+impl<K: Ord, V> Leaf<K, V> {\n     ///Creates a new Leaf from a vector of LeafElts.\n     fn new(vec: Vec<LeafElt<K, V>>) -> Leaf<K, V> {\n         Leaf {\n@@ -335,7 +335,7 @@ impl<K: TotalOrd, V> Leaf<K, V> {\n }\n \n \n-impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V> {\n+impl<K: Clone + Ord, V: Clone> Leaf<K, V> {\n     ///Returns the corresponding value to the supplied key.\n     fn get(&self, k: K) -> Option<V> {\n         for s in self.elts.iter() {\n@@ -386,28 +386,28 @@ impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V> {\n     }\n }\n \n-impl<K: Clone + TotalOrd, V: Clone> Clone for Leaf<K, V> {\n+impl<K: Clone + Ord, V: Clone> Clone for Leaf<K, V> {\n     ///Returns a new Leaf with the same elts.\n     fn clone(&self) -> Leaf<K, V> {\n         Leaf::new(self.elts.clone())\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> PartialEq for Leaf<K, V> {\n+impl<K: Ord, V: Eq> PartialEq for Leaf<K, V> {\n     fn eq(&self, other: &Leaf<K, V>) -> bool {\n         self.elts == other.elts\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalEq for Leaf<K, V> {}\n+impl<K: Ord, V: Eq> Eq for Leaf<K, V> {}\n \n-impl<K: TotalOrd, V: TotalEq> PartialOrd for Leaf<K, V> {\n+impl<K: Ord, V: Eq> PartialOrd for Leaf<K, V> {\n     fn lt(&self, other: &Leaf<K, V>) -> bool {\n         self.cmp(other) == Less\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalOrd for Leaf<K, V> {\n+impl<K: Ord, V: Eq> Ord for Leaf<K, V> {\n     ///Returns an ordering based on the first element of each Leaf.\n     fn cmp(&self, other: &Leaf<K, V>) -> Ordering {\n         if self.elts.len() > other.elts.len() {\n@@ -421,7 +421,7 @@ impl<K: TotalOrd, V: TotalEq> TotalOrd for Leaf<K, V> {\n }\n \n \n-impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Leaf<K, V> {\n+impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for Leaf<K, V> {\n     ///Returns a string representation of a Leaf.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, s) in self.elts.iter().enumerate() {\n@@ -433,7 +433,7 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Leaf<K, V> {\n }\n \n \n-impl<K: TotalOrd, V> Branch<K, V> {\n+impl<K: Ord, V> Branch<K, V> {\n     ///Creates a new Branch from a vector of BranchElts and a rightmost child (a node).\n     fn new(vec: Vec<BranchElt<K, V>>, right: Box<Node<K, V>>)\n            -> Branch<K, V> {\n@@ -492,7 +492,7 @@ impl<K: TotalOrd, V> Branch<K, V> {\n     }\n }\n \n-impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n+impl<K: Clone + Ord, V: Clone> Branch<K, V> {\n     ///Returns the corresponding value to the supplied key.\n     ///If the key is not there, find the child that might hold it.\n     fn get(&self, k: K) -> Option<V> {\n@@ -616,28 +616,28 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n     }\n }\n \n-impl<K: Clone + TotalOrd, V: Clone> Clone for Branch<K, V> {\n+impl<K: Clone + Ord, V: Clone> Clone for Branch<K, V> {\n     ///Returns a new branch using the clone methods of the Branch's internal variables.\n     fn clone(&self) -> Branch<K, V> {\n         Branch::new(self.elts.clone(), self.rightmost_child.clone())\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> PartialEq for Branch<K, V> {\n+impl<K: Ord, V: Eq> PartialEq for Branch<K, V> {\n     fn eq(&self, other: &Branch<K, V>) -> bool {\n         self.elts == other.elts\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalEq for Branch<K, V> {}\n+impl<K: Ord, V: Eq> Eq for Branch<K, V> {}\n \n-impl<K: TotalOrd, V: TotalEq> PartialOrd for Branch<K, V> {\n+impl<K: Ord, V: Eq> PartialOrd for Branch<K, V> {\n     fn lt(&self, other: &Branch<K, V>) -> bool {\n         self.cmp(other) == Less\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalOrd for Branch<K, V> {\n+impl<K: Ord, V: Eq> Ord for Branch<K, V> {\n     ///Compares the first elements of two branches to determine an ordering\n     fn cmp(&self, other: &Branch<K, V>) -> Ordering {\n         if self.elts.len() > other.elts.len() {\n@@ -650,7 +650,7 @@ impl<K: TotalOrd, V: TotalEq> TotalOrd for Branch<K, V> {\n     }\n }\n \n-impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Branch<K, V> {\n+impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for Branch<K, V> {\n     ///Returns a string representation of a Branch.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, s) in self.elts.iter().enumerate() {\n@@ -674,7 +674,7 @@ struct BranchElt<K, V> {\n     value: V\n }\n \n-impl<K: TotalOrd, V> LeafElt<K, V> {\n+impl<K: Ord, V> LeafElt<K, V> {\n     ///Creates a new LeafElt from a supplied key-value pair.\n     fn new(k: K, v: V) -> LeafElt<K, V> {\n         LeafElt {\n@@ -684,42 +684,42 @@ impl<K: TotalOrd, V> LeafElt<K, V> {\n     }\n }\n \n-impl<K: Clone + TotalOrd, V: Clone> Clone for LeafElt<K, V> {\n+impl<K: Clone + Ord, V: Clone> Clone for LeafElt<K, V> {\n     ///Returns a new LeafElt by cloning the key and value.\n     fn clone(&self) -> LeafElt<K, V> {\n         LeafElt::new(self.key.clone(), self.value.clone())\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> PartialEq for LeafElt<K, V> {\n+impl<K: Ord, V: Eq> PartialEq for LeafElt<K, V> {\n     fn eq(&self, other: &LeafElt<K, V>) -> bool {\n         self.key == other.key && self.value == other.value\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalEq for LeafElt<K, V> {}\n+impl<K: Ord, V: Eq> Eq for LeafElt<K, V> {}\n \n-impl<K: TotalOrd, V: TotalEq> PartialOrd for LeafElt<K, V> {\n+impl<K: Ord, V: Eq> PartialOrd for LeafElt<K, V> {\n     fn lt(&self, other: &LeafElt<K, V>) -> bool {\n         self.cmp(other) == Less\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalOrd for LeafElt<K, V> {\n+impl<K: Ord, V: Eq> Ord for LeafElt<K, V> {\n     ///Returns an ordering based on the keys of the LeafElts.\n     fn cmp(&self, other: &LeafElt<K, V>) -> Ordering {\n         self.key.cmp(&other.key)\n     }\n }\n \n-impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for LeafElt<K, V> {\n+impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for LeafElt<K, V> {\n     ///Returns a string representation of a LeafElt.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Key: {}, value: {};\", self.key, self.value)\n     }\n }\n \n-impl<K: TotalOrd, V> BranchElt<K, V> {\n+impl<K: Ord, V> BranchElt<K, V> {\n     ///Creates a new BranchElt from a supplied key, value, and left child.\n     fn new(k: K, v: V, n: Box<Node<K, V>>) -> BranchElt<K, V> {\n         BranchElt {\n@@ -731,7 +731,7 @@ impl<K: TotalOrd, V> BranchElt<K, V> {\n }\n \n \n-impl<K: Clone + TotalOrd, V: Clone> Clone for BranchElt<K, V> {\n+impl<K: Clone + Ord, V: Clone> Clone for BranchElt<K, V> {\n     ///Returns a new BranchElt by cloning the key, value, and left child.\n     fn clone(&self) -> BranchElt<K, V> {\n         BranchElt::new(self.key.clone(),\n@@ -740,28 +740,28 @@ impl<K: Clone + TotalOrd, V: Clone> Clone for BranchElt<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> PartialEq for BranchElt<K, V>{\n+impl<K: Ord, V: Eq> PartialEq for BranchElt<K, V>{\n     fn eq(&self, other: &BranchElt<K, V>) -> bool {\n         self.key == other.key && self.value == other.value\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalEq for BranchElt<K, V>{}\n+impl<K: Ord, V: Eq> Eq for BranchElt<K, V>{}\n \n-impl<K: TotalOrd, V: TotalEq> PartialOrd for BranchElt<K, V> {\n+impl<K: Ord, V: Eq> PartialOrd for BranchElt<K, V> {\n     fn lt(&self, other: &BranchElt<K, V>) -> bool {\n         self.cmp(other) == Less\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> TotalOrd for BranchElt<K, V> {\n-    ///Fulfills TotalOrd for BranchElts\n+impl<K: Ord, V: Eq> Ord for BranchElt<K, V> {\n+    ///Fulfills Ord for BranchElts\n     fn cmp(&self, other: &BranchElt<K, V>) -> Ordering {\n         self.key.cmp(&other.key)\n     }\n }\n \n-impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for BranchElt<K, V> {\n+impl<K: fmt::Show + Ord, V: fmt::Show> fmt::Show for BranchElt<K, V> {\n     /// Returns string containing key, value, and child (which should recur to a\n     /// leaf) Consider changing in future to be more readable.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "014d4e680ee929158ddc18f7e586636f0e6acf24", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -388,7 +388,7 @@ impl<T> DList<T> {\n     }\n }\n \n-impl<T: TotalOrd> DList<T> {\n+impl<T: Ord> DList<T> {\n     /// Insert `elt` sorted in ascending order\n     ///\n     /// O(N)"}, {"sha": "78485321aa5b57143506f6e3ce032fd2f4566b60", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -15,7 +15,7 @@\n \n use std::num::Bitwise;\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n /// A specialized Set implementation to use enum types.\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set"}, {"sha": "4eacc3863065cd7d6b3ab73b91173e7891048c89", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -12,7 +12,7 @@\n \n use std::container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use std::clone::Clone;\n-use std::cmp::{PartialEq, TotalEq, Equiv, max};\n+use std::cmp::{PartialEq, Eq, Equiv, max};\n use std::default::Default;\n use std::fmt;\n use std::fmt::Show;\n@@ -733,7 +733,7 @@ fn grow_at(capacity: uint, load_factor: Fraction) -> uint {\n     fraction_mul(capacity, load_factor)\n }\n \n-impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Get the number of elements which will force the capacity to shrink.\n     /// When size == self.shrink_at(), we halve the capacity.\n     fn shrink_at(&self) -> uint {\n@@ -925,12 +925,12 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> Container for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Container for HashMap<K, V, H> {\n     /// Return the number of elements in the map\n     fn len(&self) -> uint { self.table.size() }\n }\n \n-impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         self.minimum_capacity = self.table.size();\n@@ -945,7 +945,7 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n }\n \n \n-impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n     fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n         self.search(k).map(|idx| {\n             let (_, v) = self.table.read(&idx);\n@@ -958,7 +958,7 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n     }\n }\n \n-impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H> {\n     fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n         match self.search(k) {\n             None => None,\n@@ -1027,7 +1027,7 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V\n \n }\n \n-impl<K: Hash + TotalEq, V> HashMap<K, V, sip::SipHasher> {\n+impl<K: Hash + Eq, V> HashMap<K, V, sip::SipHasher> {\n     /// Create an empty HashMap.\n     pub fn new() -> HashMap<K, V, sip::SipHasher> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n@@ -1042,7 +1042,7 @@ impl<K: Hash + TotalEq, V> HashMap<K, V, sip::SipHasher> {\n     }\n }\n \n-impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n         HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -1390,7 +1390,7 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-impl<K: TotalEq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Like `find`, but returns a copy of the value.\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n         self.find(k).map(|v| (*v).clone())\n@@ -1402,7 +1402,7 @@ impl<K: TotalEq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-impl<K: TotalEq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V, H> {\n     fn eq(&self, other: &HashMap<K, V, H>) -> bool {\n         if self.len() != other.len() { return false; }\n \n@@ -1416,7 +1416,7 @@ impl<K: TotalEq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<\n     }\n }\n \n-impl<K: TotalEq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, r\"\\{\"));\n \n@@ -1429,7 +1429,7 @@ impl<K: TotalEq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K,\n     }\n }\n \n-impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n     fn default() -> HashMap<K, V, H> {\n         HashMap::with_hasher(Default::default())\n     }\n@@ -1453,7 +1453,7 @@ pub type Keys<'a, K, V> =\n pub type Values<'a, K, V> =\n     iter::Map<'static, (&'a K, &'a V), &'a V, Entries<'a, K, V>>;\n \n-impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n     fn from_iter<T: Iterator<(K, V)>>(iter: T) -> HashMap<K, V, H> {\n         let (lower, _) = iter.size_hint();\n         let mut map = HashMap::with_capacity_and_hasher(lower, Default::default());\n@@ -1462,7 +1462,7 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> fo\n     }\n }\n \n-impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S> + Default> Extendable<(K, V)> for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Extendable<(K, V)> for HashMap<K, V, H> {\n     fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n@@ -1486,23 +1486,23 @@ pub struct HashSet<T, H = sip::SipHasher> {\n     map: HashMap<T, (), H>\n }\n \n-impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n     fn eq(&self, other: &HashSet<T, H>) -> bool {\n         if self.len() != other.len() { return false; }\n \n         self.iter().all(|key| other.contains(key))\n     }\n }\n \n-impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Container for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Container for HashSet<T, H> {\n     fn len(&self) -> uint { self.map.len() }\n }\n \n-impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n     fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n     fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n@@ -1514,13 +1514,13 @@ impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n     }\n }\n \n-impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n     fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n \n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n }\n \n-impl<T: Hash + TotalEq> HashSet<T, sip::SipHasher> {\n+impl<T: Hash + Eq> HashSet<T, sip::SipHasher> {\n     /// Create an empty HashSet\n     pub fn new() -> HashSet<T, sip::SipHasher> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n@@ -1533,7 +1533,7 @@ impl<T: Hash + TotalEq> HashSet<T, sip::SipHasher> {\n     }\n }\n \n-impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n         HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -1603,7 +1603,7 @@ impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     }\n }\n \n-impl<T: TotalEq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n+impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, r\"\\{\"));\n \n@@ -1616,7 +1616,7 @@ impl<T: TotalEq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T,\n     }\n }\n \n-impl<T: TotalEq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n     fn from_iter<I: Iterator<T>>(iter: I) -> HashSet<T, H> {\n         let (lower, _) = iter.size_hint();\n         let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n@@ -1625,15 +1625,15 @@ impl<T: TotalEq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSe\n     }\n }\n \n-impl<T: TotalEq + Hash<S>, S, H: Hasher<S> + Default> Extendable<T> for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Extendable<T> for HashSet<T, H> {\n     fn extend<I: Iterator<T>>(&mut self, mut iter: I) {\n         for k in iter {\n             self.insert(k);\n         }\n     }\n }\n \n-impl<T: TotalEq + Hash> Default for HashSet<T, sip::SipHasher> {\n+impl<T: Eq + Hash> Default for HashSet<T, sip::SipHasher> {\n     fn default() -> HashSet<T> { HashSet::new() }\n }\n \n@@ -1691,7 +1691,7 @@ mod test_map {\n \n     local_data_key!(drop_vector: RefCell<Vec<int>>)\n \n-    #[deriving(Hash, PartialEq, TotalEq)]\n+    #[deriving(Hash, PartialEq, Eq)]\n     struct Dropable {\n         k: uint\n     }"}, {"sha": "ea25eee06d0ffd5932a22b86fc83a6a76da9afa8", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -73,7 +73,7 @@ impl<K: PartialEq> PartialEq for KeyRef<K> {\n     }\n }\n \n-impl<K: TotalEq> TotalEq for KeyRef<K> {}\n+impl<K: Eq> Eq for KeyRef<K> {}\n \n impl<K, V> LruEntry<K, V> {\n     fn new(k: K, v: V) -> LruEntry<K, V> {\n@@ -86,7 +86,7 @@ impl<K, V> LruEntry<K, V> {\n     }\n }\n \n-impl<K: Hash + TotalEq, V> LruCache<K, V> {\n+impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// Create an LRU Cache that holds at most `capacity` items.\n     pub fn new(capacity: uint) -> LruCache<K, V> {\n         let cache = LruCache {\n@@ -201,7 +201,7 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n     }\n }\n \n-impl<A: fmt::Show + Hash + TotalEq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n+impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n     /// Return a string that lists the key-value pairs from most-recently\n     /// used to least-recently used.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -222,14 +222,14 @@ impl<A: fmt::Show + Hash + TotalEq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n     }\n }\n \n-impl<K: Hash + TotalEq, V> Container for LruCache<K, V> {\n+impl<K: Hash + Eq, V> Container for LruCache<K, V> {\n     /// Return the number of key-value pairs in the cache.\n     fn len(&self) -> uint {\n         self.map.len()\n     }\n }\n \n-impl<K: Hash + TotalEq, V> Mutable for LruCache<K, V> {\n+impl<K: Hash + Eq, V> Mutable for LruCache<K, V> {\n     /// Clear the cache of all key-value pairs.\n     fn clear(&mut self) {\n         self.map.clear();"}, {"sha": "3c1337a0382c89aa86e8ffc210c11155e89b09b7", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -22,17 +22,17 @@ pub struct PriorityQueue<T> {\n     data: Vec<T>,\n }\n \n-impl<T: TotalOrd> Container for PriorityQueue<T> {\n+impl<T: Ord> Container for PriorityQueue<T> {\n     /// Returns the length of the queue\n     fn len(&self) -> uint { self.data.len() }\n }\n \n-impl<T: TotalOrd> Mutable for PriorityQueue<T> {\n+impl<T: Ord> Mutable for PriorityQueue<T> {\n     /// Drop all items from the queue\n     fn clear(&mut self) { self.data.truncate(0) }\n }\n \n-impl<T: TotalOrd> PriorityQueue<T> {\n+impl<T: Ord> PriorityQueue<T> {\n     /// An iterator visiting all values in underlying vector, in\n     /// arbitrary order.\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n@@ -214,15 +214,15 @@ impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<T: TotalOrd> FromIterator<T> for PriorityQueue<T> {\n+impl<T: Ord> FromIterator<T> for PriorityQueue<T> {\n     fn from_iter<Iter: Iterator<T>>(iter: Iter) -> PriorityQueue<T> {\n         let mut q = PriorityQueue::new();\n         q.extend(iter);\n         q\n     }\n }\n \n-impl<T: TotalOrd> Extendable<T> for PriorityQueue<T> {\n+impl<T: Ord> Extendable<T> for PriorityQueue<T> {\n     fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();\n "}, {"sha": "1184c9b7b52bb6a41e9c46d2bde4b989f631c9bd", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -10,7 +10,7 @@\n \n //! An ordered map and set implemented as self-balancing binary search\n //! trees. The only requirement for the types is that the key implements\n-//! `TotalOrd`.\n+//! `Ord`.\n \n use std::cmp::Ordering;\n use std::fmt::Show;\n@@ -43,15 +43,15 @@ pub struct TreeMap<K, V> {\n     length: uint\n }\n \n-impl<K: PartialEq + TotalOrd, V: PartialEq> PartialEq for TreeMap<K, V> {\n+impl<K: PartialEq + Ord, V: PartialEq> PartialEq for TreeMap<K, V> {\n     fn eq(&self, other: &TreeMap<K, V>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a == b)\n     }\n }\n \n // Lexicographical comparison\n-fn lt<K: PartialOrd + TotalOrd, V: PartialOrd>(a: &TreeMap<K, V>,\n+fn lt<K: PartialOrd + Ord, V: PartialOrd>(a: &TreeMap<K, V>,\n                                  b: &TreeMap<K, V>) -> bool {\n     // the Zip iterator is as long as the shortest of a and b.\n     for ((key_a, value_a), (key_b, value_b)) in a.iter().zip(b.iter()) {\n@@ -64,12 +64,12 @@ fn lt<K: PartialOrd + TotalOrd, V: PartialOrd>(a: &TreeMap<K, V>,\n     a.len() < b.len()\n }\n \n-impl<K: PartialOrd + TotalOrd, V: PartialOrd> PartialOrd for TreeMap<K, V> {\n+impl<K: PartialOrd + Ord, V: PartialOrd> PartialOrd for TreeMap<K, V> {\n     #[inline]\n     fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n }\n \n-impl<K: TotalOrd + Show, V: Show> Show for TreeMap<K, V> {\n+impl<K: Ord + Show, V: Show> Show for TreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, r\"\\{\"));\n \n@@ -82,18 +82,18 @@ impl<K: TotalOrd + Show, V: Show> Show for TreeMap<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n+impl<K: Ord, V> Container for TreeMap<K, V> {\n     fn len(&self) -> uint { self.length }\n }\n \n-impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n+impl<K: Ord, V> Mutable for TreeMap<K, V> {\n     fn clear(&mut self) {\n         self.root = None;\n         self.length = 0\n     }\n }\n \n-impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n+impl<K: Ord, V> Map<K, V> for TreeMap<K, V> {\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n         let mut current: &'a Option<Box<TreeNode<K, V>>> = &self.root;\n         loop {\n@@ -111,7 +111,7 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V> MutableMap<K, V> for TreeMap<K, V> {\n+impl<K: Ord, V> MutableMap<K, V> for TreeMap<K, V> {\n     #[inline]\n     fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n         find_mut(&mut self.root, key)\n@@ -130,7 +130,7 @@ impl<K: TotalOrd, V> MutableMap<K, V> for TreeMap<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V> TreeMap<K, V> {\n+impl<K: Ord, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n@@ -216,7 +216,7 @@ macro_rules! bound_setup {\n }\n \n \n-impl<K: TotalOrd, V> TreeMap<K, V> {\n+impl<K: Ord, V> TreeMap<K, V> {\n     /// Get a lazy iterator that should be initialized using\n     /// `traverse_left`/`traverse_right`/`traverse_complete`.\n     fn iter_for_traversal<'a>(&'a self) -> Entries<'a, K, V> {\n@@ -546,23 +546,23 @@ impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n \n /// A implementation of the `Set` trait on top of the `TreeMap` container. The\n /// only requirement is that the type of the elements contained ascribes to the\n-/// `TotalOrd` trait.\n+/// `Ord` trait.\n #[deriving(Clone)]\n pub struct TreeSet<T> {\n     map: TreeMap<T, ()>\n }\n \n-impl<T: PartialEq + TotalOrd> PartialEq for TreeSet<T> {\n+impl<T: PartialEq + Ord> PartialEq for TreeSet<T> {\n     #[inline]\n     fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n }\n \n-impl<T: PartialOrd + TotalOrd> PartialOrd for TreeSet<T> {\n+impl<T: PartialOrd + Ord> PartialOrd for TreeSet<T> {\n     #[inline]\n     fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n }\n \n-impl<T: TotalOrd + Show> Show for TreeSet<T> {\n+impl<T: Ord + Show> Show for TreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, r\"\\{\"));\n \n@@ -575,17 +575,17 @@ impl<T: TotalOrd + Show> Show for TreeSet<T> {\n     }\n }\n \n-impl<T: TotalOrd> Container for TreeSet<T> {\n+impl<T: Ord> Container for TreeSet<T> {\n     #[inline]\n     fn len(&self) -> uint { self.map.len() }\n }\n \n-impl<T: TotalOrd> Mutable for TreeSet<T> {\n+impl<T: Ord> Mutable for TreeSet<T> {\n     #[inline]\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T: TotalOrd> Set<T> for TreeSet<T> {\n+impl<T: Ord> Set<T> for TreeSet<T> {\n     #[inline]\n     fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n@@ -620,15 +620,15 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n }\n \n-impl<T: TotalOrd> MutableSet<T> for TreeSet<T> {\n+impl<T: Ord> MutableSet<T> for TreeSet<T> {\n     #[inline]\n     fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n \n     #[inline]\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n }\n \n-impl<T: TotalOrd> TreeSet<T> {\n+impl<T: Ord> TreeSet<T> {\n     /// Create an empty TreeSet\n     #[inline]\n     pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n@@ -728,7 +728,7 @@ pub struct UnionItems<'a, T> {\n }\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt<T: TotalOrd>(x: Option<&T>, y: Option<&T>,\n+fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n                         short: Ordering, long: Ordering) -> Ordering {\n     match (x, y) {\n         (None    , _       ) => short,\n@@ -737,7 +737,7 @@ fn cmp_opt<T: TotalOrd>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n-impl<'a, T: TotalOrd> Iterator<&'a T> for DifferenceItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n@@ -749,7 +749,7 @@ impl<'a, T: TotalOrd> Iterator<&'a T> for DifferenceItems<'a, T> {\n     }\n }\n \n-impl<'a, T: TotalOrd> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n@@ -761,7 +761,7 @@ impl<'a, T: TotalOrd> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n     }\n }\n \n-impl<'a, T: TotalOrd> Iterator<&'a T> for IntersectionItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             let o_cmp = match (self.a.peek(), self.b.peek()) {\n@@ -779,7 +779,7 @@ impl<'a, T: TotalOrd> Iterator<&'a T> for IntersectionItems<'a, T> {\n     }\n }\n \n-impl<'a, T: TotalOrd> Iterator<&'a T> for UnionItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n@@ -803,7 +803,7 @@ struct TreeNode<K, V> {\n     level: uint\n }\n \n-impl<K: TotalOrd, V> TreeNode<K, V> {\n+impl<K: Ord, V> TreeNode<K, V> {\n     /// Creates a new tree node.\n     #[inline]\n     pub fn new(key: K, value: V) -> TreeNode<K, V> {\n@@ -812,7 +812,7 @@ impl<K: TotalOrd, V> TreeNode<K, V> {\n }\n \n // Remove left horizontal link by rotating right\n-fn skew<K: TotalOrd, V>(node: &mut Box<TreeNode<K, V>>) {\n+fn skew<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n     if node.left.as_ref().map_or(false, |x| x.level == node.level) {\n         let mut save = node.left.take_unwrap();\n         swap(&mut node.left, &mut save.right); // save.right now None\n@@ -823,7 +823,7 @@ fn skew<K: TotalOrd, V>(node: &mut Box<TreeNode<K, V>>) {\n \n // Remove dual horizontal link by rotating left and increasing level of\n // the parent\n-fn split<K: TotalOrd, V>(node: &mut Box<TreeNode<K, V>>) {\n+fn split<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n     if node.right.as_ref().map_or(false,\n       |x| x.right.as_ref().map_or(false, |y| y.level == node.level)) {\n         let mut save = node.right.take_unwrap();\n@@ -834,7 +834,7 @@ fn split<K: TotalOrd, V>(node: &mut Box<TreeNode<K, V>>) {\n     }\n }\n \n-fn find_mut<'r, K: TotalOrd, V>(node: &'r mut Option<Box<TreeNode<K, V>>>,\n+fn find_mut<'r, K: Ord, V>(node: &'r mut Option<Box<TreeNode<K, V>>>,\n                                 key: &K)\n                              -> Option<&'r mut V> {\n     match *node {\n@@ -849,7 +849,7 @@ fn find_mut<'r, K: TotalOrd, V>(node: &'r mut Option<Box<TreeNode<K, V>>>,\n     }\n }\n \n-fn insert<K: TotalOrd, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n+fn insert<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n                           key: K, value: V) -> Option<V> {\n     match *node {\n       Some(ref mut save) => {\n@@ -879,9 +879,9 @@ fn insert<K: TotalOrd, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n     }\n }\n \n-fn remove<K: TotalOrd, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n+fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n                           key: &K) -> Option<V> {\n-    fn heir_swap<K: TotalOrd, V>(node: &mut Box<TreeNode<K, V>>,\n+    fn heir_swap<K: Ord, V>(node: &mut Box<TreeNode<K, V>>,\n                                  child: &mut Option<Box<TreeNode<K, V>>>) {\n         // *could* be done without recursion, but it won't borrow check\n         for x in child.mut_iter() {\n@@ -962,15 +962,15 @@ fn remove<K: TotalOrd, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n     };\n }\n \n-impl<K: TotalOrd, V> FromIterator<(K, V)> for TreeMap<K, V> {\n+impl<K: Ord, V> FromIterator<(K, V)> for TreeMap<K, V> {\n     fn from_iter<T: Iterator<(K, V)>>(iter: T) -> TreeMap<K, V> {\n         let mut map = TreeMap::new();\n         map.extend(iter);\n         map\n     }\n }\n \n-impl<K: TotalOrd, V> Extendable<(K, V)> for TreeMap<K, V> {\n+impl<K: Ord, V> Extendable<(K, V)> for TreeMap<K, V> {\n     #[inline]\n     fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) {\n         for (k, v) in iter {\n@@ -979,15 +979,15 @@ impl<K: TotalOrd, V> Extendable<(K, V)> for TreeMap<K, V> {\n     }\n }\n \n-impl<T: TotalOrd> FromIterator<T> for TreeSet<T> {\n+impl<T: Ord> FromIterator<T> for TreeSet<T> {\n     fn from_iter<Iter: Iterator<T>>(iter: Iter) -> TreeSet<T> {\n         let mut set = TreeSet::new();\n         set.extend(iter);\n         set\n     }\n }\n \n-impl<T: TotalOrd> Extendable<T> for TreeSet<T> {\n+impl<T: Ord> Extendable<T> for TreeSet<T> {\n     #[inline]\n     fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n         for elem in iter {\n@@ -1070,7 +1070,7 @@ mod test_treemap {\n         assert_eq!(m.find(&k1), Some(&v1));\n     }\n \n-    fn check_equal<K: PartialEq + TotalOrd, V: PartialEq>(ctrl: &[(K, V)],\n+    fn check_equal<K: PartialEq + Ord, V: PartialEq>(ctrl: &[(K, V)],\n                                             map: &TreeMap<K, V>) {\n         assert_eq!(ctrl.is_empty(), map.is_empty());\n         for x in ctrl.iter() {\n@@ -1091,7 +1091,7 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_left<K: TotalOrd, V>(node: &Option<Box<TreeNode<K, V>>>,\n+    fn check_left<K: Ord, V>(node: &Option<Box<TreeNode<K, V>>>,\n                                   parent: &Box<TreeNode<K, V>>) {\n         match *node {\n           Some(ref r) => {\n@@ -1104,7 +1104,7 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_right<K: TotalOrd, V>(node: &Option<Box<TreeNode<K, V>>>,\n+    fn check_right<K: Ord, V>(node: &Option<Box<TreeNode<K, V>>>,\n                                    parent: &Box<TreeNode<K, V>>,\n                                    parent_red: bool) {\n         match *node {\n@@ -1121,7 +1121,7 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_structure<K: TotalOrd, V>(map: &TreeMap<K, V>) {\n+    fn check_structure<K: Ord, V>(map: &TreeMap<K, V>) {\n         match map.root {\n           Some(ref r) => {\n             check_left(&r.left, r);"}, {"sha": "ef00643177bef822c882103e10e887d6fd7dd844", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -37,9 +37,6 @@\n //! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n //! ```\n \n-pub use Eq = self::TotalEq;\n-pub use Ord = self::TotalOrd;\n-\n /// Trait for values that can be compared for equality and inequality.\n ///\n /// This trait allows partial equality, where types can be unordered instead of\n@@ -51,7 +48,7 @@ pub use Ord = self::TotalOrd;\n /// default.\n ///\n /// Eventually, this will be implemented by default for types that implement\n-/// `TotalEq`.\n+/// `Eq`.\n #[lang=\"eq\"]\n pub trait PartialEq {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n@@ -71,7 +68,7 @@ pub trait PartialEq {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n-pub trait TotalEq: PartialEq {\n+pub trait Eq: PartialEq {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n     // itself, the current deriving infrastructure means doing this\n@@ -104,7 +101,7 @@ pub enum Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n-pub trait TotalOrd: TotalEq + PartialOrd {\n+pub trait Ord: Eq + PartialOrd {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n     /// By convention, `self.cmp(&other)` returns the ordering matching\n@@ -118,9 +115,9 @@ pub trait TotalOrd: TotalEq + PartialOrd {\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n-impl TotalEq for Ordering {}\n+impl Eq for Ordering {}\n \n-impl TotalOrd for Ordering {\n+impl Ord for Ordering {\n     #[inline]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as int).cmp(&(*other as int))\n@@ -182,20 +179,20 @@ pub trait Equiv<T> {\n \n /// Compare and return the minimum of two values.\n #[inline]\n-pub fn min<T: TotalOrd>(v1: T, v2: T) -> T {\n+pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n /// Compare and return the maximum of two values.\n #[inline]\n-pub fn max<T: TotalOrd>(v1: T, v2: T) -> T {\n+pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n \n-// Implementation of PartialEq, TotalEq, PartialOrd and TotalOrd for primitive types\n+// Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\n #[cfg(not(test))]\n mod impls {\n-    use cmp::{PartialOrd, TotalOrd, PartialEq, TotalEq, Ordering,\n+    use cmp::{PartialOrd, Ord, PartialEq, Eq, Ordering,\n               Less, Greater, Equal};\n \n     macro_rules! eq_impl(\n@@ -220,7 +217,7 @@ mod impls {\n \n     macro_rules! totaleq_impl(\n         ($($t:ty)*) => ($(\n-            impl TotalEq for $t {}\n+            impl Eq for $t {}\n         )*)\n     )\n \n@@ -257,7 +254,7 @@ mod impls {\n \n     macro_rules! totalord_impl(\n         ($($t:ty)*) => ($(\n-            impl TotalOrd for $t {\n+            impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n                     if *self < *other { Less }\n@@ -268,12 +265,12 @@ mod impls {\n         )*)\n     )\n \n-    impl TotalOrd for () {\n+    impl Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering { Equal }\n     }\n \n-    impl TotalOrd for bool {\n+    impl Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n             (*self as u8).cmp(&(*other as u8))\n@@ -299,11 +296,11 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: & &'a T) -> bool { *(*self) > *(*other) }\n     }\n-    impl<'a, T: TotalOrd> TotalOrd for &'a T {\n+    impl<'a, T: Ord> Ord for &'a T {\n         #[inline]\n         fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }\n     }\n-    impl<'a, T: TotalEq> TotalEq for &'a T {}\n+    impl<'a, T: Eq> Eq for &'a T {}\n \n     // &mut pointers\n     impl<'a, T: PartialEq> PartialEq for &'a mut T {\n@@ -322,11 +319,11 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: &&'a mut T) -> bool { **self > **other }\n     }\n-    impl<'a, T: TotalOrd> TotalOrd for &'a mut T {\n+    impl<'a, T: Ord> Ord for &'a mut T {\n         #[inline]\n         fn cmp(&self, other: &&'a mut T) -> Ordering { (**self).cmp(*other) }\n     }\n-    impl<'a, T: TotalEq> TotalEq for &'a mut T {}\n+    impl<'a, T: Eq> Eq for &'a mut T {}\n \n     // @ pointers\n     impl<T:PartialEq> PartialEq for @T {\n@@ -345,11 +342,11 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n     }\n-    impl<T: TotalOrd> TotalOrd for @T {\n+    impl<T: Ord> Ord for @T {\n         #[inline]\n         fn cmp(&self, other: &@T) -> Ordering { (**self).cmp(*other) }\n     }\n-    impl<T: TotalEq> TotalEq for @T {}\n+    impl<T: Eq> Eq for @T {}\n }\n \n #[cfg(test)]"}, {"sha": "35c8afee4b6be8c129ec9dbb40348aae47c82026", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -550,7 +550,7 @@ extern \"rust-intrinsic\" {\n /// `TypeId` represents a globally unique identifier for a type\n #[lang=\"type_id\"] // This needs to be kept in lockstep with the code in trans/intrinsic.rs and\n                   // middle/lang_items.rs\n-#[deriving(PartialEq, TotalEq, Show)]\n+#[deriving(PartialEq, Eq, Show)]\n #[cfg(not(test))]\n pub struct TypeId {\n     t: u64,"}, {"sha": "875c852d8ae61c3c40a92ff2a16bf805aa25eae5", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -68,7 +68,7 @@ use cmp;\n use num::{Zero, One, CheckedAdd, CheckedSub, Saturating, ToPrimitive, Int};\n use option::{Option, Some, None};\n use ops::{Add, Mul, Sub};\n-use cmp::{PartialEq, PartialOrd, TotalOrd};\n+use cmp::{PartialEq, PartialOrd, Ord};\n use clone::Clone;\n use uint;\n use mem;\n@@ -611,7 +611,7 @@ pub trait Iterator<A> {\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    fn max_by<B: TotalOrd>(&mut self, f: |&A| -> B) -> Option<A> {\n+    fn max_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> {\n         self.fold(None, |max: Option<(A, B)>, x| {\n             let x_val = f(&x);\n             match max {\n@@ -635,7 +635,7 @@ pub trait Iterator<A> {\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    fn min_by<B: TotalOrd>(&mut self, f: |&A| -> B) -> Option<A> {\n+    fn min_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> {\n         self.fold(None, |min: Option<(A, B)>, x| {\n             let x_val = f(&x);\n             match min {\n@@ -905,7 +905,7 @@ pub trait OrdIterator<A> {\n     fn min_max(&mut self) -> MinMaxResult<A>;\n }\n \n-impl<A: TotalOrd, T: Iterator<A>> OrdIterator<A> for T {\n+impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n     #[inline]\n     fn max(&mut self) -> Option<A> {\n         self.fold(None, |max, x| {\n@@ -2182,12 +2182,12 @@ impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n /// the shorter sequence compares less.\n pub mod order {\n     use cmp;\n-    use cmp::{TotalEq, TotalOrd, PartialOrd, PartialEq};\n+    use cmp::{Eq, Ord, PartialOrd, PartialEq};\n     use option::{Some, None};\n     use super::Iterator;\n \n-    /// Compare `a` and `b` for equality using `TotalEq`\n-    pub fn equals<A: TotalEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    /// Compare `a` and `b` for equality using `Eq`\n+    pub fn equals<A: Eq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2197,8 +2197,8 @@ pub mod order {\n         }\n     }\n \n-    /// Order `a` and `b` lexicographically using `TotalOrd`\n-    pub fn cmp<A: TotalOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> cmp::Ordering {\n+    /// Order `a` and `b` lexicographically using `Ord`\n+    pub fn cmp<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> cmp::Ordering {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return cmp::Equal,"}, {"sha": "b91a8cebdedbff22daacc4a112c79cb13d68f650", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -141,14 +141,14 @@\n //! }\n //! ```\n \n-use cmp::{PartialEq, TotalEq, TotalOrd};\n+use cmp::{PartialEq, Eq, Ord};\n use default::Default;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n use mem;\n use slice;\n \n /// The `Option`\n-#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show)]\n pub enum Option<T> {\n     /// No value\n     None,"}, {"sha": "a6a8319ca02a5b2c965b2d480df7f7bb048516bd", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -45,7 +45,7 @@ pub use mem::drop;\n \n pub use char::Char;\n pub use clone::Clone;\n-pub use cmp::{PartialEq, PartialOrd, TotalEq, TotalOrd};\n+pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n pub use cmp::{Ordering, Less, Equal, Greater, Equiv};\n pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n pub use iter::{FromIterator, Extendable};\n@@ -59,6 +59,6 @@ pub use str::{Str, StrSlice};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n-pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector};\n+pub use slice::{ImmutableEqVector, ImmutableOrdVector};\n pub use slice::{MutableVector};\n pub use slice::{Vector, ImmutableVector};"}, {"sha": "dacbba61856be8a24f9c7b79a517482a62befe03", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -93,7 +93,7 @@ use intrinsics;\n use iter::{range, Iterator};\n use option::{Some, None, Option};\n \n-#[cfg(not(test))] use cmp::{PartialEq, TotalEq, PartialOrd, Equiv};\n+#[cfg(not(test))] use cmp::{PartialEq, Eq, PartialOrd, Equiv};\n \n /// Return the offset of the first null pointer in `buf`.\n #[inline]\n@@ -396,7 +396,7 @@ impl<T> PartialEq for *T {\n }\n \n #[cfg(not(test))]\n-impl<T> TotalEq for *T {}\n+impl<T> Eq for *T {}\n \n #[cfg(not(test))]\n impl<T> PartialEq for *mut T {\n@@ -409,7 +409,7 @@ impl<T> PartialEq for *mut T {\n }\n \n #[cfg(not(test))]\n-impl<T> TotalEq for *mut T {}\n+impl<T> Eq for *mut T {}\n \n // Equivalence for pointers\n #[cfg(not(test))]"}, {"sha": "c19c5d3145ade2d0ecd56f193389a59ee0f937e3", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -283,7 +283,7 @@ use option::{None, Option, Some};\n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n /// See the [`std::result`](index.html) module documentation for details.\n-#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show)]\n #[must_use]\n pub enum Result<T, E> {\n     /// Contains the success value"}, {"sha": "5673d0c020d7ff75a8954c4b92afc4c375867324", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -17,7 +17,7 @@\n use mem::transmute;\n use clone::Clone;\n use container::Container;\n-use cmp::{PartialEq, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{PartialEq, Ord, Ordering, Less, Equal, Greater};\n use cmp;\n use default::Default;\n use iter::*;\n@@ -251,7 +251,7 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n pub mod traits {\n     use super::*;\n \n-    use cmp::{PartialEq, PartialOrd, TotalEq, TotalOrd, Ordering, Equiv};\n+    use cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering, Equiv};\n     use iter::{order, Iterator};\n     use container::Container;\n \n@@ -273,9 +273,9 @@ pub mod traits {\n         fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n     }\n \n-    impl<'a,T:TotalEq> TotalEq for &'a [T] {}\n+    impl<'a,T:Eq> Eq for &'a [T] {}\n \n-    impl<T:TotalEq> TotalEq for ~[T] {}\n+    impl<T:Eq> Eq for ~[T] {}\n \n     impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for &'a [T] {\n         #[inline]\n@@ -287,13 +287,13 @@ pub mod traits {\n         fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n     }\n \n-    impl<'a,T:TotalOrd> TotalOrd for &'a [T] {\n+    impl<'a,T:Ord> Ord for &'a [T] {\n         fn cmp(&self, other: & &'a [T]) -> Ordering {\n             order::cmp(self.iter(), other.iter())\n         }\n     }\n \n-    impl<T: TotalOrd> TotalOrd for ~[T] {\n+    impl<T: Ord> Ord for ~[T] {\n         #[inline]\n         fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n     }\n@@ -741,8 +741,8 @@ impl<'a,T:PartialEq> ImmutableEqVector<T> for &'a [T] {\n     }\n }\n \n-/// Extension methods for vectors containing `TotalOrd` elements.\n-pub trait ImmutableTotalOrdVector<T: TotalOrd> {\n+/// Extension methods for vectors containing `Ord` elements.\n+pub trait ImmutableOrdVector<T: Ord> {\n     /**\n      * Binary search a sorted vector for a given element.\n      *\n@@ -751,7 +751,7 @@ pub trait ImmutableTotalOrdVector<T: TotalOrd> {\n     fn bsearch_elem(&self, x: &T) -> Option<uint>;\n }\n \n-impl<'a, T: TotalOrd> ImmutableTotalOrdVector<T> for &'a [T] {\n+impl<'a, T: Ord> ImmutableOrdVector<T> for &'a [T] {\n     fn bsearch_elem(&self, x: &T) -> Option<uint> {\n         self.bsearch(|p| p.cmp(x))\n     }"}, {"sha": "c83b1d09283bb26d9ab38c15ed24005fe581a2be", "filename": "src/libcore/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -18,7 +18,7 @@ use mem;\n use char;\n use clone::Clone;\n use cmp;\n-use cmp::{PartialEq, TotalEq};\n+use cmp::{PartialEq, Eq};\n use container::Container;\n use default::Default;\n use iter::{Filter, Map, Iterator};\n@@ -698,7 +698,7 @@ pub struct Utf16Items<'a> {\n     iter: slice::Items<'a, u16>\n }\n /// The possibilities for values decoded from a `u16` stream.\n-#[deriving(PartialEq, TotalEq, Clone, Show)]\n+#[deriving(PartialEq, Eq, Clone, Show)]\n pub enum Utf16Item {\n     /// A valid codepoint.\n     ScalarValue(char),\n@@ -932,12 +932,12 @@ Section: Trait implementations\n #[allow(missing_doc)]\n pub mod traits {\n     use container::Container;\n-    use cmp::{TotalOrd, Ordering, Less, Equal, Greater, PartialEq, PartialOrd, Equiv, TotalEq};\n+    use cmp::{Ord, Ordering, Less, Equal, Greater, PartialEq, PartialOrd, Equiv, Eq};\n     use iter::Iterator;\n     use option::{Some, None};\n     use str::{Str, StrSlice, eq_slice};\n \n-    impl<'a> TotalOrd for &'a str {\n+    impl<'a> Ord for &'a str {\n         #[inline]\n         fn cmp(&self, other: & &'a str) -> Ordering {\n             for (s_b, o_b) in self.bytes().zip(other.bytes()) {\n@@ -961,7 +961,7 @@ pub mod traits {\n         fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }\n     }\n \n-    impl<'a> TotalEq for &'a str {}\n+    impl<'a> Eq for &'a str {}\n \n     impl<'a> PartialOrd for &'a str {\n         #[inline]"}, {"sha": "c8cbd49aa890d3d893a16d381bb88cd3b7bd71ee", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -28,9 +28,9 @@\n //!\n //! * `Clone`\n //! * `PartialEq`\n-//! * `TotalEq`\n+//! * `Eq`\n //! * `PartialOrd`\n-//! * `TotalOrd`\n+//! * `Ord`\n //! * `Default`\n //!\n //! # Examples\n@@ -123,7 +123,7 @@ macro_rules! tuple_impls {\n             }\n \n             #[cfg(not(test))]\n-            impl<$($T:TotalEq),+> TotalEq for ($($T,)+) {}\n+            impl<$($T:Eq),+> Eq for ($($T,)+) {}\n \n             #[cfg(not(test))]\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n@@ -146,7 +146,7 @@ macro_rules! tuple_impls {\n             }\n \n             #[cfg(not(test))]\n-            impl<$($T:TotalOrd),+> TotalOrd for ($($T,)+) {\n+            impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                     lexical_cmp!($(self.$refN(), other.$refN()),+)\n@@ -364,7 +364,7 @@ mod tests {\n         assert!(((1.0, 2.0) < (2.0, nan)));\n         assert!(!((2.0, 2.0) < (2.0, nan)));\n \n-        // TotalOrd\n+        // Ord\n         assert!(small.cmp(&small) == Equal);\n         assert!(big.cmp(&big) == Equal);\n         assert!(small.cmp(&big) == Less);"}, {"sha": "28adfa86ccfd43eb670bdeb0fe2886f04730d7dc", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -146,7 +146,7 @@ pub enum Method<'a> {\n }\n \n /// A selector for what pluralization a plural method should take\n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub enum PluralSelector {\n     /// One of the plural keywords should be used\n     Keyword(PluralKeyword),\n@@ -168,7 +168,7 @@ pub struct PluralArm<'a> {\n /// is specially placed in the `Plural` variant of `Method`.\n ///\n /// http://www.icu-project.org/apiref/icu4c/classicu_1_1PluralRules.html\n-#[deriving(PartialEq, TotalEq, Hash, Show)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n #[allow(missing_doc)]\n pub enum PluralKeyword {\n     /// The plural form for zero objects."}, {"sha": "86753fbb811cb4c6841f52eca734cea7e8a82007", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -198,12 +198,12 @@ fn list_dir_sorted(path: &Path) -> Option<Vec<Path>> {\n /**\n  * A compiled Unix shell style pattern.\n  */\n-#[deriving(Clone, PartialEq, TotalEq, PartialOrd, TotalOrd, Hash, Default)]\n+#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]\n pub struct Pattern {\n     tokens: Vec<PatternToken>,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, PartialOrd, TotalOrd, Hash)]\n+#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n enum PatternToken {\n     Char(char),\n     AnyChar,\n@@ -212,7 +212,7 @@ enum PatternToken {\n     AnyExcept(Vec<CharSpecifier> )\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, PartialOrd, TotalOrd, Hash)]\n+#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n enum CharSpecifier {\n     SingleChar(char),\n     CharRange(char, char)\n@@ -596,7 +596,7 @@ fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n /**\n  * Configuration options to modify the behaviour of `Pattern::matches_with(..)`\n  */\n-#[deriving(Clone, PartialEq, TotalEq, PartialOrd, TotalOrd, Hash, Default)]\n+#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]\n pub struct MatchOptions {\n \n     /**"}, {"sha": "4a848535b8da2db941796f36dbf9202d2e00f99c", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -89,7 +89,7 @@ impl PartialEq for BigUint {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n-impl TotalEq for BigUint {}\n+impl Eq for BigUint {}\n \n impl PartialOrd for BigUint {\n     #[inline]\n@@ -98,7 +98,7 @@ impl PartialOrd for BigUint {\n     }\n }\n \n-impl TotalOrd for BigUint {\n+impl Ord for BigUint {\n     #[inline]\n     fn cmp(&self, other: &BigUint) -> Ordering {\n         let (s_len, o_len) = (self.data.len(), other.data.len());\n@@ -786,7 +786,7 @@ fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) {\n }\n \n /// A Sign is a `BigInt`'s composing element.\n-#[deriving(PartialEq, PartialOrd, TotalEq, TotalOrd, Clone, Show)]\n+#[deriving(PartialEq, PartialOrd, Eq, Ord, Clone, Show)]\n pub enum Sign { Minus, Zero, Plus }\n \n impl Neg<Sign> for Sign {\n@@ -815,7 +815,7 @@ impl PartialEq for BigInt {\n     }\n }\n \n-impl TotalEq for BigInt {}\n+impl Eq for BigInt {}\n \n impl PartialOrd for BigInt {\n     #[inline]\n@@ -824,7 +824,7 @@ impl PartialOrd for BigInt {\n     }\n }\n \n-impl TotalOrd for BigInt {\n+impl Ord for BigInt {\n     #[inline]\n     fn cmp(&self, other: &BigInt) -> Ordering {\n         let scmp = self.sign.cmp(&other.sign);"}, {"sha": "3efc359fd3fb343f600e851692b5fb96a92f9293", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -194,8 +194,8 @@ macro_rules! cmp_impl {\n }\n cmp_impl!(impl PartialEq, eq, ne)\n cmp_impl!(impl PartialOrd, lt, gt, le, ge)\n-cmp_impl!(impl TotalEq, )\n-cmp_impl!(impl TotalOrd, cmp -> cmp::Ordering)\n+cmp_impl!(impl Eq, )\n+cmp_impl!(impl Ord, cmp -> cmp::Ordering)\n \n /* Arithmetic */\n // a/b * c/d = (a*c)/(b*d)"}, {"sha": "546182aac34e2f5a817dd40b72e7be2ca2999f1f", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -45,7 +45,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::crateid::CrateId;\n use syntax::parse::token;\n \n-#[deriving(Clone, PartialEq, PartialOrd, TotalOrd, TotalEq)]\n+#[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n pub enum OutputType {\n     OutputTypeBitcode,\n     OutputTypeAssembly,"}, {"sha": "e22de8d235cb967286827ee00c0833ed962fe109", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -132,7 +132,7 @@ pub enum EntryFnType {\n     EntryNone,\n }\n \n-#[deriving(PartialEq, PartialOrd, Clone, TotalOrd, TotalEq, Hash)]\n+#[deriving(PartialEq, PartialOrd, Clone, Ord, Eq, Hash)]\n pub enum CrateType {\n     CrateTypeExecutable,\n     CrateTypeDylib,"}, {"sha": "ce111d3ae29481f495a52bf1164db6de52407d37", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -188,13 +188,13 @@ pub struct Loan {\n     cause: euv::LoanCause,\n }\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub enum LoanPath {\n     LpVar(ast::NodeId),               // `x` in doc.rs\n     LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)\n }\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub enum LoanPathElem {\n     LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs"}, {"sha": "c3fcf037b26d6df916861c971051c1004d27a543", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -42,7 +42,7 @@ macro_rules! lets_do_this {\n         $( $variant:ident, $name:expr, $method:ident; )*\n     ) => {\n \n-#[deriving(FromPrimitive, PartialEq, TotalEq, Hash)]\n+#[deriving(FromPrimitive, PartialEq, Eq, Hash)]\n pub enum LangItem {\n     $($variant),*\n }"}, {"sha": "a195e23e6ba75b34f76b867cdcd7e393f33de505", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -72,7 +72,7 @@ use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::{ast, ast_util, visit};\n \n-#[deriving(Clone, Show, PartialEq, PartialOrd, TotalEq, TotalOrd, Hash)]\n+#[deriving(Clone, Show, PartialEq, PartialOrd, Eq, Ord, Hash)]\n pub enum Lint {\n     CTypes,\n     UnusedImports,\n@@ -135,12 +135,12 @@ pub fn level_to_str(lv: Level) -> &'static str {\n     }\n }\n \n-#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n pub enum Level {\n     Allow, Warn, Deny, Forbid\n }\n \n-#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n pub struct LintSpec {\n     pub default: Level,\n     pub lint: Lint,"}, {"sha": "e6b48f024833452ddfc87be1df10a9ae0cd02ded", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -99,7 +99,7 @@ pub struct CopiedUpvar {\n }\n \n // different kinds of pointers:\n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum PointerKind {\n     OwnedPtr,\n     GcPtr,\n@@ -109,26 +109,26 @@ pub enum PointerKind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(ElementKind),\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum FieldName {\n     NamedField(ast::Name),\n     PositionalField(uint)\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum ElementKind {\n     VecElement,\n     StrElement,\n     OtherElement,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable."}, {"sha": "f50a2090c2317e740f9073db48735c428052830a", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -109,7 +109,7 @@ enum PatternBindingMode {\n     ArgumentIrrefutableMode,\n }\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n enum Namespace {\n     TypeNS,\n     ValueNS"}, {"sha": "1142b67fdbfad55dadcb7e8ee79c69c73b7e0757", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -82,7 +82,7 @@ impl Drop for Rvalue {\n     fn drop(&mut self) { }\n }\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub enum RvalueMode {\n     /// `val` is a pointer to the actual value (and thus has type *T)\n     ByRef,"}, {"sha": "913f333b0f31a3b566c7782e9f684828bc5332b3", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -312,14 +312,14 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n }\n \n // Used to identify cached monomorphized functions and vtables\n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub struct MonoParamId {\n     pub subst: ty::t,\n     // Do we really need the vtables to be hashed? Isn't the type enough?\n     pub vtables: Vec<MonoId>\n }\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub struct MonoId {\n     pub def: ast::DefId,\n     pub params: Vec<MonoParamId>"}, {"sha": "1ee7ddb54834070de2a6ead240a90ae2293bef9f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -65,7 +65,7 @@ pub static INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n // Data types\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub struct field {\n     pub ident: ast::Ident,\n     pub mt: mt\n@@ -121,13 +121,13 @@ impl Method {\n     }\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct mt {\n     pub ty: t,\n     pub mutbl: ast::Mutability,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub enum TraitStore {\n     /// Box<Trait>\n     UniqTraitStore,\n@@ -145,7 +145,7 @@ pub struct field_ty {\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub struct creader_cache_key {\n     pub cnum: CrateNum,\n     pub pos: uint,\n@@ -172,7 +172,7 @@ impl cmp::PartialEq for intern_key {\n     }\n }\n \n-impl TotalEq for intern_key {}\n+impl Eq for intern_key {}\n \n impl<W:Writer> Hash<W> for intern_key {\n     fn hash(&self, s: &mut W) {\n@@ -387,7 +387,7 @@ pub struct t_box_ {\n enum t_opaque {}\n \n #[allow(raw_pointer_deriving)]\n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct t { inner: *t_opaque }\n \n impl fmt::Show for t {\n@@ -415,14 +415,14 @@ pub fn type_needs_infer(t: t) -> bool {\n }\n pub fn type_id(t: t) -> uint { get(t).id }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct BareFnTy {\n     pub fn_style: ast::FnStyle,\n     pub abi: abi::Abi,\n     pub sig: FnSig,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct ClosureTy {\n     pub fn_style: ast::FnStyle,\n     pub onceness: ast::Onceness,\n@@ -443,22 +443,22 @@ pub struct ClosureTy {\n  * - `output` is the return type.\n  * - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n  */\n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct FnSig {\n     pub binder_id: ast::NodeId,\n     pub inputs: Vec<t>,\n     pub output: t,\n     pub variadic: bool\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct param_ty {\n     pub idx: uint,\n     pub def_id: DefId\n }\n \n /// Representation of regions:\n-#[deriving(Clone, PartialEq, TotalEq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -499,13 +499,13 @@ pub enum Region {\n  * the original var id (that is, the root variable that is referenced\n  * by the upvar) and the id of the closure expression.\n  */\n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct UpvarId {\n     pub var_id: ast::NodeId,\n     pub closure_expr_id: ast::NodeId,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -618,13 +618,13 @@ impl Region {\n     }\n }\n \n-#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n pub struct FreeRegion {\n     pub scope_id: NodeId,\n     pub bound_region: BoundRegion\n }\n \n-#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(uint),\n@@ -643,7 +643,7 @@ pub enum BoundRegion {\n  * Represents the values to use when substituting lifetime parameters.\n  * If the value is `ErasedRegions`, then this subst is occurring during\n  * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum RegionSubsts {\n     ErasedRegions,\n     NonerasedRegions(OwnedSlice<ty::Region>)\n@@ -666,7 +666,7 @@ pub enum RegionSubsts {\n  * - `self_ty` is the type to which `self` should be remapped, if any.  The\n  *   `self` type is rather funny in that it can only appear on traits and is\n  *   always substituted away to the implementing type for a trait. */\n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct substs {\n     pub self_ty: Option<ty::t>,\n     pub tps: Vec<t>,\n@@ -722,7 +722,7 @@ mod primitives {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum sty {\n     ty_nil,\n     ty_bot,\n@@ -754,15 +754,15 @@ pub enum sty {\n             // on non-useful type error messages)\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct TyTrait {\n     pub def_id: DefId,\n     pub substs: substs,\n     pub store: TraitStore,\n     pub bounds: BuiltinBounds\n }\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub struct TraitRef {\n     pub def_id: DefId,\n     pub substs: substs\n@@ -822,15 +822,15 @@ pub enum type_err {\n     terr_variadic_mismatch(expected_found<bool>)\n }\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub struct ParamBounds {\n     pub builtin_bounds: BuiltinBounds,\n     pub trait_bounds: Vec<Rc<TraitRef>>\n }\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n-#[deriving(Clone, Encodable, PartialEq, TotalEq, Decodable, Hash, Show)]\n+#[deriving(Clone, Encodable, PartialEq, Eq, Decodable, Hash, Show)]\n #[repr(uint)]\n pub enum BuiltinBound {\n     BoundStatic,\n@@ -862,28 +862,28 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct TyVid(pub uint);\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct IntVid(pub uint);\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct FloatVid(pub uint);\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct RegionVid {\n     pub id: uint\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n     FloatVar(FloatVid)\n }\n \n-#[deriving(Clone, Encodable, Decodable, TotalEq, Hash, Show)]\n+#[deriving(Clone, Encodable, Decodable, Eq, Hash, Show)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, BoundRegion)"}, {"sha": "db551923622575218476730394243fa1131dcd08", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -31,15 +31,15 @@ use syntax::ast;\n \n mod doc;\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub enum Constraint {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n     ConstrainRegSubVar(Region, RegionVid),\n     ConstrainVarSubReg(RegionVid, Region),\n     ConstrainRegSubReg(Region, Region),\n }\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub struct TwoRegions {\n     a: Region,\n     b: Region,"}, {"sha": "b3cabbfb7e20bf4f1e358b19abab500f694ce069", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -147,7 +147,7 @@ pub struct MethodCallee {\n     pub substs: ty::substs\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct MethodCall {\n     pub expr_id: ast::NodeId,\n     pub autoderef: u32"}, {"sha": "06454adfb86aad2cddd367c6d80292e9af39f5c3", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -28,14 +28,14 @@ pub type DefIdSet = FnvHashSet<ast::DefId>;\n pub mod FnvHashMap {\n     use std::hash::Hash;\n     use collections::HashMap;\n-    pub fn new<K: Hash<super::FnvState> + TotalEq, V>() -> super::FnvHashMap<K, V> {\n+    pub fn new<K: Hash<super::FnvState> + Eq, V>() -> super::FnvHashMap<K, V> {\n         HashMap::with_hasher(super::FnvHasher)\n     }\n }\n pub mod FnvHashSet {\n     use std::hash::Hash;\n     use collections::HashSet;\n-    pub fn new<V: Hash<super::FnvState> + TotalEq>() -> super::FnvHashSet<V> {\n+    pub fn new<V: Hash<super::FnvState> + Eq>() -> super::FnvHashSet<V> {\n         HashSet::with_hasher(super::FnvHasher)\n     }\n }"}, {"sha": "35f1a89e87125fd7034f51230ea1a16d4db2ea49", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -1028,7 +1028,7 @@ pub enum Type {\n     // region, raw, other boxes, mutable\n }\n \n-#[deriving(Clone, Encodable, Decodable, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash)]\n pub enum Primitive {\n     Int, I8, I16, I32, I64,\n     Uint, U8, U16, U32, U64,"}, {"sha": "04cd861d687250d50c4dd2b72dd1ac464be558d6", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -76,7 +76,7 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for RingBuf<T> {\n impl<\n     E,\n     S: Encoder<E>,\n-    K: Encodable<S, E> + PartialEq + TotalOrd,\n+    K: Encodable<S, E> + PartialEq + Ord,\n     V: Encodable<S, E> + PartialEq\n > Encodable<S, E> for TreeMap<K, V> {\n     fn encode(&self, e: &mut S) -> Result<(), E> {\n@@ -95,7 +95,7 @@ impl<\n impl<\n     E,\n     D: Decoder<E>,\n-    K: Decodable<D, E> + PartialEq + TotalOrd,\n+    K: Decodable<D, E> + PartialEq + Ord,\n     V: Decodable<D, E> + PartialEq\n > Decodable<D, E> for TreeMap<K, V> {\n     fn decode(d: &mut D) -> Result<TreeMap<K, V>, E> {\n@@ -114,7 +114,7 @@ impl<\n impl<\n     E,\n     S: Encoder<E>,\n-    T: Encodable<S, E> + PartialEq + TotalOrd\n+    T: Encodable<S, E> + PartialEq + Ord\n > Encodable<S, E> for TreeSet<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n@@ -131,7 +131,7 @@ impl<\n impl<\n     E,\n     D: Decoder<E>,\n-    T: Decodable<D, E> + PartialEq + TotalOrd\n+    T: Decodable<D, E> + PartialEq + Ord\n > Decodable<D, E> for TreeSet<T> {\n     fn decode(d: &mut D) -> Result<TreeSet<T>, E> {\n         d.read_seq(|d, len| {\n@@ -178,7 +178,7 @@ impl<\n impl<\n     E,\n     S: Encoder<E>,\n-    K: Encodable<S, E> + Hash<X> + TotalEq,\n+    K: Encodable<S, E> + Hash<X> + Eq,\n     V: Encodable<S, E>,\n     X,\n     H: Hasher<X>\n@@ -199,7 +199,7 @@ impl<\n impl<\n     E,\n     D: Decoder<E>,\n-    K: Decodable<D, E> + Hash<S> + TotalEq,\n+    K: Decodable<D, E> + Hash<S> + Eq,\n     V: Decodable<D, E>,\n     S,\n     H: Hasher<S> + Default\n@@ -221,7 +221,7 @@ impl<\n impl<\n     E,\n     S: Encoder<E>,\n-    T: Encodable<S, E> + Hash<X> + TotalEq,\n+    T: Encodable<S, E> + Hash<X> + Eq,\n     X,\n     H: Hasher<X>\n > Encodable<S, E> for HashSet<T, H> {\n@@ -240,7 +240,7 @@ impl<\n impl<\n     E,\n     D: Decoder<E>,\n-    T: Decodable<D, E> + Hash<S> + TotalEq,\n+    T: Decodable<D, E> + Hash<S> + Eq,\n     S,\n     H: Hasher<S> + Default\n > Decodable<D, E> for HashSet<T, H> {"}, {"sha": "e9bb23a75c88f4bd7169ebb46c48cf8414acfbf9", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -23,7 +23,7 @@ use to_str::{IntoStr};\n use vec::Vec;\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n-#[deriving(Clone, PartialEq, PartialOrd, TotalOrd, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, PartialOrd, Ord, Eq, Hash)]\n pub struct Ascii { chr: u8 }\n \n impl Ascii {"}, {"sha": "7d821983075b1c66a3f78b5b9b8e4a854374008d", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -112,7 +112,7 @@ macro_rules! bitflags(\n     ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {\n         $($(#[$Flag_attr:meta])* static $Flag:ident = $value:expr),+\n     }) => (\n-        #[deriving(PartialEq, TotalEq, Clone)]\n+        #[deriving(PartialEq, Eq, Clone)]\n         $(#[$attr])*\n         pub struct $BitFlags {\n             bits: $T,"}, {"sha": "bdc4b6071fab420e17893ea9333e754e9f193ba7", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -25,7 +25,7 @@ use slice::{MutableCloneableVector, ImmutableVector, MutableVector};\n \n pub type Port = u16;\n \n-#[deriving(PartialEq, TotalEq, Clone, Hash)]\n+#[deriving(PartialEq, Eq, Clone, Hash)]\n pub enum IpAddr {\n     Ipv4Addr(u8, u8, u8, u8),\n     Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16)\n@@ -56,7 +56,7 @@ impl fmt::Show for IpAddr {\n     }\n }\n \n-#[deriving(PartialEq, TotalEq, Clone, Hash)]\n+#[deriving(PartialEq, Eq, Clone, Hash)]\n pub struct SocketAddr {\n     pub ip: IpAddr,\n     pub port: Port,"}, {"sha": "1ed465935621899f15f85f8d2ab340fb09f4547c", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -317,7 +317,7 @@ impl fmt::Show for Command {\n }\n \n /// The output of a finished process.\n-#[deriving(PartialEq, TotalEq, Clone)]\n+#[deriving(PartialEq, Eq, Clone)]\n pub struct ProcessOutput {\n     /// The status (exit code) of the process.\n     pub status: ProcessExit,\n@@ -348,7 +348,7 @@ pub enum StdioContainer {\n \n /// Describes the result of a process after it has terminated.\n /// Note that Windows have no signals, so the result is usually ExitStatus.\n-#[deriving(PartialEq, TotalEq, Clone)]\n+#[deriving(PartialEq, Eq, Clone)]\n pub enum ProcessExit {\n     /// Normal termination with an exit status.\n     ExitStatus(int),"}, {"sha": "a6bbf22b4019095f3d739fa2625c166021487b27", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -13,7 +13,7 @@\n use container::Container;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n-use cmp::{PartialEq, TotalEq};\n+use cmp::{PartialEq, Eq};\n use from_str::FromStr;\n use io::Writer;\n use iter::{DoubleEndedIterator, AdditiveIterator, Extendable, Iterator, Map};\n@@ -65,7 +65,7 @@ impl PartialEq for Path {\n     }\n }\n \n-impl TotalEq for Path {}\n+impl Eq for Path {}\n \n impl FromStr for Path {\n     fn from_str(s: &str) -> Option<Path> {"}, {"sha": "865e53cbe38dc1c90aeee12cfaa8ee32b4d2ac57", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -13,7 +13,7 @@\n use ascii::AsciiCast;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n-use cmp::{PartialEq, TotalEq};\n+use cmp::{PartialEq, Eq};\n use container::Container;\n use from_str::FromStr;\n use io::Writer;\n@@ -86,7 +86,7 @@ impl PartialEq for Path {\n     }\n }\n \n-impl TotalEq for Path {}\n+impl Eq for Path {}\n \n impl FromStr for Path {\n     fn from_str(s: &str) -> Option<Path> {"}, {"sha": "cce2cce0d6ef6ddb89b72f4ebdeb59c6ef1bdca0", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -58,7 +58,7 @@\n #[doc(no_inline)] pub use c_str::ToCStr;\n #[doc(no_inline)] pub use char::Char;\n #[doc(no_inline)] pub use clone::Clone;\n-#[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, TotalEq, TotalOrd};\n+#[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n #[doc(no_inline)] pub use cmp::{Ordering, Less, Equal, Greater, Equiv};\n #[doc(no_inline)] pub use container::{Container, Mutable, Map, MutableMap};\n #[doc(no_inline)] pub use container::{Set, MutableSet};\n@@ -81,9 +81,9 @@\n #[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n #[doc(no_inline)] pub use slice::{CloneableVector, ImmutableCloneableVector};\n-#[doc(no_inline)] pub use slice::{MutableCloneableVector, MutableTotalOrdVector};\n+#[doc(no_inline)] pub use slice::{MutableCloneableVector, MutableOrdVector};\n #[doc(no_inline)] pub use slice::{ImmutableVector, MutableVector};\n-#[doc(no_inline)] pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector};\n+#[doc(no_inline)] pub use slice::{ImmutableEqVector, ImmutableOrdVector};\n #[doc(no_inline)] pub use slice::{Vector, VectorVector, OwnedVector};\n #[doc(no_inline)] pub use slice::MutableVectorAllocating;\n #[doc(no_inline)] pub use string::String;"}, {"sha": "5753663dd87f0ce032559affdfd1eb1c1467a271", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -65,7 +65,7 @@ Vectors are a very useful type, and so there's several implementations of\n traits from other modules. Some notable examples:\n \n * `Clone`\n-* `Eq`, `Ord`, `TotalEq`, `TotalOrd` -- vectors can be compared,\n+* `Eq`, `Ord`, `Eq`, `Ord` -- vectors can be compared,\n   if the element type defines the corresponding trait.\n \n ## Iteration\n@@ -101,7 +101,7 @@ There are a number of free functions that create or take vectors, for example:\n \n use mem::transmute;\n use clone::Clone;\n-use cmp::{TotalOrd, Ordering, Less, Greater};\n+use cmp::{Ord, Ordering, Less, Greater};\n use cmp;\n use container::Container;\n use iter::*;\n@@ -117,7 +117,7 @@ use vec::Vec;\n \n pub use core::slice::{ref_slice, mut_ref_slice, Splits, Windows};\n pub use core::slice::{Chunks, Vector, ImmutableVector, ImmutableEqVector};\n-pub use core::slice::{ImmutableTotalOrdVector, MutableVector, Items, MutItems};\n+pub use core::slice::{ImmutableOrdVector, MutableVector, Items, MutItems};\n pub use core::slice::{MutSplits, MutChunks};\n pub use core::slice::{bytes, MutableCloneableVector};\n \n@@ -698,7 +698,7 @@ impl<'a,T> MutableVectorAllocating<'a, T> for &'a mut [T] {\n \n /// Methods for mutable vectors with orderable elements, such as\n /// in-place sorting.\n-pub trait MutableTotalOrdVector<T> {\n+pub trait MutableOrdVector<T> {\n     /// Sort the vector, in place.\n     ///\n     /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n@@ -714,7 +714,7 @@ pub trait MutableTotalOrdVector<T> {\n     fn sort(self);\n }\n \n-impl<'a, T: TotalOrd> MutableTotalOrdVector<T> for &'a mut [T] {\n+impl<'a, T: Ord> MutableOrdVector<T> for &'a mut [T] {\n     #[inline]\n     fn sort(self) {\n         self.sort_by(|a,b| a.cmp(b))"}, {"sha": "3af3821486ff4dd3ccb4da0b455651412b564532", "filename": "src/libstd/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -70,7 +70,7 @@ is the same as `&[u8]`.\n use char::Char;\n use char;\n use clone::Clone;\n-use cmp::{PartialEq, TotalEq, PartialOrd, TotalOrd, Equiv, Ordering};\n+use cmp::{PartialEq, Eq, PartialOrd, Ord, Equiv, Ordering};\n use container::Container;\n use default::Default;\n use fmt;\n@@ -575,7 +575,7 @@ impl<'a> PartialEq for MaybeOwned<'a> {\n     }\n }\n \n-impl<'a> TotalEq for MaybeOwned<'a> {}\n+impl<'a> Eq for MaybeOwned<'a> {}\n \n impl<'a> PartialOrd for MaybeOwned<'a> {\n     #[inline]\n@@ -584,7 +584,7 @@ impl<'a> PartialOrd for MaybeOwned<'a> {\n     }\n }\n \n-impl<'a> TotalOrd for MaybeOwned<'a> {\n+impl<'a> Ord for MaybeOwned<'a> {\n     #[inline]\n     fn cmp(&self, other: &MaybeOwned) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())"}, {"sha": "80973bb53289e105bc89cedc34ac941486be58d0", "filename": "src/libstd/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstring.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -30,7 +30,7 @@ use str;\n use vec::Vec;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n-#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd)]\n+#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n pub struct String {\n     vec: Vec<u8>,\n }"}, {"sha": "916ba083b3e6782e8879a943cb808423c695aac3", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -12,7 +12,7 @@\n \n use RawVec = raw::Vec;\n use clone::Clone;\n-use cmp::{PartialOrd, PartialEq, Ordering, TotalEq, TotalOrd, max};\n+use cmp::{PartialOrd, PartialEq, Ordering, Eq, Ord, max};\n use container::{Container, Mutable};\n use default::Default;\n use fmt;\n@@ -27,7 +27,7 @@ use ptr;\n use raw::Slice;\n use rt::heap::{allocate, reallocate, deallocate};\n use slice::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n-use slice::{MutableTotalOrdVector, OwnedVector, Vector};\n+use slice::{MutableOrdVector, OwnedVector, Vector};\n use slice::{MutableVectorAllocating};\n \n /// An owned, growable vector.\n@@ -388,9 +388,9 @@ impl<T: PartialOrd> PartialOrd for Vec<T> {\n     }\n }\n \n-impl<T: TotalEq> TotalEq for Vec<T> {}\n+impl<T: Eq> Eq for Vec<T> {}\n \n-impl<T: TotalOrd> TotalOrd for Vec<T> {\n+impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n@@ -1263,7 +1263,7 @@ impl<T> Vec<T> {\n     }\n }\n \n-impl<T:TotalOrd> Vec<T> {\n+impl<T:Ord> Vec<T> {\n     /// Sorts the vector in place.\n     ///\n     /// This sort is `O(n log n)` worst-case and stable, but allocates"}, {"sha": "cfe85995df69b08d8d97b46b8bf795298e75b114", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -13,7 +13,7 @@ use std::fmt;\n #[deriving(PartialEq)]\n pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, }\n \n-#[deriving(PartialEq, TotalEq, Hash, Encodable, Decodable, Clone)]\n+#[deriving(PartialEq, Eq, Hash, Encodable, Decodable, Clone)]\n pub enum Abi {\n     // NB: This ordering MUST match the AbiDatas array below.\n     // (This is ensured by the test indices_are_correct().)"}, {"sha": "9cbe7e0b5fce582755ae0a41fd4a234f631f4360", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -39,7 +39,7 @@ pub fn P<T: 'static>(value: T) -> P<T> {\n // table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n-#[deriving(Clone, Hash, PartialOrd, TotalEq, TotalOrd, Show)]\n+#[deriving(Clone, Hash, PartialOrd, Eq, Ord, Show)]\n pub struct Ident {\n     pub name: Name,\n     pub ctxt: SyntaxContext\n@@ -114,7 +114,7 @@ impl<D:Decoder<E>, E> Decodable<D, E> for Ident {\n /// Function name (not all functions have names)\n pub type FnIdent = Option<Ident>;\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n@@ -125,7 +125,7 @@ pub struct Lifetime {\n // for instance: std::cmp::PartialEq  .  It's represented\n // as a sequence of identifiers, along with a bunch\n // of supporting information.\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Path {\n     pub span: Span,\n     /// A `::foo` path, is relative to the crate root rather than current\n@@ -137,7 +137,7 @@ pub struct Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub identifier: Ident,\n@@ -151,7 +151,7 @@ pub type CrateNum = u32;\n \n pub type NodeId = u32;\n \n-#[deriving(Clone, TotalEq, TotalOrd, PartialOrd, PartialEq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, Eq, Ord, PartialOrd, PartialEq, Encodable, Decodable, Hash, Show)]\n pub struct DefId {\n     pub krate: CrateNum,\n     pub node: NodeId,\n@@ -171,14 +171,14 @@ pub static DUMMY_NODE_ID: NodeId = -1;\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send and Share.\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum TyParamBound {\n     TraitTyParamBound(TraitRef),\n     StaticRegionTyParamBound,\n     OtherRegionTyParamBound(Span) // FIXME -- just here until work for #5723 lands\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct TyParam {\n     pub ident: Ident,\n     pub id: NodeId,\n@@ -188,7 +188,7 @@ pub struct TyParam {\n     pub span: Span\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Generics {\n     pub lifetimes: Vec<Lifetime>,\n     pub ty_params: OwnedSlice<TyParam>,\n@@ -206,13 +206,13 @@ impl Generics {\n     }\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum MethodProvenance {\n     FromTrait(DefId),\n     FromImpl(DefId),\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Def {\n     DefFn(DefId, FnStyle),\n     DefStaticMethod(/* method */ DefId, MethodProvenance, FnStyle),\n@@ -249,7 +249,7 @@ pub enum Def {\n     DefMethod(DefId /* method */, Option<DefId> /* trait */),\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub enum DefRegion {\n     DefStaticRegion,\n     DefEarlyBoundRegion(/* index */ uint, /* lifetime decl */ NodeId),\n@@ -261,7 +261,7 @@ pub enum DefRegion {\n // used to drive conditional compilation\n pub type CrateConfig = Vec<@MetaItem> ;\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n@@ -271,7 +271,7 @@ pub struct Crate {\n \n pub type MetaItem = Spanned<MetaItem_>;\n \n-#[deriving(Clone, Encodable, Decodable, TotalEq, Hash)]\n+#[deriving(Clone, Encodable, Decodable, Eq, Hash)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n     MetaList(InternedString, Vec<@MetaItem> ),\n@@ -303,7 +303,7 @@ impl PartialEq for MetaItem_ {\n     }\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Block {\n     pub view_items: Vec<ViewItem>,\n     pub stmts: Vec<@Stmt>,\n@@ -313,26 +313,26 @@ pub struct Block {\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Pat {\n     pub id: NodeId,\n     pub node: Pat_,\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct FieldPat {\n     pub ident: Ident,\n     pub pat: @Pat,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum BindingMode {\n     BindByRef(Mutability),\n     BindByValue(Mutability),\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Pat_ {\n     PatWild,\n     PatWildMulti,\n@@ -358,20 +358,20 @@ pub enum Pat_ {\n     PatMac(Mac),\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Mutability {\n     MutMutable,\n     MutImmutable,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum ExprVstore {\n     ExprVstoreUniq,                 // ~[1,2,3,4]\n     ExprVstoreSlice,                // &[1,2,3,4]\n     ExprVstoreMutSlice,             // &mut [1,2,3,4]\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum BinOp {\n     BiAdd,\n     BiSub,\n@@ -393,7 +393,7 @@ pub enum BinOp {\n     BiGt,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum UnOp {\n     UnBox,\n     UnUniq,\n@@ -404,7 +404,7 @@ pub enum UnOp {\n \n pub type Stmt = Spanned<Stmt_>;\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Stmt_ {\n     // could be an item or a local (let) binding:\n     StmtDecl(@Decl, NodeId),\n@@ -421,7 +421,7 @@ pub enum Stmt_ {\n \n /// Where a local declaration came from: either a true `let ... =\n /// ...;`, or one desugared from the pattern of a for loop.\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum LocalSource {\n     LocalLet,\n     LocalFor,\n@@ -430,7 +430,7 @@ pub enum LocalSource {\n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n-#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Local {\n     pub ty: P<Ty>,\n     pub pat: @Pat,\n@@ -442,23 +442,23 @@ pub struct Local {\n \n pub type Decl = Spanned<Decl_>;\n \n-#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Decl_ {\n     // a local (let) binding:\n     DeclLocal(@Local),\n     // an item binding:\n     DeclItem(@Item),\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n     pub pats: Vec<@Pat>,\n     pub guard: Option<@Expr>,\n     pub body: @Expr,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Field {\n     pub ident: SpannedIdent,\n     pub expr: @Expr,\n@@ -467,26 +467,26 @@ pub struct Field {\n \n pub type SpannedIdent = Spanned<Ident>;\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n     // First expr is the place; second expr is the value.\n@@ -555,7 +555,7 @@ pub enum Expr_ {\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n     // a single token\n@@ -631,7 +631,7 @@ pub enum TokenTree {\n //\n pub type Matcher = Spanned<Matcher_>;\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Matcher_ {\n     // match one token\n     MatchTok(::parse::token::Token),\n@@ -648,20 +648,20 @@ pub type Mac = Spanned<Mac_>;\n // is being invoked, and the vector of token-trees contains the source\n // of the macro invocation.\n // There's only one flavor, now, so this could presumably be simplified.\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Mac_ {\n     MacInvocTT(Path, Vec<TokenTree> , SyntaxContext),   // new macro-invocation\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum StrStyle {\n     CookedStr,\n     RawStr(uint)\n }\n \n pub type Lit = Spanned<Lit_>;\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Lit_ {\n     LitStr(InternedString, StrStyle),\n     LitBinary(Rc<Vec<u8> >),\n@@ -677,20 +677,20 @@ pub enum Lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n-#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct TypeField {\n     pub ident: Ident,\n     pub mt: MutTy,\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct TypeMethod {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -706,13 +706,13 @@ pub struct TypeMethod {\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum TraitMethod {\n     Required(TypeMethod),\n     Provided(@Method),\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum IntTy {\n     TyI,\n     TyI8,\n@@ -728,7 +728,7 @@ impl fmt::Show for IntTy {\n     }\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum UintTy {\n     TyU,\n     TyU8,\n@@ -744,7 +744,7 @@ impl fmt::Show for UintTy {\n     }\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum FloatTy {\n     TyF32,\n     TyF64,\n@@ -758,15 +758,15 @@ impl fmt::Show for FloatTy {\n }\n \n // NB PartialEq method appears below.\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Ty {\n     pub id: NodeId,\n     pub node: Ty_,\n     pub span: Span,\n }\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum PrimTy {\n     TyInt(IntTy),\n     TyUint(UintTy),\n@@ -776,7 +776,7 @@ pub enum PrimTy {\n     TyChar\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Onceness {\n     Once,\n     Many\n@@ -791,7 +791,7 @@ impl fmt::Show for Onceness {\n     }\n }\n \n-#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct ClosureTy {\n     pub lifetimes: Vec<Lifetime>,\n     pub fn_style: FnStyle,\n@@ -804,15 +804,15 @@ pub struct ClosureTy {\n     pub bounds: Option<OwnedSlice<TyParamBound>>,\n }\n \n-#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct BareFnTy {\n     pub fn_style: FnStyle,\n     pub abi: Abi,\n     pub lifetimes: Vec<Lifetime>,\n     pub decl: P<FnDecl>\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Ty_ {\n     TyNil,\n     TyBot, /* bottom type */\n@@ -833,13 +833,13 @@ pub enum Ty_ {\n     TyInfer,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum AsmDialect {\n     AsmAtt,\n     AsmIntel\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n@@ -851,7 +851,7 @@ pub struct InlineAsm {\n     pub dialect: AsmDialect\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Arg {\n     pub ty: P<Ty>,\n     pub pat: @Pat,\n@@ -878,15 +878,15 @@ impl Arg {\n     }\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n     pub output: P<Ty>,\n     pub cf: RetStyle,\n     pub variadic: bool\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum FnStyle {\n     UnsafeFn, // declared with \"unsafe fn\"\n     NormalFn, // declared with \"fn\"\n@@ -901,14 +901,14 @@ impl fmt::Show for FnStyle {\n     }\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum RetStyle {\n     NoReturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     Return, // everything else\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum ExplicitSelf_ {\n     SelfStatic,                                // no self\n     SelfValue,                                 // `self`\n@@ -918,7 +918,7 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Method {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -932,7 +932,7 @@ pub struct Method {\n     pub vis: Visibility,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -942,31 +942,31 @@ pub struct Mod {\n     pub items: Vec<@Item>,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub view_items: Vec<ViewItem>,\n     pub items: Vec<@ForeignItem>,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct VariantArg {\n     pub ty: P<Ty>,\n     pub id: NodeId,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum VariantKind {\n     TupleVariantKind(Vec<VariantArg>),\n     StructVariantKind(@StructDef),\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct EnumDef {\n     pub variants: Vec<P<Variant>>,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Variant_ {\n     pub name: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -978,7 +978,7 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct PathListIdent_ {\n     pub name: Ident,\n     pub id: NodeId,\n@@ -988,7 +988,7 @@ pub type PathListIdent = Spanned<PathListIdent_>;\n \n pub type ViewPath = Spanned<ViewPath_>;\n \n-#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum ViewPath_ {\n \n     // quux = foo::bar::baz\n@@ -1005,15 +1005,15 @@ pub enum ViewPath_ {\n     ViewPathList(Path, Vec<PathListIdent> , NodeId)\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct ViewItem {\n     pub node: ViewItem_,\n     pub attrs: Vec<Attribute>,\n     pub vis: Visibility,\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum ViewItem_ {\n     // ident: name used to refer to this crate in the code\n     // optional (InternedString,StrStyle): if present, this is a location\n@@ -1029,17 +1029,17 @@ pub type Attribute = Spanned<Attribute_>;\n // Distinguishes between Attributes that decorate items and Attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum AttrStyle {\n     AttrOuter,\n     AttrInner,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct AttrId(pub uint);\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Attribute_ {\n     pub id: AttrId,\n     pub style: AttrStyle,\n@@ -1054,13 +1054,13 @@ pub struct Attribute_ {\n   If this impl is an ItemImpl, the impl_id is redundant (it could be the\n   same as the impl's node id).\n  */\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Visibility {\n     Public,\n     Inherited,\n@@ -1075,13 +1075,13 @@ impl Visibility {\n     }\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Sized {\n     DynSize,\n     StaticSize,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct StructField_ {\n     pub kind: StructFieldKind,\n     pub id: NodeId,\n@@ -1091,7 +1091,7 @@ pub struct StructField_ {\n \n pub type StructField = Spanned<StructField_>;\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum StructFieldKind {\n     NamedField(Ident, Visibility),\n     UnnamedField(Visibility), // element of a tuple-like struct\n@@ -1106,7 +1106,7 @@ impl StructFieldKind {\n     }\n }\n \n-#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct StructDef {\n     pub fields: Vec<StructField>, /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n@@ -1120,7 +1120,7 @@ pub struct StructDef {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Item {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1130,7 +1130,7 @@ pub struct Item {\n     pub span: Span,\n }\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Item_ {\n     ItemStatic(P<Ty>, Mutability, @Expr),\n     ItemFn(P<FnDecl>, FnStyle, Abi, Generics, P<Block>),\n@@ -1148,7 +1148,7 @@ pub enum Item_ {\n     ItemMac(Mac),\n }\n \n-#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct ForeignItem {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1158,7 +1158,7 @@ pub struct ForeignItem {\n     pub vis: Visibility,\n }\n \n-#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum ForeignItem_ {\n     ForeignItemFn(P<FnDecl>, Generics),\n     ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n@@ -1167,7 +1167,7 @@ pub enum ForeignItem_ {\n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n-#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum InlinedItem {\n     IIItem(@Item),\n     IIMethod(DefId /* impl id */, bool /* is provided */, @Method),"}, {"sha": "f31d0d869404cccea42fb5f146637d2e5441d202", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -33,7 +33,7 @@ pub trait Pos {\n \n /// A byte offset. Keep this small (currently 32-bits), as AST contains\n /// a lot of them.\n-#[deriving(Clone, PartialEq, TotalEq, Hash, PartialOrd, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, PartialOrd, Show)]\n pub struct BytePos(pub u32);\n \n /// A character offset. Because of multibyte utf8 characters, a byte offset\n@@ -96,7 +96,7 @@ pub struct Span {\n \n pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_info: None };\n \n-#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Spanned<T> {\n     pub node: T,\n     pub span: Span,\n@@ -109,7 +109,7 @@ impl PartialEq for Span {\n     fn ne(&self, other: &Span) -> bool { !(*self).eq(other) }\n }\n \n-impl TotalEq for Span {}\n+impl Eq for Span {}\n \n impl<S:Encoder<E>, E> Encodable<S, E> for Span {\n     /* Note #1972 -- spans are encoded but not decoded */"}, {"sha": "7bf4df357f43353f313acb493dc26e0c765588a1", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -28,7 +28,7 @@ Supported features (fairly exhaustive):\n   moment. (`TraitDef.additional_bounds`)\n \n Unsupported: FIXME #6257: calling methods on reference fields,\n-e.g. deriving TotalEq/TotalOrd/Clone don't work on `struct A(&int)`,\n+e.g. deriving Eq/Ord/Clone don't work on `struct A(&int)`,\n because of how the auto-dereferencing happens.\n \n The most important thing for implementers is the `Substructure` and"}, {"sha": "445b21551fdbaa7b55beafa2f3b0e5a8c62003a5", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -79,9 +79,9 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n \n                             // NOTE: after a stage0 snap this needs treatment\n                             \"PartialEq\" => expand!(eq::expand_deriving_eq),\n-                            \"Eq\" | \"TotalEq\" => expand!(totaleq::expand_deriving_totaleq),\n+                            \"Eq\" => expand!(totaleq::expand_deriving_totaleq),\n                             \"PartialOrd\" => expand!(ord::expand_deriving_ord),\n-                            \"Ord\" | \"TotalOrd\" => expand!(totalord::expand_deriving_totalord),\n+                            \"Ord\" => expand!(totalord::expand_deriving_totalord),\n \n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n "}, {"sha": "a514c1e9c5d2b59c9f514385161330f19e51283c", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -119,7 +119,7 @@ impl<T: PartialEq> PartialEq for OwnedSlice<T> {\n     }\n }\n \n-impl<T: TotalEq> TotalEq for OwnedSlice<T> {}\n+impl<T: Eq> Eq for OwnedSlice<T> {}\n \n impl<T> Container for OwnedSlice<T> {\n     fn len(&self) -> uint { self.len }"}, {"sha": "bba400742b5470427df847e85c4d5f555e30b79a", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -23,7 +23,7 @@ use parse::parser;\n use parse::token;\n \n /// The specific types of unsupported syntax\n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n pub enum ObsoleteSyntax {\n     ObsoleteOwnedType,\n     ObsoleteOwnedExpr,"}, {"sha": "34f508e42a1eb970385115463a025190d939dc55", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -24,7 +24,7 @@ use std::rc::Rc;\n use std::string::String;\n \n #[allow(non_camel_case_types)]\n-#[deriving(Clone, Encodable, Decodable, PartialEq, TotalEq, Hash, Show)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash, Show)]\n pub enum BinOp {\n     PLUS,\n     MINUS,\n@@ -39,7 +39,7 @@ pub enum BinOp {\n }\n \n #[allow(non_camel_case_types)]\n-#[deriving(Clone, Encodable, Decodable, PartialEq, TotalEq, Hash, Show)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash, Show)]\n pub enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -102,7 +102,7 @@ pub enum Token {\n     EOF,\n }\n \n-#[deriving(Clone, Encodable, Decodable, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n     NtItem(@ast::Item),\n@@ -552,7 +552,7 @@ pub fn get_ident_interner() -> Rc<IdentInterner> {\n /// destroyed. In particular, they must not access string contents. This can\n /// be fixed in the future by just leaking all strings until task death\n /// somehow.\n-#[deriving(Clone, PartialEq, Hash, PartialOrd, TotalEq, TotalOrd)]\n+#[deriving(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n pub struct InternedString {\n     string: RcStr,\n }"}, {"sha": "66260e50208f0446dfe18fac6721134617b4b4fc", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -28,7 +28,7 @@ pub struct Interner<T> {\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n-impl<T: TotalEq + Hash + Clone + 'static> Interner<T> {\n+impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n             map: RefCell::new(HashMap::new()),\n@@ -95,9 +95,9 @@ pub struct RcStr {\n     string: Rc<String>,\n }\n \n-impl TotalEq for RcStr {}\n+impl Eq for RcStr {}\n \n-impl TotalOrd for RcStr {\n+impl Ord for RcStr {\n     fn cmp(&self, other: &RcStr) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n     }"}, {"sha": "4d408864dc513548c975a1acf9e559d86855cf43", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -83,7 +83,7 @@ pub mod stats;\n // colons. This way if some test runner wants to arrange the tests\n // hierarchically it may.\n \n-#[deriving(Clone, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum TestName {\n     StaticTestName(&'static str),\n     DynTestName(String)\n@@ -183,7 +183,7 @@ pub struct Bencher {\n \n // The definition of a single test. A test runner will run a list of\n // these.\n-#[deriving(Clone, Show, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, Show, PartialEq, Eq, Hash)]\n pub struct TestDesc {\n     pub name: TestName,\n     pub ignore: bool,"}, {"sha": "b446a587bb9961a0061feb414517ea14f729a482", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -441,7 +441,7 @@ pub fn write_boxplot<T: Float + Show + FromPrimitive>(\n \n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n-pub fn freq_count<T: Iterator<U>, U: TotalEq+Hash>(mut iter: T) -> hashmap::HashMap<U, uint> {\n+pub fn freq_count<T: Iterator<U>, U: Eq+Hash>(mut iter: T) -> hashmap::HashMap<U, uint> {\n     let mut map: hashmap::HashMap<U,uint> = hashmap::HashMap::new();\n     for elem in iter {\n         map.insert_or_update_with(elem, 1, |_, count| *count += 1);"}, {"sha": "a478aa931d444cd6d338b371f0f14d33463b2748", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -74,7 +74,7 @@ mod imp {\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n-#[deriving(Clone, PartialEq, TotalEq, PartialOrd, TotalOrd, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Decodable, Show)]\n pub struct Timespec { pub sec: i64, pub nsec: i32 }\n /*\n  * Timespec assumes that pre-epoch Timespecs have negative sec and positive"}, {"sha": "5da6c5afe4278d7bb3acbf1609ff509ffde88c1b", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -48,7 +48,7 @@ use std::uint;\n ///                 fragment: Some(\"quz\".to_string()) };\n /// // https://username@example.com:8080/foo/bar?baz=qux#quz\n /// ```\n-#[deriving(Clone, PartialEq, TotalEq)]\n+#[deriving(Clone, PartialEq, Eq)]\n pub struct Url {\n     /// The scheme part of a URL, such as `https` in the above example.\n     pub scheme: String,\n@@ -81,7 +81,7 @@ pub struct Path {\n }\n \n /// An optional subcomponent of a URI authority component.\n-#[deriving(Clone, PartialEq, TotalEq)]\n+#[deriving(Clone, PartialEq, Eq)]\n pub struct UserInfo {\n     /// The user name.\n     pub user: String,"}, {"sha": "0a2b3744824f45bac9f37c71f04fea59f8b76bb4", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -487,7 +487,7 @@ impl PartialEq for Uuid {\n     }\n }\n \n-impl TotalEq for Uuid {}\n+impl Eq for Uuid {}\n \n // FIXME #9845: Test these more thoroughly\n impl<T: Encoder<E>, E> Encodable<T, E> for Uuid {"}, {"sha": "854c60a3f1b64ce78629bfc412073bd4e7745ba8", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -1,3 +1,11 @@\n+S 2014-05-30 60a43f9\n+  freebsd-x86_64 59067eb9e89bde3e20a1078104f4b1105e4b56fc\n+  linux-i386 c1a81811e8e104c91c35d94a140e3cf8463c7655\n+  linux-x86_64 5c7167a2f964118103af5735a9215e8421803406\n+  macos-i386 872b9818badefda412c7513b93742369f969094d\n+  macos-x86_64 78c0f2ead6287c433d0cd18e1860404526ba5049\n+  winnt-i386 63ca814f86493a8f06ab616b5e31d49a19bec1b2\n+\n S 2014-05-29 50b8528\n   freebsd-x86_64 cfa0dcc98a57f03a53bb53df6fd5db02143e2bee\n   linux-i386 baf7c6ab5792f3d560a0f2adc94d7ff96d0cab3d"}, {"sha": "6c038e28bb94a67dfb1c8802e603a074dea2a145", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -30,7 +30,7 @@ static OCCURRENCES: [&'static str, ..5] = [\n \n // Code implementation\n \n-#[deriving(PartialEq, PartialOrd, TotalOrd, TotalEq)]\n+#[deriving(PartialEq, PartialOrd, Ord, Eq)]\n struct Code(u64);\n \n impl Code {"}, {"sha": "964e7d8c811dd3a536609350c019a5828b3ce5b7", "filename": "src/test/compile-fail/deriving-span-TotalEq-enum-struct-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum-struct-variant.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -16,7 +16,7 @@ extern crate rand;\n #[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(TotalEq,PartialEq)]\n+#[deriving(Eq,PartialEq)]\n enum Enum {\n    A {\n      x: Error //~ ERROR"}, {"sha": "96e87ca20069420689721a6b877f10f754a0974b", "filename": "src/test/compile-fail/deriving-span-TotalEq-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -16,7 +16,7 @@ extern crate rand;\n #[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(TotalEq,PartialEq)]\n+#[deriving(Eq,PartialEq)]\n enum Enum {\n    A(\n      Error //~ ERROR"}, {"sha": "784c766c05724216197854b086cd3f7762ea6377", "filename": "src/test/compile-fail/deriving-span-TotalEq-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-struct.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -16,7 +16,7 @@ extern crate rand;\n #[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(TotalEq,PartialEq)]\n+#[deriving(Eq,PartialEq)]\n struct Struct {\n     x: Error //~ ERROR\n }"}, {"sha": "3dcff5f80ce3daf0a120c4410284d7ea711b7961", "filename": "src/test/compile-fail/deriving-span-TotalEq-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-tuple-struct.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -16,7 +16,7 @@ extern crate rand;\n #[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(TotalEq,PartialEq)]\n+#[deriving(Eq,PartialEq)]\n struct Struct(\n     Error //~ ERROR\n );"}, {"sha": "c16e64829dd0603443918e97d0f82c2a4cb57f69", "filename": "src/test/compile-fail/deriving-span-TotalOrd-enum-struct-variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum-struct-variant.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -13,10 +13,10 @@\n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(TotalEq,PartialOrd,PartialEq)]\n+#[deriving(Eq,PartialOrd,PartialEq)]\n struct Error;\n \n-#[deriving(TotalOrd,TotalEq,PartialOrd,PartialEq)]\n+#[deriving(Ord,Eq,PartialOrd,PartialEq)]\n enum Enum {\n    A {\n      x: Error //~ ERROR"}, {"sha": "4b3f0ce52c7bf1585627fc1b6eb01de923c9e50c", "filename": "src/test/compile-fail/deriving-span-TotalOrd-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -13,10 +13,10 @@\n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(TotalEq,PartialOrd,PartialEq)]\n+#[deriving(Eq,PartialOrd,PartialEq)]\n struct Error;\n \n-#[deriving(TotalOrd,TotalEq,PartialOrd,PartialEq)]\n+#[deriving(Ord,Eq,PartialOrd,PartialEq)]\n enum Enum {\n    A(\n      Error //~ ERROR"}, {"sha": "56d627423782627bc33bcc11912ebbdc45969e7f", "filename": "src/test/compile-fail/deriving-span-TotalOrd-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-struct.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -13,10 +13,10 @@\n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(TotalEq,PartialOrd,PartialEq)]\n+#[deriving(Eq,PartialOrd,PartialEq)]\n struct Error;\n \n-#[deriving(TotalOrd,TotalEq,PartialOrd,PartialEq)]\n+#[deriving(Ord,Eq,PartialOrd,PartialEq)]\n struct Struct {\n     x: Error //~ ERROR\n }"}, {"sha": "2330fdd8b893a05414e8cc75f486635041afe6f1", "filename": "src/test/compile-fail/deriving-span-TotalOrd-tuple-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-tuple-struct.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -13,10 +13,10 @@\n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(TotalEq,PartialOrd,PartialEq)]\n+#[deriving(Eq,PartialOrd,PartialEq)]\n struct Error;\n \n-#[deriving(TotalOrd,TotalEq,PartialOrd,PartialEq)]\n+#[deriving(Ord,Eq,PartialOrd,PartialEq)]\n struct Struct(\n     Error //~ ERROR\n );"}, {"sha": "48e6cae706e845f28b92bce3b5ae0233a158ba41", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(PartialEq, TotalEq, PartialOrd, TotalOrd)]\n+#[deriving(PartialEq, Eq, PartialOrd, Ord)]\n enum E<T> {\n     E0,\n     E1(T),\n@@ -22,7 +22,7 @@ pub fn main() {\n     let e21 = E2(1, 1);\n     let e22 = E2(1, 2);\n \n-    // in order for both PartialOrd and TotalOrd\n+    // in order for both PartialOrd and Ord\n     let es = [e0, e11, e12, e21, e22];\n \n     for (i, e1) in es.iter().enumerate() {\n@@ -46,7 +46,7 @@ pub fn main() {\n             assert_eq!(*e1 <= *e2, le);\n             assert_eq!(*e1 >= *e2, ge);\n \n-            // TotalOrd\n+            // Ord\n             assert_eq!(e1.cmp(e2), ord);\n         }\n     }"}, {"sha": "5958538d80ee2a62bfefd1a2943eedbeb12dab86", "filename": "src/test/run-pass/deriving-cmp-generic-struct-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(struct_variant)]\n \n-#[deriving(PartialEq, TotalEq, PartialOrd, TotalOrd)]\n+#[deriving(PartialEq, Eq, PartialOrd, Ord)]\n enum ES<T> {\n     ES1 { x: T },\n     ES2 { x: T, y: T }\n@@ -20,7 +20,7 @@ enum ES<T> {\n pub fn main() {\n     let (es11, es12, es21, es22) = (ES1 {x: 1}, ES1 {x: 2}, ES2 {x: 1, y: 1}, ES2 {x: 1, y: 2});\n \n-    // in order for both PartialOrd and TotalOrd\n+    // in order for both PartialOrd and Ord\n     let ess = [es11, es12, es21, es22];\n \n     for (i, es1) in ess.iter().enumerate() {\n@@ -42,7 +42,7 @@ pub fn main() {\n             assert_eq!(*es1 <= *es2, le);\n             assert_eq!(*es1 >= *es2, ge);\n \n-            // TotalOrd\n+            // Ord\n             assert_eq!(es1.cmp(es2), ord);\n         }\n     }"}, {"sha": "5a6daa6d520971b0848e023f4b597a9cf9819419", "filename": "src/test/run-pass/deriving-cmp-generic-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(PartialEq, TotalEq, PartialOrd, TotalOrd)]\n+#[deriving(PartialEq, Eq, PartialOrd, Ord)]\n struct S<T> {\n     x: T,\n     y: T\n@@ -18,7 +18,7 @@ pub fn main() {\n     let s1 = S {x: 1, y: 1};\n     let s2 = S {x: 1, y: 2};\n \n-    // in order for both PartialOrd and TotalOrd\n+    // in order for both PartialOrd and Ord\n     let ss = [s1, s2];\n \n     for (i, s1) in ss.iter().enumerate() {\n@@ -42,7 +42,7 @@ pub fn main() {\n             assert_eq!(*s1 <= *s2, le);\n             assert_eq!(*s1 >= *s2, ge);\n \n-            // TotalOrd\n+            // Ord\n             assert_eq!(s1.cmp(s2), ord);\n         }\n     }"}, {"sha": "875c33b9810f6305d55a3d62830674ec7ef06d97", "filename": "src/test/run-pass/deriving-cmp-generic-tuple-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(PartialEq, TotalEq, PartialOrd, TotalOrd)]\n+#[deriving(PartialEq, Eq, PartialOrd, Ord)]\n struct TS<T>(T,T);\n \n \n pub fn main() {\n     let ts1 = TS(1, 1);\n     let ts2 = TS(1, 2);\n \n-    // in order for both PartialOrd and TotalOrd\n+    // in order for both PartialOrd and Ord\n     let tss = [ts1, ts2];\n \n     for (i, ts1) in tss.iter().enumerate() {\n@@ -40,7 +40,7 @@ pub fn main() {\n             assert_eq!(*ts1 <= *ts2, le);\n             assert_eq!(*ts1 >= *ts2, ge);\n \n-            // TotalOrd\n+            // Ord\n             assert_eq!(ts1.cmp(ts2), ord);\n         }\n     }"}, {"sha": "69ee47fd1d946e4ea97cf8a1814eb09d391a6a9d", "filename": "src/test/run-pass/deriving-cmp-shortcircuit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -21,13 +21,13 @@ impl PartialOrd for FailCmp {\n     fn lt(&self, _: &FailCmp) -> bool { fail!(\"lt\") }\n }\n \n-impl TotalEq for FailCmp {}\n+impl Eq for FailCmp {}\n \n-impl TotalOrd for FailCmp {\n+impl Ord for FailCmp {\n     fn cmp(&self, _: &FailCmp) -> Ordering { fail!(\"cmp\") }\n }\n \n-#[deriving(PartialEq,PartialOrd,TotalEq,TotalOrd)]\n+#[deriving(PartialEq,PartialOrd,Eq,Ord)]\n struct ShortCircuit {\n     x: int,\n     y: FailCmp"}, {"sha": "2322675661caf6af2dabc60b8fa41dba5741dea2", "filename": "src/test/run-pass/deriving-global.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-global.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -15,21 +15,21 @@ mod submod {\n     // if any of these are implemented without global calls for any\n     // function calls, then being in a submodule will (correctly)\n     // cause errors about unrecognised module `std` (or `extra`)\n-    #[deriving(PartialEq, PartialOrd, TotalEq, TotalOrd,\n+    #[deriving(PartialEq, PartialOrd, Eq, Ord,\n                Hash,\n                Clone,\n                Show, Rand,\n                Encodable, Decodable)]\n     enum A { A1(uint), A2(int) }\n \n-    #[deriving(PartialEq, PartialOrd, TotalEq, TotalOrd,\n+    #[deriving(PartialEq, PartialOrd, Eq, Ord,\n                Hash,\n                Clone,\n                Show, Rand,\n                Encodable, Decodable)]\n     struct B { x: uint, y: int }\n \n-    #[deriving(PartialEq, PartialOrd, TotalEq, TotalOrd,\n+    #[deriving(PartialEq, PartialOrd, Eq, Ord,\n                Hash,\n                Clone,\n                Show, Rand,"}, {"sha": "1187a9a8bc4a768cae546898576d1625131719f3", "filename": "src/test/run-pass/deriving-self-lifetime-totalord-totaleq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime-totalord-totaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime-totalord-totaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime-totalord-totaleq.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -12,7 +12,7 @@\n \n use std::cmp::{Less,Equal,Greater};\n \n-#[deriving(TotalEq,TotalOrd)]\n+#[deriving(Eq,Ord)]\n struct A<'a> {\n     x: &'a int\n }"}, {"sha": "b133f627439ae9a13a6c033fa58ee5d283157ea2", "filename": "src/test/run-pass/issue-12860.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12860.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -13,7 +13,7 @@ extern crate collections;\n \n use collections::HashSet;\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n struct XYZ {\n     x: int,\n     y: int,"}, {"sha": "b8e6a5fb03e1b49822799a02b1460dcf0e9132af", "filename": "src/test/run-pass/regions-mock-tcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -40,7 +40,7 @@ impl<'tcx> PartialEq for TypeStructure<'tcx> {\n     }\n }\n \n-impl<'tcx> TotalEq for TypeStructure<'tcx> {}\n+impl<'tcx> Eq for TypeStructure<'tcx> {}\n \n struct TypeContext<'tcx, 'ast> {\n     ty_arena: &'tcx Arena,\n@@ -86,7 +86,7 @@ impl<'tcx,'ast> TypeContext<'tcx, 'ast> {\n     }\n }\n \n-#[deriving(PartialEq, TotalEq, Hash)]\n+#[deriving(PartialEq, Eq, Hash)]\n struct NodeId {\n     id: uint\n }"}, {"sha": "2575e53b6a3bbdaefe8116488b8bd35846c1896b", "filename": "src/test/run-pass/vector-sort-failure-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba701c59d84eac4e20d0796ec06db8d1cdd39cf/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs?ref=bba701c59d84eac4e20d0796ec06db8d1cdd39cf", "patch": "@@ -15,7 +15,7 @@ static MAX_LEN: uint = 20;\n static mut drop_counts: [uint, .. MAX_LEN] = [0, .. MAX_LEN];\n static mut clone_count: uint = 0;\n \n-#[deriving(Rand, PartialEq, PartialOrd, TotalEq, TotalOrd)]\n+#[deriving(Rand, PartialEq, PartialOrd, Eq, Ord)]\n struct DropCounter { x: uint, clone_num: uint }\n \n impl Clone for DropCounter {"}]}