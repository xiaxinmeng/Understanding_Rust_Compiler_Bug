{"sha": "a5ab8da1e22c2cbfca30209ef30cd469a913f08a", "node_id": "C_kwDOAAsO6NoAKGE1YWI4ZGExZTIyYzJjYmZjYTMwMjA5ZWYzMGNkNDY5YTkxM2YwOGE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-15T14:42:43Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-15T14:42:43Z"}, "message": "derive TypeVisitable and TypeFoldable for mir types", "tree": {"sha": "da76dc85e6fbf18ed693d1498a4ddbfd7c8ccc8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da76dc85e6fbf18ed693d1498a4ddbfd7c8ccc8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5ab8da1e22c2cbfca30209ef30cd469a913f08a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ab8da1e22c2cbfca30209ef30cd469a913f08a", "html_url": "https://github.com/rust-lang/rust/commit/a5ab8da1e22c2cbfca30209ef30cd469a913f08a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5ab8da1e22c2cbfca30209ef30cd469a913f08a/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d376012a43f91f6dfdd761d786c016f7c343f950", "url": "https://api.github.com/repos/rust-lang/rust/commits/d376012a43f91f6dfdd761d786c016f7c343f950", "html_url": "https://github.com/rust-lang/rust/commit/d376012a43f91f6dfdd761d786c016f7c343f950"}], "stats": {"total": 337, "additions": 25, "deletions": 312}, "files": [{"sha": "af00118fcbebacab546f2a42a379975f8896e83f", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5ab8da1e22c2cbfca30209ef30cd469a913f08a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ab8da1e22c2cbfca30209ef30cd469a913f08a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=a5ab8da1e22c2cbfca30209ef30cd469a913f08a", "patch": "@@ -2028,6 +2028,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// particular, one must be wary of `NaN`!\n \n #[derive(Clone, Copy, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(TypeFoldable, TypeVisitable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n "}, {"sha": "c7d0283aac9bab59ad008ddf303fc9c1724cef56", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5ab8da1e22c2cbfca30209ef30cd469a913f08a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ab8da1e22c2cbfca30209ef30cd469a913f08a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=a5ab8da1e22c2cbfca30209ef30cd469a913f08a", "patch": "@@ -488,7 +488,7 @@ pub struct CopyNonOverlapping<'tcx> {\n ///     must also be `cleanup`. This is a part of the type system and checked statically, so it is\n ///     still an error to have such an edge in the CFG even if it's known that it won't be taken at\n ///     runtime.\n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, TypeFoldable, TypeVisitable)]\n pub enum TerminatorKind<'tcx> {\n     /// Block has one successor; we continue execution there.\n     Goto { target: BasicBlock },\n@@ -741,7 +741,7 @@ pub enum TerminatorKind<'tcx> {\n }\n \n /// Information about an assertion failure.\n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, TypeFoldable, TypeVisitable)]\n pub enum AssertKind<O> {\n     BoundsCheck { len: O, index: O },\n     Overflow(BinOp, O, O),\n@@ -863,7 +863,7 @@ pub type AssertMessage<'tcx> = AssertKind<Operand<'tcx>>;\n ///\n /// Rust currently requires that every place obey those two rules. This is checked by MIRI and taken\n /// advantage of by codegen (via `gep inbounds`). That is possibly subject to change.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, HashStable, TypeFoldable, TypeVisitable)]\n pub struct Place<'tcx> {\n     pub local: Local,\n \n@@ -955,7 +955,7 @@ pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n /// **Needs clarifiation:** Is loading a place that has its variant index set well-formed? Miri\n /// currently implements it, but it seems like this may be something to check against in the\n /// validator.\n-#[derive(Clone, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(Clone, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable, TypeVisitable)]\n pub enum Operand<'tcx> {\n     /// Creates a value by loading the given place.\n     ///\n@@ -986,7 +986,7 @@ pub enum Operand<'tcx> {\n /// Computing any rvalue begins by evaluating the places and operands in some order (**Needs\n /// clarification**: Which order?). These are then used to produce a \"value\" - the same kind of\n /// value that an [`Operand`] produces.\n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, TypeFoldable, TypeVisitable)]\n pub enum Rvalue<'tcx> {\n     /// Yields the operand unchanged\n     Use(Operand<'tcx>),\n@@ -1146,6 +1146,7 @@ pub enum CastKind {\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(TypeFoldable, TypeVisitable)]\n pub enum AggregateKind<'tcx> {\n     /// The type is of the element\n     Array(Ty<'tcx>),"}, {"sha": "4ea333cff7d9db9841502b4a18362a36148dc3b0", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5ab8da1e22c2cbfca30209ef30cd469a913f08a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ab8da1e22c2cbfca30209ef30cd469a913f08a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=a5ab8da1e22c2cbfca30209ef30cd469a913f08a", "patch": "@@ -102,7 +102,7 @@ impl<'a> Iterator for SwitchTargetsIter<'a> {\n \n impl<'a> ExactSizeIterator for SwitchTargetsIter<'a> {}\n \n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub struct Terminator<'tcx> {\n     pub source_info: SourceInfo,\n     pub kind: TerminatorKind<'tcx>,"}, {"sha": "b8f8f697a9c05b77d62d2bc68c3c985ae6f69fef", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 17, "deletions": 164, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/a5ab8da1e22c2cbfca30209ef30cd469a913f08a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ab8da1e22c2cbfca30209ef30cd469a913f08a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=a5ab8da1e22c2cbfca30209ef30cd469a913f08a", "patch": "@@ -1,8 +1,9 @@\n //! `TypeFoldable` implementations for MIR types\n \n+use rustc_ast::InlineAsmTemplatePiece;\n+\n use super::*;\n use crate::ty;\n-use rustc_data_structures::functor::IdFunctor;\n \n TrivialTypeTraversalAndLiftImpls! {\n     BlockTailInfo,\n@@ -13,96 +14,27 @@ TrivialTypeTraversalAndLiftImpls! {\n     SourceScope,\n     SourceScopeLocalData,\n     UserTypeAnnotationIndex,\n+    BorrowKind,\n+    CastKind,\n+    BinOp,\n+    NullOp,\n+    UnOp,\n+    hir::Movability,\n+    BasicBlock,\n+    SwitchTargets,\n+    GeneratorKind,\n+    GeneratorSavedLocal,\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        use crate::mir::TerminatorKind::*;\n-\n-        let kind = match self.kind {\n-            Goto { target } => Goto { target },\n-            SwitchInt { discr, switch_ty, targets } => SwitchInt {\n-                discr: discr.try_fold_with(folder)?,\n-                switch_ty: switch_ty.try_fold_with(folder)?,\n-                targets,\n-            },\n-            Drop { place, target, unwind } => {\n-                Drop { place: place.try_fold_with(folder)?, target, unwind }\n-            }\n-            DropAndReplace { place, value, target, unwind } => DropAndReplace {\n-                place: place.try_fold_with(folder)?,\n-                value: value.try_fold_with(folder)?,\n-                target,\n-                unwind,\n-            },\n-            Yield { value, resume, resume_arg, drop } => Yield {\n-                value: value.try_fold_with(folder)?,\n-                resume,\n-                resume_arg: resume_arg.try_fold_with(folder)?,\n-                drop,\n-            },\n-            Call { func, args, destination, target, cleanup, from_hir_call, fn_span } => Call {\n-                func: func.try_fold_with(folder)?,\n-                args: args.try_fold_with(folder)?,\n-                destination: destination.try_fold_with(folder)?,\n-                target,\n-                cleanup,\n-                from_hir_call,\n-                fn_span,\n-            },\n-            Assert { cond, expected, msg, target, cleanup } => {\n-                use AssertKind::*;\n-                let msg = match msg {\n-                    BoundsCheck { len, index } => BoundsCheck {\n-                        len: len.try_fold_with(folder)?,\n-                        index: index.try_fold_with(folder)?,\n-                    },\n-                    Overflow(op, l, r) => {\n-                        Overflow(op, l.try_fold_with(folder)?, r.try_fold_with(folder)?)\n-                    }\n-                    OverflowNeg(op) => OverflowNeg(op.try_fold_with(folder)?),\n-                    DivisionByZero(op) => DivisionByZero(op.try_fold_with(folder)?),\n-                    RemainderByZero(op) => RemainderByZero(op.try_fold_with(folder)?),\n-                    ResumedAfterReturn(_) | ResumedAfterPanic(_) => msg,\n-                };\n-                Assert { cond: cond.try_fold_with(folder)?, expected, msg, target, cleanup }\n-            }\n-            GeneratorDrop => GeneratorDrop,\n-            Resume => Resume,\n-            Abort => Abort,\n-            Return => Return,\n-            Unreachable => Unreachable,\n-            FalseEdge { real_target, imaginary_target } => {\n-                FalseEdge { real_target, imaginary_target }\n-            }\n-            FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n-            InlineAsm { template, operands, options, line_spans, destination, cleanup } => {\n-                InlineAsm {\n-                    template,\n-                    operands: operands.try_fold_with(folder)?,\n-                    options,\n-                    line_spans,\n-                    destination,\n-                    cleanup,\n-                }\n-            }\n-        };\n-        Ok(Terminator { source_info: self.source_info, kind })\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx [InlineAsmTemplatePiece] {\n+    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        Ok(Place {\n-            local: self.local.try_fold_with(folder)?,\n-            projection: self.projection.try_fold_with(folder)?,\n-        })\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx [Span] {\n+    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n }\n \n@@ -112,91 +44,12 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        use crate::mir::Rvalue::*;\n-        Ok(match self {\n-            Use(op) => Use(op.try_fold_with(folder)?),\n-            Repeat(op, len) => Repeat(op.try_fold_with(folder)?, len.try_fold_with(folder)?),\n-            ThreadLocalRef(did) => ThreadLocalRef(did.try_fold_with(folder)?),\n-            Ref(region, bk, place) => {\n-                Ref(region.try_fold_with(folder)?, bk, place.try_fold_with(folder)?)\n-            }\n-            CopyForDeref(place) => CopyForDeref(place.try_fold_with(folder)?),\n-            AddressOf(mutability, place) => AddressOf(mutability, place.try_fold_with(folder)?),\n-            Len(place) => Len(place.try_fold_with(folder)?),\n-            Cast(kind, op, ty) => Cast(kind, op.try_fold_with(folder)?, ty.try_fold_with(folder)?),\n-            BinaryOp(op, box (rhs, lhs)) => {\n-                BinaryOp(op, Box::new((rhs.try_fold_with(folder)?, lhs.try_fold_with(folder)?)))\n-            }\n-            CheckedBinaryOp(op, box (rhs, lhs)) => CheckedBinaryOp(\n-                op,\n-                Box::new((rhs.try_fold_with(folder)?, lhs.try_fold_with(folder)?)),\n-            ),\n-            UnaryOp(op, val) => UnaryOp(op, val.try_fold_with(folder)?),\n-            Discriminant(place) => Discriminant(place.try_fold_with(folder)?),\n-            NullaryOp(op, ty) => NullaryOp(op, ty.try_fold_with(folder)?),\n-            Aggregate(kind, fields) => {\n-                let kind = kind.try_map_id(|kind| {\n-                    Ok(match kind {\n-                        AggregateKind::Array(ty) => AggregateKind::Array(ty.try_fold_with(folder)?),\n-                        AggregateKind::Tuple => AggregateKind::Tuple,\n-                        AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n-                            def,\n-                            v,\n-                            substs.try_fold_with(folder)?,\n-                            user_ty.try_fold_with(folder)?,\n-                            n,\n-                        ),\n-                        AggregateKind::Closure(id, substs) => {\n-                            AggregateKind::Closure(id, substs.try_fold_with(folder)?)\n-                        }\n-                        AggregateKind::Generator(id, substs, movablity) => {\n-                            AggregateKind::Generator(id, substs.try_fold_with(folder)?, movablity)\n-                        }\n-                    })\n-                })?;\n-                Aggregate(kind, fields.try_fold_with(folder)?)\n-            }\n-            ShallowInitBox(op, ty) => {\n-                ShallowInitBox(op.try_fold_with(folder)?, ty.try_fold_with(folder)?)\n-            }\n-        })\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        Ok(match self {\n-            Operand::Copy(place) => Operand::Copy(place.try_fold_with(folder)?),\n-            Operand::Move(place) => Operand::Move(place.try_fold_with(folder)?),\n-            Operand::Constant(c) => Operand::Constant(c.try_fold_with(folder)?),\n-        })\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n-        Ok(self)\n-    }\n-}\n-\n impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        Ok(Constant {\n-            span: self.span,\n-            user_ty: self.user_ty.try_fold_with(folder)?,\n-            literal: self.literal.try_fold_with(folder)?,\n-        })\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ConstantKind<'tcx> {\n     #[inline(always)]\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {"}, {"sha": "c01b6215c2da76fdf50aa7a99b89e32b250f1f7f", "filename": "compiler/rustc_middle/src/mir/type_visitable.rs", "status": "modified", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a5ab8da1e22c2cbfca30209ef30cd469a913f08a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ab8da1e22c2cbfca30209ef30cd469a913f08a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs?ref=a5ab8da1e22c2cbfca30209ef30cd469a913f08a", "patch": "@@ -3,159 +3,17 @@\n use super::*;\n use crate::ty;\n \n-impl<'tcx> TypeVisitable<'tcx> for Terminator<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        use crate::mir::TerminatorKind::*;\n-\n-        match self.kind {\n-            SwitchInt { ref discr, switch_ty, .. } => {\n-                discr.visit_with(visitor)?;\n-                switch_ty.visit_with(visitor)\n-            }\n-            Drop { ref place, .. } => place.visit_with(visitor),\n-            DropAndReplace { ref place, ref value, .. } => {\n-                place.visit_with(visitor)?;\n-                value.visit_with(visitor)\n-            }\n-            Yield { ref value, .. } => value.visit_with(visitor),\n-            Call { ref func, ref args, ref destination, .. } => {\n-                destination.visit_with(visitor)?;\n-                func.visit_with(visitor)?;\n-                args.visit_with(visitor)\n-            }\n-            Assert { ref cond, ref msg, .. } => {\n-                cond.visit_with(visitor)?;\n-                use AssertKind::*;\n-                match msg {\n-                    BoundsCheck { ref len, ref index } => {\n-                        len.visit_with(visitor)?;\n-                        index.visit_with(visitor)\n-                    }\n-                    Overflow(_, l, r) => {\n-                        l.visit_with(visitor)?;\n-                        r.visit_with(visitor)\n-                    }\n-                    OverflowNeg(op) | DivisionByZero(op) | RemainderByZero(op) => {\n-                        op.visit_with(visitor)\n-                    }\n-                    ResumedAfterReturn(_) | ResumedAfterPanic(_) => ControlFlow::CONTINUE,\n-                }\n-            }\n-            InlineAsm { ref operands, .. } => operands.visit_with(visitor),\n-            Goto { .. }\n-            | Resume\n-            | Abort\n-            | Return\n-            | GeneratorDrop\n-            | Unreachable\n-            | FalseEdge { .. }\n-            | FalseUnwind { .. } => ControlFlow::CONTINUE,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for GeneratorKind {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for Place<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.local.visit_with(visitor)?;\n-        self.projection.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeVisitable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         self.iter().try_for_each(|t| t.visit_with(visitor))\n     }\n }\n-\n-impl<'tcx> TypeVisitable<'tcx> for Rvalue<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        use crate::mir::Rvalue::*;\n-        match *self {\n-            Use(ref op) => op.visit_with(visitor),\n-            CopyForDeref(ref place) => {\n-                let op = &Operand::Copy(*place);\n-                op.visit_with(visitor)\n-            }\n-            Repeat(ref op, _) => op.visit_with(visitor),\n-            ThreadLocalRef(did) => did.visit_with(visitor),\n-            Ref(region, _, ref place) => {\n-                region.visit_with(visitor)?;\n-                place.visit_with(visitor)\n-            }\n-            AddressOf(_, ref place) => place.visit_with(visitor),\n-            Len(ref place) => place.visit_with(visitor),\n-            Cast(_, ref op, ty) => {\n-                op.visit_with(visitor)?;\n-                ty.visit_with(visitor)\n-            }\n-            BinaryOp(_, box (ref rhs, ref lhs)) | CheckedBinaryOp(_, box (ref rhs, ref lhs)) => {\n-                rhs.visit_with(visitor)?;\n-                lhs.visit_with(visitor)\n-            }\n-            UnaryOp(_, ref val) => val.visit_with(visitor),\n-            Discriminant(ref place) => place.visit_with(visitor),\n-            NullaryOp(_, ty) => ty.visit_with(visitor),\n-            Aggregate(ref kind, ref fields) => {\n-                match **kind {\n-                    AggregateKind::Array(ty) => {\n-                        ty.visit_with(visitor)?;\n-                    }\n-                    AggregateKind::Tuple => {}\n-                    AggregateKind::Adt(_, _, substs, user_ty, _) => {\n-                        substs.visit_with(visitor)?;\n-                        user_ty.visit_with(visitor)?;\n-                    }\n-                    AggregateKind::Closure(_, substs) => {\n-                        substs.visit_with(visitor)?;\n-                    }\n-                    AggregateKind::Generator(_, substs, _) => {\n-                        substs.visit_with(visitor)?;\n-                    }\n-                }\n-                fields.visit_with(visitor)\n-            }\n-            ShallowInitBox(ref op, ty) => {\n-                op.visit_with(visitor)?;\n-                ty.visit_with(visitor)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for Operand<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        match *self {\n-            Operand::Copy(ref place) | Operand::Move(ref place) => place.visit_with(visitor),\n-            Operand::Constant(ref c) => c.visit_with(visitor),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for GeneratorSavedLocal {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n-    }\n-}\n-\n impl<'tcx, R: Idx, C: Idx> TypeVisitable<'tcx> for BitMatrix<R, C> {\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n         ControlFlow::CONTINUE\n     }\n }\n \n-impl<'tcx> TypeVisitable<'tcx> for Constant<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.literal.visit_with(visitor)?;\n-        self.user_ty.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeVisitable<'tcx> for ConstantKind<'tcx> {\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         visitor.visit_mir_const(*self)"}]}