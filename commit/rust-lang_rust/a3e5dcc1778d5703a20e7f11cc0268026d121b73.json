{"sha": "a3e5dcc1778d5703a20e7f11cc0268026d121b73", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZTVkY2MxNzc4ZDU3MDNhMjBlN2YxMWNjMDI2ODAyNmQxMjFiNzM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-07T23:12:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-07T23:12:26Z"}, "message": "Merge #7201\n\n7201: Simplify some matches in completions modules r=matklad a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "ff70e96fc2b5bbb529a6a7c5aec9da3772900a6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff70e96fc2b5bbb529a6a7c5aec9da3772900a6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3e5dcc1778d5703a20e7f11cc0268026d121b73", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf95VaCRBK7hj4Ov3rIwAAdHIIACAbhmv+AeEnf08woiA4jbzH\nOAFnZ5YV0nb4dAEn04X4B0LEBq6HJPoKC1oa8v+eyVUPP1Cp71F34dIUdbSRT6zd\n25qhtGfNv+k8akAY9eZTnHzl8rcEaX+D1nMrD5DTYqe9V1OmxKgysvUIzpmQLykg\n/ZqTlVz47e/6UXDQ7A1Wqsn1Zrfp/R1xBgIIpc014QBIKGoNEQW5slwbIKOPgmwJ\n8u3Kd5yIOjvBh/Gz3sCJ7/aALTorB7SoOsnRS3Iw3wyzieJrd43SqjBUPZaCi67S\nqfwIXhDsOiIGxlWwWVMLuQ+eoAb2LP0tdXaXv61r+SSSgJKcbXWgOqRaCHz/JMI=\n=0qPo\n-----END PGP SIGNATURE-----\n", "payload": "tree ff70e96fc2b5bbb529a6a7c5aec9da3772900a6d\nparent 5722d2b7b88cf04365037b0769316916e486de48\nparent 6dca2cbba5f1a51b7623f064e9b265929f8cff72\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1610061146 +0000\ncommitter GitHub <noreply@github.com> 1610061146 +0000\n\nMerge #7201\n\n7201: Simplify some matches in completions modules r=matklad a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3e5dcc1778d5703a20e7f11cc0268026d121b73", "html_url": "https://github.com/rust-lang/rust/commit/a3e5dcc1778d5703a20e7f11cc0268026d121b73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3e5dcc1778d5703a20e7f11cc0268026d121b73/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5722d2b7b88cf04365037b0769316916e486de48", "url": "https://api.github.com/repos/rust-lang/rust/commits/5722d2b7b88cf04365037b0769316916e486de48", "html_url": "https://github.com/rust-lang/rust/commit/5722d2b7b88cf04365037b0769316916e486de48"}, {"sha": "6dca2cbba5f1a51b7623f064e9b265929f8cff72", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dca2cbba5f1a51b7623f064e9b265929f8cff72", "html_url": "https://github.com/rust-lang/rust/commit/6dca2cbba5f1a51b7623f064e9b265929f8cff72"}], "stats": {"total": 99, "additions": 42, "deletions": 57}, "files": [{"sha": "3a29b5203f2adeeef6a5af2fd5d7e2a4faaab944", "filename": "crates/completion/src/completions/attribute.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a3e5dcc1778d5703a20e7f11cc0268026d121b73/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3e5dcc1778d5703a20e7f11cc0268026d121b73/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=a3e5dcc1778d5703a20e7f11cc0268026d121b73", "patch": "@@ -21,20 +21,15 @@ pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n \n     let attribute = ctx.attribute_under_caret.as_ref()?;\n     match (attribute.path(), attribute.token_tree()) {\n-        (Some(path), Some(token_tree)) if path.to_string() == \"derive\" => {\n-            complete_derive(acc, ctx, token_tree)\n-        }\n-        (Some(path), Some(token_tree)) if path.to_string() == \"feature\" => {\n-            complete_lint(acc, ctx, token_tree, FEATURES);\n-        }\n-        (Some(path), Some(token_tree))\n-            if [\"allow\", \"warn\", \"deny\", \"forbid\"]\n-                .iter()\n-                .any(|lint_level| lint_level == &path.to_string()) =>\n-        {\n-            complete_lint(acc, ctx, token_tree.clone(), DEFAULT_LINT_COMPLETIONS);\n-            complete_lint(acc, ctx, token_tree, CLIPPY_LINTS);\n-        }\n+        (Some(path), Some(token_tree)) => match path.to_string().as_str() {\n+            \"derive\" => complete_derive(acc, ctx, token_tree),\n+            \"feature\" => complete_lint(acc, ctx, token_tree, FEATURES),\n+            \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n+                complete_lint(acc, ctx, token_tree.clone(), DEFAULT_LINT_COMPLETIONS);\n+                complete_lint(acc, ctx, token_tree, CLIPPY_LINTS);\n+            }\n+            _ => {}\n+        },\n         (_, Some(_token_tree)) => {}\n         _ => complete_attribute_start(acc, ctx, attribute),\n     }\n@@ -54,11 +49,8 @@ fn complete_attribute_start(acc: &mut Completions, ctx: &CompletionContext, attr\n             item = item.lookup_by(lookup);\n         }\n \n-        match (attr_completion.snippet, ctx.config.snippet_cap) {\n-            (Some(snippet), Some(cap)) => {\n-                item = item.insert_snippet(cap, snippet);\n-            }\n-            _ => {}\n+        if let Some((snippet, cap)) = attr_completion.snippet.zip(ctx.config.snippet_cap) {\n+            item = item.insert_snippet(cap, snippet);\n         }\n \n         if attribute.kind() == ast::AttrKind::Inner || !attr_completion.prefer_inner {"}, {"sha": "00e951ca95e582ccfd8c08ce1b6b69247b13f64d", "filename": "crates/completion/src/completions/mod_.rs", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a3e5dcc1778d5703a20e7f11cc0268026d121b73/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3e5dcc1778d5703a20e7f11cc0268026d121b73/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=a3e5dcc1778d5703a20e7f11cc0268026d121b73", "patch": "@@ -1,5 +1,7 @@\n //! Completes mod declarations.\n \n+use std::iter;\n+\n use hir::{Module, ModuleSource};\n use ide_db::base_db::{SourceDatabaseExt, VfsPath};\n use ide_db::RootDatabase;\n@@ -12,9 +14,8 @@ use crate::{context::CompletionContext, item::CompletionKind, Completions};\n /// Complete mod declaration, i.e. `mod $0 ;`\n pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n     let mod_under_caret = match &ctx.mod_declaration_under_caret {\n-        Some(mod_under_caret) if mod_under_caret.item_list().is_some() => return None,\n-        Some(mod_under_caret) => mod_under_caret,\n-        None => return None,\n+        Some(mod_under_caret) if mod_under_caret.item_list().is_none() => mod_under_caret,\n+        _ => return None,\n     };\n \n     let _p = profile::span(\"completion::complete_mod\");\n@@ -49,9 +50,13 @@ pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Op\n         .filter_map(|submodule_file| {\n             let submodule_path = source_root.path_for_file(&submodule_file)?;\n             let directory_with_submodule = submodule_path.parent()?;\n-            match submodule_path.name_and_extension()? {\n-                (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => None,\n-                (\"mod\", Some(\"rs\")) => {\n+            let (name, ext) = submodule_path.name_and_extension()?;\n+            if ext != Some(\"rs\") {\n+                return None;\n+            }\n+            match name {\n+                \"lib\" | \"main\" => None,\n+                \"mod\" => {\n                     if directory_with_submodule.parent()? == directory_to_look_for_submodules {\n                         match directory_with_submodule.name_and_extension()? {\n                             (directory_name, None) => Some(directory_name.to_owned()),\n@@ -61,9 +66,7 @@ pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Op\n                         None\n                     }\n                 }\n-                (file_name, Some(\"rs\"))\n-                    if directory_with_submodule == directory_to_look_for_submodules =>\n-                {\n+                file_name if directory_with_submodule == directory_to_look_for_submodules => {\n                     Some(file_name.to_owned())\n                 }\n                 _ => None,\n@@ -73,7 +76,7 @@ pub(crate) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Op\n         .for_each(|submodule_name| {\n             let mut label = submodule_name;\n             if mod_under_caret.semicolon_token().is_none() {\n-                label.push(';')\n+                label.push(';');\n             }\n             CompletionItem::new(CompletionKind::Magic, ctx.source_range(), &label)\n                 .kind(CompletionItemKind::Module)\n@@ -89,11 +92,13 @@ fn directory_to_look_for_submodules(\n     module_file_path: &VfsPath,\n ) -> Option<VfsPath> {\n     let directory_with_module_path = module_file_path.parent()?;\n-    let base_directory = match module_file_path.name_and_extension()? {\n-        (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => {\n-            Some(directory_with_module_path)\n-        }\n-        (regular_rust_file_name, Some(\"rs\")) => {\n+    let (name, ext) = module_file_path.name_and_extension()?;\n+    if ext != Some(\"rs\") {\n+        return None;\n+    }\n+    let base_directory = match name {\n+        \"mod\" | \"lib\" | \"main\" => Some(directory_with_module_path),\n+        regular_rust_file_name => {\n             if matches!(\n                 (\n                     directory_with_module_path\n@@ -110,37 +115,25 @@ fn directory_to_look_for_submodules(\n                 directory_with_module_path.join(regular_rust_file_name)\n             }\n         }\n-        _ => None,\n     }?;\n \n-    let mut resulting_path = base_directory;\n-    for module in module_chain_to_containing_module_file(module, db) {\n-        if let Some(name) = module.name(db) {\n-            resulting_path = resulting_path.join(&name.to_string())?;\n-        }\n-    }\n-\n-    Some(resulting_path)\n+    module_chain_to_containing_module_file(module, db)\n+        .into_iter()\n+        .filter_map(|module| module.name(db))\n+        .try_fold(base_directory, |path, name| path.join(&name.to_string()))\n }\n \n fn module_chain_to_containing_module_file(\n     current_module: Module,\n     db: &RootDatabase,\n ) -> Vec<Module> {\n-    let mut path = Vec::new();\n-\n-    let mut current_module = Some(current_module);\n-    while let Some(ModuleSource::Module(_)) =\n-        current_module.map(|module| module.definition_source(db).value)\n-    {\n-        if let Some(module) = current_module {\n-            path.insert(0, module);\n-            current_module = module.parent(db);\n-        } else {\n-            current_module = None;\n-        }\n-    }\n-\n+    let mut path =\n+        iter::successors(Some(current_module), |current_module| current_module.parent(db))\n+            .take_while(|current_module| {\n+                matches!(current_module.definition_source(db).value, ModuleSource::Module(_))\n+            })\n+            .collect::<Vec<_>>();\n+    path.reverse();\n     path\n }\n "}]}