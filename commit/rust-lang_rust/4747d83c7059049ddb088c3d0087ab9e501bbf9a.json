{"sha": "4747d83c7059049ddb088c3d0087ab9e501bbf9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NDdkODNjNzA1OTA0OWRkYjA4OGMzZDAwODdhYjllNTAxYmJmOWE=", "commit": {"author": {"name": "Geoffry Song", "email": "goffrie@gmail.com", "date": "2018-10-24T07:30:27Z"}, "committer": {"name": "Geoffry Song", "email": "goffrie@gmail.com", "date": "2018-10-26T08:07:10Z"}, "message": "Extend the impl_stable_hash_for! macro for miri.", "tree": {"sha": "b4292e699839fad899d0230762089c98205bf2ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4292e699839fad899d0230762089c98205bf2ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4747d83c7059049ddb088c3d0087ab9e501bbf9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4747d83c7059049ddb088c3d0087ab9e501bbf9a", "html_url": "https://github.com/rust-lang/rust/commit/4747d83c7059049ddb088c3d0087ab9e501bbf9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4747d83c7059049ddb088c3d0087ab9e501bbf9a/comments", "author": {"login": "goffrie", "id": 1240398, "node_id": "MDQ6VXNlcjEyNDAzOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1240398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goffrie", "html_url": "https://github.com/goffrie", "followers_url": "https://api.github.com/users/goffrie/followers", "following_url": "https://api.github.com/users/goffrie/following{/other_user}", "gists_url": "https://api.github.com/users/goffrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/goffrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goffrie/subscriptions", "organizations_url": "https://api.github.com/users/goffrie/orgs", "repos_url": "https://api.github.com/users/goffrie/repos", "events_url": "https://api.github.com/users/goffrie/events{/privacy}", "received_events_url": "https://api.github.com/users/goffrie/received_events", "type": "User", "site_admin": false}, "committer": {"login": "goffrie", "id": 1240398, "node_id": "MDQ6VXNlcjEyNDAzOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1240398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goffrie", "html_url": "https://github.com/goffrie", "followers_url": "https://api.github.com/users/goffrie/followers", "following_url": "https://api.github.com/users/goffrie/following{/other_user}", "gists_url": "https://api.github.com/users/goffrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/goffrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goffrie/subscriptions", "organizations_url": "https://api.github.com/users/goffrie/orgs", "repos_url": "https://api.github.com/users/goffrie/repos", "events_url": "https://api.github.com/users/goffrie/events{/privacy}", "received_events_url": "https://api.github.com/users/goffrie/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f99911a4a0bead7dd1f9ef2f90442844434cc391", "url": "https://api.github.com/repos/rust-lang/rust/commits/f99911a4a0bead7dd1f9ef2f90442844434cc391", "html_url": "https://github.com/rust-lang/rust/commit/f99911a4a0bead7dd1f9ef2f90442844434cc391"}], "stats": {"total": 116, "additions": 40, "deletions": 76}, "files": [{"sha": "f21f949c9f5cd220d8508c0e95225d1c7e6c6fd0", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4747d83c7059049ddb088c3d0087ab9e501bbf9a/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4747d83c7059049ddb088c3d0087ab9e501bbf9a/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=4747d83c7059049ddb088c3d0087ab9e501bbf9a", "patch": "@@ -83,7 +83,14 @@ macro_rules! __impl_stable_hash_field {\n macro_rules! impl_stable_hash_for {\n     // FIXME(mark-i-m): Some of these should be `?` rather than `*`. See the git blame and change\n     // them back when `?` is supported again.\n-    (enum $enum_name:path { $( $variant:ident $( ( $($field:ident $(-> $delegate:tt)*),* ) )* ),* $(,)* }) => {\n+    (enum $enum_name:path {\n+        $( $variant:ident\n+           // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n+           // when it should be only one or the other\n+           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n+           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n+        ),* $(,)*\n+    }) => {\n         impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $enum_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n@@ -94,8 +101,9 @@ macro_rules! impl_stable_hash_for {\n \n                 match *self {\n                     $(\n-                        $variant $( ( $(ref $field),* ) )* => {\n+                        $variant $( ( $(ref $field),* ) )* $( { $(ref $named_field),* } )* => {\n                             $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*)*\n+                            $($( __impl_stable_hash_field!($named_field, __ctx, __hasher $(, $named_delegate)*) );*)*\n                         }\n                     )*\n                 }\n@@ -133,10 +141,11 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n \n-    (impl<$tcx:lifetime $(, $T:ident)*> for struct $struct_name:path {\n-        $($field:ident),* $(,)*\n+    (impl<$tcx:lifetime $(, $lt:lifetime $(: $lt_bound:lifetime)*)* $(, $T:ident)*> for struct $struct_name:path {\n+        $($field:ident $(-> $delegate:tt)*),* $(,)*\n     }) => {\n-        impl<'a, $tcx, $($T,)*> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n+        impl<'a, $tcx, $($lt $(: $lt_bound)*,)* $($T,)*>\n+            ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n             #[inline]\n@@ -147,7 +156,7 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 } = *self;\n \n-                $( $field.hash_stable(__ctx, __hasher));*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n             }\n         }\n     };"}, {"sha": "cff2288fd8720c3ac04cd97045a105d8617d8d29", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 25, "deletions": 70, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4747d83c7059049ddb088c3d0087ab9e501bbf9a/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4747d83c7059049ddb088c3d0087ab9e501bbf9a/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=4747d83c7059049ddb088c3d0087ab9e501bbf9a", "patch": "@@ -6,9 +6,8 @@\n // it is not used by the general miri engine, just by CTFE.\n \n use std::hash::{Hash, Hasher};\n-use std::mem;\n \n-use rustc::ich::{StableHashingContext, StableHashingContextProvider};\n+use rustc::ich::StableHashingContextProvider;\n use rustc::mir;\n use rustc::mir::interpret::{\n     AllocId, Pointer, Scalar,\n@@ -20,7 +19,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::ty::layout::Align;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n \n@@ -217,23 +216,10 @@ impl_snapshot_for!(struct MemPlace {\n     align -> *align, // just copy alignment verbatim\n });\n \n-// Can't use the macro here because that does not support named enum fields.\n-impl<'a> HashStable<StableHashingContext<'a>> for Place {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self, hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>)\n-    {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Place::Ptr(mem_place) => mem_place.hash_stable(hcx, hasher),\n-\n-            Place::Local { frame, local } => {\n-                frame.hash_stable(hcx, hasher);\n-                local.hash_stable(hcx, hasher);\n-            },\n-        }\n-    }\n-}\n+impl_stable_hash_for!(enum ::interpret::Place {\n+    Ptr(mem_place),\n+    Local { frame, local },\n+});\n impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     where Ctx: SnapshotContext<'a>,\n {\n@@ -317,20 +303,10 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n     }\n }\n \n-// Can't use the macro here because that does not support named enum fields.\n-impl<'a> HashStable<StableHashingContext<'a>> for StackPopCleanup {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>)\n-    {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            StackPopCleanup::Goto(ref block) => block.hash_stable(hcx, hasher),\n-            StackPopCleanup::None { cleanup } => cleanup.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n+impl_stable_hash_for!(enum ::interpret::eval_context::StackPopCleanup {\n+    Goto(block),\n+    None { cleanup },\n+});\n \n #[derive(Eq, PartialEq)]\n struct FrameSnapshot<'a, 'tcx: 'a> {\n@@ -343,28 +319,17 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     stmt: usize,\n }\n \n-// Not using the macro because that does not support types depending on two lifetimes\n-impl<'a, 'mir, 'tcx: 'mir> HashStable<StableHashingContext<'a>> for Frame<'mir, 'tcx> {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>) {\n-\n-        let Frame {\n-            mir,\n-            instance,\n-            span,\n-            return_to_block,\n-            return_place,\n-            locals,\n-            block,\n-            stmt,\n-        } = self;\n+impl_stable_hash_for!(impl<'tcx, 'mir: 'tcx> for struct Frame<'mir, 'tcx> {\n+    mir,\n+    instance,\n+    span,\n+    return_to_block,\n+    return_place -> (return_place.as_ref().map(|r| &**r)),\n+    locals,\n+    block,\n+    stmt,\n+});\n \n-        (mir, instance, span, return_to_block).hash_stable(hcx, hasher);\n-        (return_place.as_ref().map(|r| &**r), locals, block, stmt).hash_stable(hcx, hasher);\n-    }\n-}\n impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n     where Ctx: SnapshotContext<'a>,\n {\n@@ -443,21 +408,11 @@ impl<'a, 'mir, 'tcx> Hash for EvalSnapshot<'a, 'mir, 'tcx>\n     }\n }\n \n-// Not using the macro because we need special handling for `memory`, which the macro\n-// does not support at the same time as the extra bounds on the type.\n-impl<'a, 'b, 'mir, 'tcx> HashStable<StableHashingContext<'b>>\n-    for EvalSnapshot<'a, 'mir, 'tcx>\n-{\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'b>,\n-        hasher: &mut StableHasher<W>)\n-    {\n-        // Not hashing memory: Avoid hashing memory all the time during execution\n-        let EvalSnapshot{ memory: _, stack } = self;\n-        stack.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(impl<'tcx, 'b, 'mir> for struct EvalSnapshot<'b, 'mir, 'tcx> {\n+    // Not hashing memory: Avoid hashing memory all the time during execution\n+    memory -> _,\n+    stack,\n+});\n \n impl<'a, 'mir, 'tcx> Eq for EvalSnapshot<'a, 'mir, 'tcx>\n {}"}]}