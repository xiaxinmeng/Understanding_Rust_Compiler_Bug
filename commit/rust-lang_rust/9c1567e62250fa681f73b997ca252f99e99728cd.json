{"sha": "9c1567e62250fa681f73b997ca252f99e99728cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMTU2N2U2MjI1MGZhNjgxZjczYjk5N2NhMjUyZjk5ZTk5NzI4Y2Q=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-28T21:22:37Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-29T05:20:38Z"}, "message": "Fallout from glob shadowing", "tree": {"sha": "02acc7122e6c0eaab875a54f823145a4af3f0f76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02acc7122e6c0eaab875a54f823145a4af3f0f76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c1567e62250fa681f73b997ca252f99e99728cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c1567e62250fa681f73b997ca252f99e99728cd", "html_url": "https://github.com/rust-lang/rust/commit/9c1567e62250fa681f73b997ca252f99e99728cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c1567e62250fa681f73b997ca252f99e99728cd/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f53314cd70dd194ea40c55a5d8ceae7b94409aea", "url": "https://api.github.com/repos/rust-lang/rust/commits/f53314cd70dd194ea40c55a5d8ceae7b94409aea", "html_url": "https://github.com/rust-lang/rust/commit/f53314cd70dd194ea40c55a5d8ceae7b94409aea"}], "stats": {"total": 117, "additions": 50, "deletions": 67}, "files": [{"sha": "8ac9869121cf1bb975af3678e8739dde372ce431", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c1567e62250fa681f73b997ca252f99e99728cd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1567e62250fa681f73b997ca252f99e99728cd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9c1567e62250fa681f73b997ca252f99e99728cd", "patch": "@@ -1554,8 +1554,7 @@ pub fn arg_kind<'a, 'tcx>(cx: &FunctionContext<'a, 'tcx>, t: Ty<'tcx>)\n }\n \n // work around bizarre resolve errors\n-pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n-pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n+type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n \n // create_datums_for_fn_args: creates rvalue datums for each of the\n // incoming function arguments. These will later be stored into"}, {"sha": "78410dc650d78543c5e0b1c81ba58014c6fadc5a", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c1567e62250fa681f73b997ca252f99e99728cd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1567e62250fa681f73b997ca252f99e99728cd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=9c1567e62250fa681f73b997ca252f99e99728cd", "patch": "@@ -190,8 +190,8 @@ pub fn validate_substs(substs: &Substs) {\n }\n \n // work around bizarre resolve errors\n-pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n-pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n+type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n+type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n \n // Function context.  Every LLVM function we create will have one of\n // these."}, {"sha": "4b0b21ec8d856a7bd956e50b1a514cf3108c0a39", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/9c1567e62250fa681f73b997ca252f99e99728cd/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1567e62250fa681f73b997ca252f99e99728cd/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=9c1567e62250fa681f73b997ca252f99e99728cd", "patch": "@@ -181,7 +181,7 @@\n // senders. Under the hood, however, there are actually three flavors of\n // channels in play.\n //\n-// * Oneshots - these channels are highly optimized for the one-send use case.\n+// * Flavor::Oneshots - these channels are highly optimized for the one-send use case.\n //              They contain as few atomics as possible and involve one and\n //              exactly one allocation.\n // * Streams - these channels are optimized for the non-shared use case. They\n@@ -316,7 +316,6 @@ use core::prelude::*;\n \n pub use self::TryRecvError::*;\n pub use self::TrySendError::*;\n-use self::Flavor::*;\n \n use alloc::arc::Arc;\n use core::kinds;\n@@ -478,7 +477,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n #[unstable]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(oneshot::Packet::new()));\n-    (Sender::new(Oneshot(a.clone())), Receiver::new(Oneshot(a)))\n+    (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n }\n \n /// Creates a new synchronous, bounded channel.\n@@ -518,7 +517,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n               of channel that is is creating\"]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(sync::Packet::new(bound)));\n-    (SyncSender::new(a.clone()), Receiver::new(Sync(a)))\n+    (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -592,15 +591,15 @@ impl<T: Send> Sender<T> {\n     #[unstable = \"this function may be renamed to send() in the future\"]\n     pub fn send_opt(&self, t: T) -> Result<(), T> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n-            Oneshot(ref p) => {\n+            Flavor::Oneshot(ref p) => {\n                 unsafe {\n                     let p = p.get();\n                     if !(*p).sent() {\n                         return (*p).send(t);\n                     } else {\n                         let a =\n                             Arc::new(RacyCell::new(stream::Packet::new()));\n-                        match (*p).upgrade(Receiver::new(Stream(a.clone()))) {\n+                        match (*p).upgrade(Receiver::new(Flavor::Stream(a.clone()))) {\n                             oneshot::UpSuccess => {\n                                 let ret = (*a.get()).send(t);\n                                 (a, ret)\n@@ -618,13 +617,13 @@ impl<T: Send> Sender<T> {\n                     }\n                 }\n             }\n-            Stream(ref p) => return unsafe { (*p.get()).send(t) },\n-            Shared(ref p) => return unsafe { (*p.get()).send(t) },\n-            Sync(..) => unreachable!(),\n+            Flavor::Stream(ref p) => return unsafe { (*p.get()).send(t) },\n+            Flavor::Shared(ref p) => return unsafe { (*p.get()).send(t) },\n+            Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n-            let tmp = Sender::new(Stream(new_inner));\n+            let tmp = Sender::new(Flavor::Stream(new_inner));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n         return ret;\n@@ -635,53 +634,53 @@ impl<T: Send> Sender<T> {\n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n-            Oneshot(ref p) => {\n+            Flavor::Oneshot(ref p) => {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n+                    match (*p.get()).upgrade(Receiver::new(Flavor::Shared(a.clone()))) {\n                         oneshot::UpSuccess |\n                         oneshot::UpDisconnected => (a, None, guard),\n                         oneshot::UpWoke(task) => (a, Some(task), guard)\n                     }\n                 }\n             }\n-            Stream(ref p) => {\n+            Flavor::Stream(ref p) => {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n+                    match (*p.get()).upgrade(Receiver::new(Flavor::Shared(a.clone()))) {\n                         stream::UpSuccess |\n                         stream::UpDisconnected => (a, None, guard),\n                         stream::UpWoke(task) => (a, Some(task), guard),\n                     }\n                 }\n             }\n-            Shared(ref p) => {\n+            Flavor::Shared(ref p) => {\n                 unsafe { (*p.get()).clone_chan(); }\n-                return Sender::new(Shared(p.clone()));\n+                return Sender::new(Flavor::Shared(p.clone()));\n             }\n-            Sync(..) => unreachable!(),\n+            Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n             (*packet.get()).inherit_blocker(sleeper, guard);\n \n-            let tmp = Sender::new(Shared(packet.clone()));\n+            let tmp = Sender::new(Flavor::Shared(packet.clone()));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n-        Sender::new(Shared(packet))\n+        Sender::new(Flavor::Shared(packet))\n     }\n }\n \n #[unsafe_destructor]\n impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n-            Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Sync(..) => unreachable!(),\n+            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Sync(..) => unreachable!(),\n         }\n     }\n }\n@@ -827,30 +826,30 @@ impl<T: Send> Receiver<T> {\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return Err(Empty),\n                         Err(oneshot::Disconnected) => return Err(Disconnected),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return Err(Empty),\n                         Err(stream::Disconnected) => return Err(Disconnected),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return Err(Empty),\n                         Err(shared::Disconnected) => return Err(Disconnected),\n                     }\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(sync::Empty) => return Err(Empty),\n@@ -881,30 +880,30 @@ impl<T: Send> Receiver<T> {\n     pub fn recv_opt(&self) -> Result<T, ()> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return unreachable!(),\n                         Err(oneshot::Disconnected) => return Err(()),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return unreachable!(),\n                         Err(stream::Disconnected) => return Err(()),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return unreachable!(),\n                         Err(shared::Disconnected) => return Err(()),\n                     }\n                 }\n-                Sync(ref p) => return unsafe { (*p.get()).recv() }\n+                Flavor::Sync(ref p) => return unsafe { (*p.get()).recv() }\n             };\n             unsafe {\n                 mem::swap(self.inner_mut(), new_port.inner_mut());\n@@ -924,22 +923,22 @@ impl<T: Send> select::Packet for Receiver<T> {\n     fn can_recv(&self) -> bool {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).can_recv() } {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).can_recv() } {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     return unsafe { (*p.get()).can_recv() };\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     return unsafe { (*p.get()).can_recv() };\n                 }\n             };\n@@ -953,24 +952,24 @@ impl<T: Send> select::Packet for Receiver<T> {\n     fn start_selection(&self, mut token: SignalToken) -> StartResult {\n         loop {\n             let (t, new_port) = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).start_selection(token) } {\n                         oneshot::SelSuccess => return Installed,\n                         oneshot::SelCanceled => return Abort,\n                         oneshot::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).start_selection(token) } {\n                         stream::SelSuccess => return Installed,\n                         stream::SelCanceled => return Abort,\n                         stream::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     return unsafe { (*p.get()).start_selection(token) };\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     return unsafe { (*p.get()).start_selection(token) };\n                 }\n             };\n@@ -985,14 +984,14 @@ impl<T: Send> select::Packet for Receiver<T> {\n         let mut was_upgrade = false;\n         loop {\n             let result = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => unsafe { (*p.get()).abort_selection() },\n-                Stream(ref p) => unsafe {\n+                Flavor::Oneshot(ref p) => unsafe { (*p.get()).abort_selection() },\n+                Flavor::Stream(ref p) => unsafe {\n                     (*p.get()).abort_selection(was_upgrade)\n                 },\n-                Shared(ref p) => return unsafe {\n+                Flavor::Shared(ref p) => return unsafe {\n                     (*p.get()).abort_selection(was_upgrade)\n                 },\n-                Sync(ref p) => return unsafe {\n+                Flavor::Sync(ref p) => return unsafe {\n                     (*p.get()).abort_selection()\n                 },\n             };\n@@ -1015,10 +1014,10 @@ impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n-            Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Sync(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Sync(ref mut p) => unsafe { (*p.get()).drop_port(); },\n         }\n     }\n }"}, {"sha": "39b0711721b54a5abccfadd47447c0d7b28f8503", "filename": "src/test/run-pass/issue-7663.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c1567e62250fa681f73b997ca252f99e99728cd/src%2Ftest%2Frun-pass%2Fissue-7663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1567e62250fa681f73b997ca252f99e99728cd/src%2Ftest%2Frun-pass%2Fissue-7663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7663.rs?ref=9c1567e62250fa681f73b997ca252f99e99728cd", "patch": "@@ -17,8 +17,7 @@ mod test1 {\n     mod bar { pub fn p() -> int { 2 } }\n \n     pub mod baz {\n-        use test1::foo::*;\n-        use test1::bar::*;\n+        use test1::bar::p;\n \n         pub fn my_main() { assert!(p() == 2); }\n     }\n@@ -36,20 +35,7 @@ mod test2 {\n     }\n }\n \n-mod test3 {\n-\n-    mod foo { pub fn p() -> int { 1 } }\n-    mod bar { pub fn p() -> int { 2 } }\n-\n-    pub mod baz {\n-        use test3::bar::p;\n-\n-        pub fn my_main() { assert!(p() == 2); }\n-    }\n-}\n-\n fn main() {\n     test1::baz::my_main();\n     test2::baz::my_main();\n-    test3::baz::my_main();\n }"}, {"sha": "2d087406fd6f77a2d31eed60be0227d4646f8c12", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c1567e62250fa681f73b997ca252f99e99728cd/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1567e62250fa681f73b997ca252f99e99728cd/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=9c1567e62250fa681f73b997ca252f99e99728cd", "patch": "@@ -23,7 +23,6 @@\n #![allow(unused_imports)]\n \n use std::io::*;\n-use std::io::net::tcp::*;\n use std::io::test::*;\n use std::io;\n use std::time::Duration;"}]}