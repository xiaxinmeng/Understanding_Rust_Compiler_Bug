{"sha": "3e14f011eceea613b395619d41307cf8d87be84f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMTRmMDExZWNlZWE2MTNiMzk1NjE5ZDQxMzA3Y2Y4ZDg3YmU4NGY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-05-11T20:46:39Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-05-11T20:50:23Z"}, "message": "save-analysis: give better text info in value fields", "tree": {"sha": "5b6c6ff9978c273ce1e360564641f0896a8fe3c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b6c6ff9978c273ce1e360564641f0896a8fe3c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e14f011eceea613b395619d41307cf8d87be84f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e14f011eceea613b395619d41307cf8d87be84f", "html_url": "https://github.com/rust-lang/rust/commit/3e14f011eceea613b395619d41307cf8d87be84f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e14f011eceea613b395619d41307cf8d87be84f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0a987722e8a38494d818443819ad0853771b37e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0a987722e8a38494d818443819ad0853771b37e", "html_url": "https://github.com/rust-lang/rust/commit/a0a987722e8a38494d818443819ad0853771b37e"}], "stats": {"total": 144, "additions": 109, "deletions": 35}, "files": [{"sha": "4d79ddfe8cbe30773d94043ab9975e8299202c43", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3e14f011eceea613b395619d41307cf8d87be84f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e14f011eceea613b395619d41307cf8d87be84f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=3e14f011eceea613b395619d41307cf8d87be84f", "patch": "@@ -39,7 +39,7 @@ use syntax::ast::{self, NodeId, PatKind};\n use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::{path_to_string, ty_to_string};\n+use syntax::print::pprust::{path_to_string, ty_to_string, bounds_to_string, generics_to_string};\n use syntax::ptr::P;\n \n use super::{escape, generated_code, SaveContext, PathCollector};\n@@ -388,9 +388,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n         if let Some(method_data) = self.save_ctxt.get_method_data(id, name, span) {\n \n+            let sig_str = ::make_signature(&sig.decl, &sig.generics);\n             if body.is_some() {\n                 if !self.span.filter_generated(Some(method_data.span), span) {\n-                    self.dumper.function(method_data.clone().lower(self.tcx));\n+                    let mut data = method_data.clone();\n+                    data.value = sig_str;\n+                    self.dumper.function(data.lower(self.tcx));\n                 }\n                 self.process_formals(&sig.decl.inputs, &method_data.qualname);\n             } else {\n@@ -401,7 +404,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         span: method_data.span,\n                         scope: method_data.scope,\n                         qualname: method_data.qualname.clone(),\n-                        value: String::new(), // TODO\n+                        value: sig_str,\n                     }.lower(self.tcx));\n                 }\n             }\n@@ -540,19 +543,33 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         self.visit_expr(expr);\n     }\n \n+    // FIXME tuple structs should generate tuple-specific data.\n     fn process_struct(&mut self,\n                       item: &ast::Item,\n                       def: &ast::VariantData,\n                       ty_params: &ast::Generics) {\n+        let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n-        let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n+        let val = if let ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, _), _) =\n+                    item.node {\n+            let fields_str = fields.iter()\n+                                   .enumerate()\n+                                   .map(|(i, f)| f.ident.map(|i| i.to_string())\n+                                                  .unwrap_or(i.to_string()))\n+                                   .collect::<Vec<_>>()\n+                                   .join(\", \");\n+            format!(\"{} {{ {} }}\", name, fields_str)\n+        } else {\n+            String::new()\n+        };\n+\n         if !self.span.filter_generated(sub_span, item.span) {\n             self.dumper.struct_data(StructData {\n                 span: sub_span.expect(\"No span found for struct\"),\n                 id: item.id,\n-                name: item.ident.to_string(),\n+                name: name,\n                 ctor_id: def.id(),\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n@@ -589,11 +606,17 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             let mut qualname = enum_data.qualname.clone();\n             qualname.push_str(\"::\");\n             qualname.push_str(&name);\n-            let val = self.span.snippet(variant.span);\n \n             match variant.node.data {\n-                ast::VariantData::Struct(..) => {\n+                ast::VariantData::Struct(ref fields, _) => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n+                    let fields_str = fields.iter()\n+                                           .enumerate()\n+                                           .map(|(i, f)| f.ident.map(|i| i.to_string())\n+                                                          .unwrap_or(i.to_string()))\n+                                           .collect::<Vec<_>>()\n+                                           .join(\", \");\n+                    let val = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n                     if !self.span.filter_generated(sub_span, variant.span) {\n                         self.dumper.struct_variant(StructVariantData {\n                             span: sub_span.expect(\"No span found for struct variant\"),\n@@ -606,13 +629,22 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         }.lower(self.tcx));\n                     }\n                 }\n-                _ => {\n+                ref v => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n+                    let mut val = format!(\"{}::{}\", enum_data.name, name);\n+                    if let &ast::VariantData::Tuple(ref fields, _) = v {\n+                        val.push('(');\n+                        val.push_str(&fields.iter()\n+                                            .map(|f| ty_to_string(&f.ty))\n+                                            .collect::<Vec<_>>()\n+                                            .join(\", \"));\n+                        val.push(')');\n+                    }\n                     if !self.span.filter_generated(sub_span, variant.span) {\n                         self.dumper.tuple_variant(TupleVariantData {\n                             span: sub_span.expect(\"No span found for tuple variant\"),\n                             id: variant.node.data.id(),\n-                            name: name.to_string(),\n+                            name: name,\n                             qualname: qualname,\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n@@ -678,14 +710,22 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                      generics: &ast::Generics,\n                      trait_refs: &ast::TyParamBounds,\n                      methods: &[ast::TraitItem]) {\n+        let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-        let val = self.span.snippet(item.span);\n+        let mut val = name.clone();\n+        if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n+            val.push_str(&generics_to_string(generics));\n+        }\n+        if !trait_refs.is_empty() {\n+            val.push_str(\": \");\n+            val.push_str(&bounds_to_string(trait_refs));\n+        }\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         if !self.span.filter_generated(sub_span, item.span) {\n             self.dumper.trait_data(TraitData {\n                 span: sub_span.expect(\"No span found for trait\"),\n                 id: item.id,\n-                name: item.ident.to_string(),\n+                name: name,\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n                 value: val\n@@ -915,13 +955,15 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         self.visit_pat(&p);\n \n         for &(id, ref p, immut, _) in &collector.collected_paths {\n-            let value = if immut == ast::Mutability::Immutable {\n+            let mut value = if immut == ast::Mutability::Immutable {\n                 value.to_string()\n             } else {\n                 \"<mutable>\".to_string()\n             };\n             let types = self.tcx.node_types();\n             let typ = types.get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n+            value.push_str(\": \");\n+            value.push_str(&typ);\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);\n@@ -1283,13 +1325,13 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n             ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {\n-                let value = self.span.snippet(mk_sp(ex.span.lo, subexpression.span.hi));\n+                let value = self.span.snippet(subexpression.span);\n                 self.process_var_decl(pattern, value);\n                 visit::walk_expr(self, subexpression);\n                 visit::walk_block(self, block);\n             }\n             ast::ExprKind::IfLet(ref pattern, ref subexpression, ref block, ref opt_else) => {\n-                let value = self.span.snippet(mk_sp(ex.span.lo, subexpression.span.hi));\n+                let value = self.span.snippet(subexpression.span);\n                 self.process_var_decl(pattern, value);\n                 visit::walk_expr(self, subexpression);\n                 visit::walk_block(self, block);\n@@ -1379,7 +1421,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n \n     fn visit_local(&mut self, l: &ast::Local) {\n         self.process_macro_use(l.span, l.id);\n-        let value = self.span.snippet(l.span);\n+        let value = l.init.as_ref().map(|i| self.span.snippet(i.span)).unwrap_or(String::new());\n         self.process_var_decl(&l.pat, value);\n \n         // Just walk the initialiser and type (don't want to walk the pattern again)."}, {"sha": "bdbecdd1d5341b2cea841aa9d7b700c260d7cab4", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e14f011eceea613b395619d41307cf8d87be84f/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e14f011eceea613b395619d41307cf8d87be84f/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=3e14f011eceea613b395619d41307cf8d87be84f", "patch": "@@ -167,17 +167,17 @@ struct Def {\n \n #[derive(Debug, RustcEncodable)]\n enum DefKind {\n-    // value = type + generics\n+    // value = variant names\n     Enum,\n-    // value = type + generics\n+    // value = enum name + variant name + types\n     Tuple,\n-    // value = type + generics + types\n+    // value = [enum name +] name + fields\n     Struct,\n-    // value = type + generics\n+    // value = signature\n     Trait,\n     // value = type + generics\n     Function,\n-    // No id\n+    // No id, no value.\n     Macro,\n     // value = file_name\n     Mod,\n@@ -186,8 +186,6 @@ enum DefKind {\n     // value = type and init expression\n     Variable,\n }\n-// TODO value for function and method\n-// TODO none of the values are right.\n \n impl From<EnumData> for Def {\n     fn from(data: EnumData) -> Def {"}, {"sha": "8c00a5699939824f2f1882c94d1ef66ada74d37b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3e14f011eceea613b395619d41307cf8d87be84f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e14f011eceea613b395619d41307cf8d87be84f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=3e14f011eceea613b395619d41307cf8d87be84f", "patch": "@@ -52,7 +52,7 @@ use syntax::ast::{self, NodeId, PatKind};\n use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::ty_to_string;\n+use syntax::print::pprust::{ty_to_string, arg_to_string};\n \n pub use self::csv_dumper::CsvDumper;\n pub use self::json_dumper::JsonDumper;\n@@ -122,19 +122,21 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n         match item.node {\n-            ast::ItemKind::Fn(..) => {\n+            ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n                 let name = self.tcx.node_path_str(item.id);\n                 let qualname = format!(\"::{}\", name);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n                 filter!(self.span_utils, sub_span, item.span, None);\n+\n+\n                 Some(Data::FunctionData(FunctionData {\n                     id: item.id,\n                     name: name,\n                     qualname: qualname,\n                     declaration: None,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n-                    value: String::new(), // TODO\n+                    value: make_signature(decl, generics),\n                 }))\n             }\n             ast::ItemKind::Static(ref typ, mt, ref expr) => {\n@@ -191,17 +193,22 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     filename: filename,\n                 }))\n             }\n-            ast::ItemKind::Enum(..) => {\n-                let enum_name = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-                let val = self.span_utils.snippet(item.span);\n+            ast::ItemKind::Enum(ref def, _) => {\n+                let name = item.ident.to_string();\n+                let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Enum);\n                 filter!(self.span_utils, sub_span, item.span, None);\n+                let variants_str = def.variants.iter()\n+                                      .map(|v| v.node.name.to_string())\n+                                      .collect::<Vec<_>>()\n+                                      .join(\", \");\n+                let val = format!(\"{}::{{{}}}\", name, variants_str);\n                 Some(Data::EnumData(EnumData {\n                     id: item.id,\n-                    name: item.ident.to_string(),\n+                    name: name,\n                     value: val,\n                     span: sub_span.unwrap(),\n-                    qualname: enum_name,\n+                    qualname: qualname,\n                     scope: self.enclosing_scope(item.id),\n                 }))\n             }\n@@ -355,7 +362,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             declaration: decl_id,\n             span: sub_span.unwrap(),\n             scope: self.enclosing_scope(id),\n-            value: String::new(), // TODO\n+            // FIXME you get better data here by using the visitor.\n+            value: String::new(),\n         })\n     }\n \n@@ -640,6 +648,35 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n }\n \n+fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n+    let mut sig = String::new();\n+    if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n+        sig.push('<');\n+        sig.push_str(&generics.lifetimes.iter()\n+                              .map(|l| l.lifetime.name.to_string())\n+                              .collect::<Vec<_>>()\n+                              .join(\", \"));\n+        if !generics.lifetimes.is_empty() {\n+            sig.push_str(\", \");\n+        }\n+        sig.push_str(&generics.ty_params.iter()\n+                              .map(|l| l.ident.to_string())\n+                              .collect::<Vec<_>>()\n+                              .join(\", \"));\n+        sig.push_str(\"> \");\n+    }\n+    sig.push('(');\n+    sig.push_str(&decl.inputs.iter().map(arg_to_string).collect::<Vec<_>>().join(\", \"));\n+    sig.push(')');\n+    match decl.output {\n+        ast::FunctionRetTy::None(_) => sig.push_str(\" -> !\"),\n+        ast::FunctionRetTy::Default(_) => {}\n+        ast::FunctionRetTy::Ty(ref t) => sig.push_str(&format!(\" -> {}\", ty_to_string(t))),\n+    }\n+\n+    sig\n+}\n+\n // An AST visitor for collecting paths from patterns.\n struct PathCollector {\n     // The Row field identifies the kind of pattern."}, {"sha": "e9f3472c4a10ca4edc8b8bd87d5e5ea97aae0cc5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e14f011eceea613b395619d41307cf8d87be84f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e14f011eceea613b395619d41307cf8d87be84f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3e14f011eceea613b395619d41307cf8d87be84f", "patch": "@@ -2030,10 +2030,7 @@ pub enum ItemKind {\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n     Struct(VariantData, Generics),\n     /// Represents a Trait Declaration\n-    Trait(Unsafety,\n-              Generics,\n-              TyParamBounds,\n-              Vec<TraitItem>),\n+    Trait(Unsafety, Generics, TyParamBounds, Vec<TraitItem>),\n \n     // Default trait implementations\n     ///"}]}