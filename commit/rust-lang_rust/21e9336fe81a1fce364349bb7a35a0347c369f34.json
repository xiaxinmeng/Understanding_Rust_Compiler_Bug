{"sha": "21e9336fe81a1fce364349bb7a35a0347c369f34", "node_id": "C_kwDOAAsO6NoAKDIxZTkzMzZmZTgxYTFmY2UzNjQzNDliYjdhMzVhMDM0N2MzNjlmMzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-18T18:02:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-18T18:02:39Z"}, "message": "Auto merge of #96501 - jyn514:individual-paths, r=Mark-Simulacrum\n\nPass all paths to `Step::run` at once when using `ShouldRun::krate`\n\nHelps with https://github.com/rust-lang/rust/pull/95503. The goal is to run `cargo test -p rustc_data_structures -p rustc_lint_defs` instead of `cargo test -p rustc_data_structures; cargo test -p rustc_lint_defs`, which should both recompile less and avoid replaying cached warnings.\n\nThis was surprisingly complicated. The main changes are:\n1. Invert the order of iteration in `StepDescription::run`.\n\n    Previously, it did something like:\n    ```python\n    for path in paths:\n    for (step, should_run) in should_runs:\n        if let Some(set) = should_run.pathset_for_path(path):\n        step.run(builder, set)\n    ```\n\n    That worked ok for individual paths, but didn't allow passing more than one path at a time to `Step::run`\n    (since `pathset_for_paths` only had one path available to it).\n    Change it to instead look at the intersection of `paths` and `should_run.paths`:\n\n    ```python\n    for (step, should_run) in should_runs:\n    if let Some(set) = should_run.pathset_for_paths(paths):\n        step.run(builder, set)\n    ```\n\n2. Change `pathset_for_path` to take multiple pathsets.\n\n    The goal is to avoid `x test library/alloc` testing *all* library crates, instead of just alloc.\n    The changes here are similarly subtle, to use the intersection between the paths rather than all\n    paths in `should_run.paths`. I added a test for the behavior to try and make it more clear.\n\n    Note that we use pathsets instead of just paths to allow for sets with multiple aliases (*cough* `all_krates` *cough*).\n    See the documentation added in the next commit for more detail.\n\n3. Change `StepDescription::run` to explicitly handle 0 paths.\n\n    Before this was implicitly handled by the `for` loop, which just didn't excute when there were no paths.\n    Now it needs a check, to avoid trying to run all steps (this is a problem for steps that use `default_condition`).\n\n4. Change `RunDescription` to have a list of pathsets, rather than a single path.\n\n5. Remove paths as they're matched\n\n    This allows checking at the end that no invalid paths are left over.\n    Note that if two steps matched the same path, this will no longer run both;\n    but that's a bug anyway.\n\n6. Handle suite paths separately from regular sets.\n\n    Running multiple suite paths at once instead of in separate `make_run` invocations is both tricky and not particularly useful.\n    The respective test Steps already handle this by introspecting the original paths.\n\n    Avoid having to deal with it by moving suite handling into a seperate loop than `PathSet::Set` checks.\n\n`@rustbot` label +A-rustbuild", "tree": {"sha": "77bc49a340f8652fe83dca0227edbcfa22d331f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77bc49a340f8652fe83dca0227edbcfa22d331f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21e9336fe81a1fce364349bb7a35a0347c369f34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21e9336fe81a1fce364349bb7a35a0347c369f34", "html_url": "https://github.com/rust-lang/rust/commit/21e9336fe81a1fce364349bb7a35a0347c369f34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21e9336fe81a1fce364349bb7a35a0347c369f34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec21d7ea3ca8e96863f175fbd4a6bfee79529d6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec21d7ea3ca8e96863f175fbd4a6bfee79529d6c", "html_url": "https://github.com/rust-lang/rust/commit/ec21d7ea3ca8e96863f175fbd4a6bfee79529d6c"}, {"sha": "fca6dbd9afac228b91749a5ab5c2ba2d8bfcb6ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/fca6dbd9afac228b91749a5ab5c2ba2d8bfcb6ef", "html_url": "https://github.com/rust-lang/rust/commit/fca6dbd9afac228b91749a5ab5c2ba2d8bfcb6ef"}], "stats": {"total": 257, "additions": 190, "deletions": 67}, "files": [{"sha": "62b5416cee8af011605dd4ff05011826ad4f9161", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 124, "deletions": 50, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/21e9336fe81a1fce364349bb7a35a0347c369f34/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e9336fe81a1fce364349bb7a35a0347c369f34/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=21e9336fe81a1fce364349bb7a35a0347c369f34", "patch": "@@ -91,7 +91,7 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n pub struct RunConfig<'a> {\n     pub builder: &'a Builder<'a>,\n     pub target: TargetSelection,\n-    pub path: PathBuf,\n+    pub paths: Vec<PathSet>,\n }\n \n impl RunConfig<'_> {\n@@ -150,11 +150,16 @@ impl Debug for TaskPath {\n /// Collection of paths used to match a task rule.\n #[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n pub enum PathSet {\n-    /// A collection of individual paths.\n+    /// A collection of individual paths or aliases.\n     ///\n     /// These are generally matched as a path suffix. For example, a\n-    /// command-line value of `libstd` will match if `src/libstd` is in the\n+    /// command-line value of `std` will match if `library/std` is in the\n     /// set.\n+    ///\n+    /// NOTE: the paths within a set should always be aliases of one another.\n+    /// For example, `src/librustdoc` and `src/tools/rustdoc` should be in the same set,\n+    /// but `library/core` and `library/std` generally should not, unless there's no way (for that Step)\n+    /// to build them separately.\n     Set(BTreeSet<TaskPath>),\n     /// A \"suite\" of paths.\n     ///\n@@ -177,26 +182,65 @@ impl PathSet {\n     }\n \n     fn has(&self, needle: &Path, module: Option<Kind>) -> bool {\n-        let check = |p: &TaskPath| {\n-            if let (Some(p_kind), Some(kind)) = (&p.kind, module) {\n-                p.path.ends_with(needle) && *p_kind == kind\n-            } else {\n-                p.path.ends_with(needle)\n+        match self {\n+            PathSet::Set(set) => set.iter().any(|p| Self::check(p, needle, module)),\n+            PathSet::Suite(suite) => Self::check(suite, needle, module),\n+        }\n+    }\n+\n+    // internal use only\n+    fn check(p: &TaskPath, needle: &Path, module: Option<Kind>) -> bool {\n+        if let (Some(p_kind), Some(kind)) = (&p.kind, module) {\n+            p.path.ends_with(needle) && *p_kind == kind\n+        } else {\n+            p.path.ends_with(needle)\n+        }\n+    }\n+\n+    /// Return all `TaskPath`s in `Self` that contain any of the `needles`, removing the\n+    /// matched needles.\n+    ///\n+    /// This is used for `StepDescription::krate`, which passes all matching crates at once to\n+    /// `Step::make_run`, rather than calling it many times with a single crate.\n+    /// See `tests.rs` for examples.\n+    fn intersection_removing_matches(\n+        &self,\n+        needles: &mut Vec<&Path>,\n+        module: Option<Kind>,\n+    ) -> PathSet {\n+        let mut check = |p| {\n+            for (i, n) in needles.iter().enumerate() {\n+                let matched = Self::check(p, n, module);\n+                if matched {\n+                    needles.remove(i);\n+                    return true;\n+                }\n             }\n+            false\n         };\n-\n         match self {\n-            PathSet::Set(set) => set.iter().any(check),\n-            PathSet::Suite(suite) => check(suite),\n+            PathSet::Set(set) => PathSet::Set(set.iter().filter(|&p| check(p)).cloned().collect()),\n+            PathSet::Suite(suite) => {\n+                if check(suite) {\n+                    self.clone()\n+                } else {\n+                    PathSet::empty()\n+                }\n+            }\n         }\n     }\n \n-    fn path(&self, builder: &Builder<'_>) -> PathBuf {\n+    /// A convenience wrapper for Steps which know they have no aliases and all their sets contain only a single path.\n+    ///\n+    /// This can be used with [`ShouldRun::krate`], [`ShouldRun::path`], or [`ShouldRun::alias`].\n+    #[track_caller]\n+    pub fn assert_single_path(&self) -> &TaskPath {\n         match self {\n             PathSet::Set(set) => {\n-                set.iter().next().map(|p| &p.path).unwrap_or(&builder.build.src).clone()\n+                assert_eq!(set.len(), 1, \"called assert_single_path on multiple paths\");\n+                set.iter().next().unwrap()\n             }\n-            PathSet::Suite(path) => path.path.clone(),\n+            PathSet::Suite(_) => unreachable!(\"called assert_single_path on a Suite path\"),\n         }\n     }\n }\n@@ -213,16 +257,16 @@ impl StepDescription {\n         }\n     }\n \n-    fn maybe_run(&self, builder: &Builder<'_>, pathset: &PathSet) {\n-        if self.is_excluded(builder, pathset) {\n+    fn maybe_run(&self, builder: &Builder<'_>, pathsets: Vec<PathSet>) {\n+        if pathsets.iter().any(|set| self.is_excluded(builder, set)) {\n             return;\n         }\n \n         // Determine the targets participating in this rule.\n         let targets = if self.only_hosts { &builder.hosts } else { &builder.targets };\n \n         for target in targets {\n-            let run = RunConfig { builder, path: pathset.path(builder), target: *target };\n+            let run = RunConfig { builder, paths: pathsets.clone(), target: *target };\n             (self.make_run)(run);\n         }\n     }\n@@ -261,46 +305,55 @@ impl StepDescription {\n             for (desc, should_run) in v.iter().zip(&should_runs) {\n                 if desc.default && should_run.is_really_default() {\n                     for pathset in &should_run.paths {\n-                        desc.maybe_run(builder, pathset);\n+                        desc.maybe_run(builder, vec![pathset.clone()]);\n                     }\n                 }\n             }\n         }\n \n-        for path in paths {\n-            // strip CurDir prefix if present\n-            let path = match path.strip_prefix(\".\") {\n-                Ok(p) => p,\n-                Err(_) => path,\n-            };\n+        // strip CurDir prefix if present\n+        let mut paths: Vec<_> =\n+            paths.into_iter().map(|p| p.strip_prefix(\".\").unwrap_or(p)).collect();\n \n-            let mut attempted_run = false;\n+        // Handle all test suite paths.\n+        // (This is separate from the loop below to avoid having to handle multiple paths in `is_suite_path` somehow.)\n+        paths.retain(|path| {\n             for (desc, should_run) in v.iter().zip(&should_runs) {\n-                if let Some(suite) = should_run.is_suite_path(path) {\n-                    attempted_run = true;\n-                    desc.maybe_run(builder, suite);\n-                } else if let Some(pathset) = should_run.pathset_for_path(path, desc.kind) {\n-                    attempted_run = true;\n-                    desc.maybe_run(builder, pathset);\n+                if let Some(suite) = should_run.is_suite_path(&path) {\n+                    desc.maybe_run(builder, vec![suite.clone()]);\n+                    return false;\n                 }\n             }\n+            true\n+        });\n \n-            if !attempted_run {\n-                eprintln!(\n-                    \"error: no `{}` rules matched '{}'\",\n-                    builder.kind.as_str(),\n-                    path.display()\n-                );\n-                eprintln!(\n-                    \"help: run `x.py {} --help --verbose` to show a list of available paths\",\n-                    builder.kind.as_str()\n-                );\n-                eprintln!(\n-                    \"note: if you are adding a new Step to bootstrap itself, make sure you register it with `describe!`\"\n-                );\n-                std::process::exit(1);\n+        if paths.is_empty() {\n+            return;\n+        }\n+\n+        // Handle all PathSets.\n+        for (desc, should_run) in v.iter().zip(&should_runs) {\n+            let pathsets = should_run.pathset_for_paths_removing_matches(&mut paths, desc.kind);\n+            if !pathsets.is_empty() {\n+                desc.maybe_run(builder, pathsets);\n             }\n         }\n+\n+        if !paths.is_empty() {\n+            eprintln!(\"error: no `{}` rules matched {:?}\", builder.kind.as_str(), paths,);\n+            eprintln!(\n+                \"help: run `x.py {} --help --verbose` to show a list of available paths\",\n+                builder.kind.as_str()\n+            );\n+            eprintln!(\n+                \"note: if you are adding a new Step to bootstrap itself, make sure you register it with `describe!`\"\n+            );\n+            #[cfg(not(test))]\n+            std::process::exit(1);\n+            #[cfg(test)]\n+            // so we can use #[should_panic]\n+            panic!()\n+        }\n     }\n }\n \n@@ -370,7 +423,7 @@ impl<'a> ShouldRun<'a> {\n     /// Indicates it should run if the command-line selects the given crate or\n     /// any of its (local) dependencies.\n     ///\n-    /// `make_run` will be called separately for each matching command-line path.\n+    /// `make_run` will be called a single time with all matching command-line paths.\n     pub fn krate(mut self, name: &str) -> Self {\n         for krate in self.builder.in_tree_crates(name, None) {\n             let path = krate.local_path(self.builder);\n@@ -417,9 +470,10 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n-    pub fn is_suite_path(&self, path: &Path) -> Option<&PathSet> {\n+    /// Handles individual files (not directories) within a test suite.\n+    fn is_suite_path(&self, requested_path: &Path) -> Option<&PathSet> {\n         self.paths.iter().find(|pathset| match pathset {\n-            PathSet::Suite(p) => path.starts_with(&p.path),\n+            PathSet::Suite(suite) => requested_path.starts_with(&suite.path),\n             PathSet::Set(_) => false,\n         })\n     }\n@@ -435,8 +489,28 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n-    fn pathset_for_path(&self, path: &Path, kind: Kind) -> Option<&PathSet> {\n-        self.paths.iter().find(|pathset| pathset.has(path, Some(kind)))\n+    /// Given a set of requested paths, return the subset which match the Step for this `ShouldRun`,\n+    /// removing the matches from `paths`.\n+    ///\n+    /// NOTE: this returns multiple PathSets to allow for the possibility of multiple units of work\n+    /// within the same step. For example, `test::Crate` allows testing multiple crates in the same\n+    /// cargo invocation, which are put into separate sets because they aren't aliases.\n+    ///\n+    /// The reason we return PathSet instead of PathBuf is to allow for aliases that mean the same thing\n+    /// (for now, just `all_krates` and `paths`, but we may want to add an `aliases` function in the future?)\n+    fn pathset_for_paths_removing_matches(\n+        &self,\n+        paths: &mut Vec<&Path>,\n+        kind: Kind,\n+    ) -> Vec<PathSet> {\n+        let mut sets = vec![];\n+        for pathset in &self.paths {\n+            let subset = pathset.intersection_removing_matches(paths, Some(kind));\n+            if subset != PathSet::empty() {\n+                sets.push(subset);\n+            }\n+        }\n+        sets\n     }\n }\n "}, {"sha": "70cb0de7cce04401dfdf5a7c972fa0b02cdb73d6", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/21e9336fe81a1fce364349bb7a35a0347c369f34/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e9336fe81a1fce364349bb7a35a0347c369f34/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=21e9336fe81a1fce364349bb7a35a0347c369f34", "patch": "@@ -3,7 +3,11 @@ use crate::config::{Config, TargetSelection};\n use std::thread;\n \n fn configure(cmd: &str, host: &[&str], target: &[&str]) -> Config {\n-    let mut config = Config::parse(&[cmd.to_owned()]);\n+    configure_with_args(&[cmd.to_owned()], host, target)\n+}\n+\n+fn configure_with_args(cmd: &[String], host: &[&str], target: &[&str]) -> Config {\n+    let mut config = Config::parse(cmd);\n     // don't save toolstates\n     config.save_toolstates = None;\n     config.dry_run = true;\n@@ -46,6 +50,41 @@ fn run_build(paths: &[PathBuf], config: Config) -> Cache {\n     builder.cache\n }\n \n+fn check_cli<const N: usize>(paths: [&str; N]) {\n+    run_build(\n+        &paths.map(PathBuf::from),\n+        configure_with_args(&paths.map(String::from), &[\"A\"], &[\"A\"]),\n+    );\n+}\n+\n+#[test]\n+fn test_valid() {\n+    // make sure multi suite paths are accepted\n+    check_cli([\"test\", \"src/test/ui/attr-start.rs\", \"src/test/ui/attr-shebang.rs\"]);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_invalid() {\n+    // make sure that invalid paths are caught, even when combined with valid paths\n+    check_cli([\"test\", \"library/std\", \"x\"]);\n+}\n+\n+#[test]\n+fn test_intersection() {\n+    let set = PathSet::Set(\n+        [\"library/core\", \"library/alloc\", \"library/std\"].into_iter().map(TaskPath::parse).collect(),\n+    );\n+    let mut command_paths =\n+        vec![Path::new(\"library/core\"), Path::new(\"library/alloc\"), Path::new(\"library/stdarch\")];\n+    let subset = set.intersection_removing_matches(&mut command_paths, None);\n+    assert_eq!(\n+        subset,\n+        PathSet::Set([\"library/core\", \"library/alloc\"].into_iter().map(TaskPath::parse).collect())\n+    );\n+    assert_eq!(command_paths, vec![Path::new(\"library/stdarch\")]);\n+}\n+\n #[test]\n fn test_exclude() {\n     let mut config = configure(\"test\", &[\"A\"], &[\"A\"]);\n@@ -539,7 +578,7 @@ mod dist {\n                 target: host,\n                 mode: Mode::Std,\n                 test_kind: test::TestKind::Test,\n-                krate: INTERNER.intern_str(\"std\"),\n+                crates: vec![INTERNER.intern_str(\"std\")],\n             },]\n         );\n     }"}, {"sha": "97f0bfdc484da2ea6710e1689f83b6772081d12f", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21e9336fe81a1fce364349bb7a35a0347c369f34/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e9336fe81a1fce364349bb7a35a0347c369f34/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=21e9336fe81a1fce364349bb7a35a0347c369f34", "patch": "@@ -270,15 +270,15 @@ impl Cache {\n \n #[cfg(test)]\n impl Cache {\n-    pub fn all<S: Ord + Copy + Step>(&mut self) -> Vec<(S, S::Output)> {\n+    pub fn all<S: Ord + Clone + Step>(&mut self) -> Vec<(S, S::Output)> {\n         let cache = self.0.get_mut();\n         let type_id = TypeId::of::<S>();\n         let mut v = cache\n             .remove(&type_id)\n             .map(|b| b.downcast::<HashMap<S, S::Output>>().expect(\"correct type\"))\n             .map(|m| m.into_iter().collect::<Vec<_>>())\n             .unwrap_or_default();\n-        v.sort_by_key(|&(a, _)| a);\n+        v.sort_by_key(|(s, _)| s.clone());\n         v\n     }\n "}, {"sha": "b3ebc9916538d14a8d9a94cd8e28f930213c6f6d", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21e9336fe81a1fce364349bb7a35a0347c369f34/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e9336fe81a1fce364349bb7a35a0347c369f34/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=21e9336fe81a1fce364349bb7a35a0347c369f34", "patch": "@@ -170,6 +170,7 @@ mod job {\n     pub unsafe fn setup(_build: &mut crate::Build) {}\n }\n \n+pub use crate::builder::PathSet;\n use crate::cache::{Interned, INTERNER};\n pub use crate::config::Config;\n pub use crate::flags::Subcommand;"}, {"sha": "9958306b5765cf64e4d72889ce7b1e6a8973c7b9", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/21e9336fe81a1fce364349bb7a35a0347c369f34/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e9336fe81a1fce364349bb7a35a0347c369f34/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=21e9336fe81a1fce364349bb7a35a0347c369f34", "patch": "@@ -1856,12 +1856,12 @@ impl Step for RustcGuide {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CrateLibrustc {\n     compiler: Compiler,\n     target: TargetSelection,\n     test_kind: TestKind,\n-    krate: Interned<String>,\n+    crates: Vec<Interned<String>>,\n }\n \n impl Step for CrateLibrustc {\n@@ -1877,10 +1877,14 @@ impl Step for CrateLibrustc {\n         let builder = run.builder;\n         let host = run.build_triple();\n         let compiler = builder.compiler_for(builder.top_stage, host, host);\n-        let krate = builder.crate_paths[&run.path];\n+        let crates = run\n+            .paths\n+            .iter()\n+            .map(|p| builder.crate_paths[&p.assert_single_path().path].clone())\n+            .collect();\n         let test_kind = builder.kind.into();\n \n-        builder.ensure(CrateLibrustc { compiler, target: run.target, test_kind, krate });\n+        builder.ensure(CrateLibrustc { compiler, target: run.target, test_kind, crates });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n@@ -1889,18 +1893,18 @@ impl Step for CrateLibrustc {\n             target: self.target,\n             mode: Mode::Rustc,\n             test_kind: self.test_kind,\n-            krate: self.krate,\n+            crates: self.crates,\n         });\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Crate {\n     pub compiler: Compiler,\n     pub target: TargetSelection,\n     pub mode: Mode,\n     pub test_kind: TestKind,\n-    pub krate: Interned<String>,\n+    pub crates: Vec<Interned<String>>,\n }\n \n impl Step for Crate {\n@@ -1916,9 +1920,13 @@ impl Step for Crate {\n         let host = run.build_triple();\n         let compiler = builder.compiler_for(builder.top_stage, host, host);\n         let test_kind = builder.kind.into();\n-        let krate = builder.crate_paths[&run.path];\n+        let crates = run\n+            .paths\n+            .iter()\n+            .map(|p| builder.crate_paths[&p.assert_single_path().path].clone())\n+            .collect();\n \n-        builder.ensure(Crate { compiler, target: run.target, mode: Mode::Std, test_kind, krate });\n+        builder.ensure(Crate { compiler, target: run.target, mode: Mode::Std, test_kind, crates });\n     }\n \n     /// Runs all unit tests plus documentation tests for a given crate defined\n@@ -1934,7 +1942,6 @@ impl Step for Crate {\n         let target = self.target;\n         let mode = self.mode;\n         let test_kind = self.test_kind;\n-        let krate = self.krate;\n \n         builder.ensure(compile::Std { compiler, target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n@@ -1975,7 +1982,9 @@ impl Step for Crate {\n             DocTests::Yes => {}\n         }\n \n-        cargo.arg(\"-p\").arg(krate);\n+        for krate in &self.crates {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n \n         // The tests are going to run with the *target* libraries, so we need to\n         // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n@@ -2011,8 +2020,8 @@ impl Step for Crate {\n         }\n \n         builder.info(&format!(\n-            \"{} {} stage{} ({} -> {})\",\n-            test_kind, krate, compiler.stage, &compiler.host, target\n+            \"{} {:?} stage{} ({} -> {})\",\n+            test_kind, self.crates, compiler.stage, &compiler.host, target\n         ));\n         let _time = util::timeit(&builder);\n         try_run(builder, &mut cargo.into());"}]}