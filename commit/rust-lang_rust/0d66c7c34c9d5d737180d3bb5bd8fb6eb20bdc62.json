{"sha": "0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNjZjN2MzNGM5ZDVkNzM3MTgwZDNiYjViZDhmYjZlYjIwYmRjNjI=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-02-27T05:38:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-27T05:38:03Z"}, "message": "Rollup merge of #69439 - petrochenkov:latelife, r=matthewjasper\n\nresolve: `lifetimes.rs` -> `late/lifetimes.rs`\n\nLifetime resolution should ideally be merged into the late resolution pass, at least for named lifetimes.\nLet's move it closer to it for a start.", "tree": {"sha": "a3e938ffe24c44fe5c7f289210091667b68a06f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3e938ffe24c44fe5c7f289210091667b68a06f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeV1W7CRBK7hj4Ov3rIwAAdHIIAExXHcmI+PnPEEXpc56ggm1P\nb1ipigie58QnuS3yjwGlXNze3naglnDADUiNSsDRTCtTvKDXI79Wyr3aUgdmH4ih\nG3zkiUUsPCXgwiuuWvvgWK4RbYrtsHLDlCAkC+QXe/vRjnTXPUquqEHLrUaswMfy\nYGHMCxNySy8A/nrvuiseHG5v23Yy/VOCFLDnKB4Bg7szSa59mf9ovYERpanSJFTq\nRocYlGCUJihU9yXwcwuYoaMhHvdxTKj+Pt27dMQXxK1h5jI8spXLq9IPe+5Ibuyv\nC8FF989Ux7VxyswkwNRstZR3NdORgbEASfbg09PUfMDCtgeSnTlF4yLhXiE5/DA=\n=SbCQ\n-----END PGP SIGNATURE-----\n", "payload": "tree a3e938ffe24c44fe5c7f289210091667b68a06f1\nparent add9338673f8b6913f00bf0d7b7b1cf1c50be1f5\nparent f7d55be7e58e15cbc433748715b1dc67adfc5d06\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1582781883 +0900\ncommitter GitHub <noreply@github.com> 1582781883 +0900\n\nRollup merge of #69439 - petrochenkov:latelife, r=matthewjasper\n\nresolve: `lifetimes.rs` -> `late/lifetimes.rs`\n\nLifetime resolution should ideally be merged into the late resolution pass, at least for named lifetimes.\nLet's move it closer to it for a start.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62", "html_url": "https://github.com/rust-lang/rust/commit/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "add9338673f8b6913f00bf0d7b7b1cf1c50be1f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/add9338673f8b6913f00bf0d7b7b1cf1c50be1f5", "html_url": "https://github.com/rust-lang/rust/commit/add9338673f8b6913f00bf0d7b7b1cf1c50be1f5"}, {"sha": "f7d55be7e58e15cbc433748715b1dc67adfc5d06", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7d55be7e58e15cbc433748715b1dc67adfc5d06", "html_url": "https://github.com/rust-lang/rust/commit/f7d55be7e58e15cbc433748715b1dc67adfc5d06"}], "stats": {"total": 492, "additions": 246, "deletions": 246}, "files": [{"sha": "bf9eeb0b6c5ffbdeace0949a39587ec890ccd07c", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 242, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62", "patch": "@@ -6,9 +6,8 @@ use rustc::session::Session;\n use rustc::ty::{self, DefIdTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n-use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -20,7 +19,6 @@ use syntax::ast::{self, Ident, Path};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use crate::imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n-use crate::lifetimes::{ElisionFailureInfo, LifetimeContext};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n@@ -49,40 +47,6 @@ crate struct ImportSuggestion {\n     pub path: Path,\n }\n \n-crate enum MissingLifetimeSpot<'tcx> {\n-    Generics(&'tcx hir::Generics<'tcx>),\n-    HigherRanked { span: Span, span_type: ForLifetimeSpanType },\n-}\n-\n-crate enum ForLifetimeSpanType {\n-    BoundEmpty,\n-    BoundTail,\n-    TypeEmpty,\n-    TypeTail,\n-}\n-\n-impl ForLifetimeSpanType {\n-    crate fn descr(&self) -> &'static str {\n-        match self {\n-            Self::BoundEmpty | Self::BoundTail => \"bound\",\n-            Self::TypeEmpty | Self::TypeTail => \"type\",\n-        }\n-    }\n-\n-    crate fn suggestion(&self, sugg: &str) -> String {\n-        match self {\n-            Self::BoundEmpty | Self::TypeEmpty => format!(\"for<{}> \", sugg),\n-            Self::BoundTail | Self::TypeTail => format!(\", {}\", sugg),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Into<MissingLifetimeSpot<'tcx>> for &'tcx hir::Generics<'tcx> {\n-    fn into(self) -> MissingLifetimeSpot<'tcx> {\n-        MissingLifetimeSpot::Generics(self)\n-    }\n-}\n-\n /// Adjust the impl span so that just the `impl` keyword is taken by removing\n /// everything after `<` (`\"impl<T> Iterator for A<T> {}\" -> \"impl\"`) and\n /// everything after the first whitespace (`\"impl Iterator for A\" -> \"impl\"`).\n@@ -1491,208 +1455,3 @@ crate fn show_candidates(\n         err.note(&msg);\n     }\n }\n-\n-impl<'tcx> LifetimeContext<'_, 'tcx> {\n-    crate fn report_missing_lifetime_specifiers(\n-        &self,\n-        span: Span,\n-        count: usize,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        struct_span_err!(\n-            self.tcx.sess,\n-            span,\n-            E0106,\n-            \"missing lifetime specifier{}\",\n-            pluralize!(count)\n-        )\n-    }\n-\n-    crate fn emit_undeclared_lifetime_error(&self, lifetime_ref: &hir::Lifetime) {\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            lifetime_ref.span,\n-            E0261,\n-            \"use of undeclared lifetime name `{}`\",\n-            lifetime_ref\n-        );\n-        err.span_label(lifetime_ref.span, \"undeclared lifetime\");\n-        for missing in &self.missing_named_lifetime_spots {\n-            match missing {\n-                MissingLifetimeSpot::Generics(generics) => {\n-                    let (span, sugg) = if let Some(param) = generics\n-                        .params\n-                        .iter()\n-                        .filter(|p| match p.kind {\n-                            hir::GenericParamKind::Type {\n-                                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                                ..\n-                            } => false,\n-                            _ => true,\n-                        })\n-                        .next()\n-                    {\n-                        (param.span.shrink_to_lo(), format!(\"{}, \", lifetime_ref))\n-                    } else {\n-                        (generics.span, format!(\"<{}>\", lifetime_ref))\n-                    };\n-                    err.span_suggestion(\n-                        span,\n-                        &format!(\"consider introducing lifetime `{}` here\", lifetime_ref),\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                MissingLifetimeSpot::HigherRanked { span, span_type } => {\n-                    err.span_suggestion(\n-                        *span,\n-                        &format!(\n-                            \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n-                            span_type.descr(),\n-                            lifetime_ref\n-                        ),\n-                        span_type.suggestion(&lifetime_ref.to_string()),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    err.note(\n-                        \"for more information on higher-ranked polymorphism, visit \\\n-                            https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                    );\n-                }\n-            }\n-        }\n-        err.emit();\n-    }\n-\n-    crate fn is_trait_ref_fn_scope(&mut self, trait_ref: &'tcx hir::PolyTraitRef<'tcx>) -> bool {\n-        if let def::Res::Def(_, did) = trait_ref.trait_ref.path.res {\n-            if [\n-                self.tcx.lang_items().fn_once_trait(),\n-                self.tcx.lang_items().fn_trait(),\n-                self.tcx.lang_items().fn_mut_trait(),\n-            ]\n-            .contains(&Some(did))\n-            {\n-                let (span, span_type) = match &trait_ref.bound_generic_params {\n-                    [] => (trait_ref.span.shrink_to_lo(), ForLifetimeSpanType::BoundEmpty),\n-                    [.., bound] => (bound.span.shrink_to_hi(), ForLifetimeSpanType::BoundTail),\n-                };\n-                self.missing_named_lifetime_spots\n-                    .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n-                return true;\n-            }\n-        };\n-        false\n-    }\n-\n-    crate fn add_missing_lifetime_specifiers_label(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        span: Span,\n-        count: usize,\n-        lifetime_names: &FxHashSet<ast::Ident>,\n-        params: &[ElisionFailureInfo],\n-    ) {\n-        if count > 1 {\n-            err.span_label(span, format!(\"expected {} lifetime parameters\", count));\n-        } else {\n-            let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n-            let suggest_existing = |err: &mut DiagnosticBuilder<'_>, sugg| {\n-                err.span_suggestion(\n-                    span,\n-                    \"consider using the named lifetime\",\n-                    sugg,\n-                    Applicability::MaybeIncorrect,\n-                );\n-            };\n-            let suggest_new =\n-                |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n-                    err.span_label(span, \"expected named lifetime parameter\");\n-\n-                    for missing in self.missing_named_lifetime_spots.iter().rev() {\n-                        let mut introduce_suggestion = vec![];\n-                        let msg;\n-                        let should_break;\n-                        introduce_suggestion.push(match missing {\n-                        MissingLifetimeSpot::Generics(generics) => {\n-                            msg = \"consider introducing a named lifetime parameter\".to_string();\n-                            should_break = true;\n-                            if let Some(param) = generics.params.iter().filter(|p| match p.kind {\n-                                hir::GenericParamKind::Type {\n-                                    synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                                    ..\n-                                } => false,\n-                                _ => true,\n-                            }).next() {\n-                                (param.span.shrink_to_lo(), \"'a, \".to_string())\n-                            } else {\n-                                (generics.span, \"<'a>\".to_string())\n-                            }\n-                        }\n-                        MissingLifetimeSpot::HigherRanked { span, span_type } => {\n-                            msg = format!(\n-                                \"consider making the {} lifetime-generic with a new `'a` lifetime\",\n-                                span_type.descr(),\n-                            );\n-                            should_break = false;\n-                            err.note(\n-                                \"for more information on higher-ranked polymorphism, visit \\\n-                             https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                            );\n-                            (*span, span_type.suggestion(\"'a\"))\n-                        }\n-                    });\n-                        for param in params {\n-                            if let Ok(snippet) =\n-                                self.tcx.sess.source_map().span_to_snippet(param.span)\n-                            {\n-                                if snippet.starts_with(\"&\") && !snippet.starts_with(\"&'\") {\n-                                    introduce_suggestion\n-                                        .push((param.span, format!(\"&'a {}\", &snippet[1..])));\n-                                } else if snippet.starts_with(\"&'_ \") {\n-                                    introduce_suggestion\n-                                        .push((param.span, format!(\"&'a {}\", &snippet[4..])));\n-                                }\n-                            }\n-                        }\n-                        introduce_suggestion.push((span, sugg.to_string()));\n-                        err.multipart_suggestion(\n-                            &msg,\n-                            introduce_suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        if should_break {\n-                            break;\n-                        }\n-                    }\n-                };\n-\n-            match (\n-                lifetime_names.len(),\n-                lifetime_names.iter().next(),\n-                snippet.as_ref().map(|s| s.as_str()),\n-            ) {\n-                (1, Some(name), Some(\"&\")) => {\n-                    suggest_existing(err, format!(\"&{} \", name));\n-                }\n-                (1, Some(name), Some(\"'_\")) => {\n-                    suggest_existing(err, name.to_string());\n-                }\n-                (1, Some(name), Some(snippet)) if !snippet.ends_with(\">\") => {\n-                    suggest_existing(err, format!(\"{}<{}>\", snippet, name));\n-                }\n-                (0, _, Some(\"&\")) => {\n-                    suggest_new(err, \"&'a \");\n-                }\n-                (0, _, Some(\"'_\")) => {\n-                    suggest_new(err, \"'a\");\n-                }\n-                (0, _, Some(snippet)) if !snippet.ends_with(\">\") => {\n-                    suggest_new(err, &format!(\"{}<'a>\", snippet));\n-                }\n-                _ => {\n-                    err.span_label(span, \"expected lifetime parameter\");\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "c924fef4dc9d2d1be1e9840e517f6c1c2a93911a", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62", "patch": "@@ -32,6 +32,7 @@ use std::collections::BTreeSet;\n use std::mem::replace;\n \n mod diagnostics;\n+crate mod lifetimes;\n \n type Res = def::Res<NodeId>;\n "}, {"sha": "957574cced79ba3d42b4d02f520c3d74ac289e3f", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 242, "deletions": 1, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62", "patch": "@@ -1,12 +1,14 @@\n use crate::diagnostics::{ImportSuggestion, TypoSuggestion};\n+use crate::late::lifetimes::{ElisionFailureInfo, LifetimeContext};\n use crate::late::{LateResolutionVisitor, RibKind};\n use crate::path_names_to_string;\n use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n use rustc::session::config::nightly_options;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n@@ -28,6 +30,40 @@ enum AssocSuggestion {\n     AssocItem,\n }\n \n+crate enum MissingLifetimeSpot<'tcx> {\n+    Generics(&'tcx hir::Generics<'tcx>),\n+    HigherRanked { span: Span, span_type: ForLifetimeSpanType },\n+}\n+\n+crate enum ForLifetimeSpanType {\n+    BoundEmpty,\n+    BoundTail,\n+    TypeEmpty,\n+    TypeTail,\n+}\n+\n+impl ForLifetimeSpanType {\n+    crate fn descr(&self) -> &'static str {\n+        match self {\n+            Self::BoundEmpty | Self::BoundTail => \"bound\",\n+            Self::TypeEmpty | Self::TypeTail => \"type\",\n+        }\n+    }\n+\n+    crate fn suggestion(&self, sugg: &str) -> String {\n+        match self {\n+            Self::BoundEmpty | Self::TypeEmpty => format!(\"for<{}> \", sugg),\n+            Self::BoundTail | Self::TypeTail => format!(\", {}\", sugg),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Into<MissingLifetimeSpot<'tcx>> for &'tcx hir::Generics<'tcx> {\n+    fn into(self) -> MissingLifetimeSpot<'tcx> {\n+        MissingLifetimeSpot::Generics(self)\n+    }\n+}\n+\n fn is_self_type(path: &[Segment], namespace: Namespace) -> bool {\n     namespace == TypeNS && path.len() == 1 && path[0].ident.name == kw::SelfUpper\n }\n@@ -904,3 +940,208 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n         None\n     }\n }\n+\n+impl<'tcx> LifetimeContext<'_, 'tcx> {\n+    crate fn report_missing_lifetime_specifiers(\n+        &self,\n+        span: Span,\n+        count: usize,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0106,\n+            \"missing lifetime specifier{}\",\n+            pluralize!(count)\n+        )\n+    }\n+\n+    crate fn emit_undeclared_lifetime_error(&self, lifetime_ref: &hir::Lifetime) {\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            lifetime_ref.span,\n+            E0261,\n+            \"use of undeclared lifetime name `{}`\",\n+            lifetime_ref\n+        );\n+        err.span_label(lifetime_ref.span, \"undeclared lifetime\");\n+        for missing in &self.missing_named_lifetime_spots {\n+            match missing {\n+                MissingLifetimeSpot::Generics(generics) => {\n+                    let (span, sugg) = if let Some(param) = generics\n+                        .params\n+                        .iter()\n+                        .filter(|p| match p.kind {\n+                            hir::GenericParamKind::Type {\n+                                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                                ..\n+                            } => false,\n+                            _ => true,\n+                        })\n+                        .next()\n+                    {\n+                        (param.span.shrink_to_lo(), format!(\"{}, \", lifetime_ref))\n+                    } else {\n+                        (generics.span, format!(\"<{}>\", lifetime_ref))\n+                    };\n+                    err.span_suggestion(\n+                        span,\n+                        &format!(\"consider introducing lifetime `{}` here\", lifetime_ref),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                MissingLifetimeSpot::HigherRanked { span, span_type } => {\n+                    err.span_suggestion(\n+                        *span,\n+                        &format!(\n+                            \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                            span_type.descr(),\n+                            lifetime_ref\n+                        ),\n+                        span_type.suggestion(&lifetime_ref.to_string()),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    err.note(\n+                        \"for more information on higher-ranked polymorphism, visit \\\n+                            https://doc.rust-lang.org/nomicon/hrtb.html\",\n+                    );\n+                }\n+            }\n+        }\n+        err.emit();\n+    }\n+\n+    crate fn is_trait_ref_fn_scope(&mut self, trait_ref: &'tcx hir::PolyTraitRef<'tcx>) -> bool {\n+        if let def::Res::Def(_, did) = trait_ref.trait_ref.path.res {\n+            if [\n+                self.tcx.lang_items().fn_once_trait(),\n+                self.tcx.lang_items().fn_trait(),\n+                self.tcx.lang_items().fn_mut_trait(),\n+            ]\n+            .contains(&Some(did))\n+            {\n+                let (span, span_type) = match &trait_ref.bound_generic_params {\n+                    [] => (trait_ref.span.shrink_to_lo(), ForLifetimeSpanType::BoundEmpty),\n+                    [.., bound] => (bound.span.shrink_to_hi(), ForLifetimeSpanType::BoundTail),\n+                };\n+                self.missing_named_lifetime_spots\n+                    .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n+                return true;\n+            }\n+        };\n+        false\n+    }\n+\n+    crate fn add_missing_lifetime_specifiers_label(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        span: Span,\n+        count: usize,\n+        lifetime_names: &FxHashSet<ast::Ident>,\n+        params: &[ElisionFailureInfo],\n+    ) {\n+        if count > 1 {\n+            err.span_label(span, format!(\"expected {} lifetime parameters\", count));\n+        } else {\n+            let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n+            let suggest_existing = |err: &mut DiagnosticBuilder<'_>, sugg| {\n+                err.span_suggestion(\n+                    span,\n+                    \"consider using the named lifetime\",\n+                    sugg,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            };\n+            let suggest_new =\n+                |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n+                    err.span_label(span, \"expected named lifetime parameter\");\n+\n+                    for missing in self.missing_named_lifetime_spots.iter().rev() {\n+                        let mut introduce_suggestion = vec![];\n+                        let msg;\n+                        let should_break;\n+                        introduce_suggestion.push(match missing {\n+                        MissingLifetimeSpot::Generics(generics) => {\n+                            msg = \"consider introducing a named lifetime parameter\".to_string();\n+                            should_break = true;\n+                            if let Some(param) = generics.params.iter().filter(|p| match p.kind {\n+                                hir::GenericParamKind::Type {\n+                                    synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                                    ..\n+                                } => false,\n+                                _ => true,\n+                            }).next() {\n+                                (param.span.shrink_to_lo(), \"'a, \".to_string())\n+                            } else {\n+                                (generics.span, \"<'a>\".to_string())\n+                            }\n+                        }\n+                        MissingLifetimeSpot::HigherRanked { span, span_type } => {\n+                            msg = format!(\n+                                \"consider making the {} lifetime-generic with a new `'a` lifetime\",\n+                                span_type.descr(),\n+                            );\n+                            should_break = false;\n+                            err.note(\n+                                \"for more information on higher-ranked polymorphism, visit \\\n+                             https://doc.rust-lang.org/nomicon/hrtb.html\",\n+                            );\n+                            (*span, span_type.suggestion(\"'a\"))\n+                        }\n+                    });\n+                        for param in params {\n+                            if let Ok(snippet) =\n+                                self.tcx.sess.source_map().span_to_snippet(param.span)\n+                            {\n+                                if snippet.starts_with(\"&\") && !snippet.starts_with(\"&'\") {\n+                                    introduce_suggestion\n+                                        .push((param.span, format!(\"&'a {}\", &snippet[1..])));\n+                                } else if snippet.starts_with(\"&'_ \") {\n+                                    introduce_suggestion\n+                                        .push((param.span, format!(\"&'a {}\", &snippet[4..])));\n+                                }\n+                            }\n+                        }\n+                        introduce_suggestion.push((span, sugg.to_string()));\n+                        err.multipart_suggestion(\n+                            &msg,\n+                            introduce_suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        if should_break {\n+                            break;\n+                        }\n+                    }\n+                };\n+\n+            match (\n+                lifetime_names.len(),\n+                lifetime_names.iter().next(),\n+                snippet.as_ref().map(|s| s.as_str()),\n+            ) {\n+                (1, Some(name), Some(\"&\")) => {\n+                    suggest_existing(err, format!(\"&{} \", name));\n+                }\n+                (1, Some(name), Some(\"'_\")) => {\n+                    suggest_existing(err, name.to_string());\n+                }\n+                (1, Some(name), Some(snippet)) if !snippet.ends_with(\">\") => {\n+                    suggest_existing(err, format!(\"{}<{}>\", snippet, name));\n+                }\n+                (0, _, Some(\"&\")) => {\n+                    suggest_new(err, \"&'a \");\n+                }\n+                (0, _, Some(\"'_\")) => {\n+                    suggest_new(err, \"'a\");\n+                }\n+                (0, _, Some(snippet)) if !snippet.ends_with(\">\") => {\n+                    suggest_new(err, &format!(\"{}<'a>\", snippet));\n+                }\n+                _ => {\n+                    err.span_label(span, \"expected lifetime parameter\");\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "478757f0db737a6ff653603b8e9c72db7d8639df", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62", "patch": "@@ -5,7 +5,7 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n-use crate::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n+use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n use rustc::hir::map::Map;\n use rustc::lint;\n use rustc::middle::resolve_lifetime::*;", "previous_filename": "src/librustc_resolve/lifetimes.rs"}, {"sha": "ebd3f8b832bf11c99a43801a4055e862db8b636c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0d66c7c34c9d5d737180d3bb5bd8fb6eb20bdc62", "patch": "@@ -68,7 +68,6 @@ mod def_collector;\n mod diagnostics;\n mod imports;\n mod late;\n-mod lifetimes;\n mod macros;\n \n enum Weak {\n@@ -2959,5 +2958,5 @@ impl CrateLint {\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n-    lifetimes::provide(providers);\n+    late::lifetimes::provide(providers);\n }"}]}