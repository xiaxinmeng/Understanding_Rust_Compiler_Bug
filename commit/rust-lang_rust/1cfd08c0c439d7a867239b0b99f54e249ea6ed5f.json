{"sha": "1cfd08c0c439d7a867239b0b99f54e249ea6ed5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZmQwOGMwYzQzOWQ3YTg2NzIzOWIwYjk5ZjU0ZTI0OWVhNmVkNWY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-07T21:39:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-18T10:51:42Z"}, "message": "resolve: More precise determinacy tracking during import/macro resolution", "tree": {"sha": "8826ff005e28c33908cb8acdf1e886c265313d79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8826ff005e28c33908cb8acdf1e886c265313d79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f", "html_url": "https://github.com/rust-lang/rust/commit/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0ea1c6f1e2543b905ff486d227e951c8a20756c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0ea1c6f1e2543b905ff486d227e951c8a20756c", "html_url": "https://github.com/rust-lang/rust/commit/f0ea1c6f1e2543b905ff486d227e951c8a20756c"}], "stats": {"total": 299, "additions": 166, "deletions": 133}, "files": [{"sha": "bfcd96cd75a72e7732ad96b6d48b3e55b6db8c5b", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1cfd08c0c439d7a867239b0b99f54e249ea6ed5f", "patch": "@@ -863,7 +863,6 @@ impl<'a, 'b, 'cl> BuildReducedGraphVisitor<'a, 'b, 'cl> {\n         let invocation = self.resolver.invocations[&mark];\n         invocation.module.set(self.resolver.current_module);\n         invocation.parent_legacy_scope.set(self.current_legacy_scope);\n-        invocation.output_legacy_scope.set(self.current_legacy_scope);\n         invocation\n     }\n }"}, {"sha": "7acbf3c2a8d7674b92befabe28ada0ddee05a1ef", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1cfd08c0c439d7a867239b0b99f54e249ea6ed5f", "patch": "@@ -97,6 +97,12 @@ fn is_known_tool(name: Name) -> bool {\n     [\"clippy\", \"rustfmt\"].contains(&&*name.as_str())\n }\n \n+enum DeterminacyExt {\n+    Determined,\n+    Undetermined,\n+    WeakUndetermined,\n+}\n+\n /// A free importable items suggested in case of resolution failure.\n struct ImportSuggestion {\n     path: Path,\n@@ -2022,7 +2028,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n-                false,\n                 record_used,\n                 path_span,\n             );\n@@ -2053,7 +2058,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n-                false,\n                 record_used,\n                 path_span,\n             );\n@@ -2095,7 +2099,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     ident,\n                     ns,\n                     false,\n-                    false,\n                     path_span,\n                 ) {\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -2170,7 +2173,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n         }\n         let result = self.resolve_ident_in_module_unadjusted(\n-            module, ident, ns, false, record_used, span,\n+            module, ident, ns, record_used, span,\n         );\n         self.current_module = orig_current_module;\n         result\n@@ -4411,7 +4414,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 ident,\n                 ns,\n                 false,\n-                false,\n                 module.span,\n             ).is_ok() {\n                 let import_id = match binding.kind {"}, {"sha": "4bbcb90f53bb2aaa4b79324d1cf6d6a847085f65", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 109, "deletions": 91, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=1cfd08c0c439d7a867239b0b99f54e249ea6ed5f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n-use {CrateLint, Resolver, ResolutionError, is_known_tool, resolve_error};\n+use {CrateLint, DeterminacyExt, Resolver, ResolutionError, is_known_tool, resolve_error};\n use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n use ModuleOrUniformRoot;\n use Namespace::{self, *};\n@@ -54,8 +54,8 @@ pub struct InvocationData<'a> {\n     crate parent_legacy_scope: Cell<LegacyScope<'a>>,\n     /// Legacy scope *produced* by expanding this macro invocation,\n     /// includes all the macro_rules items, other invocations, etc generated by it.\n-    /// Set to the parent scope if the macro is not expanded yet (as if the macro produced nothing).\n-    crate output_legacy_scope: Cell<LegacyScope<'a>>,\n+    /// `None` if the macro is not expanded yet.\n+    crate output_legacy_scope: Cell<Option<LegacyScope<'a>>>,\n }\n \n impl<'a> InvocationData<'a> {\n@@ -64,7 +64,7 @@ impl<'a> InvocationData<'a> {\n             module: Cell::new(graph_root),\n             def_index: CRATE_DEF_INDEX,\n             parent_legacy_scope: Cell::new(LegacyScope::Empty),\n-            output_legacy_scope: Cell::new(LegacyScope::Empty),\n+            output_legacy_scope: Cell::new(Some(LegacyScope::Empty)),\n         }\n     }\n }\n@@ -110,7 +110,7 @@ pub struct ParentScope<'a> {\n // Macro namespace is separated into two sub-namespaces, one for bang macros and\n // one for attribute-like macros (attributes, derives).\n // We ignore resolutions from one sub-namespace when searching names in scope for another.\n-fn sub_namespace_mismatch(requirement: Option<MacroKind>, candidate: Option<MacroKind>) -> bool {\n+fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKind>) -> bool {\n     #[derive(PartialEq)]\n     enum SubNS { Bang, AttrLike }\n     let sub_ns = |kind| match kind {\n@@ -121,7 +121,7 @@ fn sub_namespace_mismatch(requirement: Option<MacroKind>, candidate: Option<Macr\n     let requirement = requirement.and_then(|kind| sub_ns(kind));\n     let candidate = candidate.and_then(|kind| sub_ns(kind));\n     // \"No specific sub-namespace\" means \"matches anything\" for both requirements and candidates.\n-    candidate.is_some() && requirement.is_some() && candidate != requirement\n+    candidate.is_none() || requirement.is_none() || candidate == requirement\n }\n \n impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n@@ -136,7 +136,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n             module: Cell::new(module),\n             def_index: module.def_id().unwrap().index,\n             parent_legacy_scope: Cell::new(LegacyScope::Empty),\n-            output_legacy_scope: Cell::new(LegacyScope::Empty),\n+            output_legacy_scope: Cell::new(Some(LegacyScope::Empty)),\n         }));\n         mark\n     }\n@@ -212,7 +212,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n             expansion: mark,\n         };\n         fragment.visit_with(&mut visitor);\n-        invocation.output_legacy_scope.set(visitor.current_legacy_scope);\n+        invocation.output_legacy_scope.set(Some(visitor.current_legacy_scope));\n     }\n \n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n@@ -624,38 +624,50 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let mut innermost_result: Option<(&NameBinding, Flags)> = None;\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = WhereToResolve::DeriveHelpers;\n+        let mut where_to_resolve = if ns == MacroNS {\n+            WhereToResolve::DeriveHelpers\n+        } else {\n+            WhereToResolve::Module(parent_scope.module)\n+        };\n         let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n+        let mut determinacy = Determinacy::Determined;\n         loop {\n             let result = match where_to_resolve {\n                 WhereToResolve::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n                     for derive in &parent_scope.derives {\n                         let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n-                        if let Ok((_, ext)) = self.resolve_macro_to_def(derive, MacroKind::Derive,\n-                                                                        &parent_scope, force) {\n-                            if let SyntaxExtension::ProcMacroDerive(_, helper_attrs, _) = &*ext {\n-                                if helper_attrs.contains(&ident.name) {\n-                                    let binding =\n-                                        (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                        ty::Visibility::Public, derive.span, Mark::root())\n-                                        .to_name_binding(self.arenas);\n-                                    result = Ok((binding, Flags::empty()));\n-                                    break;\n+                        match self.resolve_macro_to_def(derive, MacroKind::Derive,\n+                                                        &parent_scope, force) {\n+                            Ok((_, ext)) => {\n+                                if let SyntaxExtension::ProcMacroDerive(_, helpers, _) = &*ext {\n+                                    if helpers.contains(&ident.name) {\n+                                        let binding =\n+                                            (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                            ty::Visibility::Public, derive.span, Mark::root())\n+                                            .to_name_binding(self.arenas);\n+                                        result = Ok((binding, Flags::empty()));\n+                                        break;\n+                                    }\n                                 }\n                             }\n+                            Err(Determinacy::Determined) => {}\n+                            Err(Determinacy::Undetermined) =>\n+                                result = Err(Determinacy::Undetermined),\n                         }\n                     }\n                     result\n                 }\n                 WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n                     LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n                         Ok((legacy_binding.binding, Flags::MACRO_RULES)),\n+                    LegacyScope::Invocation(invoc) if invoc.output_legacy_scope.get().is_none() =>\n+                        Err(Determinacy::Undetermined),\n                     _ => Err(Determinacy::Determined),\n                 }\n                 WhereToResolve::Module(module) => {\n                     let orig_current_module = mem::replace(&mut self.current_module, module);\n-                    let binding = self.resolve_ident_in_module_unadjusted(\n+                    let binding = self.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(module),\n                         ident,\n                         ns,\n@@ -664,21 +676,33 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         path_span,\n                     );\n                     self.current_module = orig_current_module;\n-                    let misc_flags = if module.is_normal() {\n-                        Flags::MISC_SUGGEST_SELF\n-                    } else {\n-                        Flags::empty()\n-                    };\n-                    binding.map(|binding| (binding, Flags::MODULE | misc_flags))\n+                    match binding {\n+                        Ok(binding) => {\n+                            let misc_flags = if module.is_normal() {\n+                                Flags::MISC_SUGGEST_SELF\n+                            } else {\n+                                Flags::empty()\n+                            };\n+                            Ok((binding, Flags::MODULE | misc_flags))\n+                        }\n+                        Err(DeterminacyExt::Undetermined) =>\n+                            return Err(Determinacy::determined(force)),\n+                        Err(DeterminacyExt::WeakUndetermined) => Err(Determinacy::Undetermined),\n+                        Err(DeterminacyExt::Determined) => Err(Determinacy::Determined),\n+                    }\n                 }\n                 WhereToResolve::MacroUsePrelude => {\n-                    let mut result = Err(Determinacy::Determined);\n                     if use_prelude || self.session.rust_2015() {\n-                        if let Some(binding) = self.macro_use_prelude.get(&ident.name).cloned() {\n-                            result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n+                        match self.macro_use_prelude.get(&ident.name).cloned() {\n+                            Some(binding) =>\n+                                Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n+                            None => Err(Determinacy::determined(\n+                                self.graph_root.unresolved_invocations.borrow().is_empty()\n+                            ))\n                         }\n+                    } else {\n+                        Err(Determinacy::Determined)\n                     }\n-                    result\n                 }\n                 WhereToResolve::BuiltinMacros => {\n                     match self.builtin_macros.get(&ident.name).cloned() {\n@@ -709,14 +733,17 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 }\n                 WhereToResolve::ExternPrelude => {\n-                    let mut result = Err(Determinacy::Determined);\n                     if use_prelude {\n-                        if let Some(binding) = self.extern_prelude_get(ident, !record_used,\n-                                                                       innermost_result.is_some()) {\n-                            result = Ok((binding, Flags::PRELUDE));\n+                        match self.extern_prelude_get(ident, !record_used,\n+                                                      innermost_result.is_some()) {\n+                            Some(binding) => Ok((binding, Flags::PRELUDE)),\n+                            None => Err(Determinacy::determined(\n+                                self.graph_root.unresolved_invocations.borrow().is_empty()\n+                            )),\n                         }\n+                    } else {\n+                        Err(Determinacy::Determined)\n                     }\n-                    result\n                 }\n                 WhereToResolve::ToolPrelude => {\n                     if use_prelude && is_known_tool(ident.name) {\n@@ -736,7 +763,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                 ident,\n                                 ns,\n                                 false,\n-                                false,\n                                 path_span,\n                             ) {\n                                 result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n@@ -757,54 +783,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n             };\n \n-            macro_rules! continue_search { () => {\n-                where_to_resolve = match where_to_resolve {\n-                    WhereToResolve::DeriveHelpers =>\n-                        WhereToResolve::MacroRules(parent_scope.legacy),\n-                    WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n-                        LegacyScope::Binding(binding) =>\n-                            WhereToResolve::MacroRules(binding.parent_legacy_scope),\n-                        LegacyScope::Invocation(invocation) =>\n-                            WhereToResolve::MacroRules(invocation.output_legacy_scope.get()),\n-                        LegacyScope::Empty => WhereToResolve::Module(parent_scope.module),\n-                        LegacyScope::Uninitialized => unreachable!(),\n-                    }\n-                    WhereToResolve::Module(module) => {\n-                        match self.hygienic_lexical_parent(module, &mut ident.span) {\n-                            Some(parent_module) => WhereToResolve::Module(parent_module),\n-                            None => {\n-                                use_prelude = !module.no_implicit_prelude;\n-                                match ns {\n-                                    TypeNS => WhereToResolve::ExternPrelude,\n-                                    ValueNS => WhereToResolve::StdLibPrelude,\n-                                    MacroNS => WhereToResolve::MacroUsePrelude,\n-                                }\n-                            }\n-                        }\n-                    }\n-                    WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n-                    WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n-                    WhereToResolve::BuiltinAttrs => WhereToResolve::LegacyPluginHelpers,\n-                    WhereToResolve::LegacyPluginHelpers => break, // nowhere else to search\n-                    WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n-                    WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n-                    WhereToResolve::StdLibPrelude => match ns {\n-                        TypeNS => WhereToResolve::BuiltinTypes,\n-                        ValueNS => break, // nowhere else to search\n-                        MacroNS => unreachable!(),\n-                    }\n-                    WhereToResolve::BuiltinTypes => break, // nowhere else to search\n-                };\n-\n-                continue;\n-            }}\n-\n             match result {\n-                Ok((binding, flags)) => {\n-                    if sub_namespace_mismatch(macro_kind, binding.macro_kind()) {\n-                        continue_search!();\n-                    }\n-\n+                Ok((binding, flags)) if sub_namespace_match(binding.macro_kind(), macro_kind) => {\n                     if !record_used {\n                         return Ok(binding);\n                     }\n@@ -865,22 +845,60 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // Found the first solution.\n                         innermost_result = Some((binding, flags));\n                     }\n-\n-                    continue_search!();\n-                },\n-                Err(Determinacy::Determined) => {\n-                    continue_search!();\n                 }\n-                Err(Determinacy::Undetermined) => return Err(Determinacy::determined(force)),\n+                Ok(..) | Err(Determinacy::Determined) => {}\n+                Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined\n             }\n+\n+            where_to_resolve = match where_to_resolve {\n+                WhereToResolve::DeriveHelpers =>\n+                    WhereToResolve::MacroRules(parent_scope.legacy),\n+                WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n+                    LegacyScope::Binding(binding) => WhereToResolve::MacroRules(\n+                        binding.parent_legacy_scope\n+                    ),\n+                    LegacyScope::Invocation(invoc) => WhereToResolve::MacroRules(\n+                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope.get())\n+                    ),\n+                    LegacyScope::Empty => WhereToResolve::Module(parent_scope.module),\n+                    LegacyScope::Uninitialized => unreachable!(),\n+                }\n+                WhereToResolve::Module(module) => {\n+                    match self.hygienic_lexical_parent(module, &mut ident.span) {\n+                        Some(parent_module) => WhereToResolve::Module(parent_module),\n+                        None => {\n+                            use_prelude = !module.no_implicit_prelude;\n+                            match ns {\n+                                TypeNS => WhereToResolve::ExternPrelude,\n+                                ValueNS => WhereToResolve::StdLibPrelude,\n+                                MacroNS => WhereToResolve::MacroUsePrelude,\n+                            }\n+                        }\n+                    }\n+                }\n+                WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n+                WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n+                WhereToResolve::BuiltinAttrs => WhereToResolve::LegacyPluginHelpers,\n+                WhereToResolve::LegacyPluginHelpers => break, // nowhere else to search\n+                WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n+                WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n+                WhereToResolve::StdLibPrelude => match ns {\n+                    TypeNS => WhereToResolve::BuiltinTypes,\n+                    ValueNS => break, // nowhere else to search\n+                    MacroNS => unreachable!(),\n+                }\n+                WhereToResolve::BuiltinTypes => break, // nowhere else to search\n+            };\n+\n+            continue;\n         }\n \n         // The first found solution was the only one, return it.\n         if let Some((binding, ..)) = innermost_result {\n             return Ok(binding);\n         }\n \n-        let determinacy = Determinacy::determined(force);\n+        let determinacy = Determinacy::determined(determinacy == Determinacy::Determined || force);\n         if determinacy == Determinacy::Determined && macro_kind == Some(MacroKind::Attr) {\n             // For single-segment attributes interpret determinate \"no resolution\" as a custom\n             // attribute. (Lexical resolution implies the first segment and attr kind should imply\n@@ -1026,7 +1044,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     def_index: invoc.def_index,\n                     module: Cell::new(graph_root),\n                     parent_legacy_scope: Cell::new(LegacyScope::Uninitialized),\n-                    output_legacy_scope: Cell::new(LegacyScope::Uninitialized),\n+                    output_legacy_scope: Cell::new(None),\n                 })\n             });\n         };"}, {"sha": "8cfeb2b12fb30bacfcf9cddc8656773daadb360f", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1cfd08c0c439d7a867239b0b99f54e249ea6ed5f", "patch": "@@ -11,7 +11,7 @@\n use self::ImportDirectiveSubclass::*;\n \n use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n-use {CrateLint, Module, ModuleOrUniformRoot, PerNS};\n+use {CrateLint, DeterminacyExt, Module, ModuleOrUniformRoot, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use {Resolver, Segment};\n@@ -135,16 +135,33 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n \n+    crate fn resolve_ident_in_module_unadjusted(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        record_used: bool,\n+        path_span: Span,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        self.resolve_ident_in_module_unadjusted_ext(\n+            module, ident, ns, false, record_used, path_span\n+        ).map_err(|determinacy_ext| match determinacy_ext {\n+            DeterminacyExt::Determined => Determined,\n+            DeterminacyExt::Undetermined | DeterminacyExt::WeakUndetermined => Undetermined,\n+        })\n+    }\n+\n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n     /// Invariant: if `record_used` is `Some`, expansion and import resolution must be complete.\n-    pub fn resolve_ident_in_module_unadjusted(&mut self,\n-                                              module: ModuleOrUniformRoot<'a>,\n-                                              ident: Ident,\n-                                              ns: Namespace,\n-                                              restricted_shadowing: bool,\n-                                              record_used: bool,\n-                                              path_span: Span)\n-                                              -> Result<&'a NameBinding<'a>, Determinacy> {\n+    crate fn resolve_ident_in_module_unadjusted_ext(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        restricted_shadowing: bool,\n+        record_used: bool,\n+        path_span: Span,\n+    ) -> Result<&'a NameBinding<'a>, DeterminacyExt> {\n         let module = match module {\n             ModuleOrUniformRoot::Module(module) => module,\n             ModuleOrUniformRoot::UniformRoot(root) => {\n@@ -157,7 +174,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                     let mut ctxt = ident.span.ctxt().modern();\n                     let self_module = self.resolve_self(&mut ctxt, self.current_module);\n \n-                    let binding = self.resolve_ident_in_module_unadjusted(\n+                    let binding = self.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(self_module),\n                         ident,\n                         ns,\n@@ -211,12 +228,12 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                         return Ok(binding);\n                     } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n                         // Macro-expanded `extern crate`items still can add names to extern prelude.\n-                        return Err(Undetermined);\n+                        return Err(DeterminacyExt::Undetermined);\n                     } else {\n-                        return Err(Determined);\n+                        return Err(DeterminacyExt::Determined);\n                     }\n                 } else {\n-                    return Err(Determined);\n+                    return Err(DeterminacyExt::Determined);\n                 };\n                 self.populate_module_if_necessary(crate_root);\n                 let binding = (crate_root, ty::Visibility::Public,\n@@ -229,7 +246,8 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n \n         let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n-            .map_err(|_| Determined)?; // This happens when there is a cycle of imports\n+            // This happens when there is a cycle of imports.\n+            .map_err(|_| DeterminacyExt::Determined)?;\n \n         if let Some(binding) = resolution.binding {\n             if !restricted_shadowing && binding.expansion != Mark::root() {\n@@ -264,13 +282,13 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 }\n             }\n \n-            return resolution.binding.ok_or(Determined);\n+            return resolution.binding.ok_or(DeterminacyExt::Determined);\n         }\n \n         let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n             // `extern crate` are always usable for backwards compatibility, see issue #37020.\n             let usable = this.is_accessible(binding.vis) || binding.is_extern_crate();\n-            if usable { Ok(binding) } else { Err(Determined) }\n+            if usable { Ok(binding) } else { Err(DeterminacyExt::Determined) }\n         };\n \n         // Items and single imports are not shadowable, if we have one, then it's determined.\n@@ -288,7 +306,8 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             if !self.is_accessible(single_import.vis.get()) {\n                 continue;\n             }\n-            let module = unwrap_or!(single_import.imported_module.get(), return Err(Undetermined));\n+            let module = unwrap_or!(single_import.imported_module.get(),\n+                                    return Err(DeterminacyExt::Undetermined));\n             let ident = match single_import.subclass {\n                 SingleImport { source, .. } => source,\n                 _ => unreachable!(),\n@@ -298,7 +317,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 Ok(binding) if !self.is_accessible_from(\n                     binding.vis, single_import.parent_scope.module\n                 ) => continue,\n-                Ok(_) | Err(Undetermined) => return Err(Undetermined),\n+                Ok(_) | Err(Undetermined) => return Err(DeterminacyExt::Undetermined),\n             }\n         }\n \n@@ -319,7 +338,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n                 return check_usable(self, binding);\n             } else {\n-                return Err(Undetermined);\n+                return Err(DeterminacyExt::Undetermined);\n             }\n         }\n \n@@ -328,17 +347,13 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         // Now we are in situation when new item/import can appear only from a glob or a macro\n         // expansion. With restricted shadowing names from globs and macro expansions cannot\n         // shadow names from outer scopes, so we can freely fallback from module search to search\n-        // in outer scopes. To continue search in outer scopes we have to lie a bit and return\n-        // `Determined` to `early_resolve_ident_in_lexical_scope` even if the correct answer\n-        // for in-module resolution could be `Undetermined`.\n-        if restricted_shadowing {\n-            return Err(Determined);\n-        }\n+        // in outer scopes. For `early_resolve_ident_in_lexical_scope` to continue search in outer\n+        // scopes we return `WeakUndetermined` instead of full `Undetermined`.\n \n         // Check if one of unexpanded macros can still define the name,\n         // if it can then our \"no resolution\" result is not determined and can be invalidated.\n         if unexpanded_macros {\n-            return Err(Undetermined);\n+            return Err(DeterminacyExt::WeakUndetermined);\n         }\n \n         // Check if one of glob imports can still define the name,\n@@ -350,7 +365,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             let module = match glob_import.imported_module.get() {\n                 Some(ModuleOrUniformRoot::Module(module)) => module,\n                 Some(ModuleOrUniformRoot::UniformRoot(_)) => continue,\n-                None => return Err(Undetermined),\n+                None => return Err(DeterminacyExt::WeakUndetermined),\n             };\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n             match ident.span.glob_adjust(module.expansion, glob_import.span.ctxt().modern()) {\n@@ -363,7 +378,6 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 ident,\n                 ns,\n                 false,\n-                false,\n                 path_span,\n             );\n             self.current_module = orig_current_module;\n@@ -373,12 +387,12 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 Ok(binding) if !self.is_accessible_from(\n                     binding.vis, glob_import.parent_scope.module\n                 ) => continue,\n-                Ok(_) | Err(Undetermined) => return Err(Undetermined),\n+                Ok(_) | Err(Undetermined) => return Err(DeterminacyExt::WeakUndetermined),\n             }\n         }\n \n         // No resolution and no one else can define the name - determinate error.\n-        Err(Determined)\n+        Err(DeterminacyExt::Determined)\n     }\n \n     // Add an import directive to the current module."}, {"sha": "8a40556a6cd0e695f8625754f592837aa3f84a3d", "filename": "src/test/ui/span/macro-ty-params.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr?ref=1cfd08c0c439d7a867239b0b99f54e249ea6ed5f", "patch": "@@ -4,6 +4,12 @@ error: unexpected generic arguments in path\n LL |     m!(MyTrait<>); //~ ERROR generic arguments in macro path\n    |        ^^^^^^^^^\n \n+error: generic arguments in macro path\n+  --> $DIR/macro-ty-params.rs:20:15\n+   |\n+LL |     m!(MyTrait<>); //~ ERROR generic arguments in macro path\n+   |               ^^\n+\n error: generic arguments in macro path\n   --> $DIR/macro-ty-params.rs:18:8\n    |\n@@ -16,11 +22,5 @@ error: generic arguments in macro path\n LL |     foo::<>!(); //~ ERROR generic arguments in macro path\n    |        ^^^^\n \n-error: generic arguments in macro path\n-  --> $DIR/macro-ty-params.rs:20:15\n-   |\n-LL |     m!(MyTrait<>); //~ ERROR generic arguments in macro path\n-   |               ^^\n-\n error: aborting due to 4 previous errors\n "}]}