{"sha": "3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYjdkZDdmNzQ4ZmY1NGZiZTlmZDExN2UwYmQxMGY2N2RhNzBjNDQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-06-05T11:30:41Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-07-28T13:52:34Z"}, "message": "Prep for dropflag-hints: Clarify trans bindings MoveByRef and MoveIntoCopy.", "tree": {"sha": "6368e21ca6a7983f1aad45a88b5f3f6a461a4712", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6368e21ca6a7983f1aad45a88b5f3f6a461a4712"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44", "html_url": "https://github.com/rust-lang/rust/commit/3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c371bb6de7a1c21b7403b86a66a8ce3318ff003", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c371bb6de7a1c21b7403b86a66a8ce3318ff003", "html_url": "https://github.com/rust-lang/rust/commit/4c371bb6de7a1c21b7403b86a66a8ce3318ff003"}], "stats": {"total": 67, "additions": 49, "deletions": 18}, "files": [{"sha": "f4024df571309ca78f094a791d9b96603c321f0a", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44", "patch": "@@ -330,11 +330,35 @@ pub enum OptResult<'blk, 'tcx: 'blk> {\n \n #[derive(Clone, Copy, PartialEq)]\n pub enum TransBindingMode {\n+    /// By-value binding for a copy type: copies from matched data\n+    /// into a fresh LLVM alloca.\n     TrByCopy(/* llbinding */ ValueRef),\n-    TrByMove,\n+\n+    /// By-value binding for a non-copy type where we copy into a\n+    /// fresh LLVM alloca; this most accurately reflects the language\n+    /// semantics (e.g. it properly handles overwrites of the matched\n+    /// input), but potentially injects an unwanted copy.\n+    TrByMoveIntoCopy(/* llbinding */ ValueRef),\n+\n+    /// Binding a non-copy type by reference under the hood; this is\n+    /// a codegen optimization to avoid unnecessary memory traffic.\n+    TrByMoveRef,\n+\n+    /// By-ref binding exposed in the original source input.\n     TrByRef,\n }\n \n+impl TransBindingMode {\n+    /// if binding by making a fresh copy; returns the alloca that it\n+    /// will copy into; otherwise None.\n+    fn alloca_if_copy(&self) -> Option<ValueRef> {\n+        match *self {\n+            TrByCopy(llbinding) | TrByMoveIntoCopy(llbinding) => Some(llbinding),\n+            TrByMoveRef | TrByRef => None,\n+        }\n+    }\n+}\n+\n /// Information about a pattern binding:\n /// - `llmatch` is a pointer to a stack slot.  The stack slot contains a\n ///   pointer into the value being matched.  Hence, llmatch has type `T**`\n@@ -891,7 +915,8 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         let llval = match binding_info.trmode {\n             // By value mut binding for a copy type: load from the ptr\n             // into the matched value and copy to our alloca\n-            TrByCopy(llbinding) => {\n+            TrByCopy(llbinding) |\n+            TrByMoveIntoCopy(llbinding) => {\n                 let llval = Load(bcx, binding_info.llmatch);\n                 let datum = Datum::new(llval, binding_info.ty, Lvalue);\n                 call_lifetime_start(bcx, llbinding);\n@@ -904,7 +929,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             },\n \n             // By value move bindings: load from the ptr into the matched value\n-            TrByMove => Load(bcx, binding_info.llmatch),\n+            TrByMoveRef => Load(bcx, binding_info.llmatch),\n \n             // By ref binding: use the ptr into the matched value\n             TrByRef => binding_info.llmatch\n@@ -944,8 +969,8 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let val = val.to_llbool(bcx);\n \n     for (_, &binding_info) in &data.bindings_map {\n-        if let TrByCopy(llbinding) = binding_info.trmode {\n-            call_lifetime_end(bcx, llbinding);\n+        if let Some(llbinding) = binding_info.trmode.alloca_if_copy() {\n+            call_lifetime_end(bcx, llbinding)\n         }\n     }\n \n@@ -1415,16 +1440,21 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n \n         let llmatch;\n         let trmode;\n+        let moves_by_default = variable_ty.moves_by_default(&param_env, span);\n         match bm {\n-            ast::BindByValue(_)\n-                if !variable_ty.moves_by_default(&param_env, span) || reassigned =>\n+            ast::BindByValue(_) if !moves_by_default || reassigned =>\n             {\n                 llmatch = alloca_no_lifetime(bcx,\n-                                 llvariable_ty.ptr_to(),\n-                                 \"__llmatch\");\n-                trmode = TrByCopy(alloca_no_lifetime(bcx,\n-                                         llvariable_ty,\n-                                         &bcx.name(name)));\n+                                             llvariable_ty.ptr_to(),\n+                                             \"__llmatch\");\n+                let llcopy = alloca_no_lifetime(bcx,\n+                                                llvariable_ty,\n+                                                &bcx.name(name));\n+                trmode = if moves_by_default {\n+                    TrByMoveIntoCopy(llcopy)\n+                } else {\n+                    TrByCopy(llcopy)\n+                };\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n@@ -1433,11 +1463,11 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n                                  &bcx.name(name));\n-                trmode = TrByMove;\n+                trmode = TrByMoveRef;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n-                                 llvariable_ty,\n+                                             llvariable_ty,\n                                  &bcx.name(name));\n                 trmode = TrByRef;\n             }"}, {"sha": "77822397e89ec4e5f211740498edc24b6867cd57", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=3eb7dd7f748ff54fbe9fd117e0bd10f67da70c44", "patch": "@@ -30,7 +30,7 @@ use middle::infer;\n use rustc::ast_map;\n use trans::{type_of, adt, machine, monomorphize};\n use trans::common::{self, CrateContext, FunctionContext, Block};\n-use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n+use trans::_match::{BindingInfo, TransBindingMode};\n use trans::type_::Type;\n use middle::ty::{self, Ty};\n use session::config::{self, FullDebugInfo};\n@@ -2082,14 +2082,15 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // dereference once more. For ByCopy we just use the stack slot we created\n     // for the binding.\n     let var_access = match binding.trmode {\n-        TrByCopy(llbinding) => VariableAccess::DirectVariable {\n+        TransBindingMode::TrByCopy(llbinding) |\n+        TransBindingMode::TrByMoveIntoCopy(llbinding) => VariableAccess::DirectVariable {\n             alloca: llbinding\n         },\n-        TrByMove => VariableAccess::IndirectVariable {\n+        TransBindingMode::TrByMoveRef => VariableAccess::IndirectVariable {\n             alloca: binding.llmatch,\n             address_operations: &aops\n         },\n-        TrByRef => VariableAccess::DirectVariable {\n+        TransBindingMode::TrByRef => VariableAccess::DirectVariable {\n             alloca: binding.llmatch\n         }\n     };"}]}