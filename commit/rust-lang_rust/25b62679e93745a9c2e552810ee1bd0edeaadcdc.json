{"sha": "25b62679e93745a9c2e552810ee1bd0edeaadcdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YjYyNjc5ZTkzNzQ1YTljMmU1NTI4MTBlZTFiZDBlZGVhYWRjZGM=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:33:38Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T21:31:41Z"}, "message": "Taking a peek", "tree": {"sha": "5949312731439a7ad2b1401187663237ec591bee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5949312731439a7ad2b1401187663237ec591bee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25b62679e93745a9c2e552810ee1bd0edeaadcdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25b62679e93745a9c2e552810ee1bd0edeaadcdc", "html_url": "https://github.com/rust-lang/rust/commit/25b62679e93745a9c2e552810ee1bd0edeaadcdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25b62679e93745a9c2e552810ee1bd0edeaadcdc/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4722744e4d0ff1dbc65f906bc5a21ada7581ce24", "url": "https://api.github.com/repos/rust-lang/rust/commits/4722744e4d0ff1dbc65f906bc5a21ada7581ce24", "html_url": "https://github.com/rust-lang/rust/commit/4722744e4d0ff1dbc65f906bc5a21ada7581ce24"}], "stats": {"total": 33, "additions": 16, "deletions": 17}, "files": [{"sha": "c7926cbaa690647ac0758773b7c6986a8e1563aa", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/25b62679e93745a9c2e552810ee1bd0edeaadcdc/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25b62679e93745a9c2e552810ee1bd0edeaadcdc/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=25b62679e93745a9c2e552810ee1bd0edeaadcdc", "patch": "@@ -455,27 +455,26 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n \n         // Iterate over each segment of the path.\n         while let Some((def_id, defs)) = stack.pop() {\n-            let mut params = defs.params.iter();\n-            let mut next_param = params.next();\n+            let mut params = defs.params.iter().peekable();\n \n             // If we have already computed substitutions for parents, we can use those directly.\n-            while let Some(param) = next_param {\n+            while let Some(&param) = params.peek() {\n                 if let Some(&kind) = parent_substs.get(param.index as usize) {\n                     push_kind(&mut substs, kind);\n-                    next_param = params.next();\n+                    params.next();\n                 } else {\n                     break;\n                 }\n             }\n \n             // (Unless it's been handled in `parent_substs`) `Self` is handled first.\n             if has_self {\n-                if let Some(param) = next_param {\n+                if let Some(&param) = params.peek() {\n                     if param.index == 0 {\n                         if let GenericParamDefKind::Type { .. } = param.kind {\n                             push_kind(&mut substs, self_ty.map(|ty| ty.into())\n                                 .unwrap_or_else(|| inferred_kind(None, param, true)));\n-                            next_param = params.next();\n+                            params.next();\n                         }\n                     }\n                 }\n@@ -484,21 +483,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             // Check whether this segment takes generic arguments and the user has provided any.\n             let (generic_args, infer_types) = args_for_def_id(def_id);\n \n-            let mut args = generic_args.iter().flat_map(|generic_args| generic_args.args.iter());\n-            let mut next_arg = args.next();\n+            let mut args = generic_args.iter().flat_map(|generic_args| generic_args.args.iter())\n+                .peekable();\n \n             loop {\n                 // We're going to iterate through the generic arguments that the user\n                 // provided, matching them with the generic parameters we expect.\n                 // Mismatches can occur as a result of elided lifetimes, or for malformed\n                 // input. We try to handle both sensibly.\n                 let mut progress_arg = true;\n-                match (next_arg, next_param) {\n-                    (Some(arg), Some(param)) => {\n+                match (args.peek(), params.peek()) {\n+                    (Some(&arg), Some(&param)) => {\n                         match (arg, &param.kind) {\n                             (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime) => {\n                                 push_kind(&mut substs, provided_kind(param, arg));\n-                                next_param = params.next();\n+                                params.next();\n                             }\n                             (GenericArg::Lifetime(_), GenericParamDefKind::Type { .. }) => {\n                                 // We expected a type argument, but got a lifetime\n@@ -510,13 +509,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                             }\n                             (GenericArg::Type(_), GenericParamDefKind::Type { .. }) => {\n                                 push_kind(&mut substs, provided_kind(param, arg));\n-                                next_param = params.next();\n+                                params.next();\n                             }\n                             (GenericArg::Type(_), GenericParamDefKind::Lifetime) => {\n                                 // We expected a lifetime argument, but got a type\n                                 // argument. That means we're inferring the lifetimes.\n                                 push_kind(&mut substs, inferred_kind(None, param, infer_types));\n-                                next_param = params.next();\n+                                params.next();\n                                 progress_arg = false;\n                             }\n                         }\n@@ -526,7 +525,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                         // Getting to this point means the user supplied more arguments than\n                         // there are parameters.\n                     }\n-                    (None, Some(param)) => {\n+                    (None, Some(&param)) => {\n                         // If there are fewer arguments than parameters, it means\n                         // we're inferring the remaining arguments.\n                         match param.kind {\n@@ -538,12 +537,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                 push_kind(&mut substs, kind);\n                             }\n                         }\n-                        next_param = params.next();\n+                        params.next();\n                     }\n                     (None, None) => break,\n                 }\n                 if progress_arg {\n-                    next_arg = args.next();\n+                    args.next();\n                 }\n             }\n         }"}, {"sha": "6d4d5188e3147c5794164ed3ce59f6fd814dbd88", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25b62679e93745a9c2e552810ee1bd0edeaadcdc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25b62679e93745a9c2e552810ee1bd0edeaadcdc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=25b62679e93745a9c2e552810ee1bd0edeaadcdc", "patch": "@@ -4832,7 +4832,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::VariantCtor(def_id, ..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n-                let mut generics = self.tcx.generics_of(def_id);\n+                let generics = self.tcx.generics_of(def_id);\n                 // Variant and struct constructors use the\n                 // generics of their parent type definition.\n                 let generics_def_id = generics.parent.unwrap_or(def_id);"}]}