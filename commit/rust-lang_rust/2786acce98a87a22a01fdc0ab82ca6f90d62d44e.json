{"sha": "2786acce98a87a22a01fdc0ab82ca6f90d62d44e", "node_id": "C_kwDOAAsO6NoAKDI3ODZhY2NlOThhODdhMjJhMDFmZGMwYWI4MmNhNmY5MGQ2MmQ0NGU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-30T01:53:53Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-05T17:34:47Z"}, "message": "Enforce Tuple trait on Fn traits", "tree": {"sha": "8cefbf0f10f59153b9445d052134319c952ac54f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cefbf0f10f59153b9445d052134319c952ac54f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2786acce98a87a22a01fdc0ab82ca6f90d62d44e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2786acce98a87a22a01fdc0ab82ca6f90d62d44e", "html_url": "https://github.com/rust-lang/rust/commit/2786acce98a87a22a01fdc0ab82ca6f90d62d44e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2786acce98a87a22a01fdc0ab82ca6f90d62d44e/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b8d9dd0a09851b3e4f400ddd1303857945be25d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b8d9dd0a09851b3e4f400ddd1303857945be25d", "html_url": "https://github.com/rust-lang/rust/commit/6b8d9dd0a09851b3e4f400ddd1303857945be25d"}], "stats": {"total": 419, "additions": 419, "deletions": 0}, "files": [{"sha": "66f4c19e0f91ab44df2e8991bad69ec58219428a", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2786acce98a87a22a01fdc0ab82ca6f90d62d44e/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2786acce98a87a22a01fdc0ab82ca6f90d62d44e/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=2786acce98a87a22a01fdc0ab82ca6f90d62d44e", "patch": "@@ -158,6 +158,8 @@ use core::hash::{Hash, Hasher};\n #[cfg(not(no_global_oom_handling))]\n use core::iter::FromIterator;\n use core::iter::{FusedIterator, Iterator};\n+#[cfg(not(bootstrap))]\n+use core::marker::Tuple;\n use core::marker::{Destruct, Unpin, Unsize};\n use core::mem;\n use core::ops::{\n@@ -1979,6 +1981,7 @@ impl<I: ExactSizeIterator + ?Sized, A: Allocator> ExactSizeIterator for Box<I, A\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator + ?Sized, A: Allocator> FusedIterator for Box<I, A> {}\n \n+#[cfg(bootstrap)]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n     type Output = <F as FnOnce<Args>>::Output;\n@@ -1988,20 +1991,48 @@ impl<Args, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n+impl<Args: Tuple, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n+    type Output = <F as FnOnce<Args>>::Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output {\n+        <F as FnOnce<Args>>::call_once(*self, args)\n+    }\n+}\n+\n+#[cfg(bootstrap)]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args, F: FnMut<Args> + ?Sized, A: Allocator> FnMut<Args> for Box<F, A> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output {\n         <F as FnMut<Args>>::call_mut(self, args)\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n+impl<Args: Tuple, F: FnMut<Args> + ?Sized, A: Allocator> FnMut<Args> for Box<F, A> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output {\n+        <F as FnMut<Args>>::call_mut(self, args)\n+    }\n+}\n+\n+#[cfg(bootstrap)]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args, F: Fn<Args> + ?Sized, A: Allocator> Fn<Args> for Box<F, A> {\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output {\n         <F as Fn<Args>>::call(self, args)\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n+impl<Args: Tuple, F: Fn<Args> + ?Sized, A: Allocator> Fn<Args> for Box<F, A> {\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output {\n+        <F as Fn<Args>>::call(self, args)\n+    }\n+}\n+\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized, A: Allocator> CoerceUnsized<Box<U, A>> for Box<T, A> {}\n "}, {"sha": "008926666c136d5f04fc2a8104d2bbd56e195fda", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2786acce98a87a22a01fdc0ab82ca6f90d62d44e/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2786acce98a87a22a01fdc0ab82ca6f90d62d44e/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=2786acce98a87a22a01fdc0ab82ca6f90d62d44e", "patch": "@@ -150,6 +150,7 @@\n #![feature(trusted_len)]\n #![feature(trusted_random_access)]\n #![feature(try_trait_v2)]\n+#![cfg_attr(not(bootstrap), feature(tuple_trait))]\n #![feature(unchecked_math)]\n #![feature(unicode_internals)]\n #![feature(unsize)]"}, {"sha": "bfbd4301230ae144b19fb2bbfdcdaa562f559561", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2786acce98a87a22a01fdc0ab82ca6f90d62d44e/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2786acce98a87a22a01fdc0ab82ca6f90d62d44e/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=2786acce98a87a22a01fdc0ab82ca6f90d62d44e", "patch": "@@ -55,6 +55,8 @@\n #![allow(missing_docs)]\n \n use crate::marker::DiscriminantKind;\n+#[cfg(not(bootstrap))]\n+use crate::marker::Tuple;\n use crate::mem;\n \n // These imports are used for simplifying intra-doc links\n@@ -2169,11 +2171,75 @@ extern \"rust-intrinsic\" {\n     /// `unreachable_unchecked` is actually being reached. The bug is in *crate A*,\n     /// which violates the principle that a `const fn` must behave the same at\n     /// compile-time and at run-time. The unsafe code in crate B is fine.\n+    #[cfg(bootstrap)]\n     #[rustc_const_unstable(feature = \"const_eval_select\", issue = \"none\")]\n     pub fn const_eval_select<ARG, F, G, RET>(arg: ARG, called_in_const: F, called_at_rt: G) -> RET\n     where\n         G: FnOnce<ARG, Output = RET>,\n         F: FnOnce<ARG, Output = RET>;\n+\n+    /// Selects which function to call depending on the context.\n+    ///\n+    /// If this function is evaluated at compile-time, then a call to this\n+    /// intrinsic will be replaced with a call to `called_in_const`. It gets\n+    /// replaced with a call to `called_at_rt` otherwise.\n+    ///\n+    /// # Type Requirements\n+    ///\n+    /// The two functions must be both function items. They cannot be function\n+    /// pointers or closures. The first function must be a `const fn`.\n+    ///\n+    /// `arg` will be the tupled arguments that will be passed to either one of\n+    /// the two functions, therefore, both functions must accept the same type of\n+    /// arguments. Both functions must return RET.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The two functions must behave observably equivalent. Safe code in other\n+    /// crates may assume that calling a `const fn` at compile-time and at run-time\n+    /// produces the same result. A function that produces a different result when\n+    /// evaluated at run-time, or has any other observable side-effects, is\n+    /// *unsound*.\n+    ///\n+    /// Here is an example of how this could cause a problem:\n+    /// ```no_run\n+    /// #![feature(const_eval_select)]\n+    /// #![feature(core_intrinsics)]\n+    /// use std::hint::unreachable_unchecked;\n+    /// use std::intrinsics::const_eval_select;\n+    ///\n+    /// // Crate A\n+    /// pub const fn inconsistent() -> i32 {\n+    ///     fn runtime() -> i32 { 1 }\n+    ///     const fn compiletime() -> i32 { 2 }\n+    ///\n+    ///     unsafe {\n+    //          // \u26a0 This code violates the required equivalence of `compiletime`\n+    ///         // and `runtime`.\n+    ///         const_eval_select((), compiletime, runtime)\n+    ///     }\n+    /// }\n+    ///\n+    /// // Crate B\n+    /// const X: i32 = inconsistent();\n+    /// let x = inconsistent();\n+    /// if x != X { unsafe { unreachable_unchecked(); }}\n+    /// ```\n+    ///\n+    /// This code causes Undefined Behavior when being run, since the\n+    /// `unreachable_unchecked` is actually being reached. The bug is in *crate A*,\n+    /// which violates the principle that a `const fn` must behave the same at\n+    /// compile-time and at run-time. The unsafe code in crate B is fine.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_eval_select\", issue = \"none\")]\n+    pub fn const_eval_select<ARG: Tuple, F, G, RET>(\n+        arg: ARG,\n+        called_in_const: F,\n+        called_at_rt: G,\n+    ) -> RET\n+    where\n+        G: FnOnce<ARG, Output = RET>,\n+        F: FnOnce<ARG, Output = RET>;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "7c93fd30d4ec1ceb8fb0ddb18a857d7b75d232f3", "filename": "library/core/src/ops/function.rs", "status": "modified", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/2786acce98a87a22a01fdc0ab82ca6f90d62d44e/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2786acce98a87a22a01fdc0ab82ca6f90d62d44e/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs?ref=2786acce98a87a22a01fdc0ab82ca6f90d62d44e", "patch": "@@ -1,3 +1,6 @@\n+#[cfg(not(bootstrap))]\n+use crate::marker::Tuple;\n+\n /// The version of the call operator that takes an immutable receiver.\n ///\n /// Instances of `Fn` can be called repeatedly without mutating state.\n@@ -51,6 +54,7 @@\n /// let double = |x| x * 2;\n /// assert_eq!(call_with_one(double), 2);\n /// ```\n+#[cfg(bootstrap)]\n #[lang = \"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Fn\"]\n@@ -78,6 +82,87 @@ pub trait Fn<Args>: FnMut<Args> {\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n }\n \n+/// The version of the call operator that takes an immutable receiver.\n+///\n+/// Instances of `Fn` can be called repeatedly without mutating state.\n+///\n+/// *This trait (`Fn`) is not to be confused with [function pointers]\n+/// (`fn`).*\n+///\n+/// `Fn` is implemented automatically by closures which only take immutable\n+/// references to captured variables or don't capture anything at all, as well\n+/// as (safe) [function pointers] (with some caveats, see their documentation\n+/// for more details). Additionally, for any type `F` that implements `Fn`, `&F`\n+/// implements `Fn`, too.\n+///\n+/// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n+/// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\n+/// is expected.\n+///\n+/// Use `Fn` as a bound when you want to accept a parameter of function-like\n+/// type and need to call it repeatedly and without mutating state (e.g., when\n+/// calling it concurrently). If you do not need such strict requirements, use\n+/// [`FnMut`] or [`FnOnce`] as bounds.\n+///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/ch13-01-closures.html\n+/// [function pointers]: fn\n+/// [nomicon]: ../../nomicon/hrtb.html\n+///\n+/// # Examples\n+///\n+/// ## Calling a closure\n+///\n+/// ```\n+/// let square = |x| x * x;\n+/// assert_eq!(square(5), 25);\n+/// ```\n+///\n+/// ## Using a `Fn` parameter\n+///\n+/// ```\n+/// fn call_with_one<F>(func: F) -> usize\n+///     where F: Fn(usize) -> usize {\n+///     func(1)\n+/// }\n+///\n+/// let double = |x| x * 2;\n+/// assert_eq!(call_with_one(double), 2);\n+/// ```\n+#[cfg(not(bootstrap))]\n+#[lang = \"fn\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"Fn\"]\n+#[rustc_paren_sugar]\n+#[rustc_on_unimplemented(\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n+    ),\n+    on(\n+        _Self = \"unsafe fn\",\n+        note = \"unsafe function cannot be called generically without an unsafe block\",\n+        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n+        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n+    ),\n+    message = \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `Fn<{Args}>` closure, found `{Self}`\"\n+)]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n+#[const_trait]\n+pub trait Fn<Args: Tuple>: FnMut<Args> {\n+    /// Performs the call operation.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n /// The version of the call operator that takes a mutable receiver.\n ///\n /// Instances of `FnMut` can be called repeatedly and may mutate state.\n@@ -139,6 +224,7 @@ pub trait Fn<Args>: FnMut<Args> {\n ///\n /// assert_eq!(x, 5);\n /// ```\n+#[cfg(bootstrap)]\n #[lang = \"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"FnMut\"]\n@@ -166,6 +252,95 @@ pub trait FnMut<Args>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n+/// The version of the call operator that takes a mutable receiver.\n+///\n+/// Instances of `FnMut` can be called repeatedly and may mutate state.\n+///\n+/// `FnMut` is implemented automatically by closures which take mutable\n+/// references to captured variables, as well as all types that implement\n+/// [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of\n+/// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n+/// implements `FnMut`, too.\n+///\n+/// Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\n+/// used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n+/// `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n+///\n+/// Use `FnMut` as a bound when you want to accept a parameter of function-like\n+/// type and need to call it repeatedly, while allowing it to mutate state.\n+/// If you don't want the parameter to mutate state, use [`Fn`] as a\n+/// bound; if you don't need to call it repeatedly, use [`FnOnce`].\n+///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/ch13-01-closures.html\n+/// [function pointers]: fn\n+/// [nomicon]: ../../nomicon/hrtb.html\n+///\n+/// # Examples\n+///\n+/// ## Calling a mutably capturing closure\n+///\n+/// ```\n+/// let mut x = 5;\n+/// {\n+///     let mut square_x = || x *= x;\n+///     square_x();\n+/// }\n+/// assert_eq!(x, 25);\n+/// ```\n+///\n+/// ## Using a `FnMut` parameter\n+///\n+/// ```\n+/// fn do_twice<F>(mut func: F)\n+///     where F: FnMut()\n+/// {\n+///     func();\n+///     func();\n+/// }\n+///\n+/// let mut x: usize = 1;\n+/// {\n+///     let add_two_to_x = || x += 2;\n+///     do_twice(add_two_to_x);\n+/// }\n+///\n+/// assert_eq!(x, 5);\n+/// ```\n+#[cfg(not(bootstrap))]\n+#[lang = \"fn_mut\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"FnMut\"]\n+#[rustc_paren_sugar]\n+#[rustc_on_unimplemented(\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n+    ),\n+    on(\n+        _Self = \"unsafe fn\",\n+        note = \"unsafe function cannot be called generically without an unsafe block\",\n+        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n+        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n+    ),\n+    message = \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `FnMut<{Args}>` closure, found `{Self}`\"\n+)]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n+#[const_trait]\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n+    /// Performs the call operation.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n /// The version of the call operator that takes a by-value receiver.\n ///\n /// Instances of `FnOnce` can be called, but might not be callable multiple\n@@ -219,6 +394,7 @@ pub trait FnMut<Args>: FnOnce<Args> {\n ///\n /// // `consume_and_return_x` can no longer be invoked at this point\n /// ```\n+#[cfg(bootstrap)]\n #[lang = \"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"FnOnce\"]\n@@ -251,6 +427,93 @@ pub trait FnOnce<Args> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n \n+/// The version of the call operator that takes a by-value receiver.\n+///\n+/// Instances of `FnOnce` can be called, but might not be callable multiple\n+/// times. Because of this, if the only thing known about a type is that it\n+/// implements `FnOnce`, it can only be called once.\n+///\n+/// `FnOnce` is implemented automatically by closures that might consume captured\n+/// variables, as well as all types that implement [`FnMut`], e.g., (safe)\n+/// [function pointers] (since `FnOnce` is a supertrait of [`FnMut`]).\n+///\n+/// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n+/// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n+///\n+/// Use `FnOnce` as a bound when you want to accept a parameter of function-like\n+/// type and only need to call it once. If you need to call the parameter\n+/// repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\n+/// state, use [`Fn`].\n+///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/ch13-01-closures.html\n+/// [function pointers]: fn\n+/// [nomicon]: ../../nomicon/hrtb.html\n+///\n+/// # Examples\n+///\n+/// ## Using a `FnOnce` parameter\n+///\n+/// ```\n+/// fn consume_with_relish<F>(func: F)\n+///     where F: FnOnce() -> String\n+/// {\n+///     // `func` consumes its captured variables, so it cannot be run more\n+///     // than once.\n+///     println!(\"Consumed: {}\", func());\n+///\n+///     println!(\"Delicious!\");\n+///\n+///     // Attempting to invoke `func()` again will throw a `use of moved\n+///     // value` error for `func`.\n+/// }\n+///\n+/// let x = String::from(\"x\");\n+/// let consume_and_return_x = move || x;\n+/// consume_with_relish(consume_and_return_x);\n+///\n+/// // `consume_and_return_x` can no longer be invoked at this point\n+/// ```\n+#[cfg(not(bootstrap))]\n+#[lang = \"fn_once\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"FnOnce\"]\n+#[rustc_paren_sugar]\n+#[rustc_on_unimplemented(\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n+    ),\n+    on(\n+        _Self = \"unsafe fn\",\n+        note = \"unsafe function cannot be called generically without an unsafe block\",\n+        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n+        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n+    ),\n+    message = \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `FnOnce<{Args}>` closure, found `{Self}`\"\n+)]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n+#[const_trait]\n+pub trait FnOnce<Args: Tuple> {\n+    /// The returned type after the call operator is used.\n+    #[lang = \"fn_once_output\"]\n+    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n+    type Output;\n+\n+    /// Performs the call operation.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+#[cfg(bootstrap)]\n mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n@@ -310,3 +573,61 @@ mod impls {\n         }\n     }\n }\n+\n+#[cfg(not(bootstrap))]\n+mod impls {\n+    use crate::marker::Tuple;\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<A: Tuple, F: ?Sized> Fn<A> for &F\n+    where\n+        F: Fn<A>,\n+    {\n+        extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<A: Tuple, F: ?Sized> FnMut<A> for &F\n+    where\n+        F: Fn<A>,\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<A: Tuple, F: ?Sized> FnOnce<A> for &F\n+    where\n+        F: Fn<A>,\n+    {\n+        type Output = F::Output;\n+\n+        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+            (*self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<A: Tuple, F: ?Sized> FnMut<A> for &mut F\n+    where\n+        F: FnMut<A>,\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<A: Tuple, F: ?Sized> FnOnce<A> for &mut F\n+    where\n+        F: FnMut<A>,\n+    {\n+        type Output = F::Output;\n+        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+}"}]}