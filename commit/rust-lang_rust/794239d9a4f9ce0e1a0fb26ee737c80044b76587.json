{"sha": "794239d9a4f9ce0e1a0fb26ee737c80044b76587", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NDIzOWQ5YTRmOWNlMGUxYTBmYjI2ZWU3MzdjODAwNDRiNzY1ODc=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-03T14:04:40Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-03T14:04:40Z"}, "message": "Don't canonicalize `'static` in normalize", "tree": {"sha": "5b8a04c38002ab107dbcca566f1e2b216f74350a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b8a04c38002ab107dbcca566f1e2b216f74350a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/794239d9a4f9ce0e1a0fb26ee737c80044b76587", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/794239d9a4f9ce0e1a0fb26ee737c80044b76587", "html_url": "https://github.com/rust-lang/rust/commit/794239d9a4f9ce0e1a0fb26ee737c80044b76587", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/794239d9a4f9ce0e1a0fb26ee737c80044b76587/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2751b867a7fa0b14dbe5ca5f315e8f373bf8a5f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2751b867a7fa0b14dbe5ca5f315e8f373bf8a5f3", "html_url": "https://github.com/rust-lang/rust/commit/2751b867a7fa0b14dbe5ca5f315e8f373bf8a5f3"}], "stats": {"total": 208, "additions": 204, "deletions": 4}, "files": [{"sha": "ae4bfcaa90373920757386fd310b806a63815398", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/794239d9a4f9ce0e1a0fb26ee737c80044b76587/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794239d9a4f9ce0e1a0fb26ee737c80044b76587/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=794239d9a4f9ce0e1a0fb26ee737c80044b76587", "patch": "@@ -115,13 +115,17 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n     /// A hacky variant of `canonicalize_query` that does not\n     /// canonicalize `'static`. Unfortunately, the existing leak\n-    /// check treaks `'static` differently in some cases (see also\n+    /// check treats `'static` differently in some cases (see also\n     /// #33684), so if we are performing an operation that may need to\n     /// prove \"leak-check\" related things, we leave `'static`\n     /// alone.\n+    ///\n+    /// `'static` is also special cased when winnowing candidates when\n+    /// selecting implementation candidates, so we also have to leave `'static`\n+    /// alone for queries that do selection.\n     //\n-    // FIXME(#48536): once we have universes, we can remove this and just use\n-    // `canonicalize_query`.\n+    // FIXME(#48536): once the above issues are resolved, we can remove this\n+    // and just use `canonicalize_query`.\n     pub fn canonicalize_hr_query_hack<V>(\n         &self,\n         value: &V,"}, {"sha": "0b20ec884fc4d8f484bab7aa3345b277ecd36af2", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/794239d9a4f9ce0e1a0fb26ee737c80044b76587/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794239d9a4f9ce0e1a0fb26ee737c80044b76587/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=794239d9a4f9ce0e1a0fb26ee737c80044b76587", "patch": "@@ -145,7 +145,9 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                 let gcx = self.infcx.tcx.global_tcx();\n \n                 let mut orig_values = OriginalQueryValues::default();\n-                let c_data = self.infcx.canonicalize_query(\n+                // HACK(matthewjasper) `'static` is special-cased in selection,\n+                // so we cannot canonicalize it.\n+                let c_data = self.infcx.canonicalize_hr_query_hack(\n                     &self.param_env.and(*data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);"}, {"sha": "1164e9ef2d62feb77d2805cad013ac7db251de82", "filename": "src/test/ui/nll/issue-61311-normalize.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/794239d9a4f9ce0e1a0fb26ee737c80044b76587/src%2Ftest%2Fui%2Fnll%2Fissue-61311-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794239d9a4f9ce0e1a0fb26ee737c80044b76587/src%2Ftest%2Fui%2Fnll%2Fissue-61311-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-61311-normalize.rs?ref=794239d9a4f9ce0e1a0fb26ee737c80044b76587", "patch": "@@ -0,0 +1,34 @@\n+// Regression test for #61311\n+// We would ICE after failing to normalize `Self::Proj` in the `impl` below.\n+\n+// compile-pass\n+\n+pub struct Unit;\n+trait Obj {}\n+\n+trait Bound {}\n+impl Bound for Unit {}\n+\n+pub trait HasProj {\n+    type Proj;\n+}\n+\n+impl<T> HasProj for T {\n+    type Proj = Unit;\n+}\n+\n+trait HasProjFn {\n+    type Proj;\n+    fn the_fn(_: Self::Proj);\n+}\n+\n+impl HasProjFn for Unit\n+where\n+    Box<dyn Obj + 'static>: HasProj,\n+    <Box<dyn Obj + 'static> as HasProj>::Proj: Bound,\n+{\n+    type Proj = Unit;\n+    fn the_fn(_: Self::Proj) {}\n+}\n+\n+fn main() {}"}, {"sha": "a36ccd36113b586c9e577f973ee3e96b4ae9e9fe", "filename": "src/test/ui/nll/issue-61320-normalize.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/794239d9a4f9ce0e1a0fb26ee737c80044b76587/src%2Ftest%2Fui%2Fnll%2Fissue-61320-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794239d9a4f9ce0e1a0fb26ee737c80044b76587/src%2Ftest%2Fui%2Fnll%2Fissue-61320-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-61320-normalize.rs?ref=794239d9a4f9ce0e1a0fb26ee737c80044b76587", "patch": "@@ -0,0 +1,160 @@\n+// Regression test for #61320\n+// This is the same issue as #61311, just a larger test case.\n+\n+// compile-pass\n+\n+pub struct AndThen<A, B, F>\n+where\n+    A: Future,\n+    B: IntoFuture,\n+{\n+    state: (A, B::Future, F),\n+}\n+\n+pub struct FutureResult<T, E> {\n+    inner: Option<Result<T, E>>,\n+}\n+\n+impl<T, E> Future for FutureResult<T, E> {\n+    type Item = T;\n+    type Error = E;\n+\n+    fn poll(&mut self) -> Poll<T, E> {\n+        unimplemented!()\n+    }\n+}\n+\n+pub type Poll<T, E> = Result<T, E>;\n+\n+impl<A, B, F> Future for AndThen<A, B, F>\n+where\n+    A: Future,\n+    B: IntoFuture<Error = A::Error>,\n+    F: FnOnce(A::Item) -> B,\n+{\n+    type Item = B::Item;\n+    type Error = B::Error;\n+\n+    fn poll(&mut self) -> Poll<B::Item, B::Error> {\n+        unimplemented!()\n+    }\n+}\n+\n+pub trait Future {\n+    type Item;\n+\n+    type Error;\n+\n+    fn poll(&mut self) -> Poll<Self::Item, Self::Error>;\n+\n+    fn and_then<F, B>(self, f: F) -> AndThen<Self, B, F>\n+    where\n+        F: FnOnce(Self::Item) -> B,\n+        B: IntoFuture<Error = Self::Error>,\n+        Self: Sized,\n+    {\n+        unimplemented!()\n+    }\n+}\n+\n+pub trait IntoFuture {\n+    /// The future that this type can be converted into.\n+    type Future: Future<Item = Self::Item, Error = Self::Error>;\n+\n+    /// The item that the future may resolve with.\n+    type Item;\n+    /// The error that the future may resolve with.\n+    type Error;\n+\n+    /// Consumes this object and produces a future.\n+    fn into_future(self) -> Self::Future;\n+}\n+\n+impl<F: Future> IntoFuture for F {\n+    type Future = F;\n+    type Item = F::Item;\n+    type Error = F::Error;\n+\n+    fn into_future(self) -> F {\n+        self\n+    }\n+}\n+\n+impl<F: ?Sized + Future> Future for ::std::boxed::Box<F> {\n+    type Item = F::Item;\n+    type Error = F::Error;\n+\n+    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {\n+        (**self).poll()\n+    }\n+}\n+\n+impl<T, E> IntoFuture for Result<T, E> {\n+    type Future = FutureResult<T, E>;\n+    type Item = T;\n+    type Error = E;\n+\n+    fn into_future(self) -> FutureResult<T, E> {\n+        unimplemented!()\n+    }\n+}\n+\n+struct Request<T>(T);\n+\n+trait RequestContext {}\n+impl<T> RequestContext for T {}\n+struct NoContext;\n+impl AsRef<NoContext> for NoContext {\n+    fn as_ref(&self) -> &Self {\n+        &NoContext\n+    }\n+}\n+\n+type BoxedError = Box<dyn std::error::Error + Send + Sync>;\n+type DefaultFuture<T, E> = Box<dyn Future<Item = T, Error = E> + Send>;\n+\n+trait Guard: Sized {\n+    type Result: IntoFuture<Item = Self, Error = BoxedError>;\n+    fn from_request(request: &Request<()>) -> Self::Result;\n+}\n+\n+trait FromRequest: Sized {\n+    type Context;\n+    type Future: Future<Item = Self, Error = BoxedError> + Send;\n+    fn from_request(request: Request<()>) -> Self::Future;\n+}\n+\n+struct MyGuard;\n+impl Guard for MyGuard {\n+    type Result = Result<Self, BoxedError>;\n+    fn from_request(_request: &Request<()>) -> Self::Result {\n+        Ok(MyGuard)\n+    }\n+}\n+\n+struct Generic<I> {\n+    _inner: I,\n+}\n+\n+impl<I> FromRequest for Generic<I>\n+where\n+    MyGuard: Guard,\n+    <MyGuard as Guard>::Result: IntoFuture<Item = MyGuard, Error = BoxedError>,\n+    <<MyGuard as Guard>::Result as IntoFuture>::Future: Send,\n+    I: FromRequest<Context = NoContext>,\n+{\n+    type Future = DefaultFuture<Self, BoxedError>;\n+    type Context = NoContext;\n+    fn from_request(headers: Request<()>) -> DefaultFuture<Self, BoxedError> {\n+        let _future = <MyGuard as Guard>::from_request(&headers)\n+            .into_future()\n+            .and_then(move |_| {\n+                <I as FromRequest>::from_request(headers)\n+                    .into_future()\n+                    .and_then(move |fld_inner| Ok(Generic { _inner: fld_inner }).into_future())\n+            });\n+        panic!();\n+    }\n+}\n+\n+fn main() {}"}]}