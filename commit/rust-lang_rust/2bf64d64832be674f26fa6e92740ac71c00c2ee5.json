{"sha": "2bf64d64832be674f26fa6e92740ac71c00c2ee5", "node_id": "C_kwDOAAsO6NoAKDJiZjY0ZDY0ODMyYmU2NzRmMjZmYTZlOTI3NDBhYzcxYzAwYzJlZTU", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-03-30T02:00:54Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-04-05T06:01:02Z"}, "message": "macros: update comments\n\nVarious small changes to comments, like wrapping code in backticks,\nchanging comments to doc comments and adding newlines.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "0e97088db954d72e9ee05ce92d858acf4dd42587", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e97088db954d72e9ee05ce92d858acf4dd42587"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bf64d64832be674f26fa6e92740ac71c00c2ee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bf64d64832be674f26fa6e92740ac71c00c2ee5", "html_url": "https://github.com/rust-lang/rust/commit/2bf64d64832be674f26fa6e92740ac71c00c2ee5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bf64d64832be674f26fa6e92740ac71c00c2ee5/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5119c5b9f1f71090d078e945ea6b5d39d08cffa", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5119c5b9f1f71090d078e945ea6b5d39d08cffa", "html_url": "https://github.com/rust-lang/rust/commit/d5119c5b9f1f71090d078e945ea6b5d39d08cffa"}], "stats": {"total": 61, "additions": 34, "deletions": 27}, "files": [{"sha": "b32eee6decc169fe2fd3743436379395f3d3c9a0", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2bf64d64832be674f26fa6e92740ac71c00c2ee5/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf64d64832be674f26fa6e92740ac71c00c2ee5/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=2bf64d64832be674f26fa6e92740ac71c00c2ee5", "patch": "@@ -5,8 +5,9 @@ use syn::spanned::Spanned;\n \n use std::collections::{BTreeSet, HashMap};\n \n-/// Implements #[derive(SessionDiagnostic)], which allows for errors to be specified as a struct, independent\n-/// from the actual diagnostics emitting code.\n+/// Implements `#[derive(SessionDiagnostic)]`, which allows for errors to be specified as a struct,\n+/// independent from the actual diagnostics emitting code.\n+///\n /// ```ignore (pseudo-rust)\n /// # extern crate rustc_errors;\n /// # use rustc_errors::Applicability;\n@@ -28,6 +29,7 @@ use std::collections::{BTreeSet, HashMap};\n ///     pub opt_sugg: Option<(Span, Applicability)>\n /// }\n /// ```\n+///\n /// Then, later, to emit the error:\n ///\n /// ```ignore (pseudo-rust)\n@@ -47,10 +49,10 @@ pub fn session_diagnostic_derive(s: synstructure::Structure<'_>) -> proc_macro2:\n     SessionDiagnosticDerive::new(diag, sess, s).into_tokens()\n }\n \n-// Checks whether the type name of `ty` matches `name`.\n-//\n-// Given some struct at a::b::c::Foo, this will return true for c::Foo, b::c::Foo, or\n-// a::b::c::Foo. This reasonably allows qualified names to be used in the macro.\n+/// Checks whether the type name of `ty` matches `name`.\n+///\n+/// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n+/// `a::b::c::Foo`. This reasonably allows qualified names to be used in the macro.\n fn type_matches_path(ty: &syn::Type, name: &[&str]) -> bool {\n     if let syn::Type::Path(ty) = ty {\n         ty.path\n@@ -65,7 +67,7 @@ fn type_matches_path(ty: &syn::Type, name: &[&str]) -> bool {\n     }\n }\n \n-/// The central struct for constructing the as_error method from an annotated struct.\n+/// The central struct for constructing the `as_error` method from an annotated struct.\n struct SessionDiagnosticDerive<'a> {\n     structure: synstructure::Structure<'a>,\n     builder: SessionDiagnosticDeriveBuilder<'a>,\n@@ -77,7 +79,7 @@ impl std::convert::From<syn::Error> for SessionDiagnosticDeriveError {\n     }\n }\n \n-/// Equivalent to rustc:errors::diagnostic::DiagnosticId, except stores the quoted expression to\n+/// Equivalent to `rustc:errors::diagnostic::DiagnosticId`, except stores the quoted expression to\n /// initialise the code with.\n enum DiagnosticId {\n     Error(proc_macro2::TokenStream),\n@@ -109,18 +111,19 @@ fn span_err(span: impl proc_macro::MultiSpan, msg: &str) -> proc_macro::Diagnost\n     Diagnostic::spanned(span, proc_macro::Level::Error, msg)\n }\n \n-/// For methods that return a Result<_, SessionDiagnosticDeriveError>: emit a diagnostic on\n-/// span $span with msg $msg (and, optionally, perform additional decoration using the FnOnce\n-/// passed in `diag`). Then, return Err(ErrorHandled).\n+/// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n+///\n+/// Emit a diagnostic on span `$span` with msg `$msg` (optionally performing additional decoration\n+/// using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n macro_rules! throw_span_err {\n     ($span:expr, $msg:expr) => {{ throw_span_err!($span, $msg, |diag| diag) }};\n     ($span:expr, $msg:expr, $f:expr) => {{\n         return Err(_throw_span_err($span, $msg, $f));\n     }};\n }\n \n-/// When possible, prefer using throw_span_err! over using this function directly. This only exists\n-/// as a function to constrain `f` to an impl FnOnce.\n+/// When possible, prefer using `throw_span_err!` over using this function directly. This only\n+/// exists as a function to constrain `f` to an `impl FnOnce`.\n fn _throw_span_err(\n     span: impl proc_macro::MultiSpan,\n     msg: &str,\n@@ -240,8 +243,8 @@ impl<'a> SessionDiagnosticDerive<'a> {\n     }\n }\n \n-/// Field information passed to the builder. Deliberately omits attrs to discourage the generate_*\n-/// methods from walking the attributes themselves.\n+/// Field information passed to the builder. Deliberately omits attrs to discourage the\n+/// `generate_*` methods from walking the attributes themselves.\n struct FieldInfo<'a> {\n     vis: &'a syn::Visibility,\n     binding: &'a synstructure::BindingInfo<'a>,\n@@ -250,22 +253,22 @@ struct FieldInfo<'a> {\n }\n \n /// Tracks persistent information required for building up the individual calls to diagnostic\n-/// methods for the final generated method. This is a separate struct to SessionDerive only to be\n-/// able to destructure and split self.builder and the self.structure up to avoid a double mut\n-/// borrow later on.\n+/// methods for the final generated method. This is a separate struct to `SessionDiagnosticDerive`\n+/// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n+/// double mut borrow later on.\n struct SessionDiagnosticDeriveBuilder<'a> {\n-    /// Name of the session parameter that's passed in to the as_error method.\n+    /// Name of the session parameter that's passed in to the `as_error` method.\n     sess: syn::Ident,\n \n     /// Store a map of field name to its corresponding field. This is built on construction of the\n     /// derive builder.\n     fields: HashMap<String, &'a syn::Field>,\n \n-    /// The identifier to use for the generated DiagnosticBuilder instance.\n+    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n     diag: syn::Ident,\n \n-    /// Whether this is a lint or an error. This dictates how the diag will be initialised. Span\n-    /// stores at what Span the kind was first set at (for error reporting purposes, if the kind\n+    /// Whether this is a lint or an error. This dictates how the diag will be initialised. `Span`\n+    /// stores at what `Span` the kind was first set at (for error reporting purposes, if the kind\n     /// was multiply specified).\n     kind: Option<(DiagnosticId, proc_macro2::Span)>,\n }\n@@ -560,20 +563,24 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n     }\n \n     /// In the strings in the attributes supplied to this macro, we want callers to be able to\n-    /// reference fields in the format string. Take this, for example:\n+    /// reference fields in the format string. For example:\n+    ///\n     /// ```ignore (not-usage-example)\n     /// struct Point {\n     ///     #[error = \"Expected a point greater than ({x}, {y})\"]\n     ///     x: i32,\n     ///     y: i32,\n     /// }\n     /// ```\n-    /// We want to automatically pick up that {x} refers `self.x` and {y} refers to `self.y`, then\n-    /// generate this call to format!:\n+    ///\n+    /// We want to automatically pick up that `{x}` refers `self.x` and `{y}` refers to `self.y`,\n+    /// then generate this call to `format!`:\n+    ///\n     /// ```ignore (not-usage-example)\n     /// format!(\"Expected a point greater than ({x}, {y})\", x = self.x, y = self.y)\n     /// ```\n-    /// This function builds the entire call to format!.\n+    ///\n+    /// This function builds the entire call to `format!`.\n     fn build_format(&self, input: &str, span: proc_macro2::Span) -> proc_macro2::TokenStream {\n         // This set is used later to generate the final format string. To keep builds reproducible,\n         // the iteration order needs to be deterministic, hence why we use a BTreeSet here instead\n@@ -646,7 +653,7 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n     }\n }\n \n-/// If `ty` is an Option, returns Some(inner type). Else, returns None.\n+/// If `ty` is an Option, returns `Some(inner type)`, otherwise returns `None`.\n fn option_inner_ty(ty: &syn::Type) -> Option<&syn::Type> {\n     if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n         if let syn::Type::Path(ty_path) = ty {"}]}