{"sha": "191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MWZmMmQ4ZmQ1N2E4MjM4ZDg1MzAyYThmMDZlMmJkMTFiMmY2ZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-04T03:07:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-04T03:07:59Z"}, "message": "Auto merge of #30651 - nagisa:mir-fix-equality-checks, r=eddyb\n\nThis is not a fix to checks themselves per se (though we still use `Eq` MIR test instead of calling `PartialEq::eq`), but rather how we handle items we encounter in pattern position.\n\nPreviously we would just call `PartialEq` with the constant and the matchee, but now we essentially inline the constant instead. E.g. these two snippets are functionally equivalent at MIR level:\n\n```\nmatch val { Some(42) => true, _ => false }\n```\nand\n```\nconst SECRET: Option<u8> = Some(42);\nmatch val { SECRET => true, _ => false }\n```\n\nThis approach also allows for more optimizations of matches. I.e. It can now exploit `SwitchInt` to switch on number inside a `Some` regardless of whether the value being an item or not.\n\nThis is based on @tsion\u2019s already approved PR so I could reuse the file for more tests.\n\nr? @eddyb\ncc @nikomatsakis @tsion", "tree": {"sha": "aee842f40ee54d842461d48f1c70c3f6aaeedf34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aee842f40ee54d842461d48f1c70c3f6aaeedf34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2", "html_url": "https://github.com/rust-lang/rust/commit/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99e59dec5a8781817b4a1858535b1ffe11b8f735", "url": "https://api.github.com/repos/rust-lang/rust/commits/99e59dec5a8781817b4a1858535b1ffe11b8f735", "html_url": "https://github.com/rust-lang/rust/commit/99e59dec5a8781817b4a1858535b1ffe11b8f735"}, {"sha": "add7410af6741ab5f7c8001f25c8f794fa7092a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/add7410af6741ab5f7c8001f25c8f794fa7092a8", "html_url": "https://github.com/rust-lang/rust/commit/add7410af6741ab5f7c8001f25c8f794fa7092a8"}], "stats": {"total": 260, "additions": 101, "deletions": 159}, "files": [{"sha": "b456aabbf524bd566e82f247ee3b34d7f85667d5", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2", "patch": "@@ -259,7 +259,7 @@ enum TestKind<'tcx> {\n \n     // test for equality\n     Eq {\n-        value: Literal<'tcx>,\n+        value: ConstVal,\n         ty: Ty<'tcx>,\n     },\n "}, {"sha": "ec67429379f952e8e3a402728d5203782060184d", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 11, "deletions": 44, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2", "patch": "@@ -37,7 +37,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 }\n             }\n \n-            PatternKind::Constant { value: Literal::Value { .. } }\n+            PatternKind::Constant { .. }\n             if is_switch_ty(match_pair.pattern.ty) => {\n                 // for integers, we use a SwitchInt match, which allows\n                 // us to handle more cases\n@@ -55,12 +55,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             }\n \n             PatternKind::Constant { ref value } => {\n-                // for other types, we use an equality comparison\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Eq {\n                         value: value.clone(),\n-                        ty: match_pair.pattern.ty.clone(),\n+                        ty: match_pair.pattern.ty.clone()\n                     }\n                 }\n             }\n@@ -113,7 +112,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         };\n \n         match *match_pair.pattern.kind {\n-            PatternKind::Constant { value: Literal::Value { ref value } } => {\n+            PatternKind::Constant { ref value } => {\n                 // if the lvalues match, the type should match\n                 assert_eq!(match_pair.pattern.ty, switch_ty);\n \n@@ -126,7 +125,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             }\n \n             PatternKind::Range { .. } |\n-            PatternKind::Constant { .. } |\n             PatternKind::Variant { .. } |\n             PatternKind::Slice { .. } |\n             PatternKind::Array { .. } |\n@@ -177,11 +175,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             }\n \n             TestKind::Eq { ref value, ty } => {\n-                // call PartialEq::eq(discrim, constant)\n-                let constant = self.literal_operand(test.span, ty.clone(), value.clone());\n-                let item_ref = self.hir.partial_eq(ty);\n-                self.call_comparison_fn(block, test.span, item_ref,\n-                                        Operand::Consume(lvalue.clone()), constant)\n+                let expect = self.literal_operand(test.span, ty.clone(), Literal::Value {\n+                    value: value.clone()\n+                });\n+                let val = Operand::Consume(lvalue.clone());\n+                let fail = self.cfg.start_new_block();\n+                let block = self.compare(block, fail, test.span, BinOp::Eq, expect, val.clone());\n+                vec![block, fail]\n             }\n \n             TestKind::Range { ref lo, ref hi, ty } => {\n@@ -251,39 +251,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         target_block\n     }\n \n-    fn call_comparison_fn(&mut self,\n-                          block: BasicBlock,\n-                          span: Span,\n-                          item_ref: ItemRef<'tcx>,\n-                          lvalue1: Operand<'tcx>,\n-                          lvalue2: Operand<'tcx>)\n-                          -> Vec<BasicBlock> {\n-        let target_blocks = vec![self.cfg.start_new_block(), self.cfg.start_new_block()];\n-\n-        let bool_ty = self.hir.bool_ty();\n-        let eq_result = self.temp(bool_ty);\n-        let func = self.item_ref_operand(span, item_ref);\n-        let call_blocks = (self.cfg.start_new_block(), self.diverge_cleanup());\n-        self.cfg.terminate(block,\n-                           Terminator::Call {\n-                               data: CallData {\n-                                   destination: eq_result.clone(),\n-                                   func: func,\n-                                   args: vec![lvalue1, lvalue2],\n-                               },\n-                               targets: call_blocks,\n-                           });\n-\n-        // check the result\n-        self.cfg.terminate(call_blocks.0,\n-                           Terminator::If {\n-                               cond: Operand::Consume(eq_result),\n-                               targets: (target_blocks[0], target_blocks[1]),\n-                           });\n-\n-        target_blocks\n-    }\n-\n     /// Given that we are performing `test` against `test_lvalue`,\n     /// this job sorts out what the status of `candidate` will be\n     /// after the test. The `resulting_candidates` vector stores, for\n@@ -368,7 +335,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             // things out here, in some cases.\n             TestKind::SwitchInt { switch_ty: _, options: _, ref indices } => {\n                 match *match_pair.pattern.kind {\n-                    PatternKind::Constant { value: Literal::Value { ref value } }\n+                    PatternKind::Constant { ref value }\n                     if is_switch_ty(match_pair.pattern.ty) => {\n                         let index = indices[value];\n                         let new_candidate = self.candidate_without_match_pair(match_pair_index,"}, {"sha": "f2bc5fec2ff5d0c70fe81f8e07f87551c41c40e0", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2", "patch": "@@ -19,12 +19,9 @@ use hair::*;\n use rustc::mir::repr::*;\n \n use rustc::middle::const_eval::{self, ConstVal};\n-use rustc::middle::def_id::DefId;\n use rustc::middle::infer::InferCtxt;\n-use rustc::middle::subst::{Subst, Substs};\n use rustc::middle::ty::{self, Ty};\n use syntax::codemap::Span;\n-use syntax::parse::token;\n use rustc_front::hir;\n \n #[derive(Copy, Clone)]\n@@ -83,11 +80,6 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n             .map(|v| Literal::Value { value: v })\n     }\n \n-    pub fn partial_eq(&mut self, ty: Ty<'tcx>) -> ItemRef<'tcx> {\n-        let eq_def_id = self.tcx.lang_items.eq_trait().unwrap();\n-        self.cmp_method_ref(eq_def_id, \"eq\", ty)\n-    }\n-\n     pub fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize {\n         adt_def.variants.len()\n     }\n@@ -118,35 +110,6 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.tcx\n     }\n-\n-    fn cmp_method_ref(&mut self,\n-                      trait_def_id: DefId,\n-                      method_name: &str,\n-                      arg_ty: Ty<'tcx>)\n-                      -> ItemRef<'tcx> {\n-        let method_name = token::intern(method_name);\n-        let substs = Substs::new_trait(vec![arg_ty], vec![], arg_ty);\n-        for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n-            match *trait_item {\n-                ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n-                    if method.name == method_name {\n-                        let method_ty = self.tcx.lookup_item_type(method.def_id);\n-                        let method_ty = method_ty.ty.subst(self.tcx, &substs);\n-                        return ItemRef {\n-                            ty: method_ty,\n-                            kind: ItemKind::Method,\n-                            def_id: method.def_id,\n-                            substs: self.tcx.mk_substs(substs),\n-                        };\n-                    }\n-                }\n-                ty::ImplOrTraitItem::ConstTraitItem(..) |\n-                ty::ImplOrTraitItem::TypeTraitItem(..) => {}\n-            }\n-        }\n-\n-        self.tcx.sess.bug(&format!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id));\n-    }\n }\n \n mod block;"}, {"sha": "1f425aafa256adc40f4cc4bd740c242235c053c1", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 32, "deletions": 46, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2", "patch": "@@ -14,11 +14,11 @@ use rustc_data_structures::fnv::FnvHashMap;\n use rustc::middle::const_eval;\n use rustc::middle::def;\n use rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n-use rustc::middle::subst::Substs;\n use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc_front::hir;\n use syntax::ast;\n+use syntax::codemap::Span;\n use syntax::ptr::P;\n \n /// When there are multiple patterns in a single arm, each one has its\n@@ -40,15 +40,15 @@ struct PatCx<'patcx, 'cx: 'patcx, 'tcx: 'cx> {\n }\n \n impl<'cx, 'tcx> Cx<'cx, 'tcx> {\n-    pub fn irrefutable_pat(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n-        PatCx::new(self, None).to_pat(pat)\n+    pub fn irrefutable_pat(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n+        PatCx::new(self, None).to_pattern(pat)\n     }\n \n     pub fn refutable_pat(&mut self,\n                          binding_map: Option<&FnvHashMap<ast::Name, ast::NodeId>>,\n-                         pat: &'tcx hir::Pat)\n+                         pat: &hir::Pat)\n                          -> Pattern<'tcx> {\n-        PatCx::new(self, binding_map).to_pat(pat)\n+        PatCx::new(self, binding_map).to_pattern(pat)\n     }\n }\n \n@@ -62,13 +62,12 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n         }\n     }\n \n-    fn to_pat(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+    fn to_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n         let kind = match pat.node {\n             hir::PatWild => PatternKind::Wild,\n \n             hir::PatLit(ref value) => {\n                 let value = const_eval::eval_const_expr(self.cx.tcx, value);\n-                let value = Literal::Value { value: value };\n                 PatternKind::Constant { value: value }\n             }\n \n@@ -88,22 +87,9 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                     def::DefConst(def_id) | def::DefAssociatedConst(def_id) =>\n                         match const_eval::lookup_const_by_id(self.cx.tcx, def_id, Some(pat.id)) {\n                             Some(const_expr) => {\n-                                let opt_value =\n-                                    const_eval::eval_const_expr_partial(\n-                                        self.cx.tcx, const_expr,\n-                                        const_eval::EvalHint::ExprTypeChecked,\n-                                        None);\n-                                let literal = if let Ok(value) = opt_value {\n-                                    Literal::Value { value: value }\n-                                } else {\n-                                    let substs = self.cx.tcx.mk_substs(Substs::empty());\n-                                    Literal::Item {\n-                                        def_id: def_id,\n-                                        kind: ItemKind::Constant,\n-                                        substs: substs\n-                                    }\n-                                };\n-                                PatternKind::Constant { value: literal }\n+                                let pat = const_eval::const_expr_to_pat(self.cx.tcx, const_expr,\n+                                                                        pat.span);\n+                                return self.to_pattern(&*pat);\n                             }\n                             None => {\n                                 self.cx.tcx.sess.span_bug(\n@@ -120,7 +106,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n \n             hir::PatRegion(ref subpattern, _) |\n             hir::PatBox(ref subpattern) => {\n-                PatternKind::Deref { subpattern: self.to_pat(subpattern) }\n+                PatternKind::Deref { subpattern: self.to_pattern(subpattern) }\n             }\n \n             hir::PatVec(ref prefix, ref slice, ref suffix) => {\n@@ -131,14 +117,14 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                             subpattern: Pattern {\n                                 ty: mt.ty,\n                                 span: pat.span,\n-                                kind: Box::new(self.slice_or_array_pattern(pat, mt.ty, prefix,\n+                                kind: Box::new(self.slice_or_array_pattern(pat.span, mt.ty, prefix,\n                                                                            slice, suffix)),\n                             },\n                         },\n \n                     ty::TySlice(..) |\n                     ty::TyArray(..) =>\n-                        self.slice_or_array_pattern(pat, ty, prefix, slice, suffix),\n+                        self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n \n                     ref sty =>\n                         self.cx.tcx.sess.span_bug(\n@@ -153,7 +139,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                                .enumerate()\n                                .map(|(i, subpattern)| FieldPattern {\n                                    field: Field::new(i),\n-                                   pattern: self.to_pat(subpattern),\n+                                   pattern: self.to_pattern(subpattern),\n                                })\n                                .collect();\n \n@@ -188,7 +174,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                     name: ident.node.name,\n                     var: id,\n                     ty: var_ty,\n-                    subpattern: self.to_opt_pat(sub),\n+                    subpattern: self.to_opt_pattern(sub),\n                 }\n             }\n \n@@ -203,7 +189,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                                    .enumerate()\n                                    .map(|(i, field)| FieldPattern {\n                                        field: Field::new(i),\n-                                       pattern: self.to_pat(field),\n+                                       pattern: self.to_pattern(field),\n                                    })\n                                    .collect();\n                 self.variant_or_leaf(pat, subpatterns)\n@@ -234,7 +220,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                               });\n                               FieldPattern {\n                                   field: Field::new(index),\n-                                  pattern: self.to_pat(&field.node.pat),\n+                                  pattern: self.to_pattern(&field.node.pat),\n                               }\n                           })\n                           .collect();\n@@ -256,49 +242,49 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n         }\n     }\n \n-    fn to_pats(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n-        pats.iter().map(|p| self.to_pat(p)).collect()\n+    fn to_patterns(&mut self, pats: &[P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n+        pats.iter().map(|p| self.to_pattern(p)).collect()\n     }\n \n-    fn to_opt_pat(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pattern<'tcx>> {\n-        pat.as_ref().map(|p| self.to_pat(p))\n+    fn to_opt_pattern(&mut self, pat: &Option<P<hir::Pat>>) -> Option<Pattern<'tcx>> {\n+        pat.as_ref().map(|p| self.to_pattern(p))\n     }\n \n     fn slice_or_array_pattern(&mut self,\n-                              pat: &'tcx hir::Pat,\n+                              span: Span,\n                               ty: Ty<'tcx>,\n-                              prefix: &'tcx [P<hir::Pat>],\n-                              slice: &'tcx Option<P<hir::Pat>>,\n-                              suffix: &'tcx [P<hir::Pat>])\n+                              prefix: &[P<hir::Pat>],\n+                              slice: &Option<P<hir::Pat>>,\n+                              suffix: &[P<hir::Pat>])\n                               -> PatternKind<'tcx> {\n         match ty.sty {\n             ty::TySlice(..) => {\n                 // matching a slice or fixed-length array\n                 PatternKind::Slice {\n-                    prefix: self.to_pats(prefix),\n-                    slice: self.to_opt_pat(slice),\n-                    suffix: self.to_pats(suffix),\n+                    prefix: self.to_patterns(prefix),\n+                    slice: self.to_opt_pattern(slice),\n+                    suffix: self.to_patterns(suffix),\n                 }\n             }\n \n             ty::TyArray(_, len) => {\n                 // fixed-length array\n                 assert!(len >= prefix.len() + suffix.len());\n                 PatternKind::Array {\n-                    prefix: self.to_pats(prefix),\n-                    slice: self.to_opt_pat(slice),\n-                    suffix: self.to_pats(suffix),\n+                    prefix: self.to_patterns(prefix),\n+                    slice: self.to_opt_pattern(slice),\n+                    suffix: self.to_patterns(suffix),\n                 }\n             }\n \n             _ => {\n-                self.cx.tcx.sess.span_bug(pat.span, \"unexpanded macro or bad constant etc\");\n+                self.cx.tcx.sess.span_bug(span, \"unexpanded macro or bad constant etc\");\n             }\n         }\n     }\n \n     fn variant_or_leaf(&mut self,\n-                       pat: &'tcx hir::Pat,\n+                       pat: &hir::Pat,\n                        subpatterns: Vec<FieldPattern<'tcx>>)\n                        -> PatternKind<'tcx> {\n         let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();"}, {"sha": "6363ddf1e1477b987cec22959da84df1bd8e5655", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2", "patch": "@@ -15,6 +15,7 @@\n //! structures.\n \n use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp, ItemKind};\n+use rustc::middle::const_eval::ConstVal;\n use rustc::middle::def_id::DefId;\n use rustc::middle::region::CodeExtent;\n use rustc::middle::subst::Substs;\n@@ -305,7 +306,7 @@ pub enum PatternKind<'tcx> {\n     }, // box P, &P, &mut P, etc\n \n     Constant {\n-        value: Literal<'tcx>,\n+        value: ConstVal,\n     },\n \n     Range {"}, {"sha": "19266191d445dd1f56d07e33078ceaecfc185bd1", "filename": "src/test/run-pass/mir_build_match_comparisons.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Ftest%2Frun-pass%2Fmir_build_match_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2/src%2Ftest%2Frun-pass%2Fmir_build_match_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_build_match_comparisons.rs?ref=191ff2d8fd57a8238d85302a8f06e2bd11b2f6d2", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_mir]\n+pub fn test1(x: i8) -> i32 {\n+  match x {\n+    1...10 => 0,\n+    _ => 1,\n+  }\n+}\n+\n+const U: Option<i8> = Some(10);\n+const S: &'static str = \"hello\";\n+\n+#[rustc_mir]\n+pub fn test2(x: i8) -> i32 {\n+  match Some(x) {\n+    U => 0,\n+    _ => 1,\n+  }\n+}\n+\n+#[rustc_mir]\n+pub fn test3(x: &'static str) -> i32 {\n+  match x {\n+    S => 0,\n+    _ => 1,\n+  }\n+}\n+\n+fn main() {\n+  assert_eq!(test1(0), 1);\n+  assert_eq!(test1(1), 0);\n+  assert_eq!(test1(2), 0);\n+  assert_eq!(test1(5), 0);\n+  assert_eq!(test1(9), 0);\n+  assert_eq!(test1(10), 0);\n+  assert_eq!(test1(11), 1);\n+  assert_eq!(test1(20), 1);\n+  assert_eq!(test2(10), 0);\n+  assert_eq!(test2(0), 1);\n+  assert_eq!(test2(20), 1);\n+  assert_eq!(test3(\"hello\"), 0);\n+  assert_eq!(test3(\"\"), 1);\n+  assert_eq!(test3(\"world\"), 1);\n+}"}, {"sha": "14184bd356b459274c6588346e987c4379c14fc4", "filename": "src/test/run-pass/mir_trans_match_range.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/99e59dec5a8781817b4a1858535b1ffe11b8f735/src%2Ftest%2Frun-pass%2Fmir_trans_match_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e59dec5a8781817b4a1858535b1ffe11b8f735/src%2Ftest%2Frun-pass%2Fmir_trans_match_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_match_range.rs?ref=99e59dec5a8781817b4a1858535b1ffe11b8f735", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rustc_attrs)]\n-\n-#[rustc_mir]\n-pub fn foo(x: i8) -> i32 {\n-  match x {\n-    1...10 => 0,\n-    _ => 1,\n-  }\n-}\n-\n-fn main() {\n-  assert_eq!(foo(0), 1);\n-  assert_eq!(foo(1), 0);\n-  assert_eq!(foo(2), 0);\n-  assert_eq!(foo(5), 0);\n-  assert_eq!(foo(9), 0);\n-  assert_eq!(foo(10), 0);\n-  assert_eq!(foo(11), 1);\n-  assert_eq!(foo(20), 1);\n-}"}]}