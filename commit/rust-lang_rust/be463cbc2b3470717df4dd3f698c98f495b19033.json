{"sha": "be463cbc2b3470717df4dd3f698c98f495b19033", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNDYzY2JjMmIzNDcwNzE3ZGY0ZGQzZjY5OGM5OGY0OTViMTkwMzM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-03T07:20:19Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-20T21:41:28Z"}, "message": "extract: error_block_no_opening_brace", "tree": {"sha": "8aca5c4accb533a734ccf2ed59817ca7970fff0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aca5c4accb533a734ccf2ed59817ca7970fff0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be463cbc2b3470717df4dd3f698c98f495b19033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be463cbc2b3470717df4dd3f698c98f495b19033", "html_url": "https://github.com/rust-lang/rust/commit/be463cbc2b3470717df4dd3f698c98f495b19033", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be463cbc2b3470717df4dd3f698c98f495b19033/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdca5cfbfd0679645f91031b2619aac42cb5f68a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdca5cfbfd0679645f91031b2619aac42cb5f68a", "html_url": "https://github.com/rust-lang/rust/commit/cdca5cfbfd0679645f91031b2619aac42cb5f68a"}], "stats": {"total": 124, "additions": 65, "deletions": 59}, "files": [{"sha": "d1ed6968fb93265f9cd6a33f9d625f30ca434593", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 65, "deletions": 59, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/be463cbc2b3470717df4dd3f698c98f495b19033/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be463cbc2b3470717df4dd3f698c98f495b19033/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=be463cbc2b3470717df4dd3f698c98f495b19033", "patch": "@@ -291,70 +291,76 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n \n         if !self.eat(&token::OpenDelim(token::Brace)) {\n-            let sp = self.token.span;\n-            let tok = self.this_token_descr();\n-            let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n-            let do_not_suggest_help =\n-                self.token.is_keyword(kw::In) || self.token == token::Colon;\n-\n-            if self.token.is_ident_named(sym::and) {\n-                e.span_suggestion_short(\n-                    self.token.span,\n-                    \"use `&&` instead of `and` for the boolean operator\",\n-                    \"&&\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            if self.token.is_ident_named(sym::or) {\n-                e.span_suggestion_short(\n-                    self.token.span,\n-                    \"use `||` instead of `or` for the boolean operator\",\n-                    \"||\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n+            return self.error_block_no_opening_brace();\n+        }\n \n-            // Check to see if the user has written something like\n-            //\n-            //    if (cond)\n-            //      bar;\n-            //\n-            // which is valid in other languages, but not Rust.\n-            match self.parse_stmt_without_recovery(false) {\n-                Ok(Some(stmt)) => {\n-                    if self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n-                        || do_not_suggest_help {\n-                        // If the next token is an open brace (e.g., `if a b {`), the place-\n-                        // inside-a-block suggestion would be more likely wrong than right.\n-                        e.span_label(sp, \"expected `{`\");\n-                        return Err(e);\n-                    }\n-                    let mut stmt_span = stmt.span;\n-                    // Expand the span to include the semicolon, if it exists.\n-                    if self.eat(&token::Semi) {\n-                        stmt_span = stmt_span.with_hi(self.prev_span.hi());\n-                    }\n-                    if let Ok(snippet) = self.span_to_snippet(stmt_span) {\n-                        e.span_suggestion(\n-                            stmt_span,\n-                            \"try placing this code inside a block\",\n-                            format!(\"{{ {} }}\", snippet),\n-                            // Speculative; has been misleading in the past (#46836).\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+        self.parse_block_tail(lo, BlockCheckMode::Default)\n+    }\n+\n+    fn error_block_no_opening_brace<T>(&mut self) -> PResult<'a, T> {\n+        let sp = self.token.span;\n+        let tok = self.this_token_descr();\n+        let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n+        let do_not_suggest_help =\n+            self.token.is_keyword(kw::In) || self.token == token::Colon;\n+\n+        if self.token.is_ident_named(sym::and) {\n+            e.span_suggestion_short(\n+                self.token.span,\n+                \"use `&&` instead of `and` for the boolean operator\",\n+                \"&&\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+        if self.token.is_ident_named(sym::or) {\n+            e.span_suggestion_short(\n+                self.token.span,\n+                \"use `||` instead of `or` for the boolean operator\",\n+                \"||\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+\n+        // Check to see if the user has written something like\n+        //\n+        //    if (cond)\n+        //      bar;\n+        //\n+        // which is valid in other languages, but not Rust.\n+        match self.parse_stmt_without_recovery(false) {\n+            Ok(Some(stmt)) => {\n+                if self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n+                    || do_not_suggest_help\n+                {\n+                    // If the next token is an open brace (e.g., `if a b {`), the place-\n+                    // inside-a-block suggestion would be more likely wrong than right.\n+                    e.span_label(sp, \"expected `{`\");\n+                    return Err(e);\n                 }\n-                Err(mut e) => {\n-                    self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n-                    e.cancel();\n+                let stmt_span = if self.eat(&token::Semi) {\n+                    // Expand the span to include the semicolon.\n+                    stmt.span.with_hi(self.prev_span.hi())\n+                } else {\n+                    stmt.span\n+                };\n+                if let Ok(snippet) = self.span_to_snippet(stmt_span) {\n+                    e.span_suggestion(\n+                        stmt_span,\n+                        \"try placing this code inside a block\",\n+                        format!(\"{{ {} }}\", snippet),\n+                        // Speculative; has been misleading in the past (#46836).\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n-                _ => ()\n             }\n-            e.span_label(sp, \"expected `{`\");\n-            return Err(e);\n+            Err(mut e) => {\n+                self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n+                e.cancel();\n+            }\n+            _ => {}\n         }\n-\n-        self.parse_block_tail(lo, BlockCheckMode::Default)\n+        e.span_label(sp, \"expected `{`\");\n+        return Err(e);\n     }\n \n     /// Parses a block. Inner attributes are allowed."}]}