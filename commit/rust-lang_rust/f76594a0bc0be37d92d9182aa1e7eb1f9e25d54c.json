{"sha": "f76594a0bc0be37d92d9182aa1e7eb1f9e25d54c", "node_id": "C_kwDOAAsO6NoAKGY3NjU5NGEwYmMwYmUzN2Q5MmQ5MTgyYWExZTdlYjFmOWUyNWQ1NGM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-27T12:40:39Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-09-13T17:18:23Z"}, "message": "Simplify MIR building entry.", "tree": {"sha": "9ca30dcc851e63f5a13d02e26ba84afe0c3fbc83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ca30dcc851e63f5a13d02e26ba84afe0c3fbc83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f76594a0bc0be37d92d9182aa1e7eb1f9e25d54c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f76594a0bc0be37d92d9182aa1e7eb1f9e25d54c", "html_url": "https://github.com/rust-lang/rust/commit/f76594a0bc0be37d92d9182aa1e7eb1f9e25d54c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f76594a0bc0be37d92d9182aa1e7eb1f9e25d54c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f370d9437795d8ad8382d106b3e55715ab0d251", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f370d9437795d8ad8382d106b3e55715ab0d251", "html_url": "https://github.com/rust-lang/rust/commit/1f370d9437795d8ad8382d106b3e55715ab0d251"}], "stats": {"total": 541, "additions": 260, "deletions": 281}, "files": [{"sha": "b70a4a5d0f8f85f793ef9328dca12dcf3699893b", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 250, "deletions": 281, "changes": 531, "blob_url": "https://github.com/rust-lang/rust/blob/f76594a0bc0be37d92d9182aa1e7eb1f9e25d54c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f76594a0bc0be37d92d9182aa1e7eb1f9e25d54c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=f76594a0bc0be37d92d9182aa1e7eb1f9e25d54c", "patch": "@@ -1,4 +1,3 @@\n-use crate::build;\n pub(crate) use crate::build::expr::as_constant::lit_to_mir_constant;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n@@ -48,9 +47,7 @@ pub(crate) fn mir_built<'tcx>(\n \n /// Construct the MIR for a given `DefId`.\n fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n-    let id = tcx.hir().local_def_id_to_hir_id(def.did);\n     let body_owner_kind = tcx.hir().body_owner_kind(def.did);\n-    let typeck_results = tcx.typeck_opt_const_arg(def);\n \n     // Ensure unsafeck and abstract const building is ran before we steal the THIR.\n     // We can't use `ensure()` for `thir_abstract_const` as it doesn't compute the query\n@@ -67,188 +64,37 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n         }\n     }\n \n-    // Figure out what primary body this item has.\n-    let body_id = tcx.hir().body_owned_by(def.did);\n-    let span_with_body = tcx.hir().span_with_body(id);\n-    let return_ty_span = if let Some(fn_decl) = tcx.hir().fn_decl_by_hir_id(id) {\n-        fn_decl.output.span()\n-    } else {\n-        match tcx.hir().get(id) {\n-            Node::Item(hir::Item {\n-                kind: hir::ItemKind::Static(ty, _, _) | hir::ItemKind::Const(ty, _),\n-                ..\n-            })\n-            | Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Const(ty, _), .. })\n-            | Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Const(ty, _), .. }) => {\n-                ty.span\n-            }\n-            Node::AnonConst(_) => tcx.def_span(def.did),\n-            _ => span_bug!(tcx.def_span(def.did), \"can't build MIR for {:?}\", def.did),\n-        }\n-    };\n-\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let body = if let Some(error_reported) = typeck_results.tainted_by_errors {\n-            build::construct_error(&infcx, def, id, body_id, body_owner_kind, error_reported)\n-        } else if body_owner_kind.is_fn_or_closure() {\n-            // fetch the fully liberated fn signature (that is, all bound\n-            // types/lifetimes replaced)\n-            let fn_sig = typeck_results.liberated_fn_sigs()[id];\n-            let fn_def_id = tcx.hir().local_def_id(id);\n-\n-            let safety = match fn_sig.unsafety {\n-                hir::Unsafety::Normal => Safety::Safe,\n-                hir::Unsafety::Unsafe => Safety::FnUnsafe,\n-            };\n-\n-            let body = tcx.hir().body(body_id);\n-            let (thir, expr) = tcx\n-                .thir_body(def)\n-                .unwrap_or_else(|_| (tcx.alloc_steal_thir(Thir::new()), ExprId::from_u32(0)));\n+    let body = match tcx.thir_body(def) {\n+        Err(error_reported) => construct_error(tcx, def.did, body_owner_kind, error_reported),\n+        Ok((thir, expr)) => {\n             // We ran all queries that depended on THIR at the beginning\n             // of `mir_build`, so now we can steal it\n             let thir = thir.steal();\n-            let ty = tcx.type_of(fn_def_id);\n-            let mut abi = fn_sig.abi;\n-            let implicit_argument = match ty.kind() {\n-                ty::Closure(..) => {\n-                    // HACK(eddyb) Avoid having RustCall on closures,\n-                    // as it adds unnecessary (and wrong) auto-tupling.\n-                    abi = Abi::Rust;\n-                    vec![ArgInfo(liberated_closure_env_ty(tcx, id, body_id), None, None, None)]\n-                }\n-                ty::Generator(..) => {\n-                    let gen_ty = tcx.typeck_body(body_id).node_type(id);\n-\n-                    // The resume argument may be missing, in that case we need to provide it here.\n-                    // It will always be `()` in this case.\n-                    if body.params.is_empty() {\n-                        vec![\n-                            ArgInfo(gen_ty, None, None, None),\n-                            ArgInfo(tcx.mk_unit(), None, None, None),\n-                        ]\n-                    } else {\n-                        vec![ArgInfo(gen_ty, None, None, None)]\n-                    }\n-                }\n-                _ => vec![],\n-            };\n \n-            let explicit_arguments = body.params.iter().enumerate().map(|(index, arg)| {\n-                let owner_id = tcx.hir().body_owner(body_id);\n-                let opt_ty_info;\n-                let self_arg;\n-                if let Some(ref fn_decl) = tcx.hir().fn_decl_by_hir_id(owner_id) {\n-                    opt_ty_info = fn_decl\n-                        .inputs\n-                        .get(index)\n-                        // Make sure that inferred closure args have no type span\n-                        .and_then(|ty| if arg.pat.span != ty.span { Some(ty.span) } else { None });\n-                    self_arg = if index == 0 && fn_decl.implicit_self.has_implicit_self() {\n-                        Some(fn_decl.implicit_self)\n-                    } else {\n-                        None\n-                    };\n-                } else {\n-                    opt_ty_info = None;\n-                    self_arg = None;\n-                }\n-\n-                // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n-                // (as it's created inside the body itself, not passed in from outside).\n-                let ty = if fn_sig.c_variadic && index == fn_sig.inputs().len() {\n-                    let va_list_did = tcx.require_lang_item(LangItem::VaList, Some(arg.span));\n-\n-                    tcx.bound_type_of(va_list_did).subst(tcx, &[tcx.lifetimes.re_erased.into()])\n-                } else {\n-                    fn_sig.inputs()[index]\n-                };\n-\n-                ArgInfo(ty, opt_ty_info, Some(&arg), self_arg)\n-            });\n-\n-            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n-\n-            let (yield_ty, return_ty) = if body.generator_kind.is_some() {\n-                let gen_ty = tcx.typeck_body(body_id).node_type(id);\n-                let gen_sig = match gen_ty.kind() {\n-                    ty::Generator(_, gen_substs, ..) => gen_substs.as_generator().sig(),\n-                    _ => span_bug!(tcx.hir().span(id), \"generator w/o generator type: {:?}\", ty),\n-                };\n-                (Some(gen_sig.yield_ty), gen_sig.return_ty)\n+            if body_owner_kind.is_fn_or_closure() {\n+                construct_fn(tcx, def, &thir, expr)\n             } else {\n-                (None, fn_sig.output())\n-            };\n-\n-            let mut mir = build::construct_fn(\n-                &thir,\n-                &infcx,\n-                def,\n-                id,\n-                arguments,\n-                safety,\n-                abi,\n-                return_ty,\n-                return_ty_span,\n-                body,\n-                expr,\n-                span_with_body,\n-            );\n-            if yield_ty.is_some() {\n-                mir.generator.as_mut().unwrap().yield_ty = yield_ty;\n+                construct_const(tcx, def, &thir, expr)\n             }\n-            mir\n-        } else {\n-            // Get the revealed type of this const. This is *not* the adjusted\n-            // type of its body, which may be a subtype of this type. For\n-            // example:\n-            //\n-            // fn foo(_: &()) {}\n-            // static X: fn(&'static ()) = foo;\n-            //\n-            // The adjusted type of the body of X is `for<'a> fn(&'a ())` which\n-            // is not the same as the type of X. We need the type of the return\n-            // place to be the type of the constant because NLL typeck will\n-            // equate them.\n-\n-            let return_ty = typeck_results.node_type(id);\n-\n-            let (thir, expr) = tcx\n-                .thir_body(def)\n-                .unwrap_or_else(|_| (tcx.alloc_steal_thir(Thir::new()), ExprId::from_u32(0)));\n-            // We ran all queries that depended on THIR at the beginning\n-            // of `mir_build`, so now we can steal it\n-            let thir = thir.steal();\n-\n-            build::construct_const(\n-                &thir,\n-                &infcx,\n-                expr,\n-                def,\n-                id,\n-                return_ty,\n-                return_ty_span,\n-                span_with_body,\n-            )\n-        };\n+        }\n+    };\n \n-        lints::check(tcx, &body);\n-\n-        // The borrow checker will replace all the regions here with its own\n-        // inference variables. There's no point having non-erased regions here.\n-        // The exception is `body.user_type_annotations`, which is used unmodified\n-        // by borrow checking.\n-        debug_assert!(\n-            !(body.local_decls.has_free_regions()\n-                || body.basic_blocks.has_free_regions()\n-                || body.var_debug_info.has_free_regions()\n-                || body.yield_ty().has_free_regions()),\n-            \"Unexpected free regions in MIR: {:?}\",\n-            body,\n-        );\n+    lints::check(tcx, &body);\n+\n+    // The borrow checker will replace all the regions here with its own\n+    // inference variables. There's no point having non-erased regions here.\n+    // The exception is `body.user_type_annotations`, which is used unmodified\n+    // by borrow checking.\n+    debug_assert!(\n+        !(body.local_decls.has_free_regions()\n+            || body.basic_blocks.has_free_regions()\n+            || body.var_debug_info.has_free_regions()\n+            || body.yield_ty().has_free_regions()),\n+        \"Unexpected free regions in MIR: {:?}\",\n+        body,\n+    );\n \n-        body\n-    })\n+    body\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -331,7 +177,7 @@ struct BlockContext(Vec<BlockFrame>);\n \n struct Builder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: InferCtxt<'a, 'tcx>,\n     typeck_results: &'tcx TypeckResults<'tcx>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -610,141 +456,264 @@ struct ArgInfo<'tcx>(\n     Option<ImplicitSelfKind>,\n );\n \n-fn construct_fn<'tcx, A>(\n-    thir: &Thir<'tcx>,\n-    infcx: &InferCtxt<'_, 'tcx>,\n+fn construct_fn<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     fn_def: ty::WithOptConstParam<LocalDefId>,\n-    fn_id: hir::HirId,\n-    arguments: A,\n-    safety: Safety,\n-    abi: Abi,\n-    return_ty: Ty<'tcx>,\n-    return_ty_span: Span,\n-    body: &'tcx hir::Body<'tcx>,\n+    thir: &Thir<'tcx>,\n     expr: ExprId,\n-    span_with_body: Span,\n-) -> Body<'tcx>\n-where\n-    A: Iterator<Item = ArgInfo<'tcx>>,\n-{\n+) -> Body<'tcx> {\n+    let span = tcx.def_span(fn_def.did);\n+    let fn_id = tcx.hir().local_def_id_to_hir_id(fn_def.did);\n+    let generator_kind = tcx.generator_kind(fn_def.did);\n+\n+    // Figure out what primary body this item has.\n+    let body_id = tcx.hir().body_owned_by(fn_def.did);\n+    let span_with_body = tcx.hir().span_with_body(fn_id);\n+    let return_ty_span = tcx\n+        .hir()\n+        .fn_decl_by_hir_id(fn_id)\n+        .unwrap_or_else(|| span_bug!(span, \"can't build MIR for {:?}\", fn_def.did))\n+        .output\n+        .span();\n+\n+    // fetch the fully liberated fn signature (that is, all bound\n+    // types/lifetimes replaced)\n+    let typeck_results = tcx.typeck_opt_const_arg(fn_def);\n+    let fn_sig = typeck_results.liberated_fn_sigs()[fn_id];\n+\n+    let safety = match fn_sig.unsafety {\n+        hir::Unsafety::Normal => Safety::Safe,\n+        hir::Unsafety::Unsafe => Safety::FnUnsafe,\n+    };\n+\n+    let body = tcx.hir().body(body_id);\n+    let ty = tcx.type_of(fn_def.did);\n+    let mut abi = fn_sig.abi;\n+    let implicit_argument = match ty.kind() {\n+        ty::Closure(..) => {\n+            // HACK(eddyb) Avoid having RustCall on closures,\n+            // as it adds unnecessary (and wrong) auto-tupling.\n+            abi = Abi::Rust;\n+            vec![ArgInfo(liberated_closure_env_ty(tcx, fn_id, body_id), None, None, None)]\n+        }\n+        ty::Generator(..) => {\n+            let gen_ty = typeck_results.node_type(fn_id);\n+\n+            // The resume argument may be missing, in that case we need to provide it here.\n+            // It will always be `()` in this case.\n+            if body.params.is_empty() {\n+                vec![ArgInfo(gen_ty, None, None, None), ArgInfo(tcx.mk_unit(), None, None, None)]\n+            } else {\n+                vec![ArgInfo(gen_ty, None, None, None)]\n+            }\n+        }\n+        _ => vec![],\n+    };\n+\n+    let explicit_arguments = body.params.iter().enumerate().map(|(index, arg)| {\n+        let owner_id = tcx.hir().body_owner(body_id);\n+        let opt_ty_info;\n+        let self_arg;\n+        if let Some(ref fn_decl) = tcx.hir().fn_decl_by_hir_id(owner_id) {\n+            opt_ty_info = fn_decl\n+                .inputs\n+                .get(index)\n+                // Make sure that inferred closure args have no type span\n+                .and_then(|ty| if arg.pat.span != ty.span { Some(ty.span) } else { None });\n+            self_arg = if index == 0 && fn_decl.implicit_self.has_implicit_self() {\n+                Some(fn_decl.implicit_self)\n+            } else {\n+                None\n+            };\n+        } else {\n+            opt_ty_info = None;\n+            self_arg = None;\n+        }\n+\n+        // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n+        // (as it's created inside the body itself, not passed in from outside).\n+        let ty = if fn_sig.c_variadic && index == fn_sig.inputs().len() {\n+            let va_list_did = tcx.require_lang_item(LangItem::VaList, Some(arg.span));\n+\n+            tcx.bound_type_of(va_list_did).subst(tcx, &[tcx.lifetimes.re_erased.into()])\n+        } else {\n+            fn_sig.inputs()[index]\n+        };\n+\n+        ArgInfo(ty, opt_ty_info, Some(&arg), self_arg)\n+    });\n+\n+    let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+\n+    let (yield_ty, return_ty) = if generator_kind.is_some() {\n+        let gen_ty = typeck_results.node_type(fn_id);\n+        let gen_sig = match gen_ty.kind() {\n+            ty::Generator(_, gen_substs, ..) => gen_substs.as_generator().sig(),\n+            _ => {\n+                span_bug!(span, \"generator w/o generator type: {:?}\", ty)\n+            }\n+        };\n+        (Some(gen_sig.yield_ty), gen_sig.return_ty)\n+    } else {\n+        (None, fn_sig.output())\n+    };\n+\n     let arguments: Vec<_> = arguments.collect();\n \n-    let tcx = infcx.tcx;\n-    let span = tcx.hir().span(fn_id);\n-\n-    let mut builder = Builder::new(\n-        thir,\n-        infcx,\n-        fn_def,\n-        fn_id,\n-        span_with_body,\n-        arguments.len(),\n-        safety,\n-        return_ty,\n-        return_ty_span,\n-        body.generator_kind,\n-    );\n+    let mut body = tcx.infer_ctxt().enter(|infcx| {\n+        let mut builder = Builder::new(\n+            thir,\n+            infcx,\n+            fn_def,\n+            fn_id,\n+            span_with_body,\n+            arguments.len(),\n+            safety,\n+            return_ty,\n+            return_ty_span,\n+            generator_kind,\n+        );\n \n-    let call_site_scope =\n-        region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::CallSite };\n-    let arg_scope =\n-        region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::Arguments };\n-    let source_info = builder.source_info(span);\n-    let call_site_s = (call_site_scope, source_info);\n-    unpack!(builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n-        let arg_scope_s = (arg_scope, source_info);\n-        // Attribute epilogue to function's closing brace\n-        let fn_end = span_with_body.shrink_to_hi();\n-        let return_block =\n-            unpack!(builder.in_breakable_scope(None, Place::return_place(), fn_end, |builder| {\n-                Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n-                    builder.args_and_body(\n-                        START_BLOCK,\n-                        fn_def.did,\n-                        &arguments,\n-                        arg_scope,\n-                        &thir[expr],\n-                    )\n-                }))\n-            }));\n-        let source_info = builder.source_info(fn_end);\n-        builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n-        builder.build_drop_trees();\n-        return_block.unit()\n-    }));\n+        let call_site_scope =\n+            region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::CallSite };\n+        let arg_scope =\n+            region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::Arguments };\n+        let source_info = builder.source_info(span);\n+        let call_site_s = (call_site_scope, source_info);\n+        unpack!(builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n+            let arg_scope_s = (arg_scope, source_info);\n+            // Attribute epilogue to function's closing brace\n+            let fn_end = span_with_body.shrink_to_hi();\n+            let return_block = unpack!(builder.in_breakable_scope(\n+                None,\n+                Place::return_place(),\n+                fn_end,\n+                |builder| {\n+                    Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n+                        builder.args_and_body(\n+                            START_BLOCK,\n+                            fn_def.did,\n+                            &arguments,\n+                            arg_scope,\n+                            &thir[expr],\n+                        )\n+                    }))\n+                }\n+            ));\n+            let source_info = builder.source_info(fn_end);\n+            builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n+            builder.build_drop_trees();\n+            return_block.unit()\n+        }));\n+\n+        builder.finish()\n+    });\n \n-    let spread_arg = if abi == Abi::RustCall {\n+    body.spread_arg = if abi == Abi::RustCall {\n         // RustCall pseudo-ABI untuples the last argument.\n         Some(Local::new(arguments.len()))\n     } else {\n         None\n     };\n-\n-    let mut body = builder.finish();\n-    body.spread_arg = spread_arg;\n+    if yield_ty.is_some() {\n+        body.generator.as_mut().unwrap().yield_ty = yield_ty;\n+    }\n     body\n }\n \n fn construct_const<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::WithOptConstParam<LocalDefId>,\n     thir: &'a Thir<'tcx>,\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n     expr: ExprId,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-    hir_id: hir::HirId,\n-    const_ty: Ty<'tcx>,\n-    const_ty_span: Span,\n-    span: Span,\n ) -> Body<'tcx> {\n-    let mut builder = Builder::new(\n-        thir,\n-        infcx,\n-        def,\n-        hir_id,\n-        span,\n-        0,\n-        Safety::Safe,\n-        const_ty,\n-        const_ty_span,\n-        None,\n-    );\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n \n-    let mut block = START_BLOCK;\n-    unpack!(block = builder.expr_into_dest(Place::return_place(), block, &thir[expr]));\n+    // Figure out what primary body this item has.\n+    let (span, const_ty_span) = match tcx.hir().get(hir_id) {\n+        Node::Item(hir::Item {\n+            kind: hir::ItemKind::Static(ty, _, _) | hir::ItemKind::Const(ty, _),\n+            span,\n+            ..\n+        })\n+        | Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Const(ty, _), span, .. })\n+        | Node::TraitItem(hir::TraitItem {\n+            kind: hir::TraitItemKind::Const(ty, Some(_)),\n+            span,\n+            ..\n+        }) => (*span, ty.span),\n+        Node::AnonConst(_) => {\n+            let span = tcx.def_span(def.did);\n+            (span, span)\n+        }\n+        _ => span_bug!(tcx.def_span(def.did), \"can't build MIR for {:?}\", def.did),\n+    };\n \n-    let source_info = builder.source_info(span);\n-    builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n+    // Get the revealed type of this const. This is *not* the adjusted\n+    // type of its body, which may be a subtype of this type. For\n+    // example:\n+    //\n+    // fn foo(_: &()) {}\n+    // static X: fn(&'static ()) = foo;\n+    //\n+    // The adjusted type of the body of X is `for<'a> fn(&'a ())` which\n+    // is not the same as the type of X. We need the type of the return\n+    // place to be the type of the constant because NLL typeck will\n+    // equate them.\n+    let typeck_results = tcx.typeck_opt_const_arg(def);\n+    let const_ty = typeck_results.node_type(hir_id);\n \n-    builder.build_drop_trees();\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let mut builder = Builder::new(\n+            thir,\n+            infcx,\n+            def,\n+            hir_id,\n+            span,\n+            0,\n+            Safety::Safe,\n+            const_ty,\n+            const_ty_span,\n+            None,\n+        );\n+\n+        let mut block = START_BLOCK;\n+        unpack!(block = builder.expr_into_dest(Place::return_place(), block, &thir[expr]));\n \n-    builder.finish()\n+        let source_info = builder.source_info(span);\n+        builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n+\n+        builder.build_drop_trees();\n+\n+        builder.finish()\n+    })\n }\n \n /// Construct MIR for an item that has had errors in type checking.\n ///\n /// This is required because we may still want to run MIR passes on an item\n /// with type errors, but normal MIR construction can't handle that in general.\n-fn construct_error<'a, 'tcx>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-    hir_id: hir::HirId,\n-    body_id: hir::BodyId,\n+fn construct_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: LocalDefId,\n     body_owner_kind: hir::BodyOwnerKind,\n     err: ErrorGuaranteed,\n ) -> Body<'tcx> {\n-    let tcx = infcx.tcx;\n-    let span = tcx.hir().span(hir_id);\n+    let span = tcx.def_span(def);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def);\n+    let generator_kind = tcx.generator_kind(def);\n+\n     let ty = tcx.ty_error();\n-    let generator_kind = tcx.hir().body(body_id).generator_kind;\n     let num_params = match body_owner_kind {\n-        hir::BodyOwnerKind::Fn => tcx.hir().fn_decl_by_hir_id(hir_id).unwrap().inputs.len(),\n+        hir::BodyOwnerKind::Fn => tcx.fn_sig(def).inputs().skip_binder().len(),\n         hir::BodyOwnerKind::Closure => {\n-            if generator_kind.is_some() {\n-                // Generators have an implicit `self` parameter *and* a possibly\n-                // implicit resume parameter.\n-                2\n-            } else {\n-                // The implicit self parameter adds another local in MIR.\n-                1 + tcx.hir().fn_decl_by_hir_id(hir_id).unwrap().inputs.len()\n+            let ty = tcx.type_of(def);\n+            match ty.kind() {\n+                ty::Closure(_, substs) => {\n+                    1 + substs.as_closure().sig().inputs().skip_binder().len()\n+                }\n+                ty::Generator(..) => 2,\n+                _ => bug!(\"expected closure or generator, found {ty:?}\"),\n             }\n         }\n         hir::BodyOwnerKind::Const => 0,\n@@ -775,7 +744,7 @@ fn construct_error<'a, 'tcx>(\n     cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n \n     let mut body = Body::new(\n-        MirSource::item(def.did.to_def_id()),\n+        MirSource::item(def.to_def_id()),\n         cfg.basic_blocks,\n         source_scopes,\n         local_decls,\n@@ -793,7 +762,7 @@ fn construct_error<'a, 'tcx>(\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn new(\n         thir: &'a Thir<'tcx>,\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n+        infcx: InferCtxt<'a, 'tcx>,\n         def: ty::WithOptConstParam<LocalDefId>,\n         hir_id: hir::HirId,\n         span: Span,"}, {"sha": "b6e28364768ec8589e63aba93ad0a12a843dc48c", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f76594a0bc0be37d92d9182aa1e7eb1f9e25d54c/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f76594a0bc0be37d92d9182aa1e7eb1f9e25d54c/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=f76594a0bc0be37d92d9182aa1e7eb1f9e25d54c", "patch": "@@ -29,6 +29,11 @@ note: ...which requires building MIR for `cycle1`...\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building THIR for `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle1`...\n   --> $DIR/auto-trait-leak.rs:14:5\n    |\n@@ -65,6 +70,11 @@ note: ...which requires building MIR for `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building THIR for `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:19:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle2`...\n   --> $DIR/auto-trait-leak.rs:20:5\n    |"}]}