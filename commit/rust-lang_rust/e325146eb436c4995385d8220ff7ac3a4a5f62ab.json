{"sha": "e325146eb436c4995385d8220ff7ac3a4a5f62ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMjUxNDZlYjQzNmM0OTk1Mzg1ZDgyMjBmZjdhYzNhNGE1ZjYyYWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-04T03:29:12Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-04T03:30:01Z"}, "message": "Merge remote-tracking branch 'brson/mainthread'\n\nConflicts:\n\tsrc/rt/rust_kernel.cpp\n\tsrc/rt/rust_scheduler.cpp\n\tsrc/rt/rust_scheduler.h", "tree": {"sha": "999875912f33a00906c76f1eac278251bf63658a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/999875912f33a00906c76f1eac278251bf63658a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e325146eb436c4995385d8220ff7ac3a4a5f62ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e325146eb436c4995385d8220ff7ac3a4a5f62ab", "html_url": "https://github.com/rust-lang/rust/commit/e325146eb436c4995385d8220ff7ac3a4a5f62ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e325146eb436c4995385d8220ff7ac3a4a5f62ab/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd97ee65200966e6c3b0fb45de1fc771c3cf5f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd97ee65200966e6c3b0fb45de1fc771c3cf5f3f", "html_url": "https://github.com/rust-lang/rust/commit/bd97ee65200966e6c3b0fb45de1fc771c3cf5f3f"}, {"sha": "4cf7efc8f7df215b0ff9e3ea15b7890b84db1b51", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf7efc8f7df215b0ff9e3ea15b7890b84db1b51", "html_url": "https://github.com/rust-lang/rust/commit/4cf7efc8f7df215b0ff9e3ea15b7890b84db1b51"}], "stats": {"total": 278, "additions": 248, "deletions": 30}, "files": [{"sha": "9bffb34da16aed5e7ab7bd18e741b326d454c128", "filename": "src/libcore/task.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=e325146eb436c4995385d8220ff7ac3a4a5f62ab", "patch": "@@ -88,6 +88,13 @@ enum sched_mode {\n     thread_per_task,\n     #[doc = \"Tasks are distributed among a fixed number of OS threads\"]\n     manual_threads(uint),\n+    #[doc = \"\n+    Tasks are scheduled on the main OS thread\n+\n+    The main OS thread is the thread used to launch the runtime which,\n+    in most cases, is the process's initial thread as created by the OS.\n+    \"]\n+    osmain\n }\n \n #[doc = \"\n@@ -107,7 +114,7 @@ Scheduler configuration options\n \"]\n type sched_opts = {\n     mode: sched_mode,\n-    native_stack_size: option<uint>,\n+    native_stack_size: option<uint>\n };\n \n #[doc = \"\n@@ -525,9 +532,14 @@ fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n             }\n             threads\n           }\n+          osmain { 0u /* Won't be used */ }\n         };\n \n-        let sched_id = rustrt::rust_new_sched(num_threads);\n+        let sched_id = if opts.mode != osmain {\n+            rustrt::rust_new_sched(num_threads)\n+        } else {\n+            rustrt::rust_osmain_sched_id()\n+        };\n         rustrt::rust_new_task_in_sched(sched_id)\n     }\n \n@@ -553,6 +565,7 @@ native mod rustrt {\n \n     fn rust_task_is_unwinding(rt: *rust_task) -> bool;\n     fn unsupervise();\n+    fn rust_osmain_sched_id() -> sched_id;\n }\n \n \n@@ -897,3 +910,23 @@ fn test_avoid_copying_the_body_unsupervise() {\n         }\n     }\n }\n+\n+#[test]\n+fn test_osmain() {\n+    let builder = task_builder();\n+    let opts = {\n+        sched: some({\n+            mode: osmain,\n+            native_stack_size: none\n+        })\n+        with get_opts(builder)\n+    };\n+    set_opts(builder, opts);\n+\n+    let po = comm::port();\n+    let ch = comm::chan(po);\n+    run(builder) {||\n+        comm::send(ch, ());\n+    }\n+    comm::recv(po);\n+}"}, {"sha": "2fed06854cba204f3dc734a9f96b6d5df42679de", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=e325146eb436c4995385d8220ff7ac3a4a5f62ab", "patch": "@@ -93,7 +93,7 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n     root_task->start((spawn_fn)main_fn, NULL, args->args);\n     root_task = NULL;\n \n-    int ret = kernel->wait_for_exit();\n+    int ret = kernel->run();\n     delete args;\n     delete kernel;\n "}, {"sha": "0d1b67674a156cee7b67a9573cbb01abc0349e1c", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=e325146eb436c4995385d8220ff7ac3a4a5f62ab", "patch": "@@ -640,6 +640,12 @@ rust_dbg_call(dbg_callback cb, void *data) {\n     return cb(data);\n }\n \n+extern \"C\" CDECL rust_sched_id\n+rust_osmain_sched_id() {\n+    rust_task *task = rust_get_current_task();\n+    return task->kernel->osmain_sched_id();\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "ff6b0e1056cc14ca6b14f6f87aa66800f86dce67", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=e325146eb436c4995385d8220ff7ac3a4a5f62ab", "patch": "@@ -5,6 +5,7 @@\n #include \"rust_port.h\"\n #include \"rust_util.h\"\n #include \"rust_scheduler.h\"\n+#include \"rust_sched_launcher.h\"\n \n #define KLOG_(...)                              \\\n     KLOG(this, kern, __VA_ARGS__)\n@@ -19,8 +20,15 @@ rust_kernel::rust_kernel(rust_env *env) :\n     rval(0),\n     max_sched_id(0),\n     sched_reaper(this),\n+    osmain_driver(NULL),\n     env(env)\n {\n+    // Create the single threaded scheduler that will run on the platform's\n+    // main thread\n+    rust_manual_sched_launcher_factory launchfac;\n+    osmain_scheduler = create_scheduler(&launchfac, 1, false);\n+    osmain_driver = launchfac.get_driver();\n+    sched_reaper.start();\n }\n \n void\n@@ -60,24 +68,36 @@ void rust_kernel::free(void *mem) {\n \n rust_sched_id\n rust_kernel::create_scheduler(size_t num_threads) {\n+    rust_thread_sched_launcher_factory launchfac;\n+    return create_scheduler(&launchfac, num_threads, true);\n+}\n+\n+rust_sched_id\n+rust_kernel::create_scheduler(rust_sched_launcher_factory *launchfac,\n+                              size_t num_threads, bool allow_exit) {\n     rust_sched_id id;\n     rust_scheduler *sched;\n     {\n         scoped_lock with(sched_lock);\n-        // If this is the first scheduler then we need to launch\n-        // the scheduler reaper.\n-        bool start_reaper = sched_table.empty();\n+\n+        if (sched_table.size() == 1) {\n+            // The OS main scheduler may not exit while there are other\n+            // schedulers\n+            KLOG_(\"Disallowing osmain scheduler to exit\");\n+            rust_scheduler *sched =\n+                get_scheduler_by_id_nolock(osmain_scheduler);\n+            assert(sched != NULL);\n+            sched->disallow_exit();\n+        }\n+\n         id = max_sched_id++;\n         assert(id != INTPTR_MAX && \"Hit the maximum scheduler id\");\n         sched = new (this, \"rust_scheduler\")\n-            rust_scheduler(this, num_threads, id);\n+            rust_scheduler(this, num_threads, id, allow_exit, launchfac);\n         bool is_new = sched_table\n             .insert(std::pair<rust_sched_id,\n                               rust_scheduler*>(id, sched)).second;\n         assert(is_new && \"Reusing a sched id?\");\n-        if (start_reaper) {\n-            sched_reaper.start();\n-        }\n     }\n     sched->start_task_threads();\n     return id;\n@@ -86,6 +106,12 @@ rust_kernel::create_scheduler(size_t num_threads) {\n rust_scheduler *\n rust_kernel::get_scheduler_by_id(rust_sched_id id) {\n     scoped_lock with(sched_lock);\n+    return get_scheduler_by_id_nolock(id);\n+}\n+\n+rust_scheduler *\n+rust_kernel::get_scheduler_by_id_nolock(rust_sched_id id) {\n+    sched_lock.must_have_lock();\n     sched_map::iterator iter = sched_table.find(id);\n     if (iter != sched_table.end()) {\n         return iter->second;\n@@ -117,23 +143,35 @@ rust_kernel::wait_for_schedulers()\n     while (!sched_table.empty()) {\n         while (!join_list.empty()) {\n             rust_sched_id id = join_list.back();\n+            KLOG_(\"Deleting scheduler %d\", id);\n             join_list.pop_back();\n             sched_map::iterator iter = sched_table.find(id);\n             assert(iter != sched_table.end());\n             rust_scheduler *sched = iter->second;\n             sched_table.erase(iter);\n             sched->join_task_threads();\n             delete sched;\n+            if (sched_table.size() == 1) {\n+                KLOG_(\"Allowing osmain scheduler to exit\");\n+                // It's only the osmain scheduler left. Tell it to exit\n+                rust_scheduler *sched =\n+                    get_scheduler_by_id_nolock(osmain_scheduler);\n+                assert(sched != NULL);\n+                sched->allow_exit();\n+            }\n         }\n         if (!sched_table.empty()) {\n             sched_lock.wait();\n         }\n     }\n }\n \n-/* Called on the main thread to wait for the kernel to exit */\n+/* Called on the main thread to run the osmain scheduler to completion,\n+   then wait for schedulers to exit */\n int\n-rust_kernel::wait_for_exit() {\n+rust_kernel::run() {\n+    assert(osmain_driver != NULL);\n+    osmain_driver->start_main_loop();\n     sched_reaper.join();\n     return rval;\n }"}, {"sha": "6a7a7070c20812f8572b03b461806256b03f9065", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=e325146eb436c4995385d8220ff7ac3a4a5f62ab", "patch": "@@ -22,6 +22,9 @@ typedef intptr_t rust_port_id;\n \n typedef std::map<rust_sched_id, rust_scheduler*> sched_map;\n \n+class rust_sched_driver;\n+class rust_sched_launcher_factory;\n+\n /**\n  * A global object shared by all thread domains. Most of the data structures\n  * in this class are synchronized since they are accessed from multiple\n@@ -54,6 +57,13 @@ class rust_kernel {\n     std::vector<rust_sched_id> join_list;\n \n     rust_sched_reaper sched_reaper;\n+    // The single-threaded scheduler that uses the main thread\n+    rust_sched_id osmain_scheduler;\n+    // Runs the single-threaded scheduler that executes tasks\n+    // on the main thread\n+    rust_sched_driver *osmain_driver;\n+\n+    rust_scheduler* get_scheduler_by_id_nolock(rust_sched_id id);\n \n public:\n     struct rust_env *env;\n@@ -71,11 +81,13 @@ class rust_kernel {\n     void fail();\n \n     rust_sched_id create_scheduler(size_t num_threads);\n+    rust_sched_id create_scheduler(rust_sched_launcher_factory *launchfac,\n+                                   size_t num_threads, bool allow_exit);\n     rust_scheduler* get_scheduler_by_id(rust_sched_id id);\n     // Called by a scheduler to indicate that it is terminating\n     void release_scheduler_id(rust_sched_id id);\n     void wait_for_schedulers();\n-    int wait_for_exit();\n+    int run();\n \n #ifdef __WIN32__\n     void win32_require(LPCTSTR fn, BOOL ok);\n@@ -88,6 +100,8 @@ class rust_kernel {\n     void release_port_id(rust_port_id tid);\n \n     void set_exit_status(int code);\n+\n+    rust_sched_id osmain_sched_id() { return osmain_scheduler; }\n };\n \n template <typename T> struct kernel_owned {"}, {"sha": "bf0481b02f2bbf56fbf8d6b7017497194f77b0f2", "filename": "src/rt/rust_sched_launcher.cpp", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_sched_launcher.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_sched_launcher.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_launcher.cpp?ref=e325146eb436c4995385d8220ff7ac3a4a5f62ab", "patch": "@@ -16,3 +16,21 @@ rust_thread_sched_launcher::rust_thread_sched_launcher(rust_scheduler *sched,\n       rust_thread(SCHED_STACK_SIZE) {\n }\n \n+rust_manual_sched_launcher::rust_manual_sched_launcher(rust_scheduler *sched,\n+                                                       int id)\n+    : rust_sched_launcher(sched, id) {\n+}\n+\n+rust_sched_launcher *\n+rust_thread_sched_launcher_factory::create(rust_scheduler *sched, int id) {\n+    return new(sched->kernel, \"rust_thread_sched_launcher\")\n+        rust_thread_sched_launcher(sched, id);\n+}\n+\n+rust_sched_launcher *\n+rust_manual_sched_launcher_factory::create(rust_scheduler *sched, int id) {\n+    assert(launcher == NULL && \"I can only track one sched_launcher\");\n+    launcher = new(sched->kernel, \"rust_manual_sched_launcher\")\n+        rust_manual_sched_launcher(sched, id);\n+    return launcher;\n+}"}, {"sha": "ace2cba25300d3e6f35fd82e18306aa477cef07e", "filename": "src/rt/rust_sched_launcher.h", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_sched_launcher.h", "raw_url": "https://github.com/rust-lang/rust/raw/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_sched_launcher.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_launcher.h?ref=e325146eb436c4995385d8220ff7ac3a4a5f62ab", "patch": "@@ -31,8 +31,42 @@ class rust_thread_sched_launcher\n public:\n     rust_thread_sched_launcher(rust_scheduler *sched, int id);\n     virtual void start() { rust_thread::start(); }\n-    virtual void run() { driver.start_main_loop(); }\n     virtual void join() { rust_thread::join(); }\n+    virtual void run() { driver.start_main_loop(); }\n+};\n+\n+class rust_manual_sched_launcher : public rust_sched_launcher {\n+public:\n+    rust_manual_sched_launcher(rust_scheduler *sched, int id);\n+    virtual void start() { }\n+    virtual void join() { }\n+    rust_sched_driver *get_driver() { return &driver; };\n+};\n+\n+class rust_sched_launcher_factory {\n+public:\n+    virtual ~rust_sched_launcher_factory() { }\n+    virtual rust_sched_launcher *\n+    create(rust_scheduler *sched, int id) = 0;\n+};\n+\n+class rust_thread_sched_launcher_factory\n+    : public rust_sched_launcher_factory {\n+public:\n+    virtual rust_sched_launcher *create(rust_scheduler *sched, int id);\n+};\n+\n+class rust_manual_sched_launcher_factory\n+    : public rust_sched_launcher_factory {\n+private:\n+    rust_manual_sched_launcher *launcher;\n+public:\n+    rust_manual_sched_launcher_factory() : launcher(NULL) { }\n+    virtual rust_sched_launcher *create(rust_scheduler *sched, int id);\n+    rust_sched_driver *get_driver() {\n+        assert(launcher != NULL);\n+        return launcher->get_driver();\n+    }\n };\n \n #endif // RUST_SCHED_LAUNCHER_H"}, {"sha": "1b5978b5cfec17bb856d1de4acaae6cc4ae262b2", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=e325146eb436c4995385d8220ff7ac3a4a5f62ab", "patch": "@@ -7,26 +7,28 @@\n \n rust_scheduler::rust_scheduler(rust_kernel *kernel,\n                                size_t num_threads,\n-                               rust_sched_id id) :\n+                               rust_sched_id id,\n+                               bool allow_exit,\n+                               rust_sched_launcher_factory *launchfac) :\n     kernel(kernel),\n     live_threads(num_threads),\n     live_tasks(0),\n-    num_threads(num_threads),\n     cur_thread(0),\n+    may_exit(allow_exit),\n+    num_threads(num_threads),\n     id(id)\n {\n-    create_task_threads();\n+    create_task_threads(launchfac);\n }\n \n rust_scheduler::~rust_scheduler() {\n     destroy_task_threads();\n }\n \n rust_sched_launcher *\n-rust_scheduler::create_task_thread(int id) {\n-    rust_sched_launcher *thread =\n-        new (kernel, \"rust_thread_sched_launcher\")\n-        rust_thread_sched_launcher(this, id);\n+rust_scheduler::create_task_thread(rust_sched_launcher_factory *launchfac,\n+                                   int id) {\n+    rust_sched_launcher *thread = launchfac->create(this, id);\n     KLOG(kernel, kern, \"created task thread: \" PTR \", id: %d\",\n           thread, id);\n     return thread;\n@@ -39,11 +41,11 @@ rust_scheduler::destroy_task_thread(rust_sched_launcher *thread) {\n }\n \n void\n-rust_scheduler::create_task_threads() {\n+rust_scheduler::create_task_threads(rust_sched_launcher_factory *launchfac) {\n     KLOG(kernel, kern, \"Using %d scheduler threads.\", num_threads);\n \n     for(size_t i = 0; i < num_threads; ++i) {\n-        threads.push(create_task_thread(i));\n+        threads.push(create_task_thread(launchfac, i));\n     }\n }\n \n@@ -100,12 +102,11 @@ rust_scheduler::release_task() {\n     {\n         scoped_lock with(lock);\n         live_tasks--;\n-        if (live_tasks == 0) {\n+        if (live_tasks == 0 && may_exit) {\n             need_exit = true;\n         }\n     }\n     if (need_exit) {\n-        // There are no more tasks on this scheduler. Time to leave\n         exit();\n     }\n }\n@@ -136,3 +137,22 @@ rust_scheduler::release_task_thread() {\n         kernel->release_scheduler_id(id);\n     }\n }\n+\n+void\n+rust_scheduler::allow_exit() {\n+    bool need_exit = false;\n+    {\n+        scoped_lock with(lock);\n+        may_exit = true;\n+        need_exit = live_tasks == 0;\n+    }\n+    if (need_exit) {\n+        exit();\n+    }\n+}\n+\n+void\n+rust_scheduler::disallow_exit() {\n+    scoped_lock with(lock);\n+    may_exit = false;\n+}"}, {"sha": "fec951f276c8fd6fa5b372f85842f1d7f58648c5", "filename": "src/rt/rust_scheduler.h", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=e325146eb436c4995385d8220ff7ac3a4a5f62ab", "patch": "@@ -6,36 +6,40 @@\n #include \"rust_kernel.h\"\n \n class rust_sched_launcher;\n+class rust_sched_launcher_factory;\n \n class rust_scheduler : public kernel_owned<rust_scheduler> {\n     // FIXME: Make these private\n public:\n     rust_kernel *kernel;\n private:\n-    // Protects live_threads and cur_thread increments\n+    // Protects live_threads, live_tasks, cur_thread, may_exit\n     lock_and_signal lock;\n     // When this hits zero we'll tell the kernel to release us\n     uintptr_t live_threads;\n     // When this hits zero we'll tell the threads to exit\n     uintptr_t live_tasks;\n+    size_t cur_thread;\n+    bool may_exit;\n \n     array_list<rust_sched_launcher *> threads;\n     const size_t num_threads;\n-    size_t cur_thread;\n \n     rust_sched_id id;\n \n-    void create_task_threads();\n+    void create_task_threads(rust_sched_launcher_factory *launchfac);\n     void destroy_task_threads();\n \n-    rust_sched_launcher *create_task_thread(int id);\n+    rust_sched_launcher *\n+    create_task_thread(rust_sched_launcher_factory *launchfac, int id);\n     void destroy_task_thread(rust_sched_launcher *thread);\n \n     void exit();\n \n public:\n     rust_scheduler(rust_kernel *kernel, size_t num_threads,\n-                   rust_sched_id id);\n+                   rust_sched_id id, bool allow_exit,\n+                   rust_sched_launcher_factory *launchfac);\n     ~rust_scheduler();\n \n     void start_task_threads();\n@@ -51,6 +55,10 @@ class rust_scheduler : public kernel_owned<rust_scheduler> {\n     void release_task_thread();\n \n     rust_sched_id get_id() { return id; }\n+    // Tells the scheduler that as soon as it runs out of tasks\n+    // to run it should exit\n+    void allow_exit();\n+    void disallow_exit();\n };\n \n #endif /* RUST_SCHEDULER_H */"}, {"sha": "cdfb5ff67a7d8c95e9f40d0f3848213a069d3c47", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=e325146eb436c4995385d8220ff7ac3a4a5f62ab", "patch": "@@ -97,3 +97,4 @@ rust_dbg_lock_unlock\n rust_dbg_lock_wait\n rust_dbg_lock_signal\n rust_dbg_call\n+rust_osmain_sched_id"}, {"sha": "70f59ee2e1b66557bfc921a091e339bc11f67046", "filename": "src/test/run-pass/osmain.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Ftest%2Frun-pass%2Fosmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e325146eb436c4995385d8220ff7ac3a4a5f62ab/src%2Ftest%2Frun-pass%2Fosmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fosmain.rs?ref=e325146eb436c4995385d8220ff7ac3a4a5f62ab", "patch": "@@ -0,0 +1,46 @@\n+// Jump back and forth between the OS main thread and a new scheduler.\n+// The OS main scheduler should continue to be available and not terminate\n+// while it is not in use.\n+\n+fn main() {\n+    run(100);\n+}\n+\n+fn run(i: int) {\n+\n+    log(debug, i);\n+\n+    if i == 0 {\n+        ret;\n+    }\n+\n+    let builder = task::task_builder();\n+    let opts = {\n+        sched: some({\n+            mode: task::osmain,\n+            native_stack_size: none\n+        })\n+        with task::get_opts(builder)\n+    };\n+    task::set_opts(builder, opts);\n+    task::unsupervise(builder);\n+    task::run(builder) {||\n+        task::yield();\n+        let builder = task::task_builder();\n+        let opts = {\n+            sched: some({\n+                mode: task::single_threaded,\n+                native_stack_size: none\n+            })\n+            with task::get_opts(builder)\n+        };\n+        task::set_opts(builder, opts);\n+        task::unsupervise(builder);\n+        task::run(builder) {||\n+            task::yield();\n+            run(i - 1);\n+            task::yield();\n+        }\n+        task::yield();\n+    }\n+}"}]}