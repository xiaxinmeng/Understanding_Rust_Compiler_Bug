{"sha": "e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZWIzY2NiYTAzNDZkYjlmYzhhNjUxNjEwMDZkY2JhYWJlODY2Zjk=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-01-18T18:27:41Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-01-19T22:43:15Z"}, "message": "Kill TraitStore", "tree": {"sha": "88ea30a0845a767df7733506cda9b1406c7576f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88ea30a0845a767df7733506cda9b1406c7576f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "html_url": "https://github.com/rust-lang/rust/commit/e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4032b85aec962486af7f205e72e93efc8a0bc434", "url": "https://api.github.com/repos/rust-lang/rust/commits/4032b85aec962486af7f205e72e93efc8a0bc434", "html_url": "https://github.com/rust-lang/rust/commit/4032b85aec962486af7f205e72e93efc8a0bc434"}], "stats": {"total": 580, "additions": 14, "deletions": 566}, "files": [{"sha": "d18c12b308d48154eac347f90126a960a6e19b4c", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -243,19 +243,6 @@ fn parse_size(st: &mut PState) -> Option<uint> {\n     }\n }\n \n-fn parse_trait_store_<F>(st: &mut PState, conv: &mut F) -> ty::TraitStore where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    match next(st) {\n-        '~' => ty::UniqTraitStore,\n-        '&' => ty::RegionTraitStore(parse_region_(st, conv), parse_mutability(st)),\n-        c => {\n-            st.tcx.sess.bug(&format!(\"parse_trait_store(): bad input '{}'\",\n-                                    c)[])\n-        }\n-    }\n-}\n-\n fn parse_vec_per_param_space<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>,\n                                              mut f: F)\n                                              -> VecPerParamSpace<T> where\n@@ -662,14 +649,12 @@ fn parse_closure_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n {\n     let unsafety = parse_unsafety(next(st));\n     let onceness = parse_onceness(next(st));\n-    let store = parse_trait_store_(st, conv);\n     let bounds = parse_existential_bounds_(st, conv);\n     let sig = parse_sig_(st, conv);\n     let abi = parse_abi_set(st);\n     ty::ClosureTy {\n         unsafety: unsafety,\n         onceness: onceness,\n-        store: store,\n         bounds: bounds,\n         sig: sig,\n         abi: abi,"}, {"sha": "4727c5dddf76829dbd9f4f902460123de9610629", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -305,17 +305,6 @@ pub fn enc_trait_ref<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n     enc_substs(w, cx, s.substs);\n }\n \n-pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore) {\n-    match s {\n-        ty::UniqTraitStore => mywrite!(w, \"~\"),\n-        ty::RegionTraitStore(re, m) => {\n-            mywrite!(w, \"&\");\n-            enc_region(w, cx, re);\n-            enc_mutability(w, m);\n-        }\n-    }\n-}\n-\n fn enc_unsafety(w: &mut SeekableMemWriter, p: ast::Unsafety) {\n     match p {\n         ast::Unsafety::Normal => mywrite!(w, \"n\"),\n@@ -347,7 +336,6 @@ pub fn enc_closure_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                                 ft: &ty::ClosureTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n     enc_onceness(w, ft.onceness);\n-    enc_trait_store(w, cx, ft.store);\n     enc_existential_bounds(w, cx, &ft.bounds);\n     enc_fn_sig(w, cx, &ft.sig);\n     enc_abi(w, ft.abi);"}, {"sha": "9fc445d9cb6a539c730633f49fc8aaae84d5cbc4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -515,17 +515,6 @@ impl tr for ty::BoundRegion {\n     }\n }\n \n-impl tr for ty::TraitStore {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::TraitStore {\n-        match *self {\n-            ty::RegionTraitStore(r, m) => {\n-                ty::RegionTraitStore(r.tr(dcx), m)\n-            }\n-            ty::UniqTraitStore => ty::UniqTraitStore\n-        }\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n "}, {"sha": "3280769ff03866bedbb3ad4dd9c0271299674b34", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -202,39 +202,6 @@ pub trait Combine<'tcx> : Sized {\n                          sig: sig})\n     }\n \n-    fn closure_tys(&self, a: &ty::ClosureTy<'tcx>,\n-                   b: &ty::ClosureTy<'tcx>) -> cres<'tcx, ty::ClosureTy<'tcx>> {\n-\n-        let store = match (a.store, b.store) {\n-            (ty::RegionTraitStore(a_r, a_m),\n-             ty::RegionTraitStore(b_r, b_m)) if a_m == b_m => {\n-                let r = try!(self.contraregions(a_r, b_r));\n-                ty::RegionTraitStore(r, a_m)\n-            }\n-\n-            _ if a.store == b.store => {\n-                a.store\n-            }\n-\n-            _ => {\n-                return Err(ty::terr_sigil_mismatch(expected_found(self, a.store, b.store)))\n-            }\n-        };\n-        let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n-        let onceness = try!(self.oncenesses(a.onceness, b.onceness));\n-        let bounds = try!(self.existential_bounds(&a.bounds, &b.bounds));\n-        let sig = try!(self.binders(&a.sig, &b.sig));\n-        let abi = try!(self.abi(a.abi, b.abi));\n-        Ok(ty::ClosureTy {\n-            unsafety: unsafety,\n-            onceness: onceness,\n-            store: store,\n-            bounds: bounds,\n-            sig: sig,\n-            abi: abi,\n-        })\n-    }\n-\n     fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> cres<'tcx, ty::FnSig<'tcx>> {\n         if a.variadic != b.variadic {\n             return Err(ty::terr_variadic_mismatch(expected_found(self, a.variadic, b.variadic)));\n@@ -356,31 +323,6 @@ pub trait Combine<'tcx> : Sized {\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n \n-    fn trait_stores(&self,\n-                    vk: ty::terr_vstore_kind,\n-                    a: ty::TraitStore,\n-                    b: ty::TraitStore)\n-                    -> cres<'tcx, ty::TraitStore> {\n-        debug!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n-\n-        match (a, b) {\n-            (ty::RegionTraitStore(a_r, a_m),\n-             ty::RegionTraitStore(b_r, b_m)) if a_m == b_m => {\n-                self.contraregions(a_r, b_r).and_then(|r| {\n-                    Ok(ty::RegionTraitStore(r, a_m))\n-                })\n-            }\n-\n-            _ if a == b => {\n-                Ok(a)\n-            }\n-\n-            _ => {\n-                Err(ty::terr_trait_stores_differ(vk, expected_found(self, a, b)))\n-            }\n-        }\n-    }\n-\n     fn trait_refs(&self,\n                   a: &ty::TraitRef<'tcx>,\n                   b: &ty::TraitRef<'tcx>)"}, {"sha": "8d1a410859091cff82c692b0c58d0a45305e1a70", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 45, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -17,7 +17,6 @@ pub use self::InferTy::*;\n pub use self::InferRegion::*;\n pub use self::ImplOrTraitItemId::*;\n pub use self::UnboxedClosureKind::*;\n-pub use self::TraitStore::*;\n pub use self::ast_ty_to_ty_cache_entry::*;\n pub use self::Variance::*;\n pub use self::AutoAdjustment::*;\n@@ -61,7 +60,7 @@ use middle::ty;\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use middle::ty_walk::TypeWalker;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n-use util::ppaux::{trait_store_to_string, ty_to_string};\n+use util::ppaux::ty_to_string;\n use util::ppaux::{Repr, UserString};\n use util::common::{memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n@@ -247,14 +246,6 @@ pub struct mt<'tcx> {\n     pub mutbl: ast::Mutability,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Show)]\n-pub enum TraitStore {\n-    /// Box<Trait>\n-    UniqTraitStore,\n-    /// &Trait and &mut Trait\n-    RegionTraitStore(Region, ast::Mutability),\n-}\n-\n #[derive(Clone, Copy, Show)]\n pub struct field_ty {\n     pub name: Name,\n@@ -1042,7 +1033,6 @@ pub struct BareFnTy<'tcx> {\n pub struct ClosureTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n     pub onceness: ast::Onceness,\n-    pub store: TraitStore,\n     pub bounds: ExistentialBounds<'tcx>,\n     pub sig: PolyFnSig<'tcx>,\n     pub abi: abi::Abi,\n@@ -1545,7 +1535,6 @@ pub enum type_err<'tcx> {\n     terr_onceness_mismatch(expected_found<Onceness>),\n     terr_abi_mismatch(expected_found<abi::Abi>),\n     terr_mutability,\n-    terr_sigil_mismatch(expected_found<TraitStore>),\n     terr_box_mutability,\n     terr_ptr_mutability,\n     terr_ref_mutability,\n@@ -1559,7 +1548,6 @@ pub enum type_err<'tcx> {\n     terr_regions_no_overlap(Region, Region),\n     terr_regions_insufficiently_polymorphic(BoundRegion, Region),\n     terr_regions_overly_polymorphic(BoundRegion, Region),\n-    terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n     terr_sorts(expected_found<Ty<'tcx>>),\n     terr_integer_as_char,\n     terr_int_mismatch(expected_found<IntVarValue>),\n@@ -4194,19 +4182,6 @@ pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> ty::Binder<Vec<Ty<'tcx>>> {\n     ty_fn_sig(fty).inputs()\n }\n \n-pub fn ty_closure_store(fty: Ty) -> TraitStore {\n-    match fty.sty {\n-        ty_unboxed_closure(..) => {\n-            // Close enough for the purposes of all the callers of this\n-            // function (which is soon to be deprecated anyhow).\n-            UniqTraitStore\n-        }\n-        ref s => {\n-            panic!(\"ty_closure_store() called on non-closure type: {:?}\", s)\n-        }\n-    }\n-}\n-\n pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> Binder<FnOutput<'tcx>> {\n     match fty.sty {\n         ty_bare_fn(_, ref f) => f.sig.output(),\n@@ -4751,13 +4726,6 @@ impl<'tcx> Repr<'tcx> for ty::type_err<'tcx> {\n /// afterwards to present additional details, particularly when it comes to lifetime-related\n /// errors.\n pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n-    fn tstore_to_closure(s: &TraitStore) -> String {\n-        match s {\n-            &UniqTraitStore => \"proc\".to_string(),\n-            &RegionTraitStore(..) => \"closure\".to_string()\n-        }\n-    }\n-\n     match *err {\n         terr_cyclic_ty => \"cyclic type of infinite size\".to_string(),\n         terr_mismatch => \"types differ\".to_string(),\n@@ -4776,11 +4744,6 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n                     values.expected,\n                     values.found)\n         }\n-        terr_sigil_mismatch(values) => {\n-            format!(\"expected {}, found {}\",\n-                    tstore_to_closure(&values.expected),\n-                    tstore_to_closure(&values.found))\n-        }\n         terr_mutability => \"values differ in mutability\".to_string(),\n         terr_box_mutability => {\n             \"boxed values differ in mutability\".to_string()\n@@ -4828,11 +4791,6 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n                      found bound lifetime parameter {}\",\n                     bound_region_ptr_to_string(cx, br))\n         }\n-        terr_trait_stores_differ(_, ref values) => {\n-            format!(\"trait storage differs: expected `{}`, found `{}`\",\n-                    trait_store_to_string(cx, (*values).expected),\n-                    trait_store_to_string(cx, (*values).found))\n-        }\n         terr_sorts(values) => {\n             // A naive approach to making sure that we're not reporting silly errors such as:\n             // (expected closure, found closure).\n@@ -7338,10 +7296,9 @@ impl ReferencesError for Region\n \n impl<'tcx> Repr<'tcx> for ClosureTy<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ClosureTy({},{},{:?},{},{},{})\",\n+        format!(\"ClosureTy({},{},{},{},{})\",\n                 self.unsafety,\n                 self.onceness,\n-                self.store,\n                 self.bounds.repr(tcx),\n                 self.sig.repr(tcx),\n                 self.abi)"}, {"sha": "c2bbfca07bf304133f4fb3e0d390f92be1580921", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -124,10 +124,6 @@ pub trait TypeFolder<'tcx> : Sized {\n         r\n     }\n \n-    fn fold_trait_store(&mut self, s: ty::TraitStore) -> ty::TraitStore {\n-        super_fold_trait_store(self, s)\n-    }\n-\n     fn fold_existential_bounds(&mut self, s: &ty::ExistentialBounds<'tcx>)\n                                -> ty::ExistentialBounds<'tcx> {\n         super_fold_existential_bounds(self, s)\n@@ -225,12 +221,6 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitStore {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitStore {\n-        folder.fold_trait_store(*self)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty<'tcx> {\n         folder.fold_ty(*self)\n@@ -699,7 +689,6 @@ pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                         -> ty::ClosureTy<'tcx>\n {\n     ty::ClosureTy {\n-        store: fty.store.fold_with(this),\n         sig: fty.sig.fold_with(this),\n         unsafety: fty.unsafety,\n         onceness: fty.onceness,\n@@ -726,17 +715,6 @@ pub fn super_fold_mt<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             mutbl: mt.mutbl}\n }\n \n-pub fn super_fold_trait_store<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                         trait_store: ty::TraitStore)\n-                                                         -> ty::TraitStore {\n-    match trait_store {\n-        ty::UniqTraitStore => ty::UniqTraitStore,\n-        ty::RegionTraitStore(r, m) => {\n-            ty::RegionTraitStore(r.fold_with(this), m)\n-        }\n-    }\n-}\n-\n pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(\n     this: &mut T,\n     bounds: &ty::ExistentialBounds<'tcx>)"}, {"sha": "ba97331d183db07e9fbde9b2406ecf4fd32d6e47", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -237,15 +237,6 @@ pub fn mt_to_string<'tcx>(cx: &ctxt<'tcx>, m: &mt<'tcx>) -> String {\n         ty_to_string(cx, m.ty))\n }\n \n-pub fn trait_store_to_string(cx: &ctxt, s: ty::TraitStore) -> String {\n-    match s {\n-        ty::UniqTraitStore => \"Box \".to_string(),\n-        ty::RegionTraitStore(r, m) => {\n-            format!(\"{}{}\", region_ptr_to_string(cx, r), mutability_to_string(m))\n-        }\n-    }\n-}\n-\n pub fn vec_map_to_string<T, F>(ts: &[T], f: F) -> String where\n     F: FnMut(&T) -> String,\n {\n@@ -303,13 +294,6 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n     fn closure_to_string<'tcx>(cx: &ctxt<'tcx>, cty: &ty::ClosureTy<'tcx>) -> String {\n         let mut s = String::new();\n \n-        match cty.store {\n-            ty::UniqTraitStore => {}\n-            ty::RegionTraitStore(region, _) => {\n-                s.push_str(&region_to_string(cx, \"\", true, region)[]);\n-            }\n-        }\n-\n         match cty.unsafety {\n             ast::Unsafety::Normal => {}\n             ast::Unsafety::Unsafe => {\n@@ -320,22 +304,12 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n \n         let bounds_str = cty.bounds.user_string(cx);\n \n-        match cty.store {\n-            ty::UniqTraitStore => {\n-                assert_eq!(cty.onceness, ast::Once);\n-                s.push_str(\"proc\");\n-                push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n-                                   &bounds_str[]);\n-            }\n-            ty::RegionTraitStore(..) => {\n-                match cty.onceness {\n-                    ast::Many => {}\n-                    ast::Once => s.push_str(\"once \")\n-                }\n-                push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n-                                   &bounds_str[]);\n-            }\n+        match cty.onceness {\n+            ast::Many => {}\n+            ast::Once => s.push_str(\"once \")\n         }\n+        push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n+                           &bounds_str[]);\n \n         s\n     }\n@@ -1090,12 +1064,6 @@ impl<'tcx> Repr<'tcx> for ty::MethodObject<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TraitStore {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        trait_store_to_string(tcx, *self)\n-    }\n-}\n-\n impl<'tcx> Repr<'tcx> for ty::BuiltinBound {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{:?}\", *self)"}, {"sha": "56fdab6e040699816baa1c2dc572c5957ce2adf8", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -362,18 +362,6 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n     }\n }\n \n-// Returns a pointer to the body for the box. The box may be an opaque\n-// box. The result will be casted to the type of body_t, if it is statically\n-// known.\n-pub fn at_box_body<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               body_t: Ty<'tcx>, boxptr: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"at_box_body\");\n-    let ccx = bcx.ccx();\n-    let ty = Type::at_box(ccx, type_of(ccx, body_t));\n-    let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n-    GEPi(bcx, boxptr, &[0u, abi::BOX_FIELD_BODY])\n-}\n-\n fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 info_ty: Ty<'tcx>, it: LangItem) -> ast::DefId {\n     match bcx.tcx().lang_items.require(it) {\n@@ -1832,7 +1820,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                    .map(|arg| node_id_type(bcx, arg.id))\n                    .collect::<Vec<_>>();\n     let monomorphized_arg_types = match closure_env.kind {\n-        closure::NotClosure | closure::BoxedClosure(..) => {\n+        closure::NotClosure => {\n             monomorphized_arg_types\n         }\n \n@@ -1859,7 +1847,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     };\n \n     bcx = match closure_env.kind {\n-        closure::NotClosure | closure::BoxedClosure(..) => {\n+        closure::NotClosure => {\n             copy_args_to_allocas(bcx,\n                                  arg_scope,\n                                  &decl.inputs[],"}, {"sha": "7a6c0c50dd1ffed8223b22dc095396016fe1900f", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 319, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -10,278 +10,34 @@\n \n pub use self::ClosureKind::*;\n \n-use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n-use llvm::ValueRef;\n use middle::mem_categorization::Typer;\n use trans::adt;\n use trans::base::*;\n use trans::build::*;\n use trans::cleanup::{CleanupMethods, ScopeId};\n use trans::common::*;\n-use trans::datum::{Datum, Lvalue, rvalue_scratch_datum};\n+use trans::datum::{Datum, rvalue_scratch_datum};\n use trans::datum::{Rvalue, ByValue};\n use trans::debuginfo;\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n use trans::type_of::*;\n-use trans::type_::Type;\n-use middle::ty::{self, Ty, UnboxedClosureTyper};\n+use middle::ty::{self, UnboxedClosureTyper};\n use middle::subst::{Substs};\n use session::config::FullDebugInfo;\n-use util::ppaux::ty_to_string;\n \n use syntax::ast;\n use syntax::ast_util;\n \n-// ___Good to know (tm)__________________________________________________\n-//\n-// The layout of a closure environment in memory is\n-// roughly as follows:\n-//\n-// struct rust_opaque_box {         // see rust_internal.h\n-//   unsigned ref_count;            // obsolete (part of @T's header)\n-//   fn(void*) *drop_glue;          // destructor (for proc)\n-//   rust_opaque_box *prev;         // obsolete (part of @T's header)\n-//   rust_opaque_box *next;         // obsolete (part of @T's header)\n-//   struct closure_data {\n-//       upvar1_t upvar1;\n-//       ...\n-//       upvarN_t upvarN;\n-//    }\n-// };\n-//\n-// Note that the closure is itself a rust_opaque_box.  This is true\n-// even for ~fn and ||, because we wish to keep binary compatibility\n-// between all kinds of closures.  The allocation strategy for this\n-// closure depends on the closure type.  For a sendfn, the closure\n-// (and the referenced type descriptors) will be allocated in the\n-// exchange heap.  For a fn, the closure is allocated in the task heap\n-// and is reference counted.  For a block, the closure is allocated on\n-// the stack.\n-//\n-// ## Opaque closures and the embedded type descriptor ##\n-//\n-// One interesting part of closures is that they encapsulate the data\n-// that they close over.  So when I have a ptr to a closure, I do not\n-// know how many type descriptors it contains nor what upvars are\n-// captured within.  That means I do not know precisely how big it is\n-// nor where its fields are located.  This is called an \"opaque\n-// closure\".\n-//\n-// Typically an opaque closure suffices because we only manipulate it\n-// by ptr.  The routine Type::at_box().ptr_to() returns an appropriate\n-// type for such an opaque closure; it allows access to the box fields,\n-// but not the closure_data itself.\n-//\n-// But sometimes, such as when cloning or freeing a closure, we need\n-// to know the full information.  That is where the type descriptor\n-// that defines the closure comes in handy.  We can use its take and\n-// drop glue functions to allocate/free data as needed.\n-//\n-// ## Subtleties concerning alignment ##\n-//\n-// It is important that we be able to locate the closure data *without\n-// knowing the kind of data that is being bound*.  This can be tricky\n-// because the alignment requirements of the bound data affects the\n-// alignment requires of the closure_data struct as a whole.  However,\n-// right now this is a non-issue in any case, because the size of the\n-// rust_opaque_box header is always a multiple of 16-bytes, which is\n-// the maximum alignment requirement we ever have to worry about.\n-//\n-// The only reason alignment matters is that, in order to learn what data\n-// is bound, we would normally first load the type descriptors: but their\n-// location is ultimately depend on their content!  There is, however, a\n-// workaround.  We can load the tydesc from the rust_opaque_box, which\n-// describes the closure_data struct and has self-contained derived type\n-// descriptors, and read the alignment from there.   It's just annoying to\n-// do.  Hopefully should this ever become an issue we'll have monomorphized\n-// and type descriptors will all be a bad dream.\n-//\n-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-#[derive(Copy)]\n-pub struct EnvValue<'tcx> {\n-    action: ast::CaptureClause,\n-    datum: Datum<'tcx, Lvalue>\n-}\n-\n-impl<'tcx> EnvValue<'tcx> {\n-    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"{:?}({})\", self.action, self.datum.to_string(ccx))\n-    }\n-}\n-\n-// Given a closure ty, emits a corresponding tuple ty\n-pub fn mk_closure_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                            bound_values: &[EnvValue<'tcx>])\n-                            -> Ty<'tcx> {\n-    // determine the types of the values in the env.  Note that this\n-    // is the actual types that will be stored in the map, not the\n-    // logical types as the user sees them, so by-ref upvars must be\n-    // converted to ptrs.\n-    let bound_tys = bound_values.iter().map(|bv| {\n-        match bv.action {\n-            ast::CaptureByValue => bv.datum.ty,\n-            ast::CaptureByRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n-        }\n-    }).collect();\n-    let cdata_ty = ty::mk_tup(tcx, bound_tys);\n-    debug!(\"cdata_ty={}\", ty_to_string(tcx, cdata_ty));\n-    return cdata_ty;\n-}\n-\n-fn tuplify_box_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n-    let ptr = ty::mk_imm_ptr(tcx, tcx.types.i8);\n-    ty::mk_tup(tcx, vec!(tcx.types.uint, ty::mk_nil_ptr(tcx), ptr, ptr, t))\n-}\n-\n-pub struct ClosureResult<'blk, 'tcx: 'blk> {\n-    llbox: ValueRef,        // llvalue of ptr to closure\n-    cdata_ty: Ty<'tcx>,     // type of the closure data\n-    bcx: Block<'blk, 'tcx>  // final bcx\n-}\n-\n-// Given a block context and a list of tydescs and values to bind\n-// construct a closure out of them. If copying is true, it is a\n-// heap allocated closure that copies the upvars into environment.\n-// Otherwise, it is stack allocated and copies pointers to the upvars.\n-pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     bound_values: Vec<EnvValue<'tcx>>)\n-                                     -> ClosureResult<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::store_environment\");\n-    let ccx = bcx.ccx();\n-    let tcx = ccx.tcx();\n-\n-    // compute the type of the closure\n-    let cdata_ty = mk_closure_tys(tcx, &bound_values[]);\n-\n-    // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n-    // tuple.  This could be a ptr in uniq or a box or on stack,\n-    // whatever.\n-    let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-    let cboxptr_ty = ty::mk_ptr(tcx, ty::mt {ty:cbox_ty, mutbl:ast::MutImmutable});\n-    let llboxptr_ty = type_of(ccx, cboxptr_ty);\n-\n-    // If there are no bound values, no point in allocating anything.\n-    if bound_values.is_empty() {\n-        return ClosureResult {llbox: C_null(llboxptr_ty),\n-                              cdata_ty: cdata_ty,\n-                              bcx: bcx};\n-    }\n-\n-    // allocate closure in the heap\n-    let llbox = alloc_ty(bcx, cbox_ty, \"__closure\");\n-\n-    let llbox = PointerCast(bcx, llbox, llboxptr_ty);\n-    debug!(\"tuplify_box_ty = {}\", ty_to_string(tcx, cbox_ty));\n-\n-    // Copy expr values into boxed bindings.\n-    let mut bcx = bcx;\n-    for (i, bv) in bound_values.into_iter().enumerate() {\n-        debug!(\"Copy {} into closure\", bv.to_string(ccx));\n-\n-        if ccx.sess().asm_comments() {\n-            add_comment(bcx, &format!(\"Copy {} into closure\",\n-                                     bv.to_string(ccx))[]);\n-        }\n-\n-        let bound_data = GEPi(bcx, llbox, &[0u, abi::BOX_FIELD_BODY, i]);\n-\n-        match bv.action {\n-            ast::CaptureByValue => {\n-                bcx = bv.datum.store_to(bcx, bound_data);\n-            }\n-            ast::CaptureByRef => {\n-                Store(bcx, bv.datum.to_llref(), bound_data);\n-            }\n-        }\n-    }\n-\n-    ClosureResult { llbox: llbox, cdata_ty: cdata_ty, bcx: bcx }\n-}\n-\n-// Given a context and a list of upvars, build a closure. This just\n-// collects the upvars and packages them up for store_environment.\n-fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n-                             freevar_mode: ast::CaptureClause,\n-                             freevars: &Vec<ty::Freevar>)\n-                             -> ClosureResult<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::build_closure\");\n-\n-    // If we need to, package up the iterator body to call\n-    let bcx = bcx0;\n-\n-    // Package up the captured upvars\n-    let mut env_vals = Vec::new();\n-    for freevar in freevars.iter() {\n-        let datum = expr::trans_local_var(bcx, freevar.def);\n-        env_vals.push(EnvValue {action: freevar_mode, datum: datum});\n-    }\n-\n-    store_environment(bcx, env_vals)\n-}\n-\n-// Given an enclosing block context, a new function context, a closure type,\n-// and a list of upvars, generate code to load and populate the environment\n-// with the upvars and type descriptors.\n-fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                cdata_ty: Ty<'tcx>,\n-                                freevars: &[ty::Freevar],\n-                                store: ty::TraitStore)\n-                                -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::load_environment\");\n-\n-    // Load a pointer to the closure data, skipping over the box header:\n-    let llcdata = at_box_body(bcx, cdata_ty, bcx.fcx.llenv.unwrap());\n-\n-    // Store the pointer to closure data in an alloca for debug info because that's what the\n-    // llvm.dbg.declare intrinsic expects\n-    let env_pointer_alloca = if bcx.sess().opts.debuginfo == FullDebugInfo {\n-        let alloc = alloc_ty(bcx, ty::mk_mut_ptr(bcx.tcx(), cdata_ty), \"__debuginfo_env_ptr\");\n-        Store(bcx, llcdata, alloc);\n-        Some(alloc)\n-    } else {\n-        None\n-    };\n-\n-    // Populate the upvars from the environment\n-    let mut i = 0u;\n-    for freevar in freevars.iter() {\n-        let mut upvarptr = GEPi(bcx, llcdata, &[0u, i]);\n-        let captured_by_ref = match store {\n-            ty::RegionTraitStore(..) => {\n-                upvarptr = Load(bcx, upvarptr);\n-                true\n-            }\n-            ty::UniqTraitStore => false\n-        };\n-        let def_id = freevar.def.def_id();\n-\n-        bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvarptr);\n-        if let Some(env_pointer_alloca) = env_pointer_alloca {\n-            debuginfo::create_captured_var_metadata(\n-                bcx,\n-                def_id.node,\n-                env_pointer_alloca,\n-                i,\n-                captured_by_ref,\n-                freevar.span);\n-        }\n-\n-        i += 1u;\n-    }\n-\n-    bcx\n-}\n \n fn load_unboxed_closure_environment<'blk, 'tcx>(\n                                     bcx: Block<'blk, 'tcx>,\n                                     arg_scope_id: ScopeId,\n                                     freevar_mode: ast::CaptureClause,\n                                     freevars: &[ty::Freevar])\n                                     -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::load_environment\");\n+    let _icx = push_ctxt(\"closure::load_unboxed_closure_environment\");\n \n     // Special case for small by-value selfs.\n     let closure_id = ast_util::local_def(bcx.fcx.id);\n@@ -341,17 +97,9 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n     bcx\n }\n \n-fn fill_fn_pair(bcx: Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n-    Store(bcx, llfn, GEPi(bcx, pair, &[0u, abi::FAT_PTR_ADDR]));\n-    let llenvptr = PointerCast(bcx, llenvptr, Type::i8p(bcx.ccx()));\n-    Store(bcx, llenvptr, GEPi(bcx, pair, &[0u, abi::FAT_PTR_EXTRA]));\n-}\n-\n #[derive(PartialEq)]\n pub enum ClosureKind<'tcx> {\n     NotClosure,\n-    // See load_environment.\n-    BoxedClosure(Ty<'tcx>, ty::TraitStore),\n     // See load_unboxed_closure_environment.\n     UnboxedClosure(ast::CaptureClause)\n }\n@@ -379,77 +127,13 @@ impl<'a, 'tcx> ClosureEnv<'a, 'tcx> {\n \n         match self.kind {\n             NotClosure => bcx,\n-            BoxedClosure(cdata_ty, store) => {\n-                load_environment(bcx, cdata_ty, self.freevars, store)\n-            }\n             UnboxedClosure(freevar_mode) => {\n                 load_unboxed_closure_environment(bcx, arg_scope, freevar_mode, self.freevars)\n             }\n         }\n     }\n }\n \n-/// Translates the body of a closure expression.\n-///\n-/// - `store`\n-/// - `decl`\n-/// - `body`\n-/// - `id`: The id of the closure expression.\n-/// - `cap_clause`: information about captured variables, if any.\n-/// - `dest`: where to write the closure value, which must be a\n-///   (fn ptr, env) pair\n-pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 store: ty::TraitStore,\n-                                 decl: &ast::FnDecl,\n-                                 body: &ast::Block,\n-                                 id: ast::NodeId,\n-                                 dest: expr::Dest)\n-                                 -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::trans_expr_fn\");\n-\n-    let dest_addr = match dest {\n-        expr::SaveIn(p) => p,\n-        expr::Ignore => {\n-            return bcx; // closure construction is non-side-effecting\n-        }\n-    };\n-\n-    let ccx = bcx.ccx();\n-    let tcx = bcx.tcx();\n-    let fty = node_id_type(bcx, id);\n-    let s = tcx.map.with_path(id, |path| {\n-        mangle_internal_name_by_path_and_seq(path, \"closure\")\n-    });\n-    let llfn = decl_internal_rust_fn(ccx, fty, &s[]);\n-\n-    // set an inline hint for all closures\n-    set_inline_hint(llfn);\n-\n-    let freevar_mode = tcx.capture_mode(id);\n-    let freevars: Vec<ty::Freevar> =\n-        ty::with_freevars(tcx, id, |fv| fv.iter().map(|&fv| fv).collect());\n-\n-    let ClosureResult {\n-        llbox,\n-        cdata_ty,\n-        bcx\n-    } = build_closure(bcx, freevar_mode, &freevars);\n-\n-    trans_closure(ccx,\n-                  decl,\n-                  body,\n-                  llfn,\n-                  bcx.fcx.param_substs,\n-                  id,\n-                  &[],\n-                  ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fty)),\n-                  ty::ty_fn_abi(fty),\n-                  ClosureEnv::new(&freevars[],\n-                                  BoxedClosure(cdata_ty, store)));\n-    fill_fn_pair(bcx, dest_addr, llfn, llbox);\n-    bcx\n-}\n-\n /// Returns the LLVM function declaration for an unboxed closure, creating it\n /// if necessary. If the ID does not correspond to a closure ID, returns None.\n pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "a8a7b7243f1a9d23e5904a6380f459fd784b78d7", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -552,7 +552,6 @@ impl<'tcx> TypeMap<'tcx> {\n                                               unique_type_id: &mut String) {\n         let ty::ClosureTy { unsafety,\n                             onceness,\n-                            store,\n                             ref bounds,\n                             ref sig,\n                             abi: _ } = closure_ty;\n@@ -564,15 +563,7 @@ impl<'tcx> TypeMap<'tcx> {\n             unique_type_id.push_str(\"once \");\n         }\n \n-        match store {\n-            ty::UniqTraitStore => unique_type_id.push_str(\"~|\"),\n-            ty::RegionTraitStore(_, ast::MutMutable) => {\n-                unique_type_id.push_str(\"&mut|\")\n-            }\n-            ty::RegionTraitStore(_, ast::MutImmutable) => {\n-                unique_type_id.push_str(\"&|\")\n-            }\n-        };\n+        unique_type_id.push_str(\"|\");\n \n         let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n "}, {"sha": "da900f0a59eeb5af8fbbfac25d1dbd9dc5fee750", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -65,7 +65,6 @@ use trans::machine::{llsize_of, llsize_of_alloc};\n use trans::type_::Type;\n \n use syntax::{ast, ast_util, codemap};\n-use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n use syntax::parse::token;\n use std::rc::Rc;\n@@ -1102,17 +1101,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // closure or an older, legacy style closure. Store this\n             // into a variable to ensure the the RefCell-lock is\n             // released before we recurse.\n-            let is_unboxed_closure =\n-                bcx.tcx().unboxed_closures.borrow().contains_key(&ast_util::local_def(expr.id));\n-            if is_unboxed_closure {\n-                closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n-            } else {\n-                let expr_ty = expr_ty(bcx, expr);\n-                let store = ty::ty_closure_store(expr_ty);\n-                debug!(\"translating block function {} with type {}\",\n-                       expr_to_string(expr), expr_ty.repr(tcx));\n-                closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n-            }\n+            closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {"}, {"sha": "5710fa24925d29e0b02ff5ea6140eab142aafac2", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -227,14 +227,6 @@ impl Type {\n         Type::vec(ccx, &Type::i8(ccx))\n     }\n \n-    // The box pointed to by @T.\n-    pub fn at_box(ccx: &CrateContext, ty: Type) -> Type {\n-        Type::struct_(ccx, &[\n-            ccx.int_type(), Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to(),\n-            Type::i8p(ccx), Type::i8p(ccx), ty\n-        ], false)\n-    }\n-\n     pub fn vtable_ptr(ccx: &CrateContext) -> Type {\n         Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to()\n     }"}, {"sha": "44434c2e91b3546d616203f78cfcd02c82c4f45b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -1459,7 +1459,6 @@ pub fn ty_of_closure<'tcx>(\n     unsafety: ast::Unsafety,\n     onceness: ast::Onceness,\n     bounds: ty::ExistentialBounds<'tcx>,\n-    store: ty::TraitStore,\n     decl: &ast::FnDecl,\n     abi: abi::Abi,\n     expected_sig: Option<ty::FnSig<'tcx>>)\n@@ -1510,7 +1509,6 @@ pub fn ty_of_closure<'tcx>(\n     ty::ClosureTy {\n         unsafety: unsafety,\n         onceness: onceness,\n-        store: store,\n         bounds: bounds,\n         abi: abi,\n         sig: ty::Binder(ty::FnSig {inputs: input_tys,"}, {"sha": "4c1083c4b6332556d4e7e77f8eb223378f6c99fa", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0eb3ccba0346db9fc8a65161006dcbaabe866f9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e0eb3ccba0346db9fc8a65161006dcbaabe866f9", "patch": "@@ -96,7 +96,6 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         //\n         // FIXME(pcwalton): Refactor this API.\n         ty::region_existential_bound(ty::ReStatic),\n-        ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n \n         decl,\n         abi::RustCall,"}]}