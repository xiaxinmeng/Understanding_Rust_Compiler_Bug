{"sha": "b70ce559b8d3102c3fed3ecef8edef3038a5ceed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MGNlNTU5YjhkMzEwMmMzZmVkM2VjZWY4ZWRlZjMwMzhhNWNlZWQ=", "commit": {"author": {"name": "Matt Hooper", "email": "matthewjhooper94@gmail.com", "date": "2020-03-24T18:33:00Z"}, "committer": {"name": "Matt Hooper", "email": "matthewjhooper94@gmail.com", "date": "2020-03-24T22:22:41Z"}, "message": "Added more unit tests", "tree": {"sha": "cfbea1c486b2de6e25aebb394adb412052713f87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfbea1c486b2de6e25aebb394adb412052713f87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b70ce559b8d3102c3fed3ecef8edef3038a5ceed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b70ce559b8d3102c3fed3ecef8edef3038a5ceed", "html_url": "https://github.com/rust-lang/rust/commit/b70ce559b8d3102c3fed3ecef8edef3038a5ceed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b70ce559b8d3102c3fed3ecef8edef3038a5ceed/comments", "author": {"login": "M-J-Hooper", "id": 13765376, "node_id": "MDQ6VXNlcjEzNzY1Mzc2", "avatar_url": "https://avatars.githubusercontent.com/u/13765376?v=4", "gravatar_id": "", "url": "https://api.github.com/users/M-J-Hooper", "html_url": "https://github.com/M-J-Hooper", "followers_url": "https://api.github.com/users/M-J-Hooper/followers", "following_url": "https://api.github.com/users/M-J-Hooper/following{/other_user}", "gists_url": "https://api.github.com/users/M-J-Hooper/gists{/gist_id}", "starred_url": "https://api.github.com/users/M-J-Hooper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/M-J-Hooper/subscriptions", "organizations_url": "https://api.github.com/users/M-J-Hooper/orgs", "repos_url": "https://api.github.com/users/M-J-Hooper/repos", "events_url": "https://api.github.com/users/M-J-Hooper/events{/privacy}", "received_events_url": "https://api.github.com/users/M-J-Hooper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "M-J-Hooper", "id": 13765376, "node_id": "MDQ6VXNlcjEzNzY1Mzc2", "avatar_url": "https://avatars.githubusercontent.com/u/13765376?v=4", "gravatar_id": "", "url": "https://api.github.com/users/M-J-Hooper", "html_url": "https://github.com/M-J-Hooper", "followers_url": "https://api.github.com/users/M-J-Hooper/followers", "following_url": "https://api.github.com/users/M-J-Hooper/following{/other_user}", "gists_url": "https://api.github.com/users/M-J-Hooper/gists{/gist_id}", "starred_url": "https://api.github.com/users/M-J-Hooper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/M-J-Hooper/subscriptions", "organizations_url": "https://api.github.com/users/M-J-Hooper/orgs", "repos_url": "https://api.github.com/users/M-J-Hooper/repos", "events_url": "https://api.github.com/users/M-J-Hooper/events{/privacy}", "received_events_url": "https://api.github.com/users/M-J-Hooper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1f9a1a1c5f32f9fb311e6e91033e1811c5acc47", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1f9a1a1c5f32f9fb311e6e91033e1811c5acc47", "html_url": "https://github.com/rust-lang/rust/commit/c1f9a1a1c5f32f9fb311e6e91033e1811c5acc47"}], "stats": {"total": 235, "additions": 159, "deletions": 76}, "files": [{"sha": "2939442067fa16d3e70b63017c858ddee5824d37", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 159, "deletions": 76, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/b70ce559b8d3102c3fed3ecef8edef3038a5ceed/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b70ce559b8d3102c3fed3ecef8edef3038a5ceed/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=b70ce559b8d3102c3fed3ecef8edef3038a5ceed", "patch": "@@ -70,6 +70,45 @@ pub(crate) fn inlay_hints(\n     res\n }\n \n+fn get_chaining_hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<RootDatabase>,\n+    options: &InlayHintsOptions,\n+    expr: ast::Expr,\n+) -> Option<()> {\n+    if !options.chaining_hints {\n+        return None;\n+    }\n+\n+    let ty = sema.type_of_expr(&expr)?;\n+    let label = ty.display_truncated(sema.db, options.max_length).to_string();\n+    if ty.is_unknown() {\n+        return None;\n+    }\n+\n+    let mut tokens = expr.syntax()\n+        .siblings_with_tokens(Direction::Next)\n+        .filter_map(NodeOrToken::into_token)\n+        .filter(|t| match t.kind() {\n+            SyntaxKind::WHITESPACE if !t.text().contains('\\n') => false,\n+            SyntaxKind::COMMENT => false,\n+            _ => true,\n+        });\n+\n+    // Chaining can be defined as an expression whose next sibling tokens are newline and dot\n+    // Ignoring extra whitespace and comments\n+    let next = tokens.next()?.kind();\n+    let next_next = tokens.next()?.kind();\n+    if next == SyntaxKind::WHITESPACE && next_next == SyntaxKind::DOT { \n+        acc.push(InlayHint {\n+            range: expr.syntax().text_range(),\n+            kind: InlayKind::ChainingHint,\n+            label: label.into(),\n+        });\n+    }\n+    Some(())\n+}\n+\n fn get_param_name_hints(\n     acc: &mut Vec<InlayHint>,\n     sema: &Semantics<RootDatabase>,\n@@ -233,89 +272,13 @@ fn get_fn_signature(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<\n     }\n }\n \n-fn get_chaining_hints(\n-    acc: &mut Vec<InlayHint>,\n-    sema: &Semantics<RootDatabase>,\n-    options: &InlayHintsOptions,\n-    expr: ast::Expr,\n-) -> Option<()> {\n-    if !options.chaining_hints {\n-        return None;\n-    }\n-\n-    let ty = sema.type_of_expr(&expr)?;\n-    let label = ty.display_truncated(sema.db, options.max_length).to_string();\n-    if ty.is_unknown() {\n-        return None;\n-    }\n-\n-    let mut tokens = expr.syntax()\n-        .siblings_with_tokens(Direction::Next)\n-        .filter_map(NodeOrToken::into_token)\n-        .filter(|t| match t.kind() {\n-            SyntaxKind::WHITESPACE if !t.text().contains('\\n') => false,\n-            SyntaxKind::COMMENT => false,\n-            _ => true,\n-        });\n-\n-    // Chaining can be defined as an expression whose next sibling tokens are newline and dot\n-    // Ignoring extra whitespace and comments\n-    let next = tokens.next()?.kind();\n-    let next_next = tokens.next()?.kind();\n-    if next == SyntaxKind::WHITESPACE && next_next == SyntaxKind::DOT { \n-        acc.push(InlayHint {\n-            range: expr.syntax().text_range(),\n-            kind: InlayKind::ChainingHint,\n-            label: label.into(),\n-        });\n-    }\n-    Some(())\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::inlay_hints::InlayHintsOptions;\n     use insta::assert_debug_snapshot;\n \n     use crate::mock_analysis::single_file;\n \n-    #[test]\n-    fn generic_chaining_hints() {\n-        let (analysis, file_id) = single_file(\n-            r#\"\n-            struct A<T>(T); \n-            struct B<T>(T);\n-            struct C<T>(T);\n-            struct X<T,R>(T, R);\n-            \n-            impl<T> A<T> {\n-                fn new(t: T) -> Self { A(t) }\n-                fn into_b(self) -> B<T> { B(self.0) }\n-            }\n-            impl<T> B<T> {\n-                fn into_c(self) -> C<T> { C(self.0) }\n-            }\n-            fn test() {\n-                let c = A::new(X(42, true))\n-                    .into_b() // All the from A -> B -> C\n-                    .into_c();\n-            }\"#,\n-        );\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsOptions{ parameter_hints: false, type_hints: false, chaining_hints: true, max_length: None}).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: [416; 465),\n-                kind: ChainingHint,\n-                label: \"B<X<i32, bool>>\",\n-            },\n-            InlayHint {\n-                range: [416; 435),\n-                kind: ChainingHint,\n-                label: \"A<X<i32, bool>>\",\n-            },\n-        ]\"###);\n-    }\n-\n     #[test]\n     fn param_hints_only() {\n         let (analysis, file_id) = single_file(\n@@ -1139,4 +1102,124 @@ fn main() {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn chaining_hints_ignore_comments() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+            struct A(B);\n+            impl A { fn into_b(self) -> B { self.0 } }\n+            struct B(C)\n+            impl B { fn into_c(self) -> C { self.0 } }\n+            struct C;\n+\n+            fn main() {\n+                let c = A(B(C))\n+                    .into_b() // This is a comment\n+                    .into_c();\n+            }\"#,\n+        );\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsOptions{ parameter_hints: false, type_hints: false, chaining_hints: true, max_length: None}).unwrap(), @r###\"\n+        [\n+            InlayHint {\n+                range: [231; 268),\n+                kind: ChainingHint,\n+                label: \"B\",\n+            },\n+            InlayHint {\n+                range: [231; 238),\n+                kind: ChainingHint,\n+                label: \"A\",\n+            },\n+        ]\"###);\n+    }\n+\n+    #[test]\n+    fn chaining_hints_without_newlines() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+            struct A(B);\n+            impl A { fn into_b(self) -> B { self.0 } }\n+            struct B(C)\n+            impl B { fn into_c(self) -> C { self.0 } }\n+            struct C;\n+\n+            fn main() {\n+                let c = A(B(C)).into_b().into_c();\n+            }\"#,\n+        );\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsOptions{ parameter_hints: false, type_hints: false, chaining_hints: true, max_length: None}).unwrap(), @r###\"[]\"###);\n+    }\n+\n+    #[test]\n+    fn struct_access_chaining_hints() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+            struct A { pub b: B }\n+            struct B { pub c: C }\n+            struct C(pub bool);\n+\n+            fn main() {\n+                let x = A { b: B { c: C(true) } }\n+                    .b\n+                    .c\n+                    .0;\n+            }\"#,\n+        );\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsOptions{ parameter_hints: false, type_hints: false, chaining_hints: true, max_length: None}).unwrap(), @r###\"\n+        [\n+            InlayHint {\n+                range: [150; 221),\n+                kind: ChainingHint,\n+                label: \"C\",\n+            },\n+            InlayHint {\n+                range: [150; 198),\n+                kind: ChainingHint,\n+                label: \"B\",\n+            },\n+            InlayHint {\n+                range: [150; 175),\n+                kind: ChainingHint,\n+                label: \"A\",\n+            },\n+        ]\"###);\n+    }\n+\n+    #[test]\n+    fn generic_chaining_hints() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+            struct A<T>(T); \n+            struct B<T>(T);\n+            struct C<T>(T);\n+            struct X<T,R>(T, R);\n+            \n+            impl<T> A<T> {\n+                fn new(t: T) -> Self { A(t) }\n+                fn into_b(self) -> B<T> { B(self.0) }\n+            }\n+            impl<T> B<T> {\n+                fn into_c(self) -> C<T> { C(self.0) }\n+            }\n+            fn main() {\n+                let c = A::new(X(42, true))\n+                    .into_b()\n+                    .into_c();\n+            }\"#,\n+        );\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsOptions{ parameter_hints: false, type_hints: false, chaining_hints: true, max_length: None}).unwrap(), @r###\"\n+        [\n+            InlayHint {\n+                range: [416; 465),\n+                kind: ChainingHint,\n+                label: \"B<X<i32, bool>>\",\n+            },\n+            InlayHint {\n+                range: [416; 435),\n+                kind: ChainingHint,\n+                label: \"A<X<i32, bool>>\",\n+            },\n+        ]\"###);\n+    }\n }"}]}