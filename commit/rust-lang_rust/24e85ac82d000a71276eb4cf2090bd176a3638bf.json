{"sha": "24e85ac82d000a71276eb4cf2090bd176a3638bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZTg1YWM4MmQwMDBhNzEyNzZlYjRjZjIwOTBiZDE3NmEzNjM4YmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-01T22:46:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-01T22:46:40Z"}, "message": "auto merge of #6880 : thomaslee/rust/issue-6745, r=catamorphism\n\nThis fixes #6745, which itself relates to #4202. Slightly ham-fisted -- feel particularly funny about using the typeck phase to gather the base -> impl mapping, and the separate code paths for traits vs. \"real\" bases feels like it could be avoided -- but it seems to work.\r\n\r\nAs always, open to suggestions if there's a better way to accomplish what I'm trying to do.\r\n\r\n@catamorphism r?", "tree": {"sha": "5d647c29bf46366667c2a088c8696f7e084e5825", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d647c29bf46366667c2a088c8696f7e084e5825"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24e85ac82d000a71276eb4cf2090bd176a3638bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24e85ac82d000a71276eb4cf2090bd176a3638bf", "html_url": "https://github.com/rust-lang/rust/commit/24e85ac82d000a71276eb4cf2090bd176a3638bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24e85ac82d000a71276eb4cf2090bd176a3638bf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c35b7b5d6e31984e4db8b5b655d137eda287a811", "url": "https://api.github.com/repos/rust-lang/rust/commits/c35b7b5d6e31984e4db8b5b655d137eda287a811", "html_url": "https://github.com/rust-lang/rust/commit/c35b7b5d6e31984e4db8b5b655d137eda287a811"}, {"sha": "42466949c24c07e6d5e13a87054d066a72ea0d99", "url": "https://api.github.com/repos/rust-lang/rust/commits/42466949c24c07e6d5e13a87054d066a72ea0d99", "html_url": "https://github.com/rust-lang/rust/commit/42466949c24c07e6d5e13a87054d066a72ea0d99"}], "stats": {"total": 158, "additions": 123, "deletions": 35}, "files": [{"sha": "5fce4f2f73156def8f55b6c32e0503898010de00", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 70, "deletions": 30, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/24e85ac82d000a71276eb4cf2090bd176a3638bf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e85ac82d000a71276eb4cf2090bd176a3638bf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=24e85ac82d000a71276eb4cf2090bd176a3638bf", "patch": "@@ -374,50 +374,90 @@ fn encode_path(ecx: @EncodeContext,\n fn encode_reexported_static_method(ecx: @EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    exp: &middle::resolve::Export2,\n-                                   m: @ty::Method) {\n-    debug!(\"(encode static trait method) reexport '%s::%s'\",\n-            *exp.name, *ecx.tcx.sess.str_of(m.ident));\n+                                   method_def_id: def_id,\n+                                   method_ident: ident) {\n+    debug!(\"(encode reexported static method) %s::%s\",\n+            *exp.name, *ecx.tcx.sess.str_of(method_ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n     ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    ebml_w.wr_str(def_to_str(m.def_id));\n+    ebml_w.wr_str(def_to_str(method_def_id));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_items_data_item_reexport_name);\n-    ebml_w.wr_str(*exp.name + \"::\" + *ecx.tcx.sess.str_of(m.ident));\n+    ebml_w.wr_str(*exp.name + \"::\" + *ecx.tcx.sess.str_of(method_ident));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n \n+fn encode_reexported_static_base_methods(ecx: @EncodeContext,\n+                                         ebml_w: &mut writer::Encoder,\n+                                         exp: &middle::resolve::Export2)\n+                                         -> bool {\n+    match ecx.tcx.base_impls.find(&exp.def_id) {\n+        Some(implementations) => {\n+            for implementations.each |&base_impl| {\n+                for base_impl.methods.each |&m| {\n+                    if m.explicit_self == ast::sty_static {\n+                        encode_reexported_static_method(ecx, ebml_w, exp,\n+                                                        m.did, m.ident);\n+                    }\n+                }\n+            }\n+\n+            true\n+        }\n+        None => { false }\n+    }\n+}\n+\n+fn encode_reexported_static_trait_methods(ecx: @EncodeContext,\n+                                          ebml_w: &mut writer::Encoder,\n+                                          exp: &middle::resolve::Export2)\n+                                          -> bool {\n+    match ecx.tcx.trait_methods_cache.find(&exp.def_id) {\n+        Some(methods) => {\n+            for methods.each |&m| {\n+                if m.explicit_self == ast::sty_static {\n+                    encode_reexported_static_method(ecx, ebml_w, exp,\n+                                                    m.def_id, m.ident);\n+                }\n+            }\n+\n+            true\n+        }\n+        None => { false }\n+    }\n+}\n+\n fn encode_reexported_static_methods(ecx: @EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n                                     mod_path: &[ast_map::path_elt],\n                                     exp: &middle::resolve::Export2) {\n-    match ecx.tcx.trait_methods_cache.find(&exp.def_id) {\n-        Some(methods) => {\n-            match ecx.tcx.items.find(&exp.def_id.node) {\n-                Some(&ast_map::node_item(item, path)) => {\n-                    let original_name = ecx.tcx.sess.str_of(item.ident);\n-\n-                    //\n-                    // We don't need to reexport static methods on traits\n-                    // declared in the same module as our `pub use ...` since\n-                    // that's done when we encode the trait item.\n-                    //\n-                    // The only exception is when the reexport *changes* the\n-                    // name e.g. `pub use Foo = self::Bar` -- we have\n-                    // encoded metadata for static methods relative to Bar,\n-                    // but not yet for Foo.\n-                    //\n-                    if mod_path != *path || *exp.name != *original_name {\n-                        for methods.each |&m| {\n-                            if m.explicit_self == ast::sty_static {\n-                                encode_reexported_static_method(ecx,\n-                                                                ebml_w,\n-                                                                exp, m);\n-                            }\n-                        }\n+    match ecx.tcx.items.find(&exp.def_id.node) {\n+        Some(&ast_map::node_item(item, path)) => {\n+            let original_name = ecx.tcx.sess.str_of(item.ident);\n+\n+            //\n+            // We don't need to reexport static methods on items\n+            // declared in the same module as our `pub use ...` since\n+            // that's done when we encode the item itself.\n+            //\n+            // The only exception is when the reexport *changes* the\n+            // name e.g. `pub use Foo = self::Bar` -- we have\n+            // encoded metadata for static methods relative to Bar,\n+            // but not yet for Foo.\n+            //\n+            if mod_path != *path || *exp.name != *original_name {\n+                if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n+                    if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n+                        debug!(fmt!(\"(encode reexported static methods) %s \\\n+                                    [trait]\",\n+                                    *original_name));\n                     }\n                 }\n-                _ => {}\n+                else {\n+                    debug!(fmt!(\"(encode reexported static methods) %s [base]\",\n+                                *original_name));\n+                }\n             }\n         }\n         _ => {}"}, {"sha": "132ffd24fc62b5118cc6e0cc0e3571e565336a55", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24e85ac82d000a71276eb4cf2090bd176a3638bf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e85ac82d000a71276eb4cf2090bd176a3638bf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=24e85ac82d000a71276eb4cf2090bd176a3638bf", "patch": "@@ -307,6 +307,9 @@ struct ctxt_ {\n     // Maps a trait onto a mapping from self-ty to impl\n     trait_impls: @mut HashMap<ast::def_id, @mut HashMap<t, @Impl>>,\n \n+    // Maps a base type to its impl\n+    base_impls: @mut HashMap<ast::def_id, @mut ~[@Impl]>,\n+\n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n     used_unsafe: @mut HashSet<ast::node_id>,\n@@ -972,6 +975,7 @@ pub fn mk_ctxt(s: session::Session,\n         destructor_for_type: @mut HashMap::new(),\n         destructors: @mut HashSet::new(),\n         trait_impls: @mut HashMap::new(),\n+        base_impls:  @mut HashMap::new(),\n         used_unsafe: @mut HashSet::new(),\n         used_mut_nodes: @mut HashSet::new(),\n      }\n@@ -3700,6 +3704,21 @@ pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @Method {\n     ty::method(cx, method_def_id)\n }\n \n+\n+pub fn add_base_impl(cx: ctxt, base_def_id: def_id, implementation: @Impl) {\n+    let implementations;\n+    match cx.base_impls.find(&base_def_id) {\n+        None => {\n+            implementations = @mut ~[];\n+            cx.base_impls.insert(base_def_id, implementations);\n+        }\n+        Some(&existing) => {\n+            implementations = existing;\n+        }\n+    }\n+    implementations.push(implementation);\n+}\n+\n pub fn trait_methods(cx: ctxt, trait_did: ast::def_id) -> @~[@Method] {\n     match cx.trait_methods_cache.find(&trait_did) {\n         Some(&methods) => methods,"}, {"sha": "9d25430d80b72dc1de529a4dad5876ecc51220c4", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24e85ac82d000a71276eb4cf2090bd176a3638bf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e85ac82d000a71276eb4cf2090bd176a3638bf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=24e85ac82d000a71276eb4cf2090bd176a3638bf", "patch": "@@ -146,7 +146,7 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n                 }\n                 _ => {\n                     fail!(\"get_base_type() returned a type that wasn't an \\\n-                           enum, class, or trait\");\n+                           enum, struct, or trait\");\n                 }\n             }\n         }\n@@ -313,6 +313,7 @@ impl CoherenceChecker {\n                             implementation = existing_implementation;\n                         }\n                     }\n+\n                     self.add_inherent_method(base_type_def_id,\n                                              implementation);\n                 }\n@@ -434,6 +435,8 @@ impl CoherenceChecker {\n         }\n \n         implementation_list.push(implementation);\n+\n+        ty::add_base_impl(self.crate_context.tcx, base_def_id, implementation);\n     }\n \n     pub fn add_trait_method(&self, trait_id: def_id, implementation: @Impl) {"}, {"sha": "88e746585c923a50fc613537e1589723258345f2", "filename": "src/test/auxiliary/reexported_static_methods.rs", "status": "renamed", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/24e85ac82d000a71276eb4cf2090bd176a3638bf/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e85ac82d000a71276eb4cf2090bd176a3638bf/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs?ref=24e85ac82d000a71276eb4cf2090bd176a3638bf", "patch": "@@ -10,6 +10,8 @@\n \n pub use sub_foo::Foo;\n pub use Baz = self::Bar;\n+pub use sub_foo::Boz;\n+pub use sub_foo::Bort;\n \n pub trait Bar {\n     pub fn bar() -> Self;\n@@ -28,4 +30,24 @@ pub mod sub_foo {\n         pub fn foo() -> int { 42 }\n     }\n \n+    pub struct Boz {\n+        unused_str: ~str\n+    }\n+\n+    pub impl Boz {\n+        pub fn boz(i: int) -> bool {\n+            i > 0\n+        }\n+    }\n+\n+    pub enum Bort {\n+        Bort1,\n+        Bort2\n+    }\n+\n+    pub impl Bort {\n+        pub fn bort() -> ~str {\n+            ~\"bort()\"\n+        }\n+    }\n }", "previous_filename": "src/test/auxiliary/mod_trait_with_static_methods_lib.rs"}, {"sha": "e8e58d78e9515809b565485922ffefe4281b15c9", "filename": "src/test/run-pass/reexported-static-methods-cross-crate.rs", "status": "renamed", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24e85ac82d000a71276eb4cf2090bd176a3638bf/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e85ac82d000a71276eb4cf2090bd176a3638bf/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs?ref=24e85ac82d000a71276eb4cf2090bd176a3638bf", "patch": "@@ -9,13 +9,17 @@\n // except according to those terms.\n \n // xfail-fast\n-// aux-build:mod_trait_with_static_methods_lib.rs\n-extern mod mod_trait_with_static_methods_lib;\n+// aux-build:reexported_static_methods.rs\n+extern mod reexported_static_methods;\n \n-use mod_trait_with_static_methods_lib::Foo;\n-use mod_trait_with_static_methods_lib::Baz;\n+use reexported_static_methods::Foo;\n+use reexported_static_methods::Baz;\n+use reexported_static_methods::Boz;\n+use reexported_static_methods::Bort;\n \n pub fn main() {\n     assert_eq!(42, Foo::foo());\n     assert_eq!(84, Baz::bar());\n+    assert!(Boz::boz(1));\n+    assert_eq!(~\"bort()\", Bort::bort());\n }", "previous_filename": "src/test/run-pass/trait_with_static_methods_cross_crate.rs"}]}