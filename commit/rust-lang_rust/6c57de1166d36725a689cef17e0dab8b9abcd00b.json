{"sha": "6c57de1166d36725a689cef17e0dab8b9abcd00b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNTdkZTExNjZkMzY3MjVhNjg5Y2VmMTdlMGRhYjhiOWFiY2QwMGI=", "commit": {"author": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-08-16T01:01:14Z"}, "committer": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-08-17T16:01:04Z"}, "message": "Don't memoize seen types.\n\nThat cache is unlikely to be particularly useful within a single\ninvocation of structurally_same_type, especially compared to memoizing\nresults across _all_ invocations of that function.", "tree": {"sha": "6f583748540a24a7e6f6b9e336ca98bde6a9f63e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f583748540a24a7e6f6b9e336ca98bde6a9f63e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c57de1166d36725a689cef17e0dab8b9abcd00b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c57de1166d36725a689cef17e0dab8b9abcd00b", "html_url": "https://github.com/rust-lang/rust/commit/6c57de1166d36725a689cef17e0dab8b9abcd00b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c57de1166d36725a689cef17e0dab8b9abcd00b/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bca48ad7acbc7b7462bce58f0513c02c4e5444b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/bca48ad7acbc7b7462bce58f0513c02c4e5444b5", "html_url": "https://github.com/rust-lang/rust/commit/bca48ad7acbc7b7462bce58f0513c02c4e5444b5"}], "stats": {"total": 60, "additions": 9, "deletions": 51}, "files": [{"sha": "781ebb6716758bf05c8a75c7bb1d557a22438cc8", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 51, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6c57de1166d36725a689cef17e0dab8b9abcd00b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c57de1166d36725a689cef17e0dab8b9abcd00b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6c57de1166d36725a689cef17e0dab8b9abcd00b", "patch": "@@ -2153,62 +2153,22 @@ impl ClashingExternDeclarations {\n         b: Ty<'tcx>,\n         ckind: CItemKind,\n     ) -> bool {\n-        // In order to avoid endlessly recursing on recursive types, we maintain a \"seen\" set.\n-        // We'll need to store every combination of types we encounter anyway, so we also memoize\n-        // the result.\n-        struct SeenSet<'tcx>(FxHashMap<(Ty<'tcx>, Ty<'tcx>), Option<bool>>);\n-\n-        enum SeenSetResult {\n-            /// We've never seen this combination of types.\n-            Unseen,\n-            /// We've seen this combination of types, but are still computing the result.\n-            Computing,\n-            /// We've seen this combination of types, and have already computed the result.\n-            Computed(bool),\n-        }\n-\n-        impl<'tcx> SeenSet<'tcx> {\n-            fn new() -> Self {\n-                SeenSet(FxHashMap::default())\n-            }\n-            /// Mark (a, b) as `Computing`.\n-            fn mark_computing(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n-                self.0.insert((a, b), None);\n-            }\n-            /// Mark (a, b) as `Computed(result)`.\n-            fn mark_computed(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, result: bool) {\n-                *self.0.get_mut(&(a, b)).expect(\"Missing prior call to mark_computing\") =\n-                    Some(result);\n-            }\n-            fn get(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> SeenSetResult {\n-                match self.0.get(&(a, b)) {\n-                    None => SeenSetResult::Unseen,\n-                    Some(None) => SeenSetResult::Computing,\n-                    Some(Some(b)) => SeenSetResult::Computed(*b),\n-                }\n-            }\n-        }\n         fn structurally_same_type_impl<'tcx>(\n-            seen_types: &mut SeenSet<'tcx>,\n+            seen_types: &mut FxHashSet<(Ty<'tcx>, Ty<'tcx>)>,\n             cx: &LateContext<'tcx>,\n             a: Ty<'tcx>,\n             b: Ty<'tcx>,\n             ckind: CItemKind,\n         ) -> bool {\n             debug!(\"structurally_same_type_impl(cx, a = {:?}, b = {:?})\", a, b);\n-            match seen_types.get(a, b) {\n-                // If we've already computed the result, just return the memoized result.\n-                SeenSetResult::Computed(result) => return result,\n-                // We are already in the process of computing structural sameness for this type,\n-                // meaning we've found a cycle. The types are structurally same, then.\n-                SeenSetResult::Computing => return true,\n-                // We haven't seen this combination of types at all -- continue on to computing\n-                // their sameness.\n-                SeenSetResult::Unseen => (),\n+            if seen_types.contains(&(a, b)) {\n+                // We've encountered a cycle. There's no point going any further -- the types are\n+                // structurally the same.\n+                return true;\n             }\n-            seen_types.mark_computing(a, b);\n+            seen_types.insert((a, b));\n             let tcx = cx.tcx;\n-            let result = if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n+            if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n                 // All nominally-same types are structurally same, too.\n                 true\n             } else {\n@@ -2333,11 +2293,9 @@ impl ClashingExternDeclarations {\n                     // uninitialised memory.\n                     _ => compare_layouts(a, b),\n                 }\n-            };\n-            seen_types.mark_computed(a, b, result);\n-            result\n+            }\n         }\n-        let mut seen_types = SeenSet::new();\n+        let mut seen_types = FxHashSet::default();\n         structurally_same_type_impl(&mut seen_types, cx, a, b, ckind)\n     }\n }"}]}