{"sha": "9af374abf9d41c533afa46e62e1047097c190445", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZjM3NGFiZjlkNDFjNTMzYWZhNDZlNjJlMTA0NzA5N2MxOTA0NDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-04T03:33:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-04T03:33:44Z"}, "message": "Auto merge of #47915 - eddyb:layout-of, r=nikomatsakis\n\nrustc: prefer ParamEnvAnd and LayoutCx over tuples for LayoutOf.\n\nThis PR provides `tcx.layout_of(param_env.and(ty))` as the idiomatic replacement for the existing `(tcx, param_env).layout_of(ty)` and removes fragile (coherence-wise) layout-related tuple impls.\n\nr? @nikomatsakis", "tree": {"sha": "467cb8fef08ee4c0a969d912f2c9e3511aeec6f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/467cb8fef08ee4c0a969d912f2c9e3511aeec6f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9af374abf9d41c533afa46e62e1047097c190445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9af374abf9d41c533afa46e62e1047097c190445", "html_url": "https://github.com/rust-lang/rust/commit/9af374abf9d41c533afa46e62e1047097c190445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9af374abf9d41c533afa46e62e1047097c190445/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d292b793ade0c1c9098fb32586033d79f6e9969", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d292b793ade0c1c9098fb32586033d79f6e9969", "html_url": "https://github.com/rust-lang/rust/commit/3d292b793ade0c1c9098fb32586033d79f6e9969"}, {"sha": "9c3dc7e8721c03e1e033895f327ff71f8fd400b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c3dc7e8721c03e1e033895f327ff71f8fd400b4", "html_url": "https://github.com/rust-lang/rust/commit/9c3dc7e8721c03e1e033895f327ff71f8fd400b4"}], "stats": {"total": 191, "additions": 107, "deletions": 84}, "files": [{"sha": "929d5e7ec62bb055274509b9618daf70727fec9d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9af374abf9d41c533afa46e62e1047097c190445", "patch": "@@ -631,7 +631,7 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a LateContext<'a, 'tcx> {\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        (self.tcx, self.param_env.reveal_all()).layout_of(ty)\n+        self.tcx.layout_of(self.param_env.and(ty))\n     }\n }\n "}, {"sha": "63b91ff110161f6c7d375071a14bf6be8c0d55c9", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 99, "deletions": 72, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9af374abf9d41c533afa46e62e1047097c190445", "patch": "@@ -895,7 +895,8 @@ fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     tcx.layout_depth.set(depth+1);\n-    let layout = LayoutDetails::compute_uncached(tcx, param_env, ty);\n+    let cx = LayoutCx { tcx, param_env };\n+    let layout = cx.layout_raw_uncached(ty);\n     tcx.layout_depth.set(depth);\n \n     layout\n@@ -908,13 +909,18 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n     };\n }\n \n-impl<'a, 'tcx> LayoutDetails {\n-    fn compute_uncached(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        param_env: ty::ParamEnv<'tcx>,\n-                        ty: Ty<'tcx>)\n-                        -> Result<&'tcx Self, LayoutError<'tcx>> {\n-        let cx = (tcx, param_env);\n-        let dl = cx.data_layout();\n+#[derive(Copy, Clone)]\n+pub struct LayoutCx<'tcx, C> {\n+    pub tcx: C,\n+    pub param_env: ty::ParamEnv<'tcx>\n+}\n+\n+impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n+    fn layout_raw_uncached(self, ty: Ty<'tcx>)\n+                           -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n+        let tcx = self.tcx;\n+        let param_env = self.param_env;\n+        let dl = self.data_layout();\n         let scalar_unit = |value: Primitive| {\n             let bits = value.size(dl).bits();\n             assert!(bits <= 128);\n@@ -924,7 +930,7 @@ impl<'a, 'tcx> LayoutDetails {\n             }\n         };\n         let scalar = |value: Primitive| {\n-            tcx.intern_layout(LayoutDetails::scalar(cx, scalar_unit(value)))\n+            tcx.intern_layout(LayoutDetails::scalar(self, scalar_unit(value)))\n         };\n         let scalar_pair = |a: Scalar, b: Scalar| {\n             let align = a.value.align(dl).max(b.value.align(dl)).max(dl.aggregate_align);\n@@ -1158,13 +1164,13 @@ impl<'a, 'tcx> LayoutDetails {\n         Ok(match ty.sty {\n             // Basic scalars.\n             ty::TyBool => {\n-                tcx.intern_layout(LayoutDetails::scalar(cx, Scalar {\n+                tcx.intern_layout(LayoutDetails::scalar(self, Scalar {\n                     value: Int(I8, false),\n                     valid_range: 0..=1\n                 }))\n             }\n             ty::TyChar => {\n-                tcx.intern_layout(LayoutDetails::scalar(cx, Scalar {\n+                tcx.intern_layout(LayoutDetails::scalar(self, Scalar {\n                     value: Int(I32, false),\n                     valid_range: 0..=0x10FFFF\n                 }))\n@@ -1180,7 +1186,7 @@ impl<'a, 'tcx> LayoutDetails {\n             ty::TyFnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n                 ptr.valid_range.start = 1;\n-                tcx.intern_layout(LayoutDetails::scalar(cx, ptr))\n+                tcx.intern_layout(LayoutDetails::scalar(self, ptr))\n             }\n \n             // The never type.\n@@ -1198,13 +1204,13 @@ impl<'a, 'tcx> LayoutDetails {\n \n                 let pointee = tcx.normalize_associated_type_in_env(&pointee, param_env);\n                 if pointee.is_sized(tcx, param_env, DUMMY_SP) {\n-                    return Ok(tcx.intern_layout(LayoutDetails::scalar(cx, data_ptr)));\n+                    return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n                 }\n \n                 let unsized_part = tcx.struct_tail(pointee);\n                 let metadata = match unsized_part.sty {\n                     ty::TyForeign(..) => {\n-                        return Ok(tcx.intern_layout(LayoutDetails::scalar(cx, data_ptr)));\n+                        return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n                     }\n                     ty::TySlice(_) | ty::TyStr => {\n                         scalar_unit(Int(dl.ptr_sized_integer(), false))\n@@ -1230,7 +1236,7 @@ impl<'a, 'tcx> LayoutDetails {\n                     }\n                 }\n \n-                let element = cx.layout_of(element)?;\n+                let element = self.layout_of(element)?;\n                 let count = count.val.to_const_int().unwrap().to_u64().unwrap();\n                 let size = element.size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n@@ -1247,7 +1253,7 @@ impl<'a, 'tcx> LayoutDetails {\n                 })\n             }\n             ty::TySlice(element) => {\n-                let element = cx.layout_of(element)?;\n+                let element = self.layout_of(element)?;\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: 0 },\n                     fields: FieldPlacement::Array {\n@@ -1289,14 +1295,14 @@ impl<'a, 'tcx> LayoutDetails {\n             // Tuples, generators and closures.\n             ty::TyGenerator(def_id, ref substs, _) => {\n                 let tys = substs.field_tys(def_id, tcx);\n-                univariant(&tys.map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                univariant(&tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n                     StructKind::AlwaysSized)?\n             }\n \n             ty::TyClosure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n-                univariant(&tys.map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                univariant(&tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n                     StructKind::AlwaysSized)?\n             }\n@@ -1308,13 +1314,13 @@ impl<'a, 'tcx> LayoutDetails {\n                     StructKind::MaybeUnsized\n                 };\n \n-                univariant(&tys.iter().map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                univariant(&tys.iter().map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(), kind)?\n             }\n \n             // SIMD vector types.\n             ty::TyAdt(def, ..) if def.repr.simd() => {\n-                let element = cx.layout_of(ty.simd_type(tcx))?;\n+                let element = self.layout_of(ty.simd_type(tcx))?;\n                 let count = ty.simd_size(tcx) as u64;\n                 assert!(count > 0);\n                 let scalar = match element.abi {\n@@ -1350,7 +1356,7 @@ impl<'a, 'tcx> LayoutDetails {\n                 // Cache the field layouts.\n                 let variants = def.variants.iter().map(|v| {\n                     v.fields.iter().map(|field| {\n-                        cx.layout_of(field.ty(tcx, substs))\n+                        self.layout_of(field.ty(tcx, substs))\n                     }).collect::<Result<Vec<_>, _>>()\n                 }).collect::<Result<Vec<_>, _>>()?;\n \n@@ -1430,7 +1436,7 @@ impl<'a, 'tcx> LayoutDetails {\n                     let mut st = univariant_uninterned(&variants[v], &def.repr, kind)?;\n                     st.variants = Variants::Single { index: v };\n                     // Exclude 0 from the range of a newtype ABI NonZero<T>.\n-                    if Some(def.did) == cx.tcx().lang_items().non_zero() {\n+                    if Some(def.did) == self.tcx.lang_items().non_zero() {\n                         match st.abi {\n                             Abi::Scalar(ref mut scalar) |\n                             Abi::ScalarPair(ref mut scalar, _) => {\n@@ -1482,7 +1488,7 @@ impl<'a, 'tcx> LayoutDetails {\n                         let count = (niche_variants.end - niche_variants.start + 1) as u128;\n                         for (field_index, field) in variants[i].iter().enumerate() {\n                             let (offset, niche, niche_start) =\n-                                match field.find_niche(cx, count)? {\n+                                match field.find_niche(self, count)? {\n                                     Some(niche) => niche,\n                                     None => continue\n                                 };\n@@ -1687,56 +1693,49 @@ impl<'a, 'tcx> LayoutDetails {\n     /// This is invoked by the `layout_raw` query to record the final\n     /// layout of each type.\n     #[inline]\n-    fn record_layout_for_printing(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  param_env: ty::ParamEnv<'tcx>,\n-                                  layout: TyLayout<'tcx>) {\n+    fn record_layout_for_printing(self, layout: TyLayout<'tcx>) {\n         // If we are running with `-Zprint-type-sizes`, record layouts for\n         // dumping later. Ignore layouts that are done with non-empty\n         // environments or non-monomorphic layouts, as the user only wants\n         // to see the stuff resulting from the final trans session.\n         if\n-            !tcx.sess.opts.debugging_opts.print_type_sizes ||\n-            ty.has_param_types() ||\n-            ty.has_self_ty() ||\n-            !param_env.caller_bounds.is_empty()\n+            !self.tcx.sess.opts.debugging_opts.print_type_sizes ||\n+            layout.ty.has_param_types() ||\n+            layout.ty.has_self_ty() ||\n+            !self.param_env.caller_bounds.is_empty()\n         {\n             return;\n         }\n \n-        Self::record_layout_for_printing_outlined(tcx, ty, param_env, layout)\n+        self.record_layout_for_printing_outlined(layout)\n     }\n \n-    fn record_layout_for_printing_outlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           ty: Ty<'tcx>,\n-                                           param_env: ty::ParamEnv<'tcx>,\n-                                           layout: TyLayout<'tcx>) {\n-        let cx = (tcx, param_env);\n+    fn record_layout_for_printing_outlined(self, layout: TyLayout<'tcx>) {\n         // (delay format until we actually need it)\n         let record = |kind, opt_discr_size, variants| {\n-            let type_desc = format!(\"{:?}\", ty);\n-            tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n-                                                              type_desc,\n-                                                              layout.align,\n-                                                              layout.size,\n-                                                              opt_discr_size,\n-                                                              variants);\n+            let type_desc = format!(\"{:?}\", layout.ty);\n+            self.tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n+                                                                   type_desc,\n+                                                                   layout.align,\n+                                                                   layout.size,\n+                                                                   opt_discr_size,\n+                                                                   variants);\n         };\n \n-        let adt_def = match ty.sty {\n+        let adt_def = match layout.ty.sty {\n             ty::TyAdt(ref adt_def, _) => {\n-                debug!(\"print-type-size t: `{:?}` process adt\", ty);\n+                debug!(\"print-type-size t: `{:?}` process adt\", layout.ty);\n                 adt_def\n             }\n \n             ty::TyClosure(..) => {\n-                debug!(\"print-type-size t: `{:?}` record closure\", ty);\n+                debug!(\"print-type-size t: `{:?}` record closure\", layout.ty);\n                 record(DataTypeKind::Closure, None, vec![]);\n                 return;\n             }\n \n             _ => {\n-                debug!(\"print-type-size t: `{:?}` skip non-nominal\", ty);\n+                debug!(\"print-type-size t: `{:?}` skip non-nominal\", layout.ty);\n                 return;\n             }\n         };\n@@ -1748,7 +1747,7 @@ impl<'a, 'tcx> LayoutDetails {\n                                   layout: TyLayout<'tcx>| {\n             let mut min_size = Size::from_bytes(0);\n             let field_info: Vec<_> = flds.iter().enumerate().map(|(i, &name)| {\n-                match layout.field(cx, i) {\n+                match layout.field(self, i) {\n                     Err(err) => {\n                         bug!(\"no layout found for field {}: `{:?}`\", name, err);\n                     }\n@@ -1808,18 +1807,18 @@ impl<'a, 'tcx> LayoutDetails {\n             Variants::NicheFilling { .. } |\n             Variants::Tagged { .. } => {\n                 debug!(\"print-type-size `{:#?}` adt general variants def {}\",\n-                       ty, adt_def.variants.len());\n+                       layout.ty, adt_def.variants.len());\n                 let variant_infos: Vec<_> =\n                     adt_def.variants.iter().enumerate().map(|(i, variant_def)| {\n                         let fields: Vec<_> =\n                             variant_def.fields.iter().map(|f| f.name).collect();\n                         build_variant_info(Some(variant_def.name),\n                                             &fields,\n-                                            layout.for_variant(cx, i))\n+                                            layout.for_variant(self, i))\n                     })\n                     .collect();\n                 record(adt_kind.into(), match layout.variants {\n-                    Variants::Tagged { ref discr, .. } => Some(discr.value.size(tcx)),\n+                    Variants::Tagged { ref discr, .. } => Some(discr.value.size(self)),\n                     _ => None\n                 }, variant_infos);\n             }\n@@ -1855,7 +1854,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n         assert!(!ty.has_infer_types());\n \n         // First try computing a static layout.\n-        let err = match (tcx, param_env).layout_of(ty) {\n+        let err = match tcx.layout_of(param_env.and(ty)) {\n             Ok(layout) => {\n                 return Ok(SizeSkeleton::Known(layout.size));\n             }\n@@ -2001,15 +2000,15 @@ impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, T: Copy> HasDataLayout for (TyCtxt<'a, 'gcx, 'tcx>, T) {\n+impl<'tcx, T: HasDataLayout> HasDataLayout for LayoutCx<'tcx, T> {\n     fn data_layout(&self) -> &TargetDataLayout {\n-        self.0.data_layout()\n+        self.tcx.data_layout()\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, T: Copy> HasTyCtxt<'gcx> for (TyCtxt<'a, 'gcx, 'tcx>, T) {\n+impl<'gcx, 'tcx, T: HasTyCtxt<'gcx>> HasTyCtxt<'gcx> for LayoutCx<'tcx, T> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n-        self.0.tcx()\n+        self.tcx.tcx()\n     }\n }\n \n@@ -2042,17 +2041,15 @@ pub trait LayoutOf<T> {\n     fn layout_of(self, ty: T) -> Self::TyLayout;\n }\n \n-impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (TyCtxt<'a, 'tcx, 'tcx>, ty::ParamEnv<'tcx>) {\n+impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n-    #[inline]\n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        let (tcx, param_env) = self;\n-\n-        let ty = tcx.normalize_associated_type_in_env(&ty, param_env.reveal_all());\n-        let details = tcx.layout_raw(param_env.reveal_all().and(ty))?;\n+        let param_env = self.param_env.reveal_all();\n+        let ty = self.tcx.normalize_associated_type_in_env(&ty, param_env);\n+        let details = self.tcx.layout_raw(param_env.and(ty))?;\n         let layout = TyLayout {\n             ty,\n             details\n@@ -2064,24 +2061,21 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (TyCtxt<'a, 'tcx, 'tcx>, ty::ParamEnv<'tcx\n         // completed, to avoid problems around recursive structures\n         // and the like. (Admitedly, I wasn't able to reproduce a problem\n         // here, but it seems like the right thing to do. -nmatsakis)\n-        LayoutDetails::record_layout_for_printing(tcx, ty, param_env, layout);\n+        self.record_layout_for_printing(layout);\n \n         Ok(layout)\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>,\n-                                       ty::ParamEnv<'tcx>) {\n+impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for LayoutCx<'tcx, ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>> {\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n-    #[inline]\n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        let (tcx_at, param_env) = self;\n-\n-        let ty = tcx_at.tcx.normalize_associated_type_in_env(&ty, param_env.reveal_all());\n-        let details = tcx_at.layout_raw(param_env.reveal_all().and(ty))?;\n+        let param_env = self.param_env.reveal_all();\n+        let ty = self.tcx.normalize_associated_type_in_env(&ty, param_env.reveal_all());\n+        let details = self.tcx.layout_raw(param_env.reveal_all().and(ty))?;\n         let layout = TyLayout {\n             ty,\n             details\n@@ -2093,12 +2087,45 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>,\n         // completed, to avoid problems around recursive structures\n         // and the like. (Admitedly, I wasn't able to reproduce a problem\n         // here, but it seems like the right thing to do. -nmatsakis)\n-        LayoutDetails::record_layout_for_printing(tcx_at.tcx, ty, param_env, layout);\n+        let cx = LayoutCx {\n+            tcx: *self.tcx,\n+            param_env: self.param_env\n+        };\n+        cx.record_layout_for_printing(layout);\n \n         Ok(layout)\n     }\n }\n \n+// Helper (inherent) `layout_of` methods to avoid pushing `LayoutCx` to users.\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+    /// Computes the layout of a type. Note that this implicitly\n+    /// executes in \"reveal all\" mode.\n+    #[inline]\n+    pub fn layout_of(self, param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                     -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n+        let cx = LayoutCx {\n+            tcx: self,\n+            param_env: param_env_and_ty.param_env\n+        };\n+        cx.layout_of(param_env_and_ty.value)\n+    }\n+}\n+\n+impl<'a, 'tcx> ty::maps::TyCtxtAt<'a, 'tcx, 'tcx> {\n+    /// Computes the layout of a type. Note that this implicitly\n+    /// executes in \"reveal all\" mode.\n+    #[inline]\n+    pub fn layout_of(self, param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                     -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n+        let cx = LayoutCx {\n+            tcx: self,\n+            param_env: param_env_and_ty.param_env\n+        };\n+        cx.layout_of(param_env_and_ty.value)\n+    }\n+}\n+\n impl<'a, 'tcx> TyLayout<'tcx> {\n     pub fn for_variant<C>(&self, cx: C, variant_index: usize) -> Self\n         where C: LayoutOf<Ty<'tcx>> + HasTyCtxt<'tcx>,"}, {"sha": "1d2813e4f6704fac35e5f489e844c6fd32221f72", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=9af374abf9d41c533afa46e62e1047097c190445", "patch": "@@ -17,7 +17,6 @@ use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::LayoutOf;\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::{Substs, Subst};\n use rustc::util::common::ErrorReported;\n@@ -313,7 +312,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           if tcx.fn_sig(def_id).abi() == Abi::RustIntrinsic {\n             let layout_of = |ty: Ty<'tcx>| {\n                 let ty = tcx.erase_regions(&ty);\n-                (tcx.at(e.span), cx.param_env).layout_of(ty).map_err(|err| {\n+                tcx.at(e.span).layout_of(cx.param_env.and(ty)).map_err(|err| {\n                     ConstEvalErr { span: e.span, kind: LayoutError(err) }\n                 })\n             };"}, {"sha": "e7e4119b9999bee72eb0558cfe216057e8e9e176", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9af374abf9d41c533afa46e62e1047097c190445", "patch": "@@ -437,8 +437,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n                             // PhantomData -- skip checking all ZST fields\n                             if def.repr.transparent() {\n-                                let is_zst = (cx, cx.param_env(field.did))\n-                                    .layout_of(field_ty)\n+                                let is_zst = cx\n+                                    .layout_of(cx.param_env(field.did).and(field_ty))\n                                     .map(|layout| layout.is_zst())\n                                     .unwrap_or(false);\n                                 if is_zst {"}, {"sha": "02fcb69fef5acff1889cd234cd77650d6603cfd9", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=9af374abf9d41c533afa46e62e1047097c190445", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> LayoutOf<Ty<'tcx>> for &'a EvalContext<'a, 'tcx\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        (self.tcx, self.param_env).layout_of(ty)\n+        self.tcx.layout_of(self.param_env.and(ty))\n             .map_err(|layout| EvalErrorKind::Layout(layout).into())\n     }\n }"}, {"sha": "ceea97e3ed3b0f1276757873ff053c99e2b295bf", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=9af374abf9d41c533afa46e62e1047097c190445", "patch": "@@ -19,7 +19,6 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::*;\n use rustc::mir::visit::*;\n use rustc::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::layout::LayoutOf;\n use rustc::ty::subst::{Subst,Substs};\n \n use std::collections::VecDeque;\n@@ -655,7 +654,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_env: ty::ParamEnv<'tcx>,\n                           ty: Ty<'tcx>) -> Option<u64> {\n-    (tcx, param_env).layout_of(ty).ok().map(|layout| layout.size.bytes())\n+    tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())\n }\n \n fn subst_and_normalize<'a, 'tcx: 'a>("}, {"sha": "a285e5f263ab7037b3f0df4045203f6a89ab639b", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=9af374abf9d41c533afa46e62e1047097c190445", "patch": "@@ -464,8 +464,7 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CodegenCx<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        (self.tcx, ty::ParamEnv::empty(traits::Reveal::All))\n-            .layout_of(ty)\n+        self.tcx.layout_of(ty::ParamEnv::empty(traits::Reveal::All).and(ty))\n             .unwrap_or_else(|e| match e {\n                 LayoutError::SizeOverflow(_) => self.sess().fatal(&e.to_string()),\n                 _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)"}, {"sha": "363d4a9dc0cd3eb5ff388df588b28a9fcba6b4d5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af374abf9d41c533afa46e62e1047097c190445/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9af374abf9d41c533afa46e62e1047097c190445", "patch": "@@ -100,7 +100,6 @@ use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n-use rustc::ty::layout::LayoutOf;\n use errors::{DiagnosticBuilder, DiagnosticId};\n \n use require_c_abi_if_variadic;\n@@ -1553,7 +1552,7 @@ fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: De\n     let field_infos: Vec<_> = adt.non_enum_variant().fields.iter().map(|field| {\n         let ty = field.ty(tcx, Substs::identity_for_item(tcx, field.did));\n         let param_env = tcx.param_env(field.did);\n-        let layout = (tcx, param_env).layout_of(ty);\n+        let layout = tcx.layout_of(param_env.and(ty));\n         // We are currently checking the type this field came from, so it must be local\n         let span = tcx.hir.span_if_local(field.did).unwrap();\n         let zst = layout.map(|layout| layout.is_zst()).unwrap_or(false);"}]}