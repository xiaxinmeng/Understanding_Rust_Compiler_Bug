{"sha": "740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MGZiMGNiYWEwYTVmZDE3NzBiMjU2ZWRmNzFkMmM0NTg3YmZmOGY=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-01T15:01:24Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-12T11:33:16Z"}, "message": "Use IndexVec instead of `usize` in librustc", "tree": {"sha": "da3eaf1f657cd0d88b5c7bbd408fa67ccdb59626", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da3eaf1f657cd0d88b5c7bbd408fa67ccdb59626"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "html_url": "https://github.com/rust-lang/rust/commit/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19ae2b940c03750adb3594ff4699c72af452c149", "url": "https://api.github.com/repos/rust-lang/rust/commits/19ae2b940c03750adb3594ff4699c72af452c149", "html_url": "https://github.com/rust-lang/rust/commit/19ae2b940c03750adb3594ff4699c72af452c149"}], "stats": {"total": 176, "additions": 108, "deletions": 68}, "files": [{"sha": "d80aa902c8b12f6bacaf15d2f9c3c14465a95b65", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -2400,6 +2400,7 @@ dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n ]\n "}, {"sha": "d2be0e4dcb9b9cef74b204431ba00b4df0e17a83", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -11,9 +11,10 @@\n use hir::def::Def;\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n-use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n+use ty::layout::{LayoutError, Pointer, SizeSkeleton, VariantIdx};\n \n use rustc_target::spec::abi::Abi::RustIntrinsic;\n+use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir;\n@@ -48,10 +49,13 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if def.variants.len() == 2 && !def.repr.c() && def.repr.int.is_none() {\n         let data_idx;\n \n-        if def.variants[0].fields.is_empty() {\n-            data_idx = 1;\n-        } else if def.variants[1].fields.is_empty() {\n-            data_idx = 0;\n+        let one = VariantIdx::new(1);\n+        let zero = VariantIdx::new(0);\n+\n+        if def.variants[zero].fields.is_empty() {\n+            data_idx = one;\n+        } else if def.variants[one].fields.is_empty() {\n+            data_idx = zero;\n         } else {\n             return ty;\n         }"}, {"sha": "59ef8fa14484b6837876aa25b56323df03e4e6f9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -76,6 +76,7 @@ use hir::def::{Def, CtorKind};\n use ty::adjustment;\n use ty::{self, Ty, TyCtxt};\n use ty::fold::TypeFoldable;\n+use ty::layout::VariantIdx;\n \n use hir::{MutImmutable, MutMutable, PatKind};\n use hir::pat_util::EnumerateAndAdjustIterator;\n@@ -87,6 +88,7 @@ use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::indexed_vec::Idx;\n use std::rc::Rc;\n use util::nodemap::ItemLocalSet;\n \n@@ -227,7 +229,7 @@ impl<'tcx> cmt_<'tcx> {\n             }\n             _ => {\n                 assert_eq!(adt_def.variants.len(), 1);\n-                &adt_def.variants[0]\n+                &adt_def.variants[VariantIdx::new(0)]\n             }\n         };\n         Some((adt_def, &variant_def.fields[field_index]))"}, {"sha": "8a0306ab346f6d31ba216ec5d5450dcbfa750daa", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -40,6 +40,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::subst::{CanonicalUserSubsts, Subst, Substs};\n use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n+use ty::layout::VariantIdx;\n use util::ppaux;\n \n pub use mir::interpret::AssertMessage;\n@@ -1939,7 +1940,7 @@ pub enum ProjectionElem<'tcx, V, T> {\n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n     /// this for ADTs with more than one variant. It may be better to\n     /// just introduce it always, or always for enums.\n-    Downcast(&'tcx AdtDef, u32),\n+    Downcast(&'tcx AdtDef, VariantIdx),\n }\n \n /// Alias for projections as they appear in places, where the base is a place\n@@ -1974,8 +1975,8 @@ impl<'tcx> Place<'tcx> {\n         self.elem(ProjectionElem::Deref)\n     }\n \n-    pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: usize) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Downcast(adt_def, variant_index as u32))\n+    pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Place<'tcx> {\n+        self.elem(ProjectionElem::Downcast(adt_def, variant_index))\n     }\n \n     pub fn index(self, index: Local) -> Place<'tcx> {\n@@ -2026,7 +2027,7 @@ impl<'tcx> Debug for Place<'tcx> {\n             Promoted(ref promoted) => write!(fmt, \"({:?}: {:?})\", promoted.0, promoted.1),\n             Projection(ref data) => match data.elem {\n                 ProjectionElem::Downcast(ref adt_def, index) => {\n-                    write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index as usize].name)\n+                    write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].name)\n                 }\n                 ProjectionElem::Deref => write!(fmt, \"(*{:?})\", data.base),\n                 ProjectionElem::Field(field, ty) => {\n@@ -2216,7 +2217,7 @@ pub enum AggregateKind<'tcx> {\n     /// active field index would identity the field `c`\n     Adt(\n         &'tcx AdtDef,\n-        usize,\n+        VariantIdx,\n         &'tcx Substs<'tcx>,\n         Option<UserTypeAnnotation<'tcx>>,\n         Option<usize>,"}, {"sha": "baa88dba459156b49fb5aae9b7efdf054817c0f1", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -16,6 +16,7 @@\n use mir::*;\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, Ty, TyCtxt};\n+use ty::layout::VariantIdx;\n use hir;\n use ty::util::IntTypeExt;\n \n@@ -27,7 +28,7 @@ pub enum PlaceTy<'tcx> {\n     /// Downcast to a particular variant of an enum.\n     Downcast { adt_def: &'tcx AdtDef,\n                substs: &'tcx Substs<'tcx>,\n-               variant_index: u32 },\n+               variant_index: VariantIdx },\n }\n \n static_assert!(PLACE_TY_IS_3_PTRS_LARGE:\n@@ -58,11 +59,11 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn field_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n     {\n         // Pass `0` here so it can be used as a \"default\" variant_index in first arm below\n-        let answer = match (self, 0) {\n+        let answer = match (self, VariantIdx::new(0)) {\n             (PlaceTy::Ty {\n                 ty: &ty::TyS { sty: ty::TyKind::Adt(adt_def, substs), .. } }, variant_index) |\n             (PlaceTy::Downcast { adt_def, substs, variant_index }, _) => {\n-                let variant_def = &adt_def.variants[variant_index as usize];\n+                let variant_def = &adt_def.variants[variant_index];\n                 let field_def = &variant_def.fields[f.index()];\n                 field_def.ty(tcx, substs)\n             }\n@@ -138,7 +139,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                 match self.to_ty(tcx).sty {\n                     ty::Adt(adt_def, substs) => {\n                         assert!(adt_def.is_enum());\n-                        assert!(index < adt_def.variants.len() as u32);\n+                        assert!(index.as_usize() < adt_def.variants.len());\n                         assert_eq!(adt_def, adt_def1);\n                         PlaceTy::Downcast { adt_def,\n                                             substs,"}, {"sha": "a86a56a45cd646bc56832ef21023b86d55aac616", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -45,7 +45,7 @@ use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TyKind::*;\n use ty::GenericParamDefKind;\n-use ty::layout::{LayoutDetails, TargetDataLayout};\n+use ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n use ty::query;\n use ty::steal::Steal;\n use ty::BindingMode;\n@@ -1009,7 +1009,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn alloc_adt_def(self,\n                          did: DefId,\n                          kind: AdtKind,\n-                         variants: Vec<ty::VariantDef>,\n+                         variants: IndexVec<VariantIdx, ty::VariantDef>,\n                          repr: ReprOptions)\n                          -> &'gcx ty::AdtDef {\n         let def = ty::AdtDef::new(self, did, kind, variants, repr);"}, {"sha": "877bd5a82e6a045441dfc1b002ddc5c7495a5d24", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 45, "deletions": 26, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -23,6 +23,7 @@ use std::mem;\n use std::ops::Bound;\n \n use ich::StableHashingContext;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n@@ -229,7 +230,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             let b_offset = a.value.size(dl).abi_align(b.value.align(dl));\n             let size = (b_offset + b.value.size(dl)).abi_align(align);\n             LayoutDetails {\n-                variants: Variants::Single { index: 0 },\n+                variants: Variants::Single { index: VariantIdx::new(0) },\n                 fields: FieldPlacement::Arbitrary {\n                     offsets: vec![Size::ZERO, b_offset],\n                     memory_index: vec![0, 1]\n@@ -454,7 +455,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             Ok(LayoutDetails {\n-                variants: Variants::Single { index: 0 },\n+                variants: Variants::Single { index: VariantIdx::new(0) },\n                 fields: FieldPlacement::Arbitrary {\n                     offsets,\n                     memory_index\n@@ -499,7 +500,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             // The never type.\n             ty::Never => {\n                 tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Single { index: 0 },\n+                    variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Union(0),\n                     abi: Abi::Uninhabited,\n                     align: dl.i8_align,\n@@ -555,7 +556,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n \n                 tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Single { index: 0 },\n+                    variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count\n@@ -568,7 +569,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             ty::Slice(element) => {\n                 let element = self.layout_of(element)?;\n                 tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Single { index: 0 },\n+                    variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count: 0\n@@ -580,7 +581,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n             ty::Str => {\n                 tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Single { index: 0 },\n+                    variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: Size::from_bytes(1),\n                         count: 0\n@@ -650,7 +651,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let size = size.abi_align(align);\n \n                 tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Single { index: 0 },\n+                    variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count\n@@ -671,7 +672,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     v.fields.iter().map(|field| {\n                         self.layout_of(field.ty(tcx, substs))\n                     }).collect::<Result<Vec<_>, _>>()\n-                }).collect::<Result<Vec<_>, _>>()?;\n+                }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                 if def.is_union() {\n                     let packed = def.repr.packed();\n@@ -697,7 +698,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n \n                     let mut size = Size::ZERO;\n-                    for field in &variants[0] {\n+                    let index = VariantIdx::new(0);\n+                    for field in &variants[index] {\n                         assert!(!field.is_unsized());\n \n                         if packed {\n@@ -710,8 +712,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n \n                     return Ok(tcx.intern_layout(LayoutDetails {\n-                        variants: Variants::Single { index: 0 },\n-                        fields: FieldPlacement::Union(variants[0].len()),\n+                        variants: Variants::Single { index },\n+                        fields: FieldPlacement::Union(variants[index].len()),\n                         abi: Abi::Aggregate { sized: true },\n                         align,\n                         size: size.abi_align(align)\n@@ -729,8 +731,12 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     uninhabited && is_zst\n                 };\n                 let (present_first, present_second) = {\n-                    let mut present_variants = (0..variants.len()).filter(|&v| {\n-                        !absent(&variants[v])\n+                    let mut present_variants = variants.iter_enumerated().filter_map(|(i, v)| {\n+                        if absent(v) {\n+                            None\n+                        } else {\n+                            Some(i)\n+                        }\n                     });\n                     (present_variants.next(), present_variants.next())\n                 };\n@@ -792,16 +798,16 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 // The current code for niche-filling relies on variant indices\n                 // instead of actual discriminants, so dataful enums with\n                 // explicit discriminants (RFC #2363) would misbehave.\n-                let no_explicit_discriminants = def.variants.iter().enumerate()\n-                    .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i));\n+                let no_explicit_discriminants = def.variants.iter_enumerated()\n+                    .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i.as_u32()));\n \n                 // Niche-filling enum optimization.\n                 if !def.repr.inhibit_enum_layout_opt() && no_explicit_discriminants {\n                     let mut dataful_variant = None;\n-                    let mut niche_variants = usize::max_value()..=0;\n+                    let mut niche_variants = VariantIdx::MAX..=VariantIdx::new(0);\n \n                     // Find one non-ZST variant.\n-                    'variants: for (v, fields) in variants.iter().enumerate() {\n+                    'variants: for (v, fields) in variants.iter_enumerated() {\n                         if absent(fields) {\n                             continue 'variants;\n                         }\n@@ -824,7 +830,9 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n \n                     if let Some(i) = dataful_variant {\n-                        let count = (niche_variants.end() - niche_variants.start() + 1) as u128;\n+                        let count = (\n+                            niche_variants.end().as_u32() - niche_variants.start().as_u32() + 1\n+                        ) as u128;\n                         for (field_index, &field) in variants[i].iter().enumerate() {\n                             let niche = match self.find_niche(field)? {\n                                 Some(niche) => niche,\n@@ -836,15 +844,15 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             };\n \n                             let mut align = dl.aggregate_align;\n-                            let st = variants.iter().enumerate().map(|(j, v)| {\n+                            let st = variants.iter_enumerated().map(|(j, v)| {\n                                 let mut st = univariant_uninterned(v,\n                                     &def.repr, StructKind::AlwaysSized)?;\n                                 st.variants = Variants::Single { index: j };\n \n                                 align = align.max(st.align);\n \n                                 Ok(st)\n-                            }).collect::<Result<Vec<_>, _>>()?;\n+                            }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                             let offset = st[i].fields.offset(field_index) + niche.offset;\n                             let size = st[i].size;\n@@ -899,7 +907,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let (mut min, mut max) = (i128::max_value(), i128::min_value());\n                 let discr_type = def.repr.discr_type();\n                 let bits = Integer::from_attr(self, discr_type).size().bits();\n-                for (i, discr) in def.discriminants(tcx).enumerate() {\n+                for (i, discr) in def.discriminants(tcx) {\n                     if variants[i].iter().any(|f| f.abi.is_uninhabited()) {\n                         continue;\n                     }\n@@ -941,7 +949,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 // Create the set of structs that represent each variant.\n-                let mut layout_variants = variants.iter().enumerate().map(|(i, field_layouts)| {\n+                let mut layout_variants = variants.iter_enumerated().map(|(i, field_layouts)| {\n                     let mut st = univariant_uninterned(&field_layouts,\n                         &def.repr, StructKind::Prefixed(min_ity.size(), prefix_align))?;\n                     st.variants = Variants::Single { index: i };\n@@ -956,7 +964,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     size = cmp::max(size, st.size);\n                     align = align.max(st.align);\n                     Ok(st)\n-                }).collect::<Result<Vec<_>, _>>()?;\n+                }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                 // Align the maximum variant size to the largest alignment.\n                 size = size.abi_align(align);\n@@ -1259,7 +1267,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 debug!(\"print-type-size `{:#?}` adt general variants def {}\",\n                        layout.ty, adt_def.variants.len());\n                 let variant_infos: Vec<_> =\n-                    adt_def.variants.iter().enumerate().map(|(i, variant_def)| {\n+                    adt_def.variants.iter_enumerated().map(|(i, variant_def)| {\n                         let fields: Vec<_> =\n                             variant_def.fields.iter().map(|f| f.ident.name).collect();\n                         build_variant_info(Some(variant_def.name),\n@@ -1339,7 +1347,8 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n                 }\n \n                 // Get a zero-sized variant or a pointer newtype.\n-                let zero_or_ptr_variant = |i: usize| {\n+                let zero_or_ptr_variant = |i| {\n+                    let i = VariantIdx::new(i);\n                     let fields = def.variants[i].fields.iter().map(|field| {\n                         SizeSkeleton::compute(field.ty(tcx, substs), tcx, param_env)\n                     });\n@@ -1562,7 +1571,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n     where C: LayoutOf<Ty = Ty<'tcx>> + HasTyCtxt<'tcx>,\n           C::TyLayout: MaybeResult<TyLayout<'tcx>>\n {\n-    fn for_variant(this: TyLayout<'tcx>, cx: &C, variant_index: usize) -> TyLayout<'tcx> {\n+    fn for_variant(this: TyLayout<'tcx>, cx: &C, variant_index: VariantIdx) -> TyLayout<'tcx> {\n         let details = match this.variants {\n             Variants::Single { index } if index == variant_index => this.details,\n \n@@ -1882,6 +1891,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for FieldPlacement {\n     }\n }\n \n+impl<'a> HashStable<StableHashingContext<'a>> for VariantIdx {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n+        self.as_u32().hash_stable(hcx, hasher)\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for Abi {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,"}, {"sha": "6d59457cc7430210ddc433414f8f8a968a2ac0f7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -32,6 +32,7 @@ use mir::GeneratorLayout;\n use session::CrateDisambiguator;\n use traits::{self, Reveal};\n use ty;\n+use ty::layout::VariantIdx;\n use ty::subst::{Subst, Substs};\n use ty::util::{IntTypeExt, Discr};\n use ty::walk::TypeWalker;\n@@ -57,7 +58,7 @@ use syntax::symbol::{keywords, Symbol, LocalInternedString, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n use smallvec;\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n \n@@ -1785,7 +1786,7 @@ pub enum VariantDiscr {\n     /// For efficiency reasons, the distance from the\n     /// last `Explicit` discriminant is being stored,\n     /// or `0` for the first variant, if it has none.\n-    Relative(usize),\n+    Relative(u32),\n }\n \n #[derive(Debug)]\n@@ -1801,8 +1802,7 @@ pub struct FieldDef {\n /// table.\n pub struct AdtDef {\n     pub did: DefId,\n-    // TODO: make this an IndexVec\n-    pub variants: Vec<VariantDef>,\n+    pub variants: IndexVec<self::layout::VariantIdx, VariantDef>,\n     flags: AdtFlags,\n     pub repr: ReprOptions,\n }\n@@ -2000,7 +2000,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     fn new(tcx: TyCtxt<'_, '_, '_>,\n            did: DefId,\n            kind: AdtKind,\n-           variants: Vec<VariantDef>,\n+           variants: IndexVec<VariantIdx, VariantDef>,\n            repr: ReprOptions) -> Self {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n@@ -2122,7 +2122,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Asserts this is a struct or union and returns its unique variant.\n     pub fn non_enum_variant(&self) -> &VariantDef {\n         assert!(self.is_struct() || self.is_union());\n-        &self.variants[0]\n+        &self.variants[VariantIdx::new(0)]\n     }\n \n     #[inline]\n@@ -2217,11 +2217,11 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     pub fn discriminants(\n         &'a self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    ) -> impl Iterator<Item=Discr<'tcx>> + Captures<'gcx> + 'a {\n+    ) -> impl Iterator<Item=(VariantIdx, Discr<'tcx>)> + Captures<'gcx> + 'a {\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx.global_tcx());\n         let mut prev_discr = None::<Discr<'tcx>>;\n-        self.variants.iter().map(move |v| {\n+        self.variants.iter_enumerated().map(move |(i, v)| {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n                 if let Some(new_discr) = self.eval_explicit_discr(tcx, expr_did) {\n@@ -2230,7 +2230,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             }\n             prev_discr = Some(discr);\n \n-            discr\n+            (i, discr)\n         })\n     }\n \n@@ -2241,7 +2241,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// assuming there are no constant-evaluation errors there.\n     pub fn discriminant_for_variant(&self,\n                                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                    variant_index: usize)\n+                                    variant_index: VariantIdx)\n                                     -> Discr<'tcx> {\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n         let explicit_value = val\n@@ -2255,12 +2255,12 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// inferred discriminant directly\n     pub fn discriminant_def_for_variant(\n         &self,\n-        variant_index: usize,\n-    ) -> (Option<DefId>, usize) {\n-        let mut explicit_index = variant_index;\n+        variant_index: VariantIdx,\n+    ) -> (Option<DefId>, u32) {\n+        let mut explicit_index = variant_index.as_u32();\n         let expr_did;\n         loop {\n-            match self.variants[explicit_index].discr {\n+            match self.variants[VariantIdx::from_u32(explicit_index)].discr {\n                 ty::VariantDiscr::Relative(0) => {\n                     expr_did = None;\n                     break;\n@@ -2274,7 +2274,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 }\n             }\n         }\n-        (expr_did, variant_index - explicit_index)\n+        (expr_did, variant_index.as_u32() - explicit_index)\n     }\n \n     pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Destructor> {"}, {"sha": "e92f92dce63d06e3bd3df0c6850170110cc2a0cd", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -33,7 +33,7 @@ CloneTypeFoldableAndLiftImpls! {\n     (),\n     bool,\n     usize,\n-    u32,\n+    ::ty::layout::VariantIdx,\n     u64,\n     ::middle::region::Scope,\n     ::syntax::ast::FloatTy,"}, {"sha": "8020893634ca5f0516984e09ba9b834a869bd3e2", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -481,7 +481,7 @@ pub fn const_field<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     instance: ty::Instance<'tcx>,\n-    variant: Option<usize>,\n+    variant: Option<u32>,\n     field: mir::Field,\n     value: &'tcx ty::Const<'tcx>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {"}, {"sha": "dfdd7f0ae58e5e0b810cdfc90ae1244c893d6b44", "filename": "src/librustc_target/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc_target%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc_target%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2FCargo.toml?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -12,4 +12,5 @@ crate-type = [\"dylib\"]\n bitflags = \"1.0\"\n log = \"0.4\"\n rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "01811aced73af8eae3368d4126f516b614f59861", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -16,6 +16,8 @@ use spec::Target;\n use std::{cmp, fmt};\n use std::ops::{Add, Deref, Sub, Mul, AddAssign, Range, RangeInclusive};\n \n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+\n pub mod call;\n \n /// Parsed [Data layout](http://llvm.org/docs/LangRef.html#data-layout)\n@@ -825,19 +827,23 @@ impl Abi {\n     }\n }\n \n+newtype_index! {\n+    pub struct VariantIdx { .. }\n+}\n+\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub enum Variants {\n     /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n     Single {\n-        index: usize\n+        index: VariantIdx,\n     },\n \n     /// General-case enums: for each case there is a struct, and they all have\n     /// all space reserved for the tag, and their first field starts\n     /// at a non-0 offset, after where the tag would go.\n     Tagged {\n         tag: Scalar,\n-        variants: Vec<LayoutDetails>,\n+        variants: IndexVec<VariantIdx, LayoutDetails>,\n     },\n \n     /// Multiple cases distinguished by a niche (values invalid for a type):\n@@ -849,11 +855,11 @@ pub enum Variants {\n     /// `None` has a null pointer for the second tuple field, and\n     /// `Some` is the identity function (with a non-null reference).\n     NicheFilling {\n-        dataful_variant: usize,\n-        niche_variants: RangeInclusive<usize>,\n+        dataful_variant: VariantIdx,\n+        niche_variants: RangeInclusive<VariantIdx>,\n         niche: Scalar,\n         niche_start: u128,\n-        variants: Vec<LayoutDetails>,\n+        variants: IndexVec<VariantIdx, LayoutDetails>,\n     }\n }\n \n@@ -871,7 +877,7 @@ impl LayoutDetails {\n         let size = scalar.value.size(cx);\n         let align = scalar.value.align(cx);\n         LayoutDetails {\n-            variants: Variants::Single { index: 0 },\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldPlacement::Union(0),\n             abi: Abi::Scalar(scalar),\n             size,\n@@ -908,12 +914,12 @@ pub trait LayoutOf {\n }\n \n pub trait TyLayoutMethods<'a, C: LayoutOf<Ty = Self>>: Sized {\n-    fn for_variant(this: TyLayout<'a, Self>, cx: &C, variant_index: usize) -> TyLayout<'a, Self>;\n+    fn for_variant(this: TyLayout<'a, Self>, cx: &C, variant_index: VariantIdx) -> TyLayout<'a, Self>;\n     fn field(this: TyLayout<'a, Self>, cx: &C, i: usize) -> C::TyLayout;\n }\n \n impl<'a, Ty> TyLayout<'a, Ty> {\n-    pub fn for_variant<C>(self, cx: &C, variant_index: usize) -> Self\n+    pub fn for_variant<C>(self, cx: &C, variant_index: VariantIdx) -> Self\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> {\n         Ty::for_variant(self, cx, variant_index)\n     }"}, {"sha": "813b39de064131d6ff16e7ad1db65d4eb1c715b7", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740fb0cbaa0a5fd1770b256edf71d2c4587bff8f/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=740fb0cbaa0a5fd1770b256edf71d2c4587bff8f", "patch": "@@ -23,7 +23,9 @@\n \n #![feature(box_syntax)]\n #![feature(nll)]\n+#![feature(rustc_attrs)]\n #![feature(slice_patterns)]\n+#![feature(step_trait)]\n \n #[macro_use]\n extern crate bitflags;\n@@ -36,5 +38,8 @@ extern crate serialize as rustc_serialize; // used by deriving\n #[allow(unused_extern_crates)]\n extern crate rustc_cratesio_shim;\n \n+#[macro_use]\n+extern crate rustc_data_structures;\n+\n pub mod abi;\n pub mod spec;"}]}