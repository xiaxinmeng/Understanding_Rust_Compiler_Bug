{"sha": "0df3b41630119f3b2dc3db27bf5ace942f210871", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZjNiNDE2MzAxMTlmM2IyZGMzZGIyN2JmNWFjZTk0MmYyMTA4NzE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-26T18:53:04Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-26T18:53:04Z"}, "message": "Skip ZST arguments\n\nFixes #413 and increases compatibility with cg_llvm", "tree": {"sha": "c42fda678a4649a0b24f130c2c172a18ad5ec9c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c42fda678a4649a0b24f130c2c172a18ad5ec9c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0df3b41630119f3b2dc3db27bf5ace942f210871", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0df3b41630119f3b2dc3db27bf5ace942f210871", "html_url": "https://github.com/rust-lang/rust/commit/0df3b41630119f3b2dc3db27bf5ace942f210871", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0df3b41630119f3b2dc3db27bf5ace942f210871/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47b1ef24e48bd3c250d14c756eb5e9de6c1ece20", "url": "https://api.github.com/repos/rust-lang/rust/commits/47b1ef24e48bd3c250d14c756eb5e9de6c1ece20", "html_url": "https://github.com/rust-lang/rust/commit/47b1ef24e48bd3c250d14c756eb5e9de6c1ece20"}], "stats": {"total": 145, "additions": 49, "deletions": 96}, "files": [{"sha": "e69c509b763756c11e3dc22417d4370187087e85", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0df3b41630119f3b2dc3db27bf5ace942f210871/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0df3b41630119f3b2dc3db27bf5ace942f210871/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=0df3b41630119f3b2dc3db27bf5ace942f210871", "patch": "@@ -206,4 +206,6 @@ fn main() {\n     }\n \n     unsafe { assert_eq!(ABC as usize, 0); }\n+\n+    &mut (|| Some(0 as *const ())) as &mut FnMut() -> Option<*const ()>;\n }"}, {"sha": "79bdfcc12406fbe7da00ff39a790f2c8d77efbfd", "filename": "src/abi.rs", "status": "modified", "additions": 45, "deletions": 93, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/0df3b41630119f3b2dc3db27bf5ace942f210871/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0df3b41630119f3b2dc3db27bf5ace942f210871/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=0df3b41630119f3b2dc3db27bf5ace942f210871", "patch": "@@ -1,7 +1,5 @@\n use std::borrow::Cow;\n-use std::iter;\n \n-use rustc::hir;\n use rustc::ty::layout::{FloatTy, Integer, Primitive, Scalar};\n use rustc_target::spec::abi::Abi;\n \n@@ -44,26 +42,16 @@ pub fn scalar_to_clif_type(tcx: TyCtxt, scalar: Scalar) -> Type {\n fn get_pass_mode<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>,\n-    is_return: bool,\n ) -> PassMode {\n     let layout = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n     assert!(!layout.is_unsized());\n \n-    if layout.size.bytes() == 0 {\n-        if is_return {\n-            PassMode::NoPass\n-        } else {\n-            PassMode::ByRef\n-        }\n+    if layout.is_zst() {\n+        // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n+        PassMode::NoPass\n     } else {\n         match &layout.abi {\n-            layout::Abi::Uninhabited => {\n-                if is_return {\n-                    PassMode::NoPass\n-                } else {\n-                    PassMode::ByRef\n-                }\n-            }\n+            layout::Abi::Uninhabited => PassMode::NoPass,\n             layout::Abi::Scalar(scalar) => {\n                 PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone()))\n             }\n@@ -80,11 +68,11 @@ fn get_pass_mode<'a, 'tcx: 'a>(\n fn adjust_arg_for_abi<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     arg: CValue<'tcx>,\n-) -> Value {\n-    match get_pass_mode(fx.tcx, arg.layout().ty, false) {\n-        PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n-        PassMode::ByVal(_) => arg.load_scalar(fx),\n-        PassMode::ByRef => arg.force_stack(fx),\n+) -> Option<Value> {\n+    match get_pass_mode(fx.tcx, arg.layout().ty) {\n+        PassMode::NoPass => None,\n+        PassMode::ByVal(_) => Some(arg.load_scalar(fx)),\n+        PassMode::ByRef => Some(arg.force_stack(fx)),\n     }\n }\n \n@@ -109,13 +97,13 @@ fn clif_sig_from_fn_sig<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sig: FnSig<'t\n \n     let inputs = inputs\n         .into_iter()\n-        .filter_map(|ty| match get_pass_mode(tcx, ty, false) {\n+        .filter_map(|ty| match get_pass_mode(tcx, ty) {\n+            PassMode::NoPass => None,\n             PassMode::ByVal(clif_ty) => Some(clif_ty),\n-            PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n             PassMode::ByRef => Some(pointer_ty(tcx)),\n         });\n \n-    let (params, returns) = match get_pass_mode(tcx, output, true) {\n+    let (params, returns) = match get_pass_mode(tcx, output) {\n         PassMode::NoPass => (inputs.map(AbiParam::new).collect(), vec![]),\n         PassMode::ByVal(ret_ty) => (\n             inputs.map(AbiParam::new).collect(),\n@@ -140,59 +128,13 @@ fn clif_sig_from_fn_sig<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sig: FnSig<'t\n     }\n }\n \n-pub fn ty_fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> ty::FnSig<'tcx> {\n-    let sig = match ty.sty {\n-        ty::FnDef(..) |\n-        // Shims currently have type TyFnPtr. Not sure this should remain.\n-        ty::FnPtr(_) => ty.fn_sig(tcx),\n-        ty::Closure(def_id, substs) => {\n-            let sig = substs.closure_sig(def_id, tcx);\n-\n-            let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-            sig.map_bound(|sig| tcx.mk_fn_sig(\n-                iter::once(*env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n-                sig.output(),\n-                sig.c_variadic,\n-                sig.unsafety,\n-                sig.abi\n-            ))\n-        }\n-        ty::Generator(def_id, substs, _) => {\n-            let sig = substs.poly_sig(def_id, tcx);\n-\n-            let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n-            let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n-\n-            sig.map_bound(|sig| {\n-                let state_did = tcx.lang_items().gen_state().unwrap();\n-                let state_adt_ref = tcx.adt_def(state_did);\n-                let state_substs = tcx.intern_substs(&[\n-                    sig.yield_ty.into(),\n-                    sig.return_ty.into(),\n-                ]);\n-                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n-\n-                tcx.mk_fn_sig(iter::once(env_ty),\n-                    ret_ty,\n-                    false,\n-                    hir::Unsafety::Normal,\n-                    Abi::Rust\n-                )\n-            })\n-        }\n-        _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)\n-    };\n-    tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &sig)\n-}\n-\n pub fn get_function_name_and_sig<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     inst: Instance<'tcx>,\n     support_vararg: bool,\n ) -> (String, Signature) {\n     assert!(!inst.substs.needs_infer() && !inst.substs.has_param_types());\n-    let fn_ty = inst.ty(tcx);\n-    let fn_sig = ty_fn_sig(tcx, fn_ty);\n+    let fn_sig = tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &inst.fn_sig(tcx));\n     if fn_sig.c_variadic && !support_vararg {\n         unimpl!(\"Variadic function definitions are not yet supported\");\n     }\n@@ -293,7 +235,7 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n     }\n \n     fn self_sig(&self) -> FnSig<'tcx> {\n-        ty_fn_sig(self.tcx, self.instance.ty(self.tcx))\n+        self.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &self.instance.fn_sig(self.tcx))\n     }\n \n     fn return_type(&self) -> Ty<'tcx> {\n@@ -405,9 +347,14 @@ fn cvalue_for_param<'a, 'tcx: 'a>(\n     local_field: Option<usize>,\n     arg_ty: Ty<'tcx>,\n     ssa_flags: crate::analyze::Flags,\n-) -> CValue<'tcx> {\n+) -> Option<CValue<'tcx>> {\n     let layout = fx.layout_of(arg_ty);\n-    let pass_mode = get_pass_mode(fx.tcx, arg_ty, false);\n+    let pass_mode = get_pass_mode(fx.tcx, arg_ty);\n+\n+    if let PassMode::NoPass = pass_mode {\n+        return None;\n+    }\n+\n     let clif_type = pass_mode.get_param_ty(fx);\n     let ebb_param = fx.bcx.append_ebb_param(start_ebb, clif_type);\n \n@@ -424,9 +371,9 @@ fn cvalue_for_param<'a, 'tcx: 'a>(\n     );\n \n     match pass_mode {\n-        PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n-        PassMode::ByVal(_) => CValue::ByVal(ebb_param, layout),\n-        PassMode::ByRef => CValue::ByRef(ebb_param, layout),\n+        PassMode::NoPass => unreachable!(),\n+        PassMode::ByVal(_) => Some(CValue::ByVal(ebb_param, layout)),\n+        PassMode::ByRef => Some(CValue::ByRef(ebb_param, layout)),\n     }\n }\n \n@@ -440,7 +387,7 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n     fx.add_global_comment(format!(\"ssa {:?}\", ssa_analyzed));\n \n     let ret_layout = fx.layout_of(fx.return_type());\n-    let output_pass_mode = get_pass_mode(fx.tcx, fx.return_type(), true);\n+    let output_pass_mode = get_pass_mode(fx.tcx, fx.return_type());\n     let ret_param = match output_pass_mode {\n         PassMode::NoPass => None,\n         PassMode::ByVal(_) => None,\n@@ -462,9 +409,10 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n         );\n     }\n \n+    // None means pass_mode == NoPass\n     enum ArgKind<'tcx> {\n-        Normal(CValue<'tcx>),\n-        Spread(Vec<CValue<'tcx>>),\n+        Normal(Option<CValue<'tcx>>),\n+        Spread(Vec<Option<CValue<'tcx>>>),\n     }\n \n     let func_params = fx\n@@ -542,13 +490,17 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n \n         match arg_kind {\n             ArgKind::Normal(param) => {\n-                place.write_cvalue(fx, param);\n+                if let Some(param) = param {\n+                    place.write_cvalue(fx, param);\n+                }\n             }\n             ArgKind::Spread(params) => {\n                 for (i, param) in params.into_iter().enumerate() {\n-                    place\n-                        .place_field(fx, mir::Field::new(i))\n-                        .write_cvalue(fx, param);\n+                    if let Some(param) = param {\n+                        place\n+                            .place_field(fx, mir::Field::new(i))\n+                            .write_cvalue(fx, param);\n+                    }\n                 }\n             }\n         }\n@@ -578,7 +530,7 @@ pub fn codegen_terminator_call<'a, 'tcx: 'a>(\n     destination: &Option<(Place<'tcx>, BasicBlock)>,\n ) {\n     let fn_ty = fx.monomorphize(&func.ty(fx.mir, fx.tcx));\n-    let sig = ty_fn_sig(fx.tcx, fn_ty);\n+    let sig = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n \n     // Unpack arguments tuple for closures\n     let args = if sig.abi == Abi::RustCall {\n@@ -649,11 +601,11 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n     args: Vec<CValue<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n ) {\n-    let fn_sig = ty_fn_sig(fx.tcx, fn_ty);\n+    let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n \n     let ret_layout = fx.layout_of(fn_sig.output());\n \n-    let output_pass_mode = get_pass_mode(fx.tcx, fn_sig.output(), true);\n+    let output_pass_mode = get_pass_mode(fx.tcx, fn_sig.output());\n     let return_ptr = match output_pass_mode {\n         PassMode::NoPass => None,\n         PassMode::ByRef => match ret_place {\n@@ -683,15 +635,15 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n         }\n \n         // Normal call\n-        Some(_) => (None, args.get(0).map(|arg| adjust_arg_for_abi(fx, *arg))),\n+        Some(_) => (None, args.get(0).and_then(|arg| adjust_arg_for_abi(fx, *arg))),\n \n         // Indirect call\n         None => {\n             let func = trans_operand(fx, func.expect(\"indirect call without func Operand\"))\n                 .load_scalar(fx);\n             (\n                 Some(func),\n-                args.get(0).map(|arg| adjust_arg_for_abi(fx, *arg)),\n+                args.get(0).and_then(|arg| adjust_arg_for_abi(fx, *arg)),\n             )\n         }\n     };\n@@ -702,7 +654,7 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n         .chain(\n             args.into_iter()\n                 .skip(1)\n-                .map(|arg| adjust_arg_for_abi(fx, arg)),\n+                .filter_map(|arg| adjust_arg_for_abi(fx, arg)),\n         )\n         .collect::<Vec<_>>();\n \n@@ -756,9 +708,9 @@ pub fn codegen_drop<'a, 'tcx: 'a>(\n     let (ptr, vtable) = drop_place.to_addr_maybe_unsized(fx);\n     let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n \n-    let fn_sig = ty_fn_sig(fx.tcx, drop_fn_ty);\n+    let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &drop_fn_ty.fn_sig(fx.tcx));\n \n-    match get_pass_mode(fx.tcx, fn_sig.output(), true) {\n+    match get_pass_mode(fx.tcx, fn_sig.output()) {\n         PassMode::NoPass => {}\n         _ => unreachable!(),\n     };\n@@ -770,7 +722,7 @@ pub fn codegen_drop<'a, 'tcx: 'a>(\n }\n \n pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n-    match get_pass_mode(fx.tcx, fx.return_type(), true) {\n+    match get_pass_mode(fx.tcx, fx.return_type()) {\n         PassMode::NoPass | PassMode::ByRef => {\n             fx.bcx.ins().return_(&[]);\n         }"}, {"sha": "ec057dd81d4767b00f372ec5ebef9d18e256d678", "filename": "src/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0df3b41630119f3b2dc3db27bf5ace942f210871/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0df3b41630119f3b2dc3db27bf5ace942f210871/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=0df3b41630119f3b2dc3db27bf5ace942f210871", "patch": "@@ -69,8 +69,7 @@ fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n         // FIXME implement u128 and i128 support\n \n         // Step 2a. Check sig for u128 and i128\n-        let fn_ty = instance.ty(tcx);\n-        let fn_sig = crate::abi::ty_fn_sig(tcx, fn_ty);\n+        let fn_sig = tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &instance.fn_sig(tcx));\n \n         struct UI128Visitor<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx, 'tcx>, bool);\n "}, {"sha": "ee16c68214b705e0a91ce318fdc13167c34f96f9", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0df3b41630119f3b2dc3db27bf5ace942f210871/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0df3b41630119f3b2dc3db27bf5ace942f210871/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=0df3b41630119f3b2dc3db27bf5ace942f210871", "patch": "@@ -75,7 +75,7 @@ impl CommentWriter {\n             global_comments: vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).as_str()),\n                 format!(\"instance {:?}\", instance),\n-                format!(\"sig {:?}\", crate::abi::ty_fn_sig(tcx, instance.ty(tcx))),\n+                format!(\"sig {:?}\", tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &instance.fn_sig(tcx))),\n                 String::new(),\n             ],\n             entity_comments: HashMap::new(),"}]}